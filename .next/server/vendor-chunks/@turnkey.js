"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@turnkey";
exports.ids = ["vendor-chunks/@turnkey"];
exports.modules = {

/***/ "(ssr)/./node_modules/@turnkey/solana/node_modules/@noble/hashes/_assert.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@turnkey/solana/node_modules/@noble/hashes/_assert.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = exports.isBytes = void 0;\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`positive integer expected, not ${n}`);\n}\nexports.number = number;\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`boolean expected, not ${b}`);\n}\nexports.bool = bool;\n// copied from utils\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\nexports.isBytes = isBytes;\nfunction bytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);\n}\nexports.bytes = bytes;\nfunction hash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(h.outputLen);\n    number(h.blockLen);\n}\nexports.hash = hash;\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nexports.exists = exists;\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\nexports.output = output;\nconst assert = { number, bool, bytes, hash, exists, output };\nexports[\"default\"] = assert;\n//# sourceMappingURL=_assert.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvc29sYW5hL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL19hc3NlcnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYyxHQUFHLGNBQWMsR0FBRyxZQUFZLEdBQUcsYUFBYSxHQUFHLFlBQVksR0FBRyxjQUFjLEdBQUcsZUFBZTtBQUNoSDtBQUNBO0FBQ0EsMERBQTBELEVBQUU7QUFDNUQ7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGlEQUFpRCxFQUFFO0FBQ25EO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsUUFBUSxrQkFBa0IsU0FBUztBQUM1RjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLElBQUk7QUFDckY7QUFDQTtBQUNBLGNBQWM7QUFDZCxpQkFBaUI7QUFDakIsa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL251cnNlYmxvYy8uL25vZGVfbW9kdWxlcy9AdHVybmtleS9zb2xhbmEvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvX2Fzc2VydC5qcz82MjI5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5vdXRwdXQgPSBleHBvcnRzLmV4aXN0cyA9IGV4cG9ydHMuaGFzaCA9IGV4cG9ydHMuYnl0ZXMgPSBleHBvcnRzLmJvb2wgPSBleHBvcnRzLm51bWJlciA9IGV4cG9ydHMuaXNCeXRlcyA9IHZvaWQgMDtcbmZ1bmN0aW9uIG51bWJlcihuKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSB8fCBuIDwgMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwb3NpdGl2ZSBpbnRlZ2VyIGV4cGVjdGVkLCBub3QgJHtufWApO1xufVxuZXhwb3J0cy5udW1iZXIgPSBudW1iZXI7XG5mdW5jdGlvbiBib29sKGIpIHtcbiAgICBpZiAodHlwZW9mIGIgIT09ICdib29sZWFuJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBib29sZWFuIGV4cGVjdGVkLCBub3QgJHtifWApO1xufVxuZXhwb3J0cy5ib29sID0gYm9vbDtcbi8vIGNvcGllZCBmcm9tIHV0aWxzXG5mdW5jdGlvbiBpc0J5dGVzKGEpIHtcbiAgICByZXR1cm4gKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8XG4gICAgICAgIChhICE9IG51bGwgJiYgdHlwZW9mIGEgPT09ICdvYmplY3QnICYmIGEuY29uc3RydWN0b3IubmFtZSA9PT0gJ1VpbnQ4QXJyYXknKSk7XG59XG5leHBvcnRzLmlzQnl0ZXMgPSBpc0J5dGVzO1xuZnVuY3Rpb24gYnl0ZXMoYiwgLi4ubGVuZ3Rocykge1xuICAgIGlmICghaXNCeXRlcyhiKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgaWYgKGxlbmd0aHMubGVuZ3RoID4gMCAmJiAhbGVuZ3Rocy5pbmNsdWRlcyhiLmxlbmd0aCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVWludDhBcnJheSBleHBlY3RlZCBvZiBsZW5ndGggJHtsZW5ndGhzfSwgbm90IG9mIGxlbmd0aD0ke2IubGVuZ3RofWApO1xufVxuZXhwb3J0cy5ieXRlcyA9IGJ5dGVzO1xuZnVuY3Rpb24gaGFzaChoKSB7XG4gICAgaWYgKHR5cGVvZiBoICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBoLmNyZWF0ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIHNob3VsZCBiZSB3cmFwcGVkIGJ5IHV0aWxzLndyYXBDb25zdHJ1Y3RvcicpO1xuICAgIG51bWJlcihoLm91dHB1dExlbik7XG4gICAgbnVtYmVyKGguYmxvY2tMZW4pO1xufVxuZXhwb3J0cy5oYXNoID0gaGFzaDtcbmZ1bmN0aW9uIGV4aXN0cyhpbnN0YW5jZSwgY2hlY2tGaW5pc2hlZCA9IHRydWUpIHtcbiAgICBpZiAoaW5zdGFuY2UuZGVzdHJveWVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkJyk7XG4gICAgaWYgKGNoZWNrRmluaXNoZWQgJiYgaW5zdGFuY2UuZmluaXNoZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCNkaWdlc3QoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZCcpO1xufVxuZXhwb3J0cy5leGlzdHMgPSBleGlzdHM7XG5mdW5jdGlvbiBvdXRwdXQob3V0LCBpbnN0YW5jZSkge1xuICAgIGJ5dGVzKG91dCk7XG4gICAgY29uc3QgbWluID0gaW5zdGFuY2Uub3V0cHV0TGVuO1xuICAgIGlmIChvdXQubGVuZ3RoIDwgbWluKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZGlnZXN0SW50bygpIGV4cGVjdHMgb3V0cHV0IGJ1ZmZlciBvZiBsZW5ndGggYXQgbGVhc3QgJHttaW59YCk7XG4gICAgfVxufVxuZXhwb3J0cy5vdXRwdXQgPSBvdXRwdXQ7XG5jb25zdCBhc3NlcnQgPSB7IG51bWJlciwgYm9vbCwgYnl0ZXMsIGhhc2gsIGV4aXN0cywgb3V0cHV0IH07XG5leHBvcnRzLmRlZmF1bHQgPSBhc3NlcnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fYXNzZXJ0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/solana/node_modules/@noble/hashes/_assert.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/solana/node_modules/@noble/hashes/_md.js":
/*!************************************************************************!*\
  !*** ./node_modules/@turnkey/solana/node_modules/@noble/hashes/_md.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.HashMD = exports.Maj = exports.Chi = void 0;\nconst _assert_js_1 = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./node_modules/@turnkey/solana/node_modules/@noble/hashes/_assert.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@turnkey/solana/node_modules/@noble/hashes/utils.js\");\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Choice: a ? b : c\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\nexports.Chi = Chi;\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\nexports.Maj = Maj;\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nclass HashMD extends utils_js_1.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0, utils_js_1.createView)(this.buffer);\n    }\n    update(data) {\n        (0, _assert_js_1.exists)(this);\n        const { view, buffer, blockLen } = this;\n        data = (0, utils_js_1.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0, utils_js_1.createView)(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0, _assert_js_1.exists)(this);\n        (0, _assert_js_1.output)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0, utils_js_1.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\nexports.HashMD = HashMD;\n//# sourceMappingURL=_md.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvc29sYW5hL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL19tZC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjLEdBQUcsV0FBVyxHQUFHLFdBQVc7QUFDMUMscUJBQXFCLG1CQUFPLENBQUMsZ0dBQWM7QUFDM0MsbUJBQW1CLG1CQUFPLENBQUMsNEZBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5QkFBeUI7QUFDekM7QUFDQTtBQUNBLDBCQUEwQixVQUFVO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQkFBK0I7QUFDL0MsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGNBQWM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFEQUFxRDtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9udXJzZWJsb2MvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvc29sYW5hL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL19tZC5qcz9hMjVjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5IYXNoTUQgPSBleHBvcnRzLk1haiA9IGV4cG9ydHMuQ2hpID0gdm9pZCAwO1xuY29uc3QgX2Fzc2VydF9qc18xID0gcmVxdWlyZShcIi4vX2Fzc2VydC5qc1wiKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbi8vIFBvbHlmaWxsIGZvciBTYWZhcmkgMTRcbmZ1bmN0aW9uIHNldEJpZ1VpbnQ2NCh2aWV3LCBieXRlT2Zmc2V0LCB2YWx1ZSwgaXNMRSkge1xuICAgIGlmICh0eXBlb2Ygdmlldy5zZXRCaWdVaW50NjQgPT09ICdmdW5jdGlvbicpXG4gICAgICAgIHJldHVybiB2aWV3LnNldEJpZ1VpbnQ2NChieXRlT2Zmc2V0LCB2YWx1ZSwgaXNMRSk7XG4gICAgY29uc3QgXzMybiA9IEJpZ0ludCgzMik7XG4gICAgY29uc3QgX3UzMl9tYXggPSBCaWdJbnQoMHhmZmZmZmZmZik7XG4gICAgY29uc3Qgd2ggPSBOdW1iZXIoKHZhbHVlID4+IF8zMm4pICYgX3UzMl9tYXgpO1xuICAgIGNvbnN0IHdsID0gTnVtYmVyKHZhbHVlICYgX3UzMl9tYXgpO1xuICAgIGNvbnN0IGggPSBpc0xFID8gNCA6IDA7XG4gICAgY29uc3QgbCA9IGlzTEUgPyAwIDogNDtcbiAgICB2aWV3LnNldFVpbnQzMihieXRlT2Zmc2V0ICsgaCwgd2gsIGlzTEUpO1xuICAgIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBsLCB3bCwgaXNMRSk7XG59XG4vLyBDaG9pY2U6IGEgPyBiIDogY1xuY29uc3QgQ2hpID0gKGEsIGIsIGMpID0+IChhICYgYikgXiAofmEgJiBjKTtcbmV4cG9ydHMuQ2hpID0gQ2hpO1xuLy8gTWFqb3JpdHkgZnVuY3Rpb24sIHRydWUgaWYgYW55IHR3byBpbnB1c3QgaXMgdHJ1ZVxuY29uc3QgTWFqID0gKGEsIGIsIGMpID0+IChhICYgYikgXiAoYSAmIGMpIF4gKGIgJiBjKTtcbmV4cG9ydHMuTWFqID0gTWFqO1xuLyoqXG4gKiBNZXJrbGUtRGFtZ2FyZCBoYXNoIGNvbnN0cnVjdGlvbiBiYXNlIGNsYXNzLlxuICogQ291bGQgYmUgdXNlZCB0byBjcmVhdGUgTUQ1LCBSSVBFTUQsIFNIQTEsIFNIQTIuXG4gKi9cbmNsYXNzIEhhc2hNRCBleHRlbmRzIHV0aWxzX2pzXzEuSGFzaCB7XG4gICAgY29uc3RydWN0b3IoYmxvY2tMZW4sIG91dHB1dExlbiwgcGFkT2Zmc2V0LCBpc0xFKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRoaXMucGFkT2Zmc2V0ID0gcGFkT2Zmc2V0O1xuICAgICAgICB0aGlzLmlzTEUgPSBpc0xFO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGJsb2NrTGVuKTtcbiAgICAgICAgdGhpcy52aWV3ID0gKDAsIHV0aWxzX2pzXzEuY3JlYXRlVmlldykodGhpcy5idWZmZXIpO1xuICAgIH1cbiAgICB1cGRhdGUoZGF0YSkge1xuICAgICAgICAoMCwgX2Fzc2VydF9qc18xLmV4aXN0cykodGhpcyk7XG4gICAgICAgIGNvbnN0IHsgdmlldywgYnVmZmVyLCBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgICAgZGF0YSA9ICgwLCB1dGlsc19qc18xLnRvQnl0ZXMpKGRhdGEpO1xuICAgICAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3MsIGxlbiAtIHBvcyk7XG4gICAgICAgICAgICAvLyBGYXN0IHBhdGg6IHdlIGhhdmUgYXQgbGVhc3Qgb25lIGJsb2NrIGluIGlucHV0LCBjYXN0IGl0IHRvIHZpZXcgYW5kIHByb2Nlc3NcbiAgICAgICAgICAgIGlmICh0YWtlID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFWaWV3ID0gKDAsIHV0aWxzX2pzXzEuY3JlYXRlVmlldykoZGF0YSk7XG4gICAgICAgICAgICAgICAgZm9yICg7IGJsb2NrTGVuIDw9IGxlbiAtIHBvczsgcG9zICs9IGJsb2NrTGVuKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3MoZGF0YVZpZXcsIHBvcyk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXIuc2V0KGRhdGEuc3ViYXJyYXkocG9zLCBwb3MgKyB0YWtlKSwgdGhpcy5wb3MpO1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gdGFrZTtcbiAgICAgICAgICAgIHBvcyArPSB0YWtlO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZW5ndGggKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgIHRoaXMucm91bmRDbGVhbigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5leGlzdHMpKHRoaXMpO1xuICAgICAgICAoMCwgX2Fzc2VydF9qc18xLm91dHB1dCkob3V0LCB0aGlzKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIC8vIFBhZGRpbmdcbiAgICAgICAgLy8gV2UgY2FuIGF2b2lkIGFsbG9jYXRpb24gb2YgYnVmZmVyIGZvciBwYWRkaW5nIGNvbXBsZXRlbHkgaWYgaXRcbiAgICAgICAgLy8gd2FzIHByZXZpb3VzbHkgbm90IGFsbG9jYXRlZCBoZXJlLiBCdXQgaXQgd29uJ3QgY2hhbmdlIHBlcmZvcm1hbmNlLlxuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgdmlldywgYmxvY2tMZW4sIGlzTEUgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IHBvcyB9ID0gdGhpcztcbiAgICAgICAgLy8gYXBwZW5kIHRoZSBiaXQgJzEnIHRvIHRoZSBtZXNzYWdlXG4gICAgICAgIGJ1ZmZlcltwb3MrK10gPSAwYjEwMDAwMDAwO1xuICAgICAgICB0aGlzLmJ1ZmZlci5zdWJhcnJheShwb3MpLmZpbGwoMCk7XG4gICAgICAgIC8vIHdlIGhhdmUgbGVzcyB0aGFuIHBhZE9mZnNldCBsZWZ0IGluIGJ1ZmZlciwgc28gd2UgY2Fubm90IHB1dCBsZW5ndGggaW5cbiAgICAgICAgLy8gY3VycmVudCBibG9jaywgbmVlZCBwcm9jZXNzIGl0IGFuZCBwYWQgYWdhaW5cbiAgICAgICAgaWYgKHRoaXMucGFkT2Zmc2V0ID4gYmxvY2tMZW4gLSBwb3MpIHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgICAgIHBvcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUGFkIHVudGlsIGZ1bGwgYmxvY2sgYnl0ZSB3aXRoIHplcm9zXG4gICAgICAgIGZvciAobGV0IGkgPSBwb3M7IGkgPCBibG9ja0xlbjsgaSsrKVxuICAgICAgICAgICAgYnVmZmVyW2ldID0gMDtcbiAgICAgICAgLy8gTm90ZTogc2hhNTEyIHJlcXVpcmVzIGxlbmd0aCB0byBiZSAxMjhiaXQgaW50ZWdlciwgYnV0IGxlbmd0aCBpbiBKUyB3aWxsIG92ZXJmbG93IGJlZm9yZSB0aGF0XG4gICAgICAgIC8vIFlvdSBuZWVkIHRvIHdyaXRlIGFyb3VuZCAyIGV4YWJ5dGVzICh1NjRfbWF4IC8gOCAvICgxMDI0Kio2KSkgZm9yIHRoaXMgdG8gaGFwcGVuLlxuICAgICAgICAvLyBTbyB3ZSBqdXN0IHdyaXRlIGxvd2VzdCA2NCBiaXRzIG9mIHRoYXQgdmFsdWUuXG4gICAgICAgIHNldEJpZ1VpbnQ2NCh2aWV3LCBibG9ja0xlbiAtIDgsIEJpZ0ludCh0aGlzLmxlbmd0aCAqIDgpLCBpc0xFKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICBjb25zdCBvdmlldyA9ICgwLCB1dGlsc19qc18xLmNyZWF0ZVZpZXcpKG91dCk7XG4gICAgICAgIGNvbnN0IGxlbiA9IHRoaXMub3V0cHV0TGVuO1xuICAgICAgICAvLyBOT1RFOiB3ZSBkbyBkaXZpc2lvbiBieSA0IGxhdGVyLCB3aGljaCBzaG91bGQgYmUgZnVzZWQgaW4gc2luZ2xlIG9wIHdpdGggbW9kdWxvIGJ5IEpJVFxuICAgICAgICBpZiAobGVuICUgNClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX3NoYTI6IG91dHB1dExlbiBzaG91bGQgYmUgYWxpZ25lZCB0byAzMmJpdCcpO1xuICAgICAgICBjb25zdCBvdXRMZW4gPSBsZW4gLyA0O1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0KCk7XG4gICAgICAgIGlmIChvdXRMZW4gPiBzdGF0ZS5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ19zaGEyOiBvdXRwdXRMZW4gYmlnZ2VyIHRoYW4gc3RhdGUnKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRMZW47IGkrKylcbiAgICAgICAgICAgIG92aWV3LnNldFVpbnQzMig0ICogaSwgc3RhdGVbaV0sIGlzTEUpO1xuICAgIH1cbiAgICBkaWdlc3QoKSB7XG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCBvdXRwdXRMZW4gfSA9IHRoaXM7XG4gICAgICAgIHRoaXMuZGlnZXN0SW50byhidWZmZXIpO1xuICAgICAgICBjb25zdCByZXMgPSBidWZmZXIuc2xpY2UoMCwgb3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIF9jbG9uZUludG8odG8pIHtcbiAgICAgICAgdG8gfHwgKHRvID0gbmV3IHRoaXMuY29uc3RydWN0b3IoKSk7XG4gICAgICAgIHRvLnNldCguLi50aGlzLmdldCgpKTtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiwgYnVmZmVyLCBsZW5ndGgsIGZpbmlzaGVkLCBkZXN0cm95ZWQsIHBvcyB9ID0gdGhpcztcbiAgICAgICAgdG8ubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0by5wb3MgPSBwb3M7XG4gICAgICAgIHRvLmZpbmlzaGVkID0gZmluaXNoZWQ7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IGRlc3Ryb3llZDtcbiAgICAgICAgaWYgKGxlbmd0aCAlIGJsb2NrTGVuKVxuICAgICAgICAgICAgdG8uYnVmZmVyLnNldChidWZmZXIpO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxufVxuZXhwb3J0cy5IYXNoTUQgPSBIYXNoTUQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fbWQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/solana/node_modules/@noble/hashes/_md.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/solana/node_modules/@noble/hashes/_u64.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@turnkey/solana/node_modules/@noble/hashes/_u64.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.add5L = exports.add5H = exports.add4H = exports.add4L = exports.add3H = exports.add3L = exports.add = exports.rotlBL = exports.rotlBH = exports.rotlSL = exports.rotlSH = exports.rotr32L = exports.rotr32H = exports.rotrBL = exports.rotrBH = exports.rotrSL = exports.rotrSH = exports.shrSL = exports.shrSH = exports.toBig = exports.split = exports.fromBig = void 0;\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nexports.fromBig = fromBig;\nfunction split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for (let i = 0; i < lst.length; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nexports.split = split;\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\nexports.toBig = toBig;\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nexports.shrSH = shrSH;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\nexports.shrSL = shrSL;\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nexports.rotrSH = rotrSH;\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\nexports.rotrSL = rotrSL;\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nexports.rotrBH = rotrBH;\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\nexports.rotrBL = rotrBL;\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nexports.rotr32H = rotr32H;\nconst rotr32L = (h, _l) => h;\nexports.rotr32L = rotr32L;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nexports.rotlSH = rotlSH;\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\nexports.rotlSL = rotlSL;\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nexports.rotlBH = rotlBH;\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\nexports.rotlBL = rotlBL;\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\nexports.add = add;\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nexports.add3L = add3L;\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nexports.add3H = add3H;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nexports.add4L = add4L;\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nexports.add4H = add4H;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nexports.add5L = add5L;\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\nexports.add5H = add5H;\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexports[\"default\"] = u64;\n//# sourceMappingURL=_u64.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvc29sYW5hL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL191NjQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxHQUFHLGFBQWEsR0FBRyxhQUFhLEdBQUcsYUFBYSxHQUFHLGFBQWEsR0FBRyxhQUFhLEdBQUcsV0FBVyxHQUFHLGNBQWMsR0FBRyxjQUFjLEdBQUcsY0FBYyxHQUFHLGNBQWMsR0FBRyxlQUFlLEdBQUcsZUFBZSxHQUFHLGNBQWMsR0FBRyxjQUFjLEdBQUcsY0FBYyxHQUFHLGNBQWMsR0FBRyxhQUFhLEdBQUcsYUFBYSxHQUFHLGFBQWEsR0FBRyxhQUFhLEdBQUcsZUFBZTtBQUN6VztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL251cnNlYmxvYy8uL25vZGVfbW9kdWxlcy9AdHVybmtleS9zb2xhbmEvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvX3U2NC5qcz8xMWM2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hZGQ1TCA9IGV4cG9ydHMuYWRkNUggPSBleHBvcnRzLmFkZDRIID0gZXhwb3J0cy5hZGQ0TCA9IGV4cG9ydHMuYWRkM0ggPSBleHBvcnRzLmFkZDNMID0gZXhwb3J0cy5hZGQgPSBleHBvcnRzLnJvdGxCTCA9IGV4cG9ydHMucm90bEJIID0gZXhwb3J0cy5yb3RsU0wgPSBleHBvcnRzLnJvdGxTSCA9IGV4cG9ydHMucm90cjMyTCA9IGV4cG9ydHMucm90cjMySCA9IGV4cG9ydHMucm90ckJMID0gZXhwb3J0cy5yb3RyQkggPSBleHBvcnRzLnJvdHJTTCA9IGV4cG9ydHMucm90clNIID0gZXhwb3J0cy5zaHJTTCA9IGV4cG9ydHMuc2hyU0ggPSBleHBvcnRzLnRvQmlnID0gZXhwb3J0cy5zcGxpdCA9IGV4cG9ydHMuZnJvbUJpZyA9IHZvaWQgMDtcbmNvbnN0IFUzMl9NQVNLNjQgPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDIgKiogMzIgLSAxKTtcbmNvbnN0IF8zMm4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDMyKTtcbi8vIFdlIGFyZSBub3QgdXNpbmcgQmlnVWludDY0QXJyYXksIGJlY2F1c2UgdGhleSBhcmUgZXh0cmVtZWx5IHNsb3cgYXMgcGVyIDIwMjJcbmZ1bmN0aW9uIGZyb21CaWcobiwgbGUgPSBmYWxzZSkge1xuICAgIGlmIChsZSlcbiAgICAgICAgcmV0dXJuIHsgaDogTnVtYmVyKG4gJiBVMzJfTUFTSzY0KSwgbDogTnVtYmVyKChuID4+IF8zMm4pICYgVTMyX01BU0s2NCkgfTtcbiAgICByZXR1cm4geyBoOiBOdW1iZXIoKG4gPj4gXzMybikgJiBVMzJfTUFTSzY0KSB8IDAsIGw6IE51bWJlcihuICYgVTMyX01BU0s2NCkgfCAwIH07XG59XG5leHBvcnRzLmZyb21CaWcgPSBmcm9tQmlnO1xuZnVuY3Rpb24gc3BsaXQobHN0LCBsZSA9IGZhbHNlKSB7XG4gICAgbGV0IEFoID0gbmV3IFVpbnQzMkFycmF5KGxzdC5sZW5ndGgpO1xuICAgIGxldCBBbCA9IG5ldyBVaW50MzJBcnJheShsc3QubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB7IGgsIGwgfSA9IGZyb21CaWcobHN0W2ldLCBsZSk7XG4gICAgICAgIFtBaFtpXSwgQWxbaV1dID0gW2gsIGxdO1xuICAgIH1cbiAgICByZXR1cm4gW0FoLCBBbF07XG59XG5leHBvcnRzLnNwbGl0ID0gc3BsaXQ7XG5jb25zdCB0b0JpZyA9IChoLCBsKSA9PiAoQmlnSW50KGggPj4+IDApIDw8IF8zMm4pIHwgQmlnSW50KGwgPj4+IDApO1xuZXhwb3J0cy50b0JpZyA9IHRvQmlnO1xuLy8gZm9yIFNoaWZ0IGluIFswLCAzMilcbmNvbnN0IHNoclNIID0gKGgsIF9sLCBzKSA9PiBoID4+PiBzO1xuZXhwb3J0cy5zaHJTSCA9IHNoclNIO1xuY29uc3Qgc2hyU0wgPSAoaCwgbCwgcykgPT4gKGggPDwgKDMyIC0gcykpIHwgKGwgPj4+IHMpO1xuZXhwb3J0cy5zaHJTTCA9IHNoclNMO1xuLy8gUmlnaHQgcm90YXRlIGZvciBTaGlmdCBpbiBbMSwgMzIpXG5jb25zdCByb3RyU0ggPSAoaCwgbCwgcykgPT4gKGggPj4+IHMpIHwgKGwgPDwgKDMyIC0gcykpO1xuZXhwb3J0cy5yb3RyU0ggPSByb3RyU0g7XG5jb25zdCByb3RyU0wgPSAoaCwgbCwgcykgPT4gKGggPDwgKDMyIC0gcykpIHwgKGwgPj4+IHMpO1xuZXhwb3J0cy5yb3RyU0wgPSByb3RyU0w7XG4vLyBSaWdodCByb3RhdGUgZm9yIFNoaWZ0IGluICgzMiwgNjQpLCBOT1RFOiAzMiBpcyBzcGVjaWFsIGNhc2UuXG5jb25zdCByb3RyQkggPSAoaCwgbCwgcykgPT4gKGggPDwgKDY0IC0gcykpIHwgKGwgPj4+IChzIC0gMzIpKTtcbmV4cG9ydHMucm90ckJIID0gcm90ckJIO1xuY29uc3Qgcm90ckJMID0gKGgsIGwsIHMpID0+IChoID4+PiAocyAtIDMyKSkgfCAobCA8PCAoNjQgLSBzKSk7XG5leHBvcnRzLnJvdHJCTCA9IHJvdHJCTDtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3Igc2hpZnQ9PT0zMiAoanVzdCBzd2FwcyBsJmgpXG5jb25zdCByb3RyMzJIID0gKF9oLCBsKSA9PiBsO1xuZXhwb3J0cy5yb3RyMzJIID0gcm90cjMySDtcbmNvbnN0IHJvdHIzMkwgPSAoaCwgX2wpID0+IGg7XG5leHBvcnRzLnJvdHIzMkwgPSByb3RyMzJMO1xuLy8gTGVmdCByb3RhdGUgZm9yIFNoaWZ0IGluIFsxLCAzMilcbmNvbnN0IHJvdGxTSCA9IChoLCBsLCBzKSA9PiAoaCA8PCBzKSB8IChsID4+PiAoMzIgLSBzKSk7XG5leHBvcnRzLnJvdGxTSCA9IHJvdGxTSDtcbmNvbnN0IHJvdGxTTCA9IChoLCBsLCBzKSA9PiAobCA8PCBzKSB8IChoID4+PiAoMzIgLSBzKSk7XG5leHBvcnRzLnJvdGxTTCA9IHJvdGxTTDtcbi8vIExlZnQgcm90YXRlIGZvciBTaGlmdCBpbiAoMzIsIDY0KSwgTk9URTogMzIgaXMgc3BlY2lhbCBjYXNlLlxuY29uc3Qgcm90bEJIID0gKGgsIGwsIHMpID0+IChsIDw8IChzIC0gMzIpKSB8IChoID4+PiAoNjQgLSBzKSk7XG5leHBvcnRzLnJvdGxCSCA9IHJvdGxCSDtcbmNvbnN0IHJvdGxCTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAocyAtIDMyKSkgfCAobCA+Pj4gKDY0IC0gcykpO1xuZXhwb3J0cy5yb3RsQkwgPSByb3RsQkw7XG4vLyBKUyB1c2VzIDMyLWJpdCBzaWduZWQgaW50ZWdlcnMgZm9yIGJpdHdpc2Ugb3BlcmF0aW9ucyB3aGljaCBtZWFucyB3ZSBjYW5ub3Rcbi8vIHNpbXBsZSB0YWtlIGNhcnJ5IG91dCBvZiBsb3cgYml0IHN1bSBieSBzaGlmdCwgd2UgbmVlZCB0byB1c2UgZGl2aXNpb24uXG5mdW5jdGlvbiBhZGQoQWgsIEFsLCBCaCwgQmwpIHtcbiAgICBjb25zdCBsID0gKEFsID4+PiAwKSArIChCbCA+Pj4gMCk7XG4gICAgcmV0dXJuIHsgaDogKEFoICsgQmggKyAoKGwgLyAyICoqIDMyKSB8IDApKSB8IDAsIGw6IGwgfCAwIH07XG59XG5leHBvcnRzLmFkZCA9IGFkZDtcbi8vIEFkZGl0aW9uIHdpdGggbW9yZSB0aGFuIDIgZWxlbWVudHNcbmNvbnN0IGFkZDNMID0gKEFsLCBCbCwgQ2wpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKTtcbmV4cG9ydHMuYWRkM0wgPSBhZGQzTDtcbmNvbnN0IGFkZDNIID0gKGxvdywgQWgsIEJoLCBDaCkgPT4gKEFoICsgQmggKyBDaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuZXhwb3J0cy5hZGQzSCA9IGFkZDNIO1xuY29uc3QgYWRkNEwgPSAoQWwsIEJsLCBDbCwgRGwpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKSArIChEbCA+Pj4gMCk7XG5leHBvcnRzLmFkZDRMID0gYWRkNEw7XG5jb25zdCBhZGQ0SCA9IChsb3csIEFoLCBCaCwgQ2gsIERoKSA9PiAoQWggKyBCaCArIENoICsgRGggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbmV4cG9ydHMuYWRkNEggPSBhZGQ0SDtcbmNvbnN0IGFkZDVMID0gKEFsLCBCbCwgQ2wsIERsLCBFbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApICsgKERsID4+PiAwKSArIChFbCA+Pj4gMCk7XG5leHBvcnRzLmFkZDVMID0gYWRkNUw7XG5jb25zdCBhZGQ1SCA9IChsb3csIEFoLCBCaCwgQ2gsIERoLCBFaCkgPT4gKEFoICsgQmggKyBDaCArIERoICsgRWggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbmV4cG9ydHMuYWRkNUggPSBhZGQ1SDtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgdTY0ID0ge1xuICAgIGZyb21CaWcsIHNwbGl0LCB0b0JpZyxcbiAgICBzaHJTSCwgc2hyU0wsXG4gICAgcm90clNILCByb3RyU0wsIHJvdHJCSCwgcm90ckJMLFxuICAgIHJvdHIzMkgsIHJvdHIzMkwsXG4gICAgcm90bFNILCByb3RsU0wsIHJvdGxCSCwgcm90bEJMLFxuICAgIGFkZCwgYWRkM0wsIGFkZDNILCBhZGQ0TCwgYWRkNEgsIGFkZDVILCBhZGQ1TCxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSB1NjQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdTY0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/solana/node_modules/@noble/hashes/_u64.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/solana/node_modules/@noble/hashes/cryptoNode.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@turnkey/solana/node_modules/@noble/hashes/cryptoNode.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.crypto = void 0;\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// See utils.ts for details.\n// The file will throw on node.js 14 and earlier.\n// @ts-ignore\nconst nc = __webpack_require__(/*! node:crypto */ \"node:crypto\");\nexports.crypto = nc && typeof nc === 'object' && 'webcrypto' in nc ? nc.webcrypto : undefined;\n//# sourceMappingURL=cryptoNode.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvc29sYW5hL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2NyeXB0b05vZGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQkFBTyxDQUFDLGdDQUFhO0FBQ2hDLGNBQWM7QUFDZCIsInNvdXJjZXMiOlsid2VicGFjazovL251cnNlYmxvYy8uL25vZGVfbW9kdWxlcy9AdHVybmtleS9zb2xhbmEvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvY3J5cHRvTm9kZS5qcz9jZWIzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcnlwdG8gPSB2b2lkIDA7XG4vLyBXZSB1c2UgV2ViQ3J5cHRvIGFrYSBnbG9iYWxUaGlzLmNyeXB0bywgd2hpY2ggZXhpc3RzIGluIGJyb3dzZXJzIGFuZCBub2RlLmpzIDE2Ky5cbi8vIFNlZSB1dGlscy50cyBmb3IgZGV0YWlscy5cbi8vIFRoZSBmaWxlIHdpbGwgdGhyb3cgb24gbm9kZS5qcyAxNCBhbmQgZWFybGllci5cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IG5jID0gcmVxdWlyZShcIm5vZGU6Y3J5cHRvXCIpO1xuZXhwb3J0cy5jcnlwdG8gPSBuYyAmJiB0eXBlb2YgbmMgPT09ICdvYmplY3QnICYmICd3ZWJjcnlwdG8nIGluIG5jID8gbmMud2ViY3J5cHRvIDogdW5kZWZpbmVkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3J5cHRvTm9kZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/solana/node_modules/@noble/hashes/cryptoNode.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/solana/node_modules/@noble/hashes/sha256.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@turnkey/solana/node_modules/@noble/hashes/sha256.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.sha224 = exports.sha256 = void 0;\nconst _md_js_1 = __webpack_require__(/*! ./_md.js */ \"(ssr)/./node_modules/@turnkey/solana/node_modules/@noble/hashes/_md.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@turnkey/solana/node_modules/@noble/hashes/utils.js\");\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state:\n// first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19\n// prettier-ignore\nconst SHA256_IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends _md_js_1.HashMD {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = SHA256_IV[0] | 0;\n        this.B = SHA256_IV[1] | 0;\n        this.C = SHA256_IV[2] | 0;\n        this.D = SHA256_IV[3] | 0;\n        this.E = SHA256_IV[4] | 0;\n        this.F = SHA256_IV[5] | 0;\n        this.G = SHA256_IV[6] | 0;\n        this.H = SHA256_IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ (W15 >>> 3);\n            const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);\n            const T1 = (H + sigma1 + (0, _md_js_1.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);\n            const T2 = (sigma0 + (0, _md_js_1.Maj)(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nexports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());\nexports.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());\n//# sourceMappingURL=sha256.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvc29sYW5hL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL3NoYTI1Ni5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjLEdBQUcsY0FBYztBQUMvQixpQkFBaUIsbUJBQU8sQ0FBQyx3RkFBVTtBQUNuQyxtQkFBbUIsbUJBQU8sQ0FBQyw0RkFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseUJBQXlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHlCQUF5QjtBQUN2Qyx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsY0FBYztBQUNkIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbnVyc2VibG9jLy4vbm9kZV9tb2R1bGVzL0B0dXJua2V5L3NvbGFuYS9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9zaGEyNTYuanM/NTI3NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2hhMjI0ID0gZXhwb3J0cy5zaGEyNTYgPSB2b2lkIDA7XG5jb25zdCBfbWRfanNfMSA9IHJlcXVpcmUoXCIuL19tZC5qc1wiKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbi8vIFNIQTItMjU2IG5lZWQgdG8gdHJ5IDJeMTI4IGhhc2hlcyB0byBleGVjdXRlIGJpcnRoZGF5IGF0dGFjay5cbi8vIEJUQyBuZXR3b3JrIGlzIGRvaW5nIDJeNjcgaGFzaGVzL3NlYyBhcyBwZXIgZWFybHkgMjAyMy5cbi8vIFJvdW5kIGNvbnN0YW50czpcbi8vIGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIGN1YmUgcm9vdHMgb2YgdGhlIGZpcnN0IDY0IHByaW1lcyAyLi4zMTEpXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IFNIQTI1Nl9LID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheShbXG4gICAgMHg0MjhhMmY5OCwgMHg3MTM3NDQ5MSwgMHhiNWMwZmJjZiwgMHhlOWI1ZGJhNSwgMHgzOTU2YzI1YiwgMHg1OWYxMTFmMSwgMHg5MjNmODJhNCwgMHhhYjFjNWVkNSxcbiAgICAweGQ4MDdhYTk4LCAweDEyODM1YjAxLCAweDI0MzE4NWJlLCAweDU1MGM3ZGMzLCAweDcyYmU1ZDc0LCAweDgwZGViMWZlLCAweDliZGMwNmE3LCAweGMxOWJmMTc0LFxuICAgIDB4ZTQ5YjY5YzEsIDB4ZWZiZTQ3ODYsIDB4MGZjMTlkYzYsIDB4MjQwY2ExY2MsIDB4MmRlOTJjNmYsIDB4NGE3NDg0YWEsIDB4NWNiMGE5ZGMsIDB4NzZmOTg4ZGEsXG4gICAgMHg5ODNlNTE1MiwgMHhhODMxYzY2ZCwgMHhiMDAzMjdjOCwgMHhiZjU5N2ZjNywgMHhjNmUwMGJmMywgMHhkNWE3OTE0NywgMHgwNmNhNjM1MSwgMHgxNDI5Mjk2NyxcbiAgICAweDI3YjcwYTg1LCAweDJlMWIyMTM4LCAweDRkMmM2ZGZjLCAweDUzMzgwZDEzLCAweDY1MGE3MzU0LCAweDc2NmEwYWJiLCAweDgxYzJjOTJlLCAweDkyNzIyYzg1LFxuICAgIDB4YTJiZmU4YTEsIDB4YTgxYTY2NGIsIDB4YzI0YjhiNzAsIDB4Yzc2YzUxYTMsIDB4ZDE5MmU4MTksIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsXG4gICAgMHgxOWE0YzExNiwgMHgxZTM3NmMwOCwgMHgyNzQ4Nzc0YywgMHgzNGIwYmNiNSwgMHgzOTFjMGNiMywgMHg0ZWQ4YWE0YSwgMHg1YjljY2E0ZiwgMHg2ODJlNmZmMyxcbiAgICAweDc0OGY4MmVlLCAweDc4YTU2MzZmLCAweDg0Yzg3ODE0LCAweDhjYzcwMjA4LCAweDkwYmVmZmZhLCAweGE0NTA2Y2ViLCAweGJlZjlhM2Y3LCAweGM2NzE3OGYyXG5dKTtcbi8vIEluaXRpYWwgc3RhdGU6XG4vLyBmaXJzdCAzMiBiaXRzIG9mIHRoZSBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBzcXVhcmUgcm9vdHMgb2YgdGhlIGZpcnN0IDggcHJpbWVzIDIuLjE5XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IFNIQTI1Nl9JViA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoW1xuICAgIDB4NmEwOWU2NjcsIDB4YmI2N2FlODUsIDB4M2M2ZWYzNzIsIDB4YTU0ZmY1M2EsIDB4NTEwZTUyN2YsIDB4OWIwNTY4OGMsIDB4MWY4M2Q5YWIsIDB4NWJlMGNkMTlcbl0pO1xuLy8gVGVtcG9yYXJ5IGJ1ZmZlciwgbm90IHVzZWQgdG8gc3RvcmUgYW55dGhpbmcgYmV0d2VlbiBydW5zXG4vLyBOYW1lZCB0aGlzIHdheSBiZWNhdXNlIGl0IG1hdGNoZXMgc3BlY2lmaWNhdGlvbi5cbmNvbnN0IFNIQTI1Nl9XID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheSg2NCk7XG5jbGFzcyBTSEEyNTYgZXh0ZW5kcyBfbWRfanNfMS5IYXNoTUQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcig2NCwgMzIsIDgsIGZhbHNlKTtcbiAgICAgICAgLy8gV2UgY2Fubm90IHVzZSBhcnJheSBoZXJlIHNpbmNlIGFycmF5IGFsbG93cyBpbmRleGluZyBieSB2YXJpYWJsZVxuICAgICAgICAvLyB3aGljaCBtZWFucyBvcHRpbWl6ZXIvY29tcGlsZXIgY2Fubm90IHVzZSByZWdpc3RlcnMuXG4gICAgICAgIHRoaXMuQSA9IFNIQTI1Nl9JVlswXSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IFNIQTI1Nl9JVlsxXSB8IDA7XG4gICAgICAgIHRoaXMuQyA9IFNIQTI1Nl9JVlsyXSB8IDA7XG4gICAgICAgIHRoaXMuRCA9IFNIQTI1Nl9JVlszXSB8IDA7XG4gICAgICAgIHRoaXMuRSA9IFNIQTI1Nl9JVls0XSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IFNIQTI1Nl9JVls1XSB8IDA7XG4gICAgICAgIHRoaXMuRyA9IFNIQTI1Nl9JVls2XSB8IDA7XG4gICAgICAgIHRoaXMuSCA9IFNIQTI1Nl9JVls3XSB8IDA7XG4gICAgfVxuICAgIGdldCgpIHtcbiAgICAgICAgY29uc3QgeyBBLCBCLCBDLCBELCBFLCBGLCBHLCBIIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW0EsIEIsIEMsIEQsIEUsIEYsIEcsIEhdO1xuICAgIH1cbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBzZXQoQSwgQiwgQywgRCwgRSwgRiwgRywgSCkge1xuICAgICAgICB0aGlzLkEgPSBBIHwgMDtcbiAgICAgICAgdGhpcy5CID0gQiB8IDA7XG4gICAgICAgIHRoaXMuQyA9IEMgfCAwO1xuICAgICAgICB0aGlzLkQgPSBEIHwgMDtcbiAgICAgICAgdGhpcy5FID0gRSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IEYgfCAwO1xuICAgICAgICB0aGlzLkcgPSBHIHwgMDtcbiAgICAgICAgdGhpcy5IID0gSCB8IDA7XG4gICAgfVxuICAgIHByb2Nlc3Modmlldywgb2Zmc2V0KSB7XG4gICAgICAgIC8vIEV4dGVuZCB0aGUgZmlyc3QgMTYgd29yZHMgaW50byB0aGUgcmVtYWluaW5nIDQ4IHdvcmRzIHdbMTYuLjYzXSBvZiB0aGUgbWVzc2FnZSBzY2hlZHVsZSBhcnJheVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyssIG9mZnNldCArPSA0KVxuICAgICAgICAgICAgU0hBMjU2X1dbaV0gPSB2aWV3LmdldFVpbnQzMihvZmZzZXQsIGZhbHNlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE2OyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgVzE1ID0gU0hBMjU2X1dbaSAtIDE1XTtcbiAgICAgICAgICAgIGNvbnN0IFcyID0gU0hBMjU2X1dbaSAtIDJdO1xuICAgICAgICAgICAgY29uc3QgczAgPSAoMCwgdXRpbHNfanNfMS5yb3RyKShXMTUsIDcpIF4gKDAsIHV0aWxzX2pzXzEucm90cikoVzE1LCAxOCkgXiAoVzE1ID4+PiAzKTtcbiAgICAgICAgICAgIGNvbnN0IHMxID0gKDAsIHV0aWxzX2pzXzEucm90cikoVzIsIDE3KSBeICgwLCB1dGlsc19qc18xLnJvdHIpKFcyLCAxOSkgXiAoVzIgPj4+IDEwKTtcbiAgICAgICAgICAgIFNIQTI1Nl9XW2ldID0gKHMxICsgU0hBMjU2X1dbaSAtIDddICsgczAgKyBTSEEyNTZfV1tpIC0gMTZdKSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcHJlc3Npb24gZnVuY3Rpb24gbWFpbiBsb29wLCA2NCByb3VuZHNcbiAgICAgICAgbGV0IHsgQSwgQiwgQywgRCwgRSwgRiwgRywgSCB9ID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2NDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTEgPSAoMCwgdXRpbHNfanNfMS5yb3RyKShFLCA2KSBeICgwLCB1dGlsc19qc18xLnJvdHIpKEUsIDExKSBeICgwLCB1dGlsc19qc18xLnJvdHIpKEUsIDI1KTtcbiAgICAgICAgICAgIGNvbnN0IFQxID0gKEggKyBzaWdtYTEgKyAoMCwgX21kX2pzXzEuQ2hpKShFLCBGLCBHKSArIFNIQTI1Nl9LW2ldICsgU0hBMjU2X1dbaV0pIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMCA9ICgwLCB1dGlsc19qc18xLnJvdHIpKEEsIDIpIF4gKDAsIHV0aWxzX2pzXzEucm90cikoQSwgMTMpIF4gKDAsIHV0aWxzX2pzXzEucm90cikoQSwgMjIpO1xuICAgICAgICAgICAgY29uc3QgVDIgPSAoc2lnbWEwICsgKDAsIF9tZF9qc18xLk1haikoQSwgQiwgQykpIHwgMDtcbiAgICAgICAgICAgIEggPSBHO1xuICAgICAgICAgICAgRyA9IEY7XG4gICAgICAgICAgICBGID0gRTtcbiAgICAgICAgICAgIEUgPSAoRCArIFQxKSB8IDA7XG4gICAgICAgICAgICBEID0gQztcbiAgICAgICAgICAgIEMgPSBCO1xuICAgICAgICAgICAgQiA9IEE7XG4gICAgICAgICAgICBBID0gKFQxICsgVDIpIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICBBID0gKEEgKyB0aGlzLkEpIHwgMDtcbiAgICAgICAgQiA9IChCICsgdGhpcy5CKSB8IDA7XG4gICAgICAgIEMgPSAoQyArIHRoaXMuQykgfCAwO1xuICAgICAgICBEID0gKEQgKyB0aGlzLkQpIHwgMDtcbiAgICAgICAgRSA9IChFICsgdGhpcy5FKSB8IDA7XG4gICAgICAgIEYgPSAoRiArIHRoaXMuRikgfCAwO1xuICAgICAgICBHID0gKEcgKyB0aGlzLkcpIHwgMDtcbiAgICAgICAgSCA9IChIICsgdGhpcy5IKSB8IDA7XG4gICAgICAgIHRoaXMuc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpO1xuICAgIH1cbiAgICByb3VuZENsZWFuKCkge1xuICAgICAgICBTSEEyNTZfVy5maWxsKDApO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICAgICAgdGhpcy5idWZmZXIuZmlsbCgwKTtcbiAgICB9XG59XG4vLyBDb25zdGFudHMgZnJvbSBodHRwczovL252bHB1YnMubmlzdC5nb3YvbmlzdHB1YnMvRklQUy9OSVNULkZJUFMuMTgwLTQucGRmXG5jbGFzcyBTSEEyMjQgZXh0ZW5kcyBTSEEyNTYge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLkEgPSAweGMxMDU5ZWQ4IHwgMDtcbiAgICAgICAgdGhpcy5CID0gMHgzNjdjZDUwNyB8IDA7XG4gICAgICAgIHRoaXMuQyA9IDB4MzA3MGRkMTcgfCAwO1xuICAgICAgICB0aGlzLkQgPSAweGY3MGU1OTM5IHwgMDtcbiAgICAgICAgdGhpcy5FID0gMHhmZmMwMGIzMSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IDB4Njg1ODE1MTEgfCAwO1xuICAgICAgICB0aGlzLkcgPSAweDY0Zjk4ZmE3IHwgMDtcbiAgICAgICAgdGhpcy5IID0gMHhiZWZhNGZhNCB8IDA7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gMjg7XG4gICAgfVxufVxuLyoqXG4gKiBTSEEyLTI1NiBoYXNoIGZ1bmN0aW9uXG4gKiBAcGFyYW0gbWVzc2FnZSAtIGRhdGEgdGhhdCB3b3VsZCBiZSBoYXNoZWRcbiAqL1xuZXhwb3J0cy5zaGEyNTYgPSAoMCwgdXRpbHNfanNfMS53cmFwQ29uc3RydWN0b3IpKCgpID0+IG5ldyBTSEEyNTYoKSk7XG5leHBvcnRzLnNoYTIyNCA9ICgwLCB1dGlsc19qc18xLndyYXBDb25zdHJ1Y3RvcikoKCkgPT4gbmV3IFNIQTIyNCgpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYTI1Ni5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/solana/node_modules/@noble/hashes/sha256.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/solana/node_modules/@noble/hashes/sha3.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@turnkey/solana/node_modules/@noble/hashes/sha3.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = exports.keccakP = void 0;\nconst _assert_js_1 = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./node_modules/@turnkey/solana/node_modules/@noble/hashes/_assert.js\");\nconst _u64_js_1 = __webpack_require__(/*! ./_u64.js */ \"(ssr)/./node_modules/@turnkey/solana/node_modules/@noble/hashes/_u64.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@turnkey/solana/node_modules/@noble/hashes/utils.js\");\n// SHA3 (keccak) is based on a new design: basically, the internal state is bigger than output size.\n// It's called a sponge function.\n// Various per round constants calculations\nconst SHA3_PI = [];\nconst SHA3_ROTL = [];\nconst _SHA3_IOTA = [];\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\nconst _7n = /* @__PURE__ */ BigInt(7);\nconst _256n = /* @__PURE__ */ BigInt(256);\nconst _0x71n = /* @__PURE__ */ BigInt(0x71);\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\n    // Pi\n    [x, y] = [y, (2 * x + 3 * y) % 5];\n    SHA3_PI.push(2 * (5 * y + x));\n    // Rotational\n    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);\n    // Iota\n    let t = _0n;\n    for (let j = 0; j < 7; j++) {\n        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;\n        if (R & _2n)\n            t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);\n    }\n    _SHA3_IOTA.push(t);\n}\nconst [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ (0, _u64_js_1.split)(_SHA3_IOTA, true);\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h, l, s) => (s > 32 ? (0, _u64_js_1.rotlBH)(h, l, s) : (0, _u64_js_1.rotlSH)(h, l, s));\nconst rotlL = (h, l, s) => (s > 32 ? (0, _u64_js_1.rotlBL)(h, l, s) : (0, _u64_js_1.rotlSL)(h, l, s));\n// Same as keccakf1600, but allows to skip some rounds\nfunction keccakP(s, rounds = 24) {\n    const B = new Uint32Array(5 * 2);\n    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n    for (let round = 24 - rounds; round < 24; round++) {\n        // Theta θ\n        for (let x = 0; x < 10; x++)\n            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n        for (let x = 0; x < 10; x += 2) {\n            const idx1 = (x + 8) % 10;\n            const idx0 = (x + 2) % 10;\n            const B0 = B[idx0];\n            const B1 = B[idx0 + 1];\n            const Th = rotlH(B0, B1, 1) ^ B[idx1];\n            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n            for (let y = 0; y < 50; y += 10) {\n                s[x + y] ^= Th;\n                s[x + y + 1] ^= Tl;\n            }\n        }\n        // Rho (ρ) and Pi (π)\n        let curH = s[2];\n        let curL = s[3];\n        for (let t = 0; t < 24; t++) {\n            const shift = SHA3_ROTL[t];\n            const Th = rotlH(curH, curL, shift);\n            const Tl = rotlL(curH, curL, shift);\n            const PI = SHA3_PI[t];\n            curH = s[PI];\n            curL = s[PI + 1];\n            s[PI] = Th;\n            s[PI + 1] = Tl;\n        }\n        // Chi (χ)\n        for (let y = 0; y < 50; y += 10) {\n            for (let x = 0; x < 10; x++)\n                B[x] = s[y + x];\n            for (let x = 0; x < 10; x++)\n                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n        }\n        // Iota (ι)\n        s[0] ^= SHA3_IOTA_H[round];\n        s[1] ^= SHA3_IOTA_L[round];\n    }\n    B.fill(0);\n}\nexports.keccakP = keccakP;\nclass Keccak extends utils_js_1.Hash {\n    // NOTE: we accept arguments in bytes instead of bits here.\n    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {\n        super();\n        this.blockLen = blockLen;\n        this.suffix = suffix;\n        this.outputLen = outputLen;\n        this.enableXOF = enableXOF;\n        this.rounds = rounds;\n        this.pos = 0;\n        this.posOut = 0;\n        this.finished = false;\n        this.destroyed = false;\n        // Can be passed from user as dkLen\n        (0, _assert_js_1.number)(outputLen);\n        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n        if (0 >= this.blockLen || this.blockLen >= 200)\n            throw new Error('Sha3 supports only keccak-f1600 function');\n        this.state = new Uint8Array(200);\n        this.state32 = (0, utils_js_1.u32)(this.state);\n    }\n    keccak() {\n        if (!utils_js_1.isLE)\n            (0, utils_js_1.byteSwap32)(this.state32);\n        keccakP(this.state32, this.rounds);\n        if (!utils_js_1.isLE)\n            (0, utils_js_1.byteSwap32)(this.state32);\n        this.posOut = 0;\n        this.pos = 0;\n    }\n    update(data) {\n        (0, _assert_js_1.exists)(this);\n        const { blockLen, state } = this;\n        data = (0, utils_js_1.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            for (let i = 0; i < take; i++)\n                state[this.pos++] ^= data[pos++];\n            if (this.pos === blockLen)\n                this.keccak();\n        }\n        return this;\n    }\n    finish() {\n        if (this.finished)\n            return;\n        this.finished = true;\n        const { state, suffix, pos, blockLen } = this;\n        // Do the padding\n        state[pos] ^= suffix;\n        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)\n            this.keccak();\n        state[blockLen - 1] ^= 0x80;\n        this.keccak();\n    }\n    writeInto(out) {\n        (0, _assert_js_1.exists)(this, false);\n        (0, _assert_js_1.bytes)(out);\n        this.finish();\n        const bufferOut = this.state;\n        const { blockLen } = this;\n        for (let pos = 0, len = out.length; pos < len;) {\n            if (this.posOut >= blockLen)\n                this.keccak();\n            const take = Math.min(blockLen - this.posOut, len - pos);\n            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n            this.posOut += take;\n            pos += take;\n        }\n        return out;\n    }\n    xofInto(out) {\n        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n        if (!this.enableXOF)\n            throw new Error('XOF is not possible for this instance');\n        return this.writeInto(out);\n    }\n    xof(bytes) {\n        (0, _assert_js_1.number)(bytes);\n        return this.xofInto(new Uint8Array(bytes));\n    }\n    digestInto(out) {\n        (0, _assert_js_1.output)(out, this);\n        if (this.finished)\n            throw new Error('digest() was already called');\n        this.writeInto(out);\n        this.destroy();\n        return out;\n    }\n    digest() {\n        return this.digestInto(new Uint8Array(this.outputLen));\n    }\n    destroy() {\n        this.destroyed = true;\n        this.state.fill(0);\n    }\n    _cloneInto(to) {\n        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));\n        to.state32.set(this.state32);\n        to.pos = this.pos;\n        to.posOut = this.posOut;\n        to.finished = this.finished;\n        to.rounds = rounds;\n        // Suffix can change in cSHAKE\n        to.suffix = suffix;\n        to.outputLen = outputLen;\n        to.enableXOF = enableXOF;\n        to.destroyed = this.destroyed;\n        return to;\n    }\n}\nexports.Keccak = Keccak;\nconst gen = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));\nexports.sha3_224 = gen(0x06, 144, 224 / 8);\n/**\n * SHA3-256 hash function\n * @param message - that would be hashed\n */\nexports.sha3_256 = gen(0x06, 136, 256 / 8);\nexports.sha3_384 = gen(0x06, 104, 384 / 8);\nexports.sha3_512 = gen(0x06, 72, 512 / 8);\nexports.keccak_224 = gen(0x01, 144, 224 / 8);\n/**\n * keccak-256 hash function. Different from SHA3-256.\n * @param message - that would be hashed\n */\nexports.keccak_256 = gen(0x01, 136, 256 / 8);\nexports.keccak_384 = gen(0x01, 104, 384 / 8);\nexports.keccak_512 = gen(0x01, 72, 512 / 8);\nconst genShake = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapXOFConstructorWithOpts)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));\nexports.shake128 = genShake(0x1f, 168, 128 / 8);\nexports.shake256 = genShake(0x1f, 136, 256 / 8);\n//# sourceMappingURL=sha3.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvc29sYW5hL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL3NoYTMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCLEdBQUcsZ0JBQWdCLEdBQUcsa0JBQWtCLEdBQUcsa0JBQWtCLEdBQUcsa0JBQWtCLEdBQUcsa0JBQWtCLEdBQUcsZ0JBQWdCLEdBQUcsZ0JBQWdCLEdBQUcsZ0JBQWdCLEdBQUcsZ0JBQWdCLEdBQUcsY0FBYyxHQUFHLGVBQWU7QUFDdE8scUJBQXFCLG1CQUFPLENBQUMsZ0dBQWM7QUFDM0Msa0JBQWtCLG1CQUFPLENBQUMsMEZBQVc7QUFDckMsbUJBQW1CLG1CQUFPLENBQUMsNEZBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFlBQVk7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFlBQVk7QUFDOUM7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQyw0QkFBNEIsUUFBUTtBQUNwQztBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBLDBCQUEwQixVQUFVO0FBQ3BDO0FBQ0EsNEJBQTRCLFVBQVU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0JBQStCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCLDRDQUE0QyxVQUFVO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaURBQWlEO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCLGtCQUFrQjtBQUNsQix1R0FBdUc7QUFDdkcsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQiIsInNvdXJjZXMiOlsid2VicGFjazovL251cnNlYmxvYy8uL25vZGVfbW9kdWxlcy9AdHVybmtleS9zb2xhbmEvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvc2hhMy5qcz8yNzg5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zaGFrZTI1NiA9IGV4cG9ydHMuc2hha2UxMjggPSBleHBvcnRzLmtlY2Nha181MTIgPSBleHBvcnRzLmtlY2Nha18zODQgPSBleHBvcnRzLmtlY2Nha18yNTYgPSBleHBvcnRzLmtlY2Nha18yMjQgPSBleHBvcnRzLnNoYTNfNTEyID0gZXhwb3J0cy5zaGEzXzM4NCA9IGV4cG9ydHMuc2hhM18yNTYgPSBleHBvcnRzLnNoYTNfMjI0ID0gZXhwb3J0cy5LZWNjYWsgPSBleHBvcnRzLmtlY2Nha1AgPSB2b2lkIDA7XG5jb25zdCBfYXNzZXJ0X2pzXzEgPSByZXF1aXJlKFwiLi9fYXNzZXJ0LmpzXCIpO1xuY29uc3QgX3U2NF9qc18xID0gcmVxdWlyZShcIi4vX3U2NC5qc1wiKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbi8vIFNIQTMgKGtlY2NhaykgaXMgYmFzZWQgb24gYSBuZXcgZGVzaWduOiBiYXNpY2FsbHksIHRoZSBpbnRlcm5hbCBzdGF0ZSBpcyBiaWdnZXIgdGhhbiBvdXRwdXQgc2l6ZS5cbi8vIEl0J3MgY2FsbGVkIGEgc3BvbmdlIGZ1bmN0aW9uLlxuLy8gVmFyaW91cyBwZXIgcm91bmQgY29uc3RhbnRzIGNhbGN1bGF0aW9uc1xuY29uc3QgU0hBM19QSSA9IFtdO1xuY29uc3QgU0hBM19ST1RMID0gW107XG5jb25zdCBfU0hBM19JT1RBID0gW107XG5jb25zdCBfMG4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDApO1xuY29uc3QgXzFuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgxKTtcbmNvbnN0IF8ybiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMik7XG5jb25zdCBfN24gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDcpO1xuY29uc3QgXzI1Nm4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDI1Nik7XG5jb25zdCBfMHg3MW4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDB4NzEpO1xuZm9yIChsZXQgcm91bmQgPSAwLCBSID0gXzFuLCB4ID0gMSwgeSA9IDA7IHJvdW5kIDwgMjQ7IHJvdW5kKyspIHtcbiAgICAvLyBQaVxuICAgIFt4LCB5XSA9IFt5LCAoMiAqIHggKyAzICogeSkgJSA1XTtcbiAgICBTSEEzX1BJLnB1c2goMiAqICg1ICogeSArIHgpKTtcbiAgICAvLyBSb3RhdGlvbmFsXG4gICAgU0hBM19ST1RMLnB1c2goKCgocm91bmQgKyAxKSAqIChyb3VuZCArIDIpKSAvIDIpICUgNjQpO1xuICAgIC8vIElvdGFcbiAgICBsZXQgdCA9IF8wbjtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IDc7IGorKykge1xuICAgICAgICBSID0gKChSIDw8IF8xbikgXiAoKFIgPj4gXzduKSAqIF8weDcxbikpICUgXzI1Nm47XG4gICAgICAgIGlmIChSICYgXzJuKVxuICAgICAgICAgICAgdCBePSBfMW4gPDwgKChfMW4gPDwgLyogQF9fUFVSRV9fICovIEJpZ0ludChqKSkgLSBfMW4pO1xuICAgIH1cbiAgICBfU0hBM19JT1RBLnB1c2godCk7XG59XG5jb25zdCBbU0hBM19JT1RBX0gsIFNIQTNfSU9UQV9MXSA9IC8qIEBfX1BVUkVfXyAqLyAoMCwgX3U2NF9qc18xLnNwbGl0KShfU0hBM19JT1RBLCB0cnVlKTtcbi8vIExlZnQgcm90YXRpb24gKHdpdGhvdXQgMCwgMzIsIDY0KVxuY29uc3Qgcm90bEggPSAoaCwgbCwgcykgPT4gKHMgPiAzMiA/ICgwLCBfdTY0X2pzXzEucm90bEJIKShoLCBsLCBzKSA6ICgwLCBfdTY0X2pzXzEucm90bFNIKShoLCBsLCBzKSk7XG5jb25zdCByb3RsTCA9IChoLCBsLCBzKSA9PiAocyA+IDMyID8gKDAsIF91NjRfanNfMS5yb3RsQkwpKGgsIGwsIHMpIDogKDAsIF91NjRfanNfMS5yb3RsU0wpKGgsIGwsIHMpKTtcbi8vIFNhbWUgYXMga2VjY2FrZjE2MDAsIGJ1dCBhbGxvd3MgdG8gc2tpcCBzb21lIHJvdW5kc1xuZnVuY3Rpb24ga2VjY2FrUChzLCByb3VuZHMgPSAyNCkge1xuICAgIGNvbnN0IEIgPSBuZXcgVWludDMyQXJyYXkoNSAqIDIpO1xuICAgIC8vIE5PVEU6IGFsbCBpbmRpY2VzIGFyZSB4MiBzaW5jZSB3ZSBzdG9yZSBzdGF0ZSBhcyB1MzIgaW5zdGVhZCBvZiB1NjQgKGJpZ2ludHMgdG8gc2xvdyBpbiBqcylcbiAgICBmb3IgKGxldCByb3VuZCA9IDI0IC0gcm91bmRzOyByb3VuZCA8IDI0OyByb3VuZCsrKSB7XG4gICAgICAgIC8vIFRoZXRhIM64XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHgrKylcbiAgICAgICAgICAgIEJbeF0gPSBzW3hdIF4gc1t4ICsgMTBdIF4gc1t4ICsgMjBdIF4gc1t4ICsgMzBdIF4gc1t4ICsgNDBdO1xuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4ICs9IDIpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkeDEgPSAoeCArIDgpICUgMTA7XG4gICAgICAgICAgICBjb25zdCBpZHgwID0gKHggKyAyKSAlIDEwO1xuICAgICAgICAgICAgY29uc3QgQjAgPSBCW2lkeDBdO1xuICAgICAgICAgICAgY29uc3QgQjEgPSBCW2lkeDAgKyAxXTtcbiAgICAgICAgICAgIGNvbnN0IFRoID0gcm90bEgoQjAsIEIxLCAxKSBeIEJbaWR4MV07XG4gICAgICAgICAgICBjb25zdCBUbCA9IHJvdGxMKEIwLCBCMSwgMSkgXiBCW2lkeDEgKyAxXTtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgNTA7IHkgKz0gMTApIHtcbiAgICAgICAgICAgICAgICBzW3ggKyB5XSBePSBUaDtcbiAgICAgICAgICAgICAgICBzW3ggKyB5ICsgMV0gXj0gVGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmhvICjPgSkgYW5kIFBpICjPgClcbiAgICAgICAgbGV0IGN1ckggPSBzWzJdO1xuICAgICAgICBsZXQgY3VyTCA9IHNbM107XG4gICAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgMjQ7IHQrKykge1xuICAgICAgICAgICAgY29uc3Qgc2hpZnQgPSBTSEEzX1JPVExbdF07XG4gICAgICAgICAgICBjb25zdCBUaCA9IHJvdGxIKGN1ckgsIGN1ckwsIHNoaWZ0KTtcbiAgICAgICAgICAgIGNvbnN0IFRsID0gcm90bEwoY3VySCwgY3VyTCwgc2hpZnQpO1xuICAgICAgICAgICAgY29uc3QgUEkgPSBTSEEzX1BJW3RdO1xuICAgICAgICAgICAgY3VySCA9IHNbUEldO1xuICAgICAgICAgICAgY3VyTCA9IHNbUEkgKyAxXTtcbiAgICAgICAgICAgIHNbUEldID0gVGg7XG4gICAgICAgICAgICBzW1BJICsgMV0gPSBUbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGkgKM+HKVxuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IDUwOyB5ICs9IDEwKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4KyspXG4gICAgICAgICAgICAgICAgQlt4XSA9IHNbeSArIHhdO1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCsrKVxuICAgICAgICAgICAgICAgIHNbeSArIHhdIF49IH5CWyh4ICsgMikgJSAxMF0gJiBCWyh4ICsgNCkgJSAxMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW90YSAozrkpXG4gICAgICAgIHNbMF0gXj0gU0hBM19JT1RBX0hbcm91bmRdO1xuICAgICAgICBzWzFdIF49IFNIQTNfSU9UQV9MW3JvdW5kXTtcbiAgICB9XG4gICAgQi5maWxsKDApO1xufVxuZXhwb3J0cy5rZWNjYWtQID0ga2VjY2FrUDtcbmNsYXNzIEtlY2NhayBleHRlbmRzIHV0aWxzX2pzXzEuSGFzaCB7XG4gICAgLy8gTk9URTogd2UgYWNjZXB0IGFyZ3VtZW50cyBpbiBieXRlcyBpbnN0ZWFkIG9mIGJpdHMgaGVyZS5cbiAgICBjb25zdHJ1Y3RvcihibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4sIGVuYWJsZVhPRiA9IGZhbHNlLCByb3VuZHMgPSAyNCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRoaXMuc3VmZml4ID0gc3VmZml4O1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdGhpcy5lbmFibGVYT0YgPSBlbmFibGVYT0Y7XG4gICAgICAgIHRoaXMucm91bmRzID0gcm91bmRzO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMucG9zT3V0ID0gMDtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICAvLyBDYW4gYmUgcGFzc2VkIGZyb20gdXNlciBhcyBka0xlblxuICAgICAgICAoMCwgX2Fzc2VydF9qc18xLm51bWJlcikob3V0cHV0TGVuKTtcbiAgICAgICAgLy8gMTYwMCA9IDV4NSBtYXRyaXggb2YgNjRiaXQuICAxNjAwIGJpdHMgPT09IDIwMCBieXRlc1xuICAgICAgICBpZiAoMCA+PSB0aGlzLmJsb2NrTGVuIHx8IHRoaXMuYmxvY2tMZW4gPj0gMjAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaGEzIHN1cHBvcnRzIG9ubHkga2VjY2FrLWYxNjAwIGZ1bmN0aW9uJyk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBuZXcgVWludDhBcnJheSgyMDApO1xuICAgICAgICB0aGlzLnN0YXRlMzIgPSAoMCwgdXRpbHNfanNfMS51MzIpKHRoaXMuc3RhdGUpO1xuICAgIH1cbiAgICBrZWNjYWsoKSB7XG4gICAgICAgIGlmICghdXRpbHNfanNfMS5pc0xFKVxuICAgICAgICAgICAgKDAsIHV0aWxzX2pzXzEuYnl0ZVN3YXAzMikodGhpcy5zdGF0ZTMyKTtcbiAgICAgICAga2VjY2FrUCh0aGlzLnN0YXRlMzIsIHRoaXMucm91bmRzKTtcbiAgICAgICAgaWYgKCF1dGlsc19qc18xLmlzTEUpXG4gICAgICAgICAgICAoMCwgdXRpbHNfanNfMS5ieXRlU3dhcDMyKSh0aGlzLnN0YXRlMzIpO1xuICAgICAgICB0aGlzLnBvc091dCA9IDA7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICB9XG4gICAgdXBkYXRlKGRhdGEpIHtcbiAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5leGlzdHMpKHRoaXMpO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBzdGF0ZSB9ID0gdGhpcztcbiAgICAgICAgZGF0YSA9ICgwLCB1dGlsc19qc18xLnRvQnl0ZXMpKGRhdGEpO1xuICAgICAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3MsIGxlbiAtIHBvcyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRha2U7IGkrKylcbiAgICAgICAgICAgICAgICBzdGF0ZVt0aGlzLnBvcysrXSBePSBkYXRhW3BvcysrXTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA9PT0gYmxvY2tMZW4pXG4gICAgICAgICAgICAgICAgdGhpcy5rZWNjYWsoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZmluaXNoKCkge1xuICAgICAgICBpZiAodGhpcy5maW5pc2hlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIGNvbnN0IHsgc3RhdGUsIHN1ZmZpeCwgcG9zLCBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgICAgLy8gRG8gdGhlIHBhZGRpbmdcbiAgICAgICAgc3RhdGVbcG9zXSBePSBzdWZmaXg7XG4gICAgICAgIGlmICgoc3VmZml4ICYgMHg4MCkgIT09IDAgJiYgcG9zID09PSBibG9ja0xlbiAtIDEpXG4gICAgICAgICAgICB0aGlzLmtlY2NhaygpO1xuICAgICAgICBzdGF0ZVtibG9ja0xlbiAtIDFdIF49IDB4ODA7XG4gICAgICAgIHRoaXMua2VjY2FrKCk7XG4gICAgfVxuICAgIHdyaXRlSW50byhvdXQpIHtcbiAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5leGlzdHMpKHRoaXMsIGZhbHNlKTtcbiAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5ieXRlcykob3V0KTtcbiAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgY29uc3QgYnVmZmVyT3V0ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMCwgbGVuID0gb3V0Lmxlbmd0aDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zT3V0ID49IGJsb2NrTGVuKVxuICAgICAgICAgICAgICAgIHRoaXMua2VjY2FrKCk7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvc091dCwgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIG91dC5zZXQoYnVmZmVyT3V0LnN1YmFycmF5KHRoaXMucG9zT3V0LCB0aGlzLnBvc091dCArIHRha2UpLCBwb3MpO1xuICAgICAgICAgICAgdGhpcy5wb3NPdXQgKz0gdGFrZTtcbiAgICAgICAgICAgIHBvcyArPSB0YWtlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIHhvZkludG8ob3V0KSB7XG4gICAgICAgIC8vIFNoYTMvS2VjY2FrIHVzYWdlIHdpdGggWE9GIGlzIHByb2JhYmx5IG1pc3Rha2UsIG9ubHkgU0hBS0UgaW5zdGFuY2VzIGNhbiBkbyBYT0ZcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZVhPRilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWE9GIGlzIG5vdCBwb3NzaWJsZSBmb3IgdGhpcyBpbnN0YW5jZScpO1xuICAgICAgICByZXR1cm4gdGhpcy53cml0ZUludG8ob3V0KTtcbiAgICB9XG4gICAgeG9mKGJ5dGVzKSB7XG4gICAgICAgICgwLCBfYXNzZXJ0X2pzXzEubnVtYmVyKShieXRlcyk7XG4gICAgICAgIHJldHVybiB0aGlzLnhvZkludG8obmV3IFVpbnQ4QXJyYXkoYnl0ZXMpKTtcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5vdXRwdXQpKG91dCwgdGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmZpbmlzaGVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaWdlc3QoKSB3YXMgYWxyZWFkeSBjYWxsZWQnKTtcbiAgICAgICAgdGhpcy53cml0ZUludG8ob3V0KTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlnZXN0SW50byhuZXcgVWludDhBcnJheSh0aGlzLm91dHB1dExlbikpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIHRoaXMuc3RhdGUuZmlsbCgwKTtcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBzdWZmaXgsIG91dHB1dExlbiwgcm91bmRzLCBlbmFibGVYT0YgfSA9IHRoaXM7XG4gICAgICAgIHRvIHx8ICh0byA9IG5ldyBLZWNjYWsoYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuLCBlbmFibGVYT0YsIHJvdW5kcykpO1xuICAgICAgICB0by5zdGF0ZTMyLnNldCh0aGlzLnN0YXRlMzIpO1xuICAgICAgICB0by5wb3MgPSB0aGlzLnBvcztcbiAgICAgICAgdG8ucG9zT3V0ID0gdGhpcy5wb3NPdXQ7XG4gICAgICAgIHRvLmZpbmlzaGVkID0gdGhpcy5maW5pc2hlZDtcbiAgICAgICAgdG8ucm91bmRzID0gcm91bmRzO1xuICAgICAgICAvLyBTdWZmaXggY2FuIGNoYW5nZSBpbiBjU0hBS0VcbiAgICAgICAgdG8uc3VmZml4ID0gc3VmZml4O1xuICAgICAgICB0by5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRvLmVuYWJsZVhPRiA9IGVuYWJsZVhPRjtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gdGhpcy5kZXN0cm95ZWQ7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG59XG5leHBvcnRzLktlY2NhayA9IEtlY2NhaztcbmNvbnN0IGdlbiA9IChzdWZmaXgsIGJsb2NrTGVuLCBvdXRwdXRMZW4pID0+ICgwLCB1dGlsc19qc18xLndyYXBDb25zdHJ1Y3RvcikoKCkgPT4gbmV3IEtlY2NhayhibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4pKTtcbmV4cG9ydHMuc2hhM18yMjQgPSBnZW4oMHgwNiwgMTQ0LCAyMjQgLyA4KTtcbi8qKlxuICogU0hBMy0yNTYgaGFzaCBmdW5jdGlvblxuICogQHBhcmFtIG1lc3NhZ2UgLSB0aGF0IHdvdWxkIGJlIGhhc2hlZFxuICovXG5leHBvcnRzLnNoYTNfMjU2ID0gZ2VuKDB4MDYsIDEzNiwgMjU2IC8gOCk7XG5leHBvcnRzLnNoYTNfMzg0ID0gZ2VuKDB4MDYsIDEwNCwgMzg0IC8gOCk7XG5leHBvcnRzLnNoYTNfNTEyID0gZ2VuKDB4MDYsIDcyLCA1MTIgLyA4KTtcbmV4cG9ydHMua2VjY2FrXzIyNCA9IGdlbigweDAxLCAxNDQsIDIyNCAvIDgpO1xuLyoqXG4gKiBrZWNjYWstMjU2IGhhc2ggZnVuY3Rpb24uIERpZmZlcmVudCBmcm9tIFNIQTMtMjU2LlxuICogQHBhcmFtIG1lc3NhZ2UgLSB0aGF0IHdvdWxkIGJlIGhhc2hlZFxuICovXG5leHBvcnRzLmtlY2Nha18yNTYgPSBnZW4oMHgwMSwgMTM2LCAyNTYgLyA4KTtcbmV4cG9ydHMua2VjY2FrXzM4NCA9IGdlbigweDAxLCAxMDQsIDM4NCAvIDgpO1xuZXhwb3J0cy5rZWNjYWtfNTEyID0gZ2VuKDB4MDEsIDcyLCA1MTIgLyA4KTtcbmNvbnN0IGdlblNoYWtlID0gKHN1ZmZpeCwgYmxvY2tMZW4sIG91dHB1dExlbikgPT4gKDAsIHV0aWxzX2pzXzEud3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMpKChvcHRzID0ge30pID0+IG5ldyBLZWNjYWsoYmxvY2tMZW4sIHN1ZmZpeCwgb3B0cy5ka0xlbiA9PT0gdW5kZWZpbmVkID8gb3V0cHV0TGVuIDogb3B0cy5ka0xlbiwgdHJ1ZSkpO1xuZXhwb3J0cy5zaGFrZTEyOCA9IGdlblNoYWtlKDB4MWYsIDE2OCwgMTI4IC8gOCk7XG5leHBvcnRzLnNoYWtlMjU2ID0gZ2VuU2hha2UoMHgxZiwgMTM2LCAyNTYgLyA4KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYTMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/solana/node_modules/@noble/hashes/sha3.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/solana/node_modules/@noble/hashes/utils.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@turnkey/solana/node_modules/@noble/hashes/utils.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.byteSwap32 = exports.byteSwapIfBE = exports.byteSwap = exports.isLE = exports.rotl = exports.rotr = exports.createView = exports.u32 = exports.u8 = exports.isBytes = void 0;\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nconst crypto_1 = __webpack_require__(/*! @noble/hashes/crypto */ \"(ssr)/./node_modules/@turnkey/solana/node_modules/@noble/hashes/cryptoNode.js\");\nconst _assert_js_1 = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./node_modules/@turnkey/solana/node_modules/@noble/hashes/_assert.js\");\n// export { isBytes } from './_assert.js';\n// We can't reuse isBytes from _assert, because somehow this causes huge perf issues\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\nexports.isBytes = isBytes;\n// Cast array to different type\nconst u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexports.u8 = u8;\nconst u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\nexports.u32 = u32;\n// Cast array to view\nconst createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\nexports.createView = createView;\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\nexports.rotr = rotr;\n// The rotate left (circular left shift) operation for uint32\nconst rotl = (word, shift) => (word << shift) | ((word >>> (32 - shift)) >>> 0);\nexports.rotl = rotl;\nexports.isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\n// The byte swap operation for uint32\nconst byteSwap = (word) => ((word << 24) & 0xff000000) |\n    ((word << 8) & 0xff0000) |\n    ((word >>> 8) & 0xff00) |\n    ((word >>> 24) & 0xff);\nexports.byteSwap = byteSwap;\n// Conditionally byte swap if on a big-endian platform\nexports.byteSwapIfBE = exports.isLE ? (n) => n : (n) => (0, exports.byteSwap)(n);\n// In place byte swap for Uint32Array\nfunction byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = (0, exports.byteSwap)(arr[i]);\n    }\n}\nexports.byteSwap32 = byteSwap32;\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    (0, _assert_js_1.bytes)(bytes);\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nexports.bytesToHex = bytesToHex;\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9)\n        return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F)\n        return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f)\n        return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\nexports.hexToBytes = hexToBytes;\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async () => { };\nexports.nextTick = nextTick;\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await (0, exports.nextTick)();\n        ts += diff;\n    }\n}\nexports.asyncLoop = asyncLoop;\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\nexports.utf8ToBytes = utf8ToBytes;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    (0, _assert_js_1.bytes)(data);\n    return data;\n}\nexports.toBytes = toBytes;\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        (0, _assert_js_1.bytes)(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\nexports.concatBytes = concatBytes;\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nexports.Hash = Hash;\nconst toStr = {}.toString;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nexports.checkOpts = checkOpts;\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nexports.wrapConstructor = wrapConstructor;\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexports.wrapConstructorWithOpts = wrapConstructorWithOpts;\nfunction wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nfunction randomBytes(bytesLength = 32) {\n    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === 'function') {\n        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\nexports.randomBytes = randomBytes;\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvc29sYW5hL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CLEdBQUcsa0NBQWtDLEdBQUcsK0JBQStCLEdBQUcsdUJBQXVCLEdBQUcsaUJBQWlCLEdBQUcsWUFBWSxHQUFHLG1CQUFtQixHQUFHLGVBQWUsR0FBRyxtQkFBbUIsR0FBRyxpQkFBaUIsR0FBRyxnQkFBZ0IsR0FBRyxrQkFBa0IsR0FBRyxrQkFBa0IsR0FBRyxrQkFBa0IsR0FBRyxvQkFBb0IsR0FBRyxnQkFBZ0IsR0FBRyxZQUFZLEdBQUcsWUFBWSxHQUFHLFlBQVksR0FBRyxrQkFBa0IsR0FBRyxXQUFXLEdBQUcsVUFBVSxHQUFHLGVBQWU7QUFDcGQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsMkdBQXNCO0FBQy9DLHFCQUFxQixtQkFBTyxDQUFDLGdHQUFjO0FBQzNDLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1osWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EsMkNBQTJDLGFBQWE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsU0FBUztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxXQUFXO0FBQ3ZFLDBEQUEwRDtBQUMxRDtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsbUJBQW1CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9udXJzZWJsb2MvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvc29sYW5hL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL3V0aWxzLmpzPzMwODEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKiEgbm9ibGUtaGFzaGVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJhbmRvbUJ5dGVzID0gZXhwb3J0cy53cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cyA9IGV4cG9ydHMud3JhcENvbnN0cnVjdG9yV2l0aE9wdHMgPSBleHBvcnRzLndyYXBDb25zdHJ1Y3RvciA9IGV4cG9ydHMuY2hlY2tPcHRzID0gZXhwb3J0cy5IYXNoID0gZXhwb3J0cy5jb25jYXRCeXRlcyA9IGV4cG9ydHMudG9CeXRlcyA9IGV4cG9ydHMudXRmOFRvQnl0ZXMgPSBleHBvcnRzLmFzeW5jTG9vcCA9IGV4cG9ydHMubmV4dFRpY2sgPSBleHBvcnRzLmhleFRvQnl0ZXMgPSBleHBvcnRzLmJ5dGVzVG9IZXggPSBleHBvcnRzLmJ5dGVTd2FwMzIgPSBleHBvcnRzLmJ5dGVTd2FwSWZCRSA9IGV4cG9ydHMuYnl0ZVN3YXAgPSBleHBvcnRzLmlzTEUgPSBleHBvcnRzLnJvdGwgPSBleHBvcnRzLnJvdHIgPSBleHBvcnRzLmNyZWF0ZVZpZXcgPSBleHBvcnRzLnUzMiA9IGV4cG9ydHMudTggPSBleHBvcnRzLmlzQnl0ZXMgPSB2b2lkIDA7XG4vLyBXZSB1c2UgV2ViQ3J5cHRvIGFrYSBnbG9iYWxUaGlzLmNyeXB0bywgd2hpY2ggZXhpc3RzIGluIGJyb3dzZXJzIGFuZCBub2RlLmpzIDE2Ky5cbi8vIG5vZGUuanMgdmVyc2lvbnMgZWFybGllciB0aGFuIHYxOSBkb24ndCBkZWNsYXJlIGl0IGluIGdsb2JhbCBzY29wZS5cbi8vIEZvciBub2RlLmpzLCBwYWNrYWdlLmpzb24jZXhwb3J0cyBmaWVsZCBtYXBwaW5nIHJld3JpdGVzIGltcG9ydFxuLy8gZnJvbSBgY3J5cHRvYCB0byBgY3J5cHRvTm9kZWAsIHdoaWNoIGltcG9ydHMgbmF0aXZlIG1vZHVsZS5cbi8vIE1ha2VzIHRoZSB1dGlscyB1bi1pbXBvcnRhYmxlIGluIGJyb3dzZXJzIHdpdGhvdXQgYSBidW5kbGVyLlxuLy8gT25jZSBub2RlLmpzIDE4IGlzIGRlcHJlY2F0ZWQgKDIwMjUtMDQtMzApLCB3ZSBjYW4ganVzdCBkcm9wIHRoZSBpbXBvcnQuXG5jb25zdCBjcnlwdG9fMSA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL2NyeXB0b1wiKTtcbmNvbnN0IF9hc3NlcnRfanNfMSA9IHJlcXVpcmUoXCIuL19hc3NlcnQuanNcIik7XG4vLyBleHBvcnQgeyBpc0J5dGVzIH0gZnJvbSAnLi9fYXNzZXJ0LmpzJztcbi8vIFdlIGNhbid0IHJldXNlIGlzQnl0ZXMgZnJvbSBfYXNzZXJ0LCBiZWNhdXNlIHNvbWVob3cgdGhpcyBjYXVzZXMgaHVnZSBwZXJmIGlzc3Vlc1xuZnVuY3Rpb24gaXNCeXRlcyhhKSB7XG4gICAgcmV0dXJuIChhIGluc3RhbmNlb2YgVWludDhBcnJheSB8fFxuICAgICAgICAoYSAhPSBudWxsICYmIHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiBhLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdVaW50OEFycmF5JykpO1xufVxuZXhwb3J0cy5pc0J5dGVzID0gaXNCeXRlcztcbi8vIENhc3QgYXJyYXkgdG8gZGlmZmVyZW50IHR5cGVcbmNvbnN0IHU4ID0gKGFycikgPT4gbmV3IFVpbnQ4QXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbmV4cG9ydHMudTggPSB1ODtcbmNvbnN0IHUzMiA9IChhcnIpID0+IG5ldyBVaW50MzJBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgTWF0aC5mbG9vcihhcnIuYnl0ZUxlbmd0aCAvIDQpKTtcbmV4cG9ydHMudTMyID0gdTMyO1xuLy8gQ2FzdCBhcnJheSB0byB2aWV3XG5jb25zdCBjcmVhdGVWaWV3ID0gKGFycikgPT4gbmV3IERhdGFWaWV3KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG5leHBvcnRzLmNyZWF0ZVZpZXcgPSBjcmVhdGVWaWV3O1xuLy8gVGhlIHJvdGF0ZSByaWdodCAoY2lyY3VsYXIgcmlnaHQgc2hpZnQpIG9wZXJhdGlvbiBmb3IgdWludDMyXG5jb25zdCByb3RyID0gKHdvcmQsIHNoaWZ0KSA9PiAod29yZCA8PCAoMzIgLSBzaGlmdCkpIHwgKHdvcmQgPj4+IHNoaWZ0KTtcbmV4cG9ydHMucm90ciA9IHJvdHI7XG4vLyBUaGUgcm90YXRlIGxlZnQgKGNpcmN1bGFyIGxlZnQgc2hpZnQpIG9wZXJhdGlvbiBmb3IgdWludDMyXG5jb25zdCByb3RsID0gKHdvcmQsIHNoaWZ0KSA9PiAod29yZCA8PCBzaGlmdCkgfCAoKHdvcmQgPj4+ICgzMiAtIHNoaWZ0KSkgPj4+IDApO1xuZXhwb3J0cy5yb3RsID0gcm90bDtcbmV4cG9ydHMuaXNMRSA9IG5ldyBVaW50OEFycmF5KG5ldyBVaW50MzJBcnJheShbMHgxMTIyMzM0NF0pLmJ1ZmZlcilbMF0gPT09IDB4NDQ7XG4vLyBUaGUgYnl0ZSBzd2FwIG9wZXJhdGlvbiBmb3IgdWludDMyXG5jb25zdCBieXRlU3dhcCA9ICh3b3JkKSA9PiAoKHdvcmQgPDwgMjQpICYgMHhmZjAwMDAwMCkgfFxuICAgICgod29yZCA8PCA4KSAmIDB4ZmYwMDAwKSB8XG4gICAgKCh3b3JkID4+PiA4KSAmIDB4ZmYwMCkgfFxuICAgICgod29yZCA+Pj4gMjQpICYgMHhmZik7XG5leHBvcnRzLmJ5dGVTd2FwID0gYnl0ZVN3YXA7XG4vLyBDb25kaXRpb25hbGx5IGJ5dGUgc3dhcCBpZiBvbiBhIGJpZy1lbmRpYW4gcGxhdGZvcm1cbmV4cG9ydHMuYnl0ZVN3YXBJZkJFID0gZXhwb3J0cy5pc0xFID8gKG4pID0+IG4gOiAobikgPT4gKDAsIGV4cG9ydHMuYnl0ZVN3YXApKG4pO1xuLy8gSW4gcGxhY2UgYnl0ZSBzd2FwIGZvciBVaW50MzJBcnJheVxuZnVuY3Rpb24gYnl0ZVN3YXAzMihhcnIpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJbaV0gPSAoMCwgZXhwb3J0cy5ieXRlU3dhcCkoYXJyW2ldKTtcbiAgICB9XG59XG5leHBvcnRzLmJ5dGVTd2FwMzIgPSBieXRlU3dhcDMyO1xuLy8gQXJyYXkgd2hlcmUgaW5kZXggMHhmMCAoMjQwKSBpcyBtYXBwZWQgdG8gc3RyaW5nICdmMCdcbmNvbnN0IGhleGVzID0gLyogQF9fUFVSRV9fICovIEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoXywgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG4vKipcbiAqIEBleGFtcGxlIGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSkpIC8vICdjYWZlMDEyMydcbiAqL1xuZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuICAgICgwLCBfYXNzZXJ0X2pzXzEuYnl0ZXMpKGJ5dGVzKTtcbiAgICAvLyBwcmUtY2FjaGluZyBpbXByb3ZlcyB0aGUgc3BlZWQgNnhcbiAgICBsZXQgaGV4ID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBoZXggKz0gaGV4ZXNbYnl0ZXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufVxuZXhwb3J0cy5ieXRlc1RvSGV4ID0gYnl0ZXNUb0hleDtcbi8vIFdlIHVzZSBvcHRpbWl6ZWQgdGVjaG5pcXVlIHRvIGNvbnZlcnQgaGV4IHN0cmluZyB0byBieXRlIGFycmF5XG5jb25zdCBhc2NpaXMgPSB7IF8wOiA0OCwgXzk6IDU3LCBfQTogNjUsIF9GOiA3MCwgX2E6IDk3LCBfZjogMTAyIH07XG5mdW5jdGlvbiBhc2NpaVRvQmFzZTE2KGNoYXIpIHtcbiAgICBpZiAoY2hhciA+PSBhc2NpaXMuXzAgJiYgY2hhciA8PSBhc2NpaXMuXzkpXG4gICAgICAgIHJldHVybiBjaGFyIC0gYXNjaWlzLl8wO1xuICAgIGlmIChjaGFyID49IGFzY2lpcy5fQSAmJiBjaGFyIDw9IGFzY2lpcy5fRilcbiAgICAgICAgcmV0dXJuIGNoYXIgLSAoYXNjaWlzLl9BIC0gMTApO1xuICAgIGlmIChjaGFyID49IGFzY2lpcy5fYSAmJiBjaGFyIDw9IGFzY2lpcy5fZilcbiAgICAgICAgcmV0dXJuIGNoYXIgLSAoYXNjaWlzLl9hIC0gMTApO1xuICAgIHJldHVybjtcbn1cbi8qKlxuICogQGV4YW1wbGUgaGV4VG9CeXRlcygnY2FmZTAxMjMnKSAvLyBVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKVxuICovXG5mdW5jdGlvbiBoZXhUb0J5dGVzKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIGNvbnN0IGhsID0gaGV4Lmxlbmd0aDtcbiAgICBjb25zdCBhbCA9IGhsIC8gMjtcbiAgICBpZiAoaGwgJSAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRlZCBoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgdW5wYWRkZWQgaGV4IG9mIGxlbmd0aCAnICsgaGwpO1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYWwpO1xuICAgIGZvciAobGV0IGFpID0gMCwgaGkgPSAwOyBhaSA8IGFsOyBhaSsrLCBoaSArPSAyKSB7XG4gICAgICAgIGNvbnN0IG4xID0gYXNjaWlUb0Jhc2UxNihoZXguY2hhckNvZGVBdChoaSkpO1xuICAgICAgICBjb25zdCBuMiA9IGFzY2lpVG9CYXNlMTYoaGV4LmNoYXJDb2RlQXQoaGkgKyAxKSk7XG4gICAgICAgIGlmIChuMSA9PT0gdW5kZWZpbmVkIHx8IG4yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYXIgPSBoZXhbaGldICsgaGV4W2hpICsgMV07XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCBub24taGV4IGNoYXJhY3RlciBcIicgKyBjaGFyICsgJ1wiIGF0IGluZGV4ICcgKyBoaSk7XG4gICAgICAgIH1cbiAgICAgICAgYXJyYXlbYWldID0gbjEgKiAxNiArIG4yO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG5leHBvcnRzLmhleFRvQnl0ZXMgPSBoZXhUb0J5dGVzO1xuLy8gVGhlcmUgaXMgbm8gc2V0SW1tZWRpYXRlIGluIGJyb3dzZXIgYW5kIHNldFRpbWVvdXQgaXMgc2xvdy5cbi8vIGNhbGwgb2YgYXN5bmMgZm4gd2lsbCByZXR1cm4gUHJvbWlzZSwgd2hpY2ggd2lsbCBiZSBmdWxsZmlsZWQgb25seSBvblxuLy8gbmV4dCBzY2hlZHVsZXIgcXVldWUgcHJvY2Vzc2luZyBzdGVwIGFuZCB0aGlzIGlzIGV4YWN0bHkgd2hhdCB3ZSBuZWVkLlxuY29uc3QgbmV4dFRpY2sgPSBhc3luYyAoKSA9PiB7IH07XG5leHBvcnRzLm5leHRUaWNrID0gbmV4dFRpY2s7XG4vLyBSZXR1cm5zIGNvbnRyb2wgdG8gdGhyZWFkIGVhY2ggJ3RpY2snIG1zIHRvIGF2b2lkIGJsb2NraW5nXG5hc3luYyBmdW5jdGlvbiBhc3luY0xvb3AoaXRlcnMsIHRpY2ssIGNiKSB7XG4gICAgbGV0IHRzID0gRGF0ZS5ub3coKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJzOyBpKyspIHtcbiAgICAgICAgY2IoaSk7XG4gICAgICAgIC8vIERhdGUubm93KCkgaXMgbm90IG1vbm90b25pYywgc28gaW4gY2FzZSBpZiBjbG9jayBnb2VzIGJhY2t3YXJkcyB3ZSByZXR1cm4gcmV0dXJuIGNvbnRyb2wgdG9vXG4gICAgICAgIGNvbnN0IGRpZmYgPSBEYXRlLm5vdygpIC0gdHM7XG4gICAgICAgIGlmIChkaWZmID49IDAgJiYgZGlmZiA8IHRpY2spXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgYXdhaXQgKDAsIGV4cG9ydHMubmV4dFRpY2spKCk7XG4gICAgICAgIHRzICs9IGRpZmY7XG4gICAgfVxufVxuZXhwb3J0cy5hc3luY0xvb3AgPSBhc3luY0xvb3A7XG4vKipcbiAqIEBleGFtcGxlIHV0ZjhUb0J5dGVzKCdhYmMnKSAvLyBuZXcgVWludDhBcnJheShbOTcsIDk4LCA5OV0pXG4gKi9cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1dGY4VG9CeXRlcyBleHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiBzdHJ9YCk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpKTsgLy8gaHR0cHM6Ly9idWd6aWwubGEvMTY4MTgwOVxufVxuZXhwb3J0cy51dGY4VG9CeXRlcyA9IHV0ZjhUb0J5dGVzO1xuLyoqXG4gKiBOb3JtYWxpemVzIChub24taGV4KSBzdHJpbmcgb3IgVWludDhBcnJheSB0byBVaW50OEFycmF5LlxuICogV2FybmluZzogd2hlbiBVaW50OEFycmF5IGlzIHBhc3NlZCwgaXQgd291bGQgTk9UIGdldCBjb3BpZWQuXG4gKiBLZWVwIGluIG1pbmQgZm9yIGZ1dHVyZSBtdXRhYmxlIG9wZXJhdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIHRvQnl0ZXMoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpXG4gICAgICAgIGRhdGEgPSB1dGY4VG9CeXRlcyhkYXRhKTtcbiAgICAoMCwgX2Fzc2VydF9qc18xLmJ5dGVzKShkYXRhKTtcbiAgICByZXR1cm4gZGF0YTtcbn1cbmV4cG9ydHMudG9CeXRlcyA9IHRvQnl0ZXM7XG4vKipcbiAqIENvcGllcyBzZXZlcmFsIFVpbnQ4QXJyYXlzIGludG8gb25lLlxuICovXG5mdW5jdGlvbiBjb25jYXRCeXRlcyguLi5hcnJheXMpIHtcbiAgICBsZXQgc3VtID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhID0gYXJyYXlzW2ldO1xuICAgICAgICAoMCwgX2Fzc2VydF9qc18xLmJ5dGVzKShhKTtcbiAgICAgICAgc3VtICs9IGEubGVuZ3RoO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheShzdW0pO1xuICAgIGZvciAobGV0IGkgPSAwLCBwYWQgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBhcnJheXNbaV07XG4gICAgICAgIHJlcy5zZXQoYSwgcGFkKTtcbiAgICAgICAgcGFkICs9IGEubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZXhwb3J0cy5jb25jYXRCeXRlcyA9IGNvbmNhdEJ5dGVzO1xuLy8gRm9yIHJ1bnRpbWUgY2hlY2sgaWYgY2xhc3MgaW1wbGVtZW50cyBpbnRlcmZhY2VcbmNsYXNzIEhhc2gge1xuICAgIC8vIFNhZmUgdmVyc2lvbiB0aGF0IGNsb25lcyBpbnRlcm5hbCBzdGF0ZVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvbmVJbnRvKCk7XG4gICAgfVxufVxuZXhwb3J0cy5IYXNoID0gSGFzaDtcbmNvbnN0IHRvU3RyID0ge30udG9TdHJpbmc7XG5mdW5jdGlvbiBjaGVja09wdHMoZGVmYXVsdHMsIG9wdHMpIHtcbiAgICBpZiAob3B0cyAhPT0gdW5kZWZpbmVkICYmIHRvU3RyLmNhbGwob3B0cykgIT09ICdbb2JqZWN0IE9iamVjdF0nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09wdGlvbnMgc2hvdWxkIGJlIG9iamVjdCBvciB1bmRlZmluZWQnKTtcbiAgICBjb25zdCBtZXJnZWQgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRzLCBvcHRzKTtcbiAgICByZXR1cm4gbWVyZ2VkO1xufVxuZXhwb3J0cy5jaGVja09wdHMgPSBjaGVja09wdHM7XG5mdW5jdGlvbiB3cmFwQ29uc3RydWN0b3IoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2cpID0+IGhhc2hDb25zKCkudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoKTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9ICgpID0+IGhhc2hDb25zKCk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0cy53cmFwQ29uc3RydWN0b3IgPSB3cmFwQ29uc3RydWN0b3I7XG5mdW5jdGlvbiB3cmFwQ29uc3RydWN0b3JXaXRoT3B0cyhoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZywgb3B0cykgPT4gaGFzaENvbnMob3B0cykudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoe30pO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKG9wdHMpID0+IGhhc2hDb25zKG9wdHMpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbmV4cG9ydHMud3JhcENvbnN0cnVjdG9yV2l0aE9wdHMgPSB3cmFwQ29uc3RydWN0b3JXaXRoT3B0cztcbmZ1bmN0aW9uIHdyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnLCBvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucyh7fSk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAob3B0cykgPT4gaGFzaENvbnMob3B0cyk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0cy53cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cyA9IHdyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzO1xuLyoqXG4gKiBTZWN1cmUgUFJORy4gVXNlcyBgY3J5cHRvLmdldFJhbmRvbVZhbHVlc2AsIHdoaWNoIGRlZmVycyB0byBPUy5cbiAqL1xuZnVuY3Rpb24gcmFuZG9tQnl0ZXMoYnl0ZXNMZW5ndGggPSAzMikge1xuICAgIGlmIChjcnlwdG9fMS5jcnlwdG8gJiYgdHlwZW9mIGNyeXB0b18xLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0b18xLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoYnl0ZXNMZW5ndGgpKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIG11c3QgYmUgZGVmaW5lZCcpO1xufVxuZXhwb3J0cy5yYW5kb21CeXRlcyA9IHJhbmRvbUJ5dGVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/solana/node_modules/@noble/hashes/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/solana/node_modules/@solana/web3.js/lib/index.cjs.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@turnkey/solana/node_modules/@solana/web3.js/lib/index.cjs.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar buffer = __webpack_require__(/*! buffer */ \"buffer\");\nvar ed25519 = __webpack_require__(/*! @noble/curves/ed25519 */ \"(ssr)/./node_modules/@noble/curves/ed25519.js\");\nvar BN = __webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/bn.js/lib/bn.js\");\nvar bs58 = __webpack_require__(/*! bs58 */ \"(ssr)/./node_modules/bs58/index.js\");\nvar sha256 = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/@turnkey/solana/node_modules/@noble/hashes/sha256.js\");\nvar borsh = __webpack_require__(/*! borsh */ \"(ssr)/./node_modules/borsh/lib/index.js\");\nvar BufferLayout = __webpack_require__(/*! @solana/buffer-layout */ \"(ssr)/./node_modules/@solana/buffer-layout/lib/Layout.js\");\nvar bigintBuffer = __webpack_require__(/*! bigint-buffer */ \"(ssr)/./node_modules/bigint-buffer/dist/node.js\");\nvar require$$0 = __webpack_require__(/*! util */ \"util\");\nvar require$$0$1 = __webpack_require__(/*! http */ \"http\");\nvar require$$0$2 = __webpack_require__(/*! https */ \"https\");\nvar superstruct = __webpack_require__(/*! superstruct */ \"(ssr)/./node_modules/superstruct/lib/index.cjs\");\nvar RpcClient = __webpack_require__(/*! jayson/lib/client/browser */ \"(ssr)/./node_modules/@turnkey/solana/node_modules/jayson/lib/client/browser/index.js\");\nvar nodeFetch = __webpack_require__(/*! node-fetch */ \"(ssr)/./node_modules/node-fetch/lib/index.js\");\nvar RpcWebSocketCommonClient = __webpack_require__(/*! rpc-websockets/dist/lib/client */ \"(ssr)/./node_modules/rpc-websockets/dist/lib/client.js\");\nvar WebsocketFactory = __webpack_require__(/*! rpc-websockets/dist/lib/client/websocket */ \"(ssr)/./node_modules/rpc-websockets/dist/lib/client/websocket.js\");\nvar sha3 = __webpack_require__(/*! @noble/hashes/sha3 */ \"(ssr)/./node_modules/@turnkey/solana/node_modules/@noble/hashes/sha3.js\");\nvar secp256k1 = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(ssr)/./node_modules/@noble/curves/secp256k1.js\");\n\nfunction _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }\n\nfunction _interopNamespaceCompat(e) {\n  if (e && typeof e === 'object' && 'default' in e) return e;\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () { return e[k]; }\n        });\n      }\n    });\n  }\n  n.default = e;\n  return Object.freeze(n);\n}\n\nvar BN__default = /*#__PURE__*/_interopDefaultCompat(BN);\nvar bs58__default = /*#__PURE__*/_interopDefaultCompat(bs58);\nvar BufferLayout__namespace = /*#__PURE__*/_interopNamespaceCompat(BufferLayout);\nvar require$$0__default = /*#__PURE__*/_interopDefaultCompat(require$$0);\nvar require$$0__default$1 = /*#__PURE__*/_interopDefaultCompat(require$$0$1);\nvar require$$0__default$2 = /*#__PURE__*/_interopDefaultCompat(require$$0$2);\nvar RpcClient__default = /*#__PURE__*/_interopDefaultCompat(RpcClient);\nvar nodeFetch__namespace = /*#__PURE__*/_interopNamespaceCompat(nodeFetch);\nvar RpcWebSocketCommonClient__default = /*#__PURE__*/_interopDefaultCompat(RpcWebSocketCommonClient);\nvar WebsocketFactory__default = /*#__PURE__*/_interopDefaultCompat(WebsocketFactory);\n\n/**\n * A 64 byte secret key, the first 32 bytes of which is the\n * private scalar and the last 32 bytes is the public key.\n * Read more: https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/\n */\n\n/**\n * Ed25519 Keypair\n */\n\nconst generatePrivateKey = ed25519.ed25519.utils.randomPrivateKey;\nconst generateKeypair = () => {\n  const privateScalar = ed25519.ed25519.utils.randomPrivateKey();\n  const publicKey = getPublicKey(privateScalar);\n  const secretKey = new Uint8Array(64);\n  secretKey.set(privateScalar);\n  secretKey.set(publicKey, 32);\n  return {\n    publicKey,\n    secretKey\n  };\n};\nconst getPublicKey = ed25519.ed25519.getPublicKey;\nfunction isOnCurve(publicKey) {\n  try {\n    ed25519.ed25519.ExtendedPoint.fromHex(publicKey);\n    return true;\n  } catch {\n    return false;\n  }\n}\nconst sign = (message, secretKey) => ed25519.ed25519.sign(message, secretKey.slice(0, 32));\nconst verify = ed25519.ed25519.verify;\n\nconst toBuffer = arr => {\n  if (buffer.Buffer.isBuffer(arr)) {\n    return arr;\n  } else if (arr instanceof Uint8Array) {\n    return buffer.Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength);\n  } else {\n    return buffer.Buffer.from(arr);\n  }\n};\n\n// Class wrapping a plain object\nclass Struct {\n  constructor(properties) {\n    Object.assign(this, properties);\n  }\n  encode() {\n    return buffer.Buffer.from(borsh.serialize(SOLANA_SCHEMA, this));\n  }\n  static decode(data) {\n    return borsh.deserialize(SOLANA_SCHEMA, this, data);\n  }\n  static decodeUnchecked(data) {\n    return borsh.deserializeUnchecked(SOLANA_SCHEMA, this, data);\n  }\n}\n\n// Class representing a Rust-compatible enum, since enums are only strings or\n// numbers in pure JS\nclass Enum extends Struct {\n  constructor(properties) {\n    super(properties);\n    this.enum = '';\n    if (Object.keys(properties).length !== 1) {\n      throw new Error('Enum can only take single value');\n    }\n    Object.keys(properties).map(key => {\n      this.enum = key;\n    });\n  }\n}\nconst SOLANA_SCHEMA = new Map();\n\nvar _class;\nlet _Symbol$toStringTag;\n\n/**\n * Maximum length of derived pubkey seed\n */\nconst MAX_SEED_LENGTH = 32;\n\n/**\n * Size of public key in bytes\n */\nconst PUBLIC_KEY_LENGTH = 32;\n\n/**\n * Value to be converted into public key\n */\n\n/**\n * JSON object representation of PublicKey class\n */\n\nfunction isPublicKeyData(value) {\n  return value._bn !== undefined;\n}\n\n// local counter used by PublicKey.unique()\nlet uniquePublicKeyCounter = 1;\n\n/**\n * A public key\n */\n_Symbol$toStringTag = Symbol.toStringTag;\nclass PublicKey extends Struct {\n  /**\n   * Create a new PublicKey object\n   * @param value ed25519 public key as buffer or base-58 encoded string\n   */\n  constructor(value) {\n    super({});\n    /** @internal */\n    this._bn = void 0;\n    if (isPublicKeyData(value)) {\n      this._bn = value._bn;\n    } else {\n      if (typeof value === 'string') {\n        // assume base 58 encoding by default\n        const decoded = bs58__default.default.decode(value);\n        if (decoded.length != PUBLIC_KEY_LENGTH) {\n          throw new Error(`Invalid public key input`);\n        }\n        this._bn = new BN__default.default(decoded);\n      } else {\n        this._bn = new BN__default.default(value);\n      }\n      if (this._bn.byteLength() > PUBLIC_KEY_LENGTH) {\n        throw new Error(`Invalid public key input`);\n      }\n    }\n  }\n\n  /**\n   * Returns a unique PublicKey for tests and benchmarks using a counter\n   */\n  static unique() {\n    const key = new PublicKey(uniquePublicKeyCounter);\n    uniquePublicKeyCounter += 1;\n    return new PublicKey(key.toBuffer());\n  }\n\n  /**\n   * Default public key value. The base58-encoded string representation is all ones (as seen below)\n   * The underlying BN number is 32 bytes that are all zeros\n   */\n\n  /**\n   * Checks if two publicKeys are equal\n   */\n  equals(publicKey) {\n    return this._bn.eq(publicKey._bn);\n  }\n\n  /**\n   * Return the base-58 representation of the public key\n   */\n  toBase58() {\n    return bs58__default.default.encode(this.toBytes());\n  }\n  toJSON() {\n    return this.toBase58();\n  }\n\n  /**\n   * Return the byte array representation of the public key in big endian\n   */\n  toBytes() {\n    const buf = this.toBuffer();\n    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);\n  }\n\n  /**\n   * Return the Buffer representation of the public key in big endian\n   */\n  toBuffer() {\n    const b = this._bn.toArrayLike(buffer.Buffer);\n    if (b.length === PUBLIC_KEY_LENGTH) {\n      return b;\n    }\n    const zeroPad = buffer.Buffer.alloc(32);\n    b.copy(zeroPad, 32 - b.length);\n    return zeroPad;\n  }\n  get [_Symbol$toStringTag]() {\n    return `PublicKey(${this.toString()})`;\n  }\n\n  /**\n   * Return the base-58 representation of the public key\n   */\n  toString() {\n    return this.toBase58();\n  }\n\n  /**\n   * Derive a public key from another key, a seed, and a program ID.\n   * The program ID will also serve as the owner of the public key, giving\n   * it permission to write data to the account.\n   */\n  /* eslint-disable require-await */\n  static async createWithSeed(fromPublicKey, seed, programId) {\n    const buffer$1 = buffer.Buffer.concat([fromPublicKey.toBuffer(), buffer.Buffer.from(seed), programId.toBuffer()]);\n    const publicKeyBytes = sha256.sha256(buffer$1);\n    return new PublicKey(publicKeyBytes);\n  }\n\n  /**\n   * Derive a program address from seeds and a program ID.\n   */\n  /* eslint-disable require-await */\n  static createProgramAddressSync(seeds, programId) {\n    let buffer$1 = buffer.Buffer.alloc(0);\n    seeds.forEach(function (seed) {\n      if (seed.length > MAX_SEED_LENGTH) {\n        throw new TypeError(`Max seed length exceeded`);\n      }\n      buffer$1 = buffer.Buffer.concat([buffer$1, toBuffer(seed)]);\n    });\n    buffer$1 = buffer.Buffer.concat([buffer$1, programId.toBuffer(), buffer.Buffer.from('ProgramDerivedAddress')]);\n    const publicKeyBytes = sha256.sha256(buffer$1);\n    if (isOnCurve(publicKeyBytes)) {\n      throw new Error(`Invalid seeds, address must fall off the curve`);\n    }\n    return new PublicKey(publicKeyBytes);\n  }\n\n  /**\n   * Async version of createProgramAddressSync\n   * For backwards compatibility\n   *\n   * @deprecated Use {@link createProgramAddressSync} instead\n   */\n  /* eslint-disable require-await */\n  static async createProgramAddress(seeds, programId) {\n    return this.createProgramAddressSync(seeds, programId);\n  }\n\n  /**\n   * Find a valid program address\n   *\n   * Valid program addresses must fall off the ed25519 curve.  This function\n   * iterates a nonce until it finds one that when combined with the seeds\n   * results in a valid program address.\n   */\n  static findProgramAddressSync(seeds, programId) {\n    let nonce = 255;\n    let address;\n    while (nonce != 0) {\n      try {\n        const seedsWithNonce = seeds.concat(buffer.Buffer.from([nonce]));\n        address = this.createProgramAddressSync(seedsWithNonce, programId);\n      } catch (err) {\n        if (err instanceof TypeError) {\n          throw err;\n        }\n        nonce--;\n        continue;\n      }\n      return [address, nonce];\n    }\n    throw new Error(`Unable to find a viable program address nonce`);\n  }\n\n  /**\n   * Async version of findProgramAddressSync\n   * For backwards compatibility\n   *\n   * @deprecated Use {@link findProgramAddressSync} instead\n   */\n  static async findProgramAddress(seeds, programId) {\n    return this.findProgramAddressSync(seeds, programId);\n  }\n\n  /**\n   * Check that a pubkey is on the ed25519 curve.\n   */\n  static isOnCurve(pubkeyData) {\n    const pubkey = new PublicKey(pubkeyData);\n    return isOnCurve(pubkey.toBytes());\n  }\n}\n_class = PublicKey;\nPublicKey.default = new _class('11111111111111111111111111111111');\nSOLANA_SCHEMA.set(PublicKey, {\n  kind: 'struct',\n  fields: [['_bn', 'u256']]\n});\n\n/**\n * An account key pair (public and secret keys).\n *\n * @deprecated since v1.10.0, please use {@link Keypair} instead.\n */\nclass Account {\n  /**\n   * Create a new Account object\n   *\n   * If the secretKey parameter is not provided a new key pair is randomly\n   * created for the account\n   *\n   * @param secretKey Secret key for the account\n   */\n  constructor(secretKey) {\n    /** @internal */\n    this._publicKey = void 0;\n    /** @internal */\n    this._secretKey = void 0;\n    if (secretKey) {\n      const secretKeyBuffer = toBuffer(secretKey);\n      if (secretKey.length !== 64) {\n        throw new Error('bad secret key size');\n      }\n      this._publicKey = secretKeyBuffer.slice(32, 64);\n      this._secretKey = secretKeyBuffer.slice(0, 32);\n    } else {\n      this._secretKey = toBuffer(generatePrivateKey());\n      this._publicKey = toBuffer(getPublicKey(this._secretKey));\n    }\n  }\n\n  /**\n   * The public key for this account\n   */\n  get publicKey() {\n    return new PublicKey(this._publicKey);\n  }\n\n  /**\n   * The **unencrypted** secret key for this account. The first 32 bytes\n   * is the private scalar and the last 32 bytes is the public key.\n   * Read more: https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/\n   */\n  get secretKey() {\n    return buffer.Buffer.concat([this._secretKey, this._publicKey], 64);\n  }\n}\n\nconst BPF_LOADER_DEPRECATED_PROGRAM_ID = new PublicKey('BPFLoader1111111111111111111111111111111111');\n\n/**\n * Maximum over-the-wire size of a Transaction\n *\n * 1280 is IPv6 minimum MTU\n * 40 bytes is the size of the IPv6 header\n * 8 bytes is the size of the fragment header\n */\nconst PACKET_DATA_SIZE = 1280 - 40 - 8;\nconst VERSION_PREFIX_MASK = 0x7f;\nconst SIGNATURE_LENGTH_IN_BYTES = 64;\n\nclass TransactionExpiredBlockheightExceededError extends Error {\n  constructor(signature) {\n    super(`Signature ${signature} has expired: block height exceeded.`);\n    this.signature = void 0;\n    this.signature = signature;\n  }\n}\nObject.defineProperty(TransactionExpiredBlockheightExceededError.prototype, 'name', {\n  value: 'TransactionExpiredBlockheightExceededError'\n});\nclass TransactionExpiredTimeoutError extends Error {\n  constructor(signature, timeoutSeconds) {\n    super(`Transaction was not confirmed in ${timeoutSeconds.toFixed(2)} seconds. It is ` + 'unknown if it succeeded or failed. Check signature ' + `${signature} using the Solana Explorer or CLI tools.`);\n    this.signature = void 0;\n    this.signature = signature;\n  }\n}\nObject.defineProperty(TransactionExpiredTimeoutError.prototype, 'name', {\n  value: 'TransactionExpiredTimeoutError'\n});\nclass TransactionExpiredNonceInvalidError extends Error {\n  constructor(signature) {\n    super(`Signature ${signature} has expired: the nonce is no longer valid.`);\n    this.signature = void 0;\n    this.signature = signature;\n  }\n}\nObject.defineProperty(TransactionExpiredNonceInvalidError.prototype, 'name', {\n  value: 'TransactionExpiredNonceInvalidError'\n});\n\nclass MessageAccountKeys {\n  constructor(staticAccountKeys, accountKeysFromLookups) {\n    this.staticAccountKeys = void 0;\n    this.accountKeysFromLookups = void 0;\n    this.staticAccountKeys = staticAccountKeys;\n    this.accountKeysFromLookups = accountKeysFromLookups;\n  }\n  keySegments() {\n    const keySegments = [this.staticAccountKeys];\n    if (this.accountKeysFromLookups) {\n      keySegments.push(this.accountKeysFromLookups.writable);\n      keySegments.push(this.accountKeysFromLookups.readonly);\n    }\n    return keySegments;\n  }\n  get(index) {\n    for (const keySegment of this.keySegments()) {\n      if (index < keySegment.length) {\n        return keySegment[index];\n      } else {\n        index -= keySegment.length;\n      }\n    }\n    return;\n  }\n  get length() {\n    return this.keySegments().flat().length;\n  }\n  compileInstructions(instructions) {\n    // Bail early if any account indexes would overflow a u8\n    const U8_MAX = 255;\n    if (this.length > U8_MAX + 1) {\n      throw new Error('Account index overflow encountered during compilation');\n    }\n    const keyIndexMap = new Map();\n    this.keySegments().flat().forEach((key, index) => {\n      keyIndexMap.set(key.toBase58(), index);\n    });\n    const findKeyIndex = key => {\n      const keyIndex = keyIndexMap.get(key.toBase58());\n      if (keyIndex === undefined) throw new Error('Encountered an unknown instruction account key during compilation');\n      return keyIndex;\n    };\n    return instructions.map(instruction => {\n      return {\n        programIdIndex: findKeyIndex(instruction.programId),\n        accountKeyIndexes: instruction.keys.map(meta => findKeyIndex(meta.pubkey)),\n        data: instruction.data\n      };\n    });\n  }\n}\n\n/**\n * Layout for a public key\n */\nconst publicKey = (property = 'publicKey') => {\n  return BufferLayout__namespace.blob(32, property);\n};\n\n/**\n * Layout for a signature\n */\nconst signature = (property = 'signature') => {\n  return BufferLayout__namespace.blob(64, property);\n};\n/**\n * Layout for a Rust String type\n */\nconst rustString = (property = 'string') => {\n  const rsl = BufferLayout__namespace.struct([BufferLayout__namespace.u32('length'), BufferLayout__namespace.u32('lengthPadding'), BufferLayout__namespace.blob(BufferLayout__namespace.offset(BufferLayout__namespace.u32(), -8), 'chars')], property);\n  const _decode = rsl.decode.bind(rsl);\n  const _encode = rsl.encode.bind(rsl);\n  const rslShim = rsl;\n  rslShim.decode = (b, offset) => {\n    const data = _decode(b, offset);\n    return data['chars'].toString();\n  };\n  rslShim.encode = (str, b, offset) => {\n    const data = {\n      chars: buffer.Buffer.from(str, 'utf8')\n    };\n    return _encode(data, b, offset);\n  };\n  rslShim.alloc = str => {\n    return BufferLayout__namespace.u32().span + BufferLayout__namespace.u32().span + buffer.Buffer.from(str, 'utf8').length;\n  };\n  return rslShim;\n};\n\n/**\n * Layout for an Authorized object\n */\nconst authorized = (property = 'authorized') => {\n  return BufferLayout__namespace.struct([publicKey('staker'), publicKey('withdrawer')], property);\n};\n\n/**\n * Layout for a Lockup object\n */\nconst lockup = (property = 'lockup') => {\n  return BufferLayout__namespace.struct([BufferLayout__namespace.ns64('unixTimestamp'), BufferLayout__namespace.ns64('epoch'), publicKey('custodian')], property);\n};\n\n/**\n *  Layout for a VoteInit object\n */\nconst voteInit = (property = 'voteInit') => {\n  return BufferLayout__namespace.struct([publicKey('nodePubkey'), publicKey('authorizedVoter'), publicKey('authorizedWithdrawer'), BufferLayout__namespace.u8('commission')], property);\n};\n\n/**\n *  Layout for a VoteAuthorizeWithSeedArgs object\n */\nconst voteAuthorizeWithSeedArgs = (property = 'voteAuthorizeWithSeedArgs') => {\n  return BufferLayout__namespace.struct([BufferLayout__namespace.u32('voteAuthorizationType'), publicKey('currentAuthorityDerivedKeyOwnerPubkey'), rustString('currentAuthorityDerivedKeySeed'), publicKey('newAuthorized')], property);\n};\nfunction getAlloc(type, fields) {\n  const getItemAlloc = item => {\n    if (item.span >= 0) {\n      return item.span;\n    } else if (typeof item.alloc === 'function') {\n      return item.alloc(fields[item.property]);\n    } else if ('count' in item && 'elementLayout' in item) {\n      const field = fields[item.property];\n      if (Array.isArray(field)) {\n        return field.length * getItemAlloc(item.elementLayout);\n      }\n    } else if ('fields' in item) {\n      // This is a `Structure` whose size needs to be recursively measured.\n      return getAlloc({\n        layout: item\n      }, fields[item.property]);\n    }\n    // Couldn't determine allocated size of layout\n    return 0;\n  };\n  let alloc = 0;\n  type.layout.fields.forEach(item => {\n    alloc += getItemAlloc(item);\n  });\n  return alloc;\n}\n\nfunction decodeLength(bytes) {\n  let len = 0;\n  let size = 0;\n  for (;;) {\n    let elem = bytes.shift();\n    len |= (elem & 0x7f) << size * 7;\n    size += 1;\n    if ((elem & 0x80) === 0) {\n      break;\n    }\n  }\n  return len;\n}\nfunction encodeLength(bytes, len) {\n  let rem_len = len;\n  for (;;) {\n    let elem = rem_len & 0x7f;\n    rem_len >>= 7;\n    if (rem_len == 0) {\n      bytes.push(elem);\n      break;\n    } else {\n      elem |= 0x80;\n      bytes.push(elem);\n    }\n  }\n}\n\nfunction assert (condition, message) {\n  if (!condition) {\n    throw new Error(message || 'Assertion failed');\n  }\n}\n\nclass CompiledKeys {\n  constructor(payer, keyMetaMap) {\n    this.payer = void 0;\n    this.keyMetaMap = void 0;\n    this.payer = payer;\n    this.keyMetaMap = keyMetaMap;\n  }\n  static compile(instructions, payer) {\n    const keyMetaMap = new Map();\n    const getOrInsertDefault = pubkey => {\n      const address = pubkey.toBase58();\n      let keyMeta = keyMetaMap.get(address);\n      if (keyMeta === undefined) {\n        keyMeta = {\n          isSigner: false,\n          isWritable: false,\n          isInvoked: false\n        };\n        keyMetaMap.set(address, keyMeta);\n      }\n      return keyMeta;\n    };\n    const payerKeyMeta = getOrInsertDefault(payer);\n    payerKeyMeta.isSigner = true;\n    payerKeyMeta.isWritable = true;\n    for (const ix of instructions) {\n      getOrInsertDefault(ix.programId).isInvoked = true;\n      for (const accountMeta of ix.keys) {\n        const keyMeta = getOrInsertDefault(accountMeta.pubkey);\n        keyMeta.isSigner ||= accountMeta.isSigner;\n        keyMeta.isWritable ||= accountMeta.isWritable;\n      }\n    }\n    return new CompiledKeys(payer, keyMetaMap);\n  }\n  getMessageComponents() {\n    const mapEntries = [...this.keyMetaMap.entries()];\n    assert(mapEntries.length <= 256, 'Max static account keys length exceeded');\n    const writableSigners = mapEntries.filter(([, meta]) => meta.isSigner && meta.isWritable);\n    const readonlySigners = mapEntries.filter(([, meta]) => meta.isSigner && !meta.isWritable);\n    const writableNonSigners = mapEntries.filter(([, meta]) => !meta.isSigner && meta.isWritable);\n    const readonlyNonSigners = mapEntries.filter(([, meta]) => !meta.isSigner && !meta.isWritable);\n    const header = {\n      numRequiredSignatures: writableSigners.length + readonlySigners.length,\n      numReadonlySignedAccounts: readonlySigners.length,\n      numReadonlyUnsignedAccounts: readonlyNonSigners.length\n    };\n\n    // sanity checks\n    {\n      assert(writableSigners.length > 0, 'Expected at least one writable signer key');\n      const [payerAddress] = writableSigners[0];\n      assert(payerAddress === this.payer.toBase58(), 'Expected first writable signer key to be the fee payer');\n    }\n    const staticAccountKeys = [...writableSigners.map(([address]) => new PublicKey(address)), ...readonlySigners.map(([address]) => new PublicKey(address)), ...writableNonSigners.map(([address]) => new PublicKey(address)), ...readonlyNonSigners.map(([address]) => new PublicKey(address))];\n    return [header, staticAccountKeys];\n  }\n  extractTableLookup(lookupTable) {\n    const [writableIndexes, drainedWritableKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, keyMeta => !keyMeta.isSigner && !keyMeta.isInvoked && keyMeta.isWritable);\n    const [readonlyIndexes, drainedReadonlyKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, keyMeta => !keyMeta.isSigner && !keyMeta.isInvoked && !keyMeta.isWritable);\n\n    // Don't extract lookup if no keys were found\n    if (writableIndexes.length === 0 && readonlyIndexes.length === 0) {\n      return;\n    }\n    return [{\n      accountKey: lookupTable.key,\n      writableIndexes,\n      readonlyIndexes\n    }, {\n      writable: drainedWritableKeys,\n      readonly: drainedReadonlyKeys\n    }];\n  }\n\n  /** @internal */\n  drainKeysFoundInLookupTable(lookupTableEntries, keyMetaFilter) {\n    const lookupTableIndexes = new Array();\n    const drainedKeys = new Array();\n    for (const [address, keyMeta] of this.keyMetaMap.entries()) {\n      if (keyMetaFilter(keyMeta)) {\n        const key = new PublicKey(address);\n        const lookupTableIndex = lookupTableEntries.findIndex(entry => entry.equals(key));\n        if (lookupTableIndex >= 0) {\n          assert(lookupTableIndex < 256, 'Max lookup table index exceeded');\n          lookupTableIndexes.push(lookupTableIndex);\n          drainedKeys.push(key);\n          this.keyMetaMap.delete(address);\n        }\n      }\n    }\n    return [lookupTableIndexes, drainedKeys];\n  }\n}\n\nconst END_OF_BUFFER_ERROR_MESSAGE = 'Reached end of buffer unexpectedly';\n\n/**\n * Delegates to `Array#shift`, but throws if the array is zero-length.\n */\nfunction guardedShift(byteArray) {\n  if (byteArray.length === 0) {\n    throw new Error(END_OF_BUFFER_ERROR_MESSAGE);\n  }\n  return byteArray.shift();\n}\n\n/**\n * Delegates to `Array#splice`, but throws if the section being spliced out extends past the end of\n * the array.\n */\nfunction guardedSplice(byteArray, ...args) {\n  const [start] = args;\n  if (args.length === 2 // Implies that `deleteCount` was supplied\n  ? start + (args[1] ?? 0) > byteArray.length : start >= byteArray.length) {\n    throw new Error(END_OF_BUFFER_ERROR_MESSAGE);\n  }\n  return byteArray.splice(...args);\n}\n\n/**\n * An instruction to execute by a program\n *\n * @property {number} programIdIndex\n * @property {number[]} accounts\n * @property {string} data\n */\n\n/**\n * Message constructor arguments\n */\n\n/**\n * List of instructions to be processed atomically\n */\nclass Message {\n  constructor(args) {\n    this.header = void 0;\n    this.accountKeys = void 0;\n    this.recentBlockhash = void 0;\n    this.instructions = void 0;\n    this.indexToProgramIds = new Map();\n    this.header = args.header;\n    this.accountKeys = args.accountKeys.map(account => new PublicKey(account));\n    this.recentBlockhash = args.recentBlockhash;\n    this.instructions = args.instructions;\n    this.instructions.forEach(ix => this.indexToProgramIds.set(ix.programIdIndex, this.accountKeys[ix.programIdIndex]));\n  }\n  get version() {\n    return 'legacy';\n  }\n  get staticAccountKeys() {\n    return this.accountKeys;\n  }\n  get compiledInstructions() {\n    return this.instructions.map(ix => ({\n      programIdIndex: ix.programIdIndex,\n      accountKeyIndexes: ix.accounts,\n      data: bs58__default.default.decode(ix.data)\n    }));\n  }\n  get addressTableLookups() {\n    return [];\n  }\n  getAccountKeys() {\n    return new MessageAccountKeys(this.staticAccountKeys);\n  }\n  static compile(args) {\n    const compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);\n    const [header, staticAccountKeys] = compiledKeys.getMessageComponents();\n    const accountKeys = new MessageAccountKeys(staticAccountKeys);\n    const instructions = accountKeys.compileInstructions(args.instructions).map(ix => ({\n      programIdIndex: ix.programIdIndex,\n      accounts: ix.accountKeyIndexes,\n      data: bs58__default.default.encode(ix.data)\n    }));\n    return new Message({\n      header,\n      accountKeys: staticAccountKeys,\n      recentBlockhash: args.recentBlockhash,\n      instructions\n    });\n  }\n  isAccountSigner(index) {\n    return index < this.header.numRequiredSignatures;\n  }\n  isAccountWritable(index) {\n    const numSignedAccounts = this.header.numRequiredSignatures;\n    if (index >= this.header.numRequiredSignatures) {\n      const unsignedAccountIndex = index - numSignedAccounts;\n      const numUnsignedAccounts = this.accountKeys.length - numSignedAccounts;\n      const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;\n      return unsignedAccountIndex < numWritableUnsignedAccounts;\n    } else {\n      const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;\n      return index < numWritableSignedAccounts;\n    }\n  }\n  isProgramId(index) {\n    return this.indexToProgramIds.has(index);\n  }\n  programIds() {\n    return [...this.indexToProgramIds.values()];\n  }\n  nonProgramIds() {\n    return this.accountKeys.filter((_, index) => !this.isProgramId(index));\n  }\n  serialize() {\n    const numKeys = this.accountKeys.length;\n    let keyCount = [];\n    encodeLength(keyCount, numKeys);\n    const instructions = this.instructions.map(instruction => {\n      const {\n        accounts,\n        programIdIndex\n      } = instruction;\n      const data = Array.from(bs58__default.default.decode(instruction.data));\n      let keyIndicesCount = [];\n      encodeLength(keyIndicesCount, accounts.length);\n      let dataCount = [];\n      encodeLength(dataCount, data.length);\n      return {\n        programIdIndex,\n        keyIndicesCount: buffer.Buffer.from(keyIndicesCount),\n        keyIndices: accounts,\n        dataLength: buffer.Buffer.from(dataCount),\n        data\n      };\n    });\n    let instructionCount = [];\n    encodeLength(instructionCount, instructions.length);\n    let instructionBuffer = buffer.Buffer.alloc(PACKET_DATA_SIZE);\n    buffer.Buffer.from(instructionCount).copy(instructionBuffer);\n    let instructionBufferLength = instructionCount.length;\n    instructions.forEach(instruction => {\n      const instructionLayout = BufferLayout__namespace.struct([BufferLayout__namespace.u8('programIdIndex'), BufferLayout__namespace.blob(instruction.keyIndicesCount.length, 'keyIndicesCount'), BufferLayout__namespace.seq(BufferLayout__namespace.u8('keyIndex'), instruction.keyIndices.length, 'keyIndices'), BufferLayout__namespace.blob(instruction.dataLength.length, 'dataLength'), BufferLayout__namespace.seq(BufferLayout__namespace.u8('userdatum'), instruction.data.length, 'data')]);\n      const length = instructionLayout.encode(instruction, instructionBuffer, instructionBufferLength);\n      instructionBufferLength += length;\n    });\n    instructionBuffer = instructionBuffer.slice(0, instructionBufferLength);\n    const signDataLayout = BufferLayout__namespace.struct([BufferLayout__namespace.blob(1, 'numRequiredSignatures'), BufferLayout__namespace.blob(1, 'numReadonlySignedAccounts'), BufferLayout__namespace.blob(1, 'numReadonlyUnsignedAccounts'), BufferLayout__namespace.blob(keyCount.length, 'keyCount'), BufferLayout__namespace.seq(publicKey('key'), numKeys, 'keys'), publicKey('recentBlockhash')]);\n    const transaction = {\n      numRequiredSignatures: buffer.Buffer.from([this.header.numRequiredSignatures]),\n      numReadonlySignedAccounts: buffer.Buffer.from([this.header.numReadonlySignedAccounts]),\n      numReadonlyUnsignedAccounts: buffer.Buffer.from([this.header.numReadonlyUnsignedAccounts]),\n      keyCount: buffer.Buffer.from(keyCount),\n      keys: this.accountKeys.map(key => toBuffer(key.toBytes())),\n      recentBlockhash: bs58__default.default.decode(this.recentBlockhash)\n    };\n    let signData = buffer.Buffer.alloc(2048);\n    const length = signDataLayout.encode(transaction, signData);\n    instructionBuffer.copy(signData, length);\n    return signData.slice(0, length + instructionBuffer.length);\n  }\n\n  /**\n   * Decode a compiled message into a Message object.\n   */\n  static from(buffer$1) {\n    // Slice up wire data\n    let byteArray = [...buffer$1];\n    const numRequiredSignatures = guardedShift(byteArray);\n    if (numRequiredSignatures !== (numRequiredSignatures & VERSION_PREFIX_MASK)) {\n      throw new Error('Versioned messages must be deserialized with VersionedMessage.deserialize()');\n    }\n    const numReadonlySignedAccounts = guardedShift(byteArray);\n    const numReadonlyUnsignedAccounts = guardedShift(byteArray);\n    const accountCount = decodeLength(byteArray);\n    let accountKeys = [];\n    for (let i = 0; i < accountCount; i++) {\n      const account = guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH);\n      accountKeys.push(new PublicKey(buffer.Buffer.from(account)));\n    }\n    const recentBlockhash = guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH);\n    const instructionCount = decodeLength(byteArray);\n    let instructions = [];\n    for (let i = 0; i < instructionCount; i++) {\n      const programIdIndex = guardedShift(byteArray);\n      const accountCount = decodeLength(byteArray);\n      const accounts = guardedSplice(byteArray, 0, accountCount);\n      const dataLength = decodeLength(byteArray);\n      const dataSlice = guardedSplice(byteArray, 0, dataLength);\n      const data = bs58__default.default.encode(buffer.Buffer.from(dataSlice));\n      instructions.push({\n        programIdIndex,\n        accounts,\n        data\n      });\n    }\n    const messageArgs = {\n      header: {\n        numRequiredSignatures,\n        numReadonlySignedAccounts,\n        numReadonlyUnsignedAccounts\n      },\n      recentBlockhash: bs58__default.default.encode(buffer.Buffer.from(recentBlockhash)),\n      accountKeys,\n      instructions\n    };\n    return new Message(messageArgs);\n  }\n}\n\n/**\n * Message constructor arguments\n */\n\nclass MessageV0 {\n  constructor(args) {\n    this.header = void 0;\n    this.staticAccountKeys = void 0;\n    this.recentBlockhash = void 0;\n    this.compiledInstructions = void 0;\n    this.addressTableLookups = void 0;\n    this.header = args.header;\n    this.staticAccountKeys = args.staticAccountKeys;\n    this.recentBlockhash = args.recentBlockhash;\n    this.compiledInstructions = args.compiledInstructions;\n    this.addressTableLookups = args.addressTableLookups;\n  }\n  get version() {\n    return 0;\n  }\n  get numAccountKeysFromLookups() {\n    let count = 0;\n    for (const lookup of this.addressTableLookups) {\n      count += lookup.readonlyIndexes.length + lookup.writableIndexes.length;\n    }\n    return count;\n  }\n  getAccountKeys(args) {\n    let accountKeysFromLookups;\n    if (args && 'accountKeysFromLookups' in args && args.accountKeysFromLookups) {\n      if (this.numAccountKeysFromLookups != args.accountKeysFromLookups.writable.length + args.accountKeysFromLookups.readonly.length) {\n        throw new Error('Failed to get account keys because of a mismatch in the number of account keys from lookups');\n      }\n      accountKeysFromLookups = args.accountKeysFromLookups;\n    } else if (args && 'addressLookupTableAccounts' in args && args.addressLookupTableAccounts) {\n      accountKeysFromLookups = this.resolveAddressTableLookups(args.addressLookupTableAccounts);\n    } else if (this.addressTableLookups.length > 0) {\n      throw new Error('Failed to get account keys because address table lookups were not resolved');\n    }\n    return new MessageAccountKeys(this.staticAccountKeys, accountKeysFromLookups);\n  }\n  isAccountSigner(index) {\n    return index < this.header.numRequiredSignatures;\n  }\n  isAccountWritable(index) {\n    const numSignedAccounts = this.header.numRequiredSignatures;\n    const numStaticAccountKeys = this.staticAccountKeys.length;\n    if (index >= numStaticAccountKeys) {\n      const lookupAccountKeysIndex = index - numStaticAccountKeys;\n      const numWritableLookupAccountKeys = this.addressTableLookups.reduce((count, lookup) => count + lookup.writableIndexes.length, 0);\n      return lookupAccountKeysIndex < numWritableLookupAccountKeys;\n    } else if (index >= this.header.numRequiredSignatures) {\n      const unsignedAccountIndex = index - numSignedAccounts;\n      const numUnsignedAccounts = numStaticAccountKeys - numSignedAccounts;\n      const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;\n      return unsignedAccountIndex < numWritableUnsignedAccounts;\n    } else {\n      const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;\n      return index < numWritableSignedAccounts;\n    }\n  }\n  resolveAddressTableLookups(addressLookupTableAccounts) {\n    const accountKeysFromLookups = {\n      writable: [],\n      readonly: []\n    };\n    for (const tableLookup of this.addressTableLookups) {\n      const tableAccount = addressLookupTableAccounts.find(account => account.key.equals(tableLookup.accountKey));\n      if (!tableAccount) {\n        throw new Error(`Failed to find address lookup table account for table key ${tableLookup.accountKey.toBase58()}`);\n      }\n      for (const index of tableLookup.writableIndexes) {\n        if (index < tableAccount.state.addresses.length) {\n          accountKeysFromLookups.writable.push(tableAccount.state.addresses[index]);\n        } else {\n          throw new Error(`Failed to find address for index ${index} in address lookup table ${tableLookup.accountKey.toBase58()}`);\n        }\n      }\n      for (const index of tableLookup.readonlyIndexes) {\n        if (index < tableAccount.state.addresses.length) {\n          accountKeysFromLookups.readonly.push(tableAccount.state.addresses[index]);\n        } else {\n          throw new Error(`Failed to find address for index ${index} in address lookup table ${tableLookup.accountKey.toBase58()}`);\n        }\n      }\n    }\n    return accountKeysFromLookups;\n  }\n  static compile(args) {\n    const compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);\n    const addressTableLookups = new Array();\n    const accountKeysFromLookups = {\n      writable: new Array(),\n      readonly: new Array()\n    };\n    const lookupTableAccounts = args.addressLookupTableAccounts || [];\n    for (const lookupTable of lookupTableAccounts) {\n      const extractResult = compiledKeys.extractTableLookup(lookupTable);\n      if (extractResult !== undefined) {\n        const [addressTableLookup, {\n          writable,\n          readonly\n        }] = extractResult;\n        addressTableLookups.push(addressTableLookup);\n        accountKeysFromLookups.writable.push(...writable);\n        accountKeysFromLookups.readonly.push(...readonly);\n      }\n    }\n    const [header, staticAccountKeys] = compiledKeys.getMessageComponents();\n    const accountKeys = new MessageAccountKeys(staticAccountKeys, accountKeysFromLookups);\n    const compiledInstructions = accountKeys.compileInstructions(args.instructions);\n    return new MessageV0({\n      header,\n      staticAccountKeys,\n      recentBlockhash: args.recentBlockhash,\n      compiledInstructions,\n      addressTableLookups\n    });\n  }\n  serialize() {\n    const encodedStaticAccountKeysLength = Array();\n    encodeLength(encodedStaticAccountKeysLength, this.staticAccountKeys.length);\n    const serializedInstructions = this.serializeInstructions();\n    const encodedInstructionsLength = Array();\n    encodeLength(encodedInstructionsLength, this.compiledInstructions.length);\n    const serializedAddressTableLookups = this.serializeAddressTableLookups();\n    const encodedAddressTableLookupsLength = Array();\n    encodeLength(encodedAddressTableLookupsLength, this.addressTableLookups.length);\n    const messageLayout = BufferLayout__namespace.struct([BufferLayout__namespace.u8('prefix'), BufferLayout__namespace.struct([BufferLayout__namespace.u8('numRequiredSignatures'), BufferLayout__namespace.u8('numReadonlySignedAccounts'), BufferLayout__namespace.u8('numReadonlyUnsignedAccounts')], 'header'), BufferLayout__namespace.blob(encodedStaticAccountKeysLength.length, 'staticAccountKeysLength'), BufferLayout__namespace.seq(publicKey(), this.staticAccountKeys.length, 'staticAccountKeys'), publicKey('recentBlockhash'), BufferLayout__namespace.blob(encodedInstructionsLength.length, 'instructionsLength'), BufferLayout__namespace.blob(serializedInstructions.length, 'serializedInstructions'), BufferLayout__namespace.blob(encodedAddressTableLookupsLength.length, 'addressTableLookupsLength'), BufferLayout__namespace.blob(serializedAddressTableLookups.length, 'serializedAddressTableLookups')]);\n    const serializedMessage = new Uint8Array(PACKET_DATA_SIZE);\n    const MESSAGE_VERSION_0_PREFIX = 1 << 7;\n    const serializedMessageLength = messageLayout.encode({\n      prefix: MESSAGE_VERSION_0_PREFIX,\n      header: this.header,\n      staticAccountKeysLength: new Uint8Array(encodedStaticAccountKeysLength),\n      staticAccountKeys: this.staticAccountKeys.map(key => key.toBytes()),\n      recentBlockhash: bs58__default.default.decode(this.recentBlockhash),\n      instructionsLength: new Uint8Array(encodedInstructionsLength),\n      serializedInstructions,\n      addressTableLookupsLength: new Uint8Array(encodedAddressTableLookupsLength),\n      serializedAddressTableLookups\n    }, serializedMessage);\n    return serializedMessage.slice(0, serializedMessageLength);\n  }\n  serializeInstructions() {\n    let serializedLength = 0;\n    const serializedInstructions = new Uint8Array(PACKET_DATA_SIZE);\n    for (const instruction of this.compiledInstructions) {\n      const encodedAccountKeyIndexesLength = Array();\n      encodeLength(encodedAccountKeyIndexesLength, instruction.accountKeyIndexes.length);\n      const encodedDataLength = Array();\n      encodeLength(encodedDataLength, instruction.data.length);\n      const instructionLayout = BufferLayout__namespace.struct([BufferLayout__namespace.u8('programIdIndex'), BufferLayout__namespace.blob(encodedAccountKeyIndexesLength.length, 'encodedAccountKeyIndexesLength'), BufferLayout__namespace.seq(BufferLayout__namespace.u8(), instruction.accountKeyIndexes.length, 'accountKeyIndexes'), BufferLayout__namespace.blob(encodedDataLength.length, 'encodedDataLength'), BufferLayout__namespace.blob(instruction.data.length, 'data')]);\n      serializedLength += instructionLayout.encode({\n        programIdIndex: instruction.programIdIndex,\n        encodedAccountKeyIndexesLength: new Uint8Array(encodedAccountKeyIndexesLength),\n        accountKeyIndexes: instruction.accountKeyIndexes,\n        encodedDataLength: new Uint8Array(encodedDataLength),\n        data: instruction.data\n      }, serializedInstructions, serializedLength);\n    }\n    return serializedInstructions.slice(0, serializedLength);\n  }\n  serializeAddressTableLookups() {\n    let serializedLength = 0;\n    const serializedAddressTableLookups = new Uint8Array(PACKET_DATA_SIZE);\n    for (const lookup of this.addressTableLookups) {\n      const encodedWritableIndexesLength = Array();\n      encodeLength(encodedWritableIndexesLength, lookup.writableIndexes.length);\n      const encodedReadonlyIndexesLength = Array();\n      encodeLength(encodedReadonlyIndexesLength, lookup.readonlyIndexes.length);\n      const addressTableLookupLayout = BufferLayout__namespace.struct([publicKey('accountKey'), BufferLayout__namespace.blob(encodedWritableIndexesLength.length, 'encodedWritableIndexesLength'), BufferLayout__namespace.seq(BufferLayout__namespace.u8(), lookup.writableIndexes.length, 'writableIndexes'), BufferLayout__namespace.blob(encodedReadonlyIndexesLength.length, 'encodedReadonlyIndexesLength'), BufferLayout__namespace.seq(BufferLayout__namespace.u8(), lookup.readonlyIndexes.length, 'readonlyIndexes')]);\n      serializedLength += addressTableLookupLayout.encode({\n        accountKey: lookup.accountKey.toBytes(),\n        encodedWritableIndexesLength: new Uint8Array(encodedWritableIndexesLength),\n        writableIndexes: lookup.writableIndexes,\n        encodedReadonlyIndexesLength: new Uint8Array(encodedReadonlyIndexesLength),\n        readonlyIndexes: lookup.readonlyIndexes\n      }, serializedAddressTableLookups, serializedLength);\n    }\n    return serializedAddressTableLookups.slice(0, serializedLength);\n  }\n  static deserialize(serializedMessage) {\n    let byteArray = [...serializedMessage];\n    const prefix = guardedShift(byteArray);\n    const maskedPrefix = prefix & VERSION_PREFIX_MASK;\n    assert(prefix !== maskedPrefix, `Expected versioned message but received legacy message`);\n    const version = maskedPrefix;\n    assert(version === 0, `Expected versioned message with version 0 but found version ${version}`);\n    const header = {\n      numRequiredSignatures: guardedShift(byteArray),\n      numReadonlySignedAccounts: guardedShift(byteArray),\n      numReadonlyUnsignedAccounts: guardedShift(byteArray)\n    };\n    const staticAccountKeys = [];\n    const staticAccountKeysLength = decodeLength(byteArray);\n    for (let i = 0; i < staticAccountKeysLength; i++) {\n      staticAccountKeys.push(new PublicKey(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH)));\n    }\n    const recentBlockhash = bs58__default.default.encode(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH));\n    const instructionCount = decodeLength(byteArray);\n    const compiledInstructions = [];\n    for (let i = 0; i < instructionCount; i++) {\n      const programIdIndex = guardedShift(byteArray);\n      const accountKeyIndexesLength = decodeLength(byteArray);\n      const accountKeyIndexes = guardedSplice(byteArray, 0, accountKeyIndexesLength);\n      const dataLength = decodeLength(byteArray);\n      const data = new Uint8Array(guardedSplice(byteArray, 0, dataLength));\n      compiledInstructions.push({\n        programIdIndex,\n        accountKeyIndexes,\n        data\n      });\n    }\n    const addressTableLookupsCount = decodeLength(byteArray);\n    const addressTableLookups = [];\n    for (let i = 0; i < addressTableLookupsCount; i++) {\n      const accountKey = new PublicKey(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH));\n      const writableIndexesLength = decodeLength(byteArray);\n      const writableIndexes = guardedSplice(byteArray, 0, writableIndexesLength);\n      const readonlyIndexesLength = decodeLength(byteArray);\n      const readonlyIndexes = guardedSplice(byteArray, 0, readonlyIndexesLength);\n      addressTableLookups.push({\n        accountKey,\n        writableIndexes,\n        readonlyIndexes\n      });\n    }\n    return new MessageV0({\n      header,\n      staticAccountKeys,\n      recentBlockhash,\n      compiledInstructions,\n      addressTableLookups\n    });\n  }\n}\n\n// eslint-disable-next-line no-redeclare\nconst VersionedMessage = {\n  deserializeMessageVersion(serializedMessage) {\n    const prefix = serializedMessage[0];\n    const maskedPrefix = prefix & VERSION_PREFIX_MASK;\n\n    // if the highest bit of the prefix is not set, the message is not versioned\n    if (maskedPrefix === prefix) {\n      return 'legacy';\n    }\n\n    // the lower 7 bits of the prefix indicate the message version\n    return maskedPrefix;\n  },\n  deserialize: serializedMessage => {\n    const version = VersionedMessage.deserializeMessageVersion(serializedMessage);\n    if (version === 'legacy') {\n      return Message.from(serializedMessage);\n    }\n    if (version === 0) {\n      return MessageV0.deserialize(serializedMessage);\n    } else {\n      throw new Error(`Transaction message version ${version} deserialization is not supported`);\n    }\n  }\n};\n\n/** @internal */\n\n/**\n * Transaction signature as base-58 encoded string\n */\n\nlet TransactionStatus = /*#__PURE__*/function (TransactionStatus) {\n  TransactionStatus[TransactionStatus[\"BLOCKHEIGHT_EXCEEDED\"] = 0] = \"BLOCKHEIGHT_EXCEEDED\";\n  TransactionStatus[TransactionStatus[\"PROCESSED\"] = 1] = \"PROCESSED\";\n  TransactionStatus[TransactionStatus[\"TIMED_OUT\"] = 2] = \"TIMED_OUT\";\n  TransactionStatus[TransactionStatus[\"NONCE_INVALID\"] = 3] = \"NONCE_INVALID\";\n  return TransactionStatus;\n}({});\n\n/**\n * Default (empty) signature\n */\nconst DEFAULT_SIGNATURE = buffer.Buffer.alloc(SIGNATURE_LENGTH_IN_BYTES).fill(0);\n\n/**\n * Account metadata used to define instructions\n */\n\n/**\n * List of TransactionInstruction object fields that may be initialized at construction\n */\n\n/**\n * Configuration object for Transaction.serialize()\n */\n\n/**\n * @internal\n */\n\n/**\n * Transaction Instruction class\n */\nclass TransactionInstruction {\n  constructor(opts) {\n    /**\n     * Public keys to include in this transaction\n     * Boolean represents whether this pubkey needs to sign the transaction\n     */\n    this.keys = void 0;\n    /**\n     * Program Id to execute\n     */\n    this.programId = void 0;\n    /**\n     * Program input\n     */\n    this.data = buffer.Buffer.alloc(0);\n    this.programId = opts.programId;\n    this.keys = opts.keys;\n    if (opts.data) {\n      this.data = opts.data;\n    }\n  }\n\n  /**\n   * @internal\n   */\n  toJSON() {\n    return {\n      keys: this.keys.map(({\n        pubkey,\n        isSigner,\n        isWritable\n      }) => ({\n        pubkey: pubkey.toJSON(),\n        isSigner,\n        isWritable\n      })),\n      programId: this.programId.toJSON(),\n      data: [...this.data]\n    };\n  }\n}\n\n/**\n * Pair of signature and corresponding public key\n */\n\n/**\n * List of Transaction object fields that may be initialized at construction\n */\n\n// For backward compatibility; an unfortunate consequence of being\n// forced to over-export types by the documentation generator.\n// See https://github.com/solana-labs/solana/pull/25820\n\n/**\n * Blockhash-based transactions have a lifetime that are defined by\n * the blockhash they include. Any transaction whose blockhash is\n * too old will be rejected.\n */\n\n/**\n * Use these options to construct a durable nonce transaction.\n */\n\n/**\n * Nonce information to be used to build an offline Transaction.\n */\n\n/**\n * @internal\n */\n\n/**\n * Transaction class\n */\nclass Transaction {\n  /**\n   * The first (payer) Transaction signature\n   *\n   * @returns {Buffer | null} Buffer of payer's signature\n   */\n  get signature() {\n    if (this.signatures.length > 0) {\n      return this.signatures[0].signature;\n    }\n    return null;\n  }\n\n  /**\n   * The transaction fee payer\n   */\n\n  // Construct a transaction with a blockhash and lastValidBlockHeight\n\n  // Construct a transaction using a durable nonce\n\n  /**\n   * @deprecated `TransactionCtorFields` has been deprecated and will be removed in a future version.\n   * Please supply a `TransactionBlockhashCtor` instead.\n   */\n\n  /**\n   * Construct an empty Transaction\n   */\n  constructor(opts) {\n    /**\n     * Signatures for the transaction.  Typically created by invoking the\n     * `sign()` method\n     */\n    this.signatures = [];\n    this.feePayer = void 0;\n    /**\n     * The instructions to atomically execute\n     */\n    this.instructions = [];\n    /**\n     * A recent transaction id. Must be populated by the caller\n     */\n    this.recentBlockhash = void 0;\n    /**\n     * the last block chain can advance to before tx is declared expired\n     * */\n    this.lastValidBlockHeight = void 0;\n    /**\n     * Optional Nonce information. If populated, transaction will use a durable\n     * Nonce hash instead of a recentBlockhash. Must be populated by the caller\n     */\n    this.nonceInfo = void 0;\n    /**\n     * If this is a nonce transaction this represents the minimum slot from which\n     * to evaluate if the nonce has advanced when attempting to confirm the\n     * transaction. This protects against a case where the transaction confirmation\n     * logic loads the nonce account from an old slot and assumes the mismatch in\n     * nonce value implies that the nonce has been advanced.\n     */\n    this.minNonceContextSlot = void 0;\n    /**\n     * @internal\n     */\n    this._message = void 0;\n    /**\n     * @internal\n     */\n    this._json = void 0;\n    if (!opts) {\n      return;\n    }\n    if (opts.feePayer) {\n      this.feePayer = opts.feePayer;\n    }\n    if (opts.signatures) {\n      this.signatures = opts.signatures;\n    }\n    if (Object.prototype.hasOwnProperty.call(opts, 'nonceInfo')) {\n      const {\n        minContextSlot,\n        nonceInfo\n      } = opts;\n      this.minNonceContextSlot = minContextSlot;\n      this.nonceInfo = nonceInfo;\n    } else if (Object.prototype.hasOwnProperty.call(opts, 'lastValidBlockHeight')) {\n      const {\n        blockhash,\n        lastValidBlockHeight\n      } = opts;\n      this.recentBlockhash = blockhash;\n      this.lastValidBlockHeight = lastValidBlockHeight;\n    } else {\n      const {\n        recentBlockhash,\n        nonceInfo\n      } = opts;\n      if (nonceInfo) {\n        this.nonceInfo = nonceInfo;\n      }\n      this.recentBlockhash = recentBlockhash;\n    }\n  }\n\n  /**\n   * @internal\n   */\n  toJSON() {\n    return {\n      recentBlockhash: this.recentBlockhash || null,\n      feePayer: this.feePayer ? this.feePayer.toJSON() : null,\n      nonceInfo: this.nonceInfo ? {\n        nonce: this.nonceInfo.nonce,\n        nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()\n      } : null,\n      instructions: this.instructions.map(instruction => instruction.toJSON()),\n      signers: this.signatures.map(({\n        publicKey\n      }) => {\n        return publicKey.toJSON();\n      })\n    };\n  }\n\n  /**\n   * Add one or more instructions to this Transaction\n   *\n   * @param {Array< Transaction | TransactionInstruction | TransactionInstructionCtorFields >} items - Instructions to add to the Transaction\n   */\n  add(...items) {\n    if (items.length === 0) {\n      throw new Error('No instructions');\n    }\n    items.forEach(item => {\n      if ('instructions' in item) {\n        this.instructions = this.instructions.concat(item.instructions);\n      } else if ('data' in item && 'programId' in item && 'keys' in item) {\n        this.instructions.push(item);\n      } else {\n        this.instructions.push(new TransactionInstruction(item));\n      }\n    });\n    return this;\n  }\n\n  /**\n   * Compile transaction data\n   */\n  compileMessage() {\n    if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json)) {\n      return this._message;\n    }\n    let recentBlockhash;\n    let instructions;\n    if (this.nonceInfo) {\n      recentBlockhash = this.nonceInfo.nonce;\n      if (this.instructions[0] != this.nonceInfo.nonceInstruction) {\n        instructions = [this.nonceInfo.nonceInstruction, ...this.instructions];\n      } else {\n        instructions = this.instructions;\n      }\n    } else {\n      recentBlockhash = this.recentBlockhash;\n      instructions = this.instructions;\n    }\n    if (!recentBlockhash) {\n      throw new Error('Transaction recentBlockhash required');\n    }\n    if (instructions.length < 1) {\n      console.warn('No instructions provided');\n    }\n    let feePayer;\n    if (this.feePayer) {\n      feePayer = this.feePayer;\n    } else if (this.signatures.length > 0 && this.signatures[0].publicKey) {\n      // Use implicit fee payer\n      feePayer = this.signatures[0].publicKey;\n    } else {\n      throw new Error('Transaction fee payer required');\n    }\n    for (let i = 0; i < instructions.length; i++) {\n      if (instructions[i].programId === undefined) {\n        throw new Error(`Transaction instruction index ${i} has undefined program id`);\n      }\n    }\n    const programIds = [];\n    const accountMetas = [];\n    instructions.forEach(instruction => {\n      instruction.keys.forEach(accountMeta => {\n        accountMetas.push({\n          ...accountMeta\n        });\n      });\n      const programId = instruction.programId.toString();\n      if (!programIds.includes(programId)) {\n        programIds.push(programId);\n      }\n    });\n\n    // Append programID account metas\n    programIds.forEach(programId => {\n      accountMetas.push({\n        pubkey: new PublicKey(programId),\n        isSigner: false,\n        isWritable: false\n      });\n    });\n\n    // Cull duplicate account metas\n    const uniqueMetas = [];\n    accountMetas.forEach(accountMeta => {\n      const pubkeyString = accountMeta.pubkey.toString();\n      const uniqueIndex = uniqueMetas.findIndex(x => {\n        return x.pubkey.toString() === pubkeyString;\n      });\n      if (uniqueIndex > -1) {\n        uniqueMetas[uniqueIndex].isWritable = uniqueMetas[uniqueIndex].isWritable || accountMeta.isWritable;\n        uniqueMetas[uniqueIndex].isSigner = uniqueMetas[uniqueIndex].isSigner || accountMeta.isSigner;\n      } else {\n        uniqueMetas.push(accountMeta);\n      }\n    });\n\n    // Sort. Prioritizing first by signer, then by writable\n    uniqueMetas.sort(function (x, y) {\n      if (x.isSigner !== y.isSigner) {\n        // Signers always come before non-signers\n        return x.isSigner ? -1 : 1;\n      }\n      if (x.isWritable !== y.isWritable) {\n        // Writable accounts always come before read-only accounts\n        return x.isWritable ? -1 : 1;\n      }\n      // Otherwise, sort by pubkey, stringwise.\n      const options = {\n        localeMatcher: 'best fit',\n        usage: 'sort',\n        sensitivity: 'variant',\n        ignorePunctuation: false,\n        numeric: false,\n        caseFirst: 'lower'\n      };\n      return x.pubkey.toBase58().localeCompare(y.pubkey.toBase58(), 'en', options);\n    });\n\n    // Move fee payer to the front\n    const feePayerIndex = uniqueMetas.findIndex(x => {\n      return x.pubkey.equals(feePayer);\n    });\n    if (feePayerIndex > -1) {\n      const [payerMeta] = uniqueMetas.splice(feePayerIndex, 1);\n      payerMeta.isSigner = true;\n      payerMeta.isWritable = true;\n      uniqueMetas.unshift(payerMeta);\n    } else {\n      uniqueMetas.unshift({\n        pubkey: feePayer,\n        isSigner: true,\n        isWritable: true\n      });\n    }\n\n    // Disallow unknown signers\n    for (const signature of this.signatures) {\n      const uniqueIndex = uniqueMetas.findIndex(x => {\n        return x.pubkey.equals(signature.publicKey);\n      });\n      if (uniqueIndex > -1) {\n        if (!uniqueMetas[uniqueIndex].isSigner) {\n          uniqueMetas[uniqueIndex].isSigner = true;\n          console.warn('Transaction references a signature that is unnecessary, ' + 'only the fee payer and instruction signer accounts should sign a transaction. ' + 'This behavior is deprecated and will throw an error in the next major version release.');\n        }\n      } else {\n        throw new Error(`unknown signer: ${signature.publicKey.toString()}`);\n      }\n    }\n    let numRequiredSignatures = 0;\n    let numReadonlySignedAccounts = 0;\n    let numReadonlyUnsignedAccounts = 0;\n\n    // Split out signing from non-signing keys and count header values\n    const signedKeys = [];\n    const unsignedKeys = [];\n    uniqueMetas.forEach(({\n      pubkey,\n      isSigner,\n      isWritable\n    }) => {\n      if (isSigner) {\n        signedKeys.push(pubkey.toString());\n        numRequiredSignatures += 1;\n        if (!isWritable) {\n          numReadonlySignedAccounts += 1;\n        }\n      } else {\n        unsignedKeys.push(pubkey.toString());\n        if (!isWritable) {\n          numReadonlyUnsignedAccounts += 1;\n        }\n      }\n    });\n    const accountKeys = signedKeys.concat(unsignedKeys);\n    const compiledInstructions = instructions.map(instruction => {\n      const {\n        data,\n        programId\n      } = instruction;\n      return {\n        programIdIndex: accountKeys.indexOf(programId.toString()),\n        accounts: instruction.keys.map(meta => accountKeys.indexOf(meta.pubkey.toString())),\n        data: bs58__default.default.encode(data)\n      };\n    });\n    compiledInstructions.forEach(instruction => {\n      assert(instruction.programIdIndex >= 0);\n      instruction.accounts.forEach(keyIndex => assert(keyIndex >= 0));\n    });\n    return new Message({\n      header: {\n        numRequiredSignatures,\n        numReadonlySignedAccounts,\n        numReadonlyUnsignedAccounts\n      },\n      accountKeys,\n      recentBlockhash,\n      instructions: compiledInstructions\n    });\n  }\n\n  /**\n   * @internal\n   */\n  _compile() {\n    const message = this.compileMessage();\n    const signedKeys = message.accountKeys.slice(0, message.header.numRequiredSignatures);\n    if (this.signatures.length === signedKeys.length) {\n      const valid = this.signatures.every((pair, index) => {\n        return signedKeys[index].equals(pair.publicKey);\n      });\n      if (valid) return message;\n    }\n    this.signatures = signedKeys.map(publicKey => ({\n      signature: null,\n      publicKey\n    }));\n    return message;\n  }\n\n  /**\n   * Get a buffer of the Transaction data that need to be covered by signatures\n   */\n  serializeMessage() {\n    return this._compile().serialize();\n  }\n\n  /**\n   * Get the estimated fee associated with a transaction\n   *\n   * @param {Connection} connection Connection to RPC Endpoint.\n   *\n   * @returns {Promise<number | null>} The estimated fee for the transaction\n   */\n  async getEstimatedFee(connection) {\n    return (await connection.getFeeForMessage(this.compileMessage())).value;\n  }\n\n  /**\n   * Specify the public keys which will be used to sign the Transaction.\n   * The first signer will be used as the transaction fee payer account.\n   *\n   * Signatures can be added with either `partialSign` or `addSignature`\n   *\n   * @deprecated Deprecated since v0.84.0. Only the fee payer needs to be\n   * specified and it can be set in the Transaction constructor or with the\n   * `feePayer` property.\n   */\n  setSigners(...signers) {\n    if (signers.length === 0) {\n      throw new Error('No signers');\n    }\n    const seen = new Set();\n    this.signatures = signers.filter(publicKey => {\n      const key = publicKey.toString();\n      if (seen.has(key)) {\n        return false;\n      } else {\n        seen.add(key);\n        return true;\n      }\n    }).map(publicKey => ({\n      signature: null,\n      publicKey\n    }));\n  }\n\n  /**\n   * Sign the Transaction with the specified signers. Multiple signatures may\n   * be applied to a Transaction. The first signature is considered \"primary\"\n   * and is used identify and confirm transactions.\n   *\n   * If the Transaction `feePayer` is not set, the first signer will be used\n   * as the transaction fee payer account.\n   *\n   * Transaction fields should not be modified after the first call to `sign`,\n   * as doing so may invalidate the signature and cause the Transaction to be\n   * rejected.\n   *\n   * The Transaction must be assigned a valid `recentBlockhash` before invoking this method\n   *\n   * @param {Array<Signer>} signers Array of signers that will sign the transaction\n   */\n  sign(...signers) {\n    if (signers.length === 0) {\n      throw new Error('No signers');\n    }\n\n    // Dedupe signers\n    const seen = new Set();\n    const uniqueSigners = [];\n    for (const signer of signers) {\n      const key = signer.publicKey.toString();\n      if (seen.has(key)) {\n        continue;\n      } else {\n        seen.add(key);\n        uniqueSigners.push(signer);\n      }\n    }\n    this.signatures = uniqueSigners.map(signer => ({\n      signature: null,\n      publicKey: signer.publicKey\n    }));\n    const message = this._compile();\n    this._partialSign(message, ...uniqueSigners);\n  }\n\n  /**\n   * Partially sign a transaction with the specified accounts. All accounts must\n   * correspond to either the fee payer or a signer account in the transaction\n   * instructions.\n   *\n   * All the caveats from the `sign` method apply to `partialSign`\n   *\n   * @param {Array<Signer>} signers Array of signers that will sign the transaction\n   */\n  partialSign(...signers) {\n    if (signers.length === 0) {\n      throw new Error('No signers');\n    }\n\n    // Dedupe signers\n    const seen = new Set();\n    const uniqueSigners = [];\n    for (const signer of signers) {\n      const key = signer.publicKey.toString();\n      if (seen.has(key)) {\n        continue;\n      } else {\n        seen.add(key);\n        uniqueSigners.push(signer);\n      }\n    }\n    const message = this._compile();\n    this._partialSign(message, ...uniqueSigners);\n  }\n\n  /**\n   * @internal\n   */\n  _partialSign(message, ...signers) {\n    const signData = message.serialize();\n    signers.forEach(signer => {\n      const signature = sign(signData, signer.secretKey);\n      this._addSignature(signer.publicKey, toBuffer(signature));\n    });\n  }\n\n  /**\n   * Add an externally created signature to a transaction. The public key\n   * must correspond to either the fee payer or a signer account in the transaction\n   * instructions.\n   *\n   * @param {PublicKey} pubkey Public key that will be added to the transaction.\n   * @param {Buffer} signature An externally created signature to add to the transaction.\n   */\n  addSignature(pubkey, signature) {\n    this._compile(); // Ensure signatures array is populated\n    this._addSignature(pubkey, signature);\n  }\n\n  /**\n   * @internal\n   */\n  _addSignature(pubkey, signature) {\n    assert(signature.length === 64);\n    const index = this.signatures.findIndex(sigpair => pubkey.equals(sigpair.publicKey));\n    if (index < 0) {\n      throw new Error(`unknown signer: ${pubkey.toString()}`);\n    }\n    this.signatures[index].signature = buffer.Buffer.from(signature);\n  }\n\n  /**\n   * Verify signatures of a Transaction\n   * Optional parameter specifies if we're expecting a fully signed Transaction or a partially signed one.\n   * If no boolean is provided, we expect a fully signed Transaction by default.\n   *\n   * @param {boolean} [requireAllSignatures=true] Require a fully signed Transaction\n   */\n  verifySignatures(requireAllSignatures = true) {\n    const signatureErrors = this._getMessageSignednessErrors(this.serializeMessage(), requireAllSignatures);\n    return !signatureErrors;\n  }\n\n  /**\n   * @internal\n   */\n  _getMessageSignednessErrors(message, requireAllSignatures) {\n    const errors = {};\n    for (const {\n      signature,\n      publicKey\n    } of this.signatures) {\n      if (signature === null) {\n        if (requireAllSignatures) {\n          (errors.missing ||= []).push(publicKey);\n        }\n      } else {\n        if (!verify(signature, message, publicKey.toBytes())) {\n          (errors.invalid ||= []).push(publicKey);\n        }\n      }\n    }\n    return errors.invalid || errors.missing ? errors : undefined;\n  }\n\n  /**\n   * Serialize the Transaction in the wire format.\n   *\n   * @param {Buffer} [config] Config of transaction.\n   *\n   * @returns {Buffer} Signature of transaction in wire format.\n   */\n  serialize(config) {\n    const {\n      requireAllSignatures,\n      verifySignatures\n    } = Object.assign({\n      requireAllSignatures: true,\n      verifySignatures: true\n    }, config);\n    const signData = this.serializeMessage();\n    if (verifySignatures) {\n      const sigErrors = this._getMessageSignednessErrors(signData, requireAllSignatures);\n      if (sigErrors) {\n        let errorMessage = 'Signature verification failed.';\n        if (sigErrors.invalid) {\n          errorMessage += `\\nInvalid signature for public key${sigErrors.invalid.length === 1 ? '' : '(s)'} [\\`${sigErrors.invalid.map(p => p.toBase58()).join('`, `')}\\`].`;\n        }\n        if (sigErrors.missing) {\n          errorMessage += `\\nMissing signature for public key${sigErrors.missing.length === 1 ? '' : '(s)'} [\\`${sigErrors.missing.map(p => p.toBase58()).join('`, `')}\\`].`;\n        }\n        throw new Error(errorMessage);\n      }\n    }\n    return this._serialize(signData);\n  }\n\n  /**\n   * @internal\n   */\n  _serialize(signData) {\n    const {\n      signatures\n    } = this;\n    const signatureCount = [];\n    encodeLength(signatureCount, signatures.length);\n    const transactionLength = signatureCount.length + signatures.length * 64 + signData.length;\n    const wireTransaction = buffer.Buffer.alloc(transactionLength);\n    assert(signatures.length < 256);\n    buffer.Buffer.from(signatureCount).copy(wireTransaction, 0);\n    signatures.forEach(({\n      signature\n    }, index) => {\n      if (signature !== null) {\n        assert(signature.length === 64, `signature has invalid length`);\n        buffer.Buffer.from(signature).copy(wireTransaction, signatureCount.length + index * 64);\n      }\n    });\n    signData.copy(wireTransaction, signatureCount.length + signatures.length * 64);\n    assert(wireTransaction.length <= PACKET_DATA_SIZE, `Transaction too large: ${wireTransaction.length} > ${PACKET_DATA_SIZE}`);\n    return wireTransaction;\n  }\n\n  /**\n   * Deprecated method\n   * @internal\n   */\n  get keys() {\n    assert(this.instructions.length === 1);\n    return this.instructions[0].keys.map(keyObj => keyObj.pubkey);\n  }\n\n  /**\n   * Deprecated method\n   * @internal\n   */\n  get programId() {\n    assert(this.instructions.length === 1);\n    return this.instructions[0].programId;\n  }\n\n  /**\n   * Deprecated method\n   * @internal\n   */\n  get data() {\n    assert(this.instructions.length === 1);\n    return this.instructions[0].data;\n  }\n\n  /**\n   * Parse a wire transaction into a Transaction object.\n   *\n   * @param {Buffer | Uint8Array | Array<number>} buffer Signature of wire Transaction\n   *\n   * @returns {Transaction} Transaction associated with the signature\n   */\n  static from(buffer$1) {\n    // Slice up wire data\n    let byteArray = [...buffer$1];\n    const signatureCount = decodeLength(byteArray);\n    let signatures = [];\n    for (let i = 0; i < signatureCount; i++) {\n      const signature = guardedSplice(byteArray, 0, SIGNATURE_LENGTH_IN_BYTES);\n      signatures.push(bs58__default.default.encode(buffer.Buffer.from(signature)));\n    }\n    return Transaction.populate(Message.from(byteArray), signatures);\n  }\n\n  /**\n   * Populate Transaction object from message and signatures\n   *\n   * @param {Message} message Message of transaction\n   * @param {Array<string>} signatures List of signatures to assign to the transaction\n   *\n   * @returns {Transaction} The populated Transaction\n   */\n  static populate(message, signatures = []) {\n    const transaction = new Transaction();\n    transaction.recentBlockhash = message.recentBlockhash;\n    if (message.header.numRequiredSignatures > 0) {\n      transaction.feePayer = message.accountKeys[0];\n    }\n    signatures.forEach((signature, index) => {\n      const sigPubkeyPair = {\n        signature: signature == bs58__default.default.encode(DEFAULT_SIGNATURE) ? null : bs58__default.default.decode(signature),\n        publicKey: message.accountKeys[index]\n      };\n      transaction.signatures.push(sigPubkeyPair);\n    });\n    message.instructions.forEach(instruction => {\n      const keys = instruction.accounts.map(account => {\n        const pubkey = message.accountKeys[account];\n        return {\n          pubkey,\n          isSigner: transaction.signatures.some(keyObj => keyObj.publicKey.toString() === pubkey.toString()) || message.isAccountSigner(account),\n          isWritable: message.isAccountWritable(account)\n        };\n      });\n      transaction.instructions.push(new TransactionInstruction({\n        keys,\n        programId: message.accountKeys[instruction.programIdIndex],\n        data: bs58__default.default.decode(instruction.data)\n      }));\n    });\n    transaction._message = message;\n    transaction._json = transaction.toJSON();\n    return transaction;\n  }\n}\n\nclass TransactionMessage {\n  constructor(args) {\n    this.payerKey = void 0;\n    this.instructions = void 0;\n    this.recentBlockhash = void 0;\n    this.payerKey = args.payerKey;\n    this.instructions = args.instructions;\n    this.recentBlockhash = args.recentBlockhash;\n  }\n  static decompile(message, args) {\n    const {\n      header,\n      compiledInstructions,\n      recentBlockhash\n    } = message;\n    const {\n      numRequiredSignatures,\n      numReadonlySignedAccounts,\n      numReadonlyUnsignedAccounts\n    } = header;\n    const numWritableSignedAccounts = numRequiredSignatures - numReadonlySignedAccounts;\n    assert(numWritableSignedAccounts > 0, 'Message header is invalid');\n    const numWritableUnsignedAccounts = message.staticAccountKeys.length - numRequiredSignatures - numReadonlyUnsignedAccounts;\n    assert(numWritableUnsignedAccounts >= 0, 'Message header is invalid');\n    const accountKeys = message.getAccountKeys(args);\n    const payerKey = accountKeys.get(0);\n    if (payerKey === undefined) {\n      throw new Error('Failed to decompile message because no account keys were found');\n    }\n    const instructions = [];\n    for (const compiledIx of compiledInstructions) {\n      const keys = [];\n      for (const keyIndex of compiledIx.accountKeyIndexes) {\n        const pubkey = accountKeys.get(keyIndex);\n        if (pubkey === undefined) {\n          throw new Error(`Failed to find key for account key index ${keyIndex}`);\n        }\n        const isSigner = keyIndex < numRequiredSignatures;\n        let isWritable;\n        if (isSigner) {\n          isWritable = keyIndex < numWritableSignedAccounts;\n        } else if (keyIndex < accountKeys.staticAccountKeys.length) {\n          isWritable = keyIndex - numRequiredSignatures < numWritableUnsignedAccounts;\n        } else {\n          isWritable = keyIndex - accountKeys.staticAccountKeys.length <\n          // accountKeysFromLookups cannot be undefined because we already found a pubkey for this index above\n          accountKeys.accountKeysFromLookups.writable.length;\n        }\n        keys.push({\n          pubkey,\n          isSigner: keyIndex < header.numRequiredSignatures,\n          isWritable\n        });\n      }\n      const programId = accountKeys.get(compiledIx.programIdIndex);\n      if (programId === undefined) {\n        throw new Error(`Failed to find program id for program id index ${compiledIx.programIdIndex}`);\n      }\n      instructions.push(new TransactionInstruction({\n        programId,\n        data: toBuffer(compiledIx.data),\n        keys\n      }));\n    }\n    return new TransactionMessage({\n      payerKey,\n      instructions,\n      recentBlockhash\n    });\n  }\n  compileToLegacyMessage() {\n    return Message.compile({\n      payerKey: this.payerKey,\n      recentBlockhash: this.recentBlockhash,\n      instructions: this.instructions\n    });\n  }\n  compileToV0Message(addressLookupTableAccounts) {\n    return MessageV0.compile({\n      payerKey: this.payerKey,\n      recentBlockhash: this.recentBlockhash,\n      instructions: this.instructions,\n      addressLookupTableAccounts\n    });\n  }\n}\n\n/**\n * Versioned transaction class\n */\nclass VersionedTransaction {\n  get version() {\n    return this.message.version;\n  }\n  constructor(message, signatures) {\n    this.signatures = void 0;\n    this.message = void 0;\n    if (signatures !== undefined) {\n      assert(signatures.length === message.header.numRequiredSignatures, 'Expected signatures length to be equal to the number of required signatures');\n      this.signatures = signatures;\n    } else {\n      const defaultSignatures = [];\n      for (let i = 0; i < message.header.numRequiredSignatures; i++) {\n        defaultSignatures.push(new Uint8Array(SIGNATURE_LENGTH_IN_BYTES));\n      }\n      this.signatures = defaultSignatures;\n    }\n    this.message = message;\n  }\n  serialize() {\n    const serializedMessage = this.message.serialize();\n    const encodedSignaturesLength = Array();\n    encodeLength(encodedSignaturesLength, this.signatures.length);\n    const transactionLayout = BufferLayout__namespace.struct([BufferLayout__namespace.blob(encodedSignaturesLength.length, 'encodedSignaturesLength'), BufferLayout__namespace.seq(signature(), this.signatures.length, 'signatures'), BufferLayout__namespace.blob(serializedMessage.length, 'serializedMessage')]);\n    const serializedTransaction = new Uint8Array(2048);\n    const serializedTransactionLength = transactionLayout.encode({\n      encodedSignaturesLength: new Uint8Array(encodedSignaturesLength),\n      signatures: this.signatures,\n      serializedMessage\n    }, serializedTransaction);\n    return serializedTransaction.slice(0, serializedTransactionLength);\n  }\n  static deserialize(serializedTransaction) {\n    let byteArray = [...serializedTransaction];\n    const signatures = [];\n    const signaturesLength = decodeLength(byteArray);\n    for (let i = 0; i < signaturesLength; i++) {\n      signatures.push(new Uint8Array(guardedSplice(byteArray, 0, SIGNATURE_LENGTH_IN_BYTES)));\n    }\n    const message = VersionedMessage.deserialize(new Uint8Array(byteArray));\n    return new VersionedTransaction(message, signatures);\n  }\n  sign(signers) {\n    const messageData = this.message.serialize();\n    const signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);\n    for (const signer of signers) {\n      const signerIndex = signerPubkeys.findIndex(pubkey => pubkey.equals(signer.publicKey));\n      assert(signerIndex >= 0, `Cannot sign with non signer key ${signer.publicKey.toBase58()}`);\n      this.signatures[signerIndex] = sign(messageData, signer.secretKey);\n    }\n  }\n  addSignature(publicKey, signature) {\n    assert(signature.byteLength === 64, 'Signature must be 64 bytes long');\n    const signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);\n    const signerIndex = signerPubkeys.findIndex(pubkey => pubkey.equals(publicKey));\n    assert(signerIndex >= 0, `Can not add signature; \\`${publicKey.toBase58()}\\` is not required to sign this transaction`);\n    this.signatures[signerIndex] = signature;\n  }\n}\n\n// TODO: These constants should be removed in favor of reading them out of a\n// Syscall account\n\n/**\n * @internal\n */\nconst NUM_TICKS_PER_SECOND = 160;\n\n/**\n * @internal\n */\nconst DEFAULT_TICKS_PER_SLOT = 64;\n\n/**\n * @internal\n */\nconst NUM_SLOTS_PER_SECOND = NUM_TICKS_PER_SECOND / DEFAULT_TICKS_PER_SLOT;\n\n/**\n * @internal\n */\nconst MS_PER_SLOT = 1000 / NUM_SLOTS_PER_SECOND;\n\nconst SYSVAR_CLOCK_PUBKEY = new PublicKey('SysvarC1ock11111111111111111111111111111111');\nconst SYSVAR_EPOCH_SCHEDULE_PUBKEY = new PublicKey('SysvarEpochSchedu1e111111111111111111111111');\nconst SYSVAR_INSTRUCTIONS_PUBKEY = new PublicKey('Sysvar1nstructions1111111111111111111111111');\nconst SYSVAR_RECENT_BLOCKHASHES_PUBKEY = new PublicKey('SysvarRecentB1ockHashes11111111111111111111');\nconst SYSVAR_RENT_PUBKEY = new PublicKey('SysvarRent111111111111111111111111111111111');\nconst SYSVAR_REWARDS_PUBKEY = new PublicKey('SysvarRewards111111111111111111111111111111');\nconst SYSVAR_SLOT_HASHES_PUBKEY = new PublicKey('SysvarS1otHashes111111111111111111111111111');\nconst SYSVAR_SLOT_HISTORY_PUBKEY = new PublicKey('SysvarS1otHistory11111111111111111111111111');\nconst SYSVAR_STAKE_HISTORY_PUBKEY = new PublicKey('SysvarStakeHistory1111111111111111111111111');\n\n/**\n * Sign, send and confirm a transaction.\n *\n * If `commitment` option is not specified, defaults to 'max' commitment.\n *\n * @param {Connection} connection\n * @param {Transaction} transaction\n * @param {Array<Signer>} signers\n * @param {ConfirmOptions} [options]\n * @returns {Promise<TransactionSignature>}\n */\nasync function sendAndConfirmTransaction(connection, transaction, signers, options) {\n  const sendOptions = options && {\n    skipPreflight: options.skipPreflight,\n    preflightCommitment: options.preflightCommitment || options.commitment,\n    maxRetries: options.maxRetries,\n    minContextSlot: options.minContextSlot\n  };\n  const signature = await connection.sendTransaction(transaction, signers, sendOptions);\n  let status;\n  if (transaction.recentBlockhash != null && transaction.lastValidBlockHeight != null) {\n    status = (await connection.confirmTransaction({\n      abortSignal: options?.abortSignal,\n      signature: signature,\n      blockhash: transaction.recentBlockhash,\n      lastValidBlockHeight: transaction.lastValidBlockHeight\n    }, options && options.commitment)).value;\n  } else if (transaction.minNonceContextSlot != null && transaction.nonceInfo != null) {\n    const {\n      nonceInstruction\n    } = transaction.nonceInfo;\n    const nonceAccountPubkey = nonceInstruction.keys[0].pubkey;\n    status = (await connection.confirmTransaction({\n      abortSignal: options?.abortSignal,\n      minContextSlot: transaction.minNonceContextSlot,\n      nonceAccountPubkey,\n      nonceValue: transaction.nonceInfo.nonce,\n      signature\n    }, options && options.commitment)).value;\n  } else {\n    if (options?.abortSignal != null) {\n      console.warn('sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was ' + 'supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` ' + 'or a combination of `nonceInfo` and `minNonceContextSlot` are abortable.');\n    }\n    status = (await connection.confirmTransaction(signature, options && options.commitment)).value;\n  }\n  if (status.err) {\n    throw new Error(`Transaction ${signature} failed (${JSON.stringify(status)})`);\n  }\n  return signature;\n}\n\n// zzz\nfunction sleep(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n/**\n * @internal\n */\n\n/**\n * Populate a buffer of instruction data using an InstructionType\n * @internal\n */\nfunction encodeData(type, fields) {\n  const allocLength = type.layout.span >= 0 ? type.layout.span : getAlloc(type, fields);\n  const data = buffer.Buffer.alloc(allocLength);\n  const layoutFields = Object.assign({\n    instruction: type.index\n  }, fields);\n  type.layout.encode(layoutFields, data);\n  return data;\n}\n\n/**\n * Decode instruction data buffer using an InstructionType\n * @internal\n */\nfunction decodeData$1(type, buffer) {\n  let data;\n  try {\n    data = type.layout.decode(buffer);\n  } catch (err) {\n    throw new Error('invalid instruction; ' + err);\n  }\n  if (data.instruction !== type.index) {\n    throw new Error(`invalid instruction; instruction index mismatch ${data.instruction} != ${type.index}`);\n  }\n  return data;\n}\n\n/**\n * https://github.com/solana-labs/solana/blob/90bedd7e067b5b8f3ddbb45da00a4e9cabb22c62/sdk/src/fee_calculator.rs#L7-L11\n *\n * @internal\n */\nconst FeeCalculatorLayout = BufferLayout__namespace.nu64('lamportsPerSignature');\n\n/**\n * Calculator for transaction fees.\n *\n * @deprecated Deprecated since Solana v1.8.0.\n */\n\n/**\n * See https://github.com/solana-labs/solana/blob/0ea2843ec9cdc517572b8e62c959f41b55cf4453/sdk/src/nonce_state.rs#L29-L32\n *\n * @internal\n */\nconst NonceAccountLayout = BufferLayout__namespace.struct([BufferLayout__namespace.u32('version'), BufferLayout__namespace.u32('state'), publicKey('authorizedPubkey'), publicKey('nonce'), BufferLayout__namespace.struct([FeeCalculatorLayout], 'feeCalculator')]);\nconst NONCE_ACCOUNT_LENGTH = NonceAccountLayout.span;\n\n/**\n * A durable nonce is a 32 byte value encoded as a base58 string.\n */\n\n/**\n * NonceAccount class\n */\nclass NonceAccount {\n  /**\n   * @internal\n   */\n  constructor(args) {\n    this.authorizedPubkey = void 0;\n    this.nonce = void 0;\n    this.feeCalculator = void 0;\n    this.authorizedPubkey = args.authorizedPubkey;\n    this.nonce = args.nonce;\n    this.feeCalculator = args.feeCalculator;\n  }\n\n  /**\n   * Deserialize NonceAccount from the account data.\n   *\n   * @param buffer account data\n   * @return NonceAccount\n   */\n  static fromAccountData(buffer) {\n    const nonceAccount = NonceAccountLayout.decode(toBuffer(buffer), 0);\n    return new NonceAccount({\n      authorizedPubkey: new PublicKey(nonceAccount.authorizedPubkey),\n      nonce: new PublicKey(nonceAccount.nonce).toString(),\n      feeCalculator: nonceAccount.feeCalculator\n    });\n  }\n}\n\nconst encodeDecode = layout => {\n  const decode = layout.decode.bind(layout);\n  const encode = layout.encode.bind(layout);\n  return {\n    decode,\n    encode\n  };\n};\nconst bigInt = length => property => {\n  const layout = BufferLayout.blob(length, property);\n  const {\n    encode,\n    decode\n  } = encodeDecode(layout);\n  const bigIntLayout = layout;\n  bigIntLayout.decode = (buffer$1, offset) => {\n    const src = decode(buffer$1, offset);\n    return bigintBuffer.toBigIntLE(buffer.Buffer.from(src));\n  };\n  bigIntLayout.encode = (bigInt, buffer, offset) => {\n    const src = bigintBuffer.toBufferLE(bigInt, length);\n    return encode(src, buffer, offset);\n  };\n  return bigIntLayout;\n};\nconst u64 = bigInt(8);\n\n/**\n * Create account system transaction params\n */\n\n/**\n * Transfer system transaction params\n */\n\n/**\n * Assign system transaction params\n */\n\n/**\n * Create account with seed system transaction params\n */\n\n/**\n * Create nonce account system transaction params\n */\n\n/**\n * Create nonce account with seed system transaction params\n */\n\n/**\n * Initialize nonce account system instruction params\n */\n\n/**\n * Advance nonce account system instruction params\n */\n\n/**\n * Withdraw nonce account system transaction params\n */\n\n/**\n * Authorize nonce account system transaction params\n */\n\n/**\n * Allocate account system transaction params\n */\n\n/**\n * Allocate account with seed system transaction params\n */\n\n/**\n * Assign account with seed system transaction params\n */\n\n/**\n * Transfer with seed system transaction params\n */\n\n/** Decoded transfer system transaction instruction */\n\n/** Decoded transferWithSeed system transaction instruction */\n\n/**\n * System Instruction class\n */\nclass SystemInstruction {\n  /**\n   * @internal\n   */\n  constructor() {}\n\n  /**\n   * Decode a system instruction and retrieve the instruction type.\n   */\n  static decodeInstructionType(instruction) {\n    this.checkProgramId(instruction.programId);\n    const instructionTypeLayout = BufferLayout__namespace.u32('instruction');\n    const typeIndex = instructionTypeLayout.decode(instruction.data);\n    let type;\n    for (const [ixType, layout] of Object.entries(SYSTEM_INSTRUCTION_LAYOUTS)) {\n      if (layout.index == typeIndex) {\n        type = ixType;\n        break;\n      }\n    }\n    if (!type) {\n      throw new Error('Instruction type incorrect; not a SystemInstruction');\n    }\n    return type;\n  }\n\n  /**\n   * Decode a create account system instruction and retrieve the instruction params.\n   */\n  static decodeCreateAccount(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 2);\n    const {\n      lamports,\n      space,\n      programId\n    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Create, instruction.data);\n    return {\n      fromPubkey: instruction.keys[0].pubkey,\n      newAccountPubkey: instruction.keys[1].pubkey,\n      lamports,\n      space,\n      programId: new PublicKey(programId)\n    };\n  }\n\n  /**\n   * Decode a transfer system instruction and retrieve the instruction params.\n   */\n  static decodeTransfer(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 2);\n    const {\n      lamports\n    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Transfer, instruction.data);\n    return {\n      fromPubkey: instruction.keys[0].pubkey,\n      toPubkey: instruction.keys[1].pubkey,\n      lamports\n    };\n  }\n\n  /**\n   * Decode a transfer with seed system instruction and retrieve the instruction params.\n   */\n  static decodeTransferWithSeed(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 3);\n    const {\n      lamports,\n      seed,\n      programId\n    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed, instruction.data);\n    return {\n      fromPubkey: instruction.keys[0].pubkey,\n      basePubkey: instruction.keys[1].pubkey,\n      toPubkey: instruction.keys[2].pubkey,\n      lamports,\n      seed,\n      programId: new PublicKey(programId)\n    };\n  }\n\n  /**\n   * Decode an allocate system instruction and retrieve the instruction params.\n   */\n  static decodeAllocate(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 1);\n    const {\n      space\n    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Allocate, instruction.data);\n    return {\n      accountPubkey: instruction.keys[0].pubkey,\n      space\n    };\n  }\n\n  /**\n   * Decode an allocate with seed system instruction and retrieve the instruction params.\n   */\n  static decodeAllocateWithSeed(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 1);\n    const {\n      base,\n      seed,\n      space,\n      programId\n    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed, instruction.data);\n    return {\n      accountPubkey: instruction.keys[0].pubkey,\n      basePubkey: new PublicKey(base),\n      seed,\n      space,\n      programId: new PublicKey(programId)\n    };\n  }\n\n  /**\n   * Decode an assign system instruction and retrieve the instruction params.\n   */\n  static decodeAssign(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 1);\n    const {\n      programId\n    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Assign, instruction.data);\n    return {\n      accountPubkey: instruction.keys[0].pubkey,\n      programId: new PublicKey(programId)\n    };\n  }\n\n  /**\n   * Decode an assign with seed system instruction and retrieve the instruction params.\n   */\n  static decodeAssignWithSeed(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 1);\n    const {\n      base,\n      seed,\n      programId\n    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed, instruction.data);\n    return {\n      accountPubkey: instruction.keys[0].pubkey,\n      basePubkey: new PublicKey(base),\n      seed,\n      programId: new PublicKey(programId)\n    };\n  }\n\n  /**\n   * Decode a create account with seed system instruction and retrieve the instruction params.\n   */\n  static decodeCreateWithSeed(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 2);\n    const {\n      base,\n      seed,\n      lamports,\n      space,\n      programId\n    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed, instruction.data);\n    return {\n      fromPubkey: instruction.keys[0].pubkey,\n      newAccountPubkey: instruction.keys[1].pubkey,\n      basePubkey: new PublicKey(base),\n      seed,\n      lamports,\n      space,\n      programId: new PublicKey(programId)\n    };\n  }\n\n  /**\n   * Decode a nonce initialize system instruction and retrieve the instruction params.\n   */\n  static decodeNonceInitialize(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 3);\n    const {\n      authorized\n    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount, instruction.data);\n    return {\n      noncePubkey: instruction.keys[0].pubkey,\n      authorizedPubkey: new PublicKey(authorized)\n    };\n  }\n\n  /**\n   * Decode a nonce advance system instruction and retrieve the instruction params.\n   */\n  static decodeNonceAdvance(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 3);\n    decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount, instruction.data);\n    return {\n      noncePubkey: instruction.keys[0].pubkey,\n      authorizedPubkey: instruction.keys[2].pubkey\n    };\n  }\n\n  /**\n   * Decode a nonce withdraw system instruction and retrieve the instruction params.\n   */\n  static decodeNonceWithdraw(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 5);\n    const {\n      lamports\n    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount, instruction.data);\n    return {\n      noncePubkey: instruction.keys[0].pubkey,\n      toPubkey: instruction.keys[1].pubkey,\n      authorizedPubkey: instruction.keys[4].pubkey,\n      lamports\n    };\n  }\n\n  /**\n   * Decode a nonce authorize system instruction and retrieve the instruction params.\n   */\n  static decodeNonceAuthorize(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 2);\n    const {\n      authorized\n    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount, instruction.data);\n    return {\n      noncePubkey: instruction.keys[0].pubkey,\n      authorizedPubkey: instruction.keys[1].pubkey,\n      newAuthorizedPubkey: new PublicKey(authorized)\n    };\n  }\n\n  /**\n   * @internal\n   */\n  static checkProgramId(programId) {\n    if (!programId.equals(SystemProgram.programId)) {\n      throw new Error('invalid instruction; programId is not SystemProgram');\n    }\n  }\n\n  /**\n   * @internal\n   */\n  static checkKeyLength(keys, expectedLength) {\n    if (keys.length < expectedLength) {\n      throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);\n    }\n  }\n}\n\n/**\n * An enumeration of valid SystemInstructionType's\n */\n\n/**\n * An enumeration of valid system InstructionType's\n * @internal\n */\nconst SYSTEM_INSTRUCTION_LAYOUTS = Object.freeze({\n  Create: {\n    index: 0,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), BufferLayout__namespace.ns64('lamports'), BufferLayout__namespace.ns64('space'), publicKey('programId')])\n  },\n  Assign: {\n    index: 1,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), publicKey('programId')])\n  },\n  Transfer: {\n    index: 2,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), u64('lamports')])\n  },\n  CreateWithSeed: {\n    index: 3,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), publicKey('base'), rustString('seed'), BufferLayout__namespace.ns64('lamports'), BufferLayout__namespace.ns64('space'), publicKey('programId')])\n  },\n  AdvanceNonceAccount: {\n    index: 4,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction')])\n  },\n  WithdrawNonceAccount: {\n    index: 5,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), BufferLayout__namespace.ns64('lamports')])\n  },\n  InitializeNonceAccount: {\n    index: 6,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), publicKey('authorized')])\n  },\n  AuthorizeNonceAccount: {\n    index: 7,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), publicKey('authorized')])\n  },\n  Allocate: {\n    index: 8,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), BufferLayout__namespace.ns64('space')])\n  },\n  AllocateWithSeed: {\n    index: 9,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), publicKey('base'), rustString('seed'), BufferLayout__namespace.ns64('space'), publicKey('programId')])\n  },\n  AssignWithSeed: {\n    index: 10,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), publicKey('base'), rustString('seed'), publicKey('programId')])\n  },\n  TransferWithSeed: {\n    index: 11,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), u64('lamports'), rustString('seed'), publicKey('programId')])\n  },\n  UpgradeNonceAccount: {\n    index: 12,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction')])\n  }\n});\n\n/**\n * Factory class for transactions to interact with the System program\n */\nclass SystemProgram {\n  /**\n   * @internal\n   */\n  constructor() {}\n\n  /**\n   * Public key that identifies the System program\n   */\n\n  /**\n   * Generate a transaction instruction that creates a new account\n   */\n  static createAccount(params) {\n    const type = SYSTEM_INSTRUCTION_LAYOUTS.Create;\n    const data = encodeData(type, {\n      lamports: params.lamports,\n      space: params.space,\n      programId: toBuffer(params.programId.toBuffer())\n    });\n    return new TransactionInstruction({\n      keys: [{\n        pubkey: params.fromPubkey,\n        isSigner: true,\n        isWritable: true\n      }, {\n        pubkey: params.newAccountPubkey,\n        isSigner: true,\n        isWritable: true\n      }],\n      programId: this.programId,\n      data\n    });\n  }\n\n  /**\n   * Generate a transaction instruction that transfers lamports from one account to another\n   */\n  static transfer(params) {\n    let data;\n    let keys;\n    if ('basePubkey' in params) {\n      const type = SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed;\n      data = encodeData(type, {\n        lamports: BigInt(params.lamports),\n        seed: params.seed,\n        programId: toBuffer(params.programId.toBuffer())\n      });\n      keys = [{\n        pubkey: params.fromPubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: params.basePubkey,\n        isSigner: true,\n        isWritable: false\n      }, {\n        pubkey: params.toPubkey,\n        isSigner: false,\n        isWritable: true\n      }];\n    } else {\n      const type = SYSTEM_INSTRUCTION_LAYOUTS.Transfer;\n      data = encodeData(type, {\n        lamports: BigInt(params.lamports)\n      });\n      keys = [{\n        pubkey: params.fromPubkey,\n        isSigner: true,\n        isWritable: true\n      }, {\n        pubkey: params.toPubkey,\n        isSigner: false,\n        isWritable: true\n      }];\n    }\n    return new TransactionInstruction({\n      keys,\n      programId: this.programId,\n      data\n    });\n  }\n\n  /**\n   * Generate a transaction instruction that assigns an account to a program\n   */\n  static assign(params) {\n    let data;\n    let keys;\n    if ('basePubkey' in params) {\n      const type = SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed;\n      data = encodeData(type, {\n        base: toBuffer(params.basePubkey.toBuffer()),\n        seed: params.seed,\n        programId: toBuffer(params.programId.toBuffer())\n      });\n      keys = [{\n        pubkey: params.accountPubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: params.basePubkey,\n        isSigner: true,\n        isWritable: false\n      }];\n    } else {\n      const type = SYSTEM_INSTRUCTION_LAYOUTS.Assign;\n      data = encodeData(type, {\n        programId: toBuffer(params.programId.toBuffer())\n      });\n      keys = [{\n        pubkey: params.accountPubkey,\n        isSigner: true,\n        isWritable: true\n      }];\n    }\n    return new TransactionInstruction({\n      keys,\n      programId: this.programId,\n      data\n    });\n  }\n\n  /**\n   * Generate a transaction instruction that creates a new account at\n   *   an address generated with `from`, a seed, and programId\n   */\n  static createAccountWithSeed(params) {\n    const type = SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed;\n    const data = encodeData(type, {\n      base: toBuffer(params.basePubkey.toBuffer()),\n      seed: params.seed,\n      lamports: params.lamports,\n      space: params.space,\n      programId: toBuffer(params.programId.toBuffer())\n    });\n    let keys = [{\n      pubkey: params.fromPubkey,\n      isSigner: true,\n      isWritable: true\n    }, {\n      pubkey: params.newAccountPubkey,\n      isSigner: false,\n      isWritable: true\n    }];\n    if (params.basePubkey != params.fromPubkey) {\n      keys.push({\n        pubkey: params.basePubkey,\n        isSigner: true,\n        isWritable: false\n      });\n    }\n    return new TransactionInstruction({\n      keys,\n      programId: this.programId,\n      data\n    });\n  }\n\n  /**\n   * Generate a transaction that creates a new Nonce account\n   */\n  static createNonceAccount(params) {\n    const transaction = new Transaction();\n    if ('basePubkey' in params && 'seed' in params) {\n      transaction.add(SystemProgram.createAccountWithSeed({\n        fromPubkey: params.fromPubkey,\n        newAccountPubkey: params.noncePubkey,\n        basePubkey: params.basePubkey,\n        seed: params.seed,\n        lamports: params.lamports,\n        space: NONCE_ACCOUNT_LENGTH,\n        programId: this.programId\n      }));\n    } else {\n      transaction.add(SystemProgram.createAccount({\n        fromPubkey: params.fromPubkey,\n        newAccountPubkey: params.noncePubkey,\n        lamports: params.lamports,\n        space: NONCE_ACCOUNT_LENGTH,\n        programId: this.programId\n      }));\n    }\n    const initParams = {\n      noncePubkey: params.noncePubkey,\n      authorizedPubkey: params.authorizedPubkey\n    };\n    transaction.add(this.nonceInitialize(initParams));\n    return transaction;\n  }\n\n  /**\n   * Generate an instruction to initialize a Nonce account\n   */\n  static nonceInitialize(params) {\n    const type = SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount;\n    const data = encodeData(type, {\n      authorized: toBuffer(params.authorizedPubkey.toBuffer())\n    });\n    const instructionData = {\n      keys: [{\n        pubkey: params.noncePubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: SYSVAR_RENT_PUBKEY,\n        isSigner: false,\n        isWritable: false\n      }],\n      programId: this.programId,\n      data\n    };\n    return new TransactionInstruction(instructionData);\n  }\n\n  /**\n   * Generate an instruction to advance the nonce in a Nonce account\n   */\n  static nonceAdvance(params) {\n    const type = SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount;\n    const data = encodeData(type);\n    const instructionData = {\n      keys: [{\n        pubkey: params.noncePubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: params.authorizedPubkey,\n        isSigner: true,\n        isWritable: false\n      }],\n      programId: this.programId,\n      data\n    };\n    return new TransactionInstruction(instructionData);\n  }\n\n  /**\n   * Generate a transaction instruction that withdraws lamports from a Nonce account\n   */\n  static nonceWithdraw(params) {\n    const type = SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount;\n    const data = encodeData(type, {\n      lamports: params.lamports\n    });\n    return new TransactionInstruction({\n      keys: [{\n        pubkey: params.noncePubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: params.toPubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: SYSVAR_RENT_PUBKEY,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: params.authorizedPubkey,\n        isSigner: true,\n        isWritable: false\n      }],\n      programId: this.programId,\n      data\n    });\n  }\n\n  /**\n   * Generate a transaction instruction that authorizes a new PublicKey as the authority\n   * on a Nonce account.\n   */\n  static nonceAuthorize(params) {\n    const type = SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount;\n    const data = encodeData(type, {\n      authorized: toBuffer(params.newAuthorizedPubkey.toBuffer())\n    });\n    return new TransactionInstruction({\n      keys: [{\n        pubkey: params.noncePubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: params.authorizedPubkey,\n        isSigner: true,\n        isWritable: false\n      }],\n      programId: this.programId,\n      data\n    });\n  }\n\n  /**\n   * Generate a transaction instruction that allocates space in an account without funding\n   */\n  static allocate(params) {\n    let data;\n    let keys;\n    if ('basePubkey' in params) {\n      const type = SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed;\n      data = encodeData(type, {\n        base: toBuffer(params.basePubkey.toBuffer()),\n        seed: params.seed,\n        space: params.space,\n        programId: toBuffer(params.programId.toBuffer())\n      });\n      keys = [{\n        pubkey: params.accountPubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: params.basePubkey,\n        isSigner: true,\n        isWritable: false\n      }];\n    } else {\n      const type = SYSTEM_INSTRUCTION_LAYOUTS.Allocate;\n      data = encodeData(type, {\n        space: params.space\n      });\n      keys = [{\n        pubkey: params.accountPubkey,\n        isSigner: true,\n        isWritable: true\n      }];\n    }\n    return new TransactionInstruction({\n      keys,\n      programId: this.programId,\n      data\n    });\n  }\n}\nSystemProgram.programId = new PublicKey('11111111111111111111111111111111');\n\n// Keep program chunks under PACKET_DATA_SIZE, leaving enough room for the\n// rest of the Transaction fields\n//\n// TODO: replace 300 with a proper constant for the size of the other\n// Transaction fields\nconst CHUNK_SIZE = PACKET_DATA_SIZE - 300;\n\n/**\n * Program loader interface\n */\nclass Loader {\n  /**\n   * @internal\n   */\n  constructor() {}\n\n  /**\n   * Amount of program data placed in each load Transaction\n   */\n\n  /**\n   * Minimum number of signatures required to load a program not including\n   * retries\n   *\n   * Can be used to calculate transaction fees\n   */\n  static getMinNumSignatures(dataLength) {\n    return 2 * (\n    // Every transaction requires two signatures (payer + program)\n    Math.ceil(dataLength / Loader.chunkSize) + 1 +\n    // Add one for Create transaction\n    1) // Add one for Finalize transaction\n    ;\n  }\n\n  /**\n   * Loads a generic program\n   *\n   * @param connection The connection to use\n   * @param payer System account that pays to load the program\n   * @param program Account to load the program into\n   * @param programId Public key that identifies the loader\n   * @param data Program octets\n   * @return true if program was loaded successfully, false if program was already loaded\n   */\n  static async load(connection, payer, program, programId, data) {\n    {\n      const balanceNeeded = await connection.getMinimumBalanceForRentExemption(data.length);\n\n      // Fetch program account info to check if it has already been created\n      const programInfo = await connection.getAccountInfo(program.publicKey, 'confirmed');\n      let transaction = null;\n      if (programInfo !== null) {\n        if (programInfo.executable) {\n          console.error('Program load failed, account is already executable');\n          return false;\n        }\n        if (programInfo.data.length !== data.length) {\n          transaction = transaction || new Transaction();\n          transaction.add(SystemProgram.allocate({\n            accountPubkey: program.publicKey,\n            space: data.length\n          }));\n        }\n        if (!programInfo.owner.equals(programId)) {\n          transaction = transaction || new Transaction();\n          transaction.add(SystemProgram.assign({\n            accountPubkey: program.publicKey,\n            programId\n          }));\n        }\n        if (programInfo.lamports < balanceNeeded) {\n          transaction = transaction || new Transaction();\n          transaction.add(SystemProgram.transfer({\n            fromPubkey: payer.publicKey,\n            toPubkey: program.publicKey,\n            lamports: balanceNeeded - programInfo.lamports\n          }));\n        }\n      } else {\n        transaction = new Transaction().add(SystemProgram.createAccount({\n          fromPubkey: payer.publicKey,\n          newAccountPubkey: program.publicKey,\n          lamports: balanceNeeded > 0 ? balanceNeeded : 1,\n          space: data.length,\n          programId\n        }));\n      }\n\n      // If the account is already created correctly, skip this step\n      // and proceed directly to loading instructions\n      if (transaction !== null) {\n        await sendAndConfirmTransaction(connection, transaction, [payer, program], {\n          commitment: 'confirmed'\n        });\n      }\n    }\n    const dataLayout = BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), BufferLayout__namespace.u32('offset'), BufferLayout__namespace.u32('bytesLength'), BufferLayout__namespace.u32('bytesLengthPadding'), BufferLayout__namespace.seq(BufferLayout__namespace.u8('byte'), BufferLayout__namespace.offset(BufferLayout__namespace.u32(), -8), 'bytes')]);\n    const chunkSize = Loader.chunkSize;\n    let offset = 0;\n    let array = data;\n    let transactions = [];\n    while (array.length > 0) {\n      const bytes = array.slice(0, chunkSize);\n      const data = buffer.Buffer.alloc(chunkSize + 16);\n      dataLayout.encode({\n        instruction: 0,\n        // Load instruction\n        offset,\n        bytes: bytes,\n        bytesLength: 0,\n        bytesLengthPadding: 0\n      }, data);\n      const transaction = new Transaction().add({\n        keys: [{\n          pubkey: program.publicKey,\n          isSigner: true,\n          isWritable: true\n        }],\n        programId,\n        data\n      });\n      transactions.push(sendAndConfirmTransaction(connection, transaction, [payer, program], {\n        commitment: 'confirmed'\n      }));\n\n      // Delay between sends in an attempt to reduce rate limit errors\n      if (connection._rpcEndpoint.includes('solana.com')) {\n        const REQUESTS_PER_SECOND = 4;\n        await sleep(1000 / REQUESTS_PER_SECOND);\n      }\n      offset += chunkSize;\n      array = array.slice(chunkSize);\n    }\n    await Promise.all(transactions);\n\n    // Finalize the account loaded with program data for execution\n    {\n      const dataLayout = BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction')]);\n      const data = buffer.Buffer.alloc(dataLayout.span);\n      dataLayout.encode({\n        instruction: 1 // Finalize instruction\n      }, data);\n      const transaction = new Transaction().add({\n        keys: [{\n          pubkey: program.publicKey,\n          isSigner: true,\n          isWritable: true\n        }, {\n          pubkey: SYSVAR_RENT_PUBKEY,\n          isSigner: false,\n          isWritable: false\n        }],\n        programId,\n        data\n      });\n      const deployCommitment = 'processed';\n      const finalizeSignature = await connection.sendTransaction(transaction, [payer, program], {\n        preflightCommitment: deployCommitment\n      });\n      const {\n        context,\n        value\n      } = await connection.confirmTransaction({\n        signature: finalizeSignature,\n        lastValidBlockHeight: transaction.lastValidBlockHeight,\n        blockhash: transaction.recentBlockhash\n      }, deployCommitment);\n      if (value.err) {\n        throw new Error(`Transaction ${finalizeSignature} failed (${JSON.stringify(value)})`);\n      }\n      // We prevent programs from being usable until the slot after their deployment.\n      // See https://github.com/solana-labs/solana/pull/29654\n      while (true // eslint-disable-line no-constant-condition\n      ) {\n        try {\n          const currentSlot = await connection.getSlot({\n            commitment: deployCommitment\n          });\n          if (currentSlot > context.slot) {\n            break;\n          }\n        } catch {\n          /* empty */\n        }\n        await new Promise(resolve => setTimeout(resolve, Math.round(MS_PER_SLOT / 2)));\n      }\n    }\n\n    // success\n    return true;\n  }\n}\nLoader.chunkSize = CHUNK_SIZE;\n\n/**\n * @deprecated Deprecated since Solana v1.17.20.\n */\nconst BPF_LOADER_PROGRAM_ID = new PublicKey('BPFLoader2111111111111111111111111111111111');\n\n/**\n * Factory class for transactions to interact with a program loader\n *\n * @deprecated Deprecated since Solana v1.17.20.\n */\nclass BpfLoader {\n  /**\n   * Minimum number of signatures required to load a program not including\n   * retries\n   *\n   * Can be used to calculate transaction fees\n   */\n  static getMinNumSignatures(dataLength) {\n    return Loader.getMinNumSignatures(dataLength);\n  }\n\n  /**\n   * Load a SBF program\n   *\n   * @param connection The connection to use\n   * @param payer Account that will pay program loading fees\n   * @param program Account to load the program into\n   * @param elf The entire ELF containing the SBF program\n   * @param loaderProgramId The program id of the BPF loader to use\n   * @return true if program was loaded successfully, false if program was already loaded\n   */\n  static load(connection, payer, program, elf, loaderProgramId) {\n    return Loader.load(connection, payer, program, loaderProgramId, elf);\n  }\n}\n\nfunction getDefaultExportFromCjs (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nvar agentkeepalive = {exports: {}};\n\n/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nvar ms$2 = function (val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n\n/*!\n * humanize-ms - index.js\n * Copyright(c) 2014 dead_horse <dead_horse@qq.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar util = require$$0__default.default;\nvar ms$1 = ms$2;\n\nvar humanizeMs = function (t) {\n  if (typeof t === 'number') return t;\n  var r = ms$1(t);\n  if (r === undefined) {\n    var err = new Error(util.format('humanize-ms(%j) result undefined', t));\n    console.warn(err.stack);\n  }\n  return r;\n};\n\nvar constants = {\n  // agent\n  CURRENT_ID: Symbol('agentkeepalive#currentId'),\n  CREATE_ID: Symbol('agentkeepalive#createId'),\n  INIT_SOCKET: Symbol('agentkeepalive#initSocket'),\n  CREATE_HTTPS_CONNECTION: Symbol('agentkeepalive#createHttpsConnection'),\n  // socket\n  SOCKET_CREATED_TIME: Symbol('agentkeepalive#socketCreatedTime'),\n  SOCKET_NAME: Symbol('agentkeepalive#socketName'),\n  SOCKET_REQUEST_COUNT: Symbol('agentkeepalive#socketRequestCount'),\n  SOCKET_REQUEST_FINISHED_COUNT: Symbol('agentkeepalive#socketRequestFinishedCount'),\n};\n\nconst OriginalAgent = require$$0__default$1.default.Agent;\nconst ms = humanizeMs;\nconst debug = require$$0__default.default.debuglog('agentkeepalive');\nconst {\n  INIT_SOCKET: INIT_SOCKET$1,\n  CURRENT_ID,\n  CREATE_ID,\n  SOCKET_CREATED_TIME,\n  SOCKET_NAME,\n  SOCKET_REQUEST_COUNT,\n  SOCKET_REQUEST_FINISHED_COUNT,\n} = constants;\n\n// OriginalAgent come from\n// - https://github.com/nodejs/node/blob/v8.12.0/lib/_http_agent.js\n// - https://github.com/nodejs/node/blob/v10.12.0/lib/_http_agent.js\n\n// node <= 10\nlet defaultTimeoutListenerCount = 1;\nconst majorVersion = parseInt(process.version.split('.', 1)[0].substring(1));\nif (majorVersion >= 11 && majorVersion <= 12) {\n  defaultTimeoutListenerCount = 2;\n} else if (majorVersion >= 13) {\n  defaultTimeoutListenerCount = 3;\n}\n\nfunction deprecate(message) {\n  console.log('[agentkeepalive:deprecated] %s', message);\n}\n\nclass Agent extends OriginalAgent {\n  constructor(options) {\n    options = options || {};\n    options.keepAlive = options.keepAlive !== false;\n    // default is keep-alive and 4s free socket timeout\n    // see https://medium.com/ssense-tech/reduce-networking-errors-in-nodejs-23b4eb9f2d83\n    if (options.freeSocketTimeout === undefined) {\n      options.freeSocketTimeout = 4000;\n    }\n    // Legacy API: keepAliveTimeout should be rename to `freeSocketTimeout`\n    if (options.keepAliveTimeout) {\n      deprecate('options.keepAliveTimeout is deprecated, please use options.freeSocketTimeout instead');\n      options.freeSocketTimeout = options.keepAliveTimeout;\n      delete options.keepAliveTimeout;\n    }\n    // Legacy API: freeSocketKeepAliveTimeout should be rename to `freeSocketTimeout`\n    if (options.freeSocketKeepAliveTimeout) {\n      deprecate('options.freeSocketKeepAliveTimeout is deprecated, please use options.freeSocketTimeout instead');\n      options.freeSocketTimeout = options.freeSocketKeepAliveTimeout;\n      delete options.freeSocketKeepAliveTimeout;\n    }\n\n    // Sets the socket to timeout after timeout milliseconds of inactivity on the socket.\n    // By default is double free socket timeout.\n    if (options.timeout === undefined) {\n      // make sure socket default inactivity timeout >= 8s\n      options.timeout = Math.max(options.freeSocketTimeout * 2, 8000);\n    }\n\n    // support humanize format\n    options.timeout = ms(options.timeout);\n    options.freeSocketTimeout = ms(options.freeSocketTimeout);\n    options.socketActiveTTL = options.socketActiveTTL ? ms(options.socketActiveTTL) : 0;\n\n    super(options);\n\n    this[CURRENT_ID] = 0;\n\n    // create socket success counter\n    this.createSocketCount = 0;\n    this.createSocketCountLastCheck = 0;\n\n    this.createSocketErrorCount = 0;\n    this.createSocketErrorCountLastCheck = 0;\n\n    this.closeSocketCount = 0;\n    this.closeSocketCountLastCheck = 0;\n\n    // socket error event count\n    this.errorSocketCount = 0;\n    this.errorSocketCountLastCheck = 0;\n\n    // request finished counter\n    this.requestCount = 0;\n    this.requestCountLastCheck = 0;\n\n    // including free socket timeout counter\n    this.timeoutSocketCount = 0;\n    this.timeoutSocketCountLastCheck = 0;\n\n    this.on('free', socket => {\n      // https://github.com/nodejs/node/pull/32000\n      // Node.js native agent will check socket timeout eqs agent.options.timeout.\n      // Use the ttl or freeSocketTimeout to overwrite.\n      const timeout = this.calcSocketTimeout(socket);\n      if (timeout > 0 && socket.timeout !== timeout) {\n        socket.setTimeout(timeout);\n      }\n    });\n  }\n\n  get freeSocketKeepAliveTimeout() {\n    deprecate('agent.freeSocketKeepAliveTimeout is deprecated, please use agent.options.freeSocketTimeout instead');\n    return this.options.freeSocketTimeout;\n  }\n\n  get timeout() {\n    deprecate('agent.timeout is deprecated, please use agent.options.timeout instead');\n    return this.options.timeout;\n  }\n\n  get socketActiveTTL() {\n    deprecate('agent.socketActiveTTL is deprecated, please use agent.options.socketActiveTTL instead');\n    return this.options.socketActiveTTL;\n  }\n\n  calcSocketTimeout(socket) {\n    /**\n     * return <= 0: should free socket\n     * return > 0: should update socket timeout\n     * return undefined: not find custom timeout\n     */\n    let freeSocketTimeout = this.options.freeSocketTimeout;\n    const socketActiveTTL = this.options.socketActiveTTL;\n    if (socketActiveTTL) {\n      // check socketActiveTTL\n      const aliveTime = Date.now() - socket[SOCKET_CREATED_TIME];\n      const diff = socketActiveTTL - aliveTime;\n      if (diff <= 0) {\n        return diff;\n      }\n      if (freeSocketTimeout && diff < freeSocketTimeout) {\n        freeSocketTimeout = diff;\n      }\n    }\n    // set freeSocketTimeout\n    if (freeSocketTimeout) {\n      // set free keepalive timer\n      // try to use socket custom freeSocketTimeout first, support headers['keep-alive']\n      // https://github.com/node-modules/urllib/blob/b76053020923f4d99a1c93cf2e16e0c5ba10bacf/lib/urllib.js#L498\n      const customFreeSocketTimeout = socket.freeSocketTimeout || socket.freeSocketKeepAliveTimeout;\n      return customFreeSocketTimeout || freeSocketTimeout;\n    }\n  }\n\n  keepSocketAlive(socket) {\n    const result = super.keepSocketAlive(socket);\n    // should not keepAlive, do nothing\n    if (!result) return result;\n\n    const customTimeout = this.calcSocketTimeout(socket);\n    if (typeof customTimeout === 'undefined') {\n      return true;\n    }\n    if (customTimeout <= 0) {\n      debug('%s(requests: %s, finished: %s) free but need to destroy by TTL, request count %s, diff is %s',\n        socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], customTimeout);\n      return false;\n    }\n    if (socket.timeout !== customTimeout) {\n      socket.setTimeout(customTimeout);\n    }\n    return true;\n  }\n\n  // only call on addRequest\n  reuseSocket(...args) {\n    // reuseSocket(socket, req)\n    super.reuseSocket(...args);\n    const socket = args[0];\n    const req = args[1];\n    req.reusedSocket = true;\n    const agentTimeout = this.options.timeout;\n    if (getSocketTimeout(socket) !== agentTimeout) {\n      // reset timeout before use\n      socket.setTimeout(agentTimeout);\n      debug('%s reset timeout to %sms', socket[SOCKET_NAME], agentTimeout);\n    }\n    socket[SOCKET_REQUEST_COUNT]++;\n    debug('%s(requests: %s, finished: %s) reuse on addRequest, timeout %sms',\n      socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT],\n      getSocketTimeout(socket));\n  }\n\n  [CREATE_ID]() {\n    const id = this[CURRENT_ID]++;\n    if (this[CURRENT_ID] === Number.MAX_SAFE_INTEGER) this[CURRENT_ID] = 0;\n    return id;\n  }\n\n  [INIT_SOCKET$1](socket, options) {\n    // bugfix here.\n    // https on node 8, 10 won't set agent.options.timeout by default\n    // TODO: need to fix on node itself\n    if (options.timeout) {\n      const timeout = getSocketTimeout(socket);\n      if (!timeout) {\n        socket.setTimeout(options.timeout);\n      }\n    }\n\n    if (this.options.keepAlive) {\n      // Disable Nagle's algorithm: http://blog.caustik.com/2012/04/08/scaling-node-js-to-100k-concurrent-connections/\n      // https://fengmk2.com/benchmark/nagle-algorithm-delayed-ack-mock.html\n      socket.setNoDelay(true);\n    }\n    this.createSocketCount++;\n    if (this.options.socketActiveTTL) {\n      socket[SOCKET_CREATED_TIME] = Date.now();\n    }\n    // don't show the hole '-----BEGIN CERTIFICATE----' key string\n    socket[SOCKET_NAME] = `sock[${this[CREATE_ID]()}#${options._agentKey}]`.split('-----BEGIN', 1)[0];\n    socket[SOCKET_REQUEST_COUNT] = 1;\n    socket[SOCKET_REQUEST_FINISHED_COUNT] = 0;\n    installListeners(this, socket, options);\n  }\n\n  createConnection(options, oncreate) {\n    let called = false;\n    const onNewCreate = (err, socket) => {\n      if (called) return;\n      called = true;\n\n      if (err) {\n        this.createSocketErrorCount++;\n        return oncreate(err);\n      }\n      this[INIT_SOCKET$1](socket, options);\n      oncreate(err, socket);\n    };\n\n    const newSocket = super.createConnection(options, onNewCreate);\n    if (newSocket) onNewCreate(null, newSocket);\n    return newSocket;\n  }\n\n  get statusChanged() {\n    const changed = this.createSocketCount !== this.createSocketCountLastCheck ||\n      this.createSocketErrorCount !== this.createSocketErrorCountLastCheck ||\n      this.closeSocketCount !== this.closeSocketCountLastCheck ||\n      this.errorSocketCount !== this.errorSocketCountLastCheck ||\n      this.timeoutSocketCount !== this.timeoutSocketCountLastCheck ||\n      this.requestCount !== this.requestCountLastCheck;\n    if (changed) {\n      this.createSocketCountLastCheck = this.createSocketCount;\n      this.createSocketErrorCountLastCheck = this.createSocketErrorCount;\n      this.closeSocketCountLastCheck = this.closeSocketCount;\n      this.errorSocketCountLastCheck = this.errorSocketCount;\n      this.timeoutSocketCountLastCheck = this.timeoutSocketCount;\n      this.requestCountLastCheck = this.requestCount;\n    }\n    return changed;\n  }\n\n  getCurrentStatus() {\n    return {\n      createSocketCount: this.createSocketCount,\n      createSocketErrorCount: this.createSocketErrorCount,\n      closeSocketCount: this.closeSocketCount,\n      errorSocketCount: this.errorSocketCount,\n      timeoutSocketCount: this.timeoutSocketCount,\n      requestCount: this.requestCount,\n      freeSockets: inspect(this.freeSockets),\n      sockets: inspect(this.sockets),\n      requests: inspect(this.requests),\n    };\n  }\n}\n\n// node 8 don't has timeout attribute on socket\n// https://github.com/nodejs/node/pull/21204/files#diff-e6ef024c3775d787c38487a6309e491dR408\nfunction getSocketTimeout(socket) {\n  return socket.timeout || socket._idleTimeout;\n}\n\nfunction installListeners(agent, socket, options) {\n  debug('%s create, timeout %sms', socket[SOCKET_NAME], getSocketTimeout(socket));\n\n  // listener socket events: close, timeout, error, free\n  function onFree() {\n    // create and socket.emit('free') logic\n    // https://github.com/nodejs/node/blob/master/lib/_http_agent.js#L311\n    // no req on the socket, it should be the new socket\n    if (!socket._httpMessage && socket[SOCKET_REQUEST_COUNT] === 1) return;\n\n    socket[SOCKET_REQUEST_FINISHED_COUNT]++;\n    agent.requestCount++;\n    debug('%s(requests: %s, finished: %s) free',\n      socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT]);\n\n    // should reuse on pedding requests?\n    const name = agent.getName(options);\n    if (socket.writable && agent.requests[name] && agent.requests[name].length) {\n      // will be reuse on agent free listener\n      socket[SOCKET_REQUEST_COUNT]++;\n      debug('%s(requests: %s, finished: %s) will be reuse on agent free event',\n        socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT]);\n    }\n  }\n  socket.on('free', onFree);\n\n  function onClose(isError) {\n    debug('%s(requests: %s, finished: %s) close, isError: %s',\n      socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], isError);\n    agent.closeSocketCount++;\n  }\n  socket.on('close', onClose);\n\n  // start socket timeout handler\n  function onTimeout() {\n    // onTimeout and emitRequestTimeout(_http_client.js)\n    // https://github.com/nodejs/node/blob/v12.x/lib/_http_client.js#L711\n    const listenerCount = socket.listeners('timeout').length;\n    // node <= 10, default listenerCount is 1, onTimeout\n    // 11 < node <= 12, default listenerCount is 2, onTimeout and emitRequestTimeout\n    // node >= 13, default listenerCount is 3, onTimeout,\n    //   onTimeout(https://github.com/nodejs/node/pull/32000/files#diff-5f7fb0850412c6be189faeddea6c5359R333)\n    //   and emitRequestTimeout\n    const timeout = getSocketTimeout(socket);\n    const req = socket._httpMessage;\n    const reqTimeoutListenerCount = req && req.listeners('timeout').length || 0;\n    debug('%s(requests: %s, finished: %s) timeout after %sms, listeners %s, defaultTimeoutListenerCount %s, hasHttpRequest %s, HttpRequest timeoutListenerCount %s',\n      socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT],\n      timeout, listenerCount, defaultTimeoutListenerCount, !!req, reqTimeoutListenerCount);\n    if (debug.enabled) {\n      debug('timeout listeners: %s', socket.listeners('timeout').map(f => f.name).join(', '));\n    }\n    agent.timeoutSocketCount++;\n    const name = agent.getName(options);\n    if (agent.freeSockets[name] && agent.freeSockets[name].indexOf(socket) !== -1) {\n      // free socket timeout, destroy quietly\n      socket.destroy();\n      // Remove it from freeSockets list immediately to prevent new requests\n      // from being sent through this socket.\n      agent.removeSocket(socket, options);\n      debug('%s is free, destroy quietly', socket[SOCKET_NAME]);\n    } else {\n      // if there is no any request socket timeout handler,\n      // agent need to handle socket timeout itself.\n      //\n      // custom request socket timeout handle logic must follow these rules:\n      //  1. Destroy socket first\n      //  2. Must emit socket 'agentRemove' event tell agent remove socket\n      //     from freeSockets list immediately.\n      //     Otherise you may be get 'socket hang up' error when reuse\n      //     free socket and timeout happen in the same time.\n      if (reqTimeoutListenerCount === 0) {\n        const error = new Error('Socket timeout');\n        error.code = 'ERR_SOCKET_TIMEOUT';\n        error.timeout = timeout;\n        // must manually call socket.end() or socket.destroy() to end the connection.\n        // https://nodejs.org/dist/latest-v10.x/docs/api/net.html#net_socket_settimeout_timeout_callback\n        socket.destroy(error);\n        agent.removeSocket(socket, options);\n        debug('%s destroy with timeout error', socket[SOCKET_NAME]);\n      }\n    }\n  }\n  socket.on('timeout', onTimeout);\n\n  function onError(err) {\n    const listenerCount = socket.listeners('error').length;\n    debug('%s(requests: %s, finished: %s) error: %s, listenerCount: %s',\n      socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT],\n      err, listenerCount);\n    agent.errorSocketCount++;\n    if (listenerCount === 1) {\n      // if socket don't contain error event handler, don't catch it, emit it again\n      debug('%s emit uncaught error event', socket[SOCKET_NAME]);\n      socket.removeListener('error', onError);\n      socket.emit('error', err);\n    }\n  }\n  socket.on('error', onError);\n\n  function onRemove() {\n    debug('%s(requests: %s, finished: %s) agentRemove',\n      socket[SOCKET_NAME],\n      socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT]);\n    // We need this function for cases like HTTP 'upgrade'\n    // (defined by WebSockets) where we need to remove a socket from the\n    // pool because it'll be locked up indefinitely\n    socket.removeListener('close', onClose);\n    socket.removeListener('error', onError);\n    socket.removeListener('free', onFree);\n    socket.removeListener('timeout', onTimeout);\n    socket.removeListener('agentRemove', onRemove);\n  }\n  socket.on('agentRemove', onRemove);\n}\n\nvar agent = Agent;\n\nfunction inspect(obj) {\n  const res = {};\n  for (const key in obj) {\n    res[key] = obj[key].length;\n  }\n  return res;\n}\n\nconst OriginalHttpsAgent = require$$0__default$2.default.Agent;\nconst HttpAgent = agent;\nconst {\n  INIT_SOCKET,\n  CREATE_HTTPS_CONNECTION,\n} = constants;\n\nlet HttpsAgent$1 = class HttpsAgent extends HttpAgent {\n  constructor(options) {\n    super(options);\n\n    this.defaultPort = 443;\n    this.protocol = 'https:';\n    this.maxCachedSessions = this.options.maxCachedSessions;\n    /* istanbul ignore next */\n    if (this.maxCachedSessions === undefined) {\n      this.maxCachedSessions = 100;\n    }\n\n    this._sessionCache = {\n      map: {},\n      list: [],\n    };\n  }\n\n  createConnection(options, oncreate) {\n    const socket = this[CREATE_HTTPS_CONNECTION](options, oncreate);\n    this[INIT_SOCKET](socket, options);\n    return socket;\n  }\n};\n\n// https://github.com/nodejs/node/blob/master/lib/https.js#L89\nHttpsAgent$1.prototype[CREATE_HTTPS_CONNECTION] = OriginalHttpsAgent.prototype.createConnection;\n\n[\n  'getName',\n  '_getSession',\n  '_cacheSession',\n  // https://github.com/nodejs/node/pull/4982\n  '_evictSession',\n].forEach(function(method) {\n  /* istanbul ignore next */\n  if (typeof OriginalHttpsAgent.prototype[method] === 'function') {\n    HttpsAgent$1.prototype[method] = OriginalHttpsAgent.prototype[method];\n  }\n});\n\nvar https_agent = HttpsAgent$1;\n\nagentkeepalive.exports = agent;\nvar HttpsAgent = agentkeepalive.exports.HttpsAgent = https_agent;\nagentkeepalive.exports.constants = constants;\n\nvar agentkeepaliveExports = agentkeepalive.exports;\nvar HttpKeepAliveAgent = /*@__PURE__*/getDefaultExportFromCjs(agentkeepaliveExports);\n\nvar objToString = Object.prototype.toString;\nvar objKeys = Object.keys || function(obj) {\n\t\tvar keys = [];\n\t\tfor (var name in obj) {\n\t\t\tkeys.push(name);\n\t\t}\n\t\treturn keys;\n\t};\n\nfunction stringify(val, isArrayProp) {\n\tvar i, max, str, keys, key, propVal, toStr;\n\tif (val === true) {\n\t\treturn \"true\";\n\t}\n\tif (val === false) {\n\t\treturn \"false\";\n\t}\n\tswitch (typeof val) {\n\t\tcase \"object\":\n\t\t\tif (val === null) {\n\t\t\t\treturn null;\n\t\t\t} else if (val.toJSON && typeof val.toJSON === \"function\") {\n\t\t\t\treturn stringify(val.toJSON(), isArrayProp);\n\t\t\t} else {\n\t\t\t\ttoStr = objToString.call(val);\n\t\t\t\tif (toStr === \"[object Array]\") {\n\t\t\t\t\tstr = '[';\n\t\t\t\t\tmax = val.length - 1;\n\t\t\t\t\tfor(i = 0; i < max; i++) {\n\t\t\t\t\t\tstr += stringify(val[i], true) + ',';\n\t\t\t\t\t}\n\t\t\t\t\tif (max > -1) {\n\t\t\t\t\t\tstr += stringify(val[i], true);\n\t\t\t\t\t}\n\t\t\t\t\treturn str + ']';\n\t\t\t\t} else if (toStr === \"[object Object]\") {\n\t\t\t\t\t// only object is left\n\t\t\t\t\tkeys = objKeys(val).sort();\n\t\t\t\t\tmax = keys.length;\n\t\t\t\t\tstr = \"\";\n\t\t\t\t\ti = 0;\n\t\t\t\t\twhile (i < max) {\n\t\t\t\t\t\tkey = keys[i];\n\t\t\t\t\t\tpropVal = stringify(val[key], false);\n\t\t\t\t\t\tif (propVal !== undefined) {\n\t\t\t\t\t\t\tif (str) {\n\t\t\t\t\t\t\t\tstr += ',';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tstr += JSON.stringify(key) + ':' + propVal;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\treturn '{' + str + '}';\n\t\t\t\t} else {\n\t\t\t\t\treturn JSON.stringify(val);\n\t\t\t\t}\n\t\t\t}\n\t\tcase \"function\":\n\t\tcase \"undefined\":\n\t\t\treturn isArrayProp ? null : undefined;\n\t\tcase \"string\":\n\t\t\treturn JSON.stringify(val);\n\t\tdefault:\n\t\t\treturn isFinite(val) ? val : null;\n\t}\n}\n\nvar fastStableStringify = function(val) {\n\tvar returnVal = stringify(val, false);\n\tif (returnVal !== undefined) {\n\t\treturn ''+ returnVal;\n\t}\n};\n\nvar fastStableStringify$1 = /*@__PURE__*/getDefaultExportFromCjs(fastStableStringify);\n\nconst MINIMUM_SLOT_PER_EPOCH = 32;\n\n// Returns the number of trailing zeros in the binary representation of self.\nfunction trailingZeros(n) {\n  let trailingZeros = 0;\n  while (n > 1) {\n    n /= 2;\n    trailingZeros++;\n  }\n  return trailingZeros;\n}\n\n// Returns the smallest power of two greater than or equal to n\nfunction nextPowerOfTwo(n) {\n  if (n === 0) return 1;\n  n--;\n  n |= n >> 1;\n  n |= n >> 2;\n  n |= n >> 4;\n  n |= n >> 8;\n  n |= n >> 16;\n  n |= n >> 32;\n  return n + 1;\n}\n\n/**\n * Epoch schedule\n * (see https://docs.solana.com/terminology#epoch)\n * Can be retrieved with the {@link Connection.getEpochSchedule} method\n */\nclass EpochSchedule {\n  constructor(slotsPerEpoch, leaderScheduleSlotOffset, warmup, firstNormalEpoch, firstNormalSlot) {\n    /** The maximum number of slots in each epoch */\n    this.slotsPerEpoch = void 0;\n    /** The number of slots before beginning of an epoch to calculate a leader schedule for that epoch */\n    this.leaderScheduleSlotOffset = void 0;\n    /** Indicates whether epochs start short and grow */\n    this.warmup = void 0;\n    /** The first epoch with `slotsPerEpoch` slots */\n    this.firstNormalEpoch = void 0;\n    /** The first slot of `firstNormalEpoch` */\n    this.firstNormalSlot = void 0;\n    this.slotsPerEpoch = slotsPerEpoch;\n    this.leaderScheduleSlotOffset = leaderScheduleSlotOffset;\n    this.warmup = warmup;\n    this.firstNormalEpoch = firstNormalEpoch;\n    this.firstNormalSlot = firstNormalSlot;\n  }\n  getEpoch(slot) {\n    return this.getEpochAndSlotIndex(slot)[0];\n  }\n  getEpochAndSlotIndex(slot) {\n    if (slot < this.firstNormalSlot) {\n      const epoch = trailingZeros(nextPowerOfTwo(slot + MINIMUM_SLOT_PER_EPOCH + 1)) - trailingZeros(MINIMUM_SLOT_PER_EPOCH) - 1;\n      const epochLen = this.getSlotsInEpoch(epoch);\n      const slotIndex = slot - (epochLen - MINIMUM_SLOT_PER_EPOCH);\n      return [epoch, slotIndex];\n    } else {\n      const normalSlotIndex = slot - this.firstNormalSlot;\n      const normalEpochIndex = Math.floor(normalSlotIndex / this.slotsPerEpoch);\n      const epoch = this.firstNormalEpoch + normalEpochIndex;\n      const slotIndex = normalSlotIndex % this.slotsPerEpoch;\n      return [epoch, slotIndex];\n    }\n  }\n  getFirstSlotInEpoch(epoch) {\n    if (epoch <= this.firstNormalEpoch) {\n      return (Math.pow(2, epoch) - 1) * MINIMUM_SLOT_PER_EPOCH;\n    } else {\n      return (epoch - this.firstNormalEpoch) * this.slotsPerEpoch + this.firstNormalSlot;\n    }\n  }\n  getLastSlotInEpoch(epoch) {\n    return this.getFirstSlotInEpoch(epoch) + this.getSlotsInEpoch(epoch) - 1;\n  }\n  getSlotsInEpoch(epoch) {\n    if (epoch < this.firstNormalEpoch) {\n      return Math.pow(2, epoch + trailingZeros(MINIMUM_SLOT_PER_EPOCH));\n    } else {\n      return this.slotsPerEpoch;\n    }\n  }\n}\n\nclass SendTransactionError extends Error {\n  constructor(message, logs) {\n    super(message);\n    this.logs = void 0;\n    this.logs = logs;\n  }\n}\n\n// Keep in sync with client/src/rpc_custom_errors.rs\n// Typescript `enums` thwart tree-shaking. See https://bargsten.org/jsts/enums/\nconst SolanaJSONRPCErrorCode = {\n  JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP: -32001,\n  JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE: -32002,\n  JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE: -32003,\n  JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE: -32004,\n  JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY: -32005,\n  JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE: -32006,\n  JSON_RPC_SERVER_ERROR_SLOT_SKIPPED: -32007,\n  JSON_RPC_SERVER_ERROR_NO_SNAPSHOT: -32008,\n  JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED: -32009,\n  JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX: -32010,\n  JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE: -32011,\n  JSON_RPC_SCAN_ERROR: -32012,\n  JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH: -32013,\n  JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET: -32014,\n  JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION: -32015,\n  JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED: -32016\n};\nclass SolanaJSONRPCError extends Error {\n  constructor({\n    code,\n    message,\n    data\n  }, customMessage) {\n    super(customMessage != null ? `${customMessage}: ${message}` : message);\n    this.code = void 0;\n    this.data = void 0;\n    this.code = code;\n    this.data = data;\n    this.name = 'SolanaJSONRPCError';\n  }\n}\n\nvar fetchImpl = typeof globalThis.fetch === 'function' ?\n// The Fetch API is supported experimentally in Node 17.5+ and natively in Node 18+.\nglobalThis.fetch :\n// Otherwise use the polyfill.\nasync function (input, init) {\n  const processedInput = typeof input === 'string' && input.slice(0, 2) === '//' ? 'https:' + input : input;\n  return await nodeFetch__namespace.default(processedInput, init);\n};\n\nclass RpcWebSocketClient extends RpcWebSocketCommonClient__default.default {\n  constructor(address, options, generate_request_id) {\n    const webSocketFactory = url => {\n      const rpc = WebsocketFactory__default.default(url, {\n        autoconnect: true,\n        max_reconnects: 5,\n        reconnect: true,\n        reconnect_interval: 1000,\n        ...options\n      });\n      if ('socket' in rpc) {\n        this.underlyingSocket = rpc.socket;\n      } else {\n        this.underlyingSocket = rpc;\n      }\n      return rpc;\n    };\n    super(webSocketFactory, address, options, generate_request_id);\n    this.underlyingSocket = void 0;\n  }\n  call(...args) {\n    const readyState = this.underlyingSocket?.readyState;\n    if (readyState === 1 /* WebSocket.OPEN */) {\n      return super.call(...args);\n    }\n    return Promise.reject(new Error('Tried to call a JSON-RPC method `' + args[0] + '` but the socket was not `CONNECTING` or `OPEN` (`readyState` was ' + readyState + ')'));\n  }\n  notify(...args) {\n    const readyState = this.underlyingSocket?.readyState;\n    if (readyState === 1 /* WebSocket.OPEN */) {\n      return super.notify(...args);\n    }\n    return Promise.reject(new Error('Tried to send a JSON-RPC notification `' + args[0] + '` but the socket was not `CONNECTING` or `OPEN` (`readyState` was ' + readyState + ')'));\n  }\n}\n\n/**\n * @internal\n */\n\n/**\n * Decode account data buffer using an AccountType\n * @internal\n */\nfunction decodeData(type, data) {\n  let decoded;\n  try {\n    decoded = type.layout.decode(data);\n  } catch (err) {\n    throw new Error('invalid instruction; ' + err);\n  }\n  if (decoded.typeIndex !== type.index) {\n    throw new Error(`invalid account data; account type mismatch ${decoded.typeIndex} != ${type.index}`);\n  }\n  return decoded;\n}\n\n/// The serialized size of lookup table metadata\nconst LOOKUP_TABLE_META_SIZE = 56;\nclass AddressLookupTableAccount {\n  constructor(args) {\n    this.key = void 0;\n    this.state = void 0;\n    this.key = args.key;\n    this.state = args.state;\n  }\n  isActive() {\n    const U64_MAX = BigInt('0xffffffffffffffff');\n    return this.state.deactivationSlot === U64_MAX;\n  }\n  static deserialize(accountData) {\n    const meta = decodeData(LookupTableMetaLayout, accountData);\n    const serializedAddressesLen = accountData.length - LOOKUP_TABLE_META_SIZE;\n    assert(serializedAddressesLen >= 0, 'lookup table is invalid');\n    assert(serializedAddressesLen % 32 === 0, 'lookup table is invalid');\n    const numSerializedAddresses = serializedAddressesLen / 32;\n    const {\n      addresses\n    } = BufferLayout__namespace.struct([BufferLayout__namespace.seq(publicKey(), numSerializedAddresses, 'addresses')]).decode(accountData.slice(LOOKUP_TABLE_META_SIZE));\n    return {\n      deactivationSlot: meta.deactivationSlot,\n      lastExtendedSlot: meta.lastExtendedSlot,\n      lastExtendedSlotStartIndex: meta.lastExtendedStartIndex,\n      authority: meta.authority.length !== 0 ? new PublicKey(meta.authority[0]) : undefined,\n      addresses: addresses.map(address => new PublicKey(address))\n    };\n  }\n}\nconst LookupTableMetaLayout = {\n  index: 1,\n  layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('typeIndex'), u64('deactivationSlot'), BufferLayout__namespace.nu64('lastExtendedSlot'), BufferLayout__namespace.u8('lastExtendedStartIndex'), BufferLayout__namespace.u8(),\n  // option\n  BufferLayout__namespace.seq(publicKey(), BufferLayout__namespace.offset(BufferLayout__namespace.u8(), -1), 'authority')])\n};\n\nconst URL_RE = /^[^:]+:\\/\\/([^:[]+|\\[[^\\]]+\\])(:\\d+)?(.*)/i;\nfunction makeWebsocketUrl(endpoint) {\n  const matches = endpoint.match(URL_RE);\n  if (matches == null) {\n    throw TypeError(`Failed to validate endpoint URL \\`${endpoint}\\``);\n  }\n  const [_,\n  // eslint-disable-line @typescript-eslint/no-unused-vars\n  hostish, portWithColon, rest] = matches;\n  const protocol = endpoint.startsWith('https:') ? 'wss:' : 'ws:';\n  const startPort = portWithColon == null ? null : parseInt(portWithColon.slice(1), 10);\n  const websocketPort =\n  // Only shift the port by +1 as a convention for ws(s) only if given endpoint\n  // is explicitly specifying the endpoint port (HTTP-based RPC), assuming\n  // we're directly trying to connect to solana-validator's ws listening port.\n  // When the endpoint omits the port, we're connecting to the protocol\n  // default ports: http(80) or https(443) and it's assumed we're behind a reverse\n  // proxy which manages WebSocket upgrade and backend port redirection.\n  startPort == null ? '' : `:${startPort + 1}`;\n  return `${protocol}//${hostish}${websocketPort}${rest}`;\n}\n\nconst PublicKeyFromString = superstruct.coerce(superstruct.instance(PublicKey), superstruct.string(), value => new PublicKey(value));\nconst RawAccountDataResult = superstruct.tuple([superstruct.string(), superstruct.literal('base64')]);\nconst BufferFromRawAccountData = superstruct.coerce(superstruct.instance(buffer.Buffer), RawAccountDataResult, value => buffer.Buffer.from(value[0], 'base64'));\n\n/**\n * Attempt to use a recent blockhash for up to 30 seconds\n * @internal\n */\nconst BLOCKHASH_CACHE_TIMEOUT_MS = 30 * 1000;\n\n/**\n * HACK.\n * Copied from rpc-websockets/dist/lib/client.\n * Otherwise, `yarn build` fails with:\n * https://gist.github.com/steveluscher/c057eca81d479ef705cdb53162f9971d\n */\n\n/** @internal */\n/** @internal */\n/** @internal */\n/** @internal */\n\n/** @internal */\n/**\n * @internal\n * Every subscription contains the args used to open the subscription with\n * the server, and a list of callers interested in notifications.\n */\n\n/**\n * @internal\n * A subscription may be in various states of connectedness. Only when it is\n * fully connected will it have a server subscription id associated with it.\n * This id can be returned to the server to unsubscribe the client entirely.\n */\n\n/**\n * A type that encapsulates a subscription's RPC method\n * names and notification (callback) signature.\n */\n\n/**\n * @internal\n * Utility type that keeps tagged unions intact while omitting properties.\n */\n\n/**\n * @internal\n * This type represents a single subscribable 'topic.' It's made up of:\n *\n * - The args used to open the subscription with the server,\n * - The state of the subscription, in terms of its connectedness, and\n * - The set of callbacks to call when the server publishes notifications\n *\n * This record gets indexed by `SubscriptionConfigHash` and is used to\n * set up subscriptions, fan out notifications, and track subscription state.\n */\n\n/**\n * @internal\n */\n\n/**\n * Extra contextual information for RPC responses\n */\n\n/**\n * Options for sending transactions\n */\n\n/**\n * Options for confirming transactions\n */\n\n/**\n * Options for getConfirmedSignaturesForAddress2\n */\n\n/**\n * Options for getSignaturesForAddress\n */\n\n/**\n * RPC Response with extra contextual information\n */\n\n/**\n * A strategy for confirming transactions that uses the last valid\n * block height for a given blockhash to check for transaction expiration.\n */\n\n/**\n * A strategy for confirming durable nonce transactions.\n */\n\n/**\n * Properties shared by all transaction confirmation strategies\n */\n\n/**\n * This type represents all transaction confirmation strategies\n */\n\n/* @internal */\nfunction assertEndpointUrl(putativeUrl) {\n  if (/^https?:/.test(putativeUrl) === false) {\n    throw new TypeError('Endpoint URL must start with `http:` or `https:`.');\n  }\n  return putativeUrl;\n}\n\n/** @internal */\nfunction extractCommitmentFromConfig(commitmentOrConfig) {\n  let commitment;\n  let config;\n  if (typeof commitmentOrConfig === 'string') {\n    commitment = commitmentOrConfig;\n  } else if (commitmentOrConfig) {\n    const {\n      commitment: specifiedCommitment,\n      ...specifiedConfig\n    } = commitmentOrConfig;\n    commitment = specifiedCommitment;\n    config = specifiedConfig;\n  }\n  return {\n    commitment,\n    config\n  };\n}\n\n/**\n * @internal\n */\nfunction createRpcResult(result) {\n  return superstruct.union([superstruct.type({\n    jsonrpc: superstruct.literal('2.0'),\n    id: superstruct.string(),\n    result\n  }), superstruct.type({\n    jsonrpc: superstruct.literal('2.0'),\n    id: superstruct.string(),\n    error: superstruct.type({\n      code: superstruct.unknown(),\n      message: superstruct.string(),\n      data: superstruct.optional(superstruct.any())\n    })\n  })]);\n}\nconst UnknownRpcResult = createRpcResult(superstruct.unknown());\n\n/**\n * @internal\n */\nfunction jsonRpcResult(schema) {\n  return superstruct.coerce(createRpcResult(schema), UnknownRpcResult, value => {\n    if ('error' in value) {\n      return value;\n    } else {\n      return {\n        ...value,\n        result: superstruct.create(value.result, schema)\n      };\n    }\n  });\n}\n\n/**\n * @internal\n */\nfunction jsonRpcResultAndContext(value) {\n  return jsonRpcResult(superstruct.type({\n    context: superstruct.type({\n      slot: superstruct.number()\n    }),\n    value\n  }));\n}\n\n/**\n * @internal\n */\nfunction notificationResultAndContext(value) {\n  return superstruct.type({\n    context: superstruct.type({\n      slot: superstruct.number()\n    }),\n    value\n  });\n}\n\n/**\n * @internal\n */\nfunction versionedMessageFromResponse(version, response) {\n  if (version === 0) {\n    return new MessageV0({\n      header: response.header,\n      staticAccountKeys: response.accountKeys.map(accountKey => new PublicKey(accountKey)),\n      recentBlockhash: response.recentBlockhash,\n      compiledInstructions: response.instructions.map(ix => ({\n        programIdIndex: ix.programIdIndex,\n        accountKeyIndexes: ix.accounts,\n        data: bs58__default.default.decode(ix.data)\n      })),\n      addressTableLookups: response.addressTableLookups\n    });\n  } else {\n    return new Message(response);\n  }\n}\n\n/**\n * The level of commitment desired when querying state\n * <pre>\n *   'processed': Query the most recent block which has reached 1 confirmation by the connected node\n *   'confirmed': Query the most recent block which has reached 1 confirmation by the cluster\n *   'finalized': Query the most recent block which has been finalized by the cluster\n * </pre>\n */\n\n// Deprecated as of v1.5.5\n\n/**\n * A subset of Commitment levels, which are at least optimistically confirmed\n * <pre>\n *   'confirmed': Query the most recent block which has reached 1 confirmation by the cluster\n *   'finalized': Query the most recent block which has been finalized by the cluster\n * </pre>\n */\n\n/**\n * Filter for largest accounts query\n * <pre>\n *   'circulating':    Return the largest accounts that are part of the circulating supply\n *   'nonCirculating': Return the largest accounts that are not part of the circulating supply\n * </pre>\n */\n\n/**\n * Configuration object for changing `getAccountInfo` query behavior\n */\n\n/**\n * Configuration object for changing `getBalance` query behavior\n */\n\n/**\n * Configuration object for changing `getBlock` query behavior\n */\n\n/**\n * Configuration object for changing `getBlock` query behavior\n */\n\n/**\n * Configuration object for changing `getStakeMinimumDelegation` query behavior\n */\n\n/**\n * Configuration object for changing `getBlockHeight` query behavior\n */\n\n/**\n * Configuration object for changing `getEpochInfo` query behavior\n */\n\n/**\n * Configuration object for changing `getInflationReward` query behavior\n */\n\n/**\n * Configuration object for changing `getLatestBlockhash` query behavior\n */\n\n/**\n * Configuration object for changing `isBlockhashValid` query behavior\n */\n\n/**\n * Configuration object for changing `getSlot` query behavior\n */\n\n/**\n * Configuration object for changing `getSlotLeader` query behavior\n */\n\n/**\n * Configuration object for changing `getTransaction` query behavior\n */\n\n/**\n * Configuration object for changing `getTransaction` query behavior\n */\n\n/**\n * Configuration object for changing `getLargestAccounts` query behavior\n */\n\n/**\n * Configuration object for changing `getSupply` request behavior\n */\n\n/**\n * Configuration object for changing query behavior\n */\n\n/**\n * Information describing a cluster node\n */\n\n/**\n * Information describing a vote account\n */\n\n/**\n * A collection of cluster vote accounts\n */\n\n/**\n * Network Inflation\n * (see https://docs.solana.com/implemented-proposals/ed_overview)\n */\n\nconst GetInflationGovernorResult = superstruct.type({\n  foundation: superstruct.number(),\n  foundationTerm: superstruct.number(),\n  initial: superstruct.number(),\n  taper: superstruct.number(),\n  terminal: superstruct.number()\n});\n\n/**\n * The inflation reward for an epoch\n */\n\n/**\n * Expected JSON RPC response for the \"getInflationReward\" message\n */\nconst GetInflationRewardResult = jsonRpcResult(superstruct.array(superstruct.nullable(superstruct.type({\n  epoch: superstruct.number(),\n  effectiveSlot: superstruct.number(),\n  amount: superstruct.number(),\n  postBalance: superstruct.number(),\n  commission: superstruct.optional(superstruct.nullable(superstruct.number()))\n}))));\n\n/**\n * Configuration object for changing `getRecentPrioritizationFees` query behavior\n */\n\n/**\n * Expected JSON RPC response for the \"getRecentPrioritizationFees\" message\n */\nconst GetRecentPrioritizationFeesResult = superstruct.array(superstruct.type({\n  slot: superstruct.number(),\n  prioritizationFee: superstruct.number()\n}));\n/**\n * Expected JSON RPC response for the \"getInflationRate\" message\n */\nconst GetInflationRateResult = superstruct.type({\n  total: superstruct.number(),\n  validator: superstruct.number(),\n  foundation: superstruct.number(),\n  epoch: superstruct.number()\n});\n\n/**\n * Information about the current epoch\n */\n\nconst GetEpochInfoResult = superstruct.type({\n  epoch: superstruct.number(),\n  slotIndex: superstruct.number(),\n  slotsInEpoch: superstruct.number(),\n  absoluteSlot: superstruct.number(),\n  blockHeight: superstruct.optional(superstruct.number()),\n  transactionCount: superstruct.optional(superstruct.number())\n});\nconst GetEpochScheduleResult = superstruct.type({\n  slotsPerEpoch: superstruct.number(),\n  leaderScheduleSlotOffset: superstruct.number(),\n  warmup: superstruct.boolean(),\n  firstNormalEpoch: superstruct.number(),\n  firstNormalSlot: superstruct.number()\n});\n\n/**\n * Leader schedule\n * (see https://docs.solana.com/terminology#leader-schedule)\n */\n\nconst GetLeaderScheduleResult = superstruct.record(superstruct.string(), superstruct.array(superstruct.number()));\n\n/**\n * Transaction error or null\n */\nconst TransactionErrorResult = superstruct.nullable(superstruct.union([superstruct.type({}), superstruct.string()]));\n\n/**\n * Signature status for a transaction\n */\nconst SignatureStatusResult = superstruct.type({\n  err: TransactionErrorResult\n});\n\n/**\n * Transaction signature received notification\n */\nconst SignatureReceivedResult = superstruct.literal('receivedSignature');\n\n/**\n * Version info for a node\n */\n\nconst VersionResult = superstruct.type({\n  'solana-core': superstruct.string(),\n  'feature-set': superstruct.optional(superstruct.number())\n});\nconst SimulatedTransactionResponseStruct = jsonRpcResultAndContext(superstruct.type({\n  err: superstruct.nullable(superstruct.union([superstruct.type({}), superstruct.string()])),\n  logs: superstruct.nullable(superstruct.array(superstruct.string())),\n  accounts: superstruct.optional(superstruct.nullable(superstruct.array(superstruct.nullable(superstruct.type({\n    executable: superstruct.boolean(),\n    owner: superstruct.string(),\n    lamports: superstruct.number(),\n    data: superstruct.array(superstruct.string()),\n    rentEpoch: superstruct.optional(superstruct.number())\n  }))))),\n  unitsConsumed: superstruct.optional(superstruct.number()),\n  returnData: superstruct.optional(superstruct.nullable(superstruct.type({\n    programId: superstruct.string(),\n    data: superstruct.tuple([superstruct.string(), superstruct.literal('base64')])\n  })))\n}));\n\n/**\n * Metadata for a parsed confirmed transaction on the ledger\n *\n * @deprecated Deprecated since Solana v1.8.0. Please use {@link ParsedTransactionMeta} instead.\n */\n\n/**\n * Collection of addresses loaded by a transaction using address table lookups\n */\n\n/**\n * Metadata for a parsed transaction on the ledger\n */\n\n/**\n * Metadata for a confirmed transaction on the ledger\n */\n\n/**\n * A processed transaction from the RPC API\n */\n\n/**\n * A processed transaction from the RPC API\n */\n\n/**\n * A processed transaction message from the RPC API\n */\n\n/**\n * A confirmed transaction on the ledger\n *\n * @deprecated Deprecated since Solana v1.8.0.\n */\n\n/**\n * A partially decoded transaction instruction\n */\n\n/**\n * A parsed transaction message account\n */\n\n/**\n * A parsed transaction instruction\n */\n\n/**\n * A parsed address table lookup\n */\n\n/**\n * A parsed transaction message\n */\n\n/**\n * A parsed transaction\n */\n\n/**\n * A parsed and confirmed transaction on the ledger\n *\n * @deprecated Deprecated since Solana v1.8.0. Please use {@link ParsedTransactionWithMeta} instead.\n */\n\n/**\n * A parsed transaction on the ledger with meta\n */\n\n/**\n * A processed block fetched from the RPC API\n */\n\n/**\n * A processed block fetched from the RPC API where the `transactionDetails` mode is `accounts`\n */\n\n/**\n * A processed block fetched from the RPC API where the `transactionDetails` mode is `none`\n */\n\n/**\n * A block with parsed transactions\n */\n\n/**\n * A block with parsed transactions where the `transactionDetails` mode is `accounts`\n */\n\n/**\n * A block with parsed transactions where the `transactionDetails` mode is `none`\n */\n\n/**\n * A processed block fetched from the RPC API\n */\n\n/**\n * A processed block fetched from the RPC API where the `transactionDetails` mode is `accounts`\n */\n\n/**\n * A processed block fetched from the RPC API where the `transactionDetails` mode is `none`\n */\n\n/**\n * A confirmed block on the ledger\n *\n * @deprecated Deprecated since Solana v1.8.0.\n */\n\n/**\n * A Block on the ledger with signatures only\n */\n\n/**\n * recent block production information\n */\n\n/**\n * Expected JSON RPC response for the \"getBlockProduction\" message\n */\nconst BlockProductionResponseStruct = jsonRpcResultAndContext(superstruct.type({\n  byIdentity: superstruct.record(superstruct.string(), superstruct.array(superstruct.number())),\n  range: superstruct.type({\n    firstSlot: superstruct.number(),\n    lastSlot: superstruct.number()\n  })\n}));\n\n/**\n * A performance sample\n */\n\nfunction createRpcClient(url, httpHeaders, customFetch, fetchMiddleware, disableRetryOnRateLimit, httpAgent) {\n  const fetch = customFetch ? customFetch : fetchImpl;\n  let agent;\n  {\n    if (httpAgent == null) {\n      {\n        const agentOptions = {\n          // One second fewer than the Solana RPC's keepalive timeout.\n          // Read more: https://github.com/solana-labs/solana/issues/27859#issuecomment-1340097889\n          freeSocketTimeout: 19000,\n          keepAlive: true,\n          maxSockets: 25\n        };\n        if (url.startsWith('https:')) {\n          agent = new HttpsAgent(agentOptions);\n        } else {\n          agent = new HttpKeepAliveAgent(agentOptions);\n        }\n      }\n    } else {\n      if (httpAgent !== false) {\n        const isHttps = url.startsWith('https:');\n        if (isHttps && !(httpAgent instanceof require$$0$2.Agent)) {\n          throw new Error('The endpoint `' + url + '` can only be paired with an `https.Agent`. You have, instead, supplied an ' + '`http.Agent` through `httpAgent`.');\n        } else if (!isHttps && httpAgent instanceof require$$0$2.Agent) {\n          throw new Error('The endpoint `' + url + '` can only be paired with an `http.Agent`. You have, instead, supplied an ' + '`https.Agent` through `httpAgent`.');\n        }\n        agent = httpAgent;\n      }\n    }\n  }\n  let fetchWithMiddleware;\n  if (fetchMiddleware) {\n    fetchWithMiddleware = async (info, init) => {\n      const modifiedFetchArgs = await new Promise((resolve, reject) => {\n        try {\n          fetchMiddleware(info, init, (modifiedInfo, modifiedInit) => resolve([modifiedInfo, modifiedInit]));\n        } catch (error) {\n          reject(error);\n        }\n      });\n      return await fetch(...modifiedFetchArgs);\n    };\n  }\n  const clientBrowser = new RpcClient__default.default(async (request, callback) => {\n    const options = {\n      method: 'POST',\n      body: request,\n      agent,\n      headers: Object.assign({\n        'Content-Type': 'application/json'\n      }, httpHeaders || {}, COMMON_HTTP_HEADERS)\n    };\n    try {\n      let too_many_requests_retries = 5;\n      let res;\n      let waitTime = 500;\n      for (;;) {\n        if (fetchWithMiddleware) {\n          res = await fetchWithMiddleware(url, options);\n        } else {\n          res = await fetch(url, options);\n        }\n        if (res.status !== 429 /* Too many requests */) {\n          break;\n        }\n        if (disableRetryOnRateLimit === true) {\n          break;\n        }\n        too_many_requests_retries -= 1;\n        if (too_many_requests_retries === 0) {\n          break;\n        }\n        console.error(`Server responded with ${res.status} ${res.statusText}.  Retrying after ${waitTime}ms delay...`);\n        await sleep(waitTime);\n        waitTime *= 2;\n      }\n      const text = await res.text();\n      if (res.ok) {\n        callback(null, text);\n      } else {\n        callback(new Error(`${res.status} ${res.statusText}: ${text}`));\n      }\n    } catch (err) {\n      if (err instanceof Error) callback(err);\n    }\n  }, {});\n  return clientBrowser;\n}\nfunction createRpcRequest(client) {\n  return (method, args) => {\n    return new Promise((resolve, reject) => {\n      client.request(method, args, (err, response) => {\n        if (err) {\n          reject(err);\n          return;\n        }\n        resolve(response);\n      });\n    });\n  };\n}\nfunction createRpcBatchRequest(client) {\n  return requests => {\n    return new Promise((resolve, reject) => {\n      // Do nothing if requests is empty\n      if (requests.length === 0) resolve([]);\n      const batch = requests.map(params => {\n        return client.request(params.methodName, params.args);\n      });\n      client.request(batch, (err, response) => {\n        if (err) {\n          reject(err);\n          return;\n        }\n        resolve(response);\n      });\n    });\n  };\n}\n\n/**\n * Expected JSON RPC response for the \"getInflationGovernor\" message\n */\nconst GetInflationGovernorRpcResult = jsonRpcResult(GetInflationGovernorResult);\n\n/**\n * Expected JSON RPC response for the \"getInflationRate\" message\n */\nconst GetInflationRateRpcResult = jsonRpcResult(GetInflationRateResult);\n\n/**\n * Expected JSON RPC response for the \"getRecentPrioritizationFees\" message\n */\nconst GetRecentPrioritizationFeesRpcResult = jsonRpcResult(GetRecentPrioritizationFeesResult);\n\n/**\n * Expected JSON RPC response for the \"getEpochInfo\" message\n */\nconst GetEpochInfoRpcResult = jsonRpcResult(GetEpochInfoResult);\n\n/**\n * Expected JSON RPC response for the \"getEpochSchedule\" message\n */\nconst GetEpochScheduleRpcResult = jsonRpcResult(GetEpochScheduleResult);\n\n/**\n * Expected JSON RPC response for the \"getLeaderSchedule\" message\n */\nconst GetLeaderScheduleRpcResult = jsonRpcResult(GetLeaderScheduleResult);\n\n/**\n * Expected JSON RPC response for the \"minimumLedgerSlot\" and \"getFirstAvailableBlock\" messages\n */\nconst SlotRpcResult = jsonRpcResult(superstruct.number());\n\n/**\n * Supply\n */\n\n/**\n * Expected JSON RPC response for the \"getSupply\" message\n */\nconst GetSupplyRpcResult = jsonRpcResultAndContext(superstruct.type({\n  total: superstruct.number(),\n  circulating: superstruct.number(),\n  nonCirculating: superstruct.number(),\n  nonCirculatingAccounts: superstruct.array(PublicKeyFromString)\n}));\n\n/**\n * Token amount object which returns a token amount in different formats\n * for various client use cases.\n */\n\n/**\n * Expected JSON RPC structure for token amounts\n */\nconst TokenAmountResult = superstruct.type({\n  amount: superstruct.string(),\n  uiAmount: superstruct.nullable(superstruct.number()),\n  decimals: superstruct.number(),\n  uiAmountString: superstruct.optional(superstruct.string())\n});\n\n/**\n * Token address and balance.\n */\n\n/**\n * Expected JSON RPC response for the \"getTokenLargestAccounts\" message\n */\nconst GetTokenLargestAccountsResult = jsonRpcResultAndContext(superstruct.array(superstruct.type({\n  address: PublicKeyFromString,\n  amount: superstruct.string(),\n  uiAmount: superstruct.nullable(superstruct.number()),\n  decimals: superstruct.number(),\n  uiAmountString: superstruct.optional(superstruct.string())\n})));\n\n/**\n * Expected JSON RPC response for the \"getTokenAccountsByOwner\" message\n */\nconst GetTokenAccountsByOwner = jsonRpcResultAndContext(superstruct.array(superstruct.type({\n  pubkey: PublicKeyFromString,\n  account: superstruct.type({\n    executable: superstruct.boolean(),\n    owner: PublicKeyFromString,\n    lamports: superstruct.number(),\n    data: BufferFromRawAccountData,\n    rentEpoch: superstruct.number()\n  })\n})));\nconst ParsedAccountDataResult = superstruct.type({\n  program: superstruct.string(),\n  parsed: superstruct.unknown(),\n  space: superstruct.number()\n});\n\n/**\n * Expected JSON RPC response for the \"getTokenAccountsByOwner\" message with parsed data\n */\nconst GetParsedTokenAccountsByOwner = jsonRpcResultAndContext(superstruct.array(superstruct.type({\n  pubkey: PublicKeyFromString,\n  account: superstruct.type({\n    executable: superstruct.boolean(),\n    owner: PublicKeyFromString,\n    lamports: superstruct.number(),\n    data: ParsedAccountDataResult,\n    rentEpoch: superstruct.number()\n  })\n})));\n\n/**\n * Pair of an account address and its balance\n */\n\n/**\n * Expected JSON RPC response for the \"getLargestAccounts\" message\n */\nconst GetLargestAccountsRpcResult = jsonRpcResultAndContext(superstruct.array(superstruct.type({\n  lamports: superstruct.number(),\n  address: PublicKeyFromString\n})));\n\n/**\n * @internal\n */\nconst AccountInfoResult = superstruct.type({\n  executable: superstruct.boolean(),\n  owner: PublicKeyFromString,\n  lamports: superstruct.number(),\n  data: BufferFromRawAccountData,\n  rentEpoch: superstruct.number()\n});\n\n/**\n * @internal\n */\nconst KeyedAccountInfoResult = superstruct.type({\n  pubkey: PublicKeyFromString,\n  account: AccountInfoResult\n});\nconst ParsedOrRawAccountData = superstruct.coerce(superstruct.union([superstruct.instance(buffer.Buffer), ParsedAccountDataResult]), superstruct.union([RawAccountDataResult, ParsedAccountDataResult]), value => {\n  if (Array.isArray(value)) {\n    return superstruct.create(value, BufferFromRawAccountData);\n  } else {\n    return value;\n  }\n});\n\n/**\n * @internal\n */\nconst ParsedAccountInfoResult = superstruct.type({\n  executable: superstruct.boolean(),\n  owner: PublicKeyFromString,\n  lamports: superstruct.number(),\n  data: ParsedOrRawAccountData,\n  rentEpoch: superstruct.number()\n});\nconst KeyedParsedAccountInfoResult = superstruct.type({\n  pubkey: PublicKeyFromString,\n  account: ParsedAccountInfoResult\n});\n\n/**\n * @internal\n */\nconst StakeActivationResult = superstruct.type({\n  state: superstruct.union([superstruct.literal('active'), superstruct.literal('inactive'), superstruct.literal('activating'), superstruct.literal('deactivating')]),\n  active: superstruct.number(),\n  inactive: superstruct.number()\n});\n\n/**\n * Expected JSON RPC response for the \"getConfirmedSignaturesForAddress2\" message\n */\n\nconst GetConfirmedSignaturesForAddress2RpcResult = jsonRpcResult(superstruct.array(superstruct.type({\n  signature: superstruct.string(),\n  slot: superstruct.number(),\n  err: TransactionErrorResult,\n  memo: superstruct.nullable(superstruct.string()),\n  blockTime: superstruct.optional(superstruct.nullable(superstruct.number()))\n})));\n\n/**\n * Expected JSON RPC response for the \"getSignaturesForAddress\" message\n */\nconst GetSignaturesForAddressRpcResult = jsonRpcResult(superstruct.array(superstruct.type({\n  signature: superstruct.string(),\n  slot: superstruct.number(),\n  err: TransactionErrorResult,\n  memo: superstruct.nullable(superstruct.string()),\n  blockTime: superstruct.optional(superstruct.nullable(superstruct.number()))\n})));\n\n/***\n * Expected JSON RPC response for the \"accountNotification\" message\n */\nconst AccountNotificationResult = superstruct.type({\n  subscription: superstruct.number(),\n  result: notificationResultAndContext(AccountInfoResult)\n});\n\n/**\n * @internal\n */\nconst ProgramAccountInfoResult = superstruct.type({\n  pubkey: PublicKeyFromString,\n  account: AccountInfoResult\n});\n\n/***\n * Expected JSON RPC response for the \"programNotification\" message\n */\nconst ProgramAccountNotificationResult = superstruct.type({\n  subscription: superstruct.number(),\n  result: notificationResultAndContext(ProgramAccountInfoResult)\n});\n\n/**\n * @internal\n */\nconst SlotInfoResult = superstruct.type({\n  parent: superstruct.number(),\n  slot: superstruct.number(),\n  root: superstruct.number()\n});\n\n/**\n * Expected JSON RPC response for the \"slotNotification\" message\n */\nconst SlotNotificationResult = superstruct.type({\n  subscription: superstruct.number(),\n  result: SlotInfoResult\n});\n\n/**\n * Slot updates which can be used for tracking the live progress of a cluster.\n * - `\"firstShredReceived\"`: connected node received the first shred of a block.\n * Indicates that a new block that is being produced.\n * - `\"completed\"`: connected node has received all shreds of a block. Indicates\n * a block was recently produced.\n * - `\"optimisticConfirmation\"`: block was optimistically confirmed by the\n * cluster. It is not guaranteed that an optimistic confirmation notification\n * will be sent for every finalized blocks.\n * - `\"root\"`: the connected node rooted this block.\n * - `\"createdBank\"`: the connected node has started validating this block.\n * - `\"frozen\"`: the connected node has validated this block.\n * - `\"dead\"`: the connected node failed to validate this block.\n */\n\n/**\n * @internal\n */\nconst SlotUpdateResult = superstruct.union([superstruct.type({\n  type: superstruct.union([superstruct.literal('firstShredReceived'), superstruct.literal('completed'), superstruct.literal('optimisticConfirmation'), superstruct.literal('root')]),\n  slot: superstruct.number(),\n  timestamp: superstruct.number()\n}), superstruct.type({\n  type: superstruct.literal('createdBank'),\n  parent: superstruct.number(),\n  slot: superstruct.number(),\n  timestamp: superstruct.number()\n}), superstruct.type({\n  type: superstruct.literal('frozen'),\n  slot: superstruct.number(),\n  timestamp: superstruct.number(),\n  stats: superstruct.type({\n    numTransactionEntries: superstruct.number(),\n    numSuccessfulTransactions: superstruct.number(),\n    numFailedTransactions: superstruct.number(),\n    maxTransactionsPerEntry: superstruct.number()\n  })\n}), superstruct.type({\n  type: superstruct.literal('dead'),\n  slot: superstruct.number(),\n  timestamp: superstruct.number(),\n  err: superstruct.string()\n})]);\n\n/**\n * Expected JSON RPC response for the \"slotsUpdatesNotification\" message\n */\nconst SlotUpdateNotificationResult = superstruct.type({\n  subscription: superstruct.number(),\n  result: SlotUpdateResult\n});\n\n/**\n * Expected JSON RPC response for the \"signatureNotification\" message\n */\nconst SignatureNotificationResult = superstruct.type({\n  subscription: superstruct.number(),\n  result: notificationResultAndContext(superstruct.union([SignatureStatusResult, SignatureReceivedResult]))\n});\n\n/**\n * Expected JSON RPC response for the \"rootNotification\" message\n */\nconst RootNotificationResult = superstruct.type({\n  subscription: superstruct.number(),\n  result: superstruct.number()\n});\nconst ContactInfoResult = superstruct.type({\n  pubkey: superstruct.string(),\n  gossip: superstruct.nullable(superstruct.string()),\n  tpu: superstruct.nullable(superstruct.string()),\n  rpc: superstruct.nullable(superstruct.string()),\n  version: superstruct.nullable(superstruct.string())\n});\nconst VoteAccountInfoResult = superstruct.type({\n  votePubkey: superstruct.string(),\n  nodePubkey: superstruct.string(),\n  activatedStake: superstruct.number(),\n  epochVoteAccount: superstruct.boolean(),\n  epochCredits: superstruct.array(superstruct.tuple([superstruct.number(), superstruct.number(), superstruct.number()])),\n  commission: superstruct.number(),\n  lastVote: superstruct.number(),\n  rootSlot: superstruct.nullable(superstruct.number())\n});\n\n/**\n * Expected JSON RPC response for the \"getVoteAccounts\" message\n */\nconst GetVoteAccounts = jsonRpcResult(superstruct.type({\n  current: superstruct.array(VoteAccountInfoResult),\n  delinquent: superstruct.array(VoteAccountInfoResult)\n}));\nconst ConfirmationStatus = superstruct.union([superstruct.literal('processed'), superstruct.literal('confirmed'), superstruct.literal('finalized')]);\nconst SignatureStatusResponse = superstruct.type({\n  slot: superstruct.number(),\n  confirmations: superstruct.nullable(superstruct.number()),\n  err: TransactionErrorResult,\n  confirmationStatus: superstruct.optional(ConfirmationStatus)\n});\n\n/**\n * Expected JSON RPC response for the \"getSignatureStatuses\" message\n */\nconst GetSignatureStatusesRpcResult = jsonRpcResultAndContext(superstruct.array(superstruct.nullable(SignatureStatusResponse)));\n\n/**\n * Expected JSON RPC response for the \"getMinimumBalanceForRentExemption\" message\n */\nconst GetMinimumBalanceForRentExemptionRpcResult = jsonRpcResult(superstruct.number());\nconst AddressTableLookupStruct = superstruct.type({\n  accountKey: PublicKeyFromString,\n  writableIndexes: superstruct.array(superstruct.number()),\n  readonlyIndexes: superstruct.array(superstruct.number())\n});\nconst ConfirmedTransactionResult = superstruct.type({\n  signatures: superstruct.array(superstruct.string()),\n  message: superstruct.type({\n    accountKeys: superstruct.array(superstruct.string()),\n    header: superstruct.type({\n      numRequiredSignatures: superstruct.number(),\n      numReadonlySignedAccounts: superstruct.number(),\n      numReadonlyUnsignedAccounts: superstruct.number()\n    }),\n    instructions: superstruct.array(superstruct.type({\n      accounts: superstruct.array(superstruct.number()),\n      data: superstruct.string(),\n      programIdIndex: superstruct.number()\n    })),\n    recentBlockhash: superstruct.string(),\n    addressTableLookups: superstruct.optional(superstruct.array(AddressTableLookupStruct))\n  })\n});\nconst AnnotatedAccountKey = superstruct.type({\n  pubkey: PublicKeyFromString,\n  signer: superstruct.boolean(),\n  writable: superstruct.boolean(),\n  source: superstruct.optional(superstruct.union([superstruct.literal('transaction'), superstruct.literal('lookupTable')]))\n});\nconst ConfirmedTransactionAccountsModeResult = superstruct.type({\n  accountKeys: superstruct.array(AnnotatedAccountKey),\n  signatures: superstruct.array(superstruct.string())\n});\nconst ParsedInstructionResult = superstruct.type({\n  parsed: superstruct.unknown(),\n  program: superstruct.string(),\n  programId: PublicKeyFromString\n});\nconst RawInstructionResult = superstruct.type({\n  accounts: superstruct.array(PublicKeyFromString),\n  data: superstruct.string(),\n  programId: PublicKeyFromString\n});\nconst InstructionResult = superstruct.union([RawInstructionResult, ParsedInstructionResult]);\nconst UnknownInstructionResult = superstruct.union([superstruct.type({\n  parsed: superstruct.unknown(),\n  program: superstruct.string(),\n  programId: superstruct.string()\n}), superstruct.type({\n  accounts: superstruct.array(superstruct.string()),\n  data: superstruct.string(),\n  programId: superstruct.string()\n})]);\nconst ParsedOrRawInstruction = superstruct.coerce(InstructionResult, UnknownInstructionResult, value => {\n  if ('accounts' in value) {\n    return superstruct.create(value, RawInstructionResult);\n  } else {\n    return superstruct.create(value, ParsedInstructionResult);\n  }\n});\n\n/**\n * @internal\n */\nconst ParsedConfirmedTransactionResult = superstruct.type({\n  signatures: superstruct.array(superstruct.string()),\n  message: superstruct.type({\n    accountKeys: superstruct.array(AnnotatedAccountKey),\n    instructions: superstruct.array(ParsedOrRawInstruction),\n    recentBlockhash: superstruct.string(),\n    addressTableLookups: superstruct.optional(superstruct.nullable(superstruct.array(AddressTableLookupStruct)))\n  })\n});\nconst TokenBalanceResult = superstruct.type({\n  accountIndex: superstruct.number(),\n  mint: superstruct.string(),\n  owner: superstruct.optional(superstruct.string()),\n  uiTokenAmount: TokenAmountResult\n});\nconst LoadedAddressesResult = superstruct.type({\n  writable: superstruct.array(PublicKeyFromString),\n  readonly: superstruct.array(PublicKeyFromString)\n});\n\n/**\n * @internal\n */\nconst ConfirmedTransactionMetaResult = superstruct.type({\n  err: TransactionErrorResult,\n  fee: superstruct.number(),\n  innerInstructions: superstruct.optional(superstruct.nullable(superstruct.array(superstruct.type({\n    index: superstruct.number(),\n    instructions: superstruct.array(superstruct.type({\n      accounts: superstruct.array(superstruct.number()),\n      data: superstruct.string(),\n      programIdIndex: superstruct.number()\n    }))\n  })))),\n  preBalances: superstruct.array(superstruct.number()),\n  postBalances: superstruct.array(superstruct.number()),\n  logMessages: superstruct.optional(superstruct.nullable(superstruct.array(superstruct.string()))),\n  preTokenBalances: superstruct.optional(superstruct.nullable(superstruct.array(TokenBalanceResult))),\n  postTokenBalances: superstruct.optional(superstruct.nullable(superstruct.array(TokenBalanceResult))),\n  loadedAddresses: superstruct.optional(LoadedAddressesResult),\n  computeUnitsConsumed: superstruct.optional(superstruct.number())\n});\n\n/**\n * @internal\n */\nconst ParsedConfirmedTransactionMetaResult = superstruct.type({\n  err: TransactionErrorResult,\n  fee: superstruct.number(),\n  innerInstructions: superstruct.optional(superstruct.nullable(superstruct.array(superstruct.type({\n    index: superstruct.number(),\n    instructions: superstruct.array(ParsedOrRawInstruction)\n  })))),\n  preBalances: superstruct.array(superstruct.number()),\n  postBalances: superstruct.array(superstruct.number()),\n  logMessages: superstruct.optional(superstruct.nullable(superstruct.array(superstruct.string()))),\n  preTokenBalances: superstruct.optional(superstruct.nullable(superstruct.array(TokenBalanceResult))),\n  postTokenBalances: superstruct.optional(superstruct.nullable(superstruct.array(TokenBalanceResult))),\n  loadedAddresses: superstruct.optional(LoadedAddressesResult),\n  computeUnitsConsumed: superstruct.optional(superstruct.number())\n});\nconst TransactionVersionStruct = superstruct.union([superstruct.literal(0), superstruct.literal('legacy')]);\n\n/** @internal */\nconst RewardsResult = superstruct.type({\n  pubkey: superstruct.string(),\n  lamports: superstruct.number(),\n  postBalance: superstruct.nullable(superstruct.number()),\n  rewardType: superstruct.nullable(superstruct.string()),\n  commission: superstruct.optional(superstruct.nullable(superstruct.number()))\n});\n\n/**\n * Expected JSON RPC response for the \"getBlock\" message\n */\nconst GetBlockRpcResult = jsonRpcResult(superstruct.nullable(superstruct.type({\n  blockhash: superstruct.string(),\n  previousBlockhash: superstruct.string(),\n  parentSlot: superstruct.number(),\n  transactions: superstruct.array(superstruct.type({\n    transaction: ConfirmedTransactionResult,\n    meta: superstruct.nullable(ConfirmedTransactionMetaResult),\n    version: superstruct.optional(TransactionVersionStruct)\n  })),\n  rewards: superstruct.optional(superstruct.array(RewardsResult)),\n  blockTime: superstruct.nullable(superstruct.number()),\n  blockHeight: superstruct.nullable(superstruct.number())\n})));\n\n/**\n * Expected JSON RPC response for the \"getBlock\" message when `transactionDetails` is `none`\n */\nconst GetNoneModeBlockRpcResult = jsonRpcResult(superstruct.nullable(superstruct.type({\n  blockhash: superstruct.string(),\n  previousBlockhash: superstruct.string(),\n  parentSlot: superstruct.number(),\n  rewards: superstruct.optional(superstruct.array(RewardsResult)),\n  blockTime: superstruct.nullable(superstruct.number()),\n  blockHeight: superstruct.nullable(superstruct.number())\n})));\n\n/**\n * Expected JSON RPC response for the \"getBlock\" message when `transactionDetails` is `accounts`\n */\nconst GetAccountsModeBlockRpcResult = jsonRpcResult(superstruct.nullable(superstruct.type({\n  blockhash: superstruct.string(),\n  previousBlockhash: superstruct.string(),\n  parentSlot: superstruct.number(),\n  transactions: superstruct.array(superstruct.type({\n    transaction: ConfirmedTransactionAccountsModeResult,\n    meta: superstruct.nullable(ConfirmedTransactionMetaResult),\n    version: superstruct.optional(TransactionVersionStruct)\n  })),\n  rewards: superstruct.optional(superstruct.array(RewardsResult)),\n  blockTime: superstruct.nullable(superstruct.number()),\n  blockHeight: superstruct.nullable(superstruct.number())\n})));\n\n/**\n * Expected parsed JSON RPC response for the \"getBlock\" message\n */\nconst GetParsedBlockRpcResult = jsonRpcResult(superstruct.nullable(superstruct.type({\n  blockhash: superstruct.string(),\n  previousBlockhash: superstruct.string(),\n  parentSlot: superstruct.number(),\n  transactions: superstruct.array(superstruct.type({\n    transaction: ParsedConfirmedTransactionResult,\n    meta: superstruct.nullable(ParsedConfirmedTransactionMetaResult),\n    version: superstruct.optional(TransactionVersionStruct)\n  })),\n  rewards: superstruct.optional(superstruct.array(RewardsResult)),\n  blockTime: superstruct.nullable(superstruct.number()),\n  blockHeight: superstruct.nullable(superstruct.number())\n})));\n\n/**\n * Expected parsed JSON RPC response for the \"getBlock\" message  when `transactionDetails` is `accounts`\n */\nconst GetParsedAccountsModeBlockRpcResult = jsonRpcResult(superstruct.nullable(superstruct.type({\n  blockhash: superstruct.string(),\n  previousBlockhash: superstruct.string(),\n  parentSlot: superstruct.number(),\n  transactions: superstruct.array(superstruct.type({\n    transaction: ConfirmedTransactionAccountsModeResult,\n    meta: superstruct.nullable(ParsedConfirmedTransactionMetaResult),\n    version: superstruct.optional(TransactionVersionStruct)\n  })),\n  rewards: superstruct.optional(superstruct.array(RewardsResult)),\n  blockTime: superstruct.nullable(superstruct.number()),\n  blockHeight: superstruct.nullable(superstruct.number())\n})));\n\n/**\n * Expected parsed JSON RPC response for the \"getBlock\" message  when `transactionDetails` is `none`\n */\nconst GetParsedNoneModeBlockRpcResult = jsonRpcResult(superstruct.nullable(superstruct.type({\n  blockhash: superstruct.string(),\n  previousBlockhash: superstruct.string(),\n  parentSlot: superstruct.number(),\n  rewards: superstruct.optional(superstruct.array(RewardsResult)),\n  blockTime: superstruct.nullable(superstruct.number()),\n  blockHeight: superstruct.nullable(superstruct.number())\n})));\n\n/**\n * Expected JSON RPC response for the \"getConfirmedBlock\" message\n *\n * @deprecated Deprecated since Solana v1.8.0. Please use {@link GetBlockRpcResult} instead.\n */\nconst GetConfirmedBlockRpcResult = jsonRpcResult(superstruct.nullable(superstruct.type({\n  blockhash: superstruct.string(),\n  previousBlockhash: superstruct.string(),\n  parentSlot: superstruct.number(),\n  transactions: superstruct.array(superstruct.type({\n    transaction: ConfirmedTransactionResult,\n    meta: superstruct.nullable(ConfirmedTransactionMetaResult)\n  })),\n  rewards: superstruct.optional(superstruct.array(RewardsResult)),\n  blockTime: superstruct.nullable(superstruct.number())\n})));\n\n/**\n * Expected JSON RPC response for the \"getBlock\" message\n */\nconst GetBlockSignaturesRpcResult = jsonRpcResult(superstruct.nullable(superstruct.type({\n  blockhash: superstruct.string(),\n  previousBlockhash: superstruct.string(),\n  parentSlot: superstruct.number(),\n  signatures: superstruct.array(superstruct.string()),\n  blockTime: superstruct.nullable(superstruct.number())\n})));\n\n/**\n * Expected JSON RPC response for the \"getTransaction\" message\n */\nconst GetTransactionRpcResult = jsonRpcResult(superstruct.nullable(superstruct.type({\n  slot: superstruct.number(),\n  meta: superstruct.nullable(ConfirmedTransactionMetaResult),\n  blockTime: superstruct.optional(superstruct.nullable(superstruct.number())),\n  transaction: ConfirmedTransactionResult,\n  version: superstruct.optional(TransactionVersionStruct)\n})));\n\n/**\n * Expected parsed JSON RPC response for the \"getTransaction\" message\n */\nconst GetParsedTransactionRpcResult = jsonRpcResult(superstruct.nullable(superstruct.type({\n  slot: superstruct.number(),\n  transaction: ParsedConfirmedTransactionResult,\n  meta: superstruct.nullable(ParsedConfirmedTransactionMetaResult),\n  blockTime: superstruct.optional(superstruct.nullable(superstruct.number())),\n  version: superstruct.optional(TransactionVersionStruct)\n})));\n\n/**\n * Expected JSON RPC response for the \"getRecentBlockhash\" message\n *\n * @deprecated Deprecated since Solana v1.8.0. Please use {@link GetLatestBlockhashRpcResult} instead.\n */\nconst GetRecentBlockhashAndContextRpcResult = jsonRpcResultAndContext(superstruct.type({\n  blockhash: superstruct.string(),\n  feeCalculator: superstruct.type({\n    lamportsPerSignature: superstruct.number()\n  })\n}));\n\n/**\n * Expected JSON RPC response for the \"getLatestBlockhash\" message\n */\nconst GetLatestBlockhashRpcResult = jsonRpcResultAndContext(superstruct.type({\n  blockhash: superstruct.string(),\n  lastValidBlockHeight: superstruct.number()\n}));\n\n/**\n * Expected JSON RPC response for the \"isBlockhashValid\" message\n */\nconst IsBlockhashValidRpcResult = jsonRpcResultAndContext(superstruct.boolean());\nconst PerfSampleResult = superstruct.type({\n  slot: superstruct.number(),\n  numTransactions: superstruct.number(),\n  numSlots: superstruct.number(),\n  samplePeriodSecs: superstruct.number()\n});\n\n/*\n * Expected JSON RPC response for \"getRecentPerformanceSamples\" message\n */\nconst GetRecentPerformanceSamplesRpcResult = jsonRpcResult(superstruct.array(PerfSampleResult));\n\n/**\n * Expected JSON RPC response for the \"getFeeCalculatorForBlockhash\" message\n */\nconst GetFeeCalculatorRpcResult = jsonRpcResultAndContext(superstruct.nullable(superstruct.type({\n  feeCalculator: superstruct.type({\n    lamportsPerSignature: superstruct.number()\n  })\n})));\n\n/**\n * Expected JSON RPC response for the \"requestAirdrop\" message\n */\nconst RequestAirdropRpcResult = jsonRpcResult(superstruct.string());\n\n/**\n * Expected JSON RPC response for the \"sendTransaction\" message\n */\nconst SendTransactionRpcResult = jsonRpcResult(superstruct.string());\n\n/**\n * Information about the latest slot being processed by a node\n */\n\n/**\n * Parsed account data\n */\n\n/**\n * Stake Activation data\n */\n\n/**\n * Data slice argument for getProgramAccounts\n */\n\n/**\n * Memory comparison filter for getProgramAccounts\n */\n\n/**\n * Data size comparison filter for getProgramAccounts\n */\n\n/**\n * A filter object for getProgramAccounts\n */\n\n/**\n * Configuration object for getProgramAccounts requests\n */\n\n/**\n * Configuration object for getParsedProgramAccounts\n */\n\n/**\n * Configuration object for getMultipleAccounts\n */\n\n/**\n * Configuration object for `getStakeActivation`\n */\n\n/**\n * Configuration object for `getStakeActivation`\n */\n\n/**\n * Configuration object for `getStakeActivation`\n */\n\n/**\n * Configuration object for `getNonce`\n */\n\n/**\n * Configuration object for `getNonceAndContext`\n */\n\n/**\n * Information describing an account\n */\n\n/**\n * Account information identified by pubkey\n */\n\n/**\n * Callback function for account change notifications\n */\n\n/**\n * Callback function for program account change notifications\n */\n\n/**\n * Callback function for slot change notifications\n */\n\n/**\n * Callback function for slot update notifications\n */\n\n/**\n * Callback function for signature status notifications\n */\n\n/**\n * Signature status notification with transaction result\n */\n\n/**\n * Signature received notification\n */\n\n/**\n * Callback function for signature notifications\n */\n\n/**\n * Signature subscription options\n */\n\n/**\n * Callback function for root change notifications\n */\n\n/**\n * @internal\n */\nconst LogsResult = superstruct.type({\n  err: TransactionErrorResult,\n  logs: superstruct.array(superstruct.string()),\n  signature: superstruct.string()\n});\n\n/**\n * Logs result.\n */\n\n/**\n * Expected JSON RPC response for the \"logsNotification\" message.\n */\nconst LogsNotificationResult = superstruct.type({\n  result: notificationResultAndContext(LogsResult),\n  subscription: superstruct.number()\n});\n\n/**\n * Filter for log subscriptions.\n */\n\n/**\n * Callback function for log notifications.\n */\n\n/**\n * Signature result\n */\n\n/**\n * Transaction error\n */\n\n/**\n * Transaction confirmation status\n * <pre>\n *   'processed': Transaction landed in a block which has reached 1 confirmation by the connected node\n *   'confirmed': Transaction landed in a block which has reached 1 confirmation by the cluster\n *   'finalized': Transaction landed in a block which has been finalized by the cluster\n * </pre>\n */\n\n/**\n * Signature status\n */\n\n/**\n * A confirmed signature with its status\n */\n\n/**\n * An object defining headers to be passed to the RPC server\n */\n\n/**\n * The type of the JavaScript `fetch()` API\n */\n\n/**\n * A callback used to augment the outgoing HTTP request\n */\n\n/**\n * Configuration for instantiating a Connection\n */\n\n/** @internal */\nconst COMMON_HTTP_HEADERS = {\n  'solana-client': `js/${\"0.0.0-development\" }`\n};\n\n/**\n * A connection to a fullnode JSON RPC endpoint\n */\nclass Connection {\n  /**\n   * Establish a JSON RPC connection\n   *\n   * @param endpoint URL to the fullnode JSON RPC endpoint\n   * @param commitmentOrConfig optional default commitment level or optional ConnectionConfig configuration object\n   */\n  constructor(endpoint, _commitmentOrConfig) {\n    /** @internal */\n    this._commitment = void 0;\n    /** @internal */\n    this._confirmTransactionInitialTimeout = void 0;\n    /** @internal */\n    this._rpcEndpoint = void 0;\n    /** @internal */\n    this._rpcWsEndpoint = void 0;\n    /** @internal */\n    this._rpcClient = void 0;\n    /** @internal */\n    this._rpcRequest = void 0;\n    /** @internal */\n    this._rpcBatchRequest = void 0;\n    /** @internal */\n    this._rpcWebSocket = void 0;\n    /** @internal */\n    this._rpcWebSocketConnected = false;\n    /** @internal */\n    this._rpcWebSocketHeartbeat = null;\n    /** @internal */\n    this._rpcWebSocketIdleTimeout = null;\n    /** @internal\n     * A number that we increment every time an active connection closes.\n     * Used to determine whether the same socket connection that was open\n     * when an async operation started is the same one that's active when\n     * its continuation fires.\n     *\n     */\n    this._rpcWebSocketGeneration = 0;\n    /** @internal */\n    this._disableBlockhashCaching = false;\n    /** @internal */\n    this._pollingBlockhash = false;\n    /** @internal */\n    this._blockhashInfo = {\n      latestBlockhash: null,\n      lastFetch: 0,\n      transactionSignatures: [],\n      simulatedSignatures: []\n    };\n    /** @internal */\n    this._nextClientSubscriptionId = 0;\n    /** @internal */\n    this._subscriptionDisposeFunctionsByClientSubscriptionId = {};\n    /** @internal */\n    this._subscriptionHashByClientSubscriptionId = {};\n    /** @internal */\n    this._subscriptionStateChangeCallbacksByHash = {};\n    /** @internal */\n    this._subscriptionCallbacksByServerSubscriptionId = {};\n    /** @internal */\n    this._subscriptionsByHash = {};\n    /**\n     * Special case.\n     * After a signature is processed, RPCs automatically dispose of the\n     * subscription on the server side. We need to track which of these\n     * subscriptions have been disposed in such a way, so that we know\n     * whether the client is dealing with a not-yet-processed signature\n     * (in which case we must tear down the server subscription) or an\n     * already-processed signature (in which case the client can simply\n     * clear out the subscription locally without telling the server).\n     *\n     * NOTE: There is a proposal to eliminate this special case, here:\n     * https://github.com/solana-labs/solana/issues/18892\n     */\n    /** @internal */\n    this._subscriptionsAutoDisposedByRpc = new Set();\n    /*\n     * Returns the current block height of the node\n     */\n    this.getBlockHeight = (() => {\n      const requestPromises = {};\n      return async commitmentOrConfig => {\n        const {\n          commitment,\n          config\n        } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([], commitment, undefined /* encoding */, config);\n        const requestHash = fastStableStringify$1(args);\n        requestPromises[requestHash] = requestPromises[requestHash] ?? (async () => {\n          try {\n            const unsafeRes = await this._rpcRequest('getBlockHeight', args);\n            const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.number()));\n            if ('error' in res) {\n              throw new SolanaJSONRPCError(res.error, 'failed to get block height information');\n            }\n            return res.result;\n          } finally {\n            delete requestPromises[requestHash];\n          }\n        })();\n        return await requestPromises[requestHash];\n      };\n    })();\n    let wsEndpoint;\n    let httpHeaders;\n    let fetch;\n    let fetchMiddleware;\n    let disableRetryOnRateLimit;\n    let httpAgent;\n    if (_commitmentOrConfig && typeof _commitmentOrConfig === 'string') {\n      this._commitment = _commitmentOrConfig;\n    } else if (_commitmentOrConfig) {\n      this._commitment = _commitmentOrConfig.commitment;\n      this._confirmTransactionInitialTimeout = _commitmentOrConfig.confirmTransactionInitialTimeout;\n      wsEndpoint = _commitmentOrConfig.wsEndpoint;\n      httpHeaders = _commitmentOrConfig.httpHeaders;\n      fetch = _commitmentOrConfig.fetch;\n      fetchMiddleware = _commitmentOrConfig.fetchMiddleware;\n      disableRetryOnRateLimit = _commitmentOrConfig.disableRetryOnRateLimit;\n      httpAgent = _commitmentOrConfig.httpAgent;\n    }\n    this._rpcEndpoint = assertEndpointUrl(endpoint);\n    this._rpcWsEndpoint = wsEndpoint || makeWebsocketUrl(endpoint);\n    this._rpcClient = createRpcClient(endpoint, httpHeaders, fetch, fetchMiddleware, disableRetryOnRateLimit, httpAgent);\n    this._rpcRequest = createRpcRequest(this._rpcClient);\n    this._rpcBatchRequest = createRpcBatchRequest(this._rpcClient);\n    this._rpcWebSocket = new RpcWebSocketClient(this._rpcWsEndpoint, {\n      autoconnect: false,\n      max_reconnects: Infinity\n    });\n    this._rpcWebSocket.on('open', this._wsOnOpen.bind(this));\n    this._rpcWebSocket.on('error', this._wsOnError.bind(this));\n    this._rpcWebSocket.on('close', this._wsOnClose.bind(this));\n    this._rpcWebSocket.on('accountNotification', this._wsOnAccountNotification.bind(this));\n    this._rpcWebSocket.on('programNotification', this._wsOnProgramAccountNotification.bind(this));\n    this._rpcWebSocket.on('slotNotification', this._wsOnSlotNotification.bind(this));\n    this._rpcWebSocket.on('slotsUpdatesNotification', this._wsOnSlotUpdatesNotification.bind(this));\n    this._rpcWebSocket.on('signatureNotification', this._wsOnSignatureNotification.bind(this));\n    this._rpcWebSocket.on('rootNotification', this._wsOnRootNotification.bind(this));\n    this._rpcWebSocket.on('logsNotification', this._wsOnLogsNotification.bind(this));\n  }\n\n  /**\n   * The default commitment used for requests\n   */\n  get commitment() {\n    return this._commitment;\n  }\n\n  /**\n   * The RPC endpoint\n   */\n  get rpcEndpoint() {\n    return this._rpcEndpoint;\n  }\n\n  /**\n   * Fetch the balance for the specified public key, return with context\n   */\n  async getBalanceAndContext(publicKey, commitmentOrConfig) {\n    /** @internal */\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(commitmentOrConfig);\n    const args = this._buildArgs([publicKey.toBase58()], commitment, undefined /* encoding */, config);\n    const unsafeRes = await this._rpcRequest('getBalance', args);\n    const res = superstruct.create(unsafeRes, jsonRpcResultAndContext(superstruct.number()));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, `failed to get balance for ${publicKey.toBase58()}`);\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the balance for the specified public key\n   */\n  async getBalance(publicKey, commitmentOrConfig) {\n    return await this.getBalanceAndContext(publicKey, commitmentOrConfig).then(x => x.value).catch(e => {\n      throw new Error('failed to get balance of account ' + publicKey.toBase58() + ': ' + e);\n    });\n  }\n\n  /**\n   * Fetch the estimated production time of a block\n   */\n  async getBlockTime(slot) {\n    const unsafeRes = await this._rpcRequest('getBlockTime', [slot]);\n    const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.nullable(superstruct.number())));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, `failed to get block time for slot ${slot}`);\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the lowest slot that the node has information about in its ledger.\n   * This value may increase over time if the node is configured to purge older ledger data\n   */\n  async getMinimumLedgerSlot() {\n    const unsafeRes = await this._rpcRequest('minimumLedgerSlot', []);\n    const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.number()));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get minimum ledger slot');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the slot of the lowest confirmed block that has not been purged from the ledger\n   */\n  async getFirstAvailableBlock() {\n    const unsafeRes = await this._rpcRequest('getFirstAvailableBlock', []);\n    const res = superstruct.create(unsafeRes, SlotRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get first available block');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch information about the current supply\n   */\n  async getSupply(config) {\n    let configArg = {};\n    if (typeof config === 'string') {\n      configArg = {\n        commitment: config\n      };\n    } else if (config) {\n      configArg = {\n        ...config,\n        commitment: config && config.commitment || this.commitment\n      };\n    } else {\n      configArg = {\n        commitment: this.commitment\n      };\n    }\n    const unsafeRes = await this._rpcRequest('getSupply', [configArg]);\n    const res = superstruct.create(unsafeRes, GetSupplyRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get supply');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the current supply of a token mint\n   */\n  async getTokenSupply(tokenMintAddress, commitment) {\n    const args = this._buildArgs([tokenMintAddress.toBase58()], commitment);\n    const unsafeRes = await this._rpcRequest('getTokenSupply', args);\n    const res = superstruct.create(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get token supply');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the current balance of a token account\n   */\n  async getTokenAccountBalance(tokenAddress, commitment) {\n    const args = this._buildArgs([tokenAddress.toBase58()], commitment);\n    const unsafeRes = await this._rpcRequest('getTokenAccountBalance', args);\n    const res = superstruct.create(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get token account balance');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch all the token accounts owned by the specified account\n   *\n   * @return {Promise<RpcResponseAndContext<GetProgramAccountsResponse>}\n   */\n  async getTokenAccountsByOwner(ownerAddress, filter, commitmentOrConfig) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(commitmentOrConfig);\n    let _args = [ownerAddress.toBase58()];\n    if ('mint' in filter) {\n      _args.push({\n        mint: filter.mint.toBase58()\n      });\n    } else {\n      _args.push({\n        programId: filter.programId.toBase58()\n      });\n    }\n    const args = this._buildArgs(_args, commitment, 'base64', config);\n    const unsafeRes = await this._rpcRequest('getTokenAccountsByOwner', args);\n    const res = superstruct.create(unsafeRes, GetTokenAccountsByOwner);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, `failed to get token accounts owned by account ${ownerAddress.toBase58()}`);\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch parsed token accounts owned by the specified account\n   *\n   * @return {Promise<RpcResponseAndContext<Array<{pubkey: PublicKey, account: AccountInfo<ParsedAccountData>}>>>}\n   */\n  async getParsedTokenAccountsByOwner(ownerAddress, filter, commitment) {\n    let _args = [ownerAddress.toBase58()];\n    if ('mint' in filter) {\n      _args.push({\n        mint: filter.mint.toBase58()\n      });\n    } else {\n      _args.push({\n        programId: filter.programId.toBase58()\n      });\n    }\n    const args = this._buildArgs(_args, commitment, 'jsonParsed');\n    const unsafeRes = await this._rpcRequest('getTokenAccountsByOwner', args);\n    const res = superstruct.create(unsafeRes, GetParsedTokenAccountsByOwner);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, `failed to get token accounts owned by account ${ownerAddress.toBase58()}`);\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the 20 largest accounts with their current balances\n   */\n  async getLargestAccounts(config) {\n    const arg = {\n      ...config,\n      commitment: config && config.commitment || this.commitment\n    };\n    const args = arg.filter || arg.commitment ? [arg] : [];\n    const unsafeRes = await this._rpcRequest('getLargestAccounts', args);\n    const res = superstruct.create(unsafeRes, GetLargestAccountsRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get largest accounts');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the 20 largest token accounts with their current balances\n   * for a given mint.\n   */\n  async getTokenLargestAccounts(mintAddress, commitment) {\n    const args = this._buildArgs([mintAddress.toBase58()], commitment);\n    const unsafeRes = await this._rpcRequest('getTokenLargestAccounts', args);\n    const res = superstruct.create(unsafeRes, GetTokenLargestAccountsResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get token largest accounts');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch all the account info for the specified public key, return with context\n   */\n  async getAccountInfoAndContext(publicKey, commitmentOrConfig) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(commitmentOrConfig);\n    const args = this._buildArgs([publicKey.toBase58()], commitment, 'base64', config);\n    const unsafeRes = await this._rpcRequest('getAccountInfo', args);\n    const res = superstruct.create(unsafeRes, jsonRpcResultAndContext(superstruct.nullable(AccountInfoResult)));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, `failed to get info about account ${publicKey.toBase58()}`);\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch parsed account info for the specified public key\n   */\n  async getParsedAccountInfo(publicKey, commitmentOrConfig) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(commitmentOrConfig);\n    const args = this._buildArgs([publicKey.toBase58()], commitment, 'jsonParsed', config);\n    const unsafeRes = await this._rpcRequest('getAccountInfo', args);\n    const res = superstruct.create(unsafeRes, jsonRpcResultAndContext(superstruct.nullable(ParsedAccountInfoResult)));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, `failed to get info about account ${publicKey.toBase58()}`);\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch all the account info for the specified public key\n   */\n  async getAccountInfo(publicKey, commitmentOrConfig) {\n    try {\n      const res = await this.getAccountInfoAndContext(publicKey, commitmentOrConfig);\n      return res.value;\n    } catch (e) {\n      throw new Error('failed to get info about account ' + publicKey.toBase58() + ': ' + e);\n    }\n  }\n\n  /**\n   * Fetch all the account info for multiple accounts specified by an array of public keys, return with context\n   */\n  async getMultipleParsedAccounts(publicKeys, rawConfig) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(rawConfig);\n    const keys = publicKeys.map(key => key.toBase58());\n    const args = this._buildArgs([keys], commitment, 'jsonParsed', config);\n    const unsafeRes = await this._rpcRequest('getMultipleAccounts', args);\n    const res = superstruct.create(unsafeRes, jsonRpcResultAndContext(superstruct.array(superstruct.nullable(ParsedAccountInfoResult))));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, `failed to get info for accounts ${keys}`);\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch all the account info for multiple accounts specified by an array of public keys, return with context\n   */\n  async getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(commitmentOrConfig);\n    const keys = publicKeys.map(key => key.toBase58());\n    const args = this._buildArgs([keys], commitment, 'base64', config);\n    const unsafeRes = await this._rpcRequest('getMultipleAccounts', args);\n    const res = superstruct.create(unsafeRes, jsonRpcResultAndContext(superstruct.array(superstruct.nullable(AccountInfoResult))));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, `failed to get info for accounts ${keys}`);\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch all the account info for multiple accounts specified by an array of public keys\n   */\n  async getMultipleAccountsInfo(publicKeys, commitmentOrConfig) {\n    const res = await this.getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig);\n    return res.value;\n  }\n\n  /**\n   * Returns epoch activation information for a stake account that has been delegated\n   */\n  async getStakeActivation(publicKey, commitmentOrConfig, epoch) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(commitmentOrConfig);\n    const args = this._buildArgs([publicKey.toBase58()], commitment, undefined /* encoding */, {\n      ...config,\n      epoch: epoch != null ? epoch : config?.epoch\n    });\n    const unsafeRes = await this._rpcRequest('getStakeActivation', args);\n    const res = superstruct.create(unsafeRes, jsonRpcResult(StakeActivationResult));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, `failed to get Stake Activation ${publicKey.toBase58()}`);\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch all the accounts owned by the specified program id\n   *\n   * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer>}>>}\n   */\n\n  // eslint-disable-next-line no-dupe-class-members\n\n  // eslint-disable-next-line no-dupe-class-members\n  async getProgramAccounts(programId, configOrCommitment) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(configOrCommitment);\n    const {\n      encoding,\n      ...configWithoutEncoding\n    } = config || {};\n    const args = this._buildArgs([programId.toBase58()], commitment, encoding || 'base64', configWithoutEncoding);\n    const unsafeRes = await this._rpcRequest('getProgramAccounts', args);\n    const baseSchema = superstruct.array(KeyedAccountInfoResult);\n    const res = configWithoutEncoding.withContext === true ? superstruct.create(unsafeRes, jsonRpcResultAndContext(baseSchema)) : superstruct.create(unsafeRes, jsonRpcResult(baseSchema));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, `failed to get accounts owned by program ${programId.toBase58()}`);\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch and parse all the accounts owned by the specified program id\n   *\n   * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer | ParsedAccountData>}>>}\n   */\n  async getParsedProgramAccounts(programId, configOrCommitment) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(configOrCommitment);\n    const args = this._buildArgs([programId.toBase58()], commitment, 'jsonParsed', config);\n    const unsafeRes = await this._rpcRequest('getProgramAccounts', args);\n    const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.array(KeyedParsedAccountInfoResult)));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, `failed to get accounts owned by program ${programId.toBase58()}`);\n    }\n    return res.result;\n  }\n\n  /** @deprecated Instead, call `confirmTransaction` and pass in {@link TransactionConfirmationStrategy} */\n  // eslint-disable-next-line no-dupe-class-members\n\n  // eslint-disable-next-line no-dupe-class-members\n  async confirmTransaction(strategy, commitment) {\n    let rawSignature;\n    if (typeof strategy == 'string') {\n      rawSignature = strategy;\n    } else {\n      const config = strategy;\n      if (config.abortSignal?.aborted) {\n        return Promise.reject(config.abortSignal.reason);\n      }\n      rawSignature = config.signature;\n    }\n    let decodedSignature;\n    try {\n      decodedSignature = bs58__default.default.decode(rawSignature);\n    } catch (err) {\n      throw new Error('signature must be base58 encoded: ' + rawSignature);\n    }\n    assert(decodedSignature.length === 64, 'signature has invalid length');\n    if (typeof strategy === 'string') {\n      return await this.confirmTransactionUsingLegacyTimeoutStrategy({\n        commitment: commitment || this.commitment,\n        signature: rawSignature\n      });\n    } else if ('lastValidBlockHeight' in strategy) {\n      return await this.confirmTransactionUsingBlockHeightExceedanceStrategy({\n        commitment: commitment || this.commitment,\n        strategy\n      });\n    } else {\n      return await this.confirmTransactionUsingDurableNonceStrategy({\n        commitment: commitment || this.commitment,\n        strategy\n      });\n    }\n  }\n  getCancellationPromise(signal) {\n    return new Promise((_, reject) => {\n      if (signal == null) {\n        return;\n      }\n      if (signal.aborted) {\n        reject(signal.reason);\n      } else {\n        signal.addEventListener('abort', () => {\n          reject(signal.reason);\n        });\n      }\n    });\n  }\n  getTransactionConfirmationPromise({\n    commitment,\n    signature\n  }) {\n    let signatureSubscriptionId;\n    let disposeSignatureSubscriptionStateChangeObserver;\n    let done = false;\n    const confirmationPromise = new Promise((resolve, reject) => {\n      try {\n        signatureSubscriptionId = this.onSignature(signature, (result, context) => {\n          signatureSubscriptionId = undefined;\n          const response = {\n            context,\n            value: result\n          };\n          resolve({\n            __type: TransactionStatus.PROCESSED,\n            response\n          });\n        }, commitment);\n        const subscriptionSetupPromise = new Promise(resolveSubscriptionSetup => {\n          if (signatureSubscriptionId == null) {\n            resolveSubscriptionSetup();\n          } else {\n            disposeSignatureSubscriptionStateChangeObserver = this._onSubscriptionStateChange(signatureSubscriptionId, nextState => {\n              if (nextState === 'subscribed') {\n                resolveSubscriptionSetup();\n              }\n            });\n          }\n        });\n        (async () => {\n          await subscriptionSetupPromise;\n          if (done) return;\n          const response = await this.getSignatureStatus(signature);\n          if (done) return;\n          if (response == null) {\n            return;\n          }\n          const {\n            context,\n            value\n          } = response;\n          if (value == null) {\n            return;\n          }\n          if (value?.err) {\n            reject(value.err);\n          } else {\n            switch (commitment) {\n              case 'confirmed':\n              case 'single':\n              case 'singleGossip':\n                {\n                  if (value.confirmationStatus === 'processed') {\n                    return;\n                  }\n                  break;\n                }\n              case 'finalized':\n              case 'max':\n              case 'root':\n                {\n                  if (value.confirmationStatus === 'processed' || value.confirmationStatus === 'confirmed') {\n                    return;\n                  }\n                  break;\n                }\n              // exhaust enums to ensure full coverage\n              case 'processed':\n              case 'recent':\n            }\n            done = true;\n            resolve({\n              __type: TransactionStatus.PROCESSED,\n              response: {\n                context,\n                value\n              }\n            });\n          }\n        })();\n      } catch (err) {\n        reject(err);\n      }\n    });\n    const abortConfirmation = () => {\n      if (disposeSignatureSubscriptionStateChangeObserver) {\n        disposeSignatureSubscriptionStateChangeObserver();\n        disposeSignatureSubscriptionStateChangeObserver = undefined;\n      }\n      if (signatureSubscriptionId != null) {\n        this.removeSignatureListener(signatureSubscriptionId);\n        signatureSubscriptionId = undefined;\n      }\n    };\n    return {\n      abortConfirmation,\n      confirmationPromise\n    };\n  }\n  async confirmTransactionUsingBlockHeightExceedanceStrategy({\n    commitment,\n    strategy: {\n      abortSignal,\n      lastValidBlockHeight,\n      signature\n    }\n  }) {\n    let done = false;\n    const expiryPromise = new Promise(resolve => {\n      const checkBlockHeight = async () => {\n        try {\n          const blockHeight = await this.getBlockHeight(commitment);\n          return blockHeight;\n        } catch (_e) {\n          return -1;\n        }\n      };\n      (async () => {\n        let currentBlockHeight = await checkBlockHeight();\n        if (done) return;\n        while (currentBlockHeight <= lastValidBlockHeight) {\n          await sleep(1000);\n          if (done) return;\n          currentBlockHeight = await checkBlockHeight();\n          if (done) return;\n        }\n        resolve({\n          __type: TransactionStatus.BLOCKHEIGHT_EXCEEDED\n        });\n      })();\n    });\n    const {\n      abortConfirmation,\n      confirmationPromise\n    } = this.getTransactionConfirmationPromise({\n      commitment,\n      signature\n    });\n    const cancellationPromise = this.getCancellationPromise(abortSignal);\n    let result;\n    try {\n      const outcome = await Promise.race([cancellationPromise, confirmationPromise, expiryPromise]);\n      if (outcome.__type === TransactionStatus.PROCESSED) {\n        result = outcome.response;\n      } else {\n        throw new TransactionExpiredBlockheightExceededError(signature);\n      }\n    } finally {\n      done = true;\n      abortConfirmation();\n    }\n    return result;\n  }\n  async confirmTransactionUsingDurableNonceStrategy({\n    commitment,\n    strategy: {\n      abortSignal,\n      minContextSlot,\n      nonceAccountPubkey,\n      nonceValue,\n      signature\n    }\n  }) {\n    let done = false;\n    const expiryPromise = new Promise(resolve => {\n      let currentNonceValue = nonceValue;\n      let lastCheckedSlot = null;\n      const getCurrentNonceValue = async () => {\n        try {\n          const {\n            context,\n            value: nonceAccount\n          } = await this.getNonceAndContext(nonceAccountPubkey, {\n            commitment,\n            minContextSlot\n          });\n          lastCheckedSlot = context.slot;\n          return nonceAccount?.nonce;\n        } catch (e) {\n          // If for whatever reason we can't reach/read the nonce\n          // account, just keep using the last-known value.\n          return currentNonceValue;\n        }\n      };\n      (async () => {\n        currentNonceValue = await getCurrentNonceValue();\n        if (done) return;\n        while (true // eslint-disable-line no-constant-condition\n        ) {\n          if (nonceValue !== currentNonceValue) {\n            resolve({\n              __type: TransactionStatus.NONCE_INVALID,\n              slotInWhichNonceDidAdvance: lastCheckedSlot\n            });\n            return;\n          }\n          await sleep(2000);\n          if (done) return;\n          currentNonceValue = await getCurrentNonceValue();\n          if (done) return;\n        }\n      })();\n    });\n    const {\n      abortConfirmation,\n      confirmationPromise\n    } = this.getTransactionConfirmationPromise({\n      commitment,\n      signature\n    });\n    const cancellationPromise = this.getCancellationPromise(abortSignal);\n    let result;\n    try {\n      const outcome = await Promise.race([cancellationPromise, confirmationPromise, expiryPromise]);\n      if (outcome.__type === TransactionStatus.PROCESSED) {\n        result = outcome.response;\n      } else {\n        // Double check that the transaction is indeed unconfirmed.\n        let signatureStatus;\n        while (true // eslint-disable-line no-constant-condition\n        ) {\n          const status = await this.getSignatureStatus(signature);\n          if (status == null) {\n            break;\n          }\n          if (status.context.slot < (outcome.slotInWhichNonceDidAdvance ?? minContextSlot)) {\n            await sleep(400);\n            continue;\n          }\n          signatureStatus = status;\n          break;\n        }\n        if (signatureStatus?.value) {\n          const commitmentForStatus = commitment || 'finalized';\n          const {\n            confirmationStatus\n          } = signatureStatus.value;\n          switch (commitmentForStatus) {\n            case 'processed':\n            case 'recent':\n              if (confirmationStatus !== 'processed' && confirmationStatus !== 'confirmed' && confirmationStatus !== 'finalized') {\n                throw new TransactionExpiredNonceInvalidError(signature);\n              }\n              break;\n            case 'confirmed':\n            case 'single':\n            case 'singleGossip':\n              if (confirmationStatus !== 'confirmed' && confirmationStatus !== 'finalized') {\n                throw new TransactionExpiredNonceInvalidError(signature);\n              }\n              break;\n            case 'finalized':\n            case 'max':\n            case 'root':\n              if (confirmationStatus !== 'finalized') {\n                throw new TransactionExpiredNonceInvalidError(signature);\n              }\n              break;\n            default:\n              // Exhaustive switch.\n              // eslint-disable-next-line @typescript-eslint/no-unused-vars\n              (_ => {})(commitmentForStatus);\n          }\n          result = {\n            context: signatureStatus.context,\n            value: {\n              err: signatureStatus.value.err\n            }\n          };\n        } else {\n          throw new TransactionExpiredNonceInvalidError(signature);\n        }\n      }\n    } finally {\n      done = true;\n      abortConfirmation();\n    }\n    return result;\n  }\n  async confirmTransactionUsingLegacyTimeoutStrategy({\n    commitment,\n    signature\n  }) {\n    let timeoutId;\n    const expiryPromise = new Promise(resolve => {\n      let timeoutMs = this._confirmTransactionInitialTimeout || 60 * 1000;\n      switch (commitment) {\n        case 'processed':\n        case 'recent':\n        case 'single':\n        case 'confirmed':\n        case 'singleGossip':\n          {\n            timeoutMs = this._confirmTransactionInitialTimeout || 30 * 1000;\n            break;\n          }\n      }\n      timeoutId = setTimeout(() => resolve({\n        __type: TransactionStatus.TIMED_OUT,\n        timeoutMs\n      }), timeoutMs);\n    });\n    const {\n      abortConfirmation,\n      confirmationPromise\n    } = this.getTransactionConfirmationPromise({\n      commitment,\n      signature\n    });\n    let result;\n    try {\n      const outcome = await Promise.race([confirmationPromise, expiryPromise]);\n      if (outcome.__type === TransactionStatus.PROCESSED) {\n        result = outcome.response;\n      } else {\n        throw new TransactionExpiredTimeoutError(signature, outcome.timeoutMs / 1000);\n      }\n    } finally {\n      clearTimeout(timeoutId);\n      abortConfirmation();\n    }\n    return result;\n  }\n\n  /**\n   * Return the list of nodes that are currently participating in the cluster\n   */\n  async getClusterNodes() {\n    const unsafeRes = await this._rpcRequest('getClusterNodes', []);\n    const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.array(ContactInfoResult)));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get cluster nodes');\n    }\n    return res.result;\n  }\n\n  /**\n   * Return the list of nodes that are currently participating in the cluster\n   */\n  async getVoteAccounts(commitment) {\n    const args = this._buildArgs([], commitment);\n    const unsafeRes = await this._rpcRequest('getVoteAccounts', args);\n    const res = superstruct.create(unsafeRes, GetVoteAccounts);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get vote accounts');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the current slot that the node is processing\n   */\n  async getSlot(commitmentOrConfig) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(commitmentOrConfig);\n    const args = this._buildArgs([], commitment, undefined /* encoding */, config);\n    const unsafeRes = await this._rpcRequest('getSlot', args);\n    const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.number()));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get slot');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the current slot leader of the cluster\n   */\n  async getSlotLeader(commitmentOrConfig) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(commitmentOrConfig);\n    const args = this._buildArgs([], commitment, undefined /* encoding */, config);\n    const unsafeRes = await this._rpcRequest('getSlotLeader', args);\n    const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.string()));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get slot leader');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch `limit` number of slot leaders starting from `startSlot`\n   *\n   * @param startSlot fetch slot leaders starting from this slot\n   * @param limit number of slot leaders to return\n   */\n  async getSlotLeaders(startSlot, limit) {\n    const args = [startSlot, limit];\n    const unsafeRes = await this._rpcRequest('getSlotLeaders', args);\n    const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.array(PublicKeyFromString)));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get slot leaders');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the current status of a signature\n   */\n  async getSignatureStatus(signature, config) {\n    const {\n      context,\n      value: values\n    } = await this.getSignatureStatuses([signature], config);\n    assert(values.length === 1);\n    const value = values[0];\n    return {\n      context,\n      value\n    };\n  }\n\n  /**\n   * Fetch the current statuses of a batch of signatures\n   */\n  async getSignatureStatuses(signatures, config) {\n    const params = [signatures];\n    if (config) {\n      params.push(config);\n    }\n    const unsafeRes = await this._rpcRequest('getSignatureStatuses', params);\n    const res = superstruct.create(unsafeRes, GetSignatureStatusesRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get signature status');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the current transaction count of the cluster\n   */\n  async getTransactionCount(commitmentOrConfig) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(commitmentOrConfig);\n    const args = this._buildArgs([], commitment, undefined /* encoding */, config);\n    const unsafeRes = await this._rpcRequest('getTransactionCount', args);\n    const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.number()));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get transaction count');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the current total currency supply of the cluster in lamports\n   *\n   * @deprecated Deprecated since v1.2.8. Please use {@link getSupply} instead.\n   */\n  async getTotalSupply(commitment) {\n    const result = await this.getSupply({\n      commitment,\n      excludeNonCirculatingAccountsList: true\n    });\n    return result.value.total;\n  }\n\n  /**\n   * Fetch the cluster InflationGovernor parameters\n   */\n  async getInflationGovernor(commitment) {\n    const args = this._buildArgs([], commitment);\n    const unsafeRes = await this._rpcRequest('getInflationGovernor', args);\n    const res = superstruct.create(unsafeRes, GetInflationGovernorRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get inflation');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the inflation reward for a list of addresses for an epoch\n   */\n  async getInflationReward(addresses, epoch, commitmentOrConfig) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(commitmentOrConfig);\n    const args = this._buildArgs([addresses.map(pubkey => pubkey.toBase58())], commitment, undefined /* encoding */, {\n      ...config,\n      epoch: epoch != null ? epoch : config?.epoch\n    });\n    const unsafeRes = await this._rpcRequest('getInflationReward', args);\n    const res = superstruct.create(unsafeRes, GetInflationRewardResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get inflation reward');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the specific inflation values for the current epoch\n   */\n  async getInflationRate() {\n    const unsafeRes = await this._rpcRequest('getInflationRate', []);\n    const res = superstruct.create(unsafeRes, GetInflationRateRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get inflation rate');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the Epoch Info parameters\n   */\n  async getEpochInfo(commitmentOrConfig) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(commitmentOrConfig);\n    const args = this._buildArgs([], commitment, undefined /* encoding */, config);\n    const unsafeRes = await this._rpcRequest('getEpochInfo', args);\n    const res = superstruct.create(unsafeRes, GetEpochInfoRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get epoch info');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the Epoch Schedule parameters\n   */\n  async getEpochSchedule() {\n    const unsafeRes = await this._rpcRequest('getEpochSchedule', []);\n    const res = superstruct.create(unsafeRes, GetEpochScheduleRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get epoch schedule');\n    }\n    const epochSchedule = res.result;\n    return new EpochSchedule(epochSchedule.slotsPerEpoch, epochSchedule.leaderScheduleSlotOffset, epochSchedule.warmup, epochSchedule.firstNormalEpoch, epochSchedule.firstNormalSlot);\n  }\n\n  /**\n   * Fetch the leader schedule for the current epoch\n   * @return {Promise<RpcResponseAndContext<LeaderSchedule>>}\n   */\n  async getLeaderSchedule() {\n    const unsafeRes = await this._rpcRequest('getLeaderSchedule', []);\n    const res = superstruct.create(unsafeRes, GetLeaderScheduleRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get leader schedule');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the minimum balance needed to exempt an account of `dataLength`\n   * size from rent\n   */\n  async getMinimumBalanceForRentExemption(dataLength, commitment) {\n    const args = this._buildArgs([dataLength], commitment);\n    const unsafeRes = await this._rpcRequest('getMinimumBalanceForRentExemption', args);\n    const res = superstruct.create(unsafeRes, GetMinimumBalanceForRentExemptionRpcResult);\n    if ('error' in res) {\n      console.warn('Unable to fetch minimum balance for rent exemption');\n      return 0;\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch a recent blockhash from the cluster, return with context\n   * @return {Promise<RpcResponseAndContext<{blockhash: Blockhash, feeCalculator: FeeCalculator}>>}\n   *\n   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getLatestBlockhash} instead.\n   */\n  async getRecentBlockhashAndContext(commitment) {\n    const args = this._buildArgs([], commitment);\n    const unsafeRes = await this._rpcRequest('getRecentBlockhash', args);\n    const res = superstruct.create(unsafeRes, GetRecentBlockhashAndContextRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get recent blockhash');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch recent performance samples\n   * @return {Promise<Array<PerfSample>>}\n   */\n  async getRecentPerformanceSamples(limit) {\n    const unsafeRes = await this._rpcRequest('getRecentPerformanceSamples', limit ? [limit] : []);\n    const res = superstruct.create(unsafeRes, GetRecentPerformanceSamplesRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get recent performance samples');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the fee calculator for a recent blockhash from the cluster, return with context\n   *\n   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getFeeForMessage} instead.\n   */\n  async getFeeCalculatorForBlockhash(blockhash, commitment) {\n    const args = this._buildArgs([blockhash], commitment);\n    const unsafeRes = await this._rpcRequest('getFeeCalculatorForBlockhash', args);\n    const res = superstruct.create(unsafeRes, GetFeeCalculatorRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get fee calculator');\n    }\n    const {\n      context,\n      value\n    } = res.result;\n    return {\n      context,\n      value: value !== null ? value.feeCalculator : null\n    };\n  }\n\n  /**\n   * Fetch the fee for a message from the cluster, return with context\n   */\n  async getFeeForMessage(message, commitment) {\n    const wireMessage = toBuffer(message.serialize()).toString('base64');\n    const args = this._buildArgs([wireMessage], commitment);\n    const unsafeRes = await this._rpcRequest('getFeeForMessage', args);\n    const res = superstruct.create(unsafeRes, jsonRpcResultAndContext(superstruct.nullable(superstruct.number())));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get fee for message');\n    }\n    if (res.result === null) {\n      throw new Error('invalid blockhash');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch a list of prioritization fees from recent blocks.\n   */\n  async getRecentPrioritizationFees(config) {\n    const accounts = config?.lockedWritableAccounts?.map(key => key.toBase58());\n    const args = accounts?.length ? [accounts] : [];\n    const unsafeRes = await this._rpcRequest('getRecentPrioritizationFees', args);\n    const res = superstruct.create(unsafeRes, GetRecentPrioritizationFeesRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get recent prioritization fees');\n    }\n    return res.result;\n  }\n  /**\n   * Fetch a recent blockhash from the cluster\n   * @return {Promise<{blockhash: Blockhash, feeCalculator: FeeCalculator}>}\n   *\n   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getLatestBlockhash} instead.\n   */\n  async getRecentBlockhash(commitment) {\n    try {\n      const res = await this.getRecentBlockhashAndContext(commitment);\n      return res.value;\n    } catch (e) {\n      throw new Error('failed to get recent blockhash: ' + e);\n    }\n  }\n\n  /**\n   * Fetch the latest blockhash from the cluster\n   * @return {Promise<BlockhashWithExpiryBlockHeight>}\n   */\n  async getLatestBlockhash(commitmentOrConfig) {\n    try {\n      const res = await this.getLatestBlockhashAndContext(commitmentOrConfig);\n      return res.value;\n    } catch (e) {\n      throw new Error('failed to get recent blockhash: ' + e);\n    }\n  }\n\n  /**\n   * Fetch the latest blockhash from the cluster\n   * @return {Promise<BlockhashWithExpiryBlockHeight>}\n   */\n  async getLatestBlockhashAndContext(commitmentOrConfig) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(commitmentOrConfig);\n    const args = this._buildArgs([], commitment, undefined /* encoding */, config);\n    const unsafeRes = await this._rpcRequest('getLatestBlockhash', args);\n    const res = superstruct.create(unsafeRes, GetLatestBlockhashRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get latest blockhash');\n    }\n    return res.result;\n  }\n\n  /**\n   * Returns whether a blockhash is still valid or not\n   */\n  async isBlockhashValid(blockhash, rawConfig) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(rawConfig);\n    const args = this._buildArgs([blockhash], commitment, undefined /* encoding */, config);\n    const unsafeRes = await this._rpcRequest('isBlockhashValid', args);\n    const res = superstruct.create(unsafeRes, IsBlockhashValidRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to determine if the blockhash `' + blockhash + '`is valid');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the node version\n   */\n  async getVersion() {\n    const unsafeRes = await this._rpcRequest('getVersion', []);\n    const res = superstruct.create(unsafeRes, jsonRpcResult(VersionResult));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get version');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the genesis hash\n   */\n  async getGenesisHash() {\n    const unsafeRes = await this._rpcRequest('getGenesisHash', []);\n    const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.string()));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get genesis hash');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch a processed block from the cluster.\n   *\n   * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by\n   * setting the `maxSupportedTransactionVersion` property.\n   */\n\n  /**\n   * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by\n   * setting the `maxSupportedTransactionVersion` property.\n   */\n  // eslint-disable-next-line no-dupe-class-members\n\n  /**\n   * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by\n   * setting the `maxSupportedTransactionVersion` property.\n   */\n  // eslint-disable-next-line no-dupe-class-members\n\n  /**\n   * Fetch a processed block from the cluster.\n   */\n  // eslint-disable-next-line no-dupe-class-members\n\n  // eslint-disable-next-line no-dupe-class-members\n\n  // eslint-disable-next-line no-dupe-class-members\n\n  /**\n   * Fetch a processed block from the cluster.\n   */\n  // eslint-disable-next-line no-dupe-class-members\n  async getBlock(slot, rawConfig) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(rawConfig);\n    const args = this._buildArgsAtLeastConfirmed([slot], commitment, undefined /* encoding */, config);\n    const unsafeRes = await this._rpcRequest('getBlock', args);\n    try {\n      switch (config?.transactionDetails) {\n        case 'accounts':\n          {\n            const res = superstruct.create(unsafeRes, GetAccountsModeBlockRpcResult);\n            if ('error' in res) {\n              throw res.error;\n            }\n            return res.result;\n          }\n        case 'none':\n          {\n            const res = superstruct.create(unsafeRes, GetNoneModeBlockRpcResult);\n            if ('error' in res) {\n              throw res.error;\n            }\n            return res.result;\n          }\n        default:\n          {\n            const res = superstruct.create(unsafeRes, GetBlockRpcResult);\n            if ('error' in res) {\n              throw res.error;\n            }\n            const {\n              result\n            } = res;\n            return result ? {\n              ...result,\n              transactions: result.transactions.map(({\n                transaction,\n                meta,\n                version\n              }) => ({\n                meta,\n                transaction: {\n                  ...transaction,\n                  message: versionedMessageFromResponse(version, transaction.message)\n                },\n                version\n              }))\n            } : null;\n          }\n      }\n    } catch (e) {\n      throw new SolanaJSONRPCError(e, 'failed to get confirmed block');\n    }\n  }\n\n  /**\n   * Fetch parsed transaction details for a confirmed or finalized block\n   */\n\n  // eslint-disable-next-line no-dupe-class-members\n\n  // eslint-disable-next-line no-dupe-class-members\n\n  // eslint-disable-next-line no-dupe-class-members\n  async getParsedBlock(slot, rawConfig) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(rawConfig);\n    const args = this._buildArgsAtLeastConfirmed([slot], commitment, 'jsonParsed', config);\n    const unsafeRes = await this._rpcRequest('getBlock', args);\n    try {\n      switch (config?.transactionDetails) {\n        case 'accounts':\n          {\n            const res = superstruct.create(unsafeRes, GetParsedAccountsModeBlockRpcResult);\n            if ('error' in res) {\n              throw res.error;\n            }\n            return res.result;\n          }\n        case 'none':\n          {\n            const res = superstruct.create(unsafeRes, GetParsedNoneModeBlockRpcResult);\n            if ('error' in res) {\n              throw res.error;\n            }\n            return res.result;\n          }\n        default:\n          {\n            const res = superstruct.create(unsafeRes, GetParsedBlockRpcResult);\n            if ('error' in res) {\n              throw res.error;\n            }\n            return res.result;\n          }\n      }\n    } catch (e) {\n      throw new SolanaJSONRPCError(e, 'failed to get block');\n    }\n  }\n  /*\n   * Returns recent block production information from the current or previous epoch\n   */\n  async getBlockProduction(configOrCommitment) {\n    let extra;\n    let commitment;\n    if (typeof configOrCommitment === 'string') {\n      commitment = configOrCommitment;\n    } else if (configOrCommitment) {\n      const {\n        commitment: c,\n        ...rest\n      } = configOrCommitment;\n      commitment = c;\n      extra = rest;\n    }\n    const args = this._buildArgs([], commitment, 'base64', extra);\n    const unsafeRes = await this._rpcRequest('getBlockProduction', args);\n    const res = superstruct.create(unsafeRes, BlockProductionResponseStruct);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get block production information');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch a confirmed or finalized transaction from the cluster.\n   *\n   * @deprecated Instead, call `getTransaction` using a\n   * `GetVersionedTransactionConfig` by setting the\n   * `maxSupportedTransactionVersion` property.\n   */\n\n  /**\n   * Fetch a confirmed or finalized transaction from the cluster.\n   */\n  // eslint-disable-next-line no-dupe-class-members\n\n  /**\n   * Fetch a confirmed or finalized transaction from the cluster.\n   */\n  // eslint-disable-next-line no-dupe-class-members\n  async getTransaction(signature, rawConfig) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(rawConfig);\n    const args = this._buildArgsAtLeastConfirmed([signature], commitment, undefined /* encoding */, config);\n    const unsafeRes = await this._rpcRequest('getTransaction', args);\n    const res = superstruct.create(unsafeRes, GetTransactionRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get transaction');\n    }\n    const result = res.result;\n    if (!result) return result;\n    return {\n      ...result,\n      transaction: {\n        ...result.transaction,\n        message: versionedMessageFromResponse(result.version, result.transaction.message)\n      }\n    };\n  }\n\n  /**\n   * Fetch parsed transaction details for a confirmed or finalized transaction\n   */\n  async getParsedTransaction(signature, commitmentOrConfig) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(commitmentOrConfig);\n    const args = this._buildArgsAtLeastConfirmed([signature], commitment, 'jsonParsed', config);\n    const unsafeRes = await this._rpcRequest('getTransaction', args);\n    const res = superstruct.create(unsafeRes, GetParsedTransactionRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get transaction');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch parsed transaction details for a batch of confirmed transactions\n   */\n  async getParsedTransactions(signatures, commitmentOrConfig) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(commitmentOrConfig);\n    const batch = signatures.map(signature => {\n      const args = this._buildArgsAtLeastConfirmed([signature], commitment, 'jsonParsed', config);\n      return {\n        methodName: 'getTransaction',\n        args\n      };\n    });\n    const unsafeRes = await this._rpcBatchRequest(batch);\n    const res = unsafeRes.map(unsafeRes => {\n      const res = superstruct.create(unsafeRes, GetParsedTransactionRpcResult);\n      if ('error' in res) {\n        throw new SolanaJSONRPCError(res.error, 'failed to get transactions');\n      }\n      return res.result;\n    });\n    return res;\n  }\n\n  /**\n   * Fetch transaction details for a batch of confirmed transactions.\n   * Similar to {@link getParsedTransactions} but returns a {@link TransactionResponse}.\n   *\n   * @deprecated Instead, call `getTransactions` using a\n   * `GetVersionedTransactionConfig` by setting the\n   * `maxSupportedTransactionVersion` property.\n   */\n\n  /**\n   * Fetch transaction details for a batch of confirmed transactions.\n   * Similar to {@link getParsedTransactions} but returns a {@link\n   * VersionedTransactionResponse}.\n   */\n  // eslint-disable-next-line no-dupe-class-members\n\n  /**\n   * Fetch transaction details for a batch of confirmed transactions.\n   * Similar to {@link getParsedTransactions} but returns a {@link\n   * VersionedTransactionResponse}.\n   */\n  // eslint-disable-next-line no-dupe-class-members\n  async getTransactions(signatures, commitmentOrConfig) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(commitmentOrConfig);\n    const batch = signatures.map(signature => {\n      const args = this._buildArgsAtLeastConfirmed([signature], commitment, undefined /* encoding */, config);\n      return {\n        methodName: 'getTransaction',\n        args\n      };\n    });\n    const unsafeRes = await this._rpcBatchRequest(batch);\n    const res = unsafeRes.map(unsafeRes => {\n      const res = superstruct.create(unsafeRes, GetTransactionRpcResult);\n      if ('error' in res) {\n        throw new SolanaJSONRPCError(res.error, 'failed to get transactions');\n      }\n      const result = res.result;\n      if (!result) return result;\n      return {\n        ...result,\n        transaction: {\n          ...result.transaction,\n          message: versionedMessageFromResponse(result.version, result.transaction.message)\n        }\n      };\n    });\n    return res;\n  }\n\n  /**\n   * Fetch a list of Transactions and transaction statuses from the cluster\n   * for a confirmed block.\n   *\n   * @deprecated Deprecated since v1.13.0. Please use {@link getBlock} instead.\n   */\n  async getConfirmedBlock(slot, commitment) {\n    const args = this._buildArgsAtLeastConfirmed([slot], commitment);\n    const unsafeRes = await this._rpcRequest('getConfirmedBlock', args);\n    const res = superstruct.create(unsafeRes, GetConfirmedBlockRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get confirmed block');\n    }\n    const result = res.result;\n    if (!result) {\n      throw new Error('Confirmed block ' + slot + ' not found');\n    }\n    const block = {\n      ...result,\n      transactions: result.transactions.map(({\n        transaction,\n        meta\n      }) => {\n        const message = new Message(transaction.message);\n        return {\n          meta,\n          transaction: {\n            ...transaction,\n            message\n          }\n        };\n      })\n    };\n    return {\n      ...block,\n      transactions: block.transactions.map(({\n        transaction,\n        meta\n      }) => {\n        return {\n          meta,\n          transaction: Transaction.populate(transaction.message, transaction.signatures)\n        };\n      })\n    };\n  }\n\n  /**\n   * Fetch confirmed blocks between two slots\n   */\n  async getBlocks(startSlot, endSlot, commitment) {\n    const args = this._buildArgsAtLeastConfirmed(endSlot !== undefined ? [startSlot, endSlot] : [startSlot], commitment);\n    const unsafeRes = await this._rpcRequest('getBlocks', args);\n    const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.array(superstruct.number())));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get blocks');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch a list of Signatures from the cluster for a block, excluding rewards\n   */\n  async getBlockSignatures(slot, commitment) {\n    const args = this._buildArgsAtLeastConfirmed([slot], commitment, undefined, {\n      transactionDetails: 'signatures',\n      rewards: false\n    });\n    const unsafeRes = await this._rpcRequest('getBlock', args);\n    const res = superstruct.create(unsafeRes, GetBlockSignaturesRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get block');\n    }\n    const result = res.result;\n    if (!result) {\n      throw new Error('Block ' + slot + ' not found');\n    }\n    return result;\n  }\n\n  /**\n   * Fetch a list of Signatures from the cluster for a confirmed block, excluding rewards\n   *\n   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getBlockSignatures} instead.\n   */\n  async getConfirmedBlockSignatures(slot, commitment) {\n    const args = this._buildArgsAtLeastConfirmed([slot], commitment, undefined, {\n      transactionDetails: 'signatures',\n      rewards: false\n    });\n    const unsafeRes = await this._rpcRequest('getConfirmedBlock', args);\n    const res = superstruct.create(unsafeRes, GetBlockSignaturesRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get confirmed block');\n    }\n    const result = res.result;\n    if (!result) {\n      throw new Error('Confirmed block ' + slot + ' not found');\n    }\n    return result;\n  }\n\n  /**\n   * Fetch a transaction details for a confirmed transaction\n   *\n   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getTransaction} instead.\n   */\n  async getConfirmedTransaction(signature, commitment) {\n    const args = this._buildArgsAtLeastConfirmed([signature], commitment);\n    const unsafeRes = await this._rpcRequest('getConfirmedTransaction', args);\n    const res = superstruct.create(unsafeRes, GetTransactionRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get transaction');\n    }\n    const result = res.result;\n    if (!result) return result;\n    const message = new Message(result.transaction.message);\n    const signatures = result.transaction.signatures;\n    return {\n      ...result,\n      transaction: Transaction.populate(message, signatures)\n    };\n  }\n\n  /**\n   * Fetch parsed transaction details for a confirmed transaction\n   *\n   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getParsedTransaction} instead.\n   */\n  async getParsedConfirmedTransaction(signature, commitment) {\n    const args = this._buildArgsAtLeastConfirmed([signature], commitment, 'jsonParsed');\n    const unsafeRes = await this._rpcRequest('getConfirmedTransaction', args);\n    const res = superstruct.create(unsafeRes, GetParsedTransactionRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get confirmed transaction');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch parsed transaction details for a batch of confirmed transactions\n   *\n   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getParsedTransactions} instead.\n   */\n  async getParsedConfirmedTransactions(signatures, commitment) {\n    const batch = signatures.map(signature => {\n      const args = this._buildArgsAtLeastConfirmed([signature], commitment, 'jsonParsed');\n      return {\n        methodName: 'getConfirmedTransaction',\n        args\n      };\n    });\n    const unsafeRes = await this._rpcBatchRequest(batch);\n    const res = unsafeRes.map(unsafeRes => {\n      const res = superstruct.create(unsafeRes, GetParsedTransactionRpcResult);\n      if ('error' in res) {\n        throw new SolanaJSONRPCError(res.error, 'failed to get confirmed transactions');\n      }\n      return res.result;\n    });\n    return res;\n  }\n\n  /**\n   * Fetch a list of all the confirmed signatures for transactions involving an address\n   * within a specified slot range. Max range allowed is 10,000 slots.\n   *\n   * @deprecated Deprecated since v1.3. Please use {@link getConfirmedSignaturesForAddress2} instead.\n   *\n   * @param address queried address\n   * @param startSlot start slot, inclusive\n   * @param endSlot end slot, inclusive\n   */\n  async getConfirmedSignaturesForAddress(address, startSlot, endSlot) {\n    let options = {};\n    let firstAvailableBlock = await this.getFirstAvailableBlock();\n    while (!('until' in options)) {\n      startSlot--;\n      if (startSlot <= 0 || startSlot < firstAvailableBlock) {\n        break;\n      }\n      try {\n        const block = await this.getConfirmedBlockSignatures(startSlot, 'finalized');\n        if (block.signatures.length > 0) {\n          options.until = block.signatures[block.signatures.length - 1].toString();\n        }\n      } catch (err) {\n        if (err instanceof Error && err.message.includes('skipped')) {\n          continue;\n        } else {\n          throw err;\n        }\n      }\n    }\n    let highestConfirmedRoot = await this.getSlot('finalized');\n    while (!('before' in options)) {\n      endSlot++;\n      if (endSlot > highestConfirmedRoot) {\n        break;\n      }\n      try {\n        const block = await this.getConfirmedBlockSignatures(endSlot);\n        if (block.signatures.length > 0) {\n          options.before = block.signatures[block.signatures.length - 1].toString();\n        }\n      } catch (err) {\n        if (err instanceof Error && err.message.includes('skipped')) {\n          continue;\n        } else {\n          throw err;\n        }\n      }\n    }\n    const confirmedSignatureInfo = await this.getConfirmedSignaturesForAddress2(address, options);\n    return confirmedSignatureInfo.map(info => info.signature);\n  }\n\n  /**\n   * Returns confirmed signatures for transactions involving an\n   * address backwards in time from the provided signature or most recent confirmed block\n   *\n   *\n   * @param address queried address\n   * @param options\n   */\n  async getConfirmedSignaturesForAddress2(address, options, commitment) {\n    const args = this._buildArgsAtLeastConfirmed([address.toBase58()], commitment, undefined, options);\n    const unsafeRes = await this._rpcRequest('getConfirmedSignaturesForAddress2', args);\n    const res = superstruct.create(unsafeRes, GetConfirmedSignaturesForAddress2RpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get confirmed signatures for address');\n    }\n    return res.result;\n  }\n\n  /**\n   * Returns confirmed signatures for transactions involving an\n   * address backwards in time from the provided signature or most recent confirmed block\n   *\n   *\n   * @param address queried address\n   * @param options\n   */\n  async getSignaturesForAddress(address, options, commitment) {\n    const args = this._buildArgsAtLeastConfirmed([address.toBase58()], commitment, undefined, options);\n    const unsafeRes = await this._rpcRequest('getSignaturesForAddress', args);\n    const res = superstruct.create(unsafeRes, GetSignaturesForAddressRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get signatures for address');\n    }\n    return res.result;\n  }\n  async getAddressLookupTable(accountKey, config) {\n    const {\n      context,\n      value: accountInfo\n    } = await this.getAccountInfoAndContext(accountKey, config);\n    let value = null;\n    if (accountInfo !== null) {\n      value = new AddressLookupTableAccount({\n        key: accountKey,\n        state: AddressLookupTableAccount.deserialize(accountInfo.data)\n      });\n    }\n    return {\n      context,\n      value\n    };\n  }\n\n  /**\n   * Fetch the contents of a Nonce account from the cluster, return with context\n   */\n  async getNonceAndContext(nonceAccount, commitmentOrConfig) {\n    const {\n      context,\n      value: accountInfo\n    } = await this.getAccountInfoAndContext(nonceAccount, commitmentOrConfig);\n    let value = null;\n    if (accountInfo !== null) {\n      value = NonceAccount.fromAccountData(accountInfo.data);\n    }\n    return {\n      context,\n      value\n    };\n  }\n\n  /**\n   * Fetch the contents of a Nonce account from the cluster\n   */\n  async getNonce(nonceAccount, commitmentOrConfig) {\n    return await this.getNonceAndContext(nonceAccount, commitmentOrConfig).then(x => x.value).catch(e => {\n      throw new Error('failed to get nonce for account ' + nonceAccount.toBase58() + ': ' + e);\n    });\n  }\n\n  /**\n   * Request an allocation of lamports to the specified address\n   *\n   * ```typescript\n   * import { Connection, PublicKey, LAMPORTS_PER_SOL } from \"@solana/web3.js\";\n   *\n   * (async () => {\n   *   const connection = new Connection(\"https://api.testnet.solana.com\", \"confirmed\");\n   *   const myAddress = new PublicKey(\"2nr1bHFT86W9tGnyvmYW4vcHKsQB3sVQfnddasz4kExM\");\n   *   const signature = await connection.requestAirdrop(myAddress, LAMPORTS_PER_SOL);\n   *   await connection.confirmTransaction(signature);\n   * })();\n   * ```\n   */\n  async requestAirdrop(to, lamports) {\n    const unsafeRes = await this._rpcRequest('requestAirdrop', [to.toBase58(), lamports]);\n    const res = superstruct.create(unsafeRes, RequestAirdropRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, `airdrop to ${to.toBase58()} failed`);\n    }\n    return res.result;\n  }\n\n  /**\n   * @internal\n   */\n  async _blockhashWithExpiryBlockHeight(disableCache) {\n    if (!disableCache) {\n      // Wait for polling to finish\n      while (this._pollingBlockhash) {\n        await sleep(100);\n      }\n      const timeSinceFetch = Date.now() - this._blockhashInfo.lastFetch;\n      const expired = timeSinceFetch >= BLOCKHASH_CACHE_TIMEOUT_MS;\n      if (this._blockhashInfo.latestBlockhash !== null && !expired) {\n        return this._blockhashInfo.latestBlockhash;\n      }\n    }\n    return await this._pollNewBlockhash();\n  }\n\n  /**\n   * @internal\n   */\n  async _pollNewBlockhash() {\n    this._pollingBlockhash = true;\n    try {\n      const startTime = Date.now();\n      const cachedLatestBlockhash = this._blockhashInfo.latestBlockhash;\n      const cachedBlockhash = cachedLatestBlockhash ? cachedLatestBlockhash.blockhash : null;\n      for (let i = 0; i < 50; i++) {\n        const latestBlockhash = await this.getLatestBlockhash('finalized');\n        if (cachedBlockhash !== latestBlockhash.blockhash) {\n          this._blockhashInfo = {\n            latestBlockhash,\n            lastFetch: Date.now(),\n            transactionSignatures: [],\n            simulatedSignatures: []\n          };\n          return latestBlockhash;\n        }\n\n        // Sleep for approximately half a slot\n        await sleep(MS_PER_SLOT / 2);\n      }\n      throw new Error(`Unable to obtain a new blockhash after ${Date.now() - startTime}ms`);\n    } finally {\n      this._pollingBlockhash = false;\n    }\n  }\n\n  /**\n   * get the stake minimum delegation\n   */\n  async getStakeMinimumDelegation(config) {\n    const {\n      commitment,\n      config: configArg\n    } = extractCommitmentFromConfig(config);\n    const args = this._buildArgs([], commitment, 'base64', configArg);\n    const unsafeRes = await this._rpcRequest('getStakeMinimumDelegation', args);\n    const res = superstruct.create(unsafeRes, jsonRpcResultAndContext(superstruct.number()));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, `failed to get stake minimum delegation`);\n    }\n    return res.result;\n  }\n\n  /**\n   * Simulate a transaction\n   *\n   * @deprecated Instead, call {@link simulateTransaction} with {@link\n   * VersionedTransaction} and {@link SimulateTransactionConfig} parameters\n   */\n\n  /**\n   * Simulate a transaction\n   */\n  // eslint-disable-next-line no-dupe-class-members\n\n  /**\n   * Simulate a transaction\n   */\n  // eslint-disable-next-line no-dupe-class-members\n  async simulateTransaction(transactionOrMessage, configOrSigners, includeAccounts) {\n    if ('message' in transactionOrMessage) {\n      const versionedTx = transactionOrMessage;\n      const wireTransaction = versionedTx.serialize();\n      const encodedTransaction = buffer.Buffer.from(wireTransaction).toString('base64');\n      if (Array.isArray(configOrSigners) || includeAccounts !== undefined) {\n        throw new Error('Invalid arguments');\n      }\n      const config = configOrSigners || {};\n      config.encoding = 'base64';\n      if (!('commitment' in config)) {\n        config.commitment = this.commitment;\n      }\n      const args = [encodedTransaction, config];\n      const unsafeRes = await this._rpcRequest('simulateTransaction', args);\n      const res = superstruct.create(unsafeRes, SimulatedTransactionResponseStruct);\n      if ('error' in res) {\n        throw new Error('failed to simulate transaction: ' + res.error.message);\n      }\n      return res.result;\n    }\n    let transaction;\n    if (transactionOrMessage instanceof Transaction) {\n      let originalTx = transactionOrMessage;\n      transaction = new Transaction();\n      transaction.feePayer = originalTx.feePayer;\n      transaction.instructions = transactionOrMessage.instructions;\n      transaction.nonceInfo = originalTx.nonceInfo;\n      transaction.signatures = originalTx.signatures;\n    } else {\n      transaction = Transaction.populate(transactionOrMessage);\n      // HACK: this function relies on mutating the populated transaction\n      transaction._message = transaction._json = undefined;\n    }\n    if (configOrSigners !== undefined && !Array.isArray(configOrSigners)) {\n      throw new Error('Invalid arguments');\n    }\n    const signers = configOrSigners;\n    if (transaction.nonceInfo && signers) {\n      transaction.sign(...signers);\n    } else {\n      let disableCache = this._disableBlockhashCaching;\n      for (;;) {\n        const latestBlockhash = await this._blockhashWithExpiryBlockHeight(disableCache);\n        transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;\n        transaction.recentBlockhash = latestBlockhash.blockhash;\n        if (!signers) break;\n        transaction.sign(...signers);\n        if (!transaction.signature) {\n          throw new Error('!signature'); // should never happen\n        }\n        const signature = transaction.signature.toString('base64');\n        if (!this._blockhashInfo.simulatedSignatures.includes(signature) && !this._blockhashInfo.transactionSignatures.includes(signature)) {\n          // The signature of this transaction has not been seen before with the\n          // current recentBlockhash, all done. Let's break\n          this._blockhashInfo.simulatedSignatures.push(signature);\n          break;\n        } else {\n          // This transaction would be treated as duplicate (its derived signature\n          // matched to one of already recorded signatures).\n          // So, we must fetch a new blockhash for a different signature by disabling\n          // our cache not to wait for the cache expiration (BLOCKHASH_CACHE_TIMEOUT_MS).\n          disableCache = true;\n        }\n      }\n    }\n    const message = transaction._compile();\n    const signData = message.serialize();\n    const wireTransaction = transaction._serialize(signData);\n    const encodedTransaction = wireTransaction.toString('base64');\n    const config = {\n      encoding: 'base64',\n      commitment: this.commitment\n    };\n    if (includeAccounts) {\n      const addresses = (Array.isArray(includeAccounts) ? includeAccounts : message.nonProgramIds()).map(key => key.toBase58());\n      config['accounts'] = {\n        encoding: 'base64',\n        addresses\n      };\n    }\n    if (signers) {\n      config.sigVerify = true;\n    }\n    const args = [encodedTransaction, config];\n    const unsafeRes = await this._rpcRequest('simulateTransaction', args);\n    const res = superstruct.create(unsafeRes, SimulatedTransactionResponseStruct);\n    if ('error' in res) {\n      let logs;\n      if ('data' in res.error) {\n        logs = res.error.data.logs;\n        if (logs && Array.isArray(logs)) {\n          const traceIndent = '\\n    ';\n          const logTrace = traceIndent + logs.join(traceIndent);\n          console.error(res.error.message, logTrace);\n        }\n      }\n      throw new SendTransactionError('failed to simulate transaction: ' + res.error.message, logs);\n    }\n    return res.result;\n  }\n\n  /**\n   * Sign and send a transaction\n   *\n   * @deprecated Instead, call {@link sendTransaction} with a {@link\n   * VersionedTransaction}\n   */\n\n  /**\n   * Send a signed transaction\n   */\n  // eslint-disable-next-line no-dupe-class-members\n\n  /**\n   * Sign and send a transaction\n   */\n  // eslint-disable-next-line no-dupe-class-members\n  async sendTransaction(transaction, signersOrOptions, options) {\n    if ('version' in transaction) {\n      if (signersOrOptions && Array.isArray(signersOrOptions)) {\n        throw new Error('Invalid arguments');\n      }\n      const wireTransaction = transaction.serialize();\n      return await this.sendRawTransaction(wireTransaction, signersOrOptions);\n    }\n    if (signersOrOptions === undefined || !Array.isArray(signersOrOptions)) {\n      throw new Error('Invalid arguments');\n    }\n    const signers = signersOrOptions;\n    if (transaction.nonceInfo) {\n      transaction.sign(...signers);\n    } else {\n      let disableCache = this._disableBlockhashCaching;\n      for (;;) {\n        const latestBlockhash = await this._blockhashWithExpiryBlockHeight(disableCache);\n        transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;\n        transaction.recentBlockhash = latestBlockhash.blockhash;\n        transaction.sign(...signers);\n        if (!transaction.signature) {\n          throw new Error('!signature'); // should never happen\n        }\n        const signature = transaction.signature.toString('base64');\n        if (!this._blockhashInfo.transactionSignatures.includes(signature)) {\n          // The signature of this transaction has not been seen before with the\n          // current recentBlockhash, all done. Let's break\n          this._blockhashInfo.transactionSignatures.push(signature);\n          break;\n        } else {\n          // This transaction would be treated as duplicate (its derived signature\n          // matched to one of already recorded signatures).\n          // So, we must fetch a new blockhash for a different signature by disabling\n          // our cache not to wait for the cache expiration (BLOCKHASH_CACHE_TIMEOUT_MS).\n          disableCache = true;\n        }\n      }\n    }\n    const wireTransaction = transaction.serialize();\n    return await this.sendRawTransaction(wireTransaction, options);\n  }\n\n  /**\n   * Send a transaction that has already been signed and serialized into the\n   * wire format\n   */\n  async sendRawTransaction(rawTransaction, options) {\n    const encodedTransaction = toBuffer(rawTransaction).toString('base64');\n    const result = await this.sendEncodedTransaction(encodedTransaction, options);\n    return result;\n  }\n\n  /**\n   * Send a transaction that has already been signed, serialized into the\n   * wire format, and encoded as a base64 string\n   */\n  async sendEncodedTransaction(encodedTransaction, options) {\n    const config = {\n      encoding: 'base64'\n    };\n    const skipPreflight = options && options.skipPreflight;\n    const preflightCommitment = skipPreflight === true ? 'processed' // FIXME Remove when https://github.com/anza-xyz/agave/pull/483 is deployed.\n    : options && options.preflightCommitment || this.commitment;\n    if (options && options.maxRetries != null) {\n      config.maxRetries = options.maxRetries;\n    }\n    if (options && options.minContextSlot != null) {\n      config.minContextSlot = options.minContextSlot;\n    }\n    if (skipPreflight) {\n      config.skipPreflight = skipPreflight;\n    }\n    if (preflightCommitment) {\n      config.preflightCommitment = preflightCommitment;\n    }\n    const args = [encodedTransaction, config];\n    const unsafeRes = await this._rpcRequest('sendTransaction', args);\n    const res = superstruct.create(unsafeRes, SendTransactionRpcResult);\n    if ('error' in res) {\n      let logs;\n      if ('data' in res.error) {\n        logs = res.error.data.logs;\n      }\n      throw new SendTransactionError('failed to send transaction: ' + res.error.message, logs);\n    }\n    return res.result;\n  }\n\n  /**\n   * @internal\n   */\n  _wsOnOpen() {\n    this._rpcWebSocketConnected = true;\n    this._rpcWebSocketHeartbeat = setInterval(() => {\n      // Ping server every 5s to prevent idle timeouts\n      (async () => {\n        try {\n          await this._rpcWebSocket.notify('ping');\n          // eslint-disable-next-line no-empty\n        } catch {}\n      })();\n    }, 5000);\n    this._updateSubscriptions();\n  }\n\n  /**\n   * @internal\n   */\n  _wsOnError(err) {\n    this._rpcWebSocketConnected = false;\n    console.error('ws error:', err.message);\n  }\n\n  /**\n   * @internal\n   */\n  _wsOnClose(code) {\n    this._rpcWebSocketConnected = false;\n    this._rpcWebSocketGeneration = (this._rpcWebSocketGeneration + 1) % Number.MAX_SAFE_INTEGER;\n    if (this._rpcWebSocketIdleTimeout) {\n      clearTimeout(this._rpcWebSocketIdleTimeout);\n      this._rpcWebSocketIdleTimeout = null;\n    }\n    if (this._rpcWebSocketHeartbeat) {\n      clearInterval(this._rpcWebSocketHeartbeat);\n      this._rpcWebSocketHeartbeat = null;\n    }\n    if (code === 1000) {\n      // explicit close, check if any subscriptions have been made since close\n      this._updateSubscriptions();\n      return;\n    }\n\n    // implicit close, prepare subscriptions for auto-reconnect\n    this._subscriptionCallbacksByServerSubscriptionId = {};\n    Object.entries(this._subscriptionsByHash).forEach(([hash, subscription]) => {\n      this._setSubscription(hash, {\n        ...subscription,\n        state: 'pending'\n      });\n    });\n  }\n\n  /**\n   * @internal\n   */\n  _setSubscription(hash, nextSubscription) {\n    const prevState = this._subscriptionsByHash[hash]?.state;\n    this._subscriptionsByHash[hash] = nextSubscription;\n    if (prevState !== nextSubscription.state) {\n      const stateChangeCallbacks = this._subscriptionStateChangeCallbacksByHash[hash];\n      if (stateChangeCallbacks) {\n        stateChangeCallbacks.forEach(cb => {\n          try {\n            cb(nextSubscription.state);\n            // eslint-disable-next-line no-empty\n          } catch {}\n        });\n      }\n    }\n  }\n\n  /**\n   * @internal\n   */\n  _onSubscriptionStateChange(clientSubscriptionId, callback) {\n    const hash = this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];\n    if (hash == null) {\n      return () => {};\n    }\n    const stateChangeCallbacks = this._subscriptionStateChangeCallbacksByHash[hash] ||= new Set();\n    stateChangeCallbacks.add(callback);\n    return () => {\n      stateChangeCallbacks.delete(callback);\n      if (stateChangeCallbacks.size === 0) {\n        delete this._subscriptionStateChangeCallbacksByHash[hash];\n      }\n    };\n  }\n\n  /**\n   * @internal\n   */\n  async _updateSubscriptions() {\n    if (Object.keys(this._subscriptionsByHash).length === 0) {\n      if (this._rpcWebSocketConnected) {\n        this._rpcWebSocketConnected = false;\n        this._rpcWebSocketIdleTimeout = setTimeout(() => {\n          this._rpcWebSocketIdleTimeout = null;\n          try {\n            this._rpcWebSocket.close();\n          } catch (err) {\n            // swallow error if socket has already been closed.\n            if (err instanceof Error) {\n              console.log(`Error when closing socket connection: ${err.message}`);\n            }\n          }\n        }, 500);\n      }\n      return;\n    }\n    if (this._rpcWebSocketIdleTimeout !== null) {\n      clearTimeout(this._rpcWebSocketIdleTimeout);\n      this._rpcWebSocketIdleTimeout = null;\n      this._rpcWebSocketConnected = true;\n    }\n    if (!this._rpcWebSocketConnected) {\n      this._rpcWebSocket.connect();\n      return;\n    }\n    const activeWebSocketGeneration = this._rpcWebSocketGeneration;\n    const isCurrentConnectionStillActive = () => {\n      return activeWebSocketGeneration === this._rpcWebSocketGeneration;\n    };\n    await Promise.all(\n    // Don't be tempted to change this to `Object.entries`. We call\n    // `_updateSubscriptions` recursively when processing the state,\n    // so it's important that we look up the *current* version of\n    // each subscription, every time we process a hash.\n    Object.keys(this._subscriptionsByHash).map(async hash => {\n      const subscription = this._subscriptionsByHash[hash];\n      if (subscription === undefined) {\n        // This entry has since been deleted. Skip.\n        return;\n      }\n      switch (subscription.state) {\n        case 'pending':\n        case 'unsubscribed':\n          if (subscription.callbacks.size === 0) {\n            /**\n             * You can end up here when:\n             *\n             * - a subscription has recently unsubscribed\n             *   without having new callbacks added to it\n             *   while the unsubscribe was in flight, or\n             * - when a pending subscription has its\n             *   listeners removed before a request was\n             *   sent to the server.\n             *\n             * Being that nobody is interested in this\n             * subscription any longer, delete it.\n             */\n            delete this._subscriptionsByHash[hash];\n            if (subscription.state === 'unsubscribed') {\n              delete this._subscriptionCallbacksByServerSubscriptionId[subscription.serverSubscriptionId];\n            }\n            await this._updateSubscriptions();\n            return;\n          }\n          await (async () => {\n            const {\n              args,\n              method\n            } = subscription;\n            try {\n              this._setSubscription(hash, {\n                ...subscription,\n                state: 'subscribing'\n              });\n              const serverSubscriptionId = await this._rpcWebSocket.call(method, args);\n              this._setSubscription(hash, {\n                ...subscription,\n                serverSubscriptionId,\n                state: 'subscribed'\n              });\n              this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId] = subscription.callbacks;\n              await this._updateSubscriptions();\n            } catch (e) {\n              if (e instanceof Error) {\n                console.error(`${method} error for argument`, args, e.message);\n              }\n              if (!isCurrentConnectionStillActive()) {\n                return;\n              }\n              // TODO: Maybe add an 'errored' state or a retry limit?\n              this._setSubscription(hash, {\n                ...subscription,\n                state: 'pending'\n              });\n              await this._updateSubscriptions();\n            }\n          })();\n          break;\n        case 'subscribed':\n          if (subscription.callbacks.size === 0) {\n            // By the time we successfully set up a subscription\n            // with the server, the client stopped caring about it.\n            // Tear it down now.\n            await (async () => {\n              const {\n                serverSubscriptionId,\n                unsubscribeMethod\n              } = subscription;\n              if (this._subscriptionsAutoDisposedByRpc.has(serverSubscriptionId)) {\n                /**\n                 * Special case.\n                 * If we're dealing with a subscription that has been auto-\n                 * disposed by the RPC, then we can skip the RPC call to\n                 * tear down the subscription here.\n                 *\n                 * NOTE: There is a proposal to eliminate this special case, here:\n                 * https://github.com/solana-labs/solana/issues/18892\n                 */\n                this._subscriptionsAutoDisposedByRpc.delete(serverSubscriptionId);\n              } else {\n                this._setSubscription(hash, {\n                  ...subscription,\n                  state: 'unsubscribing'\n                });\n                this._setSubscription(hash, {\n                  ...subscription,\n                  state: 'unsubscribing'\n                });\n                try {\n                  await this._rpcWebSocket.call(unsubscribeMethod, [serverSubscriptionId]);\n                } catch (e) {\n                  if (e instanceof Error) {\n                    console.error(`${unsubscribeMethod} error:`, e.message);\n                  }\n                  if (!isCurrentConnectionStillActive()) {\n                    return;\n                  }\n                  // TODO: Maybe add an 'errored' state or a retry limit?\n                  this._setSubscription(hash, {\n                    ...subscription,\n                    state: 'subscribed'\n                  });\n                  await this._updateSubscriptions();\n                  return;\n                }\n              }\n              this._setSubscription(hash, {\n                ...subscription,\n                state: 'unsubscribed'\n              });\n              await this._updateSubscriptions();\n            })();\n          }\n          break;\n      }\n    }));\n  }\n\n  /**\n   * @internal\n   */\n  _handleServerNotification(serverSubscriptionId, callbackArgs) {\n    const callbacks = this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId];\n    if (callbacks === undefined) {\n      return;\n    }\n    callbacks.forEach(cb => {\n      try {\n        cb(\n        // I failed to find a way to convince TypeScript that `cb` is of type\n        // `TCallback` which is certainly compatible with `Parameters<TCallback>`.\n        // See https://github.com/microsoft/TypeScript/issues/47615\n        // @ts-ignore\n        ...callbackArgs);\n      } catch (e) {\n        console.error(e);\n      }\n    });\n  }\n\n  /**\n   * @internal\n   */\n  _wsOnAccountNotification(notification) {\n    const {\n      result,\n      subscription\n    } = superstruct.create(notification, AccountNotificationResult);\n    this._handleServerNotification(subscription, [result.value, result.context]);\n  }\n\n  /**\n   * @internal\n   */\n  _makeSubscription(subscriptionConfig,\n  /**\n   * When preparing `args` for a call to `_makeSubscription`, be sure\n   * to carefully apply a default `commitment` property, if necessary.\n   *\n   * - If the user supplied a `commitment` use that.\n   * - Otherwise, if the `Connection::commitment` is set, use that.\n   * - Otherwise, set it to the RPC server default: `finalized`.\n   *\n   * This is extremely important to ensure that these two fundamentally\n   * identical subscriptions produce the same identifying hash:\n   *\n   * - A subscription made without specifying a commitment.\n   * - A subscription made where the commitment specified is the same\n   *   as the default applied to the subscription above.\n   *\n   * Example; these two subscriptions must produce the same hash:\n   *\n   * - An `accountSubscribe` subscription for `'PUBKEY'`\n   * - An `accountSubscribe` subscription for `'PUBKEY'` with commitment\n   *   `'finalized'`.\n   *\n   * See the 'making a subscription with defaulted params omitted' test\n   * in `connection-subscriptions.ts` for more.\n   */\n  args) {\n    const clientSubscriptionId = this._nextClientSubscriptionId++;\n    const hash = fastStableStringify$1([subscriptionConfig.method, args], true /* isArrayProp */);\n    const existingSubscription = this._subscriptionsByHash[hash];\n    if (existingSubscription === undefined) {\n      this._subscriptionsByHash[hash] = {\n        ...subscriptionConfig,\n        args,\n        callbacks: new Set([subscriptionConfig.callback]),\n        state: 'pending'\n      };\n    } else {\n      existingSubscription.callbacks.add(subscriptionConfig.callback);\n    }\n    this._subscriptionHashByClientSubscriptionId[clientSubscriptionId] = hash;\n    this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId] = async () => {\n      delete this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];\n      delete this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];\n      const subscription = this._subscriptionsByHash[hash];\n      assert(subscription !== undefined, `Could not find a \\`Subscription\\` when tearing down client subscription #${clientSubscriptionId}`);\n      subscription.callbacks.delete(subscriptionConfig.callback);\n      await this._updateSubscriptions();\n    };\n    this._updateSubscriptions();\n    return clientSubscriptionId;\n  }\n\n  /**\n   * Register a callback to be invoked whenever the specified account changes\n   *\n   * @param publicKey Public key of the account to monitor\n   * @param callback Function to invoke whenever the account is changed\n   * @param commitment Specify the commitment level account changes must reach before notification\n   * @return subscription id\n   */\n  onAccountChange(publicKey, callback, commitment) {\n    const args = this._buildArgs([publicKey.toBase58()], commitment || this._commitment || 'finalized',\n    // Apply connection/server default.\n    'base64');\n    return this._makeSubscription({\n      callback,\n      method: 'accountSubscribe',\n      unsubscribeMethod: 'accountUnsubscribe'\n    }, args);\n  }\n\n  /**\n   * Deregister an account notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */\n  async removeAccountChangeListener(clientSubscriptionId) {\n    await this._unsubscribeClientSubscription(clientSubscriptionId, 'account change');\n  }\n\n  /**\n   * @internal\n   */\n  _wsOnProgramAccountNotification(notification) {\n    const {\n      result,\n      subscription\n    } = superstruct.create(notification, ProgramAccountNotificationResult);\n    this._handleServerNotification(subscription, [{\n      accountId: result.value.pubkey,\n      accountInfo: result.value.account\n    }, result.context]);\n  }\n\n  /**\n   * Register a callback to be invoked whenever accounts owned by the\n   * specified program change\n   *\n   * @param programId Public key of the program to monitor\n   * @param callback Function to invoke whenever the account is changed\n   * @param commitment Specify the commitment level account changes must reach before notification\n   * @param filters The program account filters to pass into the RPC method\n   * @return subscription id\n   */\n  onProgramAccountChange(programId, callback, commitment, filters) {\n    const args = this._buildArgs([programId.toBase58()], commitment || this._commitment || 'finalized',\n    // Apply connection/server default.\n    'base64' /* encoding */, filters ? {\n      filters: filters\n    } : undefined /* extra */);\n    return this._makeSubscription({\n      callback,\n      method: 'programSubscribe',\n      unsubscribeMethod: 'programUnsubscribe'\n    }, args);\n  }\n\n  /**\n   * Deregister an account notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */\n  async removeProgramAccountChangeListener(clientSubscriptionId) {\n    await this._unsubscribeClientSubscription(clientSubscriptionId, 'program account change');\n  }\n\n  /**\n   * Registers a callback to be invoked whenever logs are emitted.\n   */\n  onLogs(filter, callback, commitment) {\n    const args = this._buildArgs([typeof filter === 'object' ? {\n      mentions: [filter.toString()]\n    } : filter], commitment || this._commitment || 'finalized' // Apply connection/server default.\n    );\n    return this._makeSubscription({\n      callback,\n      method: 'logsSubscribe',\n      unsubscribeMethod: 'logsUnsubscribe'\n    }, args);\n  }\n\n  /**\n   * Deregister a logs callback.\n   *\n   * @param clientSubscriptionId client subscription id to deregister.\n   */\n  async removeOnLogsListener(clientSubscriptionId) {\n    await this._unsubscribeClientSubscription(clientSubscriptionId, 'logs');\n  }\n\n  /**\n   * @internal\n   */\n  _wsOnLogsNotification(notification) {\n    const {\n      result,\n      subscription\n    } = superstruct.create(notification, LogsNotificationResult);\n    this._handleServerNotification(subscription, [result.value, result.context]);\n  }\n\n  /**\n   * @internal\n   */\n  _wsOnSlotNotification(notification) {\n    const {\n      result,\n      subscription\n    } = superstruct.create(notification, SlotNotificationResult);\n    this._handleServerNotification(subscription, [result]);\n  }\n\n  /**\n   * Register a callback to be invoked upon slot changes\n   *\n   * @param callback Function to invoke whenever the slot changes\n   * @return subscription id\n   */\n  onSlotChange(callback) {\n    return this._makeSubscription({\n      callback,\n      method: 'slotSubscribe',\n      unsubscribeMethod: 'slotUnsubscribe'\n    }, [] /* args */);\n  }\n\n  /**\n   * Deregister a slot notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */\n  async removeSlotChangeListener(clientSubscriptionId) {\n    await this._unsubscribeClientSubscription(clientSubscriptionId, 'slot change');\n  }\n\n  /**\n   * @internal\n   */\n  _wsOnSlotUpdatesNotification(notification) {\n    const {\n      result,\n      subscription\n    } = superstruct.create(notification, SlotUpdateNotificationResult);\n    this._handleServerNotification(subscription, [result]);\n  }\n\n  /**\n   * Register a callback to be invoked upon slot updates. {@link SlotUpdate}'s\n   * may be useful to track live progress of a cluster.\n   *\n   * @param callback Function to invoke whenever the slot updates\n   * @return subscription id\n   */\n  onSlotUpdate(callback) {\n    return this._makeSubscription({\n      callback,\n      method: 'slotsUpdatesSubscribe',\n      unsubscribeMethod: 'slotsUpdatesUnsubscribe'\n    }, [] /* args */);\n  }\n\n  /**\n   * Deregister a slot update notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */\n  async removeSlotUpdateListener(clientSubscriptionId) {\n    await this._unsubscribeClientSubscription(clientSubscriptionId, 'slot update');\n  }\n\n  /**\n   * @internal\n   */\n\n  async _unsubscribeClientSubscription(clientSubscriptionId, subscriptionName) {\n    const dispose = this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];\n    if (dispose) {\n      await dispose();\n    } else {\n      console.warn('Ignored unsubscribe request because an active subscription with id ' + `\\`${clientSubscriptionId}\\` for '${subscriptionName}' events ` + 'could not be found.');\n    }\n  }\n  _buildArgs(args, override, encoding, extra) {\n    const commitment = override || this._commitment;\n    if (commitment || encoding || extra) {\n      let options = {};\n      if (encoding) {\n        options.encoding = encoding;\n      }\n      if (commitment) {\n        options.commitment = commitment;\n      }\n      if (extra) {\n        options = Object.assign(options, extra);\n      }\n      args.push(options);\n    }\n    return args;\n  }\n\n  /**\n   * @internal\n   */\n  _buildArgsAtLeastConfirmed(args, override, encoding, extra) {\n    const commitment = override || this._commitment;\n    if (commitment && !['confirmed', 'finalized'].includes(commitment)) {\n      throw new Error('Using Connection with default commitment: `' + this._commitment + '`, but method requires at least `confirmed`');\n    }\n    return this._buildArgs(args, override, encoding, extra);\n  }\n\n  /**\n   * @internal\n   */\n  _wsOnSignatureNotification(notification) {\n    const {\n      result,\n      subscription\n    } = superstruct.create(notification, SignatureNotificationResult);\n    if (result.value !== 'receivedSignature') {\n      /**\n       * Special case.\n       * After a signature is processed, RPCs automatically dispose of the\n       * subscription on the server side. We need to track which of these\n       * subscriptions have been disposed in such a way, so that we know\n       * whether the client is dealing with a not-yet-processed signature\n       * (in which case we must tear down the server subscription) or an\n       * already-processed signature (in which case the client can simply\n       * clear out the subscription locally without telling the server).\n       *\n       * NOTE: There is a proposal to eliminate this special case, here:\n       * https://github.com/solana-labs/solana/issues/18892\n       */\n      this._subscriptionsAutoDisposedByRpc.add(subscription);\n    }\n    this._handleServerNotification(subscription, result.value === 'receivedSignature' ? [{\n      type: 'received'\n    }, result.context] : [{\n      type: 'status',\n      result: result.value\n    }, result.context]);\n  }\n\n  /**\n   * Register a callback to be invoked upon signature updates\n   *\n   * @param signature Transaction signature string in base 58\n   * @param callback Function to invoke on signature notifications\n   * @param commitment Specify the commitment level signature must reach before notification\n   * @return subscription id\n   */\n  onSignature(signature, callback, commitment) {\n    const args = this._buildArgs([signature], commitment || this._commitment || 'finalized' // Apply connection/server default.\n    );\n    const clientSubscriptionId = this._makeSubscription({\n      callback: (notification, context) => {\n        if (notification.type === 'status') {\n          callback(notification.result, context);\n          // Signatures subscriptions are auto-removed by the RPC service\n          // so no need to explicitly send an unsubscribe message.\n          try {\n            this.removeSignatureListener(clientSubscriptionId);\n            // eslint-disable-next-line no-empty\n          } catch (_err) {\n            // Already removed.\n          }\n        }\n      },\n      method: 'signatureSubscribe',\n      unsubscribeMethod: 'signatureUnsubscribe'\n    }, args);\n    return clientSubscriptionId;\n  }\n\n  /**\n   * Register a callback to be invoked when a transaction is\n   * received and/or processed.\n   *\n   * @param signature Transaction signature string in base 58\n   * @param callback Function to invoke on signature notifications\n   * @param options Enable received notifications and set the commitment\n   *   level that signature must reach before notification\n   * @return subscription id\n   */\n  onSignatureWithOptions(signature, callback, options) {\n    const {\n      commitment,\n      ...extra\n    } = {\n      ...options,\n      commitment: options && options.commitment || this._commitment || 'finalized' // Apply connection/server default.\n    };\n    const args = this._buildArgs([signature], commitment, undefined /* encoding */, extra);\n    const clientSubscriptionId = this._makeSubscription({\n      callback: (notification, context) => {\n        callback(notification, context);\n        // Signatures subscriptions are auto-removed by the RPC service\n        // so no need to explicitly send an unsubscribe message.\n        try {\n          this.removeSignatureListener(clientSubscriptionId);\n          // eslint-disable-next-line no-empty\n        } catch (_err) {\n          // Already removed.\n        }\n      },\n      method: 'signatureSubscribe',\n      unsubscribeMethod: 'signatureUnsubscribe'\n    }, args);\n    return clientSubscriptionId;\n  }\n\n  /**\n   * Deregister a signature notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */\n  async removeSignatureListener(clientSubscriptionId) {\n    await this._unsubscribeClientSubscription(clientSubscriptionId, 'signature result');\n  }\n\n  /**\n   * @internal\n   */\n  _wsOnRootNotification(notification) {\n    const {\n      result,\n      subscription\n    } = superstruct.create(notification, RootNotificationResult);\n    this._handleServerNotification(subscription, [result]);\n  }\n\n  /**\n   * Register a callback to be invoked upon root changes\n   *\n   * @param callback Function to invoke whenever the root changes\n   * @return subscription id\n   */\n  onRootChange(callback) {\n    return this._makeSubscription({\n      callback,\n      method: 'rootSubscribe',\n      unsubscribeMethod: 'rootUnsubscribe'\n    }, [] /* args */);\n  }\n\n  /**\n   * Deregister a root notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */\n  async removeRootChangeListener(clientSubscriptionId) {\n    await this._unsubscribeClientSubscription(clientSubscriptionId, 'root change');\n  }\n}\n\n/**\n * Keypair signer interface\n */\n\n/**\n * An account keypair used for signing transactions.\n */\nclass Keypair {\n  /**\n   * Create a new keypair instance.\n   * Generate random keypair if no {@link Ed25519Keypair} is provided.\n   *\n   * @param {Ed25519Keypair} keypair ed25519 keypair\n   */\n  constructor(keypair) {\n    this._keypair = void 0;\n    this._keypair = keypair ?? generateKeypair();\n  }\n\n  /**\n   * Generate a new random keypair\n   *\n   * @returns {Keypair} Keypair\n   */\n  static generate() {\n    return new Keypair(generateKeypair());\n  }\n\n  /**\n   * Create a keypair from a raw secret key byte array.\n   *\n   * This method should only be used to recreate a keypair from a previously\n   * generated secret key. Generating keypairs from a random seed should be done\n   * with the {@link Keypair.fromSeed} method.\n   *\n   * @throws error if the provided secret key is invalid and validation is not skipped.\n   *\n   * @param secretKey secret key byte array\n   * @param options skip secret key validation\n   *\n   * @returns {Keypair} Keypair\n   */\n  static fromSecretKey(secretKey, options) {\n    if (secretKey.byteLength !== 64) {\n      throw new Error('bad secret key size');\n    }\n    const publicKey = secretKey.slice(32, 64);\n    if (!options || !options.skipValidation) {\n      const privateScalar = secretKey.slice(0, 32);\n      const computedPublicKey = getPublicKey(privateScalar);\n      for (let ii = 0; ii < 32; ii++) {\n        if (publicKey[ii] !== computedPublicKey[ii]) {\n          throw new Error('provided secretKey is invalid');\n        }\n      }\n    }\n    return new Keypair({\n      publicKey,\n      secretKey\n    });\n  }\n\n  /**\n   * Generate a keypair from a 32 byte seed.\n   *\n   * @param seed seed byte array\n   *\n   * @returns {Keypair} Keypair\n   */\n  static fromSeed(seed) {\n    const publicKey = getPublicKey(seed);\n    const secretKey = new Uint8Array(64);\n    secretKey.set(seed);\n    secretKey.set(publicKey, 32);\n    return new Keypair({\n      publicKey,\n      secretKey\n    });\n  }\n\n  /**\n   * The public key for this keypair\n   *\n   * @returns {PublicKey} PublicKey\n   */\n  get publicKey() {\n    return new PublicKey(this._keypair.publicKey);\n  }\n\n  /**\n   * The raw secret key for this keypair\n   * @returns {Uint8Array} Secret key in an array of Uint8 bytes\n   */\n  get secretKey() {\n    return new Uint8Array(this._keypair.secretKey);\n  }\n}\n\n/**\n * An enumeration of valid LookupTableInstructionType's\n */\n\n/**\n * An enumeration of valid address lookup table InstructionType's\n * @internal\n */\nconst LOOKUP_TABLE_INSTRUCTION_LAYOUTS = Object.freeze({\n  CreateLookupTable: {\n    index: 0,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), u64('recentSlot'), BufferLayout__namespace.u8('bumpSeed')])\n  },\n  FreezeLookupTable: {\n    index: 1,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction')])\n  },\n  ExtendLookupTable: {\n    index: 2,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), u64(), BufferLayout__namespace.seq(publicKey(), BufferLayout__namespace.offset(BufferLayout__namespace.u32(), -8), 'addresses')])\n  },\n  DeactivateLookupTable: {\n    index: 3,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction')])\n  },\n  CloseLookupTable: {\n    index: 4,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction')])\n  }\n});\nclass AddressLookupTableInstruction {\n  /**\n   * @internal\n   */\n  constructor() {}\n  static decodeInstructionType(instruction) {\n    this.checkProgramId(instruction.programId);\n    const instructionTypeLayout = BufferLayout__namespace.u32('instruction');\n    const index = instructionTypeLayout.decode(instruction.data);\n    let type;\n    for (const [layoutType, layout] of Object.entries(LOOKUP_TABLE_INSTRUCTION_LAYOUTS)) {\n      if (layout.index == index) {\n        type = layoutType;\n        break;\n      }\n    }\n    if (!type) {\n      throw new Error('Invalid Instruction. Should be a LookupTable Instruction');\n    }\n    return type;\n  }\n  static decodeCreateLookupTable(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeysLength(instruction.keys, 4);\n    const {\n      recentSlot\n    } = decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable, instruction.data);\n    return {\n      authority: instruction.keys[1].pubkey,\n      payer: instruction.keys[2].pubkey,\n      recentSlot: Number(recentSlot)\n    };\n  }\n  static decodeExtendLookupTable(instruction) {\n    this.checkProgramId(instruction.programId);\n    if (instruction.keys.length < 2) {\n      throw new Error(`invalid instruction; found ${instruction.keys.length} keys, expected at least 2`);\n    }\n    const {\n      addresses\n    } = decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable, instruction.data);\n    return {\n      lookupTable: instruction.keys[0].pubkey,\n      authority: instruction.keys[1].pubkey,\n      payer: instruction.keys.length > 2 ? instruction.keys[2].pubkey : undefined,\n      addresses: addresses.map(buffer => new PublicKey(buffer))\n    };\n  }\n  static decodeCloseLookupTable(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeysLength(instruction.keys, 3);\n    return {\n      lookupTable: instruction.keys[0].pubkey,\n      authority: instruction.keys[1].pubkey,\n      recipient: instruction.keys[2].pubkey\n    };\n  }\n  static decodeFreezeLookupTable(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeysLength(instruction.keys, 2);\n    return {\n      lookupTable: instruction.keys[0].pubkey,\n      authority: instruction.keys[1].pubkey\n    };\n  }\n  static decodeDeactivateLookupTable(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeysLength(instruction.keys, 2);\n    return {\n      lookupTable: instruction.keys[0].pubkey,\n      authority: instruction.keys[1].pubkey\n    };\n  }\n\n  /**\n   * @internal\n   */\n  static checkProgramId(programId) {\n    if (!programId.equals(AddressLookupTableProgram.programId)) {\n      throw new Error('invalid instruction; programId is not AddressLookupTable Program');\n    }\n  }\n  /**\n   * @internal\n   */\n  static checkKeysLength(keys, expectedLength) {\n    if (keys.length < expectedLength) {\n      throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);\n    }\n  }\n}\nclass AddressLookupTableProgram {\n  /**\n   * @internal\n   */\n  constructor() {}\n  static createLookupTable(params) {\n    const [lookupTableAddress, bumpSeed] = PublicKey.findProgramAddressSync([params.authority.toBuffer(), bigintBuffer.toBufferLE(BigInt(params.recentSlot), 8)], this.programId);\n    const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable;\n    const data = encodeData(type, {\n      recentSlot: BigInt(params.recentSlot),\n      bumpSeed: bumpSeed\n    });\n    const keys = [{\n      pubkey: lookupTableAddress,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: params.authority,\n      isSigner: true,\n      isWritable: false\n    }, {\n      pubkey: params.payer,\n      isSigner: true,\n      isWritable: true\n    }, {\n      pubkey: SystemProgram.programId,\n      isSigner: false,\n      isWritable: false\n    }];\n    return [new TransactionInstruction({\n      programId: this.programId,\n      keys: keys,\n      data: data\n    }), lookupTableAddress];\n  }\n  static freezeLookupTable(params) {\n    const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.FreezeLookupTable;\n    const data = encodeData(type);\n    const keys = [{\n      pubkey: params.lookupTable,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: params.authority,\n      isSigner: true,\n      isWritable: false\n    }];\n    return new TransactionInstruction({\n      programId: this.programId,\n      keys: keys,\n      data: data\n    });\n  }\n  static extendLookupTable(params) {\n    const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable;\n    const data = encodeData(type, {\n      addresses: params.addresses.map(addr => addr.toBytes())\n    });\n    const keys = [{\n      pubkey: params.lookupTable,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: params.authority,\n      isSigner: true,\n      isWritable: false\n    }];\n    if (params.payer) {\n      keys.push({\n        pubkey: params.payer,\n        isSigner: true,\n        isWritable: true\n      }, {\n        pubkey: SystemProgram.programId,\n        isSigner: false,\n        isWritable: false\n      });\n    }\n    return new TransactionInstruction({\n      programId: this.programId,\n      keys: keys,\n      data: data\n    });\n  }\n  static deactivateLookupTable(params) {\n    const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.DeactivateLookupTable;\n    const data = encodeData(type);\n    const keys = [{\n      pubkey: params.lookupTable,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: params.authority,\n      isSigner: true,\n      isWritable: false\n    }];\n    return new TransactionInstruction({\n      programId: this.programId,\n      keys: keys,\n      data: data\n    });\n  }\n  static closeLookupTable(params) {\n    const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CloseLookupTable;\n    const data = encodeData(type);\n    const keys = [{\n      pubkey: params.lookupTable,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: params.authority,\n      isSigner: true,\n      isWritable: false\n    }, {\n      pubkey: params.recipient,\n      isSigner: false,\n      isWritable: true\n    }];\n    return new TransactionInstruction({\n      programId: this.programId,\n      keys: keys,\n      data: data\n    });\n  }\n}\nAddressLookupTableProgram.programId = new PublicKey('AddressLookupTab1e1111111111111111111111111');\n\n/**\n * Compute Budget Instruction class\n */\nclass ComputeBudgetInstruction {\n  /**\n   * @internal\n   */\n  constructor() {}\n\n  /**\n   * Decode a compute budget instruction and retrieve the instruction type.\n   */\n  static decodeInstructionType(instruction) {\n    this.checkProgramId(instruction.programId);\n    const instructionTypeLayout = BufferLayout__namespace.u8('instruction');\n    const typeIndex = instructionTypeLayout.decode(instruction.data);\n    let type;\n    for (const [ixType, layout] of Object.entries(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS)) {\n      if (layout.index == typeIndex) {\n        type = ixType;\n        break;\n      }\n    }\n    if (!type) {\n      throw new Error('Instruction type incorrect; not a ComputeBudgetInstruction');\n    }\n    return type;\n  }\n\n  /**\n   * Decode request units compute budget instruction and retrieve the instruction params.\n   */\n  static decodeRequestUnits(instruction) {\n    this.checkProgramId(instruction.programId);\n    const {\n      units,\n      additionalFee\n    } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits, instruction.data);\n    return {\n      units,\n      additionalFee\n    };\n  }\n\n  /**\n   * Decode request heap frame compute budget instruction and retrieve the instruction params.\n   */\n  static decodeRequestHeapFrame(instruction) {\n    this.checkProgramId(instruction.programId);\n    const {\n      bytes\n    } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame, instruction.data);\n    return {\n      bytes\n    };\n  }\n\n  /**\n   * Decode set compute unit limit compute budget instruction and retrieve the instruction params.\n   */\n  static decodeSetComputeUnitLimit(instruction) {\n    this.checkProgramId(instruction.programId);\n    const {\n      units\n    } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit, instruction.data);\n    return {\n      units\n    };\n  }\n\n  /**\n   * Decode set compute unit price compute budget instruction and retrieve the instruction params.\n   */\n  static decodeSetComputeUnitPrice(instruction) {\n    this.checkProgramId(instruction.programId);\n    const {\n      microLamports\n    } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice, instruction.data);\n    return {\n      microLamports\n    };\n  }\n\n  /**\n   * @internal\n   */\n  static checkProgramId(programId) {\n    if (!programId.equals(ComputeBudgetProgram.programId)) {\n      throw new Error('invalid instruction; programId is not ComputeBudgetProgram');\n    }\n  }\n}\n\n/**\n * An enumeration of valid ComputeBudgetInstructionType's\n */\n\n/**\n * Request units instruction params\n */\n\n/**\n * Request heap frame instruction params\n */\n\n/**\n * Set compute unit limit instruction params\n */\n\n/**\n * Set compute unit price instruction params\n */\n\n/**\n * An enumeration of valid ComputeBudget InstructionType's\n * @internal\n */\nconst COMPUTE_BUDGET_INSTRUCTION_LAYOUTS = Object.freeze({\n  RequestUnits: {\n    index: 0,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u8('instruction'), BufferLayout__namespace.u32('units'), BufferLayout__namespace.u32('additionalFee')])\n  },\n  RequestHeapFrame: {\n    index: 1,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u8('instruction'), BufferLayout__namespace.u32('bytes')])\n  },\n  SetComputeUnitLimit: {\n    index: 2,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u8('instruction'), BufferLayout__namespace.u32('units')])\n  },\n  SetComputeUnitPrice: {\n    index: 3,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u8('instruction'), u64('microLamports')])\n  }\n});\n\n/**\n * Factory class for transaction instructions to interact with the Compute Budget program\n */\nclass ComputeBudgetProgram {\n  /**\n   * @internal\n   */\n  constructor() {}\n\n  /**\n   * Public key that identifies the Compute Budget program\n   */\n\n  /**\n   * @deprecated Instead, call {@link setComputeUnitLimit} and/or {@link setComputeUnitPrice}\n   */\n  static requestUnits(params) {\n    const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits;\n    const data = encodeData(type, params);\n    return new TransactionInstruction({\n      keys: [],\n      programId: this.programId,\n      data\n    });\n  }\n  static requestHeapFrame(params) {\n    const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame;\n    const data = encodeData(type, params);\n    return new TransactionInstruction({\n      keys: [],\n      programId: this.programId,\n      data\n    });\n  }\n  static setComputeUnitLimit(params) {\n    const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit;\n    const data = encodeData(type, params);\n    return new TransactionInstruction({\n      keys: [],\n      programId: this.programId,\n      data\n    });\n  }\n  static setComputeUnitPrice(params) {\n    const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice;\n    const data = encodeData(type, {\n      microLamports: BigInt(params.microLamports)\n    });\n    return new TransactionInstruction({\n      keys: [],\n      programId: this.programId,\n      data\n    });\n  }\n}\nComputeBudgetProgram.programId = new PublicKey('ComputeBudget111111111111111111111111111111');\n\nconst PRIVATE_KEY_BYTES$1 = 64;\nconst PUBLIC_KEY_BYTES$1 = 32;\nconst SIGNATURE_BYTES = 64;\n\n/**\n * Params for creating an ed25519 instruction using a public key\n */\n\n/**\n * Params for creating an ed25519 instruction using a private key\n */\n\nconst ED25519_INSTRUCTION_LAYOUT = BufferLayout__namespace.struct([BufferLayout__namespace.u8('numSignatures'), BufferLayout__namespace.u8('padding'), BufferLayout__namespace.u16('signatureOffset'), BufferLayout__namespace.u16('signatureInstructionIndex'), BufferLayout__namespace.u16('publicKeyOffset'), BufferLayout__namespace.u16('publicKeyInstructionIndex'), BufferLayout__namespace.u16('messageDataOffset'), BufferLayout__namespace.u16('messageDataSize'), BufferLayout__namespace.u16('messageInstructionIndex')]);\nclass Ed25519Program {\n  /**\n   * @internal\n   */\n  constructor() {}\n\n  /**\n   * Public key that identifies the ed25519 program\n   */\n\n  /**\n   * Create an ed25519 instruction with a public key and signature. The\n   * public key must be a buffer that is 32 bytes long, and the signature\n   * must be a buffer of 64 bytes.\n   */\n  static createInstructionWithPublicKey(params) {\n    const {\n      publicKey,\n      message,\n      signature,\n      instructionIndex\n    } = params;\n    assert(publicKey.length === PUBLIC_KEY_BYTES$1, `Public Key must be ${PUBLIC_KEY_BYTES$1} bytes but received ${publicKey.length} bytes`);\n    assert(signature.length === SIGNATURE_BYTES, `Signature must be ${SIGNATURE_BYTES} bytes but received ${signature.length} bytes`);\n    const publicKeyOffset = ED25519_INSTRUCTION_LAYOUT.span;\n    const signatureOffset = publicKeyOffset + publicKey.length;\n    const messageDataOffset = signatureOffset + signature.length;\n    const numSignatures = 1;\n    const instructionData = buffer.Buffer.alloc(messageDataOffset + message.length);\n    const index = instructionIndex == null ? 0xffff // An index of `u16::MAX` makes it default to the current instruction.\n    : instructionIndex;\n    ED25519_INSTRUCTION_LAYOUT.encode({\n      numSignatures,\n      padding: 0,\n      signatureOffset,\n      signatureInstructionIndex: index,\n      publicKeyOffset,\n      publicKeyInstructionIndex: index,\n      messageDataOffset,\n      messageDataSize: message.length,\n      messageInstructionIndex: index\n    }, instructionData);\n    instructionData.fill(publicKey, publicKeyOffset);\n    instructionData.fill(signature, signatureOffset);\n    instructionData.fill(message, messageDataOffset);\n    return new TransactionInstruction({\n      keys: [],\n      programId: Ed25519Program.programId,\n      data: instructionData\n    });\n  }\n\n  /**\n   * Create an ed25519 instruction with a private key. The private key\n   * must be a buffer that is 64 bytes long.\n   */\n  static createInstructionWithPrivateKey(params) {\n    const {\n      privateKey,\n      message,\n      instructionIndex\n    } = params;\n    assert(privateKey.length === PRIVATE_KEY_BYTES$1, `Private key must be ${PRIVATE_KEY_BYTES$1} bytes but received ${privateKey.length} bytes`);\n    try {\n      const keypair = Keypair.fromSecretKey(privateKey);\n      const publicKey = keypair.publicKey.toBytes();\n      const signature = sign(message, keypair.secretKey);\n      return this.createInstructionWithPublicKey({\n        publicKey,\n        message,\n        signature,\n        instructionIndex\n      });\n    } catch (error) {\n      throw new Error(`Error creating instruction; ${error}`);\n    }\n  }\n}\nEd25519Program.programId = new PublicKey('Ed25519SigVerify111111111111111111111111111');\n\nconst ecdsaSign = (msgHash, privKey) => {\n  const signature = secp256k1.secp256k1.sign(msgHash, privKey);\n  return [signature.toCompactRawBytes(), signature.recovery];\n};\nsecp256k1.secp256k1.utils.isValidPrivateKey;\nconst publicKeyCreate = secp256k1.secp256k1.getPublicKey;\n\nconst PRIVATE_KEY_BYTES = 32;\nconst ETHEREUM_ADDRESS_BYTES = 20;\nconst PUBLIC_KEY_BYTES = 64;\nconst SIGNATURE_OFFSETS_SERIALIZED_SIZE = 11;\n\n/**\n * Params for creating an secp256k1 instruction using a public key\n */\n\n/**\n * Params for creating an secp256k1 instruction using an Ethereum address\n */\n\n/**\n * Params for creating an secp256k1 instruction using a private key\n */\n\nconst SECP256K1_INSTRUCTION_LAYOUT = BufferLayout__namespace.struct([BufferLayout__namespace.u8('numSignatures'), BufferLayout__namespace.u16('signatureOffset'), BufferLayout__namespace.u8('signatureInstructionIndex'), BufferLayout__namespace.u16('ethAddressOffset'), BufferLayout__namespace.u8('ethAddressInstructionIndex'), BufferLayout__namespace.u16('messageDataOffset'), BufferLayout__namespace.u16('messageDataSize'), BufferLayout__namespace.u8('messageInstructionIndex'), BufferLayout__namespace.blob(20, 'ethAddress'), BufferLayout__namespace.blob(64, 'signature'), BufferLayout__namespace.u8('recoveryId')]);\nclass Secp256k1Program {\n  /**\n   * @internal\n   */\n  constructor() {}\n\n  /**\n   * Public key that identifies the secp256k1 program\n   */\n\n  /**\n   * Construct an Ethereum address from a secp256k1 public key buffer.\n   * @param {Buffer} publicKey a 64 byte secp256k1 public key buffer\n   */\n  static publicKeyToEthAddress(publicKey) {\n    assert(publicKey.length === PUBLIC_KEY_BYTES, `Public key must be ${PUBLIC_KEY_BYTES} bytes but received ${publicKey.length} bytes`);\n    try {\n      return buffer.Buffer.from(sha3.keccak_256(toBuffer(publicKey))).slice(-ETHEREUM_ADDRESS_BYTES);\n    } catch (error) {\n      throw new Error(`Error constructing Ethereum address: ${error}`);\n    }\n  }\n\n  /**\n   * Create an secp256k1 instruction with a public key. The public key\n   * must be a buffer that is 64 bytes long.\n   */\n  static createInstructionWithPublicKey(params) {\n    const {\n      publicKey,\n      message,\n      signature,\n      recoveryId,\n      instructionIndex\n    } = params;\n    return Secp256k1Program.createInstructionWithEthAddress({\n      ethAddress: Secp256k1Program.publicKeyToEthAddress(publicKey),\n      message,\n      signature,\n      recoveryId,\n      instructionIndex\n    });\n  }\n\n  /**\n   * Create an secp256k1 instruction with an Ethereum address. The address\n   * must be a hex string or a buffer that is 20 bytes long.\n   */\n  static createInstructionWithEthAddress(params) {\n    const {\n      ethAddress: rawAddress,\n      message,\n      signature,\n      recoveryId,\n      instructionIndex = 0\n    } = params;\n    let ethAddress;\n    if (typeof rawAddress === 'string') {\n      if (rawAddress.startsWith('0x')) {\n        ethAddress = buffer.Buffer.from(rawAddress.substr(2), 'hex');\n      } else {\n        ethAddress = buffer.Buffer.from(rawAddress, 'hex');\n      }\n    } else {\n      ethAddress = rawAddress;\n    }\n    assert(ethAddress.length === ETHEREUM_ADDRESS_BYTES, `Address must be ${ETHEREUM_ADDRESS_BYTES} bytes but received ${ethAddress.length} bytes`);\n    const dataStart = 1 + SIGNATURE_OFFSETS_SERIALIZED_SIZE;\n    const ethAddressOffset = dataStart;\n    const signatureOffset = dataStart + ethAddress.length;\n    const messageDataOffset = signatureOffset + signature.length + 1;\n    const numSignatures = 1;\n    const instructionData = buffer.Buffer.alloc(SECP256K1_INSTRUCTION_LAYOUT.span + message.length);\n    SECP256K1_INSTRUCTION_LAYOUT.encode({\n      numSignatures,\n      signatureOffset,\n      signatureInstructionIndex: instructionIndex,\n      ethAddressOffset,\n      ethAddressInstructionIndex: instructionIndex,\n      messageDataOffset,\n      messageDataSize: message.length,\n      messageInstructionIndex: instructionIndex,\n      signature: toBuffer(signature),\n      ethAddress: toBuffer(ethAddress),\n      recoveryId\n    }, instructionData);\n    instructionData.fill(toBuffer(message), SECP256K1_INSTRUCTION_LAYOUT.span);\n    return new TransactionInstruction({\n      keys: [],\n      programId: Secp256k1Program.programId,\n      data: instructionData\n    });\n  }\n\n  /**\n   * Create an secp256k1 instruction with a private key. The private key\n   * must be a buffer that is 32 bytes long.\n   */\n  static createInstructionWithPrivateKey(params) {\n    const {\n      privateKey: pkey,\n      message,\n      instructionIndex\n    } = params;\n    assert(pkey.length === PRIVATE_KEY_BYTES, `Private key must be ${PRIVATE_KEY_BYTES} bytes but received ${pkey.length} bytes`);\n    try {\n      const privateKey = toBuffer(pkey);\n      const publicKey = publicKeyCreate(privateKey, false /* isCompressed */).slice(1); // throw away leading byte\n      const messageHash = buffer.Buffer.from(sha3.keccak_256(toBuffer(message)));\n      const [signature, recoveryId] = ecdsaSign(messageHash, privateKey);\n      return this.createInstructionWithPublicKey({\n        publicKey,\n        message,\n        signature,\n        recoveryId,\n        instructionIndex\n      });\n    } catch (error) {\n      throw new Error(`Error creating instruction; ${error}`);\n    }\n  }\n}\nSecp256k1Program.programId = new PublicKey('KeccakSecp256k11111111111111111111111111111');\n\nvar _class2;\n\n/**\n * Address of the stake config account which configures the rate\n * of stake warmup and cooldown as well as the slashing penalty.\n */\nconst STAKE_CONFIG_ID = new PublicKey('StakeConfig11111111111111111111111111111111');\n\n/**\n * Stake account authority info\n */\nclass Authorized {\n  /**\n   * Create a new Authorized object\n   * @param staker the stake authority\n   * @param withdrawer the withdraw authority\n   */\n  constructor(staker, withdrawer) {\n    /** stake authority */\n    this.staker = void 0;\n    /** withdraw authority */\n    this.withdrawer = void 0;\n    this.staker = staker;\n    this.withdrawer = withdrawer;\n  }\n}\n/**\n * Stake account lockup info\n */\nclass Lockup {\n  /**\n   * Create a new Lockup object\n   */\n  constructor(unixTimestamp, epoch, custodian) {\n    /** Unix timestamp of lockup expiration */\n    this.unixTimestamp = void 0;\n    /** Epoch of lockup expiration */\n    this.epoch = void 0;\n    /** Lockup custodian authority */\n    this.custodian = void 0;\n    this.unixTimestamp = unixTimestamp;\n    this.epoch = epoch;\n    this.custodian = custodian;\n  }\n\n  /**\n   * Default, inactive Lockup value\n   */\n}\n_class2 = Lockup;\nLockup.default = new _class2(0, 0, PublicKey.default);\n/**\n * Create stake account transaction params\n */\n/**\n * Create stake account with seed transaction params\n */\n/**\n * Initialize stake instruction params\n */\n/**\n * Delegate stake instruction params\n */\n/**\n * Authorize stake instruction params\n */\n/**\n * Authorize stake instruction params using a derived key\n */\n/**\n * Split stake instruction params\n */\n/**\n * Split with seed transaction params\n */\n/**\n * Withdraw stake instruction params\n */\n/**\n * Deactivate stake instruction params\n */\n/**\n * Merge stake instruction params\n */\n/**\n * Stake Instruction class\n */\nclass StakeInstruction {\n  /**\n   * @internal\n   */\n  constructor() {}\n\n  /**\n   * Decode a stake instruction and retrieve the instruction type.\n   */\n  static decodeInstructionType(instruction) {\n    this.checkProgramId(instruction.programId);\n    const instructionTypeLayout = BufferLayout__namespace.u32('instruction');\n    const typeIndex = instructionTypeLayout.decode(instruction.data);\n    let type;\n    for (const [ixType, layout] of Object.entries(STAKE_INSTRUCTION_LAYOUTS)) {\n      if (layout.index == typeIndex) {\n        type = ixType;\n        break;\n      }\n    }\n    if (!type) {\n      throw new Error('Instruction type incorrect; not a StakeInstruction');\n    }\n    return type;\n  }\n\n  /**\n   * Decode a initialize stake instruction and retrieve the instruction params.\n   */\n  static decodeInitialize(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 2);\n    const {\n      authorized,\n      lockup\n    } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Initialize, instruction.data);\n    return {\n      stakePubkey: instruction.keys[0].pubkey,\n      authorized: new Authorized(new PublicKey(authorized.staker), new PublicKey(authorized.withdrawer)),\n      lockup: new Lockup(lockup.unixTimestamp, lockup.epoch, new PublicKey(lockup.custodian))\n    };\n  }\n\n  /**\n   * Decode a delegate stake instruction and retrieve the instruction params.\n   */\n  static decodeDelegate(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 6);\n    decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Delegate, instruction.data);\n    return {\n      stakePubkey: instruction.keys[0].pubkey,\n      votePubkey: instruction.keys[1].pubkey,\n      authorizedPubkey: instruction.keys[5].pubkey\n    };\n  }\n\n  /**\n   * Decode an authorize stake instruction and retrieve the instruction params.\n   */\n  static decodeAuthorize(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 3);\n    const {\n      newAuthorized,\n      stakeAuthorizationType\n    } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Authorize, instruction.data);\n    const o = {\n      stakePubkey: instruction.keys[0].pubkey,\n      authorizedPubkey: instruction.keys[2].pubkey,\n      newAuthorizedPubkey: new PublicKey(newAuthorized),\n      stakeAuthorizationType: {\n        index: stakeAuthorizationType\n      }\n    };\n    if (instruction.keys.length > 3) {\n      o.custodianPubkey = instruction.keys[3].pubkey;\n    }\n    return o;\n  }\n\n  /**\n   * Decode an authorize-with-seed stake instruction and retrieve the instruction params.\n   */\n  static decodeAuthorizeWithSeed(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 2);\n    const {\n      newAuthorized,\n      stakeAuthorizationType,\n      authoritySeed,\n      authorityOwner\n    } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, instruction.data);\n    const o = {\n      stakePubkey: instruction.keys[0].pubkey,\n      authorityBase: instruction.keys[1].pubkey,\n      authoritySeed: authoritySeed,\n      authorityOwner: new PublicKey(authorityOwner),\n      newAuthorizedPubkey: new PublicKey(newAuthorized),\n      stakeAuthorizationType: {\n        index: stakeAuthorizationType\n      }\n    };\n    if (instruction.keys.length > 3) {\n      o.custodianPubkey = instruction.keys[3].pubkey;\n    }\n    return o;\n  }\n\n  /**\n   * Decode a split stake instruction and retrieve the instruction params.\n   */\n  static decodeSplit(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 3);\n    const {\n      lamports\n    } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Split, instruction.data);\n    return {\n      stakePubkey: instruction.keys[0].pubkey,\n      splitStakePubkey: instruction.keys[1].pubkey,\n      authorizedPubkey: instruction.keys[2].pubkey,\n      lamports\n    };\n  }\n\n  /**\n   * Decode a merge stake instruction and retrieve the instruction params.\n   */\n  static decodeMerge(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 3);\n    decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Merge, instruction.data);\n    return {\n      stakePubkey: instruction.keys[0].pubkey,\n      sourceStakePubKey: instruction.keys[1].pubkey,\n      authorizedPubkey: instruction.keys[4].pubkey\n    };\n  }\n\n  /**\n   * Decode a withdraw stake instruction and retrieve the instruction params.\n   */\n  static decodeWithdraw(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 5);\n    const {\n      lamports\n    } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Withdraw, instruction.data);\n    const o = {\n      stakePubkey: instruction.keys[0].pubkey,\n      toPubkey: instruction.keys[1].pubkey,\n      authorizedPubkey: instruction.keys[4].pubkey,\n      lamports\n    };\n    if (instruction.keys.length > 5) {\n      o.custodianPubkey = instruction.keys[5].pubkey;\n    }\n    return o;\n  }\n\n  /**\n   * Decode a deactivate stake instruction and retrieve the instruction params.\n   */\n  static decodeDeactivate(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 3);\n    decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Deactivate, instruction.data);\n    return {\n      stakePubkey: instruction.keys[0].pubkey,\n      authorizedPubkey: instruction.keys[2].pubkey\n    };\n  }\n\n  /**\n   * @internal\n   */\n  static checkProgramId(programId) {\n    if (!programId.equals(StakeProgram.programId)) {\n      throw new Error('invalid instruction; programId is not StakeProgram');\n    }\n  }\n\n  /**\n   * @internal\n   */\n  static checkKeyLength(keys, expectedLength) {\n    if (keys.length < expectedLength) {\n      throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);\n    }\n  }\n}\n\n/**\n * An enumeration of valid StakeInstructionType's\n */\n\n/**\n * An enumeration of valid stake InstructionType's\n * @internal\n */\nconst STAKE_INSTRUCTION_LAYOUTS = Object.freeze({\n  Initialize: {\n    index: 0,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), authorized(), lockup()])\n  },\n  Authorize: {\n    index: 1,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), publicKey('newAuthorized'), BufferLayout__namespace.u32('stakeAuthorizationType')])\n  },\n  Delegate: {\n    index: 2,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction')])\n  },\n  Split: {\n    index: 3,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), BufferLayout__namespace.ns64('lamports')])\n  },\n  Withdraw: {\n    index: 4,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), BufferLayout__namespace.ns64('lamports')])\n  },\n  Deactivate: {\n    index: 5,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction')])\n  },\n  Merge: {\n    index: 7,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction')])\n  },\n  AuthorizeWithSeed: {\n    index: 8,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), publicKey('newAuthorized'), BufferLayout__namespace.u32('stakeAuthorizationType'), rustString('authoritySeed'), publicKey('authorityOwner')])\n  }\n});\n\n/**\n * Stake authorization type\n */\n\n/**\n * An enumeration of valid StakeAuthorizationLayout's\n */\nconst StakeAuthorizationLayout = Object.freeze({\n  Staker: {\n    index: 0\n  },\n  Withdrawer: {\n    index: 1\n  }\n});\n\n/**\n * Factory class for transactions to interact with the Stake program\n */\nclass StakeProgram {\n  /**\n   * @internal\n   */\n  constructor() {}\n\n  /**\n   * Public key that identifies the Stake program\n   */\n\n  /**\n   * Generate an Initialize instruction to add to a Stake Create transaction\n   */\n  static initialize(params) {\n    const {\n      stakePubkey,\n      authorized,\n      lockup: maybeLockup\n    } = params;\n    const lockup = maybeLockup || Lockup.default;\n    const type = STAKE_INSTRUCTION_LAYOUTS.Initialize;\n    const data = encodeData(type, {\n      authorized: {\n        staker: toBuffer(authorized.staker.toBuffer()),\n        withdrawer: toBuffer(authorized.withdrawer.toBuffer())\n      },\n      lockup: {\n        unixTimestamp: lockup.unixTimestamp,\n        epoch: lockup.epoch,\n        custodian: toBuffer(lockup.custodian.toBuffer())\n      }\n    });\n    const instructionData = {\n      keys: [{\n        pubkey: stakePubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: SYSVAR_RENT_PUBKEY,\n        isSigner: false,\n        isWritable: false\n      }],\n      programId: this.programId,\n      data\n    };\n    return new TransactionInstruction(instructionData);\n  }\n\n  /**\n   * Generate a Transaction that creates a new Stake account at\n   *   an address generated with `from`, a seed, and the Stake programId\n   */\n  static createAccountWithSeed(params) {\n    const transaction = new Transaction();\n    transaction.add(SystemProgram.createAccountWithSeed({\n      fromPubkey: params.fromPubkey,\n      newAccountPubkey: params.stakePubkey,\n      basePubkey: params.basePubkey,\n      seed: params.seed,\n      lamports: params.lamports,\n      space: this.space,\n      programId: this.programId\n    }));\n    const {\n      stakePubkey,\n      authorized,\n      lockup\n    } = params;\n    return transaction.add(this.initialize({\n      stakePubkey,\n      authorized,\n      lockup\n    }));\n  }\n\n  /**\n   * Generate a Transaction that creates a new Stake account\n   */\n  static createAccount(params) {\n    const transaction = new Transaction();\n    transaction.add(SystemProgram.createAccount({\n      fromPubkey: params.fromPubkey,\n      newAccountPubkey: params.stakePubkey,\n      lamports: params.lamports,\n      space: this.space,\n      programId: this.programId\n    }));\n    const {\n      stakePubkey,\n      authorized,\n      lockup\n    } = params;\n    return transaction.add(this.initialize({\n      stakePubkey,\n      authorized,\n      lockup\n    }));\n  }\n\n  /**\n   * Generate a Transaction that delegates Stake tokens to a validator\n   * Vote PublicKey. This transaction can also be used to redelegate Stake\n   * to a new validator Vote PublicKey.\n   */\n  static delegate(params) {\n    const {\n      stakePubkey,\n      authorizedPubkey,\n      votePubkey\n    } = params;\n    const type = STAKE_INSTRUCTION_LAYOUTS.Delegate;\n    const data = encodeData(type);\n    return new Transaction().add({\n      keys: [{\n        pubkey: stakePubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: votePubkey,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: SYSVAR_CLOCK_PUBKEY,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: STAKE_CONFIG_ID,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: authorizedPubkey,\n        isSigner: true,\n        isWritable: false\n      }],\n      programId: this.programId,\n      data\n    });\n  }\n\n  /**\n   * Generate a Transaction that authorizes a new PublicKey as Staker\n   * or Withdrawer on the Stake account.\n   */\n  static authorize(params) {\n    const {\n      stakePubkey,\n      authorizedPubkey,\n      newAuthorizedPubkey,\n      stakeAuthorizationType,\n      custodianPubkey\n    } = params;\n    const type = STAKE_INSTRUCTION_LAYOUTS.Authorize;\n    const data = encodeData(type, {\n      newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),\n      stakeAuthorizationType: stakeAuthorizationType.index\n    });\n    const keys = [{\n      pubkey: stakePubkey,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: SYSVAR_CLOCK_PUBKEY,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: authorizedPubkey,\n      isSigner: true,\n      isWritable: false\n    }];\n    if (custodianPubkey) {\n      keys.push({\n        pubkey: custodianPubkey,\n        isSigner: true,\n        isWritable: false\n      });\n    }\n    return new Transaction().add({\n      keys,\n      programId: this.programId,\n      data\n    });\n  }\n\n  /**\n   * Generate a Transaction that authorizes a new PublicKey as Staker\n   * or Withdrawer on the Stake account.\n   */\n  static authorizeWithSeed(params) {\n    const {\n      stakePubkey,\n      authorityBase,\n      authoritySeed,\n      authorityOwner,\n      newAuthorizedPubkey,\n      stakeAuthorizationType,\n      custodianPubkey\n    } = params;\n    const type = STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;\n    const data = encodeData(type, {\n      newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),\n      stakeAuthorizationType: stakeAuthorizationType.index,\n      authoritySeed: authoritySeed,\n      authorityOwner: toBuffer(authorityOwner.toBuffer())\n    });\n    const keys = [{\n      pubkey: stakePubkey,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: authorityBase,\n      isSigner: true,\n      isWritable: false\n    }, {\n      pubkey: SYSVAR_CLOCK_PUBKEY,\n      isSigner: false,\n      isWritable: false\n    }];\n    if (custodianPubkey) {\n      keys.push({\n        pubkey: custodianPubkey,\n        isSigner: true,\n        isWritable: false\n      });\n    }\n    return new Transaction().add({\n      keys,\n      programId: this.programId,\n      data\n    });\n  }\n\n  /**\n   * @internal\n   */\n  static splitInstruction(params) {\n    const {\n      stakePubkey,\n      authorizedPubkey,\n      splitStakePubkey,\n      lamports\n    } = params;\n    const type = STAKE_INSTRUCTION_LAYOUTS.Split;\n    const data = encodeData(type, {\n      lamports\n    });\n    return new TransactionInstruction({\n      keys: [{\n        pubkey: stakePubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: splitStakePubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: authorizedPubkey,\n        isSigner: true,\n        isWritable: false\n      }],\n      programId: this.programId,\n      data\n    });\n  }\n\n  /**\n   * Generate a Transaction that splits Stake tokens into another stake account\n   */\n  static split(params,\n  // Compute the cost of allocating the new stake account in lamports\n  rentExemptReserve) {\n    const transaction = new Transaction();\n    transaction.add(SystemProgram.createAccount({\n      fromPubkey: params.authorizedPubkey,\n      newAccountPubkey: params.splitStakePubkey,\n      lamports: rentExemptReserve,\n      space: this.space,\n      programId: this.programId\n    }));\n    return transaction.add(this.splitInstruction(params));\n  }\n\n  /**\n   * Generate a Transaction that splits Stake tokens into another account\n   * derived from a base public key and seed\n   */\n  static splitWithSeed(params,\n  // If this stake account is new, compute the cost of allocating it in lamports\n  rentExemptReserve) {\n    const {\n      stakePubkey,\n      authorizedPubkey,\n      splitStakePubkey,\n      basePubkey,\n      seed,\n      lamports\n    } = params;\n    const transaction = new Transaction();\n    transaction.add(SystemProgram.allocate({\n      accountPubkey: splitStakePubkey,\n      basePubkey,\n      seed,\n      space: this.space,\n      programId: this.programId\n    }));\n    if (rentExemptReserve && rentExemptReserve > 0) {\n      transaction.add(SystemProgram.transfer({\n        fromPubkey: params.authorizedPubkey,\n        toPubkey: splitStakePubkey,\n        lamports: rentExemptReserve\n      }));\n    }\n    return transaction.add(this.splitInstruction({\n      stakePubkey,\n      authorizedPubkey,\n      splitStakePubkey,\n      lamports\n    }));\n  }\n\n  /**\n   * Generate a Transaction that merges Stake accounts.\n   */\n  static merge(params) {\n    const {\n      stakePubkey,\n      sourceStakePubKey,\n      authorizedPubkey\n    } = params;\n    const type = STAKE_INSTRUCTION_LAYOUTS.Merge;\n    const data = encodeData(type);\n    return new Transaction().add({\n      keys: [{\n        pubkey: stakePubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: sourceStakePubKey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: SYSVAR_CLOCK_PUBKEY,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: authorizedPubkey,\n        isSigner: true,\n        isWritable: false\n      }],\n      programId: this.programId,\n      data\n    });\n  }\n\n  /**\n   * Generate a Transaction that withdraws deactivated Stake tokens.\n   */\n  static withdraw(params) {\n    const {\n      stakePubkey,\n      authorizedPubkey,\n      toPubkey,\n      lamports,\n      custodianPubkey\n    } = params;\n    const type = STAKE_INSTRUCTION_LAYOUTS.Withdraw;\n    const data = encodeData(type, {\n      lamports\n    });\n    const keys = [{\n      pubkey: stakePubkey,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: toPubkey,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: SYSVAR_CLOCK_PUBKEY,\n      isSigner: false,\n      isWritable: false\n    }, {\n      pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,\n      isSigner: false,\n      isWritable: false\n    }, {\n      pubkey: authorizedPubkey,\n      isSigner: true,\n      isWritable: false\n    }];\n    if (custodianPubkey) {\n      keys.push({\n        pubkey: custodianPubkey,\n        isSigner: true,\n        isWritable: false\n      });\n    }\n    return new Transaction().add({\n      keys,\n      programId: this.programId,\n      data\n    });\n  }\n\n  /**\n   * Generate a Transaction that deactivates Stake tokens.\n   */\n  static deactivate(params) {\n    const {\n      stakePubkey,\n      authorizedPubkey\n    } = params;\n    const type = STAKE_INSTRUCTION_LAYOUTS.Deactivate;\n    const data = encodeData(type);\n    return new Transaction().add({\n      keys: [{\n        pubkey: stakePubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: SYSVAR_CLOCK_PUBKEY,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: authorizedPubkey,\n        isSigner: true,\n        isWritable: false\n      }],\n      programId: this.programId,\n      data\n    });\n  }\n}\nStakeProgram.programId = new PublicKey('Stake11111111111111111111111111111111111111');\n/**\n * Max space of a Stake account\n *\n * This is generated from the solana-stake-program StakeState struct as\n * `StakeStateV2::size_of()`:\n * https://docs.rs/solana-stake-program/latest/solana_stake_program/stake_state/enum.StakeStateV2.html\n */\nStakeProgram.space = 200;\n\n/**\n * Vote account info\n */\nclass VoteInit {\n  /** [0, 100] */\n\n  constructor(nodePubkey, authorizedVoter, authorizedWithdrawer, commission) {\n    this.nodePubkey = void 0;\n    this.authorizedVoter = void 0;\n    this.authorizedWithdrawer = void 0;\n    this.commission = void 0;\n    this.nodePubkey = nodePubkey;\n    this.authorizedVoter = authorizedVoter;\n    this.authorizedWithdrawer = authorizedWithdrawer;\n    this.commission = commission;\n  }\n}\n\n/**\n * Create vote account transaction params\n */\n\n/**\n * InitializeAccount instruction params\n */\n\n/**\n * Authorize instruction params\n */\n\n/**\n * AuthorizeWithSeed instruction params\n */\n\n/**\n * Withdraw from vote account transaction params\n */\n\n/**\n * Update validator identity (node pubkey) vote account instruction params.\n */\n\n/**\n * Vote Instruction class\n */\nclass VoteInstruction {\n  /**\n   * @internal\n   */\n  constructor() {}\n\n  /**\n   * Decode a vote instruction and retrieve the instruction type.\n   */\n  static decodeInstructionType(instruction) {\n    this.checkProgramId(instruction.programId);\n    const instructionTypeLayout = BufferLayout__namespace.u32('instruction');\n    const typeIndex = instructionTypeLayout.decode(instruction.data);\n    let type;\n    for (const [ixType, layout] of Object.entries(VOTE_INSTRUCTION_LAYOUTS)) {\n      if (layout.index == typeIndex) {\n        type = ixType;\n        break;\n      }\n    }\n    if (!type) {\n      throw new Error('Instruction type incorrect; not a VoteInstruction');\n    }\n    return type;\n  }\n\n  /**\n   * Decode an initialize vote instruction and retrieve the instruction params.\n   */\n  static decodeInitializeAccount(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 4);\n    const {\n      voteInit\n    } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.InitializeAccount, instruction.data);\n    return {\n      votePubkey: instruction.keys[0].pubkey,\n      nodePubkey: instruction.keys[3].pubkey,\n      voteInit: new VoteInit(new PublicKey(voteInit.nodePubkey), new PublicKey(voteInit.authorizedVoter), new PublicKey(voteInit.authorizedWithdrawer), voteInit.commission)\n    };\n  }\n\n  /**\n   * Decode an authorize instruction and retrieve the instruction params.\n   */\n  static decodeAuthorize(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 3);\n    const {\n      newAuthorized,\n      voteAuthorizationType\n    } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Authorize, instruction.data);\n    return {\n      votePubkey: instruction.keys[0].pubkey,\n      authorizedPubkey: instruction.keys[2].pubkey,\n      newAuthorizedPubkey: new PublicKey(newAuthorized),\n      voteAuthorizationType: {\n        index: voteAuthorizationType\n      }\n    };\n  }\n\n  /**\n   * Decode an authorize instruction and retrieve the instruction params.\n   */\n  static decodeAuthorizeWithSeed(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 3);\n    const {\n      voteAuthorizeWithSeedArgs: {\n        currentAuthorityDerivedKeyOwnerPubkey,\n        currentAuthorityDerivedKeySeed,\n        newAuthorized,\n        voteAuthorizationType\n      }\n    } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, instruction.data);\n    return {\n      currentAuthorityDerivedKeyBasePubkey: instruction.keys[2].pubkey,\n      currentAuthorityDerivedKeyOwnerPubkey: new PublicKey(currentAuthorityDerivedKeyOwnerPubkey),\n      currentAuthorityDerivedKeySeed: currentAuthorityDerivedKeySeed,\n      newAuthorizedPubkey: new PublicKey(newAuthorized),\n      voteAuthorizationType: {\n        index: voteAuthorizationType\n      },\n      votePubkey: instruction.keys[0].pubkey\n    };\n  }\n\n  /**\n   * Decode a withdraw instruction and retrieve the instruction params.\n   */\n  static decodeWithdraw(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 3);\n    const {\n      lamports\n    } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Withdraw, instruction.data);\n    return {\n      votePubkey: instruction.keys[0].pubkey,\n      authorizedWithdrawerPubkey: instruction.keys[2].pubkey,\n      lamports,\n      toPubkey: instruction.keys[1].pubkey\n    };\n  }\n\n  /**\n   * @internal\n   */\n  static checkProgramId(programId) {\n    if (!programId.equals(VoteProgram.programId)) {\n      throw new Error('invalid instruction; programId is not VoteProgram');\n    }\n  }\n\n  /**\n   * @internal\n   */\n  static checkKeyLength(keys, expectedLength) {\n    if (keys.length < expectedLength) {\n      throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);\n    }\n  }\n}\n\n/**\n * An enumeration of valid VoteInstructionType's\n */\n\n/** @internal */\n\nconst VOTE_INSTRUCTION_LAYOUTS = Object.freeze({\n  InitializeAccount: {\n    index: 0,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), voteInit()])\n  },\n  Authorize: {\n    index: 1,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), publicKey('newAuthorized'), BufferLayout__namespace.u32('voteAuthorizationType')])\n  },\n  Withdraw: {\n    index: 3,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), BufferLayout__namespace.ns64('lamports')])\n  },\n  UpdateValidatorIdentity: {\n    index: 4,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction')])\n  },\n  AuthorizeWithSeed: {\n    index: 10,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), voteAuthorizeWithSeedArgs()])\n  }\n});\n\n/**\n * VoteAuthorize type\n */\n\n/**\n * An enumeration of valid VoteAuthorization layouts.\n */\nconst VoteAuthorizationLayout = Object.freeze({\n  Voter: {\n    index: 0\n  },\n  Withdrawer: {\n    index: 1\n  }\n});\n\n/**\n * Factory class for transactions to interact with the Vote program\n */\nclass VoteProgram {\n  /**\n   * @internal\n   */\n  constructor() {}\n\n  /**\n   * Public key that identifies the Vote program\n   */\n\n  /**\n   * Generate an Initialize instruction.\n   */\n  static initializeAccount(params) {\n    const {\n      votePubkey,\n      nodePubkey,\n      voteInit\n    } = params;\n    const type = VOTE_INSTRUCTION_LAYOUTS.InitializeAccount;\n    const data = encodeData(type, {\n      voteInit: {\n        nodePubkey: toBuffer(voteInit.nodePubkey.toBuffer()),\n        authorizedVoter: toBuffer(voteInit.authorizedVoter.toBuffer()),\n        authorizedWithdrawer: toBuffer(voteInit.authorizedWithdrawer.toBuffer()),\n        commission: voteInit.commission\n      }\n    });\n    const instructionData = {\n      keys: [{\n        pubkey: votePubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: SYSVAR_RENT_PUBKEY,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: SYSVAR_CLOCK_PUBKEY,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: nodePubkey,\n        isSigner: true,\n        isWritable: false\n      }],\n      programId: this.programId,\n      data\n    };\n    return new TransactionInstruction(instructionData);\n  }\n\n  /**\n   * Generate a transaction that creates a new Vote account.\n   */\n  static createAccount(params) {\n    const transaction = new Transaction();\n    transaction.add(SystemProgram.createAccount({\n      fromPubkey: params.fromPubkey,\n      newAccountPubkey: params.votePubkey,\n      lamports: params.lamports,\n      space: this.space,\n      programId: this.programId\n    }));\n    return transaction.add(this.initializeAccount({\n      votePubkey: params.votePubkey,\n      nodePubkey: params.voteInit.nodePubkey,\n      voteInit: params.voteInit\n    }));\n  }\n\n  /**\n   * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account.\n   */\n  static authorize(params) {\n    const {\n      votePubkey,\n      authorizedPubkey,\n      newAuthorizedPubkey,\n      voteAuthorizationType\n    } = params;\n    const type = VOTE_INSTRUCTION_LAYOUTS.Authorize;\n    const data = encodeData(type, {\n      newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),\n      voteAuthorizationType: voteAuthorizationType.index\n    });\n    const keys = [{\n      pubkey: votePubkey,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: SYSVAR_CLOCK_PUBKEY,\n      isSigner: false,\n      isWritable: false\n    }, {\n      pubkey: authorizedPubkey,\n      isSigner: true,\n      isWritable: false\n    }];\n    return new Transaction().add({\n      keys,\n      programId: this.programId,\n      data\n    });\n  }\n\n  /**\n   * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account\n   * where the current Voter or Withdrawer authority is a derived key.\n   */\n  static authorizeWithSeed(params) {\n    const {\n      currentAuthorityDerivedKeyBasePubkey,\n      currentAuthorityDerivedKeyOwnerPubkey,\n      currentAuthorityDerivedKeySeed,\n      newAuthorizedPubkey,\n      voteAuthorizationType,\n      votePubkey\n    } = params;\n    const type = VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;\n    const data = encodeData(type, {\n      voteAuthorizeWithSeedArgs: {\n        currentAuthorityDerivedKeyOwnerPubkey: toBuffer(currentAuthorityDerivedKeyOwnerPubkey.toBuffer()),\n        currentAuthorityDerivedKeySeed: currentAuthorityDerivedKeySeed,\n        newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),\n        voteAuthorizationType: voteAuthorizationType.index\n      }\n    });\n    const keys = [{\n      pubkey: votePubkey,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: SYSVAR_CLOCK_PUBKEY,\n      isSigner: false,\n      isWritable: false\n    }, {\n      pubkey: currentAuthorityDerivedKeyBasePubkey,\n      isSigner: true,\n      isWritable: false\n    }];\n    return new Transaction().add({\n      keys,\n      programId: this.programId,\n      data\n    });\n  }\n\n  /**\n   * Generate a transaction to withdraw from a Vote account.\n   */\n  static withdraw(params) {\n    const {\n      votePubkey,\n      authorizedWithdrawerPubkey,\n      lamports,\n      toPubkey\n    } = params;\n    const type = VOTE_INSTRUCTION_LAYOUTS.Withdraw;\n    const data = encodeData(type, {\n      lamports\n    });\n    const keys = [{\n      pubkey: votePubkey,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: toPubkey,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: authorizedWithdrawerPubkey,\n      isSigner: true,\n      isWritable: false\n    }];\n    return new Transaction().add({\n      keys,\n      programId: this.programId,\n      data\n    });\n  }\n\n  /**\n   * Generate a transaction to withdraw safely from a Vote account.\n   *\n   * This function was created as a safeguard for vote accounts running validators, `safeWithdraw`\n   * checks that the withdraw amount will not exceed the specified balance while leaving enough left\n   * to cover rent. If you wish to close the vote account by withdrawing the full amount, call the\n   * `withdraw` method directly.\n   */\n  static safeWithdraw(params, currentVoteAccountBalance, rentExemptMinimum) {\n    if (params.lamports > currentVoteAccountBalance - rentExemptMinimum) {\n      throw new Error('Withdraw will leave vote account with insufficient funds.');\n    }\n    return VoteProgram.withdraw(params);\n  }\n\n  /**\n   * Generate a transaction to update the validator identity (node pubkey) of a Vote account.\n   */\n  static updateValidatorIdentity(params) {\n    const {\n      votePubkey,\n      authorizedWithdrawerPubkey,\n      nodePubkey\n    } = params;\n    const type = VOTE_INSTRUCTION_LAYOUTS.UpdateValidatorIdentity;\n    const data = encodeData(type);\n    const keys = [{\n      pubkey: votePubkey,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: nodePubkey,\n      isSigner: true,\n      isWritable: false\n    }, {\n      pubkey: authorizedWithdrawerPubkey,\n      isSigner: true,\n      isWritable: false\n    }];\n    return new Transaction().add({\n      keys,\n      programId: this.programId,\n      data\n    });\n  }\n}\nVoteProgram.programId = new PublicKey('Vote111111111111111111111111111111111111111');\n/**\n * Max space of a Vote account\n *\n * This is generated from the solana-vote-program VoteState struct as\n * `VoteState::size_of()`:\n * https://docs.rs/solana-vote-program/1.9.5/solana_vote_program/vote_state/struct.VoteState.html#method.size_of\n *\n * KEEP IN SYNC WITH `VoteState::size_of()` in https://github.com/solana-labs/solana/blob/a474cb24b9238f5edcc982f65c0b37d4a1046f7e/sdk/program/src/vote/state/mod.rs#L340-L342\n */\nVoteProgram.space = 3762;\n\nconst VALIDATOR_INFO_KEY = new PublicKey('Va1idator1nfo111111111111111111111111111111');\n\n/**\n * @internal\n */\n\n/**\n * Info used to identity validators.\n */\n\nconst InfoString = superstruct.type({\n  name: superstruct.string(),\n  website: superstruct.optional(superstruct.string()),\n  details: superstruct.optional(superstruct.string()),\n  keybaseUsername: superstruct.optional(superstruct.string())\n});\n\n/**\n * ValidatorInfo class\n */\nclass ValidatorInfo {\n  /**\n   * Construct a valid ValidatorInfo\n   *\n   * @param key validator public key\n   * @param info validator information\n   */\n  constructor(key, info) {\n    /**\n     * validator public key\n     */\n    this.key = void 0;\n    /**\n     * validator information\n     */\n    this.info = void 0;\n    this.key = key;\n    this.info = info;\n  }\n\n  /**\n   * Deserialize ValidatorInfo from the config account data. Exactly two config\n   * keys are required in the data.\n   *\n   * @param buffer config account data\n   * @return null if info was not found\n   */\n  static fromConfigData(buffer$1) {\n    let byteArray = [...buffer$1];\n    const configKeyCount = decodeLength(byteArray);\n    if (configKeyCount !== 2) return null;\n    const configKeys = [];\n    for (let i = 0; i < 2; i++) {\n      const publicKey = new PublicKey(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH));\n      const isSigner = guardedShift(byteArray) === 1;\n      configKeys.push({\n        publicKey,\n        isSigner\n      });\n    }\n    if (configKeys[0].publicKey.equals(VALIDATOR_INFO_KEY)) {\n      if (configKeys[1].isSigner) {\n        const rawInfo = rustString().decode(buffer.Buffer.from(byteArray));\n        const info = JSON.parse(rawInfo);\n        superstruct.assert(info, InfoString);\n        return new ValidatorInfo(configKeys[1].publicKey, info);\n      }\n    }\n    return null;\n  }\n}\n\nconst VOTE_PROGRAM_ID = new PublicKey('Vote111111111111111111111111111111111111111');\n\n/**\n * History of how many credits earned by the end of each epoch\n */\n\n/**\n * See https://github.com/solana-labs/solana/blob/8a12ed029cfa38d4a45400916c2463fb82bbec8c/programs/vote_api/src/vote_state.rs#L68-L88\n *\n * @internal\n */\nconst VoteAccountLayout = BufferLayout__namespace.struct([publicKey('nodePubkey'), publicKey('authorizedWithdrawer'), BufferLayout__namespace.u8('commission'), BufferLayout__namespace.nu64(),\n// votes.length\nBufferLayout__namespace.seq(BufferLayout__namespace.struct([BufferLayout__namespace.nu64('slot'), BufferLayout__namespace.u32('confirmationCount')]), BufferLayout__namespace.offset(BufferLayout__namespace.u32(), -8), 'votes'), BufferLayout__namespace.u8('rootSlotValid'), BufferLayout__namespace.nu64('rootSlot'), BufferLayout__namespace.nu64(),\n// authorizedVoters.length\nBufferLayout__namespace.seq(BufferLayout__namespace.struct([BufferLayout__namespace.nu64('epoch'), publicKey('authorizedVoter')]), BufferLayout__namespace.offset(BufferLayout__namespace.u32(), -8), 'authorizedVoters'), BufferLayout__namespace.struct([BufferLayout__namespace.seq(BufferLayout__namespace.struct([publicKey('authorizedPubkey'), BufferLayout__namespace.nu64('epochOfLastAuthorizedSwitch'), BufferLayout__namespace.nu64('targetEpoch')]), 32, 'buf'), BufferLayout__namespace.nu64('idx'), BufferLayout__namespace.u8('isEmpty')], 'priorVoters'), BufferLayout__namespace.nu64(),\n// epochCredits.length\nBufferLayout__namespace.seq(BufferLayout__namespace.struct([BufferLayout__namespace.nu64('epoch'), BufferLayout__namespace.nu64('credits'), BufferLayout__namespace.nu64('prevCredits')]), BufferLayout__namespace.offset(BufferLayout__namespace.u32(), -8), 'epochCredits'), BufferLayout__namespace.struct([BufferLayout__namespace.nu64('slot'), BufferLayout__namespace.nu64('timestamp')], 'lastTimestamp')]);\n/**\n * VoteAccount class\n */\nclass VoteAccount {\n  /**\n   * @internal\n   */\n  constructor(args) {\n    this.nodePubkey = void 0;\n    this.authorizedWithdrawer = void 0;\n    this.commission = void 0;\n    this.rootSlot = void 0;\n    this.votes = void 0;\n    this.authorizedVoters = void 0;\n    this.priorVoters = void 0;\n    this.epochCredits = void 0;\n    this.lastTimestamp = void 0;\n    this.nodePubkey = args.nodePubkey;\n    this.authorizedWithdrawer = args.authorizedWithdrawer;\n    this.commission = args.commission;\n    this.rootSlot = args.rootSlot;\n    this.votes = args.votes;\n    this.authorizedVoters = args.authorizedVoters;\n    this.priorVoters = args.priorVoters;\n    this.epochCredits = args.epochCredits;\n    this.lastTimestamp = args.lastTimestamp;\n  }\n\n  /**\n   * Deserialize VoteAccount from the account data.\n   *\n   * @param buffer account data\n   * @return VoteAccount\n   */\n  static fromAccountData(buffer) {\n    const versionOffset = 4;\n    const va = VoteAccountLayout.decode(toBuffer(buffer), versionOffset);\n    let rootSlot = va.rootSlot;\n    if (!va.rootSlotValid) {\n      rootSlot = null;\n    }\n    return new VoteAccount({\n      nodePubkey: new PublicKey(va.nodePubkey),\n      authorizedWithdrawer: new PublicKey(va.authorizedWithdrawer),\n      commission: va.commission,\n      votes: va.votes,\n      rootSlot,\n      authorizedVoters: va.authorizedVoters.map(parseAuthorizedVoter),\n      priorVoters: getPriorVoters(va.priorVoters),\n      epochCredits: va.epochCredits,\n      lastTimestamp: va.lastTimestamp\n    });\n  }\n}\nfunction parseAuthorizedVoter({\n  authorizedVoter,\n  epoch\n}) {\n  return {\n    epoch,\n    authorizedVoter: new PublicKey(authorizedVoter)\n  };\n}\nfunction parsePriorVoters({\n  authorizedPubkey,\n  epochOfLastAuthorizedSwitch,\n  targetEpoch\n}) {\n  return {\n    authorizedPubkey: new PublicKey(authorizedPubkey),\n    epochOfLastAuthorizedSwitch,\n    targetEpoch\n  };\n}\nfunction getPriorVoters({\n  buf,\n  idx,\n  isEmpty\n}) {\n  if (isEmpty) {\n    return [];\n  }\n  return [...buf.slice(idx + 1).map(parsePriorVoters), ...buf.slice(0, idx).map(parsePriorVoters)];\n}\n\nconst endpoint = {\n  http: {\n    devnet: 'http://api.devnet.solana.com',\n    testnet: 'http://api.testnet.solana.com',\n    'mainnet-beta': 'http://api.mainnet-beta.solana.com/'\n  },\n  https: {\n    devnet: 'https://api.devnet.solana.com',\n    testnet: 'https://api.testnet.solana.com',\n    'mainnet-beta': 'https://api.mainnet-beta.solana.com/'\n  }\n};\n/**\n * Retrieves the RPC API URL for the specified cluster\n * @param {Cluster} [cluster=\"devnet\"] - The cluster name of the RPC API URL to use. Possible options: 'devnet' | 'testnet' | 'mainnet-beta'\n * @param {boolean} [tls=\"http\"] - Use TLS when connecting to cluster.\n *\n * @returns {string} URL string of the RPC endpoint\n */\nfunction clusterApiUrl(cluster, tls) {\n  const key = tls === false ? 'http' : 'https';\n  if (!cluster) {\n    return endpoint[key]['devnet'];\n  }\n  const url = endpoint[key][cluster];\n  if (!url) {\n    throw new Error(`Unknown ${key} cluster: ${cluster}`);\n  }\n  return url;\n}\n\n/**\n * Send and confirm a raw transaction\n *\n * If `commitment` option is not specified, defaults to 'max' commitment.\n *\n * @param {Connection} connection\n * @param {Buffer} rawTransaction\n * @param {TransactionConfirmationStrategy} confirmationStrategy\n * @param {ConfirmOptions} [options]\n * @returns {Promise<TransactionSignature>}\n */\n\n/**\n * @deprecated Calling `sendAndConfirmRawTransaction()` without a `confirmationStrategy`\n * is no longer supported and will be removed in a future version.\n */\n// eslint-disable-next-line no-redeclare\n\n// eslint-disable-next-line no-redeclare\nasync function sendAndConfirmRawTransaction(connection, rawTransaction, confirmationStrategyOrConfirmOptions, maybeConfirmOptions) {\n  let confirmationStrategy;\n  let options;\n  if (confirmationStrategyOrConfirmOptions && Object.prototype.hasOwnProperty.call(confirmationStrategyOrConfirmOptions, 'lastValidBlockHeight')) {\n    confirmationStrategy = confirmationStrategyOrConfirmOptions;\n    options = maybeConfirmOptions;\n  } else if (confirmationStrategyOrConfirmOptions && Object.prototype.hasOwnProperty.call(confirmationStrategyOrConfirmOptions, 'nonceValue')) {\n    confirmationStrategy = confirmationStrategyOrConfirmOptions;\n    options = maybeConfirmOptions;\n  } else {\n    options = confirmationStrategyOrConfirmOptions;\n  }\n  const sendOptions = options && {\n    skipPreflight: options.skipPreflight,\n    preflightCommitment: options.preflightCommitment || options.commitment,\n    minContextSlot: options.minContextSlot\n  };\n  const signature = await connection.sendRawTransaction(rawTransaction, sendOptions);\n  const commitment = options && options.commitment;\n  const confirmationPromise = confirmationStrategy ? connection.confirmTransaction(confirmationStrategy, commitment) : connection.confirmTransaction(signature, commitment);\n  const status = (await confirmationPromise).value;\n  if (status.err) {\n    throw new Error(`Raw transaction ${signature} failed (${JSON.stringify(status)})`);\n  }\n  return signature;\n}\n\n/**\n * There are 1-billion lamports in one SOL\n */\nconst LAMPORTS_PER_SOL = 1000000000;\n\nexports.Account = Account;\nexports.AddressLookupTableAccount = AddressLookupTableAccount;\nexports.AddressLookupTableInstruction = AddressLookupTableInstruction;\nexports.AddressLookupTableProgram = AddressLookupTableProgram;\nexports.Authorized = Authorized;\nexports.BLOCKHASH_CACHE_TIMEOUT_MS = BLOCKHASH_CACHE_TIMEOUT_MS;\nexports.BPF_LOADER_DEPRECATED_PROGRAM_ID = BPF_LOADER_DEPRECATED_PROGRAM_ID;\nexports.BPF_LOADER_PROGRAM_ID = BPF_LOADER_PROGRAM_ID;\nexports.BpfLoader = BpfLoader;\nexports.COMPUTE_BUDGET_INSTRUCTION_LAYOUTS = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS;\nexports.ComputeBudgetInstruction = ComputeBudgetInstruction;\nexports.ComputeBudgetProgram = ComputeBudgetProgram;\nexports.Connection = Connection;\nexports.Ed25519Program = Ed25519Program;\nexports.Enum = Enum;\nexports.EpochSchedule = EpochSchedule;\nexports.FeeCalculatorLayout = FeeCalculatorLayout;\nexports.Keypair = Keypair;\nexports.LAMPORTS_PER_SOL = LAMPORTS_PER_SOL;\nexports.LOOKUP_TABLE_INSTRUCTION_LAYOUTS = LOOKUP_TABLE_INSTRUCTION_LAYOUTS;\nexports.Loader = Loader;\nexports.Lockup = Lockup;\nexports.MAX_SEED_LENGTH = MAX_SEED_LENGTH;\nexports.Message = Message;\nexports.MessageAccountKeys = MessageAccountKeys;\nexports.MessageV0 = MessageV0;\nexports.NONCE_ACCOUNT_LENGTH = NONCE_ACCOUNT_LENGTH;\nexports.NonceAccount = NonceAccount;\nexports.PACKET_DATA_SIZE = PACKET_DATA_SIZE;\nexports.PUBLIC_KEY_LENGTH = PUBLIC_KEY_LENGTH;\nexports.PublicKey = PublicKey;\nexports.SIGNATURE_LENGTH_IN_BYTES = SIGNATURE_LENGTH_IN_BYTES;\nexports.SOLANA_SCHEMA = SOLANA_SCHEMA;\nexports.STAKE_CONFIG_ID = STAKE_CONFIG_ID;\nexports.STAKE_INSTRUCTION_LAYOUTS = STAKE_INSTRUCTION_LAYOUTS;\nexports.SYSTEM_INSTRUCTION_LAYOUTS = SYSTEM_INSTRUCTION_LAYOUTS;\nexports.SYSVAR_CLOCK_PUBKEY = SYSVAR_CLOCK_PUBKEY;\nexports.SYSVAR_EPOCH_SCHEDULE_PUBKEY = SYSVAR_EPOCH_SCHEDULE_PUBKEY;\nexports.SYSVAR_INSTRUCTIONS_PUBKEY = SYSVAR_INSTRUCTIONS_PUBKEY;\nexports.SYSVAR_RECENT_BLOCKHASHES_PUBKEY = SYSVAR_RECENT_BLOCKHASHES_PUBKEY;\nexports.SYSVAR_RENT_PUBKEY = SYSVAR_RENT_PUBKEY;\nexports.SYSVAR_REWARDS_PUBKEY = SYSVAR_REWARDS_PUBKEY;\nexports.SYSVAR_SLOT_HASHES_PUBKEY = SYSVAR_SLOT_HASHES_PUBKEY;\nexports.SYSVAR_SLOT_HISTORY_PUBKEY = SYSVAR_SLOT_HISTORY_PUBKEY;\nexports.SYSVAR_STAKE_HISTORY_PUBKEY = SYSVAR_STAKE_HISTORY_PUBKEY;\nexports.Secp256k1Program = Secp256k1Program;\nexports.SendTransactionError = SendTransactionError;\nexports.SolanaJSONRPCError = SolanaJSONRPCError;\nexports.SolanaJSONRPCErrorCode = SolanaJSONRPCErrorCode;\nexports.StakeAuthorizationLayout = StakeAuthorizationLayout;\nexports.StakeInstruction = StakeInstruction;\nexports.StakeProgram = StakeProgram;\nexports.Struct = Struct;\nexports.SystemInstruction = SystemInstruction;\nexports.SystemProgram = SystemProgram;\nexports.Transaction = Transaction;\nexports.TransactionExpiredBlockheightExceededError = TransactionExpiredBlockheightExceededError;\nexports.TransactionExpiredNonceInvalidError = TransactionExpiredNonceInvalidError;\nexports.TransactionExpiredTimeoutError = TransactionExpiredTimeoutError;\nexports.TransactionInstruction = TransactionInstruction;\nexports.TransactionMessage = TransactionMessage;\nexports.TransactionStatus = TransactionStatus;\nexports.VALIDATOR_INFO_KEY = VALIDATOR_INFO_KEY;\nexports.VERSION_PREFIX_MASK = VERSION_PREFIX_MASK;\nexports.VOTE_PROGRAM_ID = VOTE_PROGRAM_ID;\nexports.ValidatorInfo = ValidatorInfo;\nexports.VersionedMessage = VersionedMessage;\nexports.VersionedTransaction = VersionedTransaction;\nexports.VoteAccount = VoteAccount;\nexports.VoteAuthorizationLayout = VoteAuthorizationLayout;\nexports.VoteInit = VoteInit;\nexports.VoteInstruction = VoteInstruction;\nexports.VoteProgram = VoteProgram;\nexports.clusterApiUrl = clusterApiUrl;\nexports.sendAndConfirmRawTransaction = sendAndConfirmRawTransaction;\nexports.sendAndConfirmTransaction = sendAndConfirmTransaction;\n//# sourceMappingURL=index.cjs.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvc29sYW5hL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dlYjMuanMvbGliL2luZGV4LmNqcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixhQUFhLG1CQUFPLENBQUMsc0JBQVE7QUFDN0IsY0FBYyxtQkFBTyxDQUFDLDRFQUF1QjtBQUM3QyxTQUFTLG1CQUFPLENBQUMsbURBQU87QUFDeEIsV0FBVyxtQkFBTyxDQUFDLGdEQUFNO0FBQ3pCLGFBQWEsbUJBQU8sQ0FBQyx1R0FBc0I7QUFDM0MsWUFBWSxtQkFBTyxDQUFDLHNEQUFPO0FBQzNCLG1CQUFtQixtQkFBTyxDQUFDLHVGQUF1QjtBQUNsRCxtQkFBbUIsbUJBQU8sQ0FBQyxzRUFBZTtBQUMxQyxpQkFBaUIsbUJBQU8sQ0FBQyxrQkFBTTtBQUMvQixtQkFBbUIsbUJBQU8sQ0FBQyxrQkFBTTtBQUNqQyxtQkFBbUIsbUJBQU8sQ0FBQyxvQkFBTztBQUNsQyxrQkFBa0IsbUJBQU8sQ0FBQyxtRUFBYTtBQUN2QyxnQkFBZ0IsbUJBQU8sQ0FBQyx1SEFBMkI7QUFDbkQsZ0JBQWdCLG1CQUFPLENBQUMsZ0VBQVk7QUFDcEMsK0JBQStCLG1CQUFPLENBQUMsOEZBQWdDO0FBQ3ZFLHVCQUF1QixtQkFBTyxDQUFDLGtIQUEwQztBQUN6RSxXQUFXLG1CQUFPLENBQUMsbUdBQW9CO0FBQ3ZDLGdCQUFnQixtQkFBTyxDQUFDLGdGQUF5Qjs7QUFFakQscUNBQXFDLDREQUE0RDs7QUFFakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQ0FBZ0M7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDhCQUE4QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGVBQWU7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLFdBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSw4Q0FBOEMsMkJBQTJCLDhFQUE4RSxXQUFXO0FBQ2xLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsdUJBQXVCLFdBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxVQUFVO0FBQ3hCLGNBQWMsUUFBUTtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUYsa0NBQWtDO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLDhEQUE4RCxPQUFPLDBCQUEwQixrQ0FBa0M7QUFDakk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViw4REFBOEQsT0FBTywwQkFBMEIsa0NBQWtDO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUYsUUFBUTtBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw2QkFBNkI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw4QkFBOEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHFEQUFxRCxTQUFTO0FBQzlEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxHQUFHOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrRkFBa0Y7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBLHlEQUF5RCxHQUFHO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsMkNBQTJDLCtCQUErQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCO0FBQ0EsZUFBZSx3QkFBd0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGtCQUFrQjtBQUMzRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsNkNBQTZDLEtBQUssc0RBQXNEO0FBQ3ZLO0FBQ0E7QUFDQSwrREFBK0QsNkNBQTZDLEtBQUssc0RBQXNEO0FBQ3ZLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGlGQUFpRix3QkFBd0IsSUFBSSxpQkFBaUI7QUFDOUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHFDQUFxQztBQUNsRDtBQUNBLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsZUFBZTtBQUM1QjtBQUNBLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLFNBQVM7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSwwQkFBMEI7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0Esc0JBQXNCLDBDQUEwQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLDRCQUE0QjtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxJQUFJLHFCQUFxQjtBQUM5RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLGFBQWE7QUFDeEIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsZ0JBQWdCO0FBQzNCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFdBQVcsVUFBVSx1QkFBdUI7QUFDL0U7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osMENBQTBDO0FBQzFDO0FBQ0E7QUFDQSwwQ0FBMEMsNkJBQTZCLGtCQUFrQixLQUFLLFdBQVc7QUFDekc7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUSxhQUFhLDBCQUEwQixlQUFlO0FBQzFHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSx1Q0FBdUMsbUJBQW1CLFVBQVUsc0JBQXNCO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsUUFBUTtBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxrQkFBa0IsR0FBRyxrQkFBa0I7QUFDekU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsWUFBWTtBQUMxQixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixtQ0FBbUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHFDQUFxQyxjQUFjLElBQUksUUFBUTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLDBDQUEwQztBQUMxQztBQUNBO0FBQ0EsMkNBQTJDLHdCQUF3QixtQkFBbUIsS0FBSyxXQUFXO0FBQ3RHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELFNBQVM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsY0FBYztBQUM3QyxZQUFZLFNBQVMsSUFBSSxRQUFRLEVBQUUsY0FBYyxFQUFFLEtBQUs7QUFDeEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRjs7QUFFMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCw2QkFBNkI7QUFDeEY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsaUNBQWlDO0FBQzVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxtQkFBbUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxZQUFZLEVBQUUsZUFBZSxvQkFBb0IsU0FBUztBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsOEJBQThCLFlBQVksRUFBRSxlQUFlLElBQUksS0FBSztBQUNwRTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSwyREFBMkQseUJBQXlCO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELG1DQUFtQztBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCLHFCQUFxQjtBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLHFCQUFxQjtBQUNoRztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLEtBQUs7QUFDeEY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtGQUErRix3QkFBd0I7QUFDdkg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMscUNBQXFDLDJEQUEyRDtBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtGQUErRix3QkFBd0I7QUFDdkg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGLHFCQUFxQjtBQUN2RztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0YscUJBQXFCO0FBQ3ZHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRixLQUFLO0FBQ3RGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLEtBQUs7QUFDdEY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YscUJBQXFCO0FBQ3JHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGVBQWUsZ0RBQWdEO0FBQzdFOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUYscUJBQXFCO0FBQzlHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGVBQWUsb0VBQW9FO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUYscUJBQXFCO0FBQzlHO0FBQ0E7QUFDQTs7QUFFQSxrRUFBa0UsdUNBQXVDO0FBQ3pHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGlCQUFpQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsK0JBQStCLG1EQUFtRDtBQUNoRztBQUNBLDZEQUE2RCwwQkFBMEI7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELHdCQUF3QjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTLG1EQUFtRDtBQUMxRTtBQUNBLDZEQUE2RCwwQkFBMEI7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsZUFBZTtBQUNmLGNBQWM7QUFDZDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsNkJBQTZCLGVBQWUsMEJBQTBCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQiw2QkFBNkIsZUFBZTtBQUM3RCxrQ0FBa0M7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLDZCQUE2QixlQUFlO0FBQzdELGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGdCQUFnQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELDBCQUEwQjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELHNCQUFzQjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCw0QkFBNEI7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELDZCQUE2QjtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QseUNBQXlDO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDBDQUEwQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGVBQWU7QUFDM0U7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFFBQVE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLHVCQUF1QjtBQUN2RixNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDJCQUEyQixNQUFNO0FBQ2pFLDJCQUEyQixLQUFLLGlDQUFpQztBQUNqRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx1QkFBdUIsUUFBUTtBQUMvRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsbUVBQW1FLFlBQVk7QUFDL0U7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxpQ0FBaUMsUUFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxxQ0FBcUMsbUJBQW1CO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFIQUFxSCxxQkFBcUI7QUFDMUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0EsMkRBQTJELGlCQUFpQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixnR0FBZ0cscUJBQXFCLFVBQVUsaUJBQWlCO0FBQ2hKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxzQkFBc0I7QUFDMUQ7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx3QkFBd0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRLHlCQUF5QjtBQUM3RTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVEsYUFBYSwwQkFBMEIsZUFBZTtBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQywyQkFBMkIsUUFBUTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sMEVBQTBFLG9CQUFvQixxQkFBcUIsa0JBQWtCO0FBQ3JJLHNFQUFzRSxpQkFBaUIscUJBQXFCLGtCQUFrQjtBQUM5SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiw2RUFBNkUscUJBQXFCLHFCQUFxQixtQkFBbUI7QUFDMUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTixtREFBbUQsRUFBRSxNQUFNO0FBQzNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLHdFQUF3RSxrQkFBa0IscUJBQXFCLGtCQUFrQjtBQUNqSTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDhEQUE4RCxNQUFNO0FBQ3BFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSw0RUFBNEUsd0JBQXdCLHFCQUFxQixtQkFBbUI7QUFDNUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHFFQUFxRSxtQkFBbUIscUJBQXFCLGFBQWE7QUFDMUg7QUFDQTtBQUNBLHdGQUF3RjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTixtREFBbUQsRUFBRSxNQUFNO0FBQzNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUSxhQUFhLDBCQUEwQixlQUFlO0FBQzFHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVEsYUFBYSwwQkFBMEIsZUFBZTtBQUMxRztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixLQUFLLFdBQVcsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxpQ0FBaUM7QUFDNUMsV0FBVyxnQkFBZ0I7QUFDM0IsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsV0FBVyxVQUFVLHVCQUF1QjtBQUNuRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZTtBQUNmLGlDQUFpQztBQUNqQyxxQ0FBcUM7QUFDckMsaUNBQWlDO0FBQ2pDLGtCQUFrQjtBQUNsQixrQ0FBa0M7QUFDbEMsd0NBQXdDO0FBQ3hDLDZCQUE2QjtBQUM3QixpQkFBaUI7QUFDakIsMENBQTBDO0FBQzFDLGdDQUFnQztBQUNoQyw0QkFBNEI7QUFDNUIsa0JBQWtCO0FBQ2xCLHNCQUFzQjtBQUN0QixZQUFZO0FBQ1oscUJBQXFCO0FBQ3JCLDJCQUEyQjtBQUMzQixlQUFlO0FBQ2Ysd0JBQXdCO0FBQ3hCLHdDQUF3QztBQUN4QyxjQUFjO0FBQ2QsY0FBYztBQUNkLHVCQUF1QjtBQUN2QixlQUFlO0FBQ2YsMEJBQTBCO0FBQzFCLGlCQUFpQjtBQUNqQiw0QkFBNEI7QUFDNUIsb0JBQW9CO0FBQ3BCLHdCQUF3QjtBQUN4Qix5QkFBeUI7QUFDekIsaUJBQWlCO0FBQ2pCLGlDQUFpQztBQUNqQyxxQkFBcUI7QUFDckIsdUJBQXVCO0FBQ3ZCLGlDQUFpQztBQUNqQyxrQ0FBa0M7QUFDbEMsMkJBQTJCO0FBQzNCLG9DQUFvQztBQUNwQyxrQ0FBa0M7QUFDbEMsd0NBQXdDO0FBQ3hDLDBCQUEwQjtBQUMxQiw2QkFBNkI7QUFDN0IsaUNBQWlDO0FBQ2pDLGtDQUFrQztBQUNsQyxtQ0FBbUM7QUFDbkMsd0JBQXdCO0FBQ3hCLDRCQUE0QjtBQUM1QiwwQkFBMEI7QUFDMUIsOEJBQThCO0FBQzlCLGdDQUFnQztBQUNoQyx3QkFBd0I7QUFDeEIsb0JBQW9CO0FBQ3BCLGNBQWM7QUFDZCx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCLG1CQUFtQjtBQUNuQixrREFBa0Q7QUFDbEQsMkNBQTJDO0FBQzNDLHNDQUFzQztBQUN0Qyw4QkFBOEI7QUFDOUIsMEJBQTBCO0FBQzFCLHlCQUF5QjtBQUN6QiwwQkFBMEI7QUFDMUIsMkJBQTJCO0FBQzNCLHVCQUF1QjtBQUN2QixxQkFBcUI7QUFDckIsd0JBQXdCO0FBQ3hCLDRCQUE0QjtBQUM1QixtQkFBbUI7QUFDbkIsK0JBQStCO0FBQy9CLGdCQUFnQjtBQUNoQix1QkFBdUI7QUFDdkIsbUJBQW1CO0FBQ25CLHFCQUFxQjtBQUNyQixvQ0FBb0M7QUFDcEMsaUNBQWlDO0FBQ2pDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbnVyc2VibG9jLy4vbm9kZV9tb2R1bGVzL0B0dXJua2V5L3NvbGFuYS9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL2xpYi9pbmRleC5janMuanM/YmJiMiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBidWZmZXIgPSByZXF1aXJlKCdidWZmZXInKTtcbnZhciBlZDI1NTE5ID0gcmVxdWlyZSgnQG5vYmxlL2N1cnZlcy9lZDI1NTE5Jyk7XG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIGJzNTggPSByZXF1aXJlKCdiczU4Jyk7XG52YXIgc2hhMjU2ID0gcmVxdWlyZSgnQG5vYmxlL2hhc2hlcy9zaGEyNTYnKTtcbnZhciBib3JzaCA9IHJlcXVpcmUoJ2JvcnNoJyk7XG52YXIgQnVmZmVyTGF5b3V0ID0gcmVxdWlyZSgnQHNvbGFuYS9idWZmZXItbGF5b3V0Jyk7XG52YXIgYmlnaW50QnVmZmVyID0gcmVxdWlyZSgnYmlnaW50LWJ1ZmZlcicpO1xudmFyIHJlcXVpcmUkJDAgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgcmVxdWlyZSQkMCQxID0gcmVxdWlyZSgnaHR0cCcpO1xudmFyIHJlcXVpcmUkJDAkMiA9IHJlcXVpcmUoJ2h0dHBzJyk7XG52YXIgc3VwZXJzdHJ1Y3QgPSByZXF1aXJlKCdzdXBlcnN0cnVjdCcpO1xudmFyIFJwY0NsaWVudCA9IHJlcXVpcmUoJ2pheXNvbi9saWIvY2xpZW50L2Jyb3dzZXInKTtcbnZhciBub2RlRmV0Y2ggPSByZXF1aXJlKCdub2RlLWZldGNoJyk7XG52YXIgUnBjV2ViU29ja2V0Q29tbW9uQ2xpZW50ID0gcmVxdWlyZSgncnBjLXdlYnNvY2tldHMvZGlzdC9saWIvY2xpZW50Jyk7XG52YXIgV2Vic29ja2V0RmFjdG9yeSA9IHJlcXVpcmUoJ3JwYy13ZWJzb2NrZXRzL2Rpc3QvbGliL2NsaWVudC93ZWJzb2NrZXQnKTtcbnZhciBzaGEzID0gcmVxdWlyZSgnQG5vYmxlL2hhc2hlcy9zaGEzJyk7XG52YXIgc2VjcDI1NmsxID0gcmVxdWlyZSgnQG5vYmxlL2N1cnZlcy9zZWNwMjU2azEnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0Q29tcGF0IChlKSB7IHJldHVybiBlICYmIHR5cGVvZiBlID09PSAnb2JqZWN0JyAmJiAnZGVmYXVsdCcgaW4gZSA/IGUgOiB7IGRlZmF1bHQ6IGUgfTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcE5hbWVzcGFjZUNvbXBhdChlKSB7XG4gIGlmIChlICYmIHR5cGVvZiBlID09PSAnb2JqZWN0JyAmJiAnZGVmYXVsdCcgaW4gZSkgcmV0dXJuIGU7XG4gIHZhciBuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaWYgKGUpIHtcbiAgICBPYmplY3Qua2V5cyhlKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICBpZiAoayAhPT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgIHZhciBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBrKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIGssIGQuZ2V0ID8gZCA6IHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZVtrXTsgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBuLmRlZmF1bHQgPSBlO1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShuKTtcbn1cblxudmFyIEJOX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdENvbXBhdChCTik7XG52YXIgYnM1OF9fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRDb21wYXQoYnM1OCk7XG52YXIgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BOYW1lc3BhY2VDb21wYXQoQnVmZmVyTGF5b3V0KTtcbnZhciByZXF1aXJlJCQwX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdENvbXBhdChyZXF1aXJlJCQwKTtcbnZhciByZXF1aXJlJCQwX19kZWZhdWx0JDEgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0Q29tcGF0KHJlcXVpcmUkJDAkMSk7XG52YXIgcmVxdWlyZSQkMF9fZGVmYXVsdCQyID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdENvbXBhdChyZXF1aXJlJCQwJDIpO1xudmFyIFJwY0NsaWVudF9fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRDb21wYXQoUnBjQ2xpZW50KTtcbnZhciBub2RlRmV0Y2hfX25hbWVzcGFjZSA9IC8qI19fUFVSRV9fKi9faW50ZXJvcE5hbWVzcGFjZUNvbXBhdChub2RlRmV0Y2gpO1xudmFyIFJwY1dlYlNvY2tldENvbW1vbkNsaWVudF9fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRDb21wYXQoUnBjV2ViU29ja2V0Q29tbW9uQ2xpZW50KTtcbnZhciBXZWJzb2NrZXRGYWN0b3J5X19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdENvbXBhdChXZWJzb2NrZXRGYWN0b3J5KTtcblxuLyoqXG4gKiBBIDY0IGJ5dGUgc2VjcmV0IGtleSwgdGhlIGZpcnN0IDMyIGJ5dGVzIG9mIHdoaWNoIGlzIHRoZVxuICogcHJpdmF0ZSBzY2FsYXIgYW5kIHRoZSBsYXN0IDMyIGJ5dGVzIGlzIHRoZSBwdWJsaWMga2V5LlxuICogUmVhZCBtb3JlOiBodHRwczovL2Jsb2cubW96aWxsYS5vcmcvd2FybmVyLzIwMTEvMTEvMjkvZWQyNTUxOS1rZXlzL1xuICovXG5cbi8qKlxuICogRWQyNTUxOSBLZXlwYWlyXG4gKi9cblxuY29uc3QgZ2VuZXJhdGVQcml2YXRlS2V5ID0gZWQyNTUxOS5lZDI1NTE5LnV0aWxzLnJhbmRvbVByaXZhdGVLZXk7XG5jb25zdCBnZW5lcmF0ZUtleXBhaXIgPSAoKSA9PiB7XG4gIGNvbnN0IHByaXZhdGVTY2FsYXIgPSBlZDI1NTE5LmVkMjU1MTkudXRpbHMucmFuZG9tUHJpdmF0ZUtleSgpO1xuICBjb25zdCBwdWJsaWNLZXkgPSBnZXRQdWJsaWNLZXkocHJpdmF0ZVNjYWxhcik7XG4gIGNvbnN0IHNlY3JldEtleSA9IG5ldyBVaW50OEFycmF5KDY0KTtcbiAgc2VjcmV0S2V5LnNldChwcml2YXRlU2NhbGFyKTtcbiAgc2VjcmV0S2V5LnNldChwdWJsaWNLZXksIDMyKTtcbiAgcmV0dXJuIHtcbiAgICBwdWJsaWNLZXksXG4gICAgc2VjcmV0S2V5XG4gIH07XG59O1xuY29uc3QgZ2V0UHVibGljS2V5ID0gZWQyNTUxOS5lZDI1NTE5LmdldFB1YmxpY0tleTtcbmZ1bmN0aW9uIGlzT25DdXJ2ZShwdWJsaWNLZXkpIHtcbiAgdHJ5IHtcbiAgICBlZDI1NTE5LmVkMjU1MTkuRXh0ZW5kZWRQb2ludC5mcm9tSGV4KHB1YmxpY0tleSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuY29uc3Qgc2lnbiA9IChtZXNzYWdlLCBzZWNyZXRLZXkpID0+IGVkMjU1MTkuZWQyNTUxOS5zaWduKG1lc3NhZ2UsIHNlY3JldEtleS5zbGljZSgwLCAzMikpO1xuY29uc3QgdmVyaWZ5ID0gZWQyNTUxOS5lZDI1NTE5LnZlcmlmeTtcblxuY29uc3QgdG9CdWZmZXIgPSBhcnIgPT4ge1xuICBpZiAoYnVmZmVyLkJ1ZmZlci5pc0J1ZmZlcihhcnIpKSB7XG4gICAgcmV0dXJuIGFycjtcbiAgfSBlbHNlIGlmIChhcnIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5CdWZmZXIuZnJvbShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBidWZmZXIuQnVmZmVyLmZyb20oYXJyKTtcbiAgfVxufTtcblxuLy8gQ2xhc3Mgd3JhcHBpbmcgYSBwbGFpbiBvYmplY3RcbmNsYXNzIFN0cnVjdCB7XG4gIGNvbnN0cnVjdG9yKHByb3BlcnRpZXMpIHtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIHByb3BlcnRpZXMpO1xuICB9XG4gIGVuY29kZSgpIHtcbiAgICByZXR1cm4gYnVmZmVyLkJ1ZmZlci5mcm9tKGJvcnNoLnNlcmlhbGl6ZShTT0xBTkFfU0NIRU1BLCB0aGlzKSk7XG4gIH1cbiAgc3RhdGljIGRlY29kZShkYXRhKSB7XG4gICAgcmV0dXJuIGJvcnNoLmRlc2VyaWFsaXplKFNPTEFOQV9TQ0hFTUEsIHRoaXMsIGRhdGEpO1xuICB9XG4gIHN0YXRpYyBkZWNvZGVVbmNoZWNrZWQoZGF0YSkge1xuICAgIHJldHVybiBib3JzaC5kZXNlcmlhbGl6ZVVuY2hlY2tlZChTT0xBTkFfU0NIRU1BLCB0aGlzLCBkYXRhKTtcbiAgfVxufVxuXG4vLyBDbGFzcyByZXByZXNlbnRpbmcgYSBSdXN0LWNvbXBhdGlibGUgZW51bSwgc2luY2UgZW51bXMgYXJlIG9ubHkgc3RyaW5ncyBvclxuLy8gbnVtYmVycyBpbiBwdXJlIEpTXG5jbGFzcyBFbnVtIGV4dGVuZHMgU3RydWN0IHtcbiAgY29uc3RydWN0b3IocHJvcGVydGllcykge1xuICAgIHN1cGVyKHByb3BlcnRpZXMpO1xuICAgIHRoaXMuZW51bSA9ICcnO1xuICAgIGlmIChPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKS5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRW51bSBjYW4gb25seSB0YWtlIHNpbmdsZSB2YWx1ZScpO1xuICAgIH1cbiAgICBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKS5tYXAoa2V5ID0+IHtcbiAgICAgIHRoaXMuZW51bSA9IGtleTtcbiAgICB9KTtcbiAgfVxufVxuY29uc3QgU09MQU5BX1NDSEVNQSA9IG5ldyBNYXAoKTtcblxudmFyIF9jbGFzcztcbmxldCBfU3ltYm9sJHRvU3RyaW5nVGFnO1xuXG4vKipcbiAqIE1heGltdW0gbGVuZ3RoIG9mIGRlcml2ZWQgcHVia2V5IHNlZWRcbiAqL1xuY29uc3QgTUFYX1NFRURfTEVOR1RIID0gMzI7XG5cbi8qKlxuICogU2l6ZSBvZiBwdWJsaWMga2V5IGluIGJ5dGVzXG4gKi9cbmNvbnN0IFBVQkxJQ19LRVlfTEVOR1RIID0gMzI7XG5cbi8qKlxuICogVmFsdWUgdG8gYmUgY29udmVydGVkIGludG8gcHVibGljIGtleVxuICovXG5cbi8qKlxuICogSlNPTiBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgUHVibGljS2V5IGNsYXNzXG4gKi9cblxuZnVuY3Rpb24gaXNQdWJsaWNLZXlEYXRhKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5fYm4gIT09IHVuZGVmaW5lZDtcbn1cblxuLy8gbG9jYWwgY291bnRlciB1c2VkIGJ5IFB1YmxpY0tleS51bmlxdWUoKVxubGV0IHVuaXF1ZVB1YmxpY0tleUNvdW50ZXIgPSAxO1xuXG4vKipcbiAqIEEgcHVibGljIGtleVxuICovXG5fU3ltYm9sJHRvU3RyaW5nVGFnID0gU3ltYm9sLnRvU3RyaW5nVGFnO1xuY2xhc3MgUHVibGljS2V5IGV4dGVuZHMgU3RydWN0IHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBQdWJsaWNLZXkgb2JqZWN0XG4gICAqIEBwYXJhbSB2YWx1ZSBlZDI1NTE5IHB1YmxpYyBrZXkgYXMgYnVmZmVyIG9yIGJhc2UtNTggZW5jb2RlZCBzdHJpbmdcbiAgICovXG4gIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgc3VwZXIoe30pO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9ibiA9IHZvaWQgMDtcbiAgICBpZiAoaXNQdWJsaWNLZXlEYXRhKHZhbHVlKSkge1xuICAgICAgdGhpcy5fYm4gPSB2YWx1ZS5fYm47XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIGFzc3VtZSBiYXNlIDU4IGVuY29kaW5nIGJ5IGRlZmF1bHRcbiAgICAgICAgY29uc3QgZGVjb2RlZCA9IGJzNThfX2RlZmF1bHQuZGVmYXVsdC5kZWNvZGUodmFsdWUpO1xuICAgICAgICBpZiAoZGVjb2RlZC5sZW5ndGggIT0gUFVCTElDX0tFWV9MRU5HVEgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcHVibGljIGtleSBpbnB1dGApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2JuID0gbmV3IEJOX19kZWZhdWx0LmRlZmF1bHQoZGVjb2RlZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9ibiA9IG5ldyBCTl9fZGVmYXVsdC5kZWZhdWx0KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9ibi5ieXRlTGVuZ3RoKCkgPiBQVUJMSUNfS0VZX0xFTkdUSCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcHVibGljIGtleSBpbnB1dGApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdW5pcXVlIFB1YmxpY0tleSBmb3IgdGVzdHMgYW5kIGJlbmNobWFya3MgdXNpbmcgYSBjb3VudGVyXG4gICAqL1xuICBzdGF0aWMgdW5pcXVlKCkge1xuICAgIGNvbnN0IGtleSA9IG5ldyBQdWJsaWNLZXkodW5pcXVlUHVibGljS2V5Q291bnRlcik7XG4gICAgdW5pcXVlUHVibGljS2V5Q291bnRlciArPSAxO1xuICAgIHJldHVybiBuZXcgUHVibGljS2V5KGtleS50b0J1ZmZlcigpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZhdWx0IHB1YmxpYyBrZXkgdmFsdWUuIFRoZSBiYXNlNTgtZW5jb2RlZCBzdHJpbmcgcmVwcmVzZW50YXRpb24gaXMgYWxsIG9uZXMgKGFzIHNlZW4gYmVsb3cpXG4gICAqIFRoZSB1bmRlcmx5aW5nIEJOIG51bWJlciBpcyAzMiBieXRlcyB0aGF0IGFyZSBhbGwgemVyb3NcbiAgICovXG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0d28gcHVibGljS2V5cyBhcmUgZXF1YWxcbiAgICovXG4gIGVxdWFscyhwdWJsaWNLZXkpIHtcbiAgICByZXR1cm4gdGhpcy5fYm4uZXEocHVibGljS2V5Ll9ibik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBiYXNlLTU4IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwdWJsaWMga2V5XG4gICAqL1xuICB0b0Jhc2U1OCgpIHtcbiAgICByZXR1cm4gYnM1OF9fZGVmYXVsdC5kZWZhdWx0LmVuY29kZSh0aGlzLnRvQnl0ZXMoKSk7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvQmFzZTU4KCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBieXRlIGFycmF5IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwdWJsaWMga2V5IGluIGJpZyBlbmRpYW5cbiAgICovXG4gIHRvQnl0ZXMoKSB7XG4gICAgY29uc3QgYnVmID0gdGhpcy50b0J1ZmZlcigpO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShidWYuYnVmZmVyLCBidWYuYnl0ZU9mZnNldCwgYnVmLmJ5dGVMZW5ndGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgQnVmZmVyIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwdWJsaWMga2V5IGluIGJpZyBlbmRpYW5cbiAgICovXG4gIHRvQnVmZmVyKCkge1xuICAgIGNvbnN0IGIgPSB0aGlzLl9ibi50b0FycmF5TGlrZShidWZmZXIuQnVmZmVyKTtcbiAgICBpZiAoYi5sZW5ndGggPT09IFBVQkxJQ19LRVlfTEVOR1RIKSB7XG4gICAgICByZXR1cm4gYjtcbiAgICB9XG4gICAgY29uc3QgemVyb1BhZCA9IGJ1ZmZlci5CdWZmZXIuYWxsb2MoMzIpO1xuICAgIGIuY29weSh6ZXJvUGFkLCAzMiAtIGIubGVuZ3RoKTtcbiAgICByZXR1cm4gemVyb1BhZDtcbiAgfVxuICBnZXQgW19TeW1ib2wkdG9TdHJpbmdUYWddKCkge1xuICAgIHJldHVybiBgUHVibGljS2V5KCR7dGhpcy50b1N0cmluZygpfSlgO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgYmFzZS01OCByZXByZXNlbnRhdGlvbiBvZiB0aGUgcHVibGljIGtleVxuICAgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9CYXNlNTgoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXJpdmUgYSBwdWJsaWMga2V5IGZyb20gYW5vdGhlciBrZXksIGEgc2VlZCwgYW5kIGEgcHJvZ3JhbSBJRC5cbiAgICogVGhlIHByb2dyYW0gSUQgd2lsbCBhbHNvIHNlcnZlIGFzIHRoZSBvd25lciBvZiB0aGUgcHVibGljIGtleSwgZ2l2aW5nXG4gICAqIGl0IHBlcm1pc3Npb24gdG8gd3JpdGUgZGF0YSB0byB0aGUgYWNjb3VudC5cbiAgICovXG4gIC8qIGVzbGludC1kaXNhYmxlIHJlcXVpcmUtYXdhaXQgKi9cbiAgc3RhdGljIGFzeW5jIGNyZWF0ZVdpdGhTZWVkKGZyb21QdWJsaWNLZXksIHNlZWQsIHByb2dyYW1JZCkge1xuICAgIGNvbnN0IGJ1ZmZlciQxID0gYnVmZmVyLkJ1ZmZlci5jb25jYXQoW2Zyb21QdWJsaWNLZXkudG9CdWZmZXIoKSwgYnVmZmVyLkJ1ZmZlci5mcm9tKHNlZWQpLCBwcm9ncmFtSWQudG9CdWZmZXIoKV0pO1xuICAgIGNvbnN0IHB1YmxpY0tleUJ5dGVzID0gc2hhMjU2LnNoYTI1NihidWZmZXIkMSk7XG4gICAgcmV0dXJuIG5ldyBQdWJsaWNLZXkocHVibGljS2V5Qnl0ZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcml2ZSBhIHByb2dyYW0gYWRkcmVzcyBmcm9tIHNlZWRzIGFuZCBhIHByb2dyYW0gSUQuXG4gICAqL1xuICAvKiBlc2xpbnQtZGlzYWJsZSByZXF1aXJlLWF3YWl0ICovXG4gIHN0YXRpYyBjcmVhdGVQcm9ncmFtQWRkcmVzc1N5bmMoc2VlZHMsIHByb2dyYW1JZCkge1xuICAgIGxldCBidWZmZXIkMSA9IGJ1ZmZlci5CdWZmZXIuYWxsb2MoMCk7XG4gICAgc2VlZHMuZm9yRWFjaChmdW5jdGlvbiAoc2VlZCkge1xuICAgICAgaWYgKHNlZWQubGVuZ3RoID4gTUFYX1NFRURfTEVOR1RIKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE1heCBzZWVkIGxlbmd0aCBleGNlZWRlZGApO1xuICAgICAgfVxuICAgICAgYnVmZmVyJDEgPSBidWZmZXIuQnVmZmVyLmNvbmNhdChbYnVmZmVyJDEsIHRvQnVmZmVyKHNlZWQpXSk7XG4gICAgfSk7XG4gICAgYnVmZmVyJDEgPSBidWZmZXIuQnVmZmVyLmNvbmNhdChbYnVmZmVyJDEsIHByb2dyYW1JZC50b0J1ZmZlcigpLCBidWZmZXIuQnVmZmVyLmZyb20oJ1Byb2dyYW1EZXJpdmVkQWRkcmVzcycpXSk7XG4gICAgY29uc3QgcHVibGljS2V5Qnl0ZXMgPSBzaGEyNTYuc2hhMjU2KGJ1ZmZlciQxKTtcbiAgICBpZiAoaXNPbkN1cnZlKHB1YmxpY0tleUJ5dGVzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNlZWRzLCBhZGRyZXNzIG11c3QgZmFsbCBvZmYgdGhlIGN1cnZlYCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHVibGljS2V5KHB1YmxpY0tleUJ5dGVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3luYyB2ZXJzaW9uIG9mIGNyZWF0ZVByb2dyYW1BZGRyZXNzU3luY1xuICAgKiBGb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHtAbGluayBjcmVhdGVQcm9ncmFtQWRkcmVzc1N5bmN9IGluc3RlYWRcbiAgICovXG4gIC8qIGVzbGludC1kaXNhYmxlIHJlcXVpcmUtYXdhaXQgKi9cbiAgc3RhdGljIGFzeW5jIGNyZWF0ZVByb2dyYW1BZGRyZXNzKHNlZWRzLCBwcm9ncmFtSWQpIHtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVQcm9ncmFtQWRkcmVzc1N5bmMoc2VlZHMsIHByb2dyYW1JZCk7XG4gIH1cblxuICAvKipcbiAgICogRmluZCBhIHZhbGlkIHByb2dyYW0gYWRkcmVzc1xuICAgKlxuICAgKiBWYWxpZCBwcm9ncmFtIGFkZHJlc3NlcyBtdXN0IGZhbGwgb2ZmIHRoZSBlZDI1NTE5IGN1cnZlLiAgVGhpcyBmdW5jdGlvblxuICAgKiBpdGVyYXRlcyBhIG5vbmNlIHVudGlsIGl0IGZpbmRzIG9uZSB0aGF0IHdoZW4gY29tYmluZWQgd2l0aCB0aGUgc2VlZHNcbiAgICogcmVzdWx0cyBpbiBhIHZhbGlkIHByb2dyYW0gYWRkcmVzcy5cbiAgICovXG4gIHN0YXRpYyBmaW5kUHJvZ3JhbUFkZHJlc3NTeW5jKHNlZWRzLCBwcm9ncmFtSWQpIHtcbiAgICBsZXQgbm9uY2UgPSAyNTU7XG4gICAgbGV0IGFkZHJlc3M7XG4gICAgd2hpbGUgKG5vbmNlICE9IDApIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHNlZWRzV2l0aE5vbmNlID0gc2VlZHMuY29uY2F0KGJ1ZmZlci5CdWZmZXIuZnJvbShbbm9uY2VdKSk7XG4gICAgICAgIGFkZHJlc3MgPSB0aGlzLmNyZWF0ZVByb2dyYW1BZGRyZXNzU3luYyhzZWVkc1dpdGhOb25jZSwgcHJvZ3JhbUlkKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgVHlwZUVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIG5vbmNlLS07XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFthZGRyZXNzLCBub25jZV07XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGZpbmQgYSB2aWFibGUgcHJvZ3JhbSBhZGRyZXNzIG5vbmNlYCk7XG4gIH1cblxuICAvKipcbiAgICogQXN5bmMgdmVyc2lvbiBvZiBmaW5kUHJvZ3JhbUFkZHJlc3NTeW5jXG4gICAqIEZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Uge0BsaW5rIGZpbmRQcm9ncmFtQWRkcmVzc1N5bmN9IGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBhc3luYyBmaW5kUHJvZ3JhbUFkZHJlc3Moc2VlZHMsIHByb2dyYW1JZCkge1xuICAgIHJldHVybiB0aGlzLmZpbmRQcm9ncmFtQWRkcmVzc1N5bmMoc2VlZHMsIHByb2dyYW1JZCk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgdGhhdCBhIHB1YmtleSBpcyBvbiB0aGUgZWQyNTUxOSBjdXJ2ZS5cbiAgICovXG4gIHN0YXRpYyBpc09uQ3VydmUocHVia2V5RGF0YSkge1xuICAgIGNvbnN0IHB1YmtleSA9IG5ldyBQdWJsaWNLZXkocHVia2V5RGF0YSk7XG4gICAgcmV0dXJuIGlzT25DdXJ2ZShwdWJrZXkudG9CeXRlcygpKTtcbiAgfVxufVxuX2NsYXNzID0gUHVibGljS2V5O1xuUHVibGljS2V5LmRlZmF1bHQgPSBuZXcgX2NsYXNzKCcxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuU09MQU5BX1NDSEVNQS5zZXQoUHVibGljS2V5LCB7XG4gIGtpbmQ6ICdzdHJ1Y3QnLFxuICBmaWVsZHM6IFtbJ19ibicsICd1MjU2J11dXG59KTtcblxuLyoqXG4gKiBBbiBhY2NvdW50IGtleSBwYWlyIChwdWJsaWMgYW5kIHNlY3JldCBrZXlzKS5cbiAqXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2MS4xMC4wLCBwbGVhc2UgdXNlIHtAbGluayBLZXlwYWlyfSBpbnN0ZWFkLlxuICovXG5jbGFzcyBBY2NvdW50IHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBBY2NvdW50IG9iamVjdFxuICAgKlxuICAgKiBJZiB0aGUgc2VjcmV0S2V5IHBhcmFtZXRlciBpcyBub3QgcHJvdmlkZWQgYSBuZXcga2V5IHBhaXIgaXMgcmFuZG9tbHlcbiAgICogY3JlYXRlZCBmb3IgdGhlIGFjY291bnRcbiAgICpcbiAgICogQHBhcmFtIHNlY3JldEtleSBTZWNyZXQga2V5IGZvciB0aGUgYWNjb3VudFxuICAgKi9cbiAgY29uc3RydWN0b3Ioc2VjcmV0S2V5KSB7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3B1YmxpY0tleSA9IHZvaWQgMDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fc2VjcmV0S2V5ID0gdm9pZCAwO1xuICAgIGlmIChzZWNyZXRLZXkpIHtcbiAgICAgIGNvbnN0IHNlY3JldEtleUJ1ZmZlciA9IHRvQnVmZmVyKHNlY3JldEtleSk7XG4gICAgICBpZiAoc2VjcmV0S2V5Lmxlbmd0aCAhPT0gNjQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgc2VjcmV0IGtleSBzaXplJyk7XG4gICAgICB9XG4gICAgICB0aGlzLl9wdWJsaWNLZXkgPSBzZWNyZXRLZXlCdWZmZXIuc2xpY2UoMzIsIDY0KTtcbiAgICAgIHRoaXMuX3NlY3JldEtleSA9IHNlY3JldEtleUJ1ZmZlci5zbGljZSgwLCAzMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3NlY3JldEtleSA9IHRvQnVmZmVyKGdlbmVyYXRlUHJpdmF0ZUtleSgpKTtcbiAgICAgIHRoaXMuX3B1YmxpY0tleSA9IHRvQnVmZmVyKGdldFB1YmxpY0tleSh0aGlzLl9zZWNyZXRLZXkpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhlIHB1YmxpYyBrZXkgZm9yIHRoaXMgYWNjb3VudFxuICAgKi9cbiAgZ2V0IHB1YmxpY0tleSgpIHtcbiAgICByZXR1cm4gbmV3IFB1YmxpY0tleSh0aGlzLl9wdWJsaWNLZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSAqKnVuZW5jcnlwdGVkKiogc2VjcmV0IGtleSBmb3IgdGhpcyBhY2NvdW50LiBUaGUgZmlyc3QgMzIgYnl0ZXNcbiAgICogaXMgdGhlIHByaXZhdGUgc2NhbGFyIGFuZCB0aGUgbGFzdCAzMiBieXRlcyBpcyB0aGUgcHVibGljIGtleS5cbiAgICogUmVhZCBtb3JlOiBodHRwczovL2Jsb2cubW96aWxsYS5vcmcvd2FybmVyLzIwMTEvMTEvMjkvZWQyNTUxOS1rZXlzL1xuICAgKi9cbiAgZ2V0IHNlY3JldEtleSgpIHtcbiAgICByZXR1cm4gYnVmZmVyLkJ1ZmZlci5jb25jYXQoW3RoaXMuX3NlY3JldEtleSwgdGhpcy5fcHVibGljS2V5XSwgNjQpO1xuICB9XG59XG5cbmNvbnN0IEJQRl9MT0FERVJfREVQUkVDQVRFRF9QUk9HUkFNX0lEID0gbmV3IFB1YmxpY0tleSgnQlBGTG9hZGVyMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuXG4vKipcbiAqIE1heGltdW0gb3Zlci10aGUtd2lyZSBzaXplIG9mIGEgVHJhbnNhY3Rpb25cbiAqXG4gKiAxMjgwIGlzIElQdjYgbWluaW11bSBNVFVcbiAqIDQwIGJ5dGVzIGlzIHRoZSBzaXplIG9mIHRoZSBJUHY2IGhlYWRlclxuICogOCBieXRlcyBpcyB0aGUgc2l6ZSBvZiB0aGUgZnJhZ21lbnQgaGVhZGVyXG4gKi9cbmNvbnN0IFBBQ0tFVF9EQVRBX1NJWkUgPSAxMjgwIC0gNDAgLSA4O1xuY29uc3QgVkVSU0lPTl9QUkVGSVhfTUFTSyA9IDB4N2Y7XG5jb25zdCBTSUdOQVRVUkVfTEVOR1RIX0lOX0JZVEVTID0gNjQ7XG5cbmNsYXNzIFRyYW5zYWN0aW9uRXhwaXJlZEJsb2NraGVpZ2h0RXhjZWVkZWRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3Ioc2lnbmF0dXJlKSB7XG4gICAgc3VwZXIoYFNpZ25hdHVyZSAke3NpZ25hdHVyZX0gaGFzIGV4cGlyZWQ6IGJsb2NrIGhlaWdodCBleGNlZWRlZC5gKTtcbiAgICB0aGlzLnNpZ25hdHVyZSA9IHZvaWQgMDtcbiAgICB0aGlzLnNpZ25hdHVyZSA9IHNpZ25hdHVyZTtcbiAgfVxufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyYW5zYWN0aW9uRXhwaXJlZEJsb2NraGVpZ2h0RXhjZWVkZWRFcnJvci5wcm90b3R5cGUsICduYW1lJywge1xuICB2YWx1ZTogJ1RyYW5zYWN0aW9uRXhwaXJlZEJsb2NraGVpZ2h0RXhjZWVkZWRFcnJvcidcbn0pO1xuY2xhc3MgVHJhbnNhY3Rpb25FeHBpcmVkVGltZW91dEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihzaWduYXR1cmUsIHRpbWVvdXRTZWNvbmRzKSB7XG4gICAgc3VwZXIoYFRyYW5zYWN0aW9uIHdhcyBub3QgY29uZmlybWVkIGluICR7dGltZW91dFNlY29uZHMudG9GaXhlZCgyKX0gc2Vjb25kcy4gSXQgaXMgYCArICd1bmtub3duIGlmIGl0IHN1Y2NlZWRlZCBvciBmYWlsZWQuIENoZWNrIHNpZ25hdHVyZSAnICsgYCR7c2lnbmF0dXJlfSB1c2luZyB0aGUgU29sYW5hIEV4cGxvcmVyIG9yIENMSSB0b29scy5gKTtcbiAgICB0aGlzLnNpZ25hdHVyZSA9IHZvaWQgMDtcbiAgICB0aGlzLnNpZ25hdHVyZSA9IHNpZ25hdHVyZTtcbiAgfVxufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyYW5zYWN0aW9uRXhwaXJlZFRpbWVvdXRFcnJvci5wcm90b3R5cGUsICduYW1lJywge1xuICB2YWx1ZTogJ1RyYW5zYWN0aW9uRXhwaXJlZFRpbWVvdXRFcnJvcidcbn0pO1xuY2xhc3MgVHJhbnNhY3Rpb25FeHBpcmVkTm9uY2VJbnZhbGlkRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHNpZ25hdHVyZSkge1xuICAgIHN1cGVyKGBTaWduYXR1cmUgJHtzaWduYXR1cmV9IGhhcyBleHBpcmVkOiB0aGUgbm9uY2UgaXMgbm8gbG9uZ2VyIHZhbGlkLmApO1xuICAgIHRoaXMuc2lnbmF0dXJlID0gdm9pZCAwO1xuICAgIHRoaXMuc2lnbmF0dXJlID0gc2lnbmF0dXJlO1xuICB9XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVHJhbnNhY3Rpb25FeHBpcmVkTm9uY2VJbnZhbGlkRXJyb3IucHJvdG90eXBlLCAnbmFtZScsIHtcbiAgdmFsdWU6ICdUcmFuc2FjdGlvbkV4cGlyZWROb25jZUludmFsaWRFcnJvcidcbn0pO1xuXG5jbGFzcyBNZXNzYWdlQWNjb3VudEtleXMge1xuICBjb25zdHJ1Y3RvcihzdGF0aWNBY2NvdW50S2V5cywgYWNjb3VudEtleXNGcm9tTG9va3Vwcykge1xuICAgIHRoaXMuc3RhdGljQWNjb3VudEtleXMgPSB2b2lkIDA7XG4gICAgdGhpcy5hY2NvdW50S2V5c0Zyb21Mb29rdXBzID0gdm9pZCAwO1xuICAgIHRoaXMuc3RhdGljQWNjb3VudEtleXMgPSBzdGF0aWNBY2NvdW50S2V5cztcbiAgICB0aGlzLmFjY291bnRLZXlzRnJvbUxvb2t1cHMgPSBhY2NvdW50S2V5c0Zyb21Mb29rdXBzO1xuICB9XG4gIGtleVNlZ21lbnRzKCkge1xuICAgIGNvbnN0IGtleVNlZ21lbnRzID0gW3RoaXMuc3RhdGljQWNjb3VudEtleXNdO1xuICAgIGlmICh0aGlzLmFjY291bnRLZXlzRnJvbUxvb2t1cHMpIHtcbiAgICAgIGtleVNlZ21lbnRzLnB1c2godGhpcy5hY2NvdW50S2V5c0Zyb21Mb29rdXBzLndyaXRhYmxlKTtcbiAgICAgIGtleVNlZ21lbnRzLnB1c2godGhpcy5hY2NvdW50S2V5c0Zyb21Mb29rdXBzLnJlYWRvbmx5KTtcbiAgICB9XG4gICAgcmV0dXJuIGtleVNlZ21lbnRzO1xuICB9XG4gIGdldChpbmRleCkge1xuICAgIGZvciAoY29uc3Qga2V5U2VnbWVudCBvZiB0aGlzLmtleVNlZ21lbnRzKCkpIHtcbiAgICAgIGlmIChpbmRleCA8IGtleVNlZ21lbnQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBrZXlTZWdtZW50W2luZGV4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGV4IC09IGtleVNlZ21lbnQubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgZ2V0IGxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5rZXlTZWdtZW50cygpLmZsYXQoKS5sZW5ndGg7XG4gIH1cbiAgY29tcGlsZUluc3RydWN0aW9ucyhpbnN0cnVjdGlvbnMpIHtcbiAgICAvLyBCYWlsIGVhcmx5IGlmIGFueSBhY2NvdW50IGluZGV4ZXMgd291bGQgb3ZlcmZsb3cgYSB1OFxuICAgIGNvbnN0IFU4X01BWCA9IDI1NTtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBVOF9NQVggKyAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjY291bnQgaW5kZXggb3ZlcmZsb3cgZW5jb3VudGVyZWQgZHVyaW5nIGNvbXBpbGF0aW9uJyk7XG4gICAgfVxuICAgIGNvbnN0IGtleUluZGV4TWFwID0gbmV3IE1hcCgpO1xuICAgIHRoaXMua2V5U2VnbWVudHMoKS5mbGF0KCkuZm9yRWFjaCgoa2V5LCBpbmRleCkgPT4ge1xuICAgICAga2V5SW5kZXhNYXAuc2V0KGtleS50b0Jhc2U1OCgpLCBpbmRleCk7XG4gICAgfSk7XG4gICAgY29uc3QgZmluZEtleUluZGV4ID0ga2V5ID0+IHtcbiAgICAgIGNvbnN0IGtleUluZGV4ID0ga2V5SW5kZXhNYXAuZ2V0KGtleS50b0Jhc2U1OCgpKTtcbiAgICAgIGlmIChrZXlJbmRleCA9PT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcgRXJyb3IoJ0VuY291bnRlcmVkIGFuIHVua25vd24gaW5zdHJ1Y3Rpb24gYWNjb3VudCBrZXkgZHVyaW5nIGNvbXBpbGF0aW9uJyk7XG4gICAgICByZXR1cm4ga2V5SW5kZXg7XG4gICAgfTtcbiAgICByZXR1cm4gaW5zdHJ1Y3Rpb25zLm1hcChpbnN0cnVjdGlvbiA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcm9ncmFtSWRJbmRleDogZmluZEtleUluZGV4KGluc3RydWN0aW9uLnByb2dyYW1JZCksXG4gICAgICAgIGFjY291bnRLZXlJbmRleGVzOiBpbnN0cnVjdGlvbi5rZXlzLm1hcChtZXRhID0+IGZpbmRLZXlJbmRleChtZXRhLnB1YmtleSkpLFxuICAgICAgICBkYXRhOiBpbnN0cnVjdGlvbi5kYXRhXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogTGF5b3V0IGZvciBhIHB1YmxpYyBrZXlcbiAqL1xuY29uc3QgcHVibGljS2V5ID0gKHByb3BlcnR5ID0gJ3B1YmxpY0tleScpID0+IHtcbiAgcmV0dXJuIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLmJsb2IoMzIsIHByb3BlcnR5KTtcbn07XG5cbi8qKlxuICogTGF5b3V0IGZvciBhIHNpZ25hdHVyZVxuICovXG5jb25zdCBzaWduYXR1cmUgPSAocHJvcGVydHkgPSAnc2lnbmF0dXJlJykgPT4ge1xuICByZXR1cm4gQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UuYmxvYig2NCwgcHJvcGVydHkpO1xufTtcbi8qKlxuICogTGF5b3V0IGZvciBhIFJ1c3QgU3RyaW5nIHR5cGVcbiAqL1xuY29uc3QgcnVzdFN0cmluZyA9IChwcm9wZXJ0eSA9ICdzdHJpbmcnKSA9PiB7XG4gIGNvbnN0IHJzbCA9IEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnN0cnVjdChbQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTMyKCdsZW5ndGgnKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTMyKCdsZW5ndGhQYWRkaW5nJyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLmJsb2IoQnVmZmVyTGF5b3V0X19uYW1lc3BhY2Uub2Zmc2V0KEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnUzMigpLCAtOCksICdjaGFycycpXSwgcHJvcGVydHkpO1xuICBjb25zdCBfZGVjb2RlID0gcnNsLmRlY29kZS5iaW5kKHJzbCk7XG4gIGNvbnN0IF9lbmNvZGUgPSByc2wuZW5jb2RlLmJpbmQocnNsKTtcbiAgY29uc3QgcnNsU2hpbSA9IHJzbDtcbiAgcnNsU2hpbS5kZWNvZGUgPSAoYiwgb2Zmc2V0KSA9PiB7XG4gICAgY29uc3QgZGF0YSA9IF9kZWNvZGUoYiwgb2Zmc2V0KTtcbiAgICByZXR1cm4gZGF0YVsnY2hhcnMnXS50b1N0cmluZygpO1xuICB9O1xuICByc2xTaGltLmVuY29kZSA9IChzdHIsIGIsIG9mZnNldCkgPT4ge1xuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICBjaGFyczogYnVmZmVyLkJ1ZmZlci5mcm9tKHN0ciwgJ3V0ZjgnKVxuICAgIH07XG4gICAgcmV0dXJuIF9lbmNvZGUoZGF0YSwgYiwgb2Zmc2V0KTtcbiAgfTtcbiAgcnNsU2hpbS5hbGxvYyA9IHN0ciA9PiB7XG4gICAgcmV0dXJuIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnUzMigpLnNwYW4gKyBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51MzIoKS5zcGFuICsgYnVmZmVyLkJ1ZmZlci5mcm9tKHN0ciwgJ3V0ZjgnKS5sZW5ndGg7XG4gIH07XG4gIHJldHVybiByc2xTaGltO1xufTtcblxuLyoqXG4gKiBMYXlvdXQgZm9yIGFuIEF1dGhvcml6ZWQgb2JqZWN0XG4gKi9cbmNvbnN0IGF1dGhvcml6ZWQgPSAocHJvcGVydHkgPSAnYXV0aG9yaXplZCcpID0+IHtcbiAgcmV0dXJuIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnN0cnVjdChbcHVibGljS2V5KCdzdGFrZXInKSwgcHVibGljS2V5KCd3aXRoZHJhd2VyJyldLCBwcm9wZXJ0eSk7XG59O1xuXG4vKipcbiAqIExheW91dCBmb3IgYSBMb2NrdXAgb2JqZWN0XG4gKi9cbmNvbnN0IGxvY2t1cCA9IChwcm9wZXJ0eSA9ICdsb2NrdXAnKSA9PiB7XG4gIHJldHVybiBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5zdHJ1Y3QoW0J1ZmZlckxheW91dF9fbmFtZXNwYWNlLm5zNjQoJ3VuaXhUaW1lc3RhbXAnKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UubnM2NCgnZXBvY2gnKSwgcHVibGljS2V5KCdjdXN0b2RpYW4nKV0sIHByb3BlcnR5KTtcbn07XG5cbi8qKlxuICogIExheW91dCBmb3IgYSBWb3RlSW5pdCBvYmplY3RcbiAqL1xuY29uc3Qgdm90ZUluaXQgPSAocHJvcGVydHkgPSAndm90ZUluaXQnKSA9PiB7XG4gIHJldHVybiBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5zdHJ1Y3QoW3B1YmxpY0tleSgnbm9kZVB1YmtleScpLCBwdWJsaWNLZXkoJ2F1dGhvcml6ZWRWb3RlcicpLCBwdWJsaWNLZXkoJ2F1dGhvcml6ZWRXaXRoZHJhd2VyJyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnU4KCdjb21taXNzaW9uJyldLCBwcm9wZXJ0eSk7XG59O1xuXG4vKipcbiAqICBMYXlvdXQgZm9yIGEgVm90ZUF1dGhvcml6ZVdpdGhTZWVkQXJncyBvYmplY3RcbiAqL1xuY29uc3Qgdm90ZUF1dGhvcml6ZVdpdGhTZWVkQXJncyA9IChwcm9wZXJ0eSA9ICd2b3RlQXV0aG9yaXplV2l0aFNlZWRBcmdzJykgPT4ge1xuICByZXR1cm4gQnVmZmVyTGF5b3V0X19uYW1lc3BhY2Uuc3RydWN0KFtCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51MzIoJ3ZvdGVBdXRob3JpemF0aW9uVHlwZScpLCBwdWJsaWNLZXkoJ2N1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5T3duZXJQdWJrZXknKSwgcnVzdFN0cmluZygnY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlTZWVkJyksIHB1YmxpY0tleSgnbmV3QXV0aG9yaXplZCcpXSwgcHJvcGVydHkpO1xufTtcbmZ1bmN0aW9uIGdldEFsbG9jKHR5cGUsIGZpZWxkcykge1xuICBjb25zdCBnZXRJdGVtQWxsb2MgPSBpdGVtID0+IHtcbiAgICBpZiAoaXRlbS5zcGFuID49IDApIHtcbiAgICAgIHJldHVybiBpdGVtLnNwYW47XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgaXRlbS5hbGxvYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGl0ZW0uYWxsb2MoZmllbGRzW2l0ZW0ucHJvcGVydHldKTtcbiAgICB9IGVsc2UgaWYgKCdjb3VudCcgaW4gaXRlbSAmJiAnZWxlbWVudExheW91dCcgaW4gaXRlbSkge1xuICAgICAgY29uc3QgZmllbGQgPSBmaWVsZHNbaXRlbS5wcm9wZXJ0eV07XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShmaWVsZCkpIHtcbiAgICAgICAgcmV0dXJuIGZpZWxkLmxlbmd0aCAqIGdldEl0ZW1BbGxvYyhpdGVtLmVsZW1lbnRMYXlvdXQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoJ2ZpZWxkcycgaW4gaXRlbSkge1xuICAgICAgLy8gVGhpcyBpcyBhIGBTdHJ1Y3R1cmVgIHdob3NlIHNpemUgbmVlZHMgdG8gYmUgcmVjdXJzaXZlbHkgbWVhc3VyZWQuXG4gICAgICByZXR1cm4gZ2V0QWxsb2Moe1xuICAgICAgICBsYXlvdXQ6IGl0ZW1cbiAgICAgIH0sIGZpZWxkc1tpdGVtLnByb3BlcnR5XSk7XG4gICAgfVxuICAgIC8vIENvdWxkbid0IGRldGVybWluZSBhbGxvY2F0ZWQgc2l6ZSBvZiBsYXlvdXRcbiAgICByZXR1cm4gMDtcbiAgfTtcbiAgbGV0IGFsbG9jID0gMDtcbiAgdHlwZS5sYXlvdXQuZmllbGRzLmZvckVhY2goaXRlbSA9PiB7XG4gICAgYWxsb2MgKz0gZ2V0SXRlbUFsbG9jKGl0ZW0pO1xuICB9KTtcbiAgcmV0dXJuIGFsbG9jO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVMZW5ndGgoYnl0ZXMpIHtcbiAgbGV0IGxlbiA9IDA7XG4gIGxldCBzaXplID0gMDtcbiAgZm9yICg7Oykge1xuICAgIGxldCBlbGVtID0gYnl0ZXMuc2hpZnQoKTtcbiAgICBsZW4gfD0gKGVsZW0gJiAweDdmKSA8PCBzaXplICogNztcbiAgICBzaXplICs9IDE7XG4gICAgaWYgKChlbGVtICYgMHg4MCkgPT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbGVuO1xufVxuZnVuY3Rpb24gZW5jb2RlTGVuZ3RoKGJ5dGVzLCBsZW4pIHtcbiAgbGV0IHJlbV9sZW4gPSBsZW47XG4gIGZvciAoOzspIHtcbiAgICBsZXQgZWxlbSA9IHJlbV9sZW4gJiAweDdmO1xuICAgIHJlbV9sZW4gPj49IDc7XG4gICAgaWYgKHJlbV9sZW4gPT0gMCkge1xuICAgICAgYnl0ZXMucHVzaChlbGVtKTtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtIHw9IDB4ODA7XG4gICAgICBieXRlcy5wdXNoKGVsZW0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnQgKGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlIHx8ICdBc3NlcnRpb24gZmFpbGVkJyk7XG4gIH1cbn1cblxuY2xhc3MgQ29tcGlsZWRLZXlzIHtcbiAgY29uc3RydWN0b3IocGF5ZXIsIGtleU1ldGFNYXApIHtcbiAgICB0aGlzLnBheWVyID0gdm9pZCAwO1xuICAgIHRoaXMua2V5TWV0YU1hcCA9IHZvaWQgMDtcbiAgICB0aGlzLnBheWVyID0gcGF5ZXI7XG4gICAgdGhpcy5rZXlNZXRhTWFwID0ga2V5TWV0YU1hcDtcbiAgfVxuICBzdGF0aWMgY29tcGlsZShpbnN0cnVjdGlvbnMsIHBheWVyKSB7XG4gICAgY29uc3Qga2V5TWV0YU1hcCA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBnZXRPckluc2VydERlZmF1bHQgPSBwdWJrZXkgPT4ge1xuICAgICAgY29uc3QgYWRkcmVzcyA9IHB1YmtleS50b0Jhc2U1OCgpO1xuICAgICAgbGV0IGtleU1ldGEgPSBrZXlNZXRhTWFwLmdldChhZGRyZXNzKTtcbiAgICAgIGlmIChrZXlNZXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAga2V5TWV0YSA9IHtcbiAgICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgICAgaXNXcml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgaXNJbnZva2VkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICBrZXlNZXRhTWFwLnNldChhZGRyZXNzLCBrZXlNZXRhKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBrZXlNZXRhO1xuICAgIH07XG4gICAgY29uc3QgcGF5ZXJLZXlNZXRhID0gZ2V0T3JJbnNlcnREZWZhdWx0KHBheWVyKTtcbiAgICBwYXllcktleU1ldGEuaXNTaWduZXIgPSB0cnVlO1xuICAgIHBheWVyS2V5TWV0YS5pc1dyaXRhYmxlID0gdHJ1ZTtcbiAgICBmb3IgKGNvbnN0IGl4IG9mIGluc3RydWN0aW9ucykge1xuICAgICAgZ2V0T3JJbnNlcnREZWZhdWx0KGl4LnByb2dyYW1JZCkuaXNJbnZva2VkID0gdHJ1ZTtcbiAgICAgIGZvciAoY29uc3QgYWNjb3VudE1ldGEgb2YgaXgua2V5cykge1xuICAgICAgICBjb25zdCBrZXlNZXRhID0gZ2V0T3JJbnNlcnREZWZhdWx0KGFjY291bnRNZXRhLnB1YmtleSk7XG4gICAgICAgIGtleU1ldGEuaXNTaWduZXIgfHw9IGFjY291bnRNZXRhLmlzU2lnbmVyO1xuICAgICAgICBrZXlNZXRhLmlzV3JpdGFibGUgfHw9IGFjY291bnRNZXRhLmlzV3JpdGFibGU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgQ29tcGlsZWRLZXlzKHBheWVyLCBrZXlNZXRhTWFwKTtcbiAgfVxuICBnZXRNZXNzYWdlQ29tcG9uZW50cygpIHtcbiAgICBjb25zdCBtYXBFbnRyaWVzID0gWy4uLnRoaXMua2V5TWV0YU1hcC5lbnRyaWVzKCldO1xuICAgIGFzc2VydChtYXBFbnRyaWVzLmxlbmd0aCA8PSAyNTYsICdNYXggc3RhdGljIGFjY291bnQga2V5cyBsZW5ndGggZXhjZWVkZWQnKTtcbiAgICBjb25zdCB3cml0YWJsZVNpZ25lcnMgPSBtYXBFbnRyaWVzLmZpbHRlcigoWywgbWV0YV0pID0+IG1ldGEuaXNTaWduZXIgJiYgbWV0YS5pc1dyaXRhYmxlKTtcbiAgICBjb25zdCByZWFkb25seVNpZ25lcnMgPSBtYXBFbnRyaWVzLmZpbHRlcigoWywgbWV0YV0pID0+IG1ldGEuaXNTaWduZXIgJiYgIW1ldGEuaXNXcml0YWJsZSk7XG4gICAgY29uc3Qgd3JpdGFibGVOb25TaWduZXJzID0gbWFwRW50cmllcy5maWx0ZXIoKFssIG1ldGFdKSA9PiAhbWV0YS5pc1NpZ25lciAmJiBtZXRhLmlzV3JpdGFibGUpO1xuICAgIGNvbnN0IHJlYWRvbmx5Tm9uU2lnbmVycyA9IG1hcEVudHJpZXMuZmlsdGVyKChbLCBtZXRhXSkgPT4gIW1ldGEuaXNTaWduZXIgJiYgIW1ldGEuaXNXcml0YWJsZSk7XG4gICAgY29uc3QgaGVhZGVyID0ge1xuICAgICAgbnVtUmVxdWlyZWRTaWduYXR1cmVzOiB3cml0YWJsZVNpZ25lcnMubGVuZ3RoICsgcmVhZG9ubHlTaWduZXJzLmxlbmd0aCxcbiAgICAgIG51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHM6IHJlYWRvbmx5U2lnbmVycy5sZW5ndGgsXG4gICAgICBudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHM6IHJlYWRvbmx5Tm9uU2lnbmVycy5sZW5ndGhcbiAgICB9O1xuXG4gICAgLy8gc2FuaXR5IGNoZWNrc1xuICAgIHtcbiAgICAgIGFzc2VydCh3cml0YWJsZVNpZ25lcnMubGVuZ3RoID4gMCwgJ0V4cGVjdGVkIGF0IGxlYXN0IG9uZSB3cml0YWJsZSBzaWduZXIga2V5Jyk7XG4gICAgICBjb25zdCBbcGF5ZXJBZGRyZXNzXSA9IHdyaXRhYmxlU2lnbmVyc1swXTtcbiAgICAgIGFzc2VydChwYXllckFkZHJlc3MgPT09IHRoaXMucGF5ZXIudG9CYXNlNTgoKSwgJ0V4cGVjdGVkIGZpcnN0IHdyaXRhYmxlIHNpZ25lciBrZXkgdG8gYmUgdGhlIGZlZSBwYXllcicpO1xuICAgIH1cbiAgICBjb25zdCBzdGF0aWNBY2NvdW50S2V5cyA9IFsuLi53cml0YWJsZVNpZ25lcnMubWFwKChbYWRkcmVzc10pID0+IG5ldyBQdWJsaWNLZXkoYWRkcmVzcykpLCAuLi5yZWFkb25seVNpZ25lcnMubWFwKChbYWRkcmVzc10pID0+IG5ldyBQdWJsaWNLZXkoYWRkcmVzcykpLCAuLi53cml0YWJsZU5vblNpZ25lcnMubWFwKChbYWRkcmVzc10pID0+IG5ldyBQdWJsaWNLZXkoYWRkcmVzcykpLCAuLi5yZWFkb25seU5vblNpZ25lcnMubWFwKChbYWRkcmVzc10pID0+IG5ldyBQdWJsaWNLZXkoYWRkcmVzcykpXTtcbiAgICByZXR1cm4gW2hlYWRlciwgc3RhdGljQWNjb3VudEtleXNdO1xuICB9XG4gIGV4dHJhY3RUYWJsZUxvb2t1cChsb29rdXBUYWJsZSkge1xuICAgIGNvbnN0IFt3cml0YWJsZUluZGV4ZXMsIGRyYWluZWRXcml0YWJsZUtleXNdID0gdGhpcy5kcmFpbktleXNGb3VuZEluTG9va3VwVGFibGUobG9va3VwVGFibGUuc3RhdGUuYWRkcmVzc2VzLCBrZXlNZXRhID0+ICFrZXlNZXRhLmlzU2lnbmVyICYmICFrZXlNZXRhLmlzSW52b2tlZCAmJiBrZXlNZXRhLmlzV3JpdGFibGUpO1xuICAgIGNvbnN0IFtyZWFkb25seUluZGV4ZXMsIGRyYWluZWRSZWFkb25seUtleXNdID0gdGhpcy5kcmFpbktleXNGb3VuZEluTG9va3VwVGFibGUobG9va3VwVGFibGUuc3RhdGUuYWRkcmVzc2VzLCBrZXlNZXRhID0+ICFrZXlNZXRhLmlzU2lnbmVyICYmICFrZXlNZXRhLmlzSW52b2tlZCAmJiAha2V5TWV0YS5pc1dyaXRhYmxlKTtcblxuICAgIC8vIERvbid0IGV4dHJhY3QgbG9va3VwIGlmIG5vIGtleXMgd2VyZSBmb3VuZFxuICAgIGlmICh3cml0YWJsZUluZGV4ZXMubGVuZ3RoID09PSAwICYmIHJlYWRvbmx5SW5kZXhlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIFt7XG4gICAgICBhY2NvdW50S2V5OiBsb29rdXBUYWJsZS5rZXksXG4gICAgICB3cml0YWJsZUluZGV4ZXMsXG4gICAgICByZWFkb25seUluZGV4ZXNcbiAgICB9LCB7XG4gICAgICB3cml0YWJsZTogZHJhaW5lZFdyaXRhYmxlS2V5cyxcbiAgICAgIHJlYWRvbmx5OiBkcmFpbmVkUmVhZG9ubHlLZXlzXG4gICAgfV07XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIGRyYWluS2V5c0ZvdW5kSW5Mb29rdXBUYWJsZShsb29rdXBUYWJsZUVudHJpZXMsIGtleU1ldGFGaWx0ZXIpIHtcbiAgICBjb25zdCBsb29rdXBUYWJsZUluZGV4ZXMgPSBuZXcgQXJyYXkoKTtcbiAgICBjb25zdCBkcmFpbmVkS2V5cyA9IG5ldyBBcnJheSgpO1xuICAgIGZvciAoY29uc3QgW2FkZHJlc3MsIGtleU1ldGFdIG9mIHRoaXMua2V5TWV0YU1hcC5lbnRyaWVzKCkpIHtcbiAgICAgIGlmIChrZXlNZXRhRmlsdGVyKGtleU1ldGEpKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IG5ldyBQdWJsaWNLZXkoYWRkcmVzcyk7XG4gICAgICAgIGNvbnN0IGxvb2t1cFRhYmxlSW5kZXggPSBsb29rdXBUYWJsZUVudHJpZXMuZmluZEluZGV4KGVudHJ5ID0+IGVudHJ5LmVxdWFscyhrZXkpKTtcbiAgICAgICAgaWYgKGxvb2t1cFRhYmxlSW5kZXggPj0gMCkge1xuICAgICAgICAgIGFzc2VydChsb29rdXBUYWJsZUluZGV4IDwgMjU2LCAnTWF4IGxvb2t1cCB0YWJsZSBpbmRleCBleGNlZWRlZCcpO1xuICAgICAgICAgIGxvb2t1cFRhYmxlSW5kZXhlcy5wdXNoKGxvb2t1cFRhYmxlSW5kZXgpO1xuICAgICAgICAgIGRyYWluZWRLZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICB0aGlzLmtleU1ldGFNYXAuZGVsZXRlKGFkZHJlc3MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbbG9va3VwVGFibGVJbmRleGVzLCBkcmFpbmVkS2V5c107XG4gIH1cbn1cblxuY29uc3QgRU5EX09GX0JVRkZFUl9FUlJPUl9NRVNTQUdFID0gJ1JlYWNoZWQgZW5kIG9mIGJ1ZmZlciB1bmV4cGVjdGVkbHknO1xuXG4vKipcbiAqIERlbGVnYXRlcyB0byBgQXJyYXkjc2hpZnRgLCBidXQgdGhyb3dzIGlmIHRoZSBhcnJheSBpcyB6ZXJvLWxlbmd0aC5cbiAqL1xuZnVuY3Rpb24gZ3VhcmRlZFNoaWZ0KGJ5dGVBcnJheSkge1xuICBpZiAoYnl0ZUFycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihFTkRfT0ZfQlVGRkVSX0VSUk9SX01FU1NBR0UpO1xuICB9XG4gIHJldHVybiBieXRlQXJyYXkuc2hpZnQoKTtcbn1cblxuLyoqXG4gKiBEZWxlZ2F0ZXMgdG8gYEFycmF5I3NwbGljZWAsIGJ1dCB0aHJvd3MgaWYgdGhlIHNlY3Rpb24gYmVpbmcgc3BsaWNlZCBvdXQgZXh0ZW5kcyBwYXN0IHRoZSBlbmQgb2ZcbiAqIHRoZSBhcnJheS5cbiAqL1xuZnVuY3Rpb24gZ3VhcmRlZFNwbGljZShieXRlQXJyYXksIC4uLmFyZ3MpIHtcbiAgY29uc3QgW3N0YXJ0XSA9IGFyZ3M7XG4gIGlmIChhcmdzLmxlbmd0aCA9PT0gMiAvLyBJbXBsaWVzIHRoYXQgYGRlbGV0ZUNvdW50YCB3YXMgc3VwcGxpZWRcbiAgPyBzdGFydCArIChhcmdzWzFdID8/IDApID4gYnl0ZUFycmF5Lmxlbmd0aCA6IHN0YXJ0ID49IGJ5dGVBcnJheS5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoRU5EX09GX0JVRkZFUl9FUlJPUl9NRVNTQUdFKTtcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5LnNwbGljZSguLi5hcmdzKTtcbn1cblxuLyoqXG4gKiBBbiBpbnN0cnVjdGlvbiB0byBleGVjdXRlIGJ5IGEgcHJvZ3JhbVxuICpcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwcm9ncmFtSWRJbmRleFxuICogQHByb3BlcnR5IHtudW1iZXJbXX0gYWNjb3VudHNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBkYXRhXG4gKi9cblxuLyoqXG4gKiBNZXNzYWdlIGNvbnN0cnVjdG9yIGFyZ3VtZW50c1xuICovXG5cbi8qKlxuICogTGlzdCBvZiBpbnN0cnVjdGlvbnMgdG8gYmUgcHJvY2Vzc2VkIGF0b21pY2FsbHlcbiAqL1xuY2xhc3MgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICB0aGlzLmhlYWRlciA9IHZvaWQgMDtcbiAgICB0aGlzLmFjY291bnRLZXlzID0gdm9pZCAwO1xuICAgIHRoaXMucmVjZW50QmxvY2toYXNoID0gdm9pZCAwO1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zID0gdm9pZCAwO1xuICAgIHRoaXMuaW5kZXhUb1Byb2dyYW1JZHMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5oZWFkZXIgPSBhcmdzLmhlYWRlcjtcbiAgICB0aGlzLmFjY291bnRLZXlzID0gYXJncy5hY2NvdW50S2V5cy5tYXAoYWNjb3VudCA9PiBuZXcgUHVibGljS2V5KGFjY291bnQpKTtcbiAgICB0aGlzLnJlY2VudEJsb2NraGFzaCA9IGFyZ3MucmVjZW50QmxvY2toYXNoO1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zID0gYXJncy5pbnN0cnVjdGlvbnM7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMuZm9yRWFjaChpeCA9PiB0aGlzLmluZGV4VG9Qcm9ncmFtSWRzLnNldChpeC5wcm9ncmFtSWRJbmRleCwgdGhpcy5hY2NvdW50S2V5c1tpeC5wcm9ncmFtSWRJbmRleF0pKTtcbiAgfVxuICBnZXQgdmVyc2lvbigpIHtcbiAgICByZXR1cm4gJ2xlZ2FjeSc7XG4gIH1cbiAgZ2V0IHN0YXRpY0FjY291bnRLZXlzKCkge1xuICAgIHJldHVybiB0aGlzLmFjY291bnRLZXlzO1xuICB9XG4gIGdldCBjb21waWxlZEluc3RydWN0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5pbnN0cnVjdGlvbnMubWFwKGl4ID0+ICh7XG4gICAgICBwcm9ncmFtSWRJbmRleDogaXgucHJvZ3JhbUlkSW5kZXgsXG4gICAgICBhY2NvdW50S2V5SW5kZXhlczogaXguYWNjb3VudHMsXG4gICAgICBkYXRhOiBiczU4X19kZWZhdWx0LmRlZmF1bHQuZGVjb2RlKGl4LmRhdGEpXG4gICAgfSkpO1xuICB9XG4gIGdldCBhZGRyZXNzVGFibGVMb29rdXBzKCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBnZXRBY2NvdW50S2V5cygpIHtcbiAgICByZXR1cm4gbmV3IE1lc3NhZ2VBY2NvdW50S2V5cyh0aGlzLnN0YXRpY0FjY291bnRLZXlzKTtcbiAgfVxuICBzdGF0aWMgY29tcGlsZShhcmdzKSB7XG4gICAgY29uc3QgY29tcGlsZWRLZXlzID0gQ29tcGlsZWRLZXlzLmNvbXBpbGUoYXJncy5pbnN0cnVjdGlvbnMsIGFyZ3MucGF5ZXJLZXkpO1xuICAgIGNvbnN0IFtoZWFkZXIsIHN0YXRpY0FjY291bnRLZXlzXSA9IGNvbXBpbGVkS2V5cy5nZXRNZXNzYWdlQ29tcG9uZW50cygpO1xuICAgIGNvbnN0IGFjY291bnRLZXlzID0gbmV3IE1lc3NhZ2VBY2NvdW50S2V5cyhzdGF0aWNBY2NvdW50S2V5cyk7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25zID0gYWNjb3VudEtleXMuY29tcGlsZUluc3RydWN0aW9ucyhhcmdzLmluc3RydWN0aW9ucykubWFwKGl4ID0+ICh7XG4gICAgICBwcm9ncmFtSWRJbmRleDogaXgucHJvZ3JhbUlkSW5kZXgsXG4gICAgICBhY2NvdW50czogaXguYWNjb3VudEtleUluZGV4ZXMsXG4gICAgICBkYXRhOiBiczU4X19kZWZhdWx0LmRlZmF1bHQuZW5jb2RlKGl4LmRhdGEpXG4gICAgfSkpO1xuICAgIHJldHVybiBuZXcgTWVzc2FnZSh7XG4gICAgICBoZWFkZXIsXG4gICAgICBhY2NvdW50S2V5czogc3RhdGljQWNjb3VudEtleXMsXG4gICAgICByZWNlbnRCbG9ja2hhc2g6IGFyZ3MucmVjZW50QmxvY2toYXNoLFxuICAgICAgaW5zdHJ1Y3Rpb25zXG4gICAgfSk7XG4gIH1cbiAgaXNBY2NvdW50U2lnbmVyKGluZGV4KSB7XG4gICAgcmV0dXJuIGluZGV4IDwgdGhpcy5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzO1xuICB9XG4gIGlzQWNjb3VudFdyaXRhYmxlKGluZGV4KSB7XG4gICAgY29uc3QgbnVtU2lnbmVkQWNjb3VudHMgPSB0aGlzLmhlYWRlci5udW1SZXF1aXJlZFNpZ25hdHVyZXM7XG4gICAgaWYgKGluZGV4ID49IHRoaXMuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcykge1xuICAgICAgY29uc3QgdW5zaWduZWRBY2NvdW50SW5kZXggPSBpbmRleCAtIG51bVNpZ25lZEFjY291bnRzO1xuICAgICAgY29uc3QgbnVtVW5zaWduZWRBY2NvdW50cyA9IHRoaXMuYWNjb3VudEtleXMubGVuZ3RoIC0gbnVtU2lnbmVkQWNjb3VudHM7XG4gICAgICBjb25zdCBudW1Xcml0YWJsZVVuc2lnbmVkQWNjb3VudHMgPSBudW1VbnNpZ25lZEFjY291bnRzIC0gdGhpcy5oZWFkZXIubnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzO1xuICAgICAgcmV0dXJuIHVuc2lnbmVkQWNjb3VudEluZGV4IDwgbnVtV3JpdGFibGVVbnNpZ25lZEFjY291bnRzO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBudW1Xcml0YWJsZVNpZ25lZEFjY291bnRzID0gbnVtU2lnbmVkQWNjb3VudHMgLSB0aGlzLmhlYWRlci5udW1SZWFkb25seVNpZ25lZEFjY291bnRzO1xuICAgICAgcmV0dXJuIGluZGV4IDwgbnVtV3JpdGFibGVTaWduZWRBY2NvdW50cztcbiAgICB9XG4gIH1cbiAgaXNQcm9ncmFtSWQoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5pbmRleFRvUHJvZ3JhbUlkcy5oYXMoaW5kZXgpO1xuICB9XG4gIHByb2dyYW1JZHMoKSB7XG4gICAgcmV0dXJuIFsuLi50aGlzLmluZGV4VG9Qcm9ncmFtSWRzLnZhbHVlcygpXTtcbiAgfVxuICBub25Qcm9ncmFtSWRzKCkge1xuICAgIHJldHVybiB0aGlzLmFjY291bnRLZXlzLmZpbHRlcigoXywgaW5kZXgpID0+ICF0aGlzLmlzUHJvZ3JhbUlkKGluZGV4KSk7XG4gIH1cbiAgc2VyaWFsaXplKCkge1xuICAgIGNvbnN0IG51bUtleXMgPSB0aGlzLmFjY291bnRLZXlzLmxlbmd0aDtcbiAgICBsZXQga2V5Q291bnQgPSBbXTtcbiAgICBlbmNvZGVMZW5ndGgoa2V5Q291bnQsIG51bUtleXMpO1xuICAgIGNvbnN0IGluc3RydWN0aW9ucyA9IHRoaXMuaW5zdHJ1Y3Rpb25zLm1hcChpbnN0cnVjdGlvbiA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFjY291bnRzLFxuICAgICAgICBwcm9ncmFtSWRJbmRleFxuICAgICAgfSA9IGluc3RydWN0aW9uO1xuICAgICAgY29uc3QgZGF0YSA9IEFycmF5LmZyb20oYnM1OF9fZGVmYXVsdC5kZWZhdWx0LmRlY29kZShpbnN0cnVjdGlvbi5kYXRhKSk7XG4gICAgICBsZXQga2V5SW5kaWNlc0NvdW50ID0gW107XG4gICAgICBlbmNvZGVMZW5ndGgoa2V5SW5kaWNlc0NvdW50LCBhY2NvdW50cy5sZW5ndGgpO1xuICAgICAgbGV0IGRhdGFDb3VudCA9IFtdO1xuICAgICAgZW5jb2RlTGVuZ3RoKGRhdGFDb3VudCwgZGF0YS5sZW5ndGgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHJvZ3JhbUlkSW5kZXgsXG4gICAgICAgIGtleUluZGljZXNDb3VudDogYnVmZmVyLkJ1ZmZlci5mcm9tKGtleUluZGljZXNDb3VudCksXG4gICAgICAgIGtleUluZGljZXM6IGFjY291bnRzLFxuICAgICAgICBkYXRhTGVuZ3RoOiBidWZmZXIuQnVmZmVyLmZyb20oZGF0YUNvdW50KSxcbiAgICAgICAgZGF0YVxuICAgICAgfTtcbiAgICB9KTtcbiAgICBsZXQgaW5zdHJ1Y3Rpb25Db3VudCA9IFtdO1xuICAgIGVuY29kZUxlbmd0aChpbnN0cnVjdGlvbkNvdW50LCBpbnN0cnVjdGlvbnMubGVuZ3RoKTtcbiAgICBsZXQgaW5zdHJ1Y3Rpb25CdWZmZXIgPSBidWZmZXIuQnVmZmVyLmFsbG9jKFBBQ0tFVF9EQVRBX1NJWkUpO1xuICAgIGJ1ZmZlci5CdWZmZXIuZnJvbShpbnN0cnVjdGlvbkNvdW50KS5jb3B5KGluc3RydWN0aW9uQnVmZmVyKTtcbiAgICBsZXQgaW5zdHJ1Y3Rpb25CdWZmZXJMZW5ndGggPSBpbnN0cnVjdGlvbkNvdW50Lmxlbmd0aDtcbiAgICBpbnN0cnVjdGlvbnMuZm9yRWFjaChpbnN0cnVjdGlvbiA9PiB7XG4gICAgICBjb25zdCBpbnN0cnVjdGlvbkxheW91dCA9IEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnN0cnVjdChbQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTgoJ3Byb2dyYW1JZEluZGV4JyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLmJsb2IoaW5zdHJ1Y3Rpb24ua2V5SW5kaWNlc0NvdW50Lmxlbmd0aCwgJ2tleUluZGljZXNDb3VudCcpLCBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5zZXEoQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTgoJ2tleUluZGV4JyksIGluc3RydWN0aW9uLmtleUluZGljZXMubGVuZ3RoLCAna2V5SW5kaWNlcycpLCBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5ibG9iKGluc3RydWN0aW9uLmRhdGFMZW5ndGgubGVuZ3RoLCAnZGF0YUxlbmd0aCcpLCBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5zZXEoQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTgoJ3VzZXJkYXR1bScpLCBpbnN0cnVjdGlvbi5kYXRhLmxlbmd0aCwgJ2RhdGEnKV0pO1xuICAgICAgY29uc3QgbGVuZ3RoID0gaW5zdHJ1Y3Rpb25MYXlvdXQuZW5jb2RlKGluc3RydWN0aW9uLCBpbnN0cnVjdGlvbkJ1ZmZlciwgaW5zdHJ1Y3Rpb25CdWZmZXJMZW5ndGgpO1xuICAgICAgaW5zdHJ1Y3Rpb25CdWZmZXJMZW5ndGggKz0gbGVuZ3RoO1xuICAgIH0pO1xuICAgIGluc3RydWN0aW9uQnVmZmVyID0gaW5zdHJ1Y3Rpb25CdWZmZXIuc2xpY2UoMCwgaW5zdHJ1Y3Rpb25CdWZmZXJMZW5ndGgpO1xuICAgIGNvbnN0IHNpZ25EYXRhTGF5b3V0ID0gQnVmZmVyTGF5b3V0X19uYW1lc3BhY2Uuc3RydWN0KFtCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5ibG9iKDEsICdudW1SZXF1aXJlZFNpZ25hdHVyZXMnKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UuYmxvYigxLCAnbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50cycpLCBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5ibG9iKDEsICdudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHMnKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UuYmxvYihrZXlDb3VudC5sZW5ndGgsICdrZXlDb3VudCcpLCBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5zZXEocHVibGljS2V5KCdrZXknKSwgbnVtS2V5cywgJ2tleXMnKSwgcHVibGljS2V5KCdyZWNlbnRCbG9ja2hhc2gnKV0pO1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0ge1xuICAgICAgbnVtUmVxdWlyZWRTaWduYXR1cmVzOiBidWZmZXIuQnVmZmVyLmZyb20oW3RoaXMuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlc10pLFxuICAgICAgbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50czogYnVmZmVyLkJ1ZmZlci5mcm9tKFt0aGlzLmhlYWRlci5udW1SZWFkb25seVNpZ25lZEFjY291bnRzXSksXG4gICAgICBudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHM6IGJ1ZmZlci5CdWZmZXIuZnJvbShbdGhpcy5oZWFkZXIubnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzXSksXG4gICAgICBrZXlDb3VudDogYnVmZmVyLkJ1ZmZlci5mcm9tKGtleUNvdW50KSxcbiAgICAgIGtleXM6IHRoaXMuYWNjb3VudEtleXMubWFwKGtleSA9PiB0b0J1ZmZlcihrZXkudG9CeXRlcygpKSksXG4gICAgICByZWNlbnRCbG9ja2hhc2g6IGJzNThfX2RlZmF1bHQuZGVmYXVsdC5kZWNvZGUodGhpcy5yZWNlbnRCbG9ja2hhc2gpXG4gICAgfTtcbiAgICBsZXQgc2lnbkRhdGEgPSBidWZmZXIuQnVmZmVyLmFsbG9jKDIwNDgpO1xuICAgIGNvbnN0IGxlbmd0aCA9IHNpZ25EYXRhTGF5b3V0LmVuY29kZSh0cmFuc2FjdGlvbiwgc2lnbkRhdGEpO1xuICAgIGluc3RydWN0aW9uQnVmZmVyLmNvcHkoc2lnbkRhdGEsIGxlbmd0aCk7XG4gICAgcmV0dXJuIHNpZ25EYXRhLnNsaWNlKDAsIGxlbmd0aCArIGluc3RydWN0aW9uQnVmZmVyLmxlbmd0aCk7XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGEgY29tcGlsZWQgbWVzc2FnZSBpbnRvIGEgTWVzc2FnZSBvYmplY3QuXG4gICAqL1xuICBzdGF0aWMgZnJvbShidWZmZXIkMSkge1xuICAgIC8vIFNsaWNlIHVwIHdpcmUgZGF0YVxuICAgIGxldCBieXRlQXJyYXkgPSBbLi4uYnVmZmVyJDFdO1xuICAgIGNvbnN0IG51bVJlcXVpcmVkU2lnbmF0dXJlcyA9IGd1YXJkZWRTaGlmdChieXRlQXJyYXkpO1xuICAgIGlmIChudW1SZXF1aXJlZFNpZ25hdHVyZXMgIT09IChudW1SZXF1aXJlZFNpZ25hdHVyZXMgJiBWRVJTSU9OX1BSRUZJWF9NQVNLKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdWZXJzaW9uZWQgbWVzc2FnZXMgbXVzdCBiZSBkZXNlcmlhbGl6ZWQgd2l0aCBWZXJzaW9uZWRNZXNzYWdlLmRlc2VyaWFsaXplKCknKTtcbiAgICB9XG4gICAgY29uc3QgbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50cyA9IGd1YXJkZWRTaGlmdChieXRlQXJyYXkpO1xuICAgIGNvbnN0IG51bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50cyA9IGd1YXJkZWRTaGlmdChieXRlQXJyYXkpO1xuICAgIGNvbnN0IGFjY291bnRDb3VudCA9IGRlY29kZUxlbmd0aChieXRlQXJyYXkpO1xuICAgIGxldCBhY2NvdW50S2V5cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWNjb3VudENvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IGFjY291bnQgPSBndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgMCwgUFVCTElDX0tFWV9MRU5HVEgpO1xuICAgICAgYWNjb3VudEtleXMucHVzaChuZXcgUHVibGljS2V5KGJ1ZmZlci5CdWZmZXIuZnJvbShhY2NvdW50KSkpO1xuICAgIH1cbiAgICBjb25zdCByZWNlbnRCbG9ja2hhc2ggPSBndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgMCwgUFVCTElDX0tFWV9MRU5HVEgpO1xuICAgIGNvbnN0IGluc3RydWN0aW9uQ291bnQgPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICBsZXQgaW5zdHJ1Y3Rpb25zID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnN0cnVjdGlvbkNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHByb2dyYW1JZEluZGV4ID0gZ3VhcmRlZFNoaWZ0KGJ5dGVBcnJheSk7XG4gICAgICBjb25zdCBhY2NvdW50Q291bnQgPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICAgIGNvbnN0IGFjY291bnRzID0gZ3VhcmRlZFNwbGljZShieXRlQXJyYXksIDAsIGFjY291bnRDb3VudCk7XG4gICAgICBjb25zdCBkYXRhTGVuZ3RoID0gZGVjb2RlTGVuZ3RoKGJ5dGVBcnJheSk7XG4gICAgICBjb25zdCBkYXRhU2xpY2UgPSBndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgMCwgZGF0YUxlbmd0aCk7XG4gICAgICBjb25zdCBkYXRhID0gYnM1OF9fZGVmYXVsdC5kZWZhdWx0LmVuY29kZShidWZmZXIuQnVmZmVyLmZyb20oZGF0YVNsaWNlKSk7XG4gICAgICBpbnN0cnVjdGlvbnMucHVzaCh7XG4gICAgICAgIHByb2dyYW1JZEluZGV4LFxuICAgICAgICBhY2NvdW50cyxcbiAgICAgICAgZGF0YVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IG1lc3NhZ2VBcmdzID0ge1xuICAgICAgaGVhZGVyOiB7XG4gICAgICAgIG51bVJlcXVpcmVkU2lnbmF0dXJlcyxcbiAgICAgICAgbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50cyxcbiAgICAgICAgbnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzXG4gICAgICB9LFxuICAgICAgcmVjZW50QmxvY2toYXNoOiBiczU4X19kZWZhdWx0LmRlZmF1bHQuZW5jb2RlKGJ1ZmZlci5CdWZmZXIuZnJvbShyZWNlbnRCbG9ja2hhc2gpKSxcbiAgICAgIGFjY291bnRLZXlzLFxuICAgICAgaW5zdHJ1Y3Rpb25zXG4gICAgfTtcbiAgICByZXR1cm4gbmV3IE1lc3NhZ2UobWVzc2FnZUFyZ3MpO1xuICB9XG59XG5cbi8qKlxuICogTWVzc2FnZSBjb25zdHJ1Y3RvciBhcmd1bWVudHNcbiAqL1xuXG5jbGFzcyBNZXNzYWdlVjAge1xuICBjb25zdHJ1Y3RvcihhcmdzKSB7XG4gICAgdGhpcy5oZWFkZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5zdGF0aWNBY2NvdW50S2V5cyA9IHZvaWQgMDtcbiAgICB0aGlzLnJlY2VudEJsb2NraGFzaCA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbXBpbGVkSW5zdHJ1Y3Rpb25zID0gdm9pZCAwO1xuICAgIHRoaXMuYWRkcmVzc1RhYmxlTG9va3VwcyA9IHZvaWQgMDtcbiAgICB0aGlzLmhlYWRlciA9IGFyZ3MuaGVhZGVyO1xuICAgIHRoaXMuc3RhdGljQWNjb3VudEtleXMgPSBhcmdzLnN0YXRpY0FjY291bnRLZXlzO1xuICAgIHRoaXMucmVjZW50QmxvY2toYXNoID0gYXJncy5yZWNlbnRCbG9ja2hhc2g7XG4gICAgdGhpcy5jb21waWxlZEluc3RydWN0aW9ucyA9IGFyZ3MuY29tcGlsZWRJbnN0cnVjdGlvbnM7XG4gICAgdGhpcy5hZGRyZXNzVGFibGVMb29rdXBzID0gYXJncy5hZGRyZXNzVGFibGVMb29rdXBzO1xuICB9XG4gIGdldCB2ZXJzaW9uKCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGdldCBudW1BY2NvdW50S2V5c0Zyb21Mb29rdXBzKCkge1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgZm9yIChjb25zdCBsb29rdXAgb2YgdGhpcy5hZGRyZXNzVGFibGVMb29rdXBzKSB7XG4gICAgICBjb3VudCArPSBsb29rdXAucmVhZG9ubHlJbmRleGVzLmxlbmd0aCArIGxvb2t1cC53cml0YWJsZUluZGV4ZXMubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gY291bnQ7XG4gIH1cbiAgZ2V0QWNjb3VudEtleXMoYXJncykge1xuICAgIGxldCBhY2NvdW50S2V5c0Zyb21Mb29rdXBzO1xuICAgIGlmIChhcmdzICYmICdhY2NvdW50S2V5c0Zyb21Mb29rdXBzJyBpbiBhcmdzICYmIGFyZ3MuYWNjb3VudEtleXNGcm9tTG9va3Vwcykge1xuICAgICAgaWYgKHRoaXMubnVtQWNjb3VudEtleXNGcm9tTG9va3VwcyAhPSBhcmdzLmFjY291bnRLZXlzRnJvbUxvb2t1cHMud3JpdGFibGUubGVuZ3RoICsgYXJncy5hY2NvdW50S2V5c0Zyb21Mb29rdXBzLnJlYWRvbmx5Lmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBnZXQgYWNjb3VudCBrZXlzIGJlY2F1c2Ugb2YgYSBtaXNtYXRjaCBpbiB0aGUgbnVtYmVyIG9mIGFjY291bnQga2V5cyBmcm9tIGxvb2t1cHMnKTtcbiAgICAgIH1cbiAgICAgIGFjY291bnRLZXlzRnJvbUxvb2t1cHMgPSBhcmdzLmFjY291bnRLZXlzRnJvbUxvb2t1cHM7XG4gICAgfSBlbHNlIGlmIChhcmdzICYmICdhZGRyZXNzTG9va3VwVGFibGVBY2NvdW50cycgaW4gYXJncyAmJiBhcmdzLmFkZHJlc3NMb29rdXBUYWJsZUFjY291bnRzKSB7XG4gICAgICBhY2NvdW50S2V5c0Zyb21Mb29rdXBzID0gdGhpcy5yZXNvbHZlQWRkcmVzc1RhYmxlTG9va3VwcyhhcmdzLmFkZHJlc3NMb29rdXBUYWJsZUFjY291bnRzKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuYWRkcmVzc1RhYmxlTG9va3Vwcy5sZW5ndGggPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBnZXQgYWNjb3VudCBrZXlzIGJlY2F1c2UgYWRkcmVzcyB0YWJsZSBsb29rdXBzIHdlcmUgbm90IHJlc29sdmVkJyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTWVzc2FnZUFjY291bnRLZXlzKHRoaXMuc3RhdGljQWNjb3VudEtleXMsIGFjY291bnRLZXlzRnJvbUxvb2t1cHMpO1xuICB9XG4gIGlzQWNjb3VudFNpZ25lcihpbmRleCkge1xuICAgIHJldHVybiBpbmRleCA8IHRoaXMuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcztcbiAgfVxuICBpc0FjY291bnRXcml0YWJsZShpbmRleCkge1xuICAgIGNvbnN0IG51bVNpZ25lZEFjY291bnRzID0gdGhpcy5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzO1xuICAgIGNvbnN0IG51bVN0YXRpY0FjY291bnRLZXlzID0gdGhpcy5zdGF0aWNBY2NvdW50S2V5cy5sZW5ndGg7XG4gICAgaWYgKGluZGV4ID49IG51bVN0YXRpY0FjY291bnRLZXlzKSB7XG4gICAgICBjb25zdCBsb29rdXBBY2NvdW50S2V5c0luZGV4ID0gaW5kZXggLSBudW1TdGF0aWNBY2NvdW50S2V5cztcbiAgICAgIGNvbnN0IG51bVdyaXRhYmxlTG9va3VwQWNjb3VudEtleXMgPSB0aGlzLmFkZHJlc3NUYWJsZUxvb2t1cHMucmVkdWNlKChjb3VudCwgbG9va3VwKSA9PiBjb3VudCArIGxvb2t1cC53cml0YWJsZUluZGV4ZXMubGVuZ3RoLCAwKTtcbiAgICAgIHJldHVybiBsb29rdXBBY2NvdW50S2V5c0luZGV4IDwgbnVtV3JpdGFibGVMb29rdXBBY2NvdW50S2V5cztcbiAgICB9IGVsc2UgaWYgKGluZGV4ID49IHRoaXMuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcykge1xuICAgICAgY29uc3QgdW5zaWduZWRBY2NvdW50SW5kZXggPSBpbmRleCAtIG51bVNpZ25lZEFjY291bnRzO1xuICAgICAgY29uc3QgbnVtVW5zaWduZWRBY2NvdW50cyA9IG51bVN0YXRpY0FjY291bnRLZXlzIC0gbnVtU2lnbmVkQWNjb3VudHM7XG4gICAgICBjb25zdCBudW1Xcml0YWJsZVVuc2lnbmVkQWNjb3VudHMgPSBudW1VbnNpZ25lZEFjY291bnRzIC0gdGhpcy5oZWFkZXIubnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzO1xuICAgICAgcmV0dXJuIHVuc2lnbmVkQWNjb3VudEluZGV4IDwgbnVtV3JpdGFibGVVbnNpZ25lZEFjY291bnRzO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBudW1Xcml0YWJsZVNpZ25lZEFjY291bnRzID0gbnVtU2lnbmVkQWNjb3VudHMgLSB0aGlzLmhlYWRlci5udW1SZWFkb25seVNpZ25lZEFjY291bnRzO1xuICAgICAgcmV0dXJuIGluZGV4IDwgbnVtV3JpdGFibGVTaWduZWRBY2NvdW50cztcbiAgICB9XG4gIH1cbiAgcmVzb2x2ZUFkZHJlc3NUYWJsZUxvb2t1cHMoYWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudHMpIHtcbiAgICBjb25zdCBhY2NvdW50S2V5c0Zyb21Mb29rdXBzID0ge1xuICAgICAgd3JpdGFibGU6IFtdLFxuICAgICAgcmVhZG9ubHk6IFtdXG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IHRhYmxlTG9va3VwIG9mIHRoaXMuYWRkcmVzc1RhYmxlTG9va3Vwcykge1xuICAgICAgY29uc3QgdGFibGVBY2NvdW50ID0gYWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudHMuZmluZChhY2NvdW50ID0+IGFjY291bnQua2V5LmVxdWFscyh0YWJsZUxvb2t1cC5hY2NvdW50S2V5KSk7XG4gICAgICBpZiAoIXRhYmxlQWNjb3VudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmaW5kIGFkZHJlc3MgbG9va3VwIHRhYmxlIGFjY291bnQgZm9yIHRhYmxlIGtleSAke3RhYmxlTG9va3VwLmFjY291bnRLZXkudG9CYXNlNTgoKX1gKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgaW5kZXggb2YgdGFibGVMb29rdXAud3JpdGFibGVJbmRleGVzKSB7XG4gICAgICAgIGlmIChpbmRleCA8IHRhYmxlQWNjb3VudC5zdGF0ZS5hZGRyZXNzZXMubGVuZ3RoKSB7XG4gICAgICAgICAgYWNjb3VudEtleXNGcm9tTG9va3Vwcy53cml0YWJsZS5wdXNoKHRhYmxlQWNjb3VudC5zdGF0ZS5hZGRyZXNzZXNbaW5kZXhdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmaW5kIGFkZHJlc3MgZm9yIGluZGV4ICR7aW5kZXh9IGluIGFkZHJlc3MgbG9va3VwIHRhYmxlICR7dGFibGVMb29rdXAuYWNjb3VudEtleS50b0Jhc2U1OCgpfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGluZGV4IG9mIHRhYmxlTG9va3VwLnJlYWRvbmx5SW5kZXhlcykge1xuICAgICAgICBpZiAoaW5kZXggPCB0YWJsZUFjY291bnQuc3RhdGUuYWRkcmVzc2VzLmxlbmd0aCkge1xuICAgICAgICAgIGFjY291bnRLZXlzRnJvbUxvb2t1cHMucmVhZG9ubHkucHVzaCh0YWJsZUFjY291bnQuc3RhdGUuYWRkcmVzc2VzW2luZGV4XSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmluZCBhZGRyZXNzIGZvciBpbmRleCAke2luZGV4fSBpbiBhZGRyZXNzIGxvb2t1cCB0YWJsZSAke3RhYmxlTG9va3VwLmFjY291bnRLZXkudG9CYXNlNTgoKX1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYWNjb3VudEtleXNGcm9tTG9va3VwcztcbiAgfVxuICBzdGF0aWMgY29tcGlsZShhcmdzKSB7XG4gICAgY29uc3QgY29tcGlsZWRLZXlzID0gQ29tcGlsZWRLZXlzLmNvbXBpbGUoYXJncy5pbnN0cnVjdGlvbnMsIGFyZ3MucGF5ZXJLZXkpO1xuICAgIGNvbnN0IGFkZHJlc3NUYWJsZUxvb2t1cHMgPSBuZXcgQXJyYXkoKTtcbiAgICBjb25zdCBhY2NvdW50S2V5c0Zyb21Mb29rdXBzID0ge1xuICAgICAgd3JpdGFibGU6IG5ldyBBcnJheSgpLFxuICAgICAgcmVhZG9ubHk6IG5ldyBBcnJheSgpXG4gICAgfTtcbiAgICBjb25zdCBsb29rdXBUYWJsZUFjY291bnRzID0gYXJncy5hZGRyZXNzTG9va3VwVGFibGVBY2NvdW50cyB8fCBbXTtcbiAgICBmb3IgKGNvbnN0IGxvb2t1cFRhYmxlIG9mIGxvb2t1cFRhYmxlQWNjb3VudHMpIHtcbiAgICAgIGNvbnN0IGV4dHJhY3RSZXN1bHQgPSBjb21waWxlZEtleXMuZXh0cmFjdFRhYmxlTG9va3VwKGxvb2t1cFRhYmxlKTtcbiAgICAgIGlmIChleHRyYWN0UmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgW2FkZHJlc3NUYWJsZUxvb2t1cCwge1xuICAgICAgICAgIHdyaXRhYmxlLFxuICAgICAgICAgIHJlYWRvbmx5XG4gICAgICAgIH1dID0gZXh0cmFjdFJlc3VsdDtcbiAgICAgICAgYWRkcmVzc1RhYmxlTG9va3Vwcy5wdXNoKGFkZHJlc3NUYWJsZUxvb2t1cCk7XG4gICAgICAgIGFjY291bnRLZXlzRnJvbUxvb2t1cHMud3JpdGFibGUucHVzaCguLi53cml0YWJsZSk7XG4gICAgICAgIGFjY291bnRLZXlzRnJvbUxvb2t1cHMucmVhZG9ubHkucHVzaCguLi5yZWFkb25seSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IFtoZWFkZXIsIHN0YXRpY0FjY291bnRLZXlzXSA9IGNvbXBpbGVkS2V5cy5nZXRNZXNzYWdlQ29tcG9uZW50cygpO1xuICAgIGNvbnN0IGFjY291bnRLZXlzID0gbmV3IE1lc3NhZ2VBY2NvdW50S2V5cyhzdGF0aWNBY2NvdW50S2V5cywgYWNjb3VudEtleXNGcm9tTG9va3Vwcyk7XG4gICAgY29uc3QgY29tcGlsZWRJbnN0cnVjdGlvbnMgPSBhY2NvdW50S2V5cy5jb21waWxlSW5zdHJ1Y3Rpb25zKGFyZ3MuaW5zdHJ1Y3Rpb25zKTtcbiAgICByZXR1cm4gbmV3IE1lc3NhZ2VWMCh7XG4gICAgICBoZWFkZXIsXG4gICAgICBzdGF0aWNBY2NvdW50S2V5cyxcbiAgICAgIHJlY2VudEJsb2NraGFzaDogYXJncy5yZWNlbnRCbG9ja2hhc2gsXG4gICAgICBjb21waWxlZEluc3RydWN0aW9ucyxcbiAgICAgIGFkZHJlc3NUYWJsZUxvb2t1cHNcbiAgICB9KTtcbiAgfVxuICBzZXJpYWxpemUoKSB7XG4gICAgY29uc3QgZW5jb2RlZFN0YXRpY0FjY291bnRLZXlzTGVuZ3RoID0gQXJyYXkoKTtcbiAgICBlbmNvZGVMZW5ndGgoZW5jb2RlZFN0YXRpY0FjY291bnRLZXlzTGVuZ3RoLCB0aGlzLnN0YXRpY0FjY291bnRLZXlzLmxlbmd0aCk7XG4gICAgY29uc3Qgc2VyaWFsaXplZEluc3RydWN0aW9ucyA9IHRoaXMuc2VyaWFsaXplSW5zdHJ1Y3Rpb25zKCk7XG4gICAgY29uc3QgZW5jb2RlZEluc3RydWN0aW9uc0xlbmd0aCA9IEFycmF5KCk7XG4gICAgZW5jb2RlTGVuZ3RoKGVuY29kZWRJbnN0cnVjdGlvbnNMZW5ndGgsIHRoaXMuY29tcGlsZWRJbnN0cnVjdGlvbnMubGVuZ3RoKTtcbiAgICBjb25zdCBzZXJpYWxpemVkQWRkcmVzc1RhYmxlTG9va3VwcyA9IHRoaXMuc2VyaWFsaXplQWRkcmVzc1RhYmxlTG9va3VwcygpO1xuICAgIGNvbnN0IGVuY29kZWRBZGRyZXNzVGFibGVMb29rdXBzTGVuZ3RoID0gQXJyYXkoKTtcbiAgICBlbmNvZGVMZW5ndGgoZW5jb2RlZEFkZHJlc3NUYWJsZUxvb2t1cHNMZW5ndGgsIHRoaXMuYWRkcmVzc1RhYmxlTG9va3Vwcy5sZW5ndGgpO1xuICAgIGNvbnN0IG1lc3NhZ2VMYXlvdXQgPSBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5zdHJ1Y3QoW0J1ZmZlckxheW91dF9fbmFtZXNwYWNlLnU4KCdwcmVmaXgnKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2Uuc3RydWN0KFtCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51OCgnbnVtUmVxdWlyZWRTaWduYXR1cmVzJyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnU4KCdudW1SZWFkb25seVNpZ25lZEFjY291bnRzJyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnU4KCdudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHMnKV0sICdoZWFkZXInKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UuYmxvYihlbmNvZGVkU3RhdGljQWNjb3VudEtleXNMZW5ndGgubGVuZ3RoLCAnc3RhdGljQWNjb3VudEtleXNMZW5ndGgnKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2Uuc2VxKHB1YmxpY0tleSgpLCB0aGlzLnN0YXRpY0FjY291bnRLZXlzLmxlbmd0aCwgJ3N0YXRpY0FjY291bnRLZXlzJyksIHB1YmxpY0tleSgncmVjZW50QmxvY2toYXNoJyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLmJsb2IoZW5jb2RlZEluc3RydWN0aW9uc0xlbmd0aC5sZW5ndGgsICdpbnN0cnVjdGlvbnNMZW5ndGgnKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UuYmxvYihzZXJpYWxpemVkSW5zdHJ1Y3Rpb25zLmxlbmd0aCwgJ3NlcmlhbGl6ZWRJbnN0cnVjdGlvbnMnKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UuYmxvYihlbmNvZGVkQWRkcmVzc1RhYmxlTG9va3Vwc0xlbmd0aC5sZW5ndGgsICdhZGRyZXNzVGFibGVMb29rdXBzTGVuZ3RoJyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLmJsb2Ioc2VyaWFsaXplZEFkZHJlc3NUYWJsZUxvb2t1cHMubGVuZ3RoLCAnc2VyaWFsaXplZEFkZHJlc3NUYWJsZUxvb2t1cHMnKV0pO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRNZXNzYWdlID0gbmV3IFVpbnQ4QXJyYXkoUEFDS0VUX0RBVEFfU0laRSk7XG4gICAgY29uc3QgTUVTU0FHRV9WRVJTSU9OXzBfUFJFRklYID0gMSA8PCA3O1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRNZXNzYWdlTGVuZ3RoID0gbWVzc2FnZUxheW91dC5lbmNvZGUoe1xuICAgICAgcHJlZml4OiBNRVNTQUdFX1ZFUlNJT05fMF9QUkVGSVgsXG4gICAgICBoZWFkZXI6IHRoaXMuaGVhZGVyLFxuICAgICAgc3RhdGljQWNjb3VudEtleXNMZW5ndGg6IG5ldyBVaW50OEFycmF5KGVuY29kZWRTdGF0aWNBY2NvdW50S2V5c0xlbmd0aCksXG4gICAgICBzdGF0aWNBY2NvdW50S2V5czogdGhpcy5zdGF0aWNBY2NvdW50S2V5cy5tYXAoa2V5ID0+IGtleS50b0J5dGVzKCkpLFxuICAgICAgcmVjZW50QmxvY2toYXNoOiBiczU4X19kZWZhdWx0LmRlZmF1bHQuZGVjb2RlKHRoaXMucmVjZW50QmxvY2toYXNoKSxcbiAgICAgIGluc3RydWN0aW9uc0xlbmd0aDogbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZEluc3RydWN0aW9uc0xlbmd0aCksXG4gICAgICBzZXJpYWxpemVkSW5zdHJ1Y3Rpb25zLFxuICAgICAgYWRkcmVzc1RhYmxlTG9va3Vwc0xlbmd0aDogbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZEFkZHJlc3NUYWJsZUxvb2t1cHNMZW5ndGgpLFxuICAgICAgc2VyaWFsaXplZEFkZHJlc3NUYWJsZUxvb2t1cHNcbiAgICB9LCBzZXJpYWxpemVkTWVzc2FnZSk7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWRNZXNzYWdlLnNsaWNlKDAsIHNlcmlhbGl6ZWRNZXNzYWdlTGVuZ3RoKTtcbiAgfVxuICBzZXJpYWxpemVJbnN0cnVjdGlvbnMoKSB7XG4gICAgbGV0IHNlcmlhbGl6ZWRMZW5ndGggPSAwO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRJbnN0cnVjdGlvbnMgPSBuZXcgVWludDhBcnJheShQQUNLRVRfREFUQV9TSVpFKTtcbiAgICBmb3IgKGNvbnN0IGluc3RydWN0aW9uIG9mIHRoaXMuY29tcGlsZWRJbnN0cnVjdGlvbnMpIHtcbiAgICAgIGNvbnN0IGVuY29kZWRBY2NvdW50S2V5SW5kZXhlc0xlbmd0aCA9IEFycmF5KCk7XG4gICAgICBlbmNvZGVMZW5ndGgoZW5jb2RlZEFjY291bnRLZXlJbmRleGVzTGVuZ3RoLCBpbnN0cnVjdGlvbi5hY2NvdW50S2V5SW5kZXhlcy5sZW5ndGgpO1xuICAgICAgY29uc3QgZW5jb2RlZERhdGFMZW5ndGggPSBBcnJheSgpO1xuICAgICAgZW5jb2RlTGVuZ3RoKGVuY29kZWREYXRhTGVuZ3RoLCBpbnN0cnVjdGlvbi5kYXRhLmxlbmd0aCk7XG4gICAgICBjb25zdCBpbnN0cnVjdGlvbkxheW91dCA9IEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnN0cnVjdChbQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTgoJ3Byb2dyYW1JZEluZGV4JyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLmJsb2IoZW5jb2RlZEFjY291bnRLZXlJbmRleGVzTGVuZ3RoLmxlbmd0aCwgJ2VuY29kZWRBY2NvdW50S2V5SW5kZXhlc0xlbmd0aCcpLCBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5zZXEoQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTgoKSwgaW5zdHJ1Y3Rpb24uYWNjb3VudEtleUluZGV4ZXMubGVuZ3RoLCAnYWNjb3VudEtleUluZGV4ZXMnKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UuYmxvYihlbmNvZGVkRGF0YUxlbmd0aC5sZW5ndGgsICdlbmNvZGVkRGF0YUxlbmd0aCcpLCBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5ibG9iKGluc3RydWN0aW9uLmRhdGEubGVuZ3RoLCAnZGF0YScpXSk7XG4gICAgICBzZXJpYWxpemVkTGVuZ3RoICs9IGluc3RydWN0aW9uTGF5b3V0LmVuY29kZSh7XG4gICAgICAgIHByb2dyYW1JZEluZGV4OiBpbnN0cnVjdGlvbi5wcm9ncmFtSWRJbmRleCxcbiAgICAgICAgZW5jb2RlZEFjY291bnRLZXlJbmRleGVzTGVuZ3RoOiBuZXcgVWludDhBcnJheShlbmNvZGVkQWNjb3VudEtleUluZGV4ZXNMZW5ndGgpLFxuICAgICAgICBhY2NvdW50S2V5SW5kZXhlczogaW5zdHJ1Y3Rpb24uYWNjb3VudEtleUluZGV4ZXMsXG4gICAgICAgIGVuY29kZWREYXRhTGVuZ3RoOiBuZXcgVWludDhBcnJheShlbmNvZGVkRGF0YUxlbmd0aCksXG4gICAgICAgIGRhdGE6IGluc3RydWN0aW9uLmRhdGFcbiAgICAgIH0sIHNlcmlhbGl6ZWRJbnN0cnVjdGlvbnMsIHNlcmlhbGl6ZWRMZW5ndGgpO1xuICAgIH1cbiAgICByZXR1cm4gc2VyaWFsaXplZEluc3RydWN0aW9ucy5zbGljZSgwLCBzZXJpYWxpemVkTGVuZ3RoKTtcbiAgfVxuICBzZXJpYWxpemVBZGRyZXNzVGFibGVMb29rdXBzKCkge1xuICAgIGxldCBzZXJpYWxpemVkTGVuZ3RoID0gMDtcbiAgICBjb25zdCBzZXJpYWxpemVkQWRkcmVzc1RhYmxlTG9va3VwcyA9IG5ldyBVaW50OEFycmF5KFBBQ0tFVF9EQVRBX1NJWkUpO1xuICAgIGZvciAoY29uc3QgbG9va3VwIG9mIHRoaXMuYWRkcmVzc1RhYmxlTG9va3Vwcykge1xuICAgICAgY29uc3QgZW5jb2RlZFdyaXRhYmxlSW5kZXhlc0xlbmd0aCA9IEFycmF5KCk7XG4gICAgICBlbmNvZGVMZW5ndGgoZW5jb2RlZFdyaXRhYmxlSW5kZXhlc0xlbmd0aCwgbG9va3VwLndyaXRhYmxlSW5kZXhlcy5sZW5ndGgpO1xuICAgICAgY29uc3QgZW5jb2RlZFJlYWRvbmx5SW5kZXhlc0xlbmd0aCA9IEFycmF5KCk7XG4gICAgICBlbmNvZGVMZW5ndGgoZW5jb2RlZFJlYWRvbmx5SW5kZXhlc0xlbmd0aCwgbG9va3VwLnJlYWRvbmx5SW5kZXhlcy5sZW5ndGgpO1xuICAgICAgY29uc3QgYWRkcmVzc1RhYmxlTG9va3VwTGF5b3V0ID0gQnVmZmVyTGF5b3V0X19uYW1lc3BhY2Uuc3RydWN0KFtwdWJsaWNLZXkoJ2FjY291bnRLZXknKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UuYmxvYihlbmNvZGVkV3JpdGFibGVJbmRleGVzTGVuZ3RoLmxlbmd0aCwgJ2VuY29kZWRXcml0YWJsZUluZGV4ZXNMZW5ndGgnKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2Uuc2VxKEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnU4KCksIGxvb2t1cC53cml0YWJsZUluZGV4ZXMubGVuZ3RoLCAnd3JpdGFibGVJbmRleGVzJyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLmJsb2IoZW5jb2RlZFJlYWRvbmx5SW5kZXhlc0xlbmd0aC5sZW5ndGgsICdlbmNvZGVkUmVhZG9ubHlJbmRleGVzTGVuZ3RoJyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnNlcShCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51OCgpLCBsb29rdXAucmVhZG9ubHlJbmRleGVzLmxlbmd0aCwgJ3JlYWRvbmx5SW5kZXhlcycpXSk7XG4gICAgICBzZXJpYWxpemVkTGVuZ3RoICs9IGFkZHJlc3NUYWJsZUxvb2t1cExheW91dC5lbmNvZGUoe1xuICAgICAgICBhY2NvdW50S2V5OiBsb29rdXAuYWNjb3VudEtleS50b0J5dGVzKCksXG4gICAgICAgIGVuY29kZWRXcml0YWJsZUluZGV4ZXNMZW5ndGg6IG5ldyBVaW50OEFycmF5KGVuY29kZWRXcml0YWJsZUluZGV4ZXNMZW5ndGgpLFxuICAgICAgICB3cml0YWJsZUluZGV4ZXM6IGxvb2t1cC53cml0YWJsZUluZGV4ZXMsXG4gICAgICAgIGVuY29kZWRSZWFkb25seUluZGV4ZXNMZW5ndGg6IG5ldyBVaW50OEFycmF5KGVuY29kZWRSZWFkb25seUluZGV4ZXNMZW5ndGgpLFxuICAgICAgICByZWFkb25seUluZGV4ZXM6IGxvb2t1cC5yZWFkb25seUluZGV4ZXNcbiAgICAgIH0sIHNlcmlhbGl6ZWRBZGRyZXNzVGFibGVMb29rdXBzLCBzZXJpYWxpemVkTGVuZ3RoKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWRBZGRyZXNzVGFibGVMb29rdXBzLnNsaWNlKDAsIHNlcmlhbGl6ZWRMZW5ndGgpO1xuICB9XG4gIHN0YXRpYyBkZXNlcmlhbGl6ZShzZXJpYWxpemVkTWVzc2FnZSkge1xuICAgIGxldCBieXRlQXJyYXkgPSBbLi4uc2VyaWFsaXplZE1lc3NhZ2VdO1xuICAgIGNvbnN0IHByZWZpeCA9IGd1YXJkZWRTaGlmdChieXRlQXJyYXkpO1xuICAgIGNvbnN0IG1hc2tlZFByZWZpeCA9IHByZWZpeCAmIFZFUlNJT05fUFJFRklYX01BU0s7XG4gICAgYXNzZXJ0KHByZWZpeCAhPT0gbWFza2VkUHJlZml4LCBgRXhwZWN0ZWQgdmVyc2lvbmVkIG1lc3NhZ2UgYnV0IHJlY2VpdmVkIGxlZ2FjeSBtZXNzYWdlYCk7XG4gICAgY29uc3QgdmVyc2lvbiA9IG1hc2tlZFByZWZpeDtcbiAgICBhc3NlcnQodmVyc2lvbiA9PT0gMCwgYEV4cGVjdGVkIHZlcnNpb25lZCBtZXNzYWdlIHdpdGggdmVyc2lvbiAwIGJ1dCBmb3VuZCB2ZXJzaW9uICR7dmVyc2lvbn1gKTtcbiAgICBjb25zdCBoZWFkZXIgPSB7XG4gICAgICBudW1SZXF1aXJlZFNpZ25hdHVyZXM6IGd1YXJkZWRTaGlmdChieXRlQXJyYXkpLFxuICAgICAgbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50czogZ3VhcmRlZFNoaWZ0KGJ5dGVBcnJheSksXG4gICAgICBudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHM6IGd1YXJkZWRTaGlmdChieXRlQXJyYXkpXG4gICAgfTtcbiAgICBjb25zdCBzdGF0aWNBY2NvdW50S2V5cyA9IFtdO1xuICAgIGNvbnN0IHN0YXRpY0FjY291bnRLZXlzTGVuZ3RoID0gZGVjb2RlTGVuZ3RoKGJ5dGVBcnJheSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0aWNBY2NvdW50S2V5c0xlbmd0aDsgaSsrKSB7XG4gICAgICBzdGF0aWNBY2NvdW50S2V5cy5wdXNoKG5ldyBQdWJsaWNLZXkoZ3VhcmRlZFNwbGljZShieXRlQXJyYXksIDAsIFBVQkxJQ19LRVlfTEVOR1RIKSkpO1xuICAgIH1cbiAgICBjb25zdCByZWNlbnRCbG9ja2hhc2ggPSBiczU4X19kZWZhdWx0LmRlZmF1bHQuZW5jb2RlKGd1YXJkZWRTcGxpY2UoYnl0ZUFycmF5LCAwLCBQVUJMSUNfS0VZX0xFTkdUSCkpO1xuICAgIGNvbnN0IGluc3RydWN0aW9uQ291bnQgPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICBjb25zdCBjb21waWxlZEluc3RydWN0aW9ucyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5zdHJ1Y3Rpb25Db3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBwcm9ncmFtSWRJbmRleCA9IGd1YXJkZWRTaGlmdChieXRlQXJyYXkpO1xuICAgICAgY29uc3QgYWNjb3VudEtleUluZGV4ZXNMZW5ndGggPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICAgIGNvbnN0IGFjY291bnRLZXlJbmRleGVzID0gZ3VhcmRlZFNwbGljZShieXRlQXJyYXksIDAsIGFjY291bnRLZXlJbmRleGVzTGVuZ3RoKTtcbiAgICAgIGNvbnN0IGRhdGFMZW5ndGggPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheShndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgMCwgZGF0YUxlbmd0aCkpO1xuICAgICAgY29tcGlsZWRJbnN0cnVjdGlvbnMucHVzaCh7XG4gICAgICAgIHByb2dyYW1JZEluZGV4LFxuICAgICAgICBhY2NvdW50S2V5SW5kZXhlcyxcbiAgICAgICAgZGF0YVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGFkZHJlc3NUYWJsZUxvb2t1cHNDb3VudCA9IGRlY29kZUxlbmd0aChieXRlQXJyYXkpO1xuICAgIGNvbnN0IGFkZHJlc3NUYWJsZUxvb2t1cHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFkZHJlc3NUYWJsZUxvb2t1cHNDb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBhY2NvdW50S2V5ID0gbmV3IFB1YmxpY0tleShndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgMCwgUFVCTElDX0tFWV9MRU5HVEgpKTtcbiAgICAgIGNvbnN0IHdyaXRhYmxlSW5kZXhlc0xlbmd0aCA9IGRlY29kZUxlbmd0aChieXRlQXJyYXkpO1xuICAgICAgY29uc3Qgd3JpdGFibGVJbmRleGVzID0gZ3VhcmRlZFNwbGljZShieXRlQXJyYXksIDAsIHdyaXRhYmxlSW5kZXhlc0xlbmd0aCk7XG4gICAgICBjb25zdCByZWFkb25seUluZGV4ZXNMZW5ndGggPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICAgIGNvbnN0IHJlYWRvbmx5SW5kZXhlcyA9IGd1YXJkZWRTcGxpY2UoYnl0ZUFycmF5LCAwLCByZWFkb25seUluZGV4ZXNMZW5ndGgpO1xuICAgICAgYWRkcmVzc1RhYmxlTG9va3Vwcy5wdXNoKHtcbiAgICAgICAgYWNjb3VudEtleSxcbiAgICAgICAgd3JpdGFibGVJbmRleGVzLFxuICAgICAgICByZWFkb25seUluZGV4ZXNcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE1lc3NhZ2VWMCh7XG4gICAgICBoZWFkZXIsXG4gICAgICBzdGF0aWNBY2NvdW50S2V5cyxcbiAgICAgIHJlY2VudEJsb2NraGFzaCxcbiAgICAgIGNvbXBpbGVkSW5zdHJ1Y3Rpb25zLFxuICAgICAgYWRkcmVzc1RhYmxlTG9va3Vwc1xuICAgIH0pO1xuICB9XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbmNvbnN0IFZlcnNpb25lZE1lc3NhZ2UgPSB7XG4gIGRlc2VyaWFsaXplTWVzc2FnZVZlcnNpb24oc2VyaWFsaXplZE1lc3NhZ2UpIHtcbiAgICBjb25zdCBwcmVmaXggPSBzZXJpYWxpemVkTWVzc2FnZVswXTtcbiAgICBjb25zdCBtYXNrZWRQcmVmaXggPSBwcmVmaXggJiBWRVJTSU9OX1BSRUZJWF9NQVNLO1xuXG4gICAgLy8gaWYgdGhlIGhpZ2hlc3QgYml0IG9mIHRoZSBwcmVmaXggaXMgbm90IHNldCwgdGhlIG1lc3NhZ2UgaXMgbm90IHZlcnNpb25lZFxuICAgIGlmIChtYXNrZWRQcmVmaXggPT09IHByZWZpeCkge1xuICAgICAgcmV0dXJuICdsZWdhY3knO1xuICAgIH1cblxuICAgIC8vIHRoZSBsb3dlciA3IGJpdHMgb2YgdGhlIHByZWZpeCBpbmRpY2F0ZSB0aGUgbWVzc2FnZSB2ZXJzaW9uXG4gICAgcmV0dXJuIG1hc2tlZFByZWZpeDtcbiAgfSxcbiAgZGVzZXJpYWxpemU6IHNlcmlhbGl6ZWRNZXNzYWdlID0+IHtcbiAgICBjb25zdCB2ZXJzaW9uID0gVmVyc2lvbmVkTWVzc2FnZS5kZXNlcmlhbGl6ZU1lc3NhZ2VWZXJzaW9uKHNlcmlhbGl6ZWRNZXNzYWdlKTtcbiAgICBpZiAodmVyc2lvbiA9PT0gJ2xlZ2FjeScpIHtcbiAgICAgIHJldHVybiBNZXNzYWdlLmZyb20oc2VyaWFsaXplZE1lc3NhZ2UpO1xuICAgIH1cbiAgICBpZiAodmVyc2lvbiA9PT0gMCkge1xuICAgICAgcmV0dXJuIE1lc3NhZ2VWMC5kZXNlcmlhbGl6ZShzZXJpYWxpemVkTWVzc2FnZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVHJhbnNhY3Rpb24gbWVzc2FnZSB2ZXJzaW9uICR7dmVyc2lvbn0gZGVzZXJpYWxpemF0aW9uIGlzIG5vdCBzdXBwb3J0ZWRgKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKiBAaW50ZXJuYWwgKi9cblxuLyoqXG4gKiBUcmFuc2FjdGlvbiBzaWduYXR1cmUgYXMgYmFzZS01OCBlbmNvZGVkIHN0cmluZ1xuICovXG5cbmxldCBUcmFuc2FjdGlvblN0YXR1cyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoVHJhbnNhY3Rpb25TdGF0dXMpIHtcbiAgVHJhbnNhY3Rpb25TdGF0dXNbVHJhbnNhY3Rpb25TdGF0dXNbXCJCTE9DS0hFSUdIVF9FWENFRURFRFwiXSA9IDBdID0gXCJCTE9DS0hFSUdIVF9FWENFRURFRFwiO1xuICBUcmFuc2FjdGlvblN0YXR1c1tUcmFuc2FjdGlvblN0YXR1c1tcIlBST0NFU1NFRFwiXSA9IDFdID0gXCJQUk9DRVNTRURcIjtcbiAgVHJhbnNhY3Rpb25TdGF0dXNbVHJhbnNhY3Rpb25TdGF0dXNbXCJUSU1FRF9PVVRcIl0gPSAyXSA9IFwiVElNRURfT1VUXCI7XG4gIFRyYW5zYWN0aW9uU3RhdHVzW1RyYW5zYWN0aW9uU3RhdHVzW1wiTk9OQ0VfSU5WQUxJRFwiXSA9IDNdID0gXCJOT05DRV9JTlZBTElEXCI7XG4gIHJldHVybiBUcmFuc2FjdGlvblN0YXR1cztcbn0oe30pO1xuXG4vKipcbiAqIERlZmF1bHQgKGVtcHR5KSBzaWduYXR1cmVcbiAqL1xuY29uc3QgREVGQVVMVF9TSUdOQVRVUkUgPSBidWZmZXIuQnVmZmVyLmFsbG9jKFNJR05BVFVSRV9MRU5HVEhfSU5fQllURVMpLmZpbGwoMCk7XG5cbi8qKlxuICogQWNjb3VudCBtZXRhZGF0YSB1c2VkIHRvIGRlZmluZSBpbnN0cnVjdGlvbnNcbiAqL1xuXG4vKipcbiAqIExpc3Qgb2YgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbiBvYmplY3QgZmllbGRzIHRoYXQgbWF5IGJlIGluaXRpYWxpemVkIGF0IGNvbnN0cnVjdGlvblxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIFRyYW5zYWN0aW9uLnNlcmlhbGl6ZSgpXG4gKi9cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG4vKipcbiAqIFRyYW5zYWN0aW9uIEluc3RydWN0aW9uIGNsYXNzXG4gKi9cbmNsYXNzIFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24ge1xuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgLyoqXG4gICAgICogUHVibGljIGtleXMgdG8gaW5jbHVkZSBpbiB0aGlzIHRyYW5zYWN0aW9uXG4gICAgICogQm9vbGVhbiByZXByZXNlbnRzIHdoZXRoZXIgdGhpcyBwdWJrZXkgbmVlZHMgdG8gc2lnbiB0aGUgdHJhbnNhY3Rpb25cbiAgICAgKi9cbiAgICB0aGlzLmtleXMgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogUHJvZ3JhbSBJZCB0byBleGVjdXRlXG4gICAgICovXG4gICAgdGhpcy5wcm9ncmFtSWQgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogUHJvZ3JhbSBpbnB1dFxuICAgICAqL1xuICAgIHRoaXMuZGF0YSA9IGJ1ZmZlci5CdWZmZXIuYWxsb2MoMCk7XG4gICAgdGhpcy5wcm9ncmFtSWQgPSBvcHRzLnByb2dyYW1JZDtcbiAgICB0aGlzLmtleXMgPSBvcHRzLmtleXM7XG4gICAgaWYgKG9wdHMuZGF0YSkge1xuICAgICAgdGhpcy5kYXRhID0gb3B0cy5kYXRhO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAga2V5czogdGhpcy5rZXlzLm1hcCgoe1xuICAgICAgICBwdWJrZXksXG4gICAgICAgIGlzU2lnbmVyLFxuICAgICAgICBpc1dyaXRhYmxlXG4gICAgICB9KSA9PiAoe1xuICAgICAgICBwdWJrZXk6IHB1YmtleS50b0pTT04oKSxcbiAgICAgICAgaXNTaWduZXIsXG4gICAgICAgIGlzV3JpdGFibGVcbiAgICAgIH0pKSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQudG9KU09OKCksXG4gICAgICBkYXRhOiBbLi4udGhpcy5kYXRhXVxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBQYWlyIG9mIHNpZ25hdHVyZSBhbmQgY29ycmVzcG9uZGluZyBwdWJsaWMga2V5XG4gKi9cblxuLyoqXG4gKiBMaXN0IG9mIFRyYW5zYWN0aW9uIG9iamVjdCBmaWVsZHMgdGhhdCBtYXkgYmUgaW5pdGlhbGl6ZWQgYXQgY29uc3RydWN0aW9uXG4gKi9cblxuLy8gRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHk7IGFuIHVuZm9ydHVuYXRlIGNvbnNlcXVlbmNlIG9mIGJlaW5nXG4vLyBmb3JjZWQgdG8gb3Zlci1leHBvcnQgdHlwZXMgYnkgdGhlIGRvY3VtZW50YXRpb24gZ2VuZXJhdG9yLlxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zb2xhbmEtbGFicy9zb2xhbmEvcHVsbC8yNTgyMFxuXG4vKipcbiAqIEJsb2NraGFzaC1iYXNlZCB0cmFuc2FjdGlvbnMgaGF2ZSBhIGxpZmV0aW1lIHRoYXQgYXJlIGRlZmluZWQgYnlcbiAqIHRoZSBibG9ja2hhc2ggdGhleSBpbmNsdWRlLiBBbnkgdHJhbnNhY3Rpb24gd2hvc2UgYmxvY2toYXNoIGlzXG4gKiB0b28gb2xkIHdpbGwgYmUgcmVqZWN0ZWQuXG4gKi9cblxuLyoqXG4gKiBVc2UgdGhlc2Ugb3B0aW9ucyB0byBjb25zdHJ1Y3QgYSBkdXJhYmxlIG5vbmNlIHRyYW5zYWN0aW9uLlxuICovXG5cbi8qKlxuICogTm9uY2UgaW5mb3JtYXRpb24gdG8gYmUgdXNlZCB0byBidWlsZCBhbiBvZmZsaW5lIFRyYW5zYWN0aW9uLlxuICovXG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cblxuLyoqXG4gKiBUcmFuc2FjdGlvbiBjbGFzc1xuICovXG5jbGFzcyBUcmFuc2FjdGlvbiB7XG4gIC8qKlxuICAgKiBUaGUgZmlyc3QgKHBheWVyKSBUcmFuc2FjdGlvbiBzaWduYXR1cmVcbiAgICpcbiAgICogQHJldHVybnMge0J1ZmZlciB8IG51bGx9IEJ1ZmZlciBvZiBwYXllcidzIHNpZ25hdHVyZVxuICAgKi9cbiAgZ2V0IHNpZ25hdHVyZSgpIHtcbiAgICBpZiAodGhpcy5zaWduYXR1cmVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiB0aGlzLnNpZ25hdHVyZXNbMF0uc2lnbmF0dXJlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgdHJhbnNhY3Rpb24gZmVlIHBheWVyXG4gICAqL1xuXG4gIC8vIENvbnN0cnVjdCBhIHRyYW5zYWN0aW9uIHdpdGggYSBibG9ja2hhc2ggYW5kIGxhc3RWYWxpZEJsb2NrSGVpZ2h0XG5cbiAgLy8gQ29uc3RydWN0IGEgdHJhbnNhY3Rpb24gdXNpbmcgYSBkdXJhYmxlIG5vbmNlXG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIGBUcmFuc2FjdGlvbkN0b3JGaWVsZHNgIGhhcyBiZWVuIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uLlxuICAgKiBQbGVhc2Ugc3VwcGx5IGEgYFRyYW5zYWN0aW9uQmxvY2toYXNoQ3RvcmAgaW5zdGVhZC5cbiAgICovXG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhbiBlbXB0eSBUcmFuc2FjdGlvblxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIC8qKlxuICAgICAqIFNpZ25hdHVyZXMgZm9yIHRoZSB0cmFuc2FjdGlvbi4gIFR5cGljYWxseSBjcmVhdGVkIGJ5IGludm9raW5nIHRoZVxuICAgICAqIGBzaWduKClgIG1ldGhvZFxuICAgICAqL1xuICAgIHRoaXMuc2lnbmF0dXJlcyA9IFtdO1xuICAgIHRoaXMuZmVlUGF5ZXIgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogVGhlIGluc3RydWN0aW9ucyB0byBhdG9taWNhbGx5IGV4ZWN1dGVcbiAgICAgKi9cbiAgICB0aGlzLmluc3RydWN0aW9ucyA9IFtdO1xuICAgIC8qKlxuICAgICAqIEEgcmVjZW50IHRyYW5zYWN0aW9uIGlkLiBNdXN0IGJlIHBvcHVsYXRlZCBieSB0aGUgY2FsbGVyXG4gICAgICovXG4gICAgdGhpcy5yZWNlbnRCbG9ja2hhc2ggPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogdGhlIGxhc3QgYmxvY2sgY2hhaW4gY2FuIGFkdmFuY2UgdG8gYmVmb3JlIHR4IGlzIGRlY2xhcmVkIGV4cGlyZWRcbiAgICAgKiAqL1xuICAgIHRoaXMubGFzdFZhbGlkQmxvY2tIZWlnaHQgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogT3B0aW9uYWwgTm9uY2UgaW5mb3JtYXRpb24uIElmIHBvcHVsYXRlZCwgdHJhbnNhY3Rpb24gd2lsbCB1c2UgYSBkdXJhYmxlXG4gICAgICogTm9uY2UgaGFzaCBpbnN0ZWFkIG9mIGEgcmVjZW50QmxvY2toYXNoLiBNdXN0IGJlIHBvcHVsYXRlZCBieSB0aGUgY2FsbGVyXG4gICAgICovXG4gICAgdGhpcy5ub25jZUluZm8gPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogSWYgdGhpcyBpcyBhIG5vbmNlIHRyYW5zYWN0aW9uIHRoaXMgcmVwcmVzZW50cyB0aGUgbWluaW11bSBzbG90IGZyb20gd2hpY2hcbiAgICAgKiB0byBldmFsdWF0ZSBpZiB0aGUgbm9uY2UgaGFzIGFkdmFuY2VkIHdoZW4gYXR0ZW1wdGluZyB0byBjb25maXJtIHRoZVxuICAgICAqIHRyYW5zYWN0aW9uLiBUaGlzIHByb3RlY3RzIGFnYWluc3QgYSBjYXNlIHdoZXJlIHRoZSB0cmFuc2FjdGlvbiBjb25maXJtYXRpb25cbiAgICAgKiBsb2dpYyBsb2FkcyB0aGUgbm9uY2UgYWNjb3VudCBmcm9tIGFuIG9sZCBzbG90IGFuZCBhc3N1bWVzIHRoZSBtaXNtYXRjaCBpblxuICAgICAqIG5vbmNlIHZhbHVlIGltcGxpZXMgdGhhdCB0aGUgbm9uY2UgaGFzIGJlZW4gYWR2YW5jZWQuXG4gICAgICovXG4gICAgdGhpcy5taW5Ob25jZUNvbnRleHRTbG90ID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuX21lc3NhZ2UgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5fanNvbiA9IHZvaWQgMDtcbiAgICBpZiAoIW9wdHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG9wdHMuZmVlUGF5ZXIpIHtcbiAgICAgIHRoaXMuZmVlUGF5ZXIgPSBvcHRzLmZlZVBheWVyO1xuICAgIH1cbiAgICBpZiAob3B0cy5zaWduYXR1cmVzKSB7XG4gICAgICB0aGlzLnNpZ25hdHVyZXMgPSBvcHRzLnNpZ25hdHVyZXM7XG4gICAgfVxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0cywgJ25vbmNlSW5mbycpKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG1pbkNvbnRleHRTbG90LFxuICAgICAgICBub25jZUluZm9cbiAgICAgIH0gPSBvcHRzO1xuICAgICAgdGhpcy5taW5Ob25jZUNvbnRleHRTbG90ID0gbWluQ29udGV4dFNsb3Q7XG4gICAgICB0aGlzLm5vbmNlSW5mbyA9IG5vbmNlSW5mbztcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRzLCAnbGFzdFZhbGlkQmxvY2tIZWlnaHQnKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBibG9ja2hhc2gsXG4gICAgICAgIGxhc3RWYWxpZEJsb2NrSGVpZ2h0XG4gICAgICB9ID0gb3B0cztcbiAgICAgIHRoaXMucmVjZW50QmxvY2toYXNoID0gYmxvY2toYXNoO1xuICAgICAgdGhpcy5sYXN0VmFsaWRCbG9ja0hlaWdodCA9IGxhc3RWYWxpZEJsb2NrSGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJlY2VudEJsb2NraGFzaCxcbiAgICAgICAgbm9uY2VJbmZvXG4gICAgICB9ID0gb3B0cztcbiAgICAgIGlmIChub25jZUluZm8pIHtcbiAgICAgICAgdGhpcy5ub25jZUluZm8gPSBub25jZUluZm87XG4gICAgICB9XG4gICAgICB0aGlzLnJlY2VudEJsb2NraGFzaCA9IHJlY2VudEJsb2NraGFzaDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlY2VudEJsb2NraGFzaDogdGhpcy5yZWNlbnRCbG9ja2hhc2ggfHwgbnVsbCxcbiAgICAgIGZlZVBheWVyOiB0aGlzLmZlZVBheWVyID8gdGhpcy5mZWVQYXllci50b0pTT04oKSA6IG51bGwsXG4gICAgICBub25jZUluZm86IHRoaXMubm9uY2VJbmZvID8ge1xuICAgICAgICBub25jZTogdGhpcy5ub25jZUluZm8ubm9uY2UsXG4gICAgICAgIG5vbmNlSW5zdHJ1Y3Rpb246IHRoaXMubm9uY2VJbmZvLm5vbmNlSW5zdHJ1Y3Rpb24udG9KU09OKClcbiAgICAgIH0gOiBudWxsLFxuICAgICAgaW5zdHJ1Y3Rpb25zOiB0aGlzLmluc3RydWN0aW9ucy5tYXAoaW5zdHJ1Y3Rpb24gPT4gaW5zdHJ1Y3Rpb24udG9KU09OKCkpLFxuICAgICAgc2lnbmVyczogdGhpcy5zaWduYXR1cmVzLm1hcCgoe1xuICAgICAgICBwdWJsaWNLZXlcbiAgICAgIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIHB1YmxpY0tleS50b0pTT04oKTtcbiAgICAgIH0pXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgb25lIG9yIG1vcmUgaW5zdHJ1Y3Rpb25zIHRvIHRoaXMgVHJhbnNhY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTwgVHJhbnNhY3Rpb24gfCBUcmFuc2FjdGlvbkluc3RydWN0aW9uIHwgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbkN0b3JGaWVsZHMgPn0gaXRlbXMgLSBJbnN0cnVjdGlvbnMgdG8gYWRkIHRvIHRoZSBUcmFuc2FjdGlvblxuICAgKi9cbiAgYWRkKC4uLml0ZW1zKSB7XG4gICAgaWYgKGl0ZW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBpbnN0cnVjdGlvbnMnKTtcbiAgICB9XG4gICAgaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgIGlmICgnaW5zdHJ1Y3Rpb25zJyBpbiBpdGVtKSB7XG4gICAgICAgIHRoaXMuaW5zdHJ1Y3Rpb25zID0gdGhpcy5pbnN0cnVjdGlvbnMuY29uY2F0KGl0ZW0uaW5zdHJ1Y3Rpb25zKTtcbiAgICAgIH0gZWxzZSBpZiAoJ2RhdGEnIGluIGl0ZW0gJiYgJ3Byb2dyYW1JZCcgaW4gaXRlbSAmJiAna2V5cycgaW4gaXRlbSkge1xuICAgICAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKGl0ZW0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaChuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbihpdGVtKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ29tcGlsZSB0cmFuc2FjdGlvbiBkYXRhXG4gICAqL1xuICBjb21waWxlTWVzc2FnZSgpIHtcbiAgICBpZiAodGhpcy5fbWVzc2FnZSAmJiBKU09OLnN0cmluZ2lmeSh0aGlzLnRvSlNPTigpKSA9PT0gSlNPTi5zdHJpbmdpZnkodGhpcy5fanNvbikpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tZXNzYWdlO1xuICAgIH1cbiAgICBsZXQgcmVjZW50QmxvY2toYXNoO1xuICAgIGxldCBpbnN0cnVjdGlvbnM7XG4gICAgaWYgKHRoaXMubm9uY2VJbmZvKSB7XG4gICAgICByZWNlbnRCbG9ja2hhc2ggPSB0aGlzLm5vbmNlSW5mby5ub25jZTtcbiAgICAgIGlmICh0aGlzLmluc3RydWN0aW9uc1swXSAhPSB0aGlzLm5vbmNlSW5mby5ub25jZUluc3RydWN0aW9uKSB7XG4gICAgICAgIGluc3RydWN0aW9ucyA9IFt0aGlzLm5vbmNlSW5mby5ub25jZUluc3RydWN0aW9uLCAuLi50aGlzLmluc3RydWN0aW9uc107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnN0cnVjdGlvbnMgPSB0aGlzLmluc3RydWN0aW9ucztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVjZW50QmxvY2toYXNoID0gdGhpcy5yZWNlbnRCbG9ja2hhc2g7XG4gICAgICBpbnN0cnVjdGlvbnMgPSB0aGlzLmluc3RydWN0aW9ucztcbiAgICB9XG4gICAgaWYgKCFyZWNlbnRCbG9ja2hhc2gpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNhY3Rpb24gcmVjZW50QmxvY2toYXNoIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIGlmIChpbnN0cnVjdGlvbnMubGVuZ3RoIDwgMSkge1xuICAgICAgY29uc29sZS53YXJuKCdObyBpbnN0cnVjdGlvbnMgcHJvdmlkZWQnKTtcbiAgICB9XG4gICAgbGV0IGZlZVBheWVyO1xuICAgIGlmICh0aGlzLmZlZVBheWVyKSB7XG4gICAgICBmZWVQYXllciA9IHRoaXMuZmVlUGF5ZXI7XG4gICAgfSBlbHNlIGlmICh0aGlzLnNpZ25hdHVyZXMubGVuZ3RoID4gMCAmJiB0aGlzLnNpZ25hdHVyZXNbMF0ucHVibGljS2V5KSB7XG4gICAgICAvLyBVc2UgaW1wbGljaXQgZmVlIHBheWVyXG4gICAgICBmZWVQYXllciA9IHRoaXMuc2lnbmF0dXJlc1swXS5wdWJsaWNLZXk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNhY3Rpb24gZmVlIHBheWVyIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5zdHJ1Y3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaW5zdHJ1Y3Rpb25zW2ldLnByb2dyYW1JZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVHJhbnNhY3Rpb24gaW5zdHJ1Y3Rpb24gaW5kZXggJHtpfSBoYXMgdW5kZWZpbmVkIHByb2dyYW0gaWRgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcHJvZ3JhbUlkcyA9IFtdO1xuICAgIGNvbnN0IGFjY291bnRNZXRhcyA9IFtdO1xuICAgIGluc3RydWN0aW9ucy5mb3JFYWNoKGluc3RydWN0aW9uID0+IHtcbiAgICAgIGluc3RydWN0aW9uLmtleXMuZm9yRWFjaChhY2NvdW50TWV0YSA9PiB7XG4gICAgICAgIGFjY291bnRNZXRhcy5wdXNoKHtcbiAgICAgICAgICAuLi5hY2NvdW50TWV0YVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcHJvZ3JhbUlkID0gaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkLnRvU3RyaW5nKCk7XG4gICAgICBpZiAoIXByb2dyYW1JZHMuaW5jbHVkZXMocHJvZ3JhbUlkKSkge1xuICAgICAgICBwcm9ncmFtSWRzLnB1c2gocHJvZ3JhbUlkKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIEFwcGVuZCBwcm9ncmFtSUQgYWNjb3VudCBtZXRhc1xuICAgIHByb2dyYW1JZHMuZm9yRWFjaChwcm9ncmFtSWQgPT4ge1xuICAgICAgYWNjb3VudE1ldGFzLnB1c2goe1xuICAgICAgICBwdWJrZXk6IG5ldyBQdWJsaWNLZXkocHJvZ3JhbUlkKSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyBDdWxsIGR1cGxpY2F0ZSBhY2NvdW50IG1ldGFzXG4gICAgY29uc3QgdW5pcXVlTWV0YXMgPSBbXTtcbiAgICBhY2NvdW50TWV0YXMuZm9yRWFjaChhY2NvdW50TWV0YSA9PiB7XG4gICAgICBjb25zdCBwdWJrZXlTdHJpbmcgPSBhY2NvdW50TWV0YS5wdWJrZXkudG9TdHJpbmcoKTtcbiAgICAgIGNvbnN0IHVuaXF1ZUluZGV4ID0gdW5pcXVlTWV0YXMuZmluZEluZGV4KHggPT4ge1xuICAgICAgICByZXR1cm4geC5wdWJrZXkudG9TdHJpbmcoKSA9PT0gcHVia2V5U3RyaW5nO1xuICAgICAgfSk7XG4gICAgICBpZiAodW5pcXVlSW5kZXggPiAtMSkge1xuICAgICAgICB1bmlxdWVNZXRhc1t1bmlxdWVJbmRleF0uaXNXcml0YWJsZSA9IHVuaXF1ZU1ldGFzW3VuaXF1ZUluZGV4XS5pc1dyaXRhYmxlIHx8IGFjY291bnRNZXRhLmlzV3JpdGFibGU7XG4gICAgICAgIHVuaXF1ZU1ldGFzW3VuaXF1ZUluZGV4XS5pc1NpZ25lciA9IHVuaXF1ZU1ldGFzW3VuaXF1ZUluZGV4XS5pc1NpZ25lciB8fCBhY2NvdW50TWV0YS5pc1NpZ25lcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVuaXF1ZU1ldGFzLnB1c2goYWNjb3VudE1ldGEpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gU29ydC4gUHJpb3JpdGl6aW5nIGZpcnN0IGJ5IHNpZ25lciwgdGhlbiBieSB3cml0YWJsZVxuICAgIHVuaXF1ZU1ldGFzLnNvcnQoZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIGlmICh4LmlzU2lnbmVyICE9PSB5LmlzU2lnbmVyKSB7XG4gICAgICAgIC8vIFNpZ25lcnMgYWx3YXlzIGNvbWUgYmVmb3JlIG5vbi1zaWduZXJzXG4gICAgICAgIHJldHVybiB4LmlzU2lnbmVyID8gLTEgOiAxO1xuICAgICAgfVxuICAgICAgaWYgKHguaXNXcml0YWJsZSAhPT0geS5pc1dyaXRhYmxlKSB7XG4gICAgICAgIC8vIFdyaXRhYmxlIGFjY291bnRzIGFsd2F5cyBjb21lIGJlZm9yZSByZWFkLW9ubHkgYWNjb3VudHNcbiAgICAgICAgcmV0dXJuIHguaXNXcml0YWJsZSA/IC0xIDogMTtcbiAgICAgIH1cbiAgICAgIC8vIE90aGVyd2lzZSwgc29ydCBieSBwdWJrZXksIHN0cmluZ3dpc2UuXG4gICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICBsb2NhbGVNYXRjaGVyOiAnYmVzdCBmaXQnLFxuICAgICAgICB1c2FnZTogJ3NvcnQnLFxuICAgICAgICBzZW5zaXRpdml0eTogJ3ZhcmlhbnQnLFxuICAgICAgICBpZ25vcmVQdW5jdHVhdGlvbjogZmFsc2UsXG4gICAgICAgIG51bWVyaWM6IGZhbHNlLFxuICAgICAgICBjYXNlRmlyc3Q6ICdsb3dlcidcbiAgICAgIH07XG4gICAgICByZXR1cm4geC5wdWJrZXkudG9CYXNlNTgoKS5sb2NhbGVDb21wYXJlKHkucHVia2V5LnRvQmFzZTU4KCksICdlbicsIG9wdGlvbnMpO1xuICAgIH0pO1xuXG4gICAgLy8gTW92ZSBmZWUgcGF5ZXIgdG8gdGhlIGZyb250XG4gICAgY29uc3QgZmVlUGF5ZXJJbmRleCA9IHVuaXF1ZU1ldGFzLmZpbmRJbmRleCh4ID0+IHtcbiAgICAgIHJldHVybiB4LnB1YmtleS5lcXVhbHMoZmVlUGF5ZXIpO1xuICAgIH0pO1xuICAgIGlmIChmZWVQYXllckluZGV4ID4gLTEpIHtcbiAgICAgIGNvbnN0IFtwYXllck1ldGFdID0gdW5pcXVlTWV0YXMuc3BsaWNlKGZlZVBheWVySW5kZXgsIDEpO1xuICAgICAgcGF5ZXJNZXRhLmlzU2lnbmVyID0gdHJ1ZTtcbiAgICAgIHBheWVyTWV0YS5pc1dyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIHVuaXF1ZU1ldGFzLnVuc2hpZnQocGF5ZXJNZXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdW5pcXVlTWV0YXMudW5zaGlmdCh7XG4gICAgICAgIHB1YmtleTogZmVlUGF5ZXIsXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBEaXNhbGxvdyB1bmtub3duIHNpZ25lcnNcbiAgICBmb3IgKGNvbnN0IHNpZ25hdHVyZSBvZiB0aGlzLnNpZ25hdHVyZXMpIHtcbiAgICAgIGNvbnN0IHVuaXF1ZUluZGV4ID0gdW5pcXVlTWV0YXMuZmluZEluZGV4KHggPT4ge1xuICAgICAgICByZXR1cm4geC5wdWJrZXkuZXF1YWxzKHNpZ25hdHVyZS5wdWJsaWNLZXkpO1xuICAgICAgfSk7XG4gICAgICBpZiAodW5pcXVlSW5kZXggPiAtMSkge1xuICAgICAgICBpZiAoIXVuaXF1ZU1ldGFzW3VuaXF1ZUluZGV4XS5pc1NpZ25lcikge1xuICAgICAgICAgIHVuaXF1ZU1ldGFzW3VuaXF1ZUluZGV4XS5pc1NpZ25lciA9IHRydWU7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdUcmFuc2FjdGlvbiByZWZlcmVuY2VzIGEgc2lnbmF0dXJlIHRoYXQgaXMgdW5uZWNlc3NhcnksICcgKyAnb25seSB0aGUgZmVlIHBheWVyIGFuZCBpbnN0cnVjdGlvbiBzaWduZXIgYWNjb3VudHMgc2hvdWxkIHNpZ24gYSB0cmFuc2FjdGlvbi4gJyArICdUaGlzIGJlaGF2aW9yIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgdGhyb3cgYW4gZXJyb3IgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiByZWxlYXNlLicpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gc2lnbmVyOiAke3NpZ25hdHVyZS5wdWJsaWNLZXkudG9TdHJpbmcoKX1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IG51bVJlcXVpcmVkU2lnbmF0dXJlcyA9IDA7XG4gICAgbGV0IG51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHMgPSAwO1xuICAgIGxldCBudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHMgPSAwO1xuXG4gICAgLy8gU3BsaXQgb3V0IHNpZ25pbmcgZnJvbSBub24tc2lnbmluZyBrZXlzIGFuZCBjb3VudCBoZWFkZXIgdmFsdWVzXG4gICAgY29uc3Qgc2lnbmVkS2V5cyA9IFtdO1xuICAgIGNvbnN0IHVuc2lnbmVkS2V5cyA9IFtdO1xuICAgIHVuaXF1ZU1ldGFzLmZvckVhY2goKHtcbiAgICAgIHB1YmtleSxcbiAgICAgIGlzU2lnbmVyLFxuICAgICAgaXNXcml0YWJsZVxuICAgIH0pID0+IHtcbiAgICAgIGlmIChpc1NpZ25lcikge1xuICAgICAgICBzaWduZWRLZXlzLnB1c2gocHVia2V5LnRvU3RyaW5nKCkpO1xuICAgICAgICBudW1SZXF1aXJlZFNpZ25hdHVyZXMgKz0gMTtcbiAgICAgICAgaWYgKCFpc1dyaXRhYmxlKSB7XG4gICAgICAgICAgbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50cyArPSAxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1bnNpZ25lZEtleXMucHVzaChwdWJrZXkudG9TdHJpbmcoKSk7XG4gICAgICAgIGlmICghaXNXcml0YWJsZSkge1xuICAgICAgICAgIG51bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50cyArPSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgYWNjb3VudEtleXMgPSBzaWduZWRLZXlzLmNvbmNhdCh1bnNpZ25lZEtleXMpO1xuICAgIGNvbnN0IGNvbXBpbGVkSW5zdHJ1Y3Rpb25zID0gaW5zdHJ1Y3Rpb25zLm1hcChpbnN0cnVjdGlvbiA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRhdGEsXG4gICAgICAgIHByb2dyYW1JZFxuICAgICAgfSA9IGluc3RydWN0aW9uO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHJvZ3JhbUlkSW5kZXg6IGFjY291bnRLZXlzLmluZGV4T2YocHJvZ3JhbUlkLnRvU3RyaW5nKCkpLFxuICAgICAgICBhY2NvdW50czogaW5zdHJ1Y3Rpb24ua2V5cy5tYXAobWV0YSA9PiBhY2NvdW50S2V5cy5pbmRleE9mKG1ldGEucHVia2V5LnRvU3RyaW5nKCkpKSxcbiAgICAgICAgZGF0YTogYnM1OF9fZGVmYXVsdC5kZWZhdWx0LmVuY29kZShkYXRhKVxuICAgICAgfTtcbiAgICB9KTtcbiAgICBjb21waWxlZEluc3RydWN0aW9ucy5mb3JFYWNoKGluc3RydWN0aW9uID0+IHtcbiAgICAgIGFzc2VydChpbnN0cnVjdGlvbi5wcm9ncmFtSWRJbmRleCA+PSAwKTtcbiAgICAgIGluc3RydWN0aW9uLmFjY291bnRzLmZvckVhY2goa2V5SW5kZXggPT4gYXNzZXJ0KGtleUluZGV4ID49IDApKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IE1lc3NhZ2Uoe1xuICAgICAgaGVhZGVyOiB7XG4gICAgICAgIG51bVJlcXVpcmVkU2lnbmF0dXJlcyxcbiAgICAgICAgbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50cyxcbiAgICAgICAgbnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzXG4gICAgICB9LFxuICAgICAgYWNjb3VudEtleXMsXG4gICAgICByZWNlbnRCbG9ja2hhc2gsXG4gICAgICBpbnN0cnVjdGlvbnM6IGNvbXBpbGVkSW5zdHJ1Y3Rpb25zXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfY29tcGlsZSgpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5jb21waWxlTWVzc2FnZSgpO1xuICAgIGNvbnN0IHNpZ25lZEtleXMgPSBtZXNzYWdlLmFjY291bnRLZXlzLnNsaWNlKDAsIG1lc3NhZ2UuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcyk7XG4gICAgaWYgKHRoaXMuc2lnbmF0dXJlcy5sZW5ndGggPT09IHNpZ25lZEtleXMubGVuZ3RoKSB7XG4gICAgICBjb25zdCB2YWxpZCA9IHRoaXMuc2lnbmF0dXJlcy5ldmVyeSgocGFpciwgaW5kZXgpID0+IHtcbiAgICAgICAgcmV0dXJuIHNpZ25lZEtleXNbaW5kZXhdLmVxdWFscyhwYWlyLnB1YmxpY0tleSk7XG4gICAgICB9KTtcbiAgICAgIGlmICh2YWxpZCkgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIHRoaXMuc2lnbmF0dXJlcyA9IHNpZ25lZEtleXMubWFwKHB1YmxpY0tleSA9PiAoe1xuICAgICAgc2lnbmF0dXJlOiBudWxsLFxuICAgICAgcHVibGljS2V5XG4gICAgfSkpO1xuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIGJ1ZmZlciBvZiB0aGUgVHJhbnNhY3Rpb24gZGF0YSB0aGF0IG5lZWQgdG8gYmUgY292ZXJlZCBieSBzaWduYXR1cmVzXG4gICAqL1xuICBzZXJpYWxpemVNZXNzYWdlKCkge1xuICAgIHJldHVybiB0aGlzLl9jb21waWxlKCkuc2VyaWFsaXplKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBlc3RpbWF0ZWQgZmVlIGFzc29jaWF0ZWQgd2l0aCBhIHRyYW5zYWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7Q29ubmVjdGlvbn0gY29ubmVjdGlvbiBDb25uZWN0aW9uIHRvIFJQQyBFbmRwb2ludC5cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8bnVtYmVyIHwgbnVsbD59IFRoZSBlc3RpbWF0ZWQgZmVlIGZvciB0aGUgdHJhbnNhY3Rpb25cbiAgICovXG4gIGFzeW5jIGdldEVzdGltYXRlZEZlZShjb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuIChhd2FpdCBjb25uZWN0aW9uLmdldEZlZUZvck1lc3NhZ2UodGhpcy5jb21waWxlTWVzc2FnZSgpKSkudmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogU3BlY2lmeSB0aGUgcHVibGljIGtleXMgd2hpY2ggd2lsbCBiZSB1c2VkIHRvIHNpZ24gdGhlIFRyYW5zYWN0aW9uLlxuICAgKiBUaGUgZmlyc3Qgc2lnbmVyIHdpbGwgYmUgdXNlZCBhcyB0aGUgdHJhbnNhY3Rpb24gZmVlIHBheWVyIGFjY291bnQuXG4gICAqXG4gICAqIFNpZ25hdHVyZXMgY2FuIGJlIGFkZGVkIHdpdGggZWl0aGVyIGBwYXJ0aWFsU2lnbmAgb3IgYGFkZFNpZ25hdHVyZWBcbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSB2MC44NC4wLiBPbmx5IHRoZSBmZWUgcGF5ZXIgbmVlZHMgdG8gYmVcbiAgICogc3BlY2lmaWVkIGFuZCBpdCBjYW4gYmUgc2V0IGluIHRoZSBUcmFuc2FjdGlvbiBjb25zdHJ1Y3RvciBvciB3aXRoIHRoZVxuICAgKiBgZmVlUGF5ZXJgIHByb3BlcnR5LlxuICAgKi9cbiAgc2V0U2lnbmVycyguLi5zaWduZXJzKSB7XG4gICAgaWYgKHNpZ25lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHNpZ25lcnMnKTtcbiAgICB9XG4gICAgY29uc3Qgc2VlbiA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLnNpZ25hdHVyZXMgPSBzaWduZXJzLmZpbHRlcihwdWJsaWNLZXkgPT4ge1xuICAgICAgY29uc3Qga2V5ID0gcHVibGljS2V5LnRvU3RyaW5nKCk7XG4gICAgICBpZiAoc2Vlbi5oYXMoa2V5KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWVuLmFkZChrZXkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KS5tYXAocHVibGljS2V5ID0+ICh7XG4gICAgICBzaWduYXR1cmU6IG51bGwsXG4gICAgICBwdWJsaWNLZXlcbiAgICB9KSk7XG4gIH1cblxuICAvKipcbiAgICogU2lnbiB0aGUgVHJhbnNhY3Rpb24gd2l0aCB0aGUgc3BlY2lmaWVkIHNpZ25lcnMuIE11bHRpcGxlIHNpZ25hdHVyZXMgbWF5XG4gICAqIGJlIGFwcGxpZWQgdG8gYSBUcmFuc2FjdGlvbi4gVGhlIGZpcnN0IHNpZ25hdHVyZSBpcyBjb25zaWRlcmVkIFwicHJpbWFyeVwiXG4gICAqIGFuZCBpcyB1c2VkIGlkZW50aWZ5IGFuZCBjb25maXJtIHRyYW5zYWN0aW9ucy5cbiAgICpcbiAgICogSWYgdGhlIFRyYW5zYWN0aW9uIGBmZWVQYXllcmAgaXMgbm90IHNldCwgdGhlIGZpcnN0IHNpZ25lciB3aWxsIGJlIHVzZWRcbiAgICogYXMgdGhlIHRyYW5zYWN0aW9uIGZlZSBwYXllciBhY2NvdW50LlxuICAgKlxuICAgKiBUcmFuc2FjdGlvbiBmaWVsZHMgc2hvdWxkIG5vdCBiZSBtb2RpZmllZCBhZnRlciB0aGUgZmlyc3QgY2FsbCB0byBgc2lnbmAsXG4gICAqIGFzIGRvaW5nIHNvIG1heSBpbnZhbGlkYXRlIHRoZSBzaWduYXR1cmUgYW5kIGNhdXNlIHRoZSBUcmFuc2FjdGlvbiB0byBiZVxuICAgKiByZWplY3RlZC5cbiAgICpcbiAgICogVGhlIFRyYW5zYWN0aW9uIG11c3QgYmUgYXNzaWduZWQgYSB2YWxpZCBgcmVjZW50QmxvY2toYXNoYCBiZWZvcmUgaW52b2tpbmcgdGhpcyBtZXRob2RcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxTaWduZXI+fSBzaWduZXJzIEFycmF5IG9mIHNpZ25lcnMgdGhhdCB3aWxsIHNpZ24gdGhlIHRyYW5zYWN0aW9uXG4gICAqL1xuICBzaWduKC4uLnNpZ25lcnMpIHtcbiAgICBpZiAoc2lnbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc2lnbmVycycpO1xuICAgIH1cblxuICAgIC8vIERlZHVwZSBzaWduZXJzXG4gICAgY29uc3Qgc2VlbiA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCB1bmlxdWVTaWduZXJzID0gW107XG4gICAgZm9yIChjb25zdCBzaWduZXIgb2Ygc2lnbmVycykge1xuICAgICAgY29uc3Qga2V5ID0gc2lnbmVyLnB1YmxpY0tleS50b1N0cmluZygpO1xuICAgICAgaWYgKHNlZW4uaGFzKGtleSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWVuLmFkZChrZXkpO1xuICAgICAgICB1bmlxdWVTaWduZXJzLnB1c2goc2lnbmVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5zaWduYXR1cmVzID0gdW5pcXVlU2lnbmVycy5tYXAoc2lnbmVyID0+ICh7XG4gICAgICBzaWduYXR1cmU6IG51bGwsXG4gICAgICBwdWJsaWNLZXk6IHNpZ25lci5wdWJsaWNLZXlcbiAgICB9KSk7XG4gICAgY29uc3QgbWVzc2FnZSA9IHRoaXMuX2NvbXBpbGUoKTtcbiAgICB0aGlzLl9wYXJ0aWFsU2lnbihtZXNzYWdlLCAuLi51bmlxdWVTaWduZXJzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJ0aWFsbHkgc2lnbiBhIHRyYW5zYWN0aW9uIHdpdGggdGhlIHNwZWNpZmllZCBhY2NvdW50cy4gQWxsIGFjY291bnRzIG11c3RcbiAgICogY29ycmVzcG9uZCB0byBlaXRoZXIgdGhlIGZlZSBwYXllciBvciBhIHNpZ25lciBhY2NvdW50IGluIHRoZSB0cmFuc2FjdGlvblxuICAgKiBpbnN0cnVjdGlvbnMuXG4gICAqXG4gICAqIEFsbCB0aGUgY2F2ZWF0cyBmcm9tIHRoZSBgc2lnbmAgbWV0aG9kIGFwcGx5IHRvIGBwYXJ0aWFsU2lnbmBcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxTaWduZXI+fSBzaWduZXJzIEFycmF5IG9mIHNpZ25lcnMgdGhhdCB3aWxsIHNpZ24gdGhlIHRyYW5zYWN0aW9uXG4gICAqL1xuICBwYXJ0aWFsU2lnbiguLi5zaWduZXJzKSB7XG4gICAgaWYgKHNpZ25lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHNpZ25lcnMnKTtcbiAgICB9XG5cbiAgICAvLyBEZWR1cGUgc2lnbmVyc1xuICAgIGNvbnN0IHNlZW4gPSBuZXcgU2V0KCk7XG4gICAgY29uc3QgdW5pcXVlU2lnbmVycyA9IFtdO1xuICAgIGZvciAoY29uc3Qgc2lnbmVyIG9mIHNpZ25lcnMpIHtcbiAgICAgIGNvbnN0IGtleSA9IHNpZ25lci5wdWJsaWNLZXkudG9TdHJpbmcoKTtcbiAgICAgIGlmIChzZWVuLmhhcyhrZXkpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2Vlbi5hZGQoa2V5KTtcbiAgICAgICAgdW5pcXVlU2lnbmVycy5wdXNoKHNpZ25lcik7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG1lc3NhZ2UgPSB0aGlzLl9jb21waWxlKCk7XG4gICAgdGhpcy5fcGFydGlhbFNpZ24obWVzc2FnZSwgLi4udW5pcXVlU2lnbmVycyk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfcGFydGlhbFNpZ24obWVzc2FnZSwgLi4uc2lnbmVycykge1xuICAgIGNvbnN0IHNpZ25EYXRhID0gbWVzc2FnZS5zZXJpYWxpemUoKTtcbiAgICBzaWduZXJzLmZvckVhY2goc2lnbmVyID0+IHtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHNpZ24oc2lnbkRhdGEsIHNpZ25lci5zZWNyZXRLZXkpO1xuICAgICAgdGhpcy5fYWRkU2lnbmF0dXJlKHNpZ25lci5wdWJsaWNLZXksIHRvQnVmZmVyKHNpZ25hdHVyZSkpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhbiBleHRlcm5hbGx5IGNyZWF0ZWQgc2lnbmF0dXJlIHRvIGEgdHJhbnNhY3Rpb24uIFRoZSBwdWJsaWMga2V5XG4gICAqIG11c3QgY29ycmVzcG9uZCB0byBlaXRoZXIgdGhlIGZlZSBwYXllciBvciBhIHNpZ25lciBhY2NvdW50IGluIHRoZSB0cmFuc2FjdGlvblxuICAgKiBpbnN0cnVjdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7UHVibGljS2V5fSBwdWJrZXkgUHVibGljIGtleSB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIHRyYW5zYWN0aW9uLlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gc2lnbmF0dXJlIEFuIGV4dGVybmFsbHkgY3JlYXRlZCBzaWduYXR1cmUgdG8gYWRkIHRvIHRoZSB0cmFuc2FjdGlvbi5cbiAgICovXG4gIGFkZFNpZ25hdHVyZShwdWJrZXksIHNpZ25hdHVyZSkge1xuICAgIHRoaXMuX2NvbXBpbGUoKTsgLy8gRW5zdXJlIHNpZ25hdHVyZXMgYXJyYXkgaXMgcG9wdWxhdGVkXG4gICAgdGhpcy5fYWRkU2lnbmF0dXJlKHB1YmtleSwgc2lnbmF0dXJlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9hZGRTaWduYXR1cmUocHVia2V5LCBzaWduYXR1cmUpIHtcbiAgICBhc3NlcnQoc2lnbmF0dXJlLmxlbmd0aCA9PT0gNjQpO1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5zaWduYXR1cmVzLmZpbmRJbmRleChzaWdwYWlyID0+IHB1YmtleS5lcXVhbHMoc2lncGFpci5wdWJsaWNLZXkpKTtcbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gc2lnbmVyOiAke3B1YmtleS50b1N0cmluZygpfWApO1xuICAgIH1cbiAgICB0aGlzLnNpZ25hdHVyZXNbaW5kZXhdLnNpZ25hdHVyZSA9IGJ1ZmZlci5CdWZmZXIuZnJvbShzaWduYXR1cmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmeSBzaWduYXR1cmVzIG9mIGEgVHJhbnNhY3Rpb25cbiAgICogT3B0aW9uYWwgcGFyYW1ldGVyIHNwZWNpZmllcyBpZiB3ZSdyZSBleHBlY3RpbmcgYSBmdWxseSBzaWduZWQgVHJhbnNhY3Rpb24gb3IgYSBwYXJ0aWFsbHkgc2lnbmVkIG9uZS5cbiAgICogSWYgbm8gYm9vbGVhbiBpcyBwcm92aWRlZCwgd2UgZXhwZWN0IGEgZnVsbHkgc2lnbmVkIFRyYW5zYWN0aW9uIGJ5IGRlZmF1bHQuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlcXVpcmVBbGxTaWduYXR1cmVzPXRydWVdIFJlcXVpcmUgYSBmdWxseSBzaWduZWQgVHJhbnNhY3Rpb25cbiAgICovXG4gIHZlcmlmeVNpZ25hdHVyZXMocmVxdWlyZUFsbFNpZ25hdHVyZXMgPSB0cnVlKSB7XG4gICAgY29uc3Qgc2lnbmF0dXJlRXJyb3JzID0gdGhpcy5fZ2V0TWVzc2FnZVNpZ25lZG5lc3NFcnJvcnModGhpcy5zZXJpYWxpemVNZXNzYWdlKCksIHJlcXVpcmVBbGxTaWduYXR1cmVzKTtcbiAgICByZXR1cm4gIXNpZ25hdHVyZUVycm9ycztcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9nZXRNZXNzYWdlU2lnbmVkbmVzc0Vycm9ycyhtZXNzYWdlLCByZXF1aXJlQWxsU2lnbmF0dXJlcykge1xuICAgIGNvbnN0IGVycm9ycyA9IHt9O1xuICAgIGZvciAoY29uc3Qge1xuICAgICAgc2lnbmF0dXJlLFxuICAgICAgcHVibGljS2V5XG4gICAgfSBvZiB0aGlzLnNpZ25hdHVyZXMpIHtcbiAgICAgIGlmIChzaWduYXR1cmUgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKHJlcXVpcmVBbGxTaWduYXR1cmVzKSB7XG4gICAgICAgICAgKGVycm9ycy5taXNzaW5nIHx8PSBbXSkucHVzaChwdWJsaWNLZXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXZlcmlmeShzaWduYXR1cmUsIG1lc3NhZ2UsIHB1YmxpY0tleS50b0J5dGVzKCkpKSB7XG4gICAgICAgICAgKGVycm9ycy5pbnZhbGlkIHx8PSBbXSkucHVzaChwdWJsaWNLZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlcnJvcnMuaW52YWxpZCB8fCBlcnJvcnMubWlzc2luZyA/IGVycm9ycyA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXJpYWxpemUgdGhlIFRyYW5zYWN0aW9uIGluIHRoZSB3aXJlIGZvcm1hdC5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IFtjb25maWddIENvbmZpZyBvZiB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogQHJldHVybnMge0J1ZmZlcn0gU2lnbmF0dXJlIG9mIHRyYW5zYWN0aW9uIGluIHdpcmUgZm9ybWF0LlxuICAgKi9cbiAgc2VyaWFsaXplKGNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlcXVpcmVBbGxTaWduYXR1cmVzLFxuICAgICAgdmVyaWZ5U2lnbmF0dXJlc1xuICAgIH0gPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIHJlcXVpcmVBbGxTaWduYXR1cmVzOiB0cnVlLFxuICAgICAgdmVyaWZ5U2lnbmF0dXJlczogdHJ1ZVxuICAgIH0sIGNvbmZpZyk7XG4gICAgY29uc3Qgc2lnbkRhdGEgPSB0aGlzLnNlcmlhbGl6ZU1lc3NhZ2UoKTtcbiAgICBpZiAodmVyaWZ5U2lnbmF0dXJlcykge1xuICAgICAgY29uc3Qgc2lnRXJyb3JzID0gdGhpcy5fZ2V0TWVzc2FnZVNpZ25lZG5lc3NFcnJvcnMoc2lnbkRhdGEsIHJlcXVpcmVBbGxTaWduYXR1cmVzKTtcbiAgICAgIGlmIChzaWdFcnJvcnMpIHtcbiAgICAgICAgbGV0IGVycm9yTWVzc2FnZSA9ICdTaWduYXR1cmUgdmVyaWZpY2F0aW9uIGZhaWxlZC4nO1xuICAgICAgICBpZiAoc2lnRXJyb3JzLmludmFsaWQpIHtcbiAgICAgICAgICBlcnJvck1lc3NhZ2UgKz0gYFxcbkludmFsaWQgc2lnbmF0dXJlIGZvciBwdWJsaWMga2V5JHtzaWdFcnJvcnMuaW52YWxpZC5sZW5ndGggPT09IDEgPyAnJyA6ICcocyknfSBbXFxgJHtzaWdFcnJvcnMuaW52YWxpZC5tYXAocCA9PiBwLnRvQmFzZTU4KCkpLmpvaW4oJ2AsIGAnKX1cXGBdLmA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNpZ0Vycm9ycy5taXNzaW5nKSB7XG4gICAgICAgICAgZXJyb3JNZXNzYWdlICs9IGBcXG5NaXNzaW5nIHNpZ25hdHVyZSBmb3IgcHVibGljIGtleSR7c2lnRXJyb3JzLm1pc3NpbmcubGVuZ3RoID09PSAxID8gJycgOiAnKHMpJ30gW1xcYCR7c2lnRXJyb3JzLm1pc3NpbmcubWFwKHAgPT4gcC50b0Jhc2U1OCgpKS5qb2luKCdgLCBgJyl9XFxgXS5gO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc2VyaWFsaXplKHNpZ25EYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9zZXJpYWxpemUoc2lnbkRhdGEpIHtcbiAgICBjb25zdCB7XG4gICAgICBzaWduYXR1cmVzXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qgc2lnbmF0dXJlQ291bnQgPSBbXTtcbiAgICBlbmNvZGVMZW5ndGgoc2lnbmF0dXJlQ291bnQsIHNpZ25hdHVyZXMubGVuZ3RoKTtcbiAgICBjb25zdCB0cmFuc2FjdGlvbkxlbmd0aCA9IHNpZ25hdHVyZUNvdW50Lmxlbmd0aCArIHNpZ25hdHVyZXMubGVuZ3RoICogNjQgKyBzaWduRGF0YS5sZW5ndGg7XG4gICAgY29uc3Qgd2lyZVRyYW5zYWN0aW9uID0gYnVmZmVyLkJ1ZmZlci5hbGxvYyh0cmFuc2FjdGlvbkxlbmd0aCk7XG4gICAgYXNzZXJ0KHNpZ25hdHVyZXMubGVuZ3RoIDwgMjU2KTtcbiAgICBidWZmZXIuQnVmZmVyLmZyb20oc2lnbmF0dXJlQ291bnQpLmNvcHkod2lyZVRyYW5zYWN0aW9uLCAwKTtcbiAgICBzaWduYXR1cmVzLmZvckVhY2goKHtcbiAgICAgIHNpZ25hdHVyZVxuICAgIH0sIGluZGV4KSA9PiB7XG4gICAgICBpZiAoc2lnbmF0dXJlICE9PSBudWxsKSB7XG4gICAgICAgIGFzc2VydChzaWduYXR1cmUubGVuZ3RoID09PSA2NCwgYHNpZ25hdHVyZSBoYXMgaW52YWxpZCBsZW5ndGhgKTtcbiAgICAgICAgYnVmZmVyLkJ1ZmZlci5mcm9tKHNpZ25hdHVyZSkuY29weSh3aXJlVHJhbnNhY3Rpb24sIHNpZ25hdHVyZUNvdW50Lmxlbmd0aCArIGluZGV4ICogNjQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHNpZ25EYXRhLmNvcHkod2lyZVRyYW5zYWN0aW9uLCBzaWduYXR1cmVDb3VudC5sZW5ndGggKyBzaWduYXR1cmVzLmxlbmd0aCAqIDY0KTtcbiAgICBhc3NlcnQod2lyZVRyYW5zYWN0aW9uLmxlbmd0aCA8PSBQQUNLRVRfREFUQV9TSVpFLCBgVHJhbnNhY3Rpb24gdG9vIGxhcmdlOiAke3dpcmVUcmFuc2FjdGlvbi5sZW5ndGh9ID4gJHtQQUNLRVRfREFUQV9TSVpFfWApO1xuICAgIHJldHVybiB3aXJlVHJhbnNhY3Rpb247XG4gIH1cblxuICAvKipcbiAgICogRGVwcmVjYXRlZCBtZXRob2RcbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXQga2V5cygpIHtcbiAgICBhc3NlcnQodGhpcy5pbnN0cnVjdGlvbnMubGVuZ3RoID09PSAxKTtcbiAgICByZXR1cm4gdGhpcy5pbnN0cnVjdGlvbnNbMF0ua2V5cy5tYXAoa2V5T2JqID0+IGtleU9iai5wdWJrZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcHJlY2F0ZWQgbWV0aG9kXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZ2V0IHByb2dyYW1JZCgpIHtcbiAgICBhc3NlcnQodGhpcy5pbnN0cnVjdGlvbnMubGVuZ3RoID09PSAxKTtcbiAgICByZXR1cm4gdGhpcy5pbnN0cnVjdGlvbnNbMF0ucHJvZ3JhbUlkO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcHJlY2F0ZWQgbWV0aG9kXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZ2V0IGRhdGEoKSB7XG4gICAgYXNzZXJ0KHRoaXMuaW5zdHJ1Y3Rpb25zLmxlbmd0aCA9PT0gMSk7XG4gICAgcmV0dXJuIHRoaXMuaW5zdHJ1Y3Rpb25zWzBdLmRhdGE7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgYSB3aXJlIHRyYW5zYWN0aW9uIGludG8gYSBUcmFuc2FjdGlvbiBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyIHwgVWludDhBcnJheSB8IEFycmF5PG51bWJlcj59IGJ1ZmZlciBTaWduYXR1cmUgb2Ygd2lyZSBUcmFuc2FjdGlvblxuICAgKlxuICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb259IFRyYW5zYWN0aW9uIGFzc29jaWF0ZWQgd2l0aCB0aGUgc2lnbmF0dXJlXG4gICAqL1xuICBzdGF0aWMgZnJvbShidWZmZXIkMSkge1xuICAgIC8vIFNsaWNlIHVwIHdpcmUgZGF0YVxuICAgIGxldCBieXRlQXJyYXkgPSBbLi4uYnVmZmVyJDFdO1xuICAgIGNvbnN0IHNpZ25hdHVyZUNvdW50ID0gZGVjb2RlTGVuZ3RoKGJ5dGVBcnJheSk7XG4gICAgbGV0IHNpZ25hdHVyZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpZ25hdHVyZUNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGd1YXJkZWRTcGxpY2UoYnl0ZUFycmF5LCAwLCBTSUdOQVRVUkVfTEVOR1RIX0lOX0JZVEVTKTtcbiAgICAgIHNpZ25hdHVyZXMucHVzaChiczU4X19kZWZhdWx0LmRlZmF1bHQuZW5jb2RlKGJ1ZmZlci5CdWZmZXIuZnJvbShzaWduYXR1cmUpKSk7XG4gICAgfVxuICAgIHJldHVybiBUcmFuc2FjdGlvbi5wb3B1bGF0ZShNZXNzYWdlLmZyb20oYnl0ZUFycmF5KSwgc2lnbmF0dXJlcyk7XG4gIH1cblxuICAvKipcbiAgICogUG9wdWxhdGUgVHJhbnNhY3Rpb24gb2JqZWN0IGZyb20gbWVzc2FnZSBhbmQgc2lnbmF0dXJlc1xuICAgKlxuICAgKiBAcGFyYW0ge01lc3NhZ2V9IG1lc3NhZ2UgTWVzc2FnZSBvZiB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IHNpZ25hdHVyZXMgTGlzdCBvZiBzaWduYXR1cmVzIHRvIGFzc2lnbiB0byB0aGUgdHJhbnNhY3Rpb25cbiAgICpcbiAgICogQHJldHVybnMge1RyYW5zYWN0aW9ufSBUaGUgcG9wdWxhdGVkIFRyYW5zYWN0aW9uXG4gICAqL1xuICBzdGF0aWMgcG9wdWxhdGUobWVzc2FnZSwgc2lnbmF0dXJlcyA9IFtdKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICB0cmFuc2FjdGlvbi5yZWNlbnRCbG9ja2hhc2ggPSBtZXNzYWdlLnJlY2VudEJsb2NraGFzaDtcbiAgICBpZiAobWVzc2FnZS5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzID4gMCkge1xuICAgICAgdHJhbnNhY3Rpb24uZmVlUGF5ZXIgPSBtZXNzYWdlLmFjY291bnRLZXlzWzBdO1xuICAgIH1cbiAgICBzaWduYXR1cmVzLmZvckVhY2goKHNpZ25hdHVyZSwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHNpZ1B1YmtleVBhaXIgPSB7XG4gICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlID09IGJzNThfX2RlZmF1bHQuZGVmYXVsdC5lbmNvZGUoREVGQVVMVF9TSUdOQVRVUkUpID8gbnVsbCA6IGJzNThfX2RlZmF1bHQuZGVmYXVsdC5kZWNvZGUoc2lnbmF0dXJlKSxcbiAgICAgICAgcHVibGljS2V5OiBtZXNzYWdlLmFjY291bnRLZXlzW2luZGV4XVxuICAgICAgfTtcbiAgICAgIHRyYW5zYWN0aW9uLnNpZ25hdHVyZXMucHVzaChzaWdQdWJrZXlQYWlyKTtcbiAgICB9KTtcbiAgICBtZXNzYWdlLmluc3RydWN0aW9ucy5mb3JFYWNoKGluc3RydWN0aW9uID0+IHtcbiAgICAgIGNvbnN0IGtleXMgPSBpbnN0cnVjdGlvbi5hY2NvdW50cy5tYXAoYWNjb3VudCA9PiB7XG4gICAgICAgIGNvbnN0IHB1YmtleSA9IG1lc3NhZ2UuYWNjb3VudEtleXNbYWNjb3VudF07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcHVia2V5LFxuICAgICAgICAgIGlzU2lnbmVyOiB0cmFuc2FjdGlvbi5zaWduYXR1cmVzLnNvbWUoa2V5T2JqID0+IGtleU9iai5wdWJsaWNLZXkudG9TdHJpbmcoKSA9PT0gcHVia2V5LnRvU3RyaW5nKCkpIHx8IG1lc3NhZ2UuaXNBY2NvdW50U2lnbmVyKGFjY291bnQpLFxuICAgICAgICAgIGlzV3JpdGFibGU6IG1lc3NhZ2UuaXNBY2NvdW50V3JpdGFibGUoYWNjb3VudClcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgdHJhbnNhY3Rpb24uaW5zdHJ1Y3Rpb25zLnB1c2gobmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAgICBrZXlzLFxuICAgICAgICBwcm9ncmFtSWQ6IG1lc3NhZ2UuYWNjb3VudEtleXNbaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkSW5kZXhdLFxuICAgICAgICBkYXRhOiBiczU4X19kZWZhdWx0LmRlZmF1bHQuZGVjb2RlKGluc3RydWN0aW9uLmRhdGEpXG4gICAgICB9KSk7XG4gICAgfSk7XG4gICAgdHJhbnNhY3Rpb24uX21lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRyYW5zYWN0aW9uLl9qc29uID0gdHJhbnNhY3Rpb24udG9KU09OKCk7XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uO1xuICB9XG59XG5cbmNsYXNzIFRyYW5zYWN0aW9uTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICB0aGlzLnBheWVyS2V5ID0gdm9pZCAwO1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zID0gdm9pZCAwO1xuICAgIHRoaXMucmVjZW50QmxvY2toYXNoID0gdm9pZCAwO1xuICAgIHRoaXMucGF5ZXJLZXkgPSBhcmdzLnBheWVyS2V5O1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zID0gYXJncy5pbnN0cnVjdGlvbnM7XG4gICAgdGhpcy5yZWNlbnRCbG9ja2hhc2ggPSBhcmdzLnJlY2VudEJsb2NraGFzaDtcbiAgfVxuICBzdGF0aWMgZGVjb21waWxlKG1lc3NhZ2UsIGFyZ3MpIHtcbiAgICBjb25zdCB7XG4gICAgICBoZWFkZXIsXG4gICAgICBjb21waWxlZEluc3RydWN0aW9ucyxcbiAgICAgIHJlY2VudEJsb2NraGFzaFxuICAgIH0gPSBtZXNzYWdlO1xuICAgIGNvbnN0IHtcbiAgICAgIG51bVJlcXVpcmVkU2lnbmF0dXJlcyxcbiAgICAgIG51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHMsXG4gICAgICBudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHNcbiAgICB9ID0gaGVhZGVyO1xuICAgIGNvbnN0IG51bVdyaXRhYmxlU2lnbmVkQWNjb3VudHMgPSBudW1SZXF1aXJlZFNpZ25hdHVyZXMgLSBudW1SZWFkb25seVNpZ25lZEFjY291bnRzO1xuICAgIGFzc2VydChudW1Xcml0YWJsZVNpZ25lZEFjY291bnRzID4gMCwgJ01lc3NhZ2UgaGVhZGVyIGlzIGludmFsaWQnKTtcbiAgICBjb25zdCBudW1Xcml0YWJsZVVuc2lnbmVkQWNjb3VudHMgPSBtZXNzYWdlLnN0YXRpY0FjY291bnRLZXlzLmxlbmd0aCAtIG51bVJlcXVpcmVkU2lnbmF0dXJlcyAtIG51bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50cztcbiAgICBhc3NlcnQobnVtV3JpdGFibGVVbnNpZ25lZEFjY291bnRzID49IDAsICdNZXNzYWdlIGhlYWRlciBpcyBpbnZhbGlkJyk7XG4gICAgY29uc3QgYWNjb3VudEtleXMgPSBtZXNzYWdlLmdldEFjY291bnRLZXlzKGFyZ3MpO1xuICAgIGNvbnN0IHBheWVyS2V5ID0gYWNjb3VudEtleXMuZ2V0KDApO1xuICAgIGlmIChwYXllcktleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBkZWNvbXBpbGUgbWVzc2FnZSBiZWNhdXNlIG5vIGFjY291bnQga2V5cyB3ZXJlIGZvdW5kJyk7XG4gICAgfVxuICAgIGNvbnN0IGluc3RydWN0aW9ucyA9IFtdO1xuICAgIGZvciAoY29uc3QgY29tcGlsZWRJeCBvZiBjb21waWxlZEluc3RydWN0aW9ucykge1xuICAgICAgY29uc3Qga2V5cyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBrZXlJbmRleCBvZiBjb21waWxlZEl4LmFjY291bnRLZXlJbmRleGVzKSB7XG4gICAgICAgIGNvbnN0IHB1YmtleSA9IGFjY291bnRLZXlzLmdldChrZXlJbmRleCk7XG4gICAgICAgIGlmIChwdWJrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZpbmQga2V5IGZvciBhY2NvdW50IGtleSBpbmRleCAke2tleUluZGV4fWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzU2lnbmVyID0ga2V5SW5kZXggPCBudW1SZXF1aXJlZFNpZ25hdHVyZXM7XG4gICAgICAgIGxldCBpc1dyaXRhYmxlO1xuICAgICAgICBpZiAoaXNTaWduZXIpIHtcbiAgICAgICAgICBpc1dyaXRhYmxlID0ga2V5SW5kZXggPCBudW1Xcml0YWJsZVNpZ25lZEFjY291bnRzO1xuICAgICAgICB9IGVsc2UgaWYgKGtleUluZGV4IDwgYWNjb3VudEtleXMuc3RhdGljQWNjb3VudEtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgaXNXcml0YWJsZSA9IGtleUluZGV4IC0gbnVtUmVxdWlyZWRTaWduYXR1cmVzIDwgbnVtV3JpdGFibGVVbnNpZ25lZEFjY291bnRzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlzV3JpdGFibGUgPSBrZXlJbmRleCAtIGFjY291bnRLZXlzLnN0YXRpY0FjY291bnRLZXlzLmxlbmd0aCA8XG4gICAgICAgICAgLy8gYWNjb3VudEtleXNGcm9tTG9va3VwcyBjYW5ub3QgYmUgdW5kZWZpbmVkIGJlY2F1c2Ugd2UgYWxyZWFkeSBmb3VuZCBhIHB1YmtleSBmb3IgdGhpcyBpbmRleCBhYm92ZVxuICAgICAgICAgIGFjY291bnRLZXlzLmFjY291bnRLZXlzRnJvbUxvb2t1cHMud3JpdGFibGUubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGtleXMucHVzaCh7XG4gICAgICAgICAgcHVia2V5LFxuICAgICAgICAgIGlzU2lnbmVyOiBrZXlJbmRleCA8IGhlYWRlci5udW1SZXF1aXJlZFNpZ25hdHVyZXMsXG4gICAgICAgICAgaXNXcml0YWJsZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByb2dyYW1JZCA9IGFjY291bnRLZXlzLmdldChjb21waWxlZEl4LnByb2dyYW1JZEluZGV4KTtcbiAgICAgIGlmIChwcm9ncmFtSWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmaW5kIHByb2dyYW0gaWQgZm9yIHByb2dyYW0gaWQgaW5kZXggJHtjb21waWxlZEl4LnByb2dyYW1JZEluZGV4fWApO1xuICAgICAgfVxuICAgICAgaW5zdHJ1Y3Rpb25zLnB1c2gobmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAgICBwcm9ncmFtSWQsXG4gICAgICAgIGRhdGE6IHRvQnVmZmVyKGNvbXBpbGVkSXguZGF0YSksXG4gICAgICAgIGtleXNcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbk1lc3NhZ2Uoe1xuICAgICAgcGF5ZXJLZXksXG4gICAgICBpbnN0cnVjdGlvbnMsXG4gICAgICByZWNlbnRCbG9ja2hhc2hcbiAgICB9KTtcbiAgfVxuICBjb21waWxlVG9MZWdhY3lNZXNzYWdlKCkge1xuICAgIHJldHVybiBNZXNzYWdlLmNvbXBpbGUoe1xuICAgICAgcGF5ZXJLZXk6IHRoaXMucGF5ZXJLZXksXG4gICAgICByZWNlbnRCbG9ja2hhc2g6IHRoaXMucmVjZW50QmxvY2toYXNoLFxuICAgICAgaW5zdHJ1Y3Rpb25zOiB0aGlzLmluc3RydWN0aW9uc1xuICAgIH0pO1xuICB9XG4gIGNvbXBpbGVUb1YwTWVzc2FnZShhZGRyZXNzTG9va3VwVGFibGVBY2NvdW50cykge1xuICAgIHJldHVybiBNZXNzYWdlVjAuY29tcGlsZSh7XG4gICAgICBwYXllcktleTogdGhpcy5wYXllcktleSxcbiAgICAgIHJlY2VudEJsb2NraGFzaDogdGhpcy5yZWNlbnRCbG9ja2hhc2gsXG4gICAgICBpbnN0cnVjdGlvbnM6IHRoaXMuaW5zdHJ1Y3Rpb25zLFxuICAgICAgYWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudHNcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIFZlcnNpb25lZCB0cmFuc2FjdGlvbiBjbGFzc1xuICovXG5jbGFzcyBWZXJzaW9uZWRUcmFuc2FjdGlvbiB7XG4gIGdldCB2ZXJzaW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2UudmVyc2lvbjtcbiAgfVxuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzaWduYXR1cmVzKSB7XG4gICAgdGhpcy5zaWduYXR1cmVzID0gdm9pZCAwO1xuICAgIHRoaXMubWVzc2FnZSA9IHZvaWQgMDtcbiAgICBpZiAoc2lnbmF0dXJlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBhc3NlcnQoc2lnbmF0dXJlcy5sZW5ndGggPT09IG1lc3NhZ2UuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcywgJ0V4cGVjdGVkIHNpZ25hdHVyZXMgbGVuZ3RoIHRvIGJlIGVxdWFsIHRvIHRoZSBudW1iZXIgb2YgcmVxdWlyZWQgc2lnbmF0dXJlcycpO1xuICAgICAgdGhpcy5zaWduYXR1cmVzID0gc2lnbmF0dXJlcztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZGVmYXVsdFNpZ25hdHVyZXMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVzc2FnZS5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzOyBpKyspIHtcbiAgICAgICAgZGVmYXVsdFNpZ25hdHVyZXMucHVzaChuZXcgVWludDhBcnJheShTSUdOQVRVUkVfTEVOR1RIX0lOX0JZVEVTKSk7XG4gICAgICB9XG4gICAgICB0aGlzLnNpZ25hdHVyZXMgPSBkZWZhdWx0U2lnbmF0dXJlcztcbiAgICB9XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgfVxuICBzZXJpYWxpemUoKSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZE1lc3NhZ2UgPSB0aGlzLm1lc3NhZ2Uuc2VyaWFsaXplKCk7XG4gICAgY29uc3QgZW5jb2RlZFNpZ25hdHVyZXNMZW5ndGggPSBBcnJheSgpO1xuICAgIGVuY29kZUxlbmd0aChlbmNvZGVkU2lnbmF0dXJlc0xlbmd0aCwgdGhpcy5zaWduYXR1cmVzLmxlbmd0aCk7XG4gICAgY29uc3QgdHJhbnNhY3Rpb25MYXlvdXQgPSBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5zdHJ1Y3QoW0J1ZmZlckxheW91dF9fbmFtZXNwYWNlLmJsb2IoZW5jb2RlZFNpZ25hdHVyZXNMZW5ndGgubGVuZ3RoLCAnZW5jb2RlZFNpZ25hdHVyZXNMZW5ndGgnKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2Uuc2VxKHNpZ25hdHVyZSgpLCB0aGlzLnNpZ25hdHVyZXMubGVuZ3RoLCAnc2lnbmF0dXJlcycpLCBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5ibG9iKHNlcmlhbGl6ZWRNZXNzYWdlLmxlbmd0aCwgJ3NlcmlhbGl6ZWRNZXNzYWdlJyldKTtcbiAgICBjb25zdCBzZXJpYWxpemVkVHJhbnNhY3Rpb24gPSBuZXcgVWludDhBcnJheSgyMDQ4KTtcbiAgICBjb25zdCBzZXJpYWxpemVkVHJhbnNhY3Rpb25MZW5ndGggPSB0cmFuc2FjdGlvbkxheW91dC5lbmNvZGUoe1xuICAgICAgZW5jb2RlZFNpZ25hdHVyZXNMZW5ndGg6IG5ldyBVaW50OEFycmF5KGVuY29kZWRTaWduYXR1cmVzTGVuZ3RoKSxcbiAgICAgIHNpZ25hdHVyZXM6IHRoaXMuc2lnbmF0dXJlcyxcbiAgICAgIHNlcmlhbGl6ZWRNZXNzYWdlXG4gICAgfSwgc2VyaWFsaXplZFRyYW5zYWN0aW9uKTtcbiAgICByZXR1cm4gc2VyaWFsaXplZFRyYW5zYWN0aW9uLnNsaWNlKDAsIHNlcmlhbGl6ZWRUcmFuc2FjdGlvbkxlbmd0aCk7XG4gIH1cbiAgc3RhdGljIGRlc2VyaWFsaXplKHNlcmlhbGl6ZWRUcmFuc2FjdGlvbikge1xuICAgIGxldCBieXRlQXJyYXkgPSBbLi4uc2VyaWFsaXplZFRyYW5zYWN0aW9uXTtcbiAgICBjb25zdCBzaWduYXR1cmVzID0gW107XG4gICAgY29uc3Qgc2lnbmF0dXJlc0xlbmd0aCA9IGRlY29kZUxlbmd0aChieXRlQXJyYXkpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2lnbmF0dXJlc0xlbmd0aDsgaSsrKSB7XG4gICAgICBzaWduYXR1cmVzLnB1c2gobmV3IFVpbnQ4QXJyYXkoZ3VhcmRlZFNwbGljZShieXRlQXJyYXksIDAsIFNJR05BVFVSRV9MRU5HVEhfSU5fQllURVMpKSk7XG4gICAgfVxuICAgIGNvbnN0IG1lc3NhZ2UgPSBWZXJzaW9uZWRNZXNzYWdlLmRlc2VyaWFsaXplKG5ldyBVaW50OEFycmF5KGJ5dGVBcnJheSkpO1xuICAgIHJldHVybiBuZXcgVmVyc2lvbmVkVHJhbnNhY3Rpb24obWVzc2FnZSwgc2lnbmF0dXJlcyk7XG4gIH1cbiAgc2lnbihzaWduZXJzKSB7XG4gICAgY29uc3QgbWVzc2FnZURhdGEgPSB0aGlzLm1lc3NhZ2Uuc2VyaWFsaXplKCk7XG4gICAgY29uc3Qgc2lnbmVyUHVia2V5cyA9IHRoaXMubWVzc2FnZS5zdGF0aWNBY2NvdW50S2V5cy5zbGljZSgwLCB0aGlzLm1lc3NhZ2UuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcyk7XG4gICAgZm9yIChjb25zdCBzaWduZXIgb2Ygc2lnbmVycykge1xuICAgICAgY29uc3Qgc2lnbmVySW5kZXggPSBzaWduZXJQdWJrZXlzLmZpbmRJbmRleChwdWJrZXkgPT4gcHVia2V5LmVxdWFscyhzaWduZXIucHVibGljS2V5KSk7XG4gICAgICBhc3NlcnQoc2lnbmVySW5kZXggPj0gMCwgYENhbm5vdCBzaWduIHdpdGggbm9uIHNpZ25lciBrZXkgJHtzaWduZXIucHVibGljS2V5LnRvQmFzZTU4KCl9YCk7XG4gICAgICB0aGlzLnNpZ25hdHVyZXNbc2lnbmVySW5kZXhdID0gc2lnbihtZXNzYWdlRGF0YSwgc2lnbmVyLnNlY3JldEtleSk7XG4gICAgfVxuICB9XG4gIGFkZFNpZ25hdHVyZShwdWJsaWNLZXksIHNpZ25hdHVyZSkge1xuICAgIGFzc2VydChzaWduYXR1cmUuYnl0ZUxlbmd0aCA9PT0gNjQsICdTaWduYXR1cmUgbXVzdCBiZSA2NCBieXRlcyBsb25nJyk7XG4gICAgY29uc3Qgc2lnbmVyUHVia2V5cyA9IHRoaXMubWVzc2FnZS5zdGF0aWNBY2NvdW50S2V5cy5zbGljZSgwLCB0aGlzLm1lc3NhZ2UuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcyk7XG4gICAgY29uc3Qgc2lnbmVySW5kZXggPSBzaWduZXJQdWJrZXlzLmZpbmRJbmRleChwdWJrZXkgPT4gcHVia2V5LmVxdWFscyhwdWJsaWNLZXkpKTtcbiAgICBhc3NlcnQoc2lnbmVySW5kZXggPj0gMCwgYENhbiBub3QgYWRkIHNpZ25hdHVyZTsgXFxgJHtwdWJsaWNLZXkudG9CYXNlNTgoKX1cXGAgaXMgbm90IHJlcXVpcmVkIHRvIHNpZ24gdGhpcyB0cmFuc2FjdGlvbmApO1xuICAgIHRoaXMuc2lnbmF0dXJlc1tzaWduZXJJbmRleF0gPSBzaWduYXR1cmU7XG4gIH1cbn1cblxuLy8gVE9ETzogVGhlc2UgY29uc3RhbnRzIHNob3VsZCBiZSByZW1vdmVkIGluIGZhdm9yIG9mIHJlYWRpbmcgdGhlbSBvdXQgb2YgYVxuLy8gU3lzY2FsbCBhY2NvdW50XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IE5VTV9USUNLU19QRVJfU0VDT05EID0gMTYwO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBERUZBVUxUX1RJQ0tTX1BFUl9TTE9UID0gNjQ7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IE5VTV9TTE9UU19QRVJfU0VDT05EID0gTlVNX1RJQ0tTX1BFUl9TRUNPTkQgLyBERUZBVUxUX1RJQ0tTX1BFUl9TTE9UO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBNU19QRVJfU0xPVCA9IDEwMDAgLyBOVU1fU0xPVFNfUEVSX1NFQ09ORDtcblxuY29uc3QgU1lTVkFSX0NMT0NLX1BVQktFWSA9IG5ldyBQdWJsaWNLZXkoJ1N5c3ZhckMxb2NrMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcbmNvbnN0IFNZU1ZBUl9FUE9DSF9TQ0hFRFVMRV9QVUJLRVkgPSBuZXcgUHVibGljS2V5KCdTeXN2YXJFcG9jaFNjaGVkdTFlMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5jb25zdCBTWVNWQVJfSU5TVFJVQ1RJT05TX1BVQktFWSA9IG5ldyBQdWJsaWNLZXkoJ1N5c3ZhcjFuc3RydWN0aW9uczExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcbmNvbnN0IFNZU1ZBUl9SRUNFTlRfQkxPQ0tIQVNIRVNfUFVCS0VZID0gbmV3IFB1YmxpY0tleSgnU3lzdmFyUmVjZW50QjFvY2tIYXNoZXMxMTExMTExMTExMTExMTExMTExMScpO1xuY29uc3QgU1lTVkFSX1JFTlRfUFVCS0VZID0gbmV3IFB1YmxpY0tleSgnU3lzdmFyUmVudDExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuY29uc3QgU1lTVkFSX1JFV0FSRFNfUFVCS0VZID0gbmV3IFB1YmxpY0tleSgnU3lzdmFyUmV3YXJkczExMTExMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuY29uc3QgU1lTVkFSX1NMT1RfSEFTSEVTX1BVQktFWSA9IG5ldyBQdWJsaWNLZXkoJ1N5c3ZhclMxb3RIYXNoZXMxMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcbmNvbnN0IFNZU1ZBUl9TTE9UX0hJU1RPUllfUFVCS0VZID0gbmV3IFB1YmxpY0tleSgnU3lzdmFyUzFvdEhpc3RvcnkxMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuY29uc3QgU1lTVkFSX1NUQUtFX0hJU1RPUllfUFVCS0VZID0gbmV3IFB1YmxpY0tleSgnU3lzdmFyU3Rha2VIaXN0b3J5MTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuXG4vKipcbiAqIFNpZ24sIHNlbmQgYW5kIGNvbmZpcm0gYSB0cmFuc2FjdGlvbi5cbiAqXG4gKiBJZiBgY29tbWl0bWVudGAgb3B0aW9uIGlzIG5vdCBzcGVjaWZpZWQsIGRlZmF1bHRzIHRvICdtYXgnIGNvbW1pdG1lbnQuXG4gKlxuICogQHBhcmFtIHtDb25uZWN0aW9ufSBjb25uZWN0aW9uXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtBcnJheTxTaWduZXI+fSBzaWduZXJzXG4gKiBAcGFyYW0ge0NvbmZpcm1PcHRpb25zfSBbb3B0aW9uc11cbiAqIEByZXR1cm5zIHtQcm9taXNlPFRyYW5zYWN0aW9uU2lnbmF0dXJlPn1cbiAqL1xuYXN5bmMgZnVuY3Rpb24gc2VuZEFuZENvbmZpcm1UcmFuc2FjdGlvbihjb25uZWN0aW9uLCB0cmFuc2FjdGlvbiwgc2lnbmVycywgb3B0aW9ucykge1xuICBjb25zdCBzZW5kT3B0aW9ucyA9IG9wdGlvbnMgJiYge1xuICAgIHNraXBQcmVmbGlnaHQ6IG9wdGlvbnMuc2tpcFByZWZsaWdodCxcbiAgICBwcmVmbGlnaHRDb21taXRtZW50OiBvcHRpb25zLnByZWZsaWdodENvbW1pdG1lbnQgfHwgb3B0aW9ucy5jb21taXRtZW50LFxuICAgIG1heFJldHJpZXM6IG9wdGlvbnMubWF4UmV0cmllcyxcbiAgICBtaW5Db250ZXh0U2xvdDogb3B0aW9ucy5taW5Db250ZXh0U2xvdFxuICB9O1xuICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBjb25uZWN0aW9uLnNlbmRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgc2lnbmVycywgc2VuZE9wdGlvbnMpO1xuICBsZXQgc3RhdHVzO1xuICBpZiAodHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoICE9IG51bGwgJiYgdHJhbnNhY3Rpb24ubGFzdFZhbGlkQmxvY2tIZWlnaHQgIT0gbnVsbCkge1xuICAgIHN0YXR1cyA9IChhd2FpdCBjb25uZWN0aW9uLmNvbmZpcm1UcmFuc2FjdGlvbih7XG4gICAgICBhYm9ydFNpZ25hbDogb3B0aW9ucz8uYWJvcnRTaWduYWwsXG4gICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZSxcbiAgICAgIGJsb2NraGFzaDogdHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoLFxuICAgICAgbGFzdFZhbGlkQmxvY2tIZWlnaHQ6IHRyYW5zYWN0aW9uLmxhc3RWYWxpZEJsb2NrSGVpZ2h0XG4gICAgfSwgb3B0aW9ucyAmJiBvcHRpb25zLmNvbW1pdG1lbnQpKS52YWx1ZTtcbiAgfSBlbHNlIGlmICh0cmFuc2FjdGlvbi5taW5Ob25jZUNvbnRleHRTbG90ICE9IG51bGwgJiYgdHJhbnNhY3Rpb24ubm9uY2VJbmZvICE9IG51bGwpIHtcbiAgICBjb25zdCB7XG4gICAgICBub25jZUluc3RydWN0aW9uXG4gICAgfSA9IHRyYW5zYWN0aW9uLm5vbmNlSW5mbztcbiAgICBjb25zdCBub25jZUFjY291bnRQdWJrZXkgPSBub25jZUluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5O1xuICAgIHN0YXR1cyA9IChhd2FpdCBjb25uZWN0aW9uLmNvbmZpcm1UcmFuc2FjdGlvbih7XG4gICAgICBhYm9ydFNpZ25hbDogb3B0aW9ucz8uYWJvcnRTaWduYWwsXG4gICAgICBtaW5Db250ZXh0U2xvdDogdHJhbnNhY3Rpb24ubWluTm9uY2VDb250ZXh0U2xvdCxcbiAgICAgIG5vbmNlQWNjb3VudFB1YmtleSxcbiAgICAgIG5vbmNlVmFsdWU6IHRyYW5zYWN0aW9uLm5vbmNlSW5mby5ub25jZSxcbiAgICAgIHNpZ25hdHVyZVxuICAgIH0sIG9wdGlvbnMgJiYgb3B0aW9ucy5jb21taXRtZW50KSkudmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgaWYgKG9wdGlvbnM/LmFib3J0U2lnbmFsICE9IG51bGwpIHtcbiAgICAgIGNvbnNvbGUud2Fybignc2VuZEFuZENvbmZpcm1UcmFuc2FjdGlvbigpOiBBIHRyYW5zYWN0aW9uIHdpdGggYSBkZXByZWNhdGVkIGNvbmZpcm1hdGlvbiBzdHJhdGVneSB3YXMgJyArICdzdXBwbGllZCBhbG9uZyB3aXRoIGFuIGBhYm9ydFNpZ25hbGAuIE9ubHkgdHJhbnNhY3Rpb25zIGhhdmluZyBgbGFzdFZhbGlkQmxvY2tIZWlnaHRgICcgKyAnb3IgYSBjb21iaW5hdGlvbiBvZiBgbm9uY2VJbmZvYCBhbmQgYG1pbk5vbmNlQ29udGV4dFNsb3RgIGFyZSBhYm9ydGFibGUuJyk7XG4gICAgfVxuICAgIHN0YXR1cyA9IChhd2FpdCBjb25uZWN0aW9uLmNvbmZpcm1UcmFuc2FjdGlvbihzaWduYXR1cmUsIG9wdGlvbnMgJiYgb3B0aW9ucy5jb21taXRtZW50KSkudmFsdWU7XG4gIH1cbiAgaWYgKHN0YXR1cy5lcnIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRyYW5zYWN0aW9uICR7c2lnbmF0dXJlfSBmYWlsZWQgKCR7SlNPTi5zdHJpbmdpZnkoc3RhdHVzKX0pYCk7XG4gIH1cbiAgcmV0dXJuIHNpZ25hdHVyZTtcbn1cblxuLy8genp6XG5mdW5jdGlvbiBzbGVlcChtcykge1xuICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cblxuLyoqXG4gKiBQb3B1bGF0ZSBhIGJ1ZmZlciBvZiBpbnN0cnVjdGlvbiBkYXRhIHVzaW5nIGFuIEluc3RydWN0aW9uVHlwZVxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGVuY29kZURhdGEodHlwZSwgZmllbGRzKSB7XG4gIGNvbnN0IGFsbG9jTGVuZ3RoID0gdHlwZS5sYXlvdXQuc3BhbiA+PSAwID8gdHlwZS5sYXlvdXQuc3BhbiA6IGdldEFsbG9jKHR5cGUsIGZpZWxkcyk7XG4gIGNvbnN0IGRhdGEgPSBidWZmZXIuQnVmZmVyLmFsbG9jKGFsbG9jTGVuZ3RoKTtcbiAgY29uc3QgbGF5b3V0RmllbGRzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgaW5zdHJ1Y3Rpb246IHR5cGUuaW5kZXhcbiAgfSwgZmllbGRzKTtcbiAgdHlwZS5sYXlvdXQuZW5jb2RlKGxheW91dEZpZWxkcywgZGF0YSk7XG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIERlY29kZSBpbnN0cnVjdGlvbiBkYXRhIGJ1ZmZlciB1c2luZyBhbiBJbnN0cnVjdGlvblR5cGVcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBkZWNvZGVEYXRhJDEodHlwZSwgYnVmZmVyKSB7XG4gIGxldCBkYXRhO1xuICB0cnkge1xuICAgIGRhdGEgPSB0eXBlLmxheW91dC5kZWNvZGUoYnVmZmVyKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGluc3RydWN0aW9uOyAnICsgZXJyKTtcbiAgfVxuICBpZiAoZGF0YS5pbnN0cnVjdGlvbiAhPT0gdHlwZS5pbmRleCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBpbnN0cnVjdGlvbjsgaW5zdHJ1Y3Rpb24gaW5kZXggbWlzbWF0Y2ggJHtkYXRhLmluc3RydWN0aW9ufSAhPSAke3R5cGUuaW5kZXh9YCk7XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3NvbGFuYS1sYWJzL3NvbGFuYS9ibG9iLzkwYmVkZDdlMDY3YjViOGYzZGRiYjQ1ZGEwMGE0ZTljYWJiMjJjNjIvc2RrL3NyYy9mZWVfY2FsY3VsYXRvci5ycyNMNy1MMTFcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgRmVlQ2FsY3VsYXRvckxheW91dCA9IEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLm51NjQoJ2xhbXBvcnRzUGVyU2lnbmF0dXJlJyk7XG5cbi8qKlxuICogQ2FsY3VsYXRvciBmb3IgdHJhbnNhY3Rpb24gZmVlcy5cbiAqXG4gKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFNvbGFuYSB2MS44LjAuXG4gKi9cblxuLyoqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3NvbGFuYS1sYWJzL3NvbGFuYS9ibG9iLzBlYTI4NDNlYzljZGM1MTc1NzJiOGU2MmM5NTlmNDFiNTVjZjQ0NTMvc2RrL3NyYy9ub25jZV9zdGF0ZS5ycyNMMjktTDMyXG4gKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IE5vbmNlQWNjb3VudExheW91dCA9IEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnN0cnVjdChbQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTMyKCd2ZXJzaW9uJyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnUzMignc3RhdGUnKSwgcHVibGljS2V5KCdhdXRob3JpemVkUHVia2V5JyksIHB1YmxpY0tleSgnbm9uY2UnKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2Uuc3RydWN0KFtGZWVDYWxjdWxhdG9yTGF5b3V0XSwgJ2ZlZUNhbGN1bGF0b3InKV0pO1xuY29uc3QgTk9OQ0VfQUNDT1VOVF9MRU5HVEggPSBOb25jZUFjY291bnRMYXlvdXQuc3BhbjtcblxuLyoqXG4gKiBBIGR1cmFibGUgbm9uY2UgaXMgYSAzMiBieXRlIHZhbHVlIGVuY29kZWQgYXMgYSBiYXNlNTggc3RyaW5nLlxuICovXG5cbi8qKlxuICogTm9uY2VBY2NvdW50IGNsYXNzXG4gKi9cbmNsYXNzIE5vbmNlQWNjb3VudCB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICB0aGlzLmF1dGhvcml6ZWRQdWJrZXkgPSB2b2lkIDA7XG4gICAgdGhpcy5ub25jZSA9IHZvaWQgMDtcbiAgICB0aGlzLmZlZUNhbGN1bGF0b3IgPSB2b2lkIDA7XG4gICAgdGhpcy5hdXRob3JpemVkUHVia2V5ID0gYXJncy5hdXRob3JpemVkUHVia2V5O1xuICAgIHRoaXMubm9uY2UgPSBhcmdzLm5vbmNlO1xuICAgIHRoaXMuZmVlQ2FsY3VsYXRvciA9IGFyZ3MuZmVlQ2FsY3VsYXRvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXNlcmlhbGl6ZSBOb25jZUFjY291bnQgZnJvbSB0aGUgYWNjb3VudCBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0gYnVmZmVyIGFjY291bnQgZGF0YVxuICAgKiBAcmV0dXJuIE5vbmNlQWNjb3VudFxuICAgKi9cbiAgc3RhdGljIGZyb21BY2NvdW50RGF0YShidWZmZXIpIHtcbiAgICBjb25zdCBub25jZUFjY291bnQgPSBOb25jZUFjY291bnRMYXlvdXQuZGVjb2RlKHRvQnVmZmVyKGJ1ZmZlciksIDApO1xuICAgIHJldHVybiBuZXcgTm9uY2VBY2NvdW50KHtcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXk6IG5ldyBQdWJsaWNLZXkobm9uY2VBY2NvdW50LmF1dGhvcml6ZWRQdWJrZXkpLFxuICAgICAgbm9uY2U6IG5ldyBQdWJsaWNLZXkobm9uY2VBY2NvdW50Lm5vbmNlKS50b1N0cmluZygpLFxuICAgICAgZmVlQ2FsY3VsYXRvcjogbm9uY2VBY2NvdW50LmZlZUNhbGN1bGF0b3JcbiAgICB9KTtcbiAgfVxufVxuXG5jb25zdCBlbmNvZGVEZWNvZGUgPSBsYXlvdXQgPT4ge1xuICBjb25zdCBkZWNvZGUgPSBsYXlvdXQuZGVjb2RlLmJpbmQobGF5b3V0KTtcbiAgY29uc3QgZW5jb2RlID0gbGF5b3V0LmVuY29kZS5iaW5kKGxheW91dCk7XG4gIHJldHVybiB7XG4gICAgZGVjb2RlLFxuICAgIGVuY29kZVxuICB9O1xufTtcbmNvbnN0IGJpZ0ludCA9IGxlbmd0aCA9PiBwcm9wZXJ0eSA9PiB7XG4gIGNvbnN0IGxheW91dCA9IEJ1ZmZlckxheW91dC5ibG9iKGxlbmd0aCwgcHJvcGVydHkpO1xuICBjb25zdCB7XG4gICAgZW5jb2RlLFxuICAgIGRlY29kZVxuICB9ID0gZW5jb2RlRGVjb2RlKGxheW91dCk7XG4gIGNvbnN0IGJpZ0ludExheW91dCA9IGxheW91dDtcbiAgYmlnSW50TGF5b3V0LmRlY29kZSA9IChidWZmZXIkMSwgb2Zmc2V0KSA9PiB7XG4gICAgY29uc3Qgc3JjID0gZGVjb2RlKGJ1ZmZlciQxLCBvZmZzZXQpO1xuICAgIHJldHVybiBiaWdpbnRCdWZmZXIudG9CaWdJbnRMRShidWZmZXIuQnVmZmVyLmZyb20oc3JjKSk7XG4gIH07XG4gIGJpZ0ludExheW91dC5lbmNvZGUgPSAoYmlnSW50LCBidWZmZXIsIG9mZnNldCkgPT4ge1xuICAgIGNvbnN0IHNyYyA9IGJpZ2ludEJ1ZmZlci50b0J1ZmZlckxFKGJpZ0ludCwgbGVuZ3RoKTtcbiAgICByZXR1cm4gZW5jb2RlKHNyYywgYnVmZmVyLCBvZmZzZXQpO1xuICB9O1xuICByZXR1cm4gYmlnSW50TGF5b3V0O1xufTtcbmNvbnN0IHU2NCA9IGJpZ0ludCg4KTtcblxuLyoqXG4gKiBDcmVhdGUgYWNjb3VudCBzeXN0ZW0gdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBUcmFuc2ZlciBzeXN0ZW0gdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBBc3NpZ24gc3lzdGVtIHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogQ3JlYXRlIGFjY291bnQgd2l0aCBzZWVkIHN5c3RlbSB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZSBub25jZSBhY2NvdW50IHN5c3RlbSB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZSBub25jZSBhY2NvdW50IHdpdGggc2VlZCBzeXN0ZW0gdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBJbml0aWFsaXplIG5vbmNlIGFjY291bnQgc3lzdGVtIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogQWR2YW5jZSBub25jZSBhY2NvdW50IHN5c3RlbSBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIFdpdGhkcmF3IG5vbmNlIGFjY291bnQgc3lzdGVtIHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogQXV0aG9yaXplIG5vbmNlIGFjY291bnQgc3lzdGVtIHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogQWxsb2NhdGUgYWNjb3VudCBzeXN0ZW0gdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBBbGxvY2F0ZSBhY2NvdW50IHdpdGggc2VlZCBzeXN0ZW0gdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBBc3NpZ24gYWNjb3VudCB3aXRoIHNlZWQgc3lzdGVtIHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogVHJhbnNmZXIgd2l0aCBzZWVkIHN5c3RlbSB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKiogRGVjb2RlZCB0cmFuc2ZlciBzeXN0ZW0gdHJhbnNhY3Rpb24gaW5zdHJ1Y3Rpb24gKi9cblxuLyoqIERlY29kZWQgdHJhbnNmZXJXaXRoU2VlZCBzeXN0ZW0gdHJhbnNhY3Rpb24gaW5zdHJ1Y3Rpb24gKi9cblxuLyoqXG4gKiBTeXN0ZW0gSW5zdHJ1Y3Rpb24gY2xhc3NcbiAqL1xuY2xhc3MgU3lzdGVtSW5zdHJ1Y3Rpb24ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHt9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIHN5c3RlbSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHR5cGUuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlSW5zdHJ1Y3Rpb25UeXBlKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIGNvbnN0IGluc3RydWN0aW9uVHlwZUxheW91dCA9IEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnUzMignaW5zdHJ1Y3Rpb24nKTtcbiAgICBjb25zdCB0eXBlSW5kZXggPSBpbnN0cnVjdGlvblR5cGVMYXlvdXQuZGVjb2RlKGluc3RydWN0aW9uLmRhdGEpO1xuICAgIGxldCB0eXBlO1xuICAgIGZvciAoY29uc3QgW2l4VHlwZSwgbGF5b3V0XSBvZiBPYmplY3QuZW50cmllcyhTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUykpIHtcbiAgICAgIGlmIChsYXlvdXQuaW5kZXggPT0gdHlwZUluZGV4KSB7XG4gICAgICAgIHR5cGUgPSBpeFR5cGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5zdHJ1Y3Rpb24gdHlwZSBpbmNvcnJlY3Q7IG5vdCBhIFN5c3RlbUluc3RydWN0aW9uJyk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIGNyZWF0ZSBhY2NvdW50IHN5c3RlbSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVDcmVhdGVBY2NvdW50KGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMik7XG4gICAgY29uc3Qge1xuICAgICAgbGFtcG9ydHMsXG4gICAgICBzcGFjZSxcbiAgICAgIHByb2dyYW1JZFxuICAgIH0gPSBkZWNvZGVEYXRhJDEoU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuQ3JlYXRlLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgZnJvbVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBuZXdBY2NvdW50UHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleSxcbiAgICAgIGxhbXBvcnRzLFxuICAgICAgc3BhY2UsXG4gICAgICBwcm9ncmFtSWQ6IG5ldyBQdWJsaWNLZXkocHJvZ3JhbUlkKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGEgdHJhbnNmZXIgc3lzdGVtIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZVRyYW5zZmVyKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMik7XG4gICAgY29uc3Qge1xuICAgICAgbGFtcG9ydHNcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLlRyYW5zZmVyLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgZnJvbVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICB0b1B1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICBsYW1wb3J0c1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGEgdHJhbnNmZXIgd2l0aCBzZWVkIHN5c3RlbSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVUcmFuc2ZlcldpdGhTZWVkKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMyk7XG4gICAgY29uc3Qge1xuICAgICAgbGFtcG9ydHMsXG4gICAgICBzZWVkLFxuICAgICAgcHJvZ3JhbUlkXG4gICAgfSA9IGRlY29kZURhdGEkMShTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5UcmFuc2ZlcldpdGhTZWVkLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgZnJvbVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBiYXNlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleSxcbiAgICAgIHRvUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzJdLnB1YmtleSxcbiAgICAgIGxhbXBvcnRzLFxuICAgICAgc2VlZCxcbiAgICAgIHByb2dyYW1JZDogbmV3IFB1YmxpY0tleShwcm9ncmFtSWQpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYW4gYWxsb2NhdGUgc3lzdGVtIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZUFsbG9jYXRlKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMSk7XG4gICAgY29uc3Qge1xuICAgICAgc3BhY2VcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkFsbG9jYXRlLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgYWNjb3VudFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBzcGFjZVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGFuIGFsbG9jYXRlIHdpdGggc2VlZCBzeXN0ZW0gaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlQWxsb2NhdGVXaXRoU2VlZChpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDEpO1xuICAgIGNvbnN0IHtcbiAgICAgIGJhc2UsXG4gICAgICBzZWVkLFxuICAgICAgc3BhY2UsXG4gICAgICBwcm9ncmFtSWRcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkFsbG9jYXRlV2l0aFNlZWQsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBhY2NvdW50UHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGJhc2VQdWJrZXk6IG5ldyBQdWJsaWNLZXkoYmFzZSksXG4gICAgICBzZWVkLFxuICAgICAgc3BhY2UsXG4gICAgICBwcm9ncmFtSWQ6IG5ldyBQdWJsaWNLZXkocHJvZ3JhbUlkKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGFuIGFzc2lnbiBzeXN0ZW0gaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlQXNzaWduKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMSk7XG4gICAgY29uc3Qge1xuICAgICAgcHJvZ3JhbUlkXG4gICAgfSA9IGRlY29kZURhdGEkMShTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5Bc3NpZ24sIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBhY2NvdW50UHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIHByb2dyYW1JZDogbmV3IFB1YmxpY0tleShwcm9ncmFtSWQpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYW4gYXNzaWduIHdpdGggc2VlZCBzeXN0ZW0gaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlQXNzaWduV2l0aFNlZWQoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAxKTtcbiAgICBjb25zdCB7XG4gICAgICBiYXNlLFxuICAgICAgc2VlZCxcbiAgICAgIHByb2dyYW1JZFxuICAgIH0gPSBkZWNvZGVEYXRhJDEoU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuQXNzaWduV2l0aFNlZWQsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBhY2NvdW50UHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGJhc2VQdWJrZXk6IG5ldyBQdWJsaWNLZXkoYmFzZSksXG4gICAgICBzZWVkLFxuICAgICAgcHJvZ3JhbUlkOiBuZXcgUHVibGljS2V5KHByb2dyYW1JZClcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIGNyZWF0ZSBhY2NvdW50IHdpdGggc2VlZCBzeXN0ZW0gaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlQ3JlYXRlV2l0aFNlZWQoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAyKTtcbiAgICBjb25zdCB7XG4gICAgICBiYXNlLFxuICAgICAgc2VlZCxcbiAgICAgIGxhbXBvcnRzLFxuICAgICAgc3BhY2UsXG4gICAgICBwcm9ncmFtSWRcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkNyZWF0ZVdpdGhTZWVkLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgZnJvbVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBuZXdBY2NvdW50UHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleSxcbiAgICAgIGJhc2VQdWJrZXk6IG5ldyBQdWJsaWNLZXkoYmFzZSksXG4gICAgICBzZWVkLFxuICAgICAgbGFtcG9ydHMsXG4gICAgICBzcGFjZSxcbiAgICAgIHByb2dyYW1JZDogbmV3IFB1YmxpY0tleShwcm9ncmFtSWQpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBub25jZSBpbml0aWFsaXplIHN5c3RlbSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVOb25jZUluaXRpYWxpemUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAzKTtcbiAgICBjb25zdCB7XG4gICAgICBhdXRob3JpemVkXG4gICAgfSA9IGRlY29kZURhdGEkMShTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5Jbml0aWFsaXplTm9uY2VBY2NvdW50LCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgbm9uY2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleTogbmV3IFB1YmxpY0tleShhdXRob3JpemVkKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGEgbm9uY2UgYWR2YW5jZSBzeXN0ZW0gaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlTm9uY2VBZHZhbmNlKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMyk7XG4gICAgZGVjb2RlRGF0YSQxKFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkFkdmFuY2VOb25jZUFjY291bnQsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBub25jZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzJdLnB1YmtleVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGEgbm9uY2Ugd2l0aGRyYXcgc3lzdGVtIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZU5vbmNlV2l0aGRyYXcoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCA1KTtcbiAgICBjb25zdCB7XG4gICAgICBsYW1wb3J0c1xuICAgIH0gPSBkZWNvZGVEYXRhJDEoU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuV2l0aGRyYXdOb25jZUFjY291bnQsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBub25jZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICB0b1B1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzRdLnB1YmtleSxcbiAgICAgIGxhbXBvcnRzXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBub25jZSBhdXRob3JpemUgc3lzdGVtIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZU5vbmNlQXV0aG9yaXplKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMik7XG4gICAgY29uc3Qge1xuICAgICAgYXV0aG9yaXplZFxuICAgIH0gPSBkZWNvZGVEYXRhJDEoU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuQXV0aG9yaXplTm9uY2VBY2NvdW50LCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgbm9uY2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICBuZXdBdXRob3JpemVkUHVia2V5OiBuZXcgUHVibGljS2V5KGF1dGhvcml6ZWQpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHN0YXRpYyBjaGVja1Byb2dyYW1JZChwcm9ncmFtSWQpIHtcbiAgICBpZiAoIXByb2dyYW1JZC5lcXVhbHMoU3lzdGVtUHJvZ3JhbS5wcm9ncmFtSWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5zdHJ1Y3Rpb247IHByb2dyYW1JZCBpcyBub3QgU3lzdGVtUHJvZ3JhbScpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHN0YXRpYyBjaGVja0tleUxlbmd0aChrZXlzLCBleHBlY3RlZExlbmd0aCkge1xuICAgIGlmIChrZXlzLmxlbmd0aCA8IGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgaW5zdHJ1Y3Rpb247IGZvdW5kICR7a2V5cy5sZW5ndGh9IGtleXMsIGV4cGVjdGVkIGF0IGxlYXN0ICR7ZXhwZWN0ZWRMZW5ndGh9YCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQW4gZW51bWVyYXRpb24gb2YgdmFsaWQgU3lzdGVtSW5zdHJ1Y3Rpb25UeXBlJ3NcbiAqL1xuXG4vKipcbiAqIEFuIGVudW1lcmF0aW9uIG9mIHZhbGlkIHN5c3RlbSBJbnN0cnVjdGlvblR5cGUnc1xuICogQGludGVybmFsXG4gKi9cbmNvbnN0IFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTID0gT2JqZWN0LmZyZWV6ZSh7XG4gIENyZWF0ZToge1xuICAgIGluZGV4OiAwLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0X19uYW1lc3BhY2Uuc3RydWN0KFtCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51MzIoJ2luc3RydWN0aW9uJyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLm5zNjQoJ2xhbXBvcnRzJyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLm5zNjQoJ3NwYWNlJyksIHB1YmxpY0tleSgncHJvZ3JhbUlkJyldKVxuICB9LFxuICBBc3NpZ246IHtcbiAgICBpbmRleDogMSxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnN0cnVjdChbQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTMyKCdpbnN0cnVjdGlvbicpLCBwdWJsaWNLZXkoJ3Byb2dyYW1JZCcpXSlcbiAgfSxcbiAgVHJhbnNmZXI6IHtcbiAgICBpbmRleDogMixcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnN0cnVjdChbQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTMyKCdpbnN0cnVjdGlvbicpLCB1NjQoJ2xhbXBvcnRzJyldKVxuICB9LFxuICBDcmVhdGVXaXRoU2VlZDoge1xuICAgIGluZGV4OiAzLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0X19uYW1lc3BhY2Uuc3RydWN0KFtCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51MzIoJ2luc3RydWN0aW9uJyksIHB1YmxpY0tleSgnYmFzZScpLCBydXN0U3RyaW5nKCdzZWVkJyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLm5zNjQoJ2xhbXBvcnRzJyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLm5zNjQoJ3NwYWNlJyksIHB1YmxpY0tleSgncHJvZ3JhbUlkJyldKVxuICB9LFxuICBBZHZhbmNlTm9uY2VBY2NvdW50OiB7XG4gICAgaW5kZXg6IDQsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5zdHJ1Y3QoW0J1ZmZlckxheW91dF9fbmFtZXNwYWNlLnUzMignaW5zdHJ1Y3Rpb24nKV0pXG4gIH0sXG4gIFdpdGhkcmF3Tm9uY2VBY2NvdW50OiB7XG4gICAgaW5kZXg6IDUsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5zdHJ1Y3QoW0J1ZmZlckxheW91dF9fbmFtZXNwYWNlLnUzMignaW5zdHJ1Y3Rpb24nKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UubnM2NCgnbGFtcG9ydHMnKV0pXG4gIH0sXG4gIEluaXRpYWxpemVOb25jZUFjY291bnQ6IHtcbiAgICBpbmRleDogNixcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnN0cnVjdChbQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTMyKCdpbnN0cnVjdGlvbicpLCBwdWJsaWNLZXkoJ2F1dGhvcml6ZWQnKV0pXG4gIH0sXG4gIEF1dGhvcml6ZU5vbmNlQWNjb3VudDoge1xuICAgIGluZGV4OiA3LFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0X19uYW1lc3BhY2Uuc3RydWN0KFtCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51MzIoJ2luc3RydWN0aW9uJyksIHB1YmxpY0tleSgnYXV0aG9yaXplZCcpXSlcbiAgfSxcbiAgQWxsb2NhdGU6IHtcbiAgICBpbmRleDogOCxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnN0cnVjdChbQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTMyKCdpbnN0cnVjdGlvbicpLCBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5uczY0KCdzcGFjZScpXSlcbiAgfSxcbiAgQWxsb2NhdGVXaXRoU2VlZDoge1xuICAgIGluZGV4OiA5LFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0X19uYW1lc3BhY2Uuc3RydWN0KFtCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51MzIoJ2luc3RydWN0aW9uJyksIHB1YmxpY0tleSgnYmFzZScpLCBydXN0U3RyaW5nKCdzZWVkJyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLm5zNjQoJ3NwYWNlJyksIHB1YmxpY0tleSgncHJvZ3JhbUlkJyldKVxuICB9LFxuICBBc3NpZ25XaXRoU2VlZDoge1xuICAgIGluZGV4OiAxMCxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnN0cnVjdChbQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTMyKCdpbnN0cnVjdGlvbicpLCBwdWJsaWNLZXkoJ2Jhc2UnKSwgcnVzdFN0cmluZygnc2VlZCcpLCBwdWJsaWNLZXkoJ3Byb2dyYW1JZCcpXSlcbiAgfSxcbiAgVHJhbnNmZXJXaXRoU2VlZDoge1xuICAgIGluZGV4OiAxMSxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnN0cnVjdChbQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTMyKCdpbnN0cnVjdGlvbicpLCB1NjQoJ2xhbXBvcnRzJyksIHJ1c3RTdHJpbmcoJ3NlZWQnKSwgcHVibGljS2V5KCdwcm9ncmFtSWQnKV0pXG4gIH0sXG4gIFVwZ3JhZGVOb25jZUFjY291bnQ6IHtcbiAgICBpbmRleDogMTIsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5zdHJ1Y3QoW0J1ZmZlckxheW91dF9fbmFtZXNwYWNlLnUzMignaW5zdHJ1Y3Rpb24nKV0pXG4gIH1cbn0pO1xuXG4vKipcbiAqIEZhY3RvcnkgY2xhc3MgZm9yIHRyYW5zYWN0aW9ucyB0byBpbnRlcmFjdCB3aXRoIHRoZSBTeXN0ZW0gcHJvZ3JhbVxuICovXG5jbGFzcyBTeXN0ZW1Qcm9ncmFtIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7fVxuXG4gIC8qKlxuICAgKiBQdWJsaWMga2V5IHRoYXQgaWRlbnRpZmllcyB0aGUgU3lzdGVtIHByb2dyYW1cbiAgICovXG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdHJhbnNhY3Rpb24gaW5zdHJ1Y3Rpb24gdGhhdCBjcmVhdGVzIGEgbmV3IGFjY291bnRcbiAgICovXG4gIHN0YXRpYyBjcmVhdGVBY2NvdW50KHBhcmFtcykge1xuICAgIGNvbnN0IHR5cGUgPSBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5DcmVhdGU7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgbGFtcG9ydHM6IHBhcmFtcy5sYW1wb3J0cyxcbiAgICAgIHNwYWNlOiBwYXJhbXMuc3BhY2UsXG4gICAgICBwcm9ncmFtSWQ6IHRvQnVmZmVyKHBhcmFtcy5wcm9ncmFtSWQudG9CdWZmZXIoKSlcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5czogW3tcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuZnJvbVB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBwYXJhbXMubmV3QWNjb3VudFB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH1dLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIGluc3RydWN0aW9uIHRoYXQgdHJhbnNmZXJzIGxhbXBvcnRzIGZyb20gb25lIGFjY291bnQgdG8gYW5vdGhlclxuICAgKi9cbiAgc3RhdGljIHRyYW5zZmVyKHBhcmFtcykge1xuICAgIGxldCBkYXRhO1xuICAgIGxldCBrZXlzO1xuICAgIGlmICgnYmFzZVB1YmtleScgaW4gcGFyYW1zKSB7XG4gICAgICBjb25zdCB0eXBlID0gU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuVHJhbnNmZXJXaXRoU2VlZDtcbiAgICAgIGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgICAgbGFtcG9ydHM6IEJpZ0ludChwYXJhbXMubGFtcG9ydHMpLFxuICAgICAgICBzZWVkOiBwYXJhbXMuc2VlZCxcbiAgICAgICAgcHJvZ3JhbUlkOiB0b0J1ZmZlcihwYXJhbXMucHJvZ3JhbUlkLnRvQnVmZmVyKCkpXG4gICAgICB9KTtcbiAgICAgIGtleXMgPSBbe1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5mcm9tUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuYmFzZVB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLnRvUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH1dO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0eXBlID0gU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuVHJhbnNmZXI7XG4gICAgICBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICAgIGxhbXBvcnRzOiBCaWdJbnQocGFyYW1zLmxhbXBvcnRzKVxuICAgICAgfSk7XG4gICAgICBrZXlzID0gW3tcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuZnJvbVB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBwYXJhbXMudG9QdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfV07XG4gICAgfVxuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBrZXlzLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIGluc3RydWN0aW9uIHRoYXQgYXNzaWducyBhbiBhY2NvdW50IHRvIGEgcHJvZ3JhbVxuICAgKi9cbiAgc3RhdGljIGFzc2lnbihwYXJhbXMpIHtcbiAgICBsZXQgZGF0YTtcbiAgICBsZXQga2V5cztcbiAgICBpZiAoJ2Jhc2VQdWJrZXknIGluIHBhcmFtcykge1xuICAgICAgY29uc3QgdHlwZSA9IFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkFzc2lnbldpdGhTZWVkO1xuICAgICAgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgICBiYXNlOiB0b0J1ZmZlcihwYXJhbXMuYmFzZVB1YmtleS50b0J1ZmZlcigpKSxcbiAgICAgICAgc2VlZDogcGFyYW1zLnNlZWQsXG4gICAgICAgIHByb2dyYW1JZDogdG9CdWZmZXIocGFyYW1zLnByb2dyYW1JZC50b0J1ZmZlcigpKVxuICAgICAgfSk7XG4gICAgICBrZXlzID0gW3tcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuYWNjb3VudFB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLmJhc2VQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5Bc3NpZ247XG4gICAgICBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICAgIHByb2dyYW1JZDogdG9CdWZmZXIocGFyYW1zLnByb2dyYW1JZC50b0J1ZmZlcigpKVxuICAgICAgfSk7XG4gICAgICBrZXlzID0gW3tcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuYWNjb3VudFB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH1dO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5cyxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0cmFuc2FjdGlvbiBpbnN0cnVjdGlvbiB0aGF0IGNyZWF0ZXMgYSBuZXcgYWNjb3VudCBhdFxuICAgKiAgIGFuIGFkZHJlc3MgZ2VuZXJhdGVkIHdpdGggYGZyb21gLCBhIHNlZWQsIGFuZCBwcm9ncmFtSWRcbiAgICovXG4gIHN0YXRpYyBjcmVhdGVBY2NvdW50V2l0aFNlZWQocGFyYW1zKSB7XG4gICAgY29uc3QgdHlwZSA9IFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkNyZWF0ZVdpdGhTZWVkO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIGJhc2U6IHRvQnVmZmVyKHBhcmFtcy5iYXNlUHVia2V5LnRvQnVmZmVyKCkpLFxuICAgICAgc2VlZDogcGFyYW1zLnNlZWQsXG4gICAgICBsYW1wb3J0czogcGFyYW1zLmxhbXBvcnRzLFxuICAgICAgc3BhY2U6IHBhcmFtcy5zcGFjZSxcbiAgICAgIHByb2dyYW1JZDogdG9CdWZmZXIocGFyYW1zLnByb2dyYW1JZC50b0J1ZmZlcigpKVxuICAgIH0pO1xuICAgIGxldCBrZXlzID0gW3tcbiAgICAgIHB1YmtleTogcGFyYW1zLmZyb21QdWJrZXksXG4gICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IHBhcmFtcy5uZXdBY2NvdW50UHVia2V5LFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH1dO1xuICAgIGlmIChwYXJhbXMuYmFzZVB1YmtleSAhPSBwYXJhbXMuZnJvbVB1YmtleSkge1xuICAgICAga2V5cy5wdXNoKHtcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuYmFzZVB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXMsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdHJhbnNhY3Rpb24gdGhhdCBjcmVhdGVzIGEgbmV3IE5vbmNlIGFjY291bnRcbiAgICovXG4gIHN0YXRpYyBjcmVhdGVOb25jZUFjY291bnQocGFyYW1zKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICBpZiAoJ2Jhc2VQdWJrZXknIGluIHBhcmFtcyAmJiAnc2VlZCcgaW4gcGFyYW1zKSB7XG4gICAgICB0cmFuc2FjdGlvbi5hZGQoU3lzdGVtUHJvZ3JhbS5jcmVhdGVBY2NvdW50V2l0aFNlZWQoe1xuICAgICAgICBmcm9tUHVia2V5OiBwYXJhbXMuZnJvbVB1YmtleSxcbiAgICAgICAgbmV3QWNjb3VudFB1YmtleTogcGFyYW1zLm5vbmNlUHVia2V5LFxuICAgICAgICBiYXNlUHVia2V5OiBwYXJhbXMuYmFzZVB1YmtleSxcbiAgICAgICAgc2VlZDogcGFyYW1zLnNlZWQsXG4gICAgICAgIGxhbXBvcnRzOiBwYXJhbXMubGFtcG9ydHMsXG4gICAgICAgIHNwYWNlOiBOT05DRV9BQ0NPVU5UX0xFTkdUSCxcbiAgICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZFxuICAgICAgfSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmFuc2FjdGlvbi5hZGQoU3lzdGVtUHJvZ3JhbS5jcmVhdGVBY2NvdW50KHtcbiAgICAgICAgZnJvbVB1YmtleTogcGFyYW1zLmZyb21QdWJrZXksXG4gICAgICAgIG5ld0FjY291bnRQdWJrZXk6IHBhcmFtcy5ub25jZVB1YmtleSxcbiAgICAgICAgbGFtcG9ydHM6IHBhcmFtcy5sYW1wb3J0cyxcbiAgICAgICAgc3BhY2U6IE5PTkNFX0FDQ09VTlRfTEVOR1RILFxuICAgICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkXG4gICAgICB9KSk7XG4gICAgfVxuICAgIGNvbnN0IGluaXRQYXJhbXMgPSB7XG4gICAgICBub25jZVB1YmtleTogcGFyYW1zLm5vbmNlUHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleTogcGFyYW1zLmF1dGhvcml6ZWRQdWJrZXlcbiAgICB9O1xuICAgIHRyYW5zYWN0aW9uLmFkZCh0aGlzLm5vbmNlSW5pdGlhbGl6ZShpbml0UGFyYW1zKSk7XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGFuIGluc3RydWN0aW9uIHRvIGluaXRpYWxpemUgYSBOb25jZSBhY2NvdW50XG4gICAqL1xuICBzdGF0aWMgbm9uY2VJbml0aWFsaXplKHBhcmFtcykge1xuICAgIGNvbnN0IHR5cGUgPSBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5Jbml0aWFsaXplTm9uY2VBY2NvdW50O1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIGF1dGhvcml6ZWQ6IHRvQnVmZmVyKHBhcmFtcy5hdXRob3JpemVkUHVia2V5LnRvQnVmZmVyKCkpXG4gICAgfSk7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25EYXRhID0ge1xuICAgICAga2V5czogW3tcbiAgICAgICAgcHVia2V5OiBwYXJhbXMubm9uY2VQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IFNZU1ZBUl9SRUNFTlRfQkxPQ0tIQVNIRVNfUFVCS0VZLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU1lTVkFSX1JFTlRfUFVCS0VZLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9XSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oaW5zdHJ1Y3Rpb25EYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhbiBpbnN0cnVjdGlvbiB0byBhZHZhbmNlIHRoZSBub25jZSBpbiBhIE5vbmNlIGFjY291bnRcbiAgICovXG4gIHN0YXRpYyBub25jZUFkdmFuY2UocGFyYW1zKSB7XG4gICAgY29uc3QgdHlwZSA9IFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkFkdmFuY2VOb25jZUFjY291bnQ7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSk7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25EYXRhID0ge1xuICAgICAga2V5czogW3tcbiAgICAgICAgcHVia2V5OiBwYXJhbXMubm9uY2VQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IFNZU1ZBUl9SRUNFTlRfQkxPQ0tIQVNIRVNfUFVCS0VZLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLmF1dGhvcml6ZWRQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfV0sXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH07XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKGluc3RydWN0aW9uRGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0cmFuc2FjdGlvbiBpbnN0cnVjdGlvbiB0aGF0IHdpdGhkcmF3cyBsYW1wb3J0cyBmcm9tIGEgTm9uY2UgYWNjb3VudFxuICAgKi9cbiAgc3RhdGljIG5vbmNlV2l0aGRyYXcocGFyYW1zKSB7XG4gICAgY29uc3QgdHlwZSA9IFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLldpdGhkcmF3Tm9uY2VBY2NvdW50O1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIGxhbXBvcnRzOiBwYXJhbXMubGFtcG9ydHNcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5czogW3tcbiAgICAgICAgcHVia2V5OiBwYXJhbXMubm9uY2VQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy50b1B1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU1lTVkFSX1JFQ0VOVF9CTE9DS0hBU0hFU19QVUJLRVksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBTWVNWQVJfUkVOVF9QVUJLRVksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuYXV0aG9yaXplZFB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9XSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0cmFuc2FjdGlvbiBpbnN0cnVjdGlvbiB0aGF0IGF1dGhvcml6ZXMgYSBuZXcgUHVibGljS2V5IGFzIHRoZSBhdXRob3JpdHlcbiAgICogb24gYSBOb25jZSBhY2NvdW50LlxuICAgKi9cbiAgc3RhdGljIG5vbmNlQXV0aG9yaXplKHBhcmFtcykge1xuICAgIGNvbnN0IHR5cGUgPSBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5BdXRob3JpemVOb25jZUFjY291bnQ7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgYXV0aG9yaXplZDogdG9CdWZmZXIocGFyYW1zLm5ld0F1dGhvcml6ZWRQdWJrZXkudG9CdWZmZXIoKSlcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5czogW3tcbiAgICAgICAgcHVia2V5OiBwYXJhbXMubm9uY2VQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5hdXRob3JpemVkUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH1dLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIGluc3RydWN0aW9uIHRoYXQgYWxsb2NhdGVzIHNwYWNlIGluIGFuIGFjY291bnQgd2l0aG91dCBmdW5kaW5nXG4gICAqL1xuICBzdGF0aWMgYWxsb2NhdGUocGFyYW1zKSB7XG4gICAgbGV0IGRhdGE7XG4gICAgbGV0IGtleXM7XG4gICAgaWYgKCdiYXNlUHVia2V5JyBpbiBwYXJhbXMpIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5BbGxvY2F0ZVdpdGhTZWVkO1xuICAgICAgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgICBiYXNlOiB0b0J1ZmZlcihwYXJhbXMuYmFzZVB1YmtleS50b0J1ZmZlcigpKSxcbiAgICAgICAgc2VlZDogcGFyYW1zLnNlZWQsXG4gICAgICAgIHNwYWNlOiBwYXJhbXMuc3BhY2UsXG4gICAgICAgIHByb2dyYW1JZDogdG9CdWZmZXIocGFyYW1zLnByb2dyYW1JZC50b0J1ZmZlcigpKVxuICAgICAgfSk7XG4gICAgICBrZXlzID0gW3tcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuYWNjb3VudFB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLmJhc2VQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5BbGxvY2F0ZTtcbiAgICAgIGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgICAgc3BhY2U6IHBhcmFtcy5zcGFjZVxuICAgICAgfSk7XG4gICAgICBrZXlzID0gW3tcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuYWNjb3VudFB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH1dO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5cyxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cbn1cblN5c3RlbVByb2dyYW0ucHJvZ3JhbUlkID0gbmV3IFB1YmxpY0tleSgnMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcblxuLy8gS2VlcCBwcm9ncmFtIGNodW5rcyB1bmRlciBQQUNLRVRfREFUQV9TSVpFLCBsZWF2aW5nIGVub3VnaCByb29tIGZvciB0aGVcbi8vIHJlc3Qgb2YgdGhlIFRyYW5zYWN0aW9uIGZpZWxkc1xuLy9cbi8vIFRPRE86IHJlcGxhY2UgMzAwIHdpdGggYSBwcm9wZXIgY29uc3RhbnQgZm9yIHRoZSBzaXplIG9mIHRoZSBvdGhlclxuLy8gVHJhbnNhY3Rpb24gZmllbGRzXG5jb25zdCBDSFVOS19TSVpFID0gUEFDS0VUX0RBVEFfU0laRSAtIDMwMDtcblxuLyoqXG4gKiBQcm9ncmFtIGxvYWRlciBpbnRlcmZhY2VcbiAqL1xuY2xhc3MgTG9hZGVyIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7fVxuXG4gIC8qKlxuICAgKiBBbW91bnQgb2YgcHJvZ3JhbSBkYXRhIHBsYWNlZCBpbiBlYWNoIGxvYWQgVHJhbnNhY3Rpb25cbiAgICovXG5cbiAgLyoqXG4gICAqIE1pbmltdW0gbnVtYmVyIG9mIHNpZ25hdHVyZXMgcmVxdWlyZWQgdG8gbG9hZCBhIHByb2dyYW0gbm90IGluY2x1ZGluZ1xuICAgKiByZXRyaWVzXG4gICAqXG4gICAqIENhbiBiZSB1c2VkIHRvIGNhbGN1bGF0ZSB0cmFuc2FjdGlvbiBmZWVzXG4gICAqL1xuICBzdGF0aWMgZ2V0TWluTnVtU2lnbmF0dXJlcyhkYXRhTGVuZ3RoKSB7XG4gICAgcmV0dXJuIDIgKiAoXG4gICAgLy8gRXZlcnkgdHJhbnNhY3Rpb24gcmVxdWlyZXMgdHdvIHNpZ25hdHVyZXMgKHBheWVyICsgcHJvZ3JhbSlcbiAgICBNYXRoLmNlaWwoZGF0YUxlbmd0aCAvIExvYWRlci5jaHVua1NpemUpICsgMSArXG4gICAgLy8gQWRkIG9uZSBmb3IgQ3JlYXRlIHRyYW5zYWN0aW9uXG4gICAgMSkgLy8gQWRkIG9uZSBmb3IgRmluYWxpemUgdHJhbnNhY3Rpb25cbiAgICA7XG4gIH1cblxuICAvKipcbiAgICogTG9hZHMgYSBnZW5lcmljIHByb2dyYW1cbiAgICpcbiAgICogQHBhcmFtIGNvbm5lY3Rpb24gVGhlIGNvbm5lY3Rpb24gdG8gdXNlXG4gICAqIEBwYXJhbSBwYXllciBTeXN0ZW0gYWNjb3VudCB0aGF0IHBheXMgdG8gbG9hZCB0aGUgcHJvZ3JhbVxuICAgKiBAcGFyYW0gcHJvZ3JhbSBBY2NvdW50IHRvIGxvYWQgdGhlIHByb2dyYW0gaW50b1xuICAgKiBAcGFyYW0gcHJvZ3JhbUlkIFB1YmxpYyBrZXkgdGhhdCBpZGVudGlmaWVzIHRoZSBsb2FkZXJcbiAgICogQHBhcmFtIGRhdGEgUHJvZ3JhbSBvY3RldHNcbiAgICogQHJldHVybiB0cnVlIGlmIHByb2dyYW0gd2FzIGxvYWRlZCBzdWNjZXNzZnVsbHksIGZhbHNlIGlmIHByb2dyYW0gd2FzIGFscmVhZHkgbG9hZGVkXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgbG9hZChjb25uZWN0aW9uLCBwYXllciwgcHJvZ3JhbSwgcHJvZ3JhbUlkLCBkYXRhKSB7XG4gICAge1xuICAgICAgY29uc3QgYmFsYW5jZU5lZWRlZCA9IGF3YWl0IGNvbm5lY3Rpb24uZ2V0TWluaW11bUJhbGFuY2VGb3JSZW50RXhlbXB0aW9uKGRhdGEubGVuZ3RoKTtcblxuICAgICAgLy8gRmV0Y2ggcHJvZ3JhbSBhY2NvdW50IGluZm8gdG8gY2hlY2sgaWYgaXQgaGFzIGFscmVhZHkgYmVlbiBjcmVhdGVkXG4gICAgICBjb25zdCBwcm9ncmFtSW5mbyA9IGF3YWl0IGNvbm5lY3Rpb24uZ2V0QWNjb3VudEluZm8ocHJvZ3JhbS5wdWJsaWNLZXksICdjb25maXJtZWQnKTtcbiAgICAgIGxldCB0cmFuc2FjdGlvbiA9IG51bGw7XG4gICAgICBpZiAocHJvZ3JhbUluZm8gIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHByb2dyYW1JbmZvLmV4ZWN1dGFibGUpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdQcm9ncmFtIGxvYWQgZmFpbGVkLCBhY2NvdW50IGlzIGFscmVhZHkgZXhlY3V0YWJsZScpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvZ3JhbUluZm8uZGF0YS5sZW5ndGggIT09IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgdHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbiB8fCBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICAgICAgICB0cmFuc2FjdGlvbi5hZGQoU3lzdGVtUHJvZ3JhbS5hbGxvY2F0ZSh7XG4gICAgICAgICAgICBhY2NvdW50UHVia2V5OiBwcm9ncmFtLnB1YmxpY0tleSxcbiAgICAgICAgICAgIHNwYWNlOiBkYXRhLmxlbmd0aFxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXByb2dyYW1JbmZvLm93bmVyLmVxdWFscyhwcm9ncmFtSWQpKSB7XG4gICAgICAgICAgdHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbiB8fCBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICAgICAgICB0cmFuc2FjdGlvbi5hZGQoU3lzdGVtUHJvZ3JhbS5hc3NpZ24oe1xuICAgICAgICAgICAgYWNjb3VudFB1YmtleTogcHJvZ3JhbS5wdWJsaWNLZXksXG4gICAgICAgICAgICBwcm9ncmFtSWRcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2dyYW1JbmZvLmxhbXBvcnRzIDwgYmFsYW5jZU5lZWRlZCkge1xuICAgICAgICAgIHRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb24gfHwgbmV3IFRyYW5zYWN0aW9uKCk7XG4gICAgICAgICAgdHJhbnNhY3Rpb24uYWRkKFN5c3RlbVByb2dyYW0udHJhbnNmZXIoe1xuICAgICAgICAgICAgZnJvbVB1YmtleTogcGF5ZXIucHVibGljS2V5LFxuICAgICAgICAgICAgdG9QdWJrZXk6IHByb2dyYW0ucHVibGljS2V5LFxuICAgICAgICAgICAgbGFtcG9ydHM6IGJhbGFuY2VOZWVkZWQgLSBwcm9ncmFtSW5mby5sYW1wb3J0c1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoU3lzdGVtUHJvZ3JhbS5jcmVhdGVBY2NvdW50KHtcbiAgICAgICAgICBmcm9tUHVia2V5OiBwYXllci5wdWJsaWNLZXksXG4gICAgICAgICAgbmV3QWNjb3VudFB1YmtleTogcHJvZ3JhbS5wdWJsaWNLZXksXG4gICAgICAgICAgbGFtcG9ydHM6IGJhbGFuY2VOZWVkZWQgPiAwID8gYmFsYW5jZU5lZWRlZCA6IDEsXG4gICAgICAgICAgc3BhY2U6IGRhdGEubGVuZ3RoLFxuICAgICAgICAgIHByb2dyYW1JZFxuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSBhY2NvdW50IGlzIGFscmVhZHkgY3JlYXRlZCBjb3JyZWN0bHksIHNraXAgdGhpcyBzdGVwXG4gICAgICAvLyBhbmQgcHJvY2VlZCBkaXJlY3RseSB0byBsb2FkaW5nIGluc3RydWN0aW9uc1xuICAgICAgaWYgKHRyYW5zYWN0aW9uICE9PSBudWxsKSB7XG4gICAgICAgIGF3YWl0IHNlbmRBbmRDb25maXJtVHJhbnNhY3Rpb24oY29ubmVjdGlvbiwgdHJhbnNhY3Rpb24sIFtwYXllciwgcHJvZ3JhbV0sIHtcbiAgICAgICAgICBjb21taXRtZW50OiAnY29uZmlybWVkJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZGF0YUxheW91dCA9IEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnN0cnVjdChbQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTMyKCdpbnN0cnVjdGlvbicpLCBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51MzIoJ29mZnNldCcpLCBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51MzIoJ2J5dGVzTGVuZ3RoJyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnUzMignYnl0ZXNMZW5ndGhQYWRkaW5nJyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnNlcShCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51OCgnYnl0ZScpLCBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5vZmZzZXQoQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTMyKCksIC04KSwgJ2J5dGVzJyldKTtcbiAgICBjb25zdCBjaHVua1NpemUgPSBMb2FkZXIuY2h1bmtTaXplO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGxldCBhcnJheSA9IGRhdGE7XG4gICAgbGV0IHRyYW5zYWN0aW9ucyA9IFtdO1xuICAgIHdoaWxlIChhcnJheS5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBieXRlcyA9IGFycmF5LnNsaWNlKDAsIGNodW5rU2l6ZSk7XG4gICAgICBjb25zdCBkYXRhID0gYnVmZmVyLkJ1ZmZlci5hbGxvYyhjaHVua1NpemUgKyAxNik7XG4gICAgICBkYXRhTGF5b3V0LmVuY29kZSh7XG4gICAgICAgIGluc3RydWN0aW9uOiAwLFxuICAgICAgICAvLyBMb2FkIGluc3RydWN0aW9uXG4gICAgICAgIG9mZnNldCxcbiAgICAgICAgYnl0ZXM6IGJ5dGVzLFxuICAgICAgICBieXRlc0xlbmd0aDogMCxcbiAgICAgICAgYnl0ZXNMZW5ndGhQYWRkaW5nOiAwXG4gICAgICB9LCBkYXRhKTtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKHtcbiAgICAgICAga2V5czogW3tcbiAgICAgICAgICBwdWJrZXk6IHByb2dyYW0ucHVibGljS2V5LFxuICAgICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgICAgfV0sXG4gICAgICAgIHByb2dyYW1JZCxcbiAgICAgICAgZGF0YVxuICAgICAgfSk7XG4gICAgICB0cmFuc2FjdGlvbnMucHVzaChzZW5kQW5kQ29uZmlybVRyYW5zYWN0aW9uKGNvbm5lY3Rpb24sIHRyYW5zYWN0aW9uLCBbcGF5ZXIsIHByb2dyYW1dLCB7XG4gICAgICAgIGNvbW1pdG1lbnQ6ICdjb25maXJtZWQnXG4gICAgICB9KSk7XG5cbiAgICAgIC8vIERlbGF5IGJldHdlZW4gc2VuZHMgaW4gYW4gYXR0ZW1wdCB0byByZWR1Y2UgcmF0ZSBsaW1pdCBlcnJvcnNcbiAgICAgIGlmIChjb25uZWN0aW9uLl9ycGNFbmRwb2ludC5pbmNsdWRlcygnc29sYW5hLmNvbScpKSB7XG4gICAgICAgIGNvbnN0IFJFUVVFU1RTX1BFUl9TRUNPTkQgPSA0O1xuICAgICAgICBhd2FpdCBzbGVlcCgxMDAwIC8gUkVRVUVTVFNfUEVSX1NFQ09ORCk7XG4gICAgICB9XG4gICAgICBvZmZzZXQgKz0gY2h1bmtTaXplO1xuICAgICAgYXJyYXkgPSBhcnJheS5zbGljZShjaHVua1NpemUpO1xuICAgIH1cbiAgICBhd2FpdCBQcm9taXNlLmFsbCh0cmFuc2FjdGlvbnMpO1xuXG4gICAgLy8gRmluYWxpemUgdGhlIGFjY291bnQgbG9hZGVkIHdpdGggcHJvZ3JhbSBkYXRhIGZvciBleGVjdXRpb25cbiAgICB7XG4gICAgICBjb25zdCBkYXRhTGF5b3V0ID0gQnVmZmVyTGF5b3V0X19uYW1lc3BhY2Uuc3RydWN0KFtCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51MzIoJ2luc3RydWN0aW9uJyldKTtcbiAgICAgIGNvbnN0IGRhdGEgPSBidWZmZXIuQnVmZmVyLmFsbG9jKGRhdGFMYXlvdXQuc3Bhbik7XG4gICAgICBkYXRhTGF5b3V0LmVuY29kZSh7XG4gICAgICAgIGluc3RydWN0aW9uOiAxIC8vIEZpbmFsaXplIGluc3RydWN0aW9uXG4gICAgICB9LCBkYXRhKTtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKHtcbiAgICAgICAga2V5czogW3tcbiAgICAgICAgICBwdWJrZXk6IHByb2dyYW0ucHVibGljS2V5LFxuICAgICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgICAgfSwge1xuICAgICAgICAgIHB1YmtleTogU1lTVkFSX1JFTlRfUFVCS0VZLFxuICAgICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgICB9XSxcbiAgICAgICAgcHJvZ3JhbUlkLFxuICAgICAgICBkYXRhXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGRlcGxveUNvbW1pdG1lbnQgPSAncHJvY2Vzc2VkJztcbiAgICAgIGNvbnN0IGZpbmFsaXplU2lnbmF0dXJlID0gYXdhaXQgY29ubmVjdGlvbi5zZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIFtwYXllciwgcHJvZ3JhbV0sIHtcbiAgICAgICAgcHJlZmxpZ2h0Q29tbWl0bWVudDogZGVwbG95Q29tbWl0bWVudFxuICAgICAgfSk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIHZhbHVlXG4gICAgICB9ID0gYXdhaXQgY29ubmVjdGlvbi5jb25maXJtVHJhbnNhY3Rpb24oe1xuICAgICAgICBzaWduYXR1cmU6IGZpbmFsaXplU2lnbmF0dXJlLFxuICAgICAgICBsYXN0VmFsaWRCbG9ja0hlaWdodDogdHJhbnNhY3Rpb24ubGFzdFZhbGlkQmxvY2tIZWlnaHQsXG4gICAgICAgIGJsb2NraGFzaDogdHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoXG4gICAgICB9LCBkZXBsb3lDb21taXRtZW50KTtcbiAgICAgIGlmICh2YWx1ZS5lcnIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUcmFuc2FjdGlvbiAke2ZpbmFsaXplU2lnbmF0dXJlfSBmYWlsZWQgKCR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfSlgKTtcbiAgICAgIH1cbiAgICAgIC8vIFdlIHByZXZlbnQgcHJvZ3JhbXMgZnJvbSBiZWluZyB1c2FibGUgdW50aWwgdGhlIHNsb3QgYWZ0ZXIgdGhlaXIgZGVwbG95bWVudC5cbiAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vc29sYW5hLWxhYnMvc29sYW5hL3B1bGwvMjk2NTRcbiAgICAgIHdoaWxlICh0cnVlIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gICAgICApIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBjdXJyZW50U2xvdCA9IGF3YWl0IGNvbm5lY3Rpb24uZ2V0U2xvdCh7XG4gICAgICAgICAgICBjb21taXRtZW50OiBkZXBsb3lDb21taXRtZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGN1cnJlbnRTbG90ID4gY29udGV4dC5zbG90KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIC8qIGVtcHR5ICovXG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIE1hdGgucm91bmQoTVNfUEVSX1NMT1QgLyAyKSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHN1Y2Nlc3NcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuTG9hZGVyLmNodW5rU2l6ZSA9IENIVU5LX1NJWkU7XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBTb2xhbmEgdjEuMTcuMjAuXG4gKi9cbmNvbnN0IEJQRl9MT0FERVJfUFJPR1JBTV9JRCA9IG5ldyBQdWJsaWNLZXkoJ0JQRkxvYWRlcjIxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcblxuLyoqXG4gKiBGYWN0b3J5IGNsYXNzIGZvciB0cmFuc2FjdGlvbnMgdG8gaW50ZXJhY3Qgd2l0aCBhIHByb2dyYW0gbG9hZGVyXG4gKlxuICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBTb2xhbmEgdjEuMTcuMjAuXG4gKi9cbmNsYXNzIEJwZkxvYWRlciB7XG4gIC8qKlxuICAgKiBNaW5pbXVtIG51bWJlciBvZiBzaWduYXR1cmVzIHJlcXVpcmVkIHRvIGxvYWQgYSBwcm9ncmFtIG5vdCBpbmNsdWRpbmdcbiAgICogcmV0cmllc1xuICAgKlxuICAgKiBDYW4gYmUgdXNlZCB0byBjYWxjdWxhdGUgdHJhbnNhY3Rpb24gZmVlc1xuICAgKi9cbiAgc3RhdGljIGdldE1pbk51bVNpZ25hdHVyZXMoZGF0YUxlbmd0aCkge1xuICAgIHJldHVybiBMb2FkZXIuZ2V0TWluTnVtU2lnbmF0dXJlcyhkYXRhTGVuZ3RoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkIGEgU0JGIHByb2dyYW1cbiAgICpcbiAgICogQHBhcmFtIGNvbm5lY3Rpb24gVGhlIGNvbm5lY3Rpb24gdG8gdXNlXG4gICAqIEBwYXJhbSBwYXllciBBY2NvdW50IHRoYXQgd2lsbCBwYXkgcHJvZ3JhbSBsb2FkaW5nIGZlZXNcbiAgICogQHBhcmFtIHByb2dyYW0gQWNjb3VudCB0byBsb2FkIHRoZSBwcm9ncmFtIGludG9cbiAgICogQHBhcmFtIGVsZiBUaGUgZW50aXJlIEVMRiBjb250YWluaW5nIHRoZSBTQkYgcHJvZ3JhbVxuICAgKiBAcGFyYW0gbG9hZGVyUHJvZ3JhbUlkIFRoZSBwcm9ncmFtIGlkIG9mIHRoZSBCUEYgbG9hZGVyIHRvIHVzZVxuICAgKiBAcmV0dXJuIHRydWUgaWYgcHJvZ3JhbSB3YXMgbG9hZGVkIHN1Y2Nlc3NmdWxseSwgZmFsc2UgaWYgcHJvZ3JhbSB3YXMgYWxyZWFkeSBsb2FkZWRcbiAgICovXG4gIHN0YXRpYyBsb2FkKGNvbm5lY3Rpb24sIHBheWVyLCBwcm9ncmFtLCBlbGYsIGxvYWRlclByb2dyYW1JZCkge1xuICAgIHJldHVybiBMb2FkZXIubG9hZChjb25uZWN0aW9uLCBwYXllciwgcHJvZ3JhbSwgbG9hZGVyUHJvZ3JhbUlkLCBlbGYpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRFeHBvcnRGcm9tQ2pzICh4KSB7XG5cdHJldHVybiB4ICYmIHguX19lc01vZHVsZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ2RlZmF1bHQnKSA/IHhbJ2RlZmF1bHQnXSA6IHg7XG59XG5cbnZhciBhZ2VudGtlZXBhbGl2ZSA9IHtleHBvcnRzOiB7fX07XG5cbi8qKlxuICogSGVscGVycy5cbiAqL1xuXG52YXIgcyA9IDEwMDA7XG52YXIgbSA9IHMgKiA2MDtcbnZhciBoID0gbSAqIDYwO1xudmFyIGQgPSBoICogMjQ7XG52YXIgdyA9IGQgKiA3O1xudmFyIHkgPSBkICogMzY1LjI1O1xuXG4vKipcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHRocm93cyB7RXJyb3J9IHRocm93IGFuIGVycm9yIGlmIHZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgbnVtYmVyXG4gKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG52YXIgbXMkMiA9IGZ1bmN0aW9uICh2YWwsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbDtcbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIHZhbC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHBhcnNlKHZhbCk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUodmFsKSkge1xuICAgIHJldHVybiBvcHRpb25zLmxvbmcgPyBmbXRMb25nKHZhbCkgOiBmbXRTaG9ydCh2YWwpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAndmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSB2YWxpZCBudW1iZXIuIHZhbD0nICtcbiAgICAgIEpTT04uc3RyaW5naWZ5KHZhbClcbiAgKTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgaWYgKHN0ci5sZW5ndGggPiAxMDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG1hdGNoID0gL14oLT8oPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHdlZWtzP3x3fHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKFxuICAgIHN0clxuICApO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3llYXJzJzpcbiAgICBjYXNlICd5ZWFyJzpcbiAgICBjYXNlICd5cnMnOlxuICAgIGNhc2UgJ3lyJzpcbiAgICBjYXNlICd5JzpcbiAgICAgIHJldHVybiBuICogeTtcbiAgICBjYXNlICd3ZWVrcyc6XG4gICAgY2FzZSAnd2Vlayc6XG4gICAgY2FzZSAndyc6XG4gICAgICByZXR1cm4gbiAqIHc7XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZDtcbiAgICBjYXNlICdob3Vycyc6XG4gICAgY2FzZSAnaG91cic6XG4gICAgY2FzZSAnaHJzJzpcbiAgICBjYXNlICdocic6XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gbiAqIGg7XG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnbWludXRlJzpcbiAgICBjYXNlICdtaW5zJzpcbiAgICBjYXNlICdtaW4nOlxuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIG4gKiBtO1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAnc2Vjcyc6XG4gICAgY2FzZSAnc2VjJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogcztcbiAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxuICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICBjYXNlICdtc2Vjcyc6XG4gICAgY2FzZSAnbXNlYyc6XG4gICAgY2FzZSAnbXMnOlxuICAgICAgcmV0dXJuIG47XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRTaG9ydChtcykge1xuICB2YXIgbXNBYnMgPSBNYXRoLmFicyhtcyk7XG4gIGlmIChtc0FicyA+PSBkKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcbiAgfVxuICBpZiAobXNBYnMgPj0gaCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IG0pIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xuICB9XG4gIGlmIChtc0FicyA+PSBzKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcbiAgfVxuICByZXR1cm4gbXMgKyAnbXMnO1xufVxuXG4vKipcbiAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10TG9uZyhtcykge1xuICB2YXIgbXNBYnMgPSBNYXRoLmFicyhtcyk7XG4gIGlmIChtc0FicyA+PSBkKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGQsICdkYXknKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gaCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBoLCAnaG91cicpO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIG0sICdtaW51dGUnKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBzLCAnc2Vjb25kJyk7XG4gIH1cbiAgcmV0dXJuIG1zICsgJyBtcyc7XG59XG5cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBtc0FicywgbiwgbmFtZSkge1xuICB2YXIgaXNQbHVyYWwgPSBtc0FicyA+PSBuICogMS41O1xuICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG4pICsgJyAnICsgbmFtZSArIChpc1BsdXJhbCA/ICdzJyA6ICcnKTtcbn1cblxuLyohXG4gKiBodW1hbml6ZS1tcyAtIGluZGV4LmpzXG4gKiBDb3B5cmlnaHQoYykgMjAxNCBkZWFkX2hvcnNlIDxkZWFkX2hvcnNlQHFxLmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgdXRpbCA9IHJlcXVpcmUkJDBfX2RlZmF1bHQuZGVmYXVsdDtcbnZhciBtcyQxID0gbXMkMjtcblxudmFyIGh1bWFuaXplTXMgPSBmdW5jdGlvbiAodCkge1xuICBpZiAodHlwZW9mIHQgPT09ICdudW1iZXInKSByZXR1cm4gdDtcbiAgdmFyIHIgPSBtcyQxKHQpO1xuICBpZiAociA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcih1dGlsLmZvcm1hdCgnaHVtYW5pemUtbXMoJWopIHJlc3VsdCB1bmRlZmluZWQnLCB0KSk7XG4gICAgY29uc29sZS53YXJuKGVyci5zdGFjayk7XG4gIH1cbiAgcmV0dXJuIHI7XG59O1xuXG52YXIgY29uc3RhbnRzID0ge1xuICAvLyBhZ2VudFxuICBDVVJSRU5UX0lEOiBTeW1ib2woJ2FnZW50a2VlcGFsaXZlI2N1cnJlbnRJZCcpLFxuICBDUkVBVEVfSUQ6IFN5bWJvbCgnYWdlbnRrZWVwYWxpdmUjY3JlYXRlSWQnKSxcbiAgSU5JVF9TT0NLRVQ6IFN5bWJvbCgnYWdlbnRrZWVwYWxpdmUjaW5pdFNvY2tldCcpLFxuICBDUkVBVEVfSFRUUFNfQ09OTkVDVElPTjogU3ltYm9sKCdhZ2VudGtlZXBhbGl2ZSNjcmVhdGVIdHRwc0Nvbm5lY3Rpb24nKSxcbiAgLy8gc29ja2V0XG4gIFNPQ0tFVF9DUkVBVEVEX1RJTUU6IFN5bWJvbCgnYWdlbnRrZWVwYWxpdmUjc29ja2V0Q3JlYXRlZFRpbWUnKSxcbiAgU09DS0VUX05BTUU6IFN5bWJvbCgnYWdlbnRrZWVwYWxpdmUjc29ja2V0TmFtZScpLFxuICBTT0NLRVRfUkVRVUVTVF9DT1VOVDogU3ltYm9sKCdhZ2VudGtlZXBhbGl2ZSNzb2NrZXRSZXF1ZXN0Q291bnQnKSxcbiAgU09DS0VUX1JFUVVFU1RfRklOSVNIRURfQ09VTlQ6IFN5bWJvbCgnYWdlbnRrZWVwYWxpdmUjc29ja2V0UmVxdWVzdEZpbmlzaGVkQ291bnQnKSxcbn07XG5cbmNvbnN0IE9yaWdpbmFsQWdlbnQgPSByZXF1aXJlJCQwX19kZWZhdWx0JDEuZGVmYXVsdC5BZ2VudDtcbmNvbnN0IG1zID0gaHVtYW5pemVNcztcbmNvbnN0IGRlYnVnID0gcmVxdWlyZSQkMF9fZGVmYXVsdC5kZWZhdWx0LmRlYnVnbG9nKCdhZ2VudGtlZXBhbGl2ZScpO1xuY29uc3Qge1xuICBJTklUX1NPQ0tFVDogSU5JVF9TT0NLRVQkMSxcbiAgQ1VSUkVOVF9JRCxcbiAgQ1JFQVRFX0lELFxuICBTT0NLRVRfQ1JFQVRFRF9USU1FLFxuICBTT0NLRVRfTkFNRSxcbiAgU09DS0VUX1JFUVVFU1RfQ09VTlQsXG4gIFNPQ0tFVF9SRVFVRVNUX0ZJTklTSEVEX0NPVU5ULFxufSA9IGNvbnN0YW50cztcblxuLy8gT3JpZ2luYWxBZ2VudCBjb21lIGZyb21cbi8vIC0gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvdjguMTIuMC9saWIvX2h0dHBfYWdlbnQuanNcbi8vIC0gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvdjEwLjEyLjAvbGliL19odHRwX2FnZW50LmpzXG5cbi8vIG5vZGUgPD0gMTBcbmxldCBkZWZhdWx0VGltZW91dExpc3RlbmVyQ291bnQgPSAxO1xuY29uc3QgbWFqb3JWZXJzaW9uID0gcGFyc2VJbnQocHJvY2Vzcy52ZXJzaW9uLnNwbGl0KCcuJywgMSlbMF0uc3Vic3RyaW5nKDEpKTtcbmlmIChtYWpvclZlcnNpb24gPj0gMTEgJiYgbWFqb3JWZXJzaW9uIDw9IDEyKSB7XG4gIGRlZmF1bHRUaW1lb3V0TGlzdGVuZXJDb3VudCA9IDI7XG59IGVsc2UgaWYgKG1ham9yVmVyc2lvbiA+PSAxMykge1xuICBkZWZhdWx0VGltZW91dExpc3RlbmVyQ291bnQgPSAzO1xufVxuXG5mdW5jdGlvbiBkZXByZWNhdGUobWVzc2FnZSkge1xuICBjb25zb2xlLmxvZygnW2FnZW50a2VlcGFsaXZlOmRlcHJlY2F0ZWRdICVzJywgbWVzc2FnZSk7XG59XG5cbmNsYXNzIEFnZW50IGV4dGVuZHMgT3JpZ2luYWxBZ2VudCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLmtlZXBBbGl2ZSA9IG9wdGlvbnMua2VlcEFsaXZlICE9PSBmYWxzZTtcbiAgICAvLyBkZWZhdWx0IGlzIGtlZXAtYWxpdmUgYW5kIDRzIGZyZWUgc29ja2V0IHRpbWVvdXRcbiAgICAvLyBzZWUgaHR0cHM6Ly9tZWRpdW0uY29tL3NzZW5zZS10ZWNoL3JlZHVjZS1uZXR3b3JraW5nLWVycm9ycy1pbi1ub2RlanMtMjNiNGViOWYyZDgzXG4gICAgaWYgKG9wdGlvbnMuZnJlZVNvY2tldFRpbWVvdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgb3B0aW9ucy5mcmVlU29ja2V0VGltZW91dCA9IDQwMDA7XG4gICAgfVxuICAgIC8vIExlZ2FjeSBBUEk6IGtlZXBBbGl2ZVRpbWVvdXQgc2hvdWxkIGJlIHJlbmFtZSB0byBgZnJlZVNvY2tldFRpbWVvdXRgXG4gICAgaWYgKG9wdGlvbnMua2VlcEFsaXZlVGltZW91dCkge1xuICAgICAgZGVwcmVjYXRlKCdvcHRpb25zLmtlZXBBbGl2ZVRpbWVvdXQgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBvcHRpb25zLmZyZWVTb2NrZXRUaW1lb3V0IGluc3RlYWQnKTtcbiAgICAgIG9wdGlvbnMuZnJlZVNvY2tldFRpbWVvdXQgPSBvcHRpb25zLmtlZXBBbGl2ZVRpbWVvdXQ7XG4gICAgICBkZWxldGUgb3B0aW9ucy5rZWVwQWxpdmVUaW1lb3V0O1xuICAgIH1cbiAgICAvLyBMZWdhY3kgQVBJOiBmcmVlU29ja2V0S2VlcEFsaXZlVGltZW91dCBzaG91bGQgYmUgcmVuYW1lIHRvIGBmcmVlU29ja2V0VGltZW91dGBcbiAgICBpZiAob3B0aW9ucy5mcmVlU29ja2V0S2VlcEFsaXZlVGltZW91dCkge1xuICAgICAgZGVwcmVjYXRlKCdvcHRpb25zLmZyZWVTb2NrZXRLZWVwQWxpdmVUaW1lb3V0IGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2Ugb3B0aW9ucy5mcmVlU29ja2V0VGltZW91dCBpbnN0ZWFkJyk7XG4gICAgICBvcHRpb25zLmZyZWVTb2NrZXRUaW1lb3V0ID0gb3B0aW9ucy5mcmVlU29ja2V0S2VlcEFsaXZlVGltZW91dDtcbiAgICAgIGRlbGV0ZSBvcHRpb25zLmZyZWVTb2NrZXRLZWVwQWxpdmVUaW1lb3V0O1xuICAgIH1cblxuICAgIC8vIFNldHMgdGhlIHNvY2tldCB0byB0aW1lb3V0IGFmdGVyIHRpbWVvdXQgbWlsbGlzZWNvbmRzIG9mIGluYWN0aXZpdHkgb24gdGhlIHNvY2tldC5cbiAgICAvLyBCeSBkZWZhdWx0IGlzIGRvdWJsZSBmcmVlIHNvY2tldCB0aW1lb3V0LlxuICAgIGlmIChvcHRpb25zLnRpbWVvdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gbWFrZSBzdXJlIHNvY2tldCBkZWZhdWx0IGluYWN0aXZpdHkgdGltZW91dCA+PSA4c1xuICAgICAgb3B0aW9ucy50aW1lb3V0ID0gTWF0aC5tYXgob3B0aW9ucy5mcmVlU29ja2V0VGltZW91dCAqIDIsIDgwMDApO1xuICAgIH1cblxuICAgIC8vIHN1cHBvcnQgaHVtYW5pemUgZm9ybWF0XG4gICAgb3B0aW9ucy50aW1lb3V0ID0gbXMob3B0aW9ucy50aW1lb3V0KTtcbiAgICBvcHRpb25zLmZyZWVTb2NrZXRUaW1lb3V0ID0gbXMob3B0aW9ucy5mcmVlU29ja2V0VGltZW91dCk7XG4gICAgb3B0aW9ucy5zb2NrZXRBY3RpdmVUVEwgPSBvcHRpb25zLnNvY2tldEFjdGl2ZVRUTCA/IG1zKG9wdGlvbnMuc29ja2V0QWN0aXZlVFRMKSA6IDA7XG5cbiAgICBzdXBlcihvcHRpb25zKTtcblxuICAgIHRoaXNbQ1VSUkVOVF9JRF0gPSAwO1xuXG4gICAgLy8gY3JlYXRlIHNvY2tldCBzdWNjZXNzIGNvdW50ZXJcbiAgICB0aGlzLmNyZWF0ZVNvY2tldENvdW50ID0gMDtcbiAgICB0aGlzLmNyZWF0ZVNvY2tldENvdW50TGFzdENoZWNrID0gMDtcblxuICAgIHRoaXMuY3JlYXRlU29ja2V0RXJyb3JDb3VudCA9IDA7XG4gICAgdGhpcy5jcmVhdGVTb2NrZXRFcnJvckNvdW50TGFzdENoZWNrID0gMDtcblxuICAgIHRoaXMuY2xvc2VTb2NrZXRDb3VudCA9IDA7XG4gICAgdGhpcy5jbG9zZVNvY2tldENvdW50TGFzdENoZWNrID0gMDtcblxuICAgIC8vIHNvY2tldCBlcnJvciBldmVudCBjb3VudFxuICAgIHRoaXMuZXJyb3JTb2NrZXRDb3VudCA9IDA7XG4gICAgdGhpcy5lcnJvclNvY2tldENvdW50TGFzdENoZWNrID0gMDtcblxuICAgIC8vIHJlcXVlc3QgZmluaXNoZWQgY291bnRlclxuICAgIHRoaXMucmVxdWVzdENvdW50ID0gMDtcbiAgICB0aGlzLnJlcXVlc3RDb3VudExhc3RDaGVjayA9IDA7XG5cbiAgICAvLyBpbmNsdWRpbmcgZnJlZSBzb2NrZXQgdGltZW91dCBjb3VudGVyXG4gICAgdGhpcy50aW1lb3V0U29ja2V0Q291bnQgPSAwO1xuICAgIHRoaXMudGltZW91dFNvY2tldENvdW50TGFzdENoZWNrID0gMDtcblxuICAgIHRoaXMub24oJ2ZyZWUnLCBzb2NrZXQgPT4ge1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL3B1bGwvMzIwMDBcbiAgICAgIC8vIE5vZGUuanMgbmF0aXZlIGFnZW50IHdpbGwgY2hlY2sgc29ja2V0IHRpbWVvdXQgZXFzIGFnZW50Lm9wdGlvbnMudGltZW91dC5cbiAgICAgIC8vIFVzZSB0aGUgdHRsIG9yIGZyZWVTb2NrZXRUaW1lb3V0IHRvIG92ZXJ3cml0ZS5cbiAgICAgIGNvbnN0IHRpbWVvdXQgPSB0aGlzLmNhbGNTb2NrZXRUaW1lb3V0KHNvY2tldCk7XG4gICAgICBpZiAodGltZW91dCA+IDAgJiYgc29ja2V0LnRpbWVvdXQgIT09IHRpbWVvdXQpIHtcbiAgICAgICAgc29ja2V0LnNldFRpbWVvdXQodGltZW91dCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBnZXQgZnJlZVNvY2tldEtlZXBBbGl2ZVRpbWVvdXQoKSB7XG4gICAgZGVwcmVjYXRlKCdhZ2VudC5mcmVlU29ja2V0S2VlcEFsaXZlVGltZW91dCBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIGFnZW50Lm9wdGlvbnMuZnJlZVNvY2tldFRpbWVvdXQgaW5zdGVhZCcpO1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZnJlZVNvY2tldFRpbWVvdXQ7XG4gIH1cblxuICBnZXQgdGltZW91dCgpIHtcbiAgICBkZXByZWNhdGUoJ2FnZW50LnRpbWVvdXQgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBhZ2VudC5vcHRpb25zLnRpbWVvdXQgaW5zdGVhZCcpO1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMudGltZW91dDtcbiAgfVxuXG4gIGdldCBzb2NrZXRBY3RpdmVUVEwoKSB7XG4gICAgZGVwcmVjYXRlKCdhZ2VudC5zb2NrZXRBY3RpdmVUVEwgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBhZ2VudC5vcHRpb25zLnNvY2tldEFjdGl2ZVRUTCBpbnN0ZWFkJyk7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5zb2NrZXRBY3RpdmVUVEw7XG4gIH1cblxuICBjYWxjU29ja2V0VGltZW91dChzb2NrZXQpIHtcbiAgICAvKipcbiAgICAgKiByZXR1cm4gPD0gMDogc2hvdWxkIGZyZWUgc29ja2V0XG4gICAgICogcmV0dXJuID4gMDogc2hvdWxkIHVwZGF0ZSBzb2NrZXQgdGltZW91dFxuICAgICAqIHJldHVybiB1bmRlZmluZWQ6IG5vdCBmaW5kIGN1c3RvbSB0aW1lb3V0XG4gICAgICovXG4gICAgbGV0IGZyZWVTb2NrZXRUaW1lb3V0ID0gdGhpcy5vcHRpb25zLmZyZWVTb2NrZXRUaW1lb3V0O1xuICAgIGNvbnN0IHNvY2tldEFjdGl2ZVRUTCA9IHRoaXMub3B0aW9ucy5zb2NrZXRBY3RpdmVUVEw7XG4gICAgaWYgKHNvY2tldEFjdGl2ZVRUTCkge1xuICAgICAgLy8gY2hlY2sgc29ja2V0QWN0aXZlVFRMXG4gICAgICBjb25zdCBhbGl2ZVRpbWUgPSBEYXRlLm5vdygpIC0gc29ja2V0W1NPQ0tFVF9DUkVBVEVEX1RJTUVdO1xuICAgICAgY29uc3QgZGlmZiA9IHNvY2tldEFjdGl2ZVRUTCAtIGFsaXZlVGltZTtcbiAgICAgIGlmIChkaWZmIDw9IDApIHtcbiAgICAgICAgcmV0dXJuIGRpZmY7XG4gICAgICB9XG4gICAgICBpZiAoZnJlZVNvY2tldFRpbWVvdXQgJiYgZGlmZiA8IGZyZWVTb2NrZXRUaW1lb3V0KSB7XG4gICAgICAgIGZyZWVTb2NrZXRUaW1lb3V0ID0gZGlmZjtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gc2V0IGZyZWVTb2NrZXRUaW1lb3V0XG4gICAgaWYgKGZyZWVTb2NrZXRUaW1lb3V0KSB7XG4gICAgICAvLyBzZXQgZnJlZSBrZWVwYWxpdmUgdGltZXJcbiAgICAgIC8vIHRyeSB0byB1c2Ugc29ja2V0IGN1c3RvbSBmcmVlU29ja2V0VGltZW91dCBmaXJzdCwgc3VwcG9ydCBoZWFkZXJzWydrZWVwLWFsaXZlJ11cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlLW1vZHVsZXMvdXJsbGliL2Jsb2IvYjc2MDUzMDIwOTIzZjRkOTlhMWM5M2NmMmUxNmUwYzViYTEwYmFjZi9saWIvdXJsbGliLmpzI0w0OThcbiAgICAgIGNvbnN0IGN1c3RvbUZyZWVTb2NrZXRUaW1lb3V0ID0gc29ja2V0LmZyZWVTb2NrZXRUaW1lb3V0IHx8IHNvY2tldC5mcmVlU29ja2V0S2VlcEFsaXZlVGltZW91dDtcbiAgICAgIHJldHVybiBjdXN0b21GcmVlU29ja2V0VGltZW91dCB8fCBmcmVlU29ja2V0VGltZW91dDtcbiAgICB9XG4gIH1cblxuICBrZWVwU29ja2V0QWxpdmUoc29ja2V0KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gc3VwZXIua2VlcFNvY2tldEFsaXZlKHNvY2tldCk7XG4gICAgLy8gc2hvdWxkIG5vdCBrZWVwQWxpdmUsIGRvIG5vdGhpbmdcbiAgICBpZiAoIXJlc3VsdCkgcmV0dXJuIHJlc3VsdDtcblxuICAgIGNvbnN0IGN1c3RvbVRpbWVvdXQgPSB0aGlzLmNhbGNTb2NrZXRUaW1lb3V0KHNvY2tldCk7XG4gICAgaWYgKHR5cGVvZiBjdXN0b21UaW1lb3V0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChjdXN0b21UaW1lb3V0IDw9IDApIHtcbiAgICAgIGRlYnVnKCclcyhyZXF1ZXN0czogJXMsIGZpbmlzaGVkOiAlcykgZnJlZSBidXQgbmVlZCB0byBkZXN0cm95IGJ5IFRUTCwgcmVxdWVzdCBjb3VudCAlcywgZGlmZiBpcyAlcycsXG4gICAgICAgIHNvY2tldFtTT0NLRVRfTkFNRV0sIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9DT1VOVF0sIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9GSU5JU0hFRF9DT1VOVF0sIGN1c3RvbVRpbWVvdXQpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoc29ja2V0LnRpbWVvdXQgIT09IGN1c3RvbVRpbWVvdXQpIHtcbiAgICAgIHNvY2tldC5zZXRUaW1lb3V0KGN1c3RvbVRpbWVvdXQpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIG9ubHkgY2FsbCBvbiBhZGRSZXF1ZXN0XG4gIHJldXNlU29ja2V0KC4uLmFyZ3MpIHtcbiAgICAvLyByZXVzZVNvY2tldChzb2NrZXQsIHJlcSlcbiAgICBzdXBlci5yZXVzZVNvY2tldCguLi5hcmdzKTtcbiAgICBjb25zdCBzb2NrZXQgPSBhcmdzWzBdO1xuICAgIGNvbnN0IHJlcSA9IGFyZ3NbMV07XG4gICAgcmVxLnJldXNlZFNvY2tldCA9IHRydWU7XG4gICAgY29uc3QgYWdlbnRUaW1lb3V0ID0gdGhpcy5vcHRpb25zLnRpbWVvdXQ7XG4gICAgaWYgKGdldFNvY2tldFRpbWVvdXQoc29ja2V0KSAhPT0gYWdlbnRUaW1lb3V0KSB7XG4gICAgICAvLyByZXNldCB0aW1lb3V0IGJlZm9yZSB1c2VcbiAgICAgIHNvY2tldC5zZXRUaW1lb3V0KGFnZW50VGltZW91dCk7XG4gICAgICBkZWJ1ZygnJXMgcmVzZXQgdGltZW91dCB0byAlc21zJywgc29ja2V0W1NPQ0tFVF9OQU1FXSwgYWdlbnRUaW1lb3V0KTtcbiAgICB9XG4gICAgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0NPVU5UXSsrO1xuICAgIGRlYnVnKCclcyhyZXF1ZXN0czogJXMsIGZpbmlzaGVkOiAlcykgcmV1c2Ugb24gYWRkUmVxdWVzdCwgdGltZW91dCAlc21zJyxcbiAgICAgIHNvY2tldFtTT0NLRVRfTkFNRV0sIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9DT1VOVF0sIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9GSU5JU0hFRF9DT1VOVF0sXG4gICAgICBnZXRTb2NrZXRUaW1lb3V0KHNvY2tldCkpO1xuICB9XG5cbiAgW0NSRUFURV9JRF0oKSB7XG4gICAgY29uc3QgaWQgPSB0aGlzW0NVUlJFTlRfSURdKys7XG4gICAgaWYgKHRoaXNbQ1VSUkVOVF9JRF0gPT09IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSB0aGlzW0NVUlJFTlRfSURdID0gMDtcbiAgICByZXR1cm4gaWQ7XG4gIH1cblxuICBbSU5JVF9TT0NLRVQkMV0oc29ja2V0LCBvcHRpb25zKSB7XG4gICAgLy8gYnVnZml4IGhlcmUuXG4gICAgLy8gaHR0cHMgb24gbm9kZSA4LCAxMCB3b24ndCBzZXQgYWdlbnQub3B0aW9ucy50aW1lb3V0IGJ5IGRlZmF1bHRcbiAgICAvLyBUT0RPOiBuZWVkIHRvIGZpeCBvbiBub2RlIGl0c2VsZlxuICAgIGlmIChvcHRpb25zLnRpbWVvdXQpIHtcbiAgICAgIGNvbnN0IHRpbWVvdXQgPSBnZXRTb2NrZXRUaW1lb3V0KHNvY2tldCk7XG4gICAgICBpZiAoIXRpbWVvdXQpIHtcbiAgICAgICAgc29ja2V0LnNldFRpbWVvdXQob3B0aW9ucy50aW1lb3V0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmtlZXBBbGl2ZSkge1xuICAgICAgLy8gRGlzYWJsZSBOYWdsZSdzIGFsZ29yaXRobTogaHR0cDovL2Jsb2cuY2F1c3Rpay5jb20vMjAxMi8wNC8wOC9zY2FsaW5nLW5vZGUtanMtdG8tMTAway1jb25jdXJyZW50LWNvbm5lY3Rpb25zL1xuICAgICAgLy8gaHR0cHM6Ly9mZW5nbWsyLmNvbS9iZW5jaG1hcmsvbmFnbGUtYWxnb3JpdGhtLWRlbGF5ZWQtYWNrLW1vY2suaHRtbFxuICAgICAgc29ja2V0LnNldE5vRGVsYXkodHJ1ZSk7XG4gICAgfVxuICAgIHRoaXMuY3JlYXRlU29ja2V0Q291bnQrKztcbiAgICBpZiAodGhpcy5vcHRpb25zLnNvY2tldEFjdGl2ZVRUTCkge1xuICAgICAgc29ja2V0W1NPQ0tFVF9DUkVBVEVEX1RJTUVdID0gRGF0ZS5ub3coKTtcbiAgICB9XG4gICAgLy8gZG9uJ3Qgc2hvdyB0aGUgaG9sZSAnLS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0nIGtleSBzdHJpbmdcbiAgICBzb2NrZXRbU09DS0VUX05BTUVdID0gYHNvY2tbJHt0aGlzW0NSRUFURV9JRF0oKX0jJHtvcHRpb25zLl9hZ2VudEtleX1dYC5zcGxpdCgnLS0tLS1CRUdJTicsIDEpWzBdO1xuICAgIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9DT1VOVF0gPSAxO1xuICAgIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9GSU5JU0hFRF9DT1VOVF0gPSAwO1xuICAgIGluc3RhbGxMaXN0ZW5lcnModGhpcywgc29ja2V0LCBvcHRpb25zKTtcbiAgfVxuXG4gIGNyZWF0ZUNvbm5lY3Rpb24ob3B0aW9ucywgb25jcmVhdGUpIHtcbiAgICBsZXQgY2FsbGVkID0gZmFsc2U7XG4gICAgY29uc3Qgb25OZXdDcmVhdGUgPSAoZXJyLCBzb2NrZXQpID0+IHtcbiAgICAgIGlmIChjYWxsZWQpIHJldHVybjtcbiAgICAgIGNhbGxlZCA9IHRydWU7XG5cbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgdGhpcy5jcmVhdGVTb2NrZXRFcnJvckNvdW50Kys7XG4gICAgICAgIHJldHVybiBvbmNyZWF0ZShlcnIpO1xuICAgICAgfVxuICAgICAgdGhpc1tJTklUX1NPQ0tFVCQxXShzb2NrZXQsIG9wdGlvbnMpO1xuICAgICAgb25jcmVhdGUoZXJyLCBzb2NrZXQpO1xuICAgIH07XG5cbiAgICBjb25zdCBuZXdTb2NrZXQgPSBzdXBlci5jcmVhdGVDb25uZWN0aW9uKG9wdGlvbnMsIG9uTmV3Q3JlYXRlKTtcbiAgICBpZiAobmV3U29ja2V0KSBvbk5ld0NyZWF0ZShudWxsLCBuZXdTb2NrZXQpO1xuICAgIHJldHVybiBuZXdTb2NrZXQ7XG4gIH1cblxuICBnZXQgc3RhdHVzQ2hhbmdlZCgpIHtcbiAgICBjb25zdCBjaGFuZ2VkID0gdGhpcy5jcmVhdGVTb2NrZXRDb3VudCAhPT0gdGhpcy5jcmVhdGVTb2NrZXRDb3VudExhc3RDaGVjayB8fFxuICAgICAgdGhpcy5jcmVhdGVTb2NrZXRFcnJvckNvdW50ICE9PSB0aGlzLmNyZWF0ZVNvY2tldEVycm9yQ291bnRMYXN0Q2hlY2sgfHxcbiAgICAgIHRoaXMuY2xvc2VTb2NrZXRDb3VudCAhPT0gdGhpcy5jbG9zZVNvY2tldENvdW50TGFzdENoZWNrIHx8XG4gICAgICB0aGlzLmVycm9yU29ja2V0Q291bnQgIT09IHRoaXMuZXJyb3JTb2NrZXRDb3VudExhc3RDaGVjayB8fFxuICAgICAgdGhpcy50aW1lb3V0U29ja2V0Q291bnQgIT09IHRoaXMudGltZW91dFNvY2tldENvdW50TGFzdENoZWNrIHx8XG4gICAgICB0aGlzLnJlcXVlc3RDb3VudCAhPT0gdGhpcy5yZXF1ZXN0Q291bnRMYXN0Q2hlY2s7XG4gICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgIHRoaXMuY3JlYXRlU29ja2V0Q291bnRMYXN0Q2hlY2sgPSB0aGlzLmNyZWF0ZVNvY2tldENvdW50O1xuICAgICAgdGhpcy5jcmVhdGVTb2NrZXRFcnJvckNvdW50TGFzdENoZWNrID0gdGhpcy5jcmVhdGVTb2NrZXRFcnJvckNvdW50O1xuICAgICAgdGhpcy5jbG9zZVNvY2tldENvdW50TGFzdENoZWNrID0gdGhpcy5jbG9zZVNvY2tldENvdW50O1xuICAgICAgdGhpcy5lcnJvclNvY2tldENvdW50TGFzdENoZWNrID0gdGhpcy5lcnJvclNvY2tldENvdW50O1xuICAgICAgdGhpcy50aW1lb3V0U29ja2V0Q291bnRMYXN0Q2hlY2sgPSB0aGlzLnRpbWVvdXRTb2NrZXRDb3VudDtcbiAgICAgIHRoaXMucmVxdWVzdENvdW50TGFzdENoZWNrID0gdGhpcy5yZXF1ZXN0Q291bnQ7XG4gICAgfVxuICAgIHJldHVybiBjaGFuZ2VkO1xuICB9XG5cbiAgZ2V0Q3VycmVudFN0YXR1cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY3JlYXRlU29ja2V0Q291bnQ6IHRoaXMuY3JlYXRlU29ja2V0Q291bnQsXG4gICAgICBjcmVhdGVTb2NrZXRFcnJvckNvdW50OiB0aGlzLmNyZWF0ZVNvY2tldEVycm9yQ291bnQsXG4gICAgICBjbG9zZVNvY2tldENvdW50OiB0aGlzLmNsb3NlU29ja2V0Q291bnQsXG4gICAgICBlcnJvclNvY2tldENvdW50OiB0aGlzLmVycm9yU29ja2V0Q291bnQsXG4gICAgICB0aW1lb3V0U29ja2V0Q291bnQ6IHRoaXMudGltZW91dFNvY2tldENvdW50LFxuICAgICAgcmVxdWVzdENvdW50OiB0aGlzLnJlcXVlc3RDb3VudCxcbiAgICAgIGZyZWVTb2NrZXRzOiBpbnNwZWN0KHRoaXMuZnJlZVNvY2tldHMpLFxuICAgICAgc29ja2V0czogaW5zcGVjdCh0aGlzLnNvY2tldHMpLFxuICAgICAgcmVxdWVzdHM6IGluc3BlY3QodGhpcy5yZXF1ZXN0cyksXG4gICAgfTtcbiAgfVxufVxuXG4vLyBub2RlIDggZG9uJ3QgaGFzIHRpbWVvdXQgYXR0cmlidXRlIG9uIHNvY2tldFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL3B1bGwvMjEyMDQvZmlsZXMjZGlmZi1lNmVmMDI0YzM3NzVkNzg3YzM4NDg3YTYzMDllNDkxZFI0MDhcbmZ1bmN0aW9uIGdldFNvY2tldFRpbWVvdXQoc29ja2V0KSB7XG4gIHJldHVybiBzb2NrZXQudGltZW91dCB8fCBzb2NrZXQuX2lkbGVUaW1lb3V0O1xufVxuXG5mdW5jdGlvbiBpbnN0YWxsTGlzdGVuZXJzKGFnZW50LCBzb2NrZXQsIG9wdGlvbnMpIHtcbiAgZGVidWcoJyVzIGNyZWF0ZSwgdGltZW91dCAlc21zJywgc29ja2V0W1NPQ0tFVF9OQU1FXSwgZ2V0U29ja2V0VGltZW91dChzb2NrZXQpKTtcblxuICAvLyBsaXN0ZW5lciBzb2NrZXQgZXZlbnRzOiBjbG9zZSwgdGltZW91dCwgZXJyb3IsIGZyZWVcbiAgZnVuY3Rpb24gb25GcmVlKCkge1xuICAgIC8vIGNyZWF0ZSBhbmQgc29ja2V0LmVtaXQoJ2ZyZWUnKSBsb2dpY1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL21hc3Rlci9saWIvX2h0dHBfYWdlbnQuanMjTDMxMVxuICAgIC8vIG5vIHJlcSBvbiB0aGUgc29ja2V0LCBpdCBzaG91bGQgYmUgdGhlIG5ldyBzb2NrZXRcbiAgICBpZiAoIXNvY2tldC5faHR0cE1lc3NhZ2UgJiYgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0NPVU5UXSA9PT0gMSkgcmV0dXJuO1xuXG4gICAgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0ZJTklTSEVEX0NPVU5UXSsrO1xuICAgIGFnZW50LnJlcXVlc3RDb3VudCsrO1xuICAgIGRlYnVnKCclcyhyZXF1ZXN0czogJXMsIGZpbmlzaGVkOiAlcykgZnJlZScsXG4gICAgICBzb2NrZXRbU09DS0VUX05BTUVdLCBzb2NrZXRbU09DS0VUX1JFUVVFU1RfQ09VTlRdLCBzb2NrZXRbU09DS0VUX1JFUVVFU1RfRklOSVNIRURfQ09VTlRdKTtcblxuICAgIC8vIHNob3VsZCByZXVzZSBvbiBwZWRkaW5nIHJlcXVlc3RzP1xuICAgIGNvbnN0IG5hbWUgPSBhZ2VudC5nZXROYW1lKG9wdGlvbnMpO1xuICAgIGlmIChzb2NrZXQud3JpdGFibGUgJiYgYWdlbnQucmVxdWVzdHNbbmFtZV0gJiYgYWdlbnQucmVxdWVzdHNbbmFtZV0ubGVuZ3RoKSB7XG4gICAgICAvLyB3aWxsIGJlIHJldXNlIG9uIGFnZW50IGZyZWUgbGlzdGVuZXJcbiAgICAgIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9DT1VOVF0rKztcbiAgICAgIGRlYnVnKCclcyhyZXF1ZXN0czogJXMsIGZpbmlzaGVkOiAlcykgd2lsbCBiZSByZXVzZSBvbiBhZ2VudCBmcmVlIGV2ZW50JyxcbiAgICAgICAgc29ja2V0W1NPQ0tFVF9OQU1FXSwgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0NPVU5UXSwgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0ZJTklTSEVEX0NPVU5UXSk7XG4gICAgfVxuICB9XG4gIHNvY2tldC5vbignZnJlZScsIG9uRnJlZSk7XG5cbiAgZnVuY3Rpb24gb25DbG9zZShpc0Vycm9yKSB7XG4gICAgZGVidWcoJyVzKHJlcXVlc3RzOiAlcywgZmluaXNoZWQ6ICVzKSBjbG9zZSwgaXNFcnJvcjogJXMnLFxuICAgICAgc29ja2V0W1NPQ0tFVF9OQU1FXSwgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0NPVU5UXSwgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0ZJTklTSEVEX0NPVU5UXSwgaXNFcnJvcik7XG4gICAgYWdlbnQuY2xvc2VTb2NrZXRDb3VudCsrO1xuICB9XG4gIHNvY2tldC5vbignY2xvc2UnLCBvbkNsb3NlKTtcblxuICAvLyBzdGFydCBzb2NrZXQgdGltZW91dCBoYW5kbGVyXG4gIGZ1bmN0aW9uIG9uVGltZW91dCgpIHtcbiAgICAvLyBvblRpbWVvdXQgYW5kIGVtaXRSZXF1ZXN0VGltZW91dChfaHR0cF9jbGllbnQuanMpXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvdjEyLngvbGliL19odHRwX2NsaWVudC5qcyNMNzExXG4gICAgY29uc3QgbGlzdGVuZXJDb3VudCA9IHNvY2tldC5saXN0ZW5lcnMoJ3RpbWVvdXQnKS5sZW5ndGg7XG4gICAgLy8gbm9kZSA8PSAxMCwgZGVmYXVsdCBsaXN0ZW5lckNvdW50IGlzIDEsIG9uVGltZW91dFxuICAgIC8vIDExIDwgbm9kZSA8PSAxMiwgZGVmYXVsdCBsaXN0ZW5lckNvdW50IGlzIDIsIG9uVGltZW91dCBhbmQgZW1pdFJlcXVlc3RUaW1lb3V0XG4gICAgLy8gbm9kZSA+PSAxMywgZGVmYXVsdCBsaXN0ZW5lckNvdW50IGlzIDMsIG9uVGltZW91dCxcbiAgICAvLyAgIG9uVGltZW91dChodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvcHVsbC8zMjAwMC9maWxlcyNkaWZmLTVmN2ZiMDg1MDQxMmM2YmUxODlmYWVkZGVhNmM1MzU5UjMzMylcbiAgICAvLyAgIGFuZCBlbWl0UmVxdWVzdFRpbWVvdXRcbiAgICBjb25zdCB0aW1lb3V0ID0gZ2V0U29ja2V0VGltZW91dChzb2NrZXQpO1xuICAgIGNvbnN0IHJlcSA9IHNvY2tldC5faHR0cE1lc3NhZ2U7XG4gICAgY29uc3QgcmVxVGltZW91dExpc3RlbmVyQ291bnQgPSByZXEgJiYgcmVxLmxpc3RlbmVycygndGltZW91dCcpLmxlbmd0aCB8fCAwO1xuICAgIGRlYnVnKCclcyhyZXF1ZXN0czogJXMsIGZpbmlzaGVkOiAlcykgdGltZW91dCBhZnRlciAlc21zLCBsaXN0ZW5lcnMgJXMsIGRlZmF1bHRUaW1lb3V0TGlzdGVuZXJDb3VudCAlcywgaGFzSHR0cFJlcXVlc3QgJXMsIEh0dHBSZXF1ZXN0IHRpbWVvdXRMaXN0ZW5lckNvdW50ICVzJyxcbiAgICAgIHNvY2tldFtTT0NLRVRfTkFNRV0sIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9DT1VOVF0sIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9GSU5JU0hFRF9DT1VOVF0sXG4gICAgICB0aW1lb3V0LCBsaXN0ZW5lckNvdW50LCBkZWZhdWx0VGltZW91dExpc3RlbmVyQ291bnQsICEhcmVxLCByZXFUaW1lb3V0TGlzdGVuZXJDb3VudCk7XG4gICAgaWYgKGRlYnVnLmVuYWJsZWQpIHtcbiAgICAgIGRlYnVnKCd0aW1lb3V0IGxpc3RlbmVyczogJXMnLCBzb2NrZXQubGlzdGVuZXJzKCd0aW1lb3V0JykubWFwKGYgPT4gZi5uYW1lKS5qb2luKCcsICcpKTtcbiAgICB9XG4gICAgYWdlbnQudGltZW91dFNvY2tldENvdW50Kys7XG4gICAgY29uc3QgbmFtZSA9IGFnZW50LmdldE5hbWUob3B0aW9ucyk7XG4gICAgaWYgKGFnZW50LmZyZWVTb2NrZXRzW25hbWVdICYmIGFnZW50LmZyZWVTb2NrZXRzW25hbWVdLmluZGV4T2Yoc29ja2V0KSAhPT0gLTEpIHtcbiAgICAgIC8vIGZyZWUgc29ja2V0IHRpbWVvdXQsIGRlc3Ryb3kgcXVpZXRseVxuICAgICAgc29ja2V0LmRlc3Ryb3koKTtcbiAgICAgIC8vIFJlbW92ZSBpdCBmcm9tIGZyZWVTb2NrZXRzIGxpc3QgaW1tZWRpYXRlbHkgdG8gcHJldmVudCBuZXcgcmVxdWVzdHNcbiAgICAgIC8vIGZyb20gYmVpbmcgc2VudCB0aHJvdWdoIHRoaXMgc29ja2V0LlxuICAgICAgYWdlbnQucmVtb3ZlU29ja2V0KHNvY2tldCwgb3B0aW9ucyk7XG4gICAgICBkZWJ1ZygnJXMgaXMgZnJlZSwgZGVzdHJveSBxdWlldGx5Jywgc29ja2V0W1NPQ0tFVF9OQU1FXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIGFueSByZXF1ZXN0IHNvY2tldCB0aW1lb3V0IGhhbmRsZXIsXG4gICAgICAvLyBhZ2VudCBuZWVkIHRvIGhhbmRsZSBzb2NrZXQgdGltZW91dCBpdHNlbGYuXG4gICAgICAvL1xuICAgICAgLy8gY3VzdG9tIHJlcXVlc3Qgc29ja2V0IHRpbWVvdXQgaGFuZGxlIGxvZ2ljIG11c3QgZm9sbG93IHRoZXNlIHJ1bGVzOlxuICAgICAgLy8gIDEuIERlc3Ryb3kgc29ja2V0IGZpcnN0XG4gICAgICAvLyAgMi4gTXVzdCBlbWl0IHNvY2tldCAnYWdlbnRSZW1vdmUnIGV2ZW50IHRlbGwgYWdlbnQgcmVtb3ZlIHNvY2tldFxuICAgICAgLy8gICAgIGZyb20gZnJlZVNvY2tldHMgbGlzdCBpbW1lZGlhdGVseS5cbiAgICAgIC8vICAgICBPdGhlcmlzZSB5b3UgbWF5IGJlIGdldCAnc29ja2V0IGhhbmcgdXAnIGVycm9yIHdoZW4gcmV1c2VcbiAgICAgIC8vICAgICBmcmVlIHNvY2tldCBhbmQgdGltZW91dCBoYXBwZW4gaW4gdGhlIHNhbWUgdGltZS5cbiAgICAgIGlmIChyZXFUaW1lb3V0TGlzdGVuZXJDb3VudCA9PT0gMCkge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignU29ja2V0IHRpbWVvdXQnKTtcbiAgICAgICAgZXJyb3IuY29kZSA9ICdFUlJfU09DS0VUX1RJTUVPVVQnO1xuICAgICAgICBlcnJvci50aW1lb3V0ID0gdGltZW91dDtcbiAgICAgICAgLy8gbXVzdCBtYW51YWxseSBjYWxsIHNvY2tldC5lbmQoKSBvciBzb2NrZXQuZGVzdHJveSgpIHRvIGVuZCB0aGUgY29ubmVjdGlvbi5cbiAgICAgICAgLy8gaHR0cHM6Ly9ub2RlanMub3JnL2Rpc3QvbGF0ZXN0LXYxMC54L2RvY3MvYXBpL25ldC5odG1sI25ldF9zb2NrZXRfc2V0dGltZW91dF90aW1lb3V0X2NhbGxiYWNrXG4gICAgICAgIHNvY2tldC5kZXN0cm95KGVycm9yKTtcbiAgICAgICAgYWdlbnQucmVtb3ZlU29ja2V0KHNvY2tldCwgb3B0aW9ucyk7XG4gICAgICAgIGRlYnVnKCclcyBkZXN0cm95IHdpdGggdGltZW91dCBlcnJvcicsIHNvY2tldFtTT0NLRVRfTkFNRV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzb2NrZXQub24oJ3RpbWVvdXQnLCBvblRpbWVvdXQpO1xuXG4gIGZ1bmN0aW9uIG9uRXJyb3IoZXJyKSB7XG4gICAgY29uc3QgbGlzdGVuZXJDb3VudCA9IHNvY2tldC5saXN0ZW5lcnMoJ2Vycm9yJykubGVuZ3RoO1xuICAgIGRlYnVnKCclcyhyZXF1ZXN0czogJXMsIGZpbmlzaGVkOiAlcykgZXJyb3I6ICVzLCBsaXN0ZW5lckNvdW50OiAlcycsXG4gICAgICBzb2NrZXRbU09DS0VUX05BTUVdLCBzb2NrZXRbU09DS0VUX1JFUVVFU1RfQ09VTlRdLCBzb2NrZXRbU09DS0VUX1JFUVVFU1RfRklOSVNIRURfQ09VTlRdLFxuICAgICAgZXJyLCBsaXN0ZW5lckNvdW50KTtcbiAgICBhZ2VudC5lcnJvclNvY2tldENvdW50Kys7XG4gICAgaWYgKGxpc3RlbmVyQ291bnQgPT09IDEpIHtcbiAgICAgIC8vIGlmIHNvY2tldCBkb24ndCBjb250YWluIGVycm9yIGV2ZW50IGhhbmRsZXIsIGRvbid0IGNhdGNoIGl0LCBlbWl0IGl0IGFnYWluXG4gICAgICBkZWJ1ZygnJXMgZW1pdCB1bmNhdWdodCBlcnJvciBldmVudCcsIHNvY2tldFtTT0NLRVRfTkFNRV0pO1xuICAgICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IpO1xuICAgICAgc29ja2V0LmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICB9XG4gIH1cbiAgc29ja2V0Lm9uKCdlcnJvcicsIG9uRXJyb3IpO1xuXG4gIGZ1bmN0aW9uIG9uUmVtb3ZlKCkge1xuICAgIGRlYnVnKCclcyhyZXF1ZXN0czogJXMsIGZpbmlzaGVkOiAlcykgYWdlbnRSZW1vdmUnLFxuICAgICAgc29ja2V0W1NPQ0tFVF9OQU1FXSxcbiAgICAgIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9DT1VOVF0sIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9GSU5JU0hFRF9DT1VOVF0pO1xuICAgIC8vIFdlIG5lZWQgdGhpcyBmdW5jdGlvbiBmb3IgY2FzZXMgbGlrZSBIVFRQICd1cGdyYWRlJ1xuICAgIC8vIChkZWZpbmVkIGJ5IFdlYlNvY2tldHMpIHdoZXJlIHdlIG5lZWQgdG8gcmVtb3ZlIGEgc29ja2V0IGZyb20gdGhlXG4gICAgLy8gcG9vbCBiZWNhdXNlIGl0J2xsIGJlIGxvY2tlZCB1cCBpbmRlZmluaXRlbHlcbiAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25DbG9zZSk7XG4gICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IpO1xuICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignZnJlZScsIG9uRnJlZSk7XG4gICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCd0aW1lb3V0Jywgb25UaW1lb3V0KTtcbiAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2FnZW50UmVtb3ZlJywgb25SZW1vdmUpO1xuICB9XG4gIHNvY2tldC5vbignYWdlbnRSZW1vdmUnLCBvblJlbW92ZSk7XG59XG5cbnZhciBhZ2VudCA9IEFnZW50O1xuXG5mdW5jdGlvbiBpbnNwZWN0KG9iaikge1xuICBjb25zdCByZXMgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgcmVzW2tleV0gPSBvYmpba2V5XS5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuY29uc3QgT3JpZ2luYWxIdHRwc0FnZW50ID0gcmVxdWlyZSQkMF9fZGVmYXVsdCQyLmRlZmF1bHQuQWdlbnQ7XG5jb25zdCBIdHRwQWdlbnQgPSBhZ2VudDtcbmNvbnN0IHtcbiAgSU5JVF9TT0NLRVQsXG4gIENSRUFURV9IVFRQU19DT05ORUNUSU9OLFxufSA9IGNvbnN0YW50cztcblxubGV0IEh0dHBzQWdlbnQkMSA9IGNsYXNzIEh0dHBzQWdlbnQgZXh0ZW5kcyBIdHRwQWdlbnQge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG5cbiAgICB0aGlzLmRlZmF1bHRQb3J0ID0gNDQzO1xuICAgIHRoaXMucHJvdG9jb2wgPSAnaHR0cHM6JztcbiAgICB0aGlzLm1heENhY2hlZFNlc3Npb25zID0gdGhpcy5vcHRpb25zLm1heENhY2hlZFNlc3Npb25zO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKHRoaXMubWF4Q2FjaGVkU2Vzc2lvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5tYXhDYWNoZWRTZXNzaW9ucyA9IDEwMDtcbiAgICB9XG5cbiAgICB0aGlzLl9zZXNzaW9uQ2FjaGUgPSB7XG4gICAgICBtYXA6IHt9LFxuICAgICAgbGlzdDogW10sXG4gICAgfTtcbiAgfVxuXG4gIGNyZWF0ZUNvbm5lY3Rpb24ob3B0aW9ucywgb25jcmVhdGUpIHtcbiAgICBjb25zdCBzb2NrZXQgPSB0aGlzW0NSRUFURV9IVFRQU19DT05ORUNUSU9OXShvcHRpb25zLCBvbmNyZWF0ZSk7XG4gICAgdGhpc1tJTklUX1NPQ0tFVF0oc29ja2V0LCBvcHRpb25zKTtcbiAgICByZXR1cm4gc29ja2V0O1xuICB9XG59O1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi9tYXN0ZXIvbGliL2h0dHBzLmpzI0w4OVxuSHR0cHNBZ2VudCQxLnByb3RvdHlwZVtDUkVBVEVfSFRUUFNfQ09OTkVDVElPTl0gPSBPcmlnaW5hbEh0dHBzQWdlbnQucHJvdG90eXBlLmNyZWF0ZUNvbm5lY3Rpb247XG5cbltcbiAgJ2dldE5hbWUnLFxuICAnX2dldFNlc3Npb24nLFxuICAnX2NhY2hlU2Vzc2lvbicsXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9wdWxsLzQ5ODJcbiAgJ19ldmljdFNlc3Npb24nLFxuXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBpZiAodHlwZW9mIE9yaWdpbmFsSHR0cHNBZ2VudC5wcm90b3R5cGVbbWV0aG9kXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIEh0dHBzQWdlbnQkMS5wcm90b3R5cGVbbWV0aG9kXSA9IE9yaWdpbmFsSHR0cHNBZ2VudC5wcm90b3R5cGVbbWV0aG9kXTtcbiAgfVxufSk7XG5cbnZhciBodHRwc19hZ2VudCA9IEh0dHBzQWdlbnQkMTtcblxuYWdlbnRrZWVwYWxpdmUuZXhwb3J0cyA9IGFnZW50O1xudmFyIEh0dHBzQWdlbnQgPSBhZ2VudGtlZXBhbGl2ZS5leHBvcnRzLkh0dHBzQWdlbnQgPSBodHRwc19hZ2VudDtcbmFnZW50a2VlcGFsaXZlLmV4cG9ydHMuY29uc3RhbnRzID0gY29uc3RhbnRzO1xuXG52YXIgYWdlbnRrZWVwYWxpdmVFeHBvcnRzID0gYWdlbnRrZWVwYWxpdmUuZXhwb3J0cztcbnZhciBIdHRwS2VlcEFsaXZlQWdlbnQgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoYWdlbnRrZWVwYWxpdmVFeHBvcnRzKTtcblxudmFyIG9ialRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBvYmpLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ob2JqKSB7XG5cdFx0dmFyIGtleXMgPSBbXTtcblx0XHRmb3IgKHZhciBuYW1lIGluIG9iaikge1xuXHRcdFx0a2V5cy5wdXNoKG5hbWUpO1xuXHRcdH1cblx0XHRyZXR1cm4ga2V5cztcblx0fTtcblxuZnVuY3Rpb24gc3RyaW5naWZ5KHZhbCwgaXNBcnJheVByb3ApIHtcblx0dmFyIGksIG1heCwgc3RyLCBrZXlzLCBrZXksIHByb3BWYWwsIHRvU3RyO1xuXHRpZiAodmFsID09PSB0cnVlKSB7XG5cdFx0cmV0dXJuIFwidHJ1ZVwiO1xuXHR9XG5cdGlmICh2YWwgPT09IGZhbHNlKSB7XG5cdFx0cmV0dXJuIFwiZmFsc2VcIjtcblx0fVxuXHRzd2l0Y2ggKHR5cGVvZiB2YWwpIHtcblx0XHRjYXNlIFwib2JqZWN0XCI6XG5cdFx0XHRpZiAodmFsID09PSBudWxsKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fSBlbHNlIGlmICh2YWwudG9KU09OICYmIHR5cGVvZiB2YWwudG9KU09OID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0cmV0dXJuIHN0cmluZ2lmeSh2YWwudG9KU09OKCksIGlzQXJyYXlQcm9wKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRvU3RyID0gb2JqVG9TdHJpbmcuY2FsbCh2YWwpO1xuXHRcdFx0XHRpZiAodG9TdHIgPT09IFwiW29iamVjdCBBcnJheV1cIikge1xuXHRcdFx0XHRcdHN0ciA9ICdbJztcblx0XHRcdFx0XHRtYXggPSB2YWwubGVuZ3RoIC0gMTtcblx0XHRcdFx0XHRmb3IoaSA9IDA7IGkgPCBtYXg7IGkrKykge1xuXHRcdFx0XHRcdFx0c3RyICs9IHN0cmluZ2lmeSh2YWxbaV0sIHRydWUpICsgJywnO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAobWF4ID4gLTEpIHtcblx0XHRcdFx0XHRcdHN0ciArPSBzdHJpbmdpZnkodmFsW2ldLCB0cnVlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHN0ciArICddJztcblx0XHRcdFx0fSBlbHNlIGlmICh0b1N0ciA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIikge1xuXHRcdFx0XHRcdC8vIG9ubHkgb2JqZWN0IGlzIGxlZnRcblx0XHRcdFx0XHRrZXlzID0gb2JqS2V5cyh2YWwpLnNvcnQoKTtcblx0XHRcdFx0XHRtYXggPSBrZXlzLmxlbmd0aDtcblx0XHRcdFx0XHRzdHIgPSBcIlwiO1xuXHRcdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRcdHdoaWxlIChpIDwgbWF4KSB7XG5cdFx0XHRcdFx0XHRrZXkgPSBrZXlzW2ldO1xuXHRcdFx0XHRcdFx0cHJvcFZhbCA9IHN0cmluZ2lmeSh2YWxba2V5XSwgZmFsc2UpO1xuXHRcdFx0XHRcdFx0aWYgKHByb3BWYWwgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0XHRpZiAoc3RyKSB7XG5cdFx0XHRcdFx0XHRcdFx0c3RyICs9ICcsJztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRzdHIgKz0gSlNPTi5zdHJpbmdpZnkoa2V5KSArICc6JyArIHByb3BWYWw7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpKys7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiAneycgKyBzdHIgKyAnfSc7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRjYXNlIFwiZnVuY3Rpb25cIjpcblx0XHRjYXNlIFwidW5kZWZpbmVkXCI6XG5cdFx0XHRyZXR1cm4gaXNBcnJheVByb3AgPyBudWxsIDogdW5kZWZpbmVkO1xuXHRcdGNhc2UgXCJzdHJpbmdcIjpcblx0XHRcdHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWwpO1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHRyZXR1cm4gaXNGaW5pdGUodmFsKSA/IHZhbCA6IG51bGw7XG5cdH1cbn1cblxudmFyIGZhc3RTdGFibGVTdHJpbmdpZnkgPSBmdW5jdGlvbih2YWwpIHtcblx0dmFyIHJldHVyblZhbCA9IHN0cmluZ2lmeSh2YWwsIGZhbHNlKTtcblx0aWYgKHJldHVyblZhbCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuICcnKyByZXR1cm5WYWw7XG5cdH1cbn07XG5cbnZhciBmYXN0U3RhYmxlU3RyaW5naWZ5JDEgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoZmFzdFN0YWJsZVN0cmluZ2lmeSk7XG5cbmNvbnN0IE1JTklNVU1fU0xPVF9QRVJfRVBPQ0ggPSAzMjtcblxuLy8gUmV0dXJucyB0aGUgbnVtYmVyIG9mIHRyYWlsaW5nIHplcm9zIGluIHRoZSBiaW5hcnkgcmVwcmVzZW50YXRpb24gb2Ygc2VsZi5cbmZ1bmN0aW9uIHRyYWlsaW5nWmVyb3Mobikge1xuICBsZXQgdHJhaWxpbmdaZXJvcyA9IDA7XG4gIHdoaWxlIChuID4gMSkge1xuICAgIG4gLz0gMjtcbiAgICB0cmFpbGluZ1plcm9zKys7XG4gIH1cbiAgcmV0dXJuIHRyYWlsaW5nWmVyb3M7XG59XG5cbi8vIFJldHVybnMgdGhlIHNtYWxsZXN0IHBvd2VyIG9mIHR3byBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gblxuZnVuY3Rpb24gbmV4dFBvd2VyT2ZUd28obikge1xuICBpZiAobiA9PT0gMCkgcmV0dXJuIDE7XG4gIG4tLTtcbiAgbiB8PSBuID4+IDE7XG4gIG4gfD0gbiA+PiAyO1xuICBuIHw9IG4gPj4gNDtcbiAgbiB8PSBuID4+IDg7XG4gIG4gfD0gbiA+PiAxNjtcbiAgbiB8PSBuID4+IDMyO1xuICByZXR1cm4gbiArIDE7XG59XG5cbi8qKlxuICogRXBvY2ggc2NoZWR1bGVcbiAqIChzZWUgaHR0cHM6Ly9kb2NzLnNvbGFuYS5jb20vdGVybWlub2xvZ3kjZXBvY2gpXG4gKiBDYW4gYmUgcmV0cmlldmVkIHdpdGggdGhlIHtAbGluayBDb25uZWN0aW9uLmdldEVwb2NoU2NoZWR1bGV9IG1ldGhvZFxuICovXG5jbGFzcyBFcG9jaFNjaGVkdWxlIHtcbiAgY29uc3RydWN0b3Ioc2xvdHNQZXJFcG9jaCwgbGVhZGVyU2NoZWR1bGVTbG90T2Zmc2V0LCB3YXJtdXAsIGZpcnN0Tm9ybWFsRXBvY2gsIGZpcnN0Tm9ybWFsU2xvdCkge1xuICAgIC8qKiBUaGUgbWF4aW11bSBudW1iZXIgb2Ygc2xvdHMgaW4gZWFjaCBlcG9jaCAqL1xuICAgIHRoaXMuc2xvdHNQZXJFcG9jaCA9IHZvaWQgMDtcbiAgICAvKiogVGhlIG51bWJlciBvZiBzbG90cyBiZWZvcmUgYmVnaW5uaW5nIG9mIGFuIGVwb2NoIHRvIGNhbGN1bGF0ZSBhIGxlYWRlciBzY2hlZHVsZSBmb3IgdGhhdCBlcG9jaCAqL1xuICAgIHRoaXMubGVhZGVyU2NoZWR1bGVTbG90T2Zmc2V0ID0gdm9pZCAwO1xuICAgIC8qKiBJbmRpY2F0ZXMgd2hldGhlciBlcG9jaHMgc3RhcnQgc2hvcnQgYW5kIGdyb3cgKi9cbiAgICB0aGlzLndhcm11cCA9IHZvaWQgMDtcbiAgICAvKiogVGhlIGZpcnN0IGVwb2NoIHdpdGggYHNsb3RzUGVyRXBvY2hgIHNsb3RzICovXG4gICAgdGhpcy5maXJzdE5vcm1hbEVwb2NoID0gdm9pZCAwO1xuICAgIC8qKiBUaGUgZmlyc3Qgc2xvdCBvZiBgZmlyc3ROb3JtYWxFcG9jaGAgKi9cbiAgICB0aGlzLmZpcnN0Tm9ybWFsU2xvdCA9IHZvaWQgMDtcbiAgICB0aGlzLnNsb3RzUGVyRXBvY2ggPSBzbG90c1BlckVwb2NoO1xuICAgIHRoaXMubGVhZGVyU2NoZWR1bGVTbG90T2Zmc2V0ID0gbGVhZGVyU2NoZWR1bGVTbG90T2Zmc2V0O1xuICAgIHRoaXMud2FybXVwID0gd2FybXVwO1xuICAgIHRoaXMuZmlyc3ROb3JtYWxFcG9jaCA9IGZpcnN0Tm9ybWFsRXBvY2g7XG4gICAgdGhpcy5maXJzdE5vcm1hbFNsb3QgPSBmaXJzdE5vcm1hbFNsb3Q7XG4gIH1cbiAgZ2V0RXBvY2goc2xvdCkge1xuICAgIHJldHVybiB0aGlzLmdldEVwb2NoQW5kU2xvdEluZGV4KHNsb3QpWzBdO1xuICB9XG4gIGdldEVwb2NoQW5kU2xvdEluZGV4KHNsb3QpIHtcbiAgICBpZiAoc2xvdCA8IHRoaXMuZmlyc3ROb3JtYWxTbG90KSB7XG4gICAgICBjb25zdCBlcG9jaCA9IHRyYWlsaW5nWmVyb3MobmV4dFBvd2VyT2ZUd28oc2xvdCArIE1JTklNVU1fU0xPVF9QRVJfRVBPQ0ggKyAxKSkgLSB0cmFpbGluZ1plcm9zKE1JTklNVU1fU0xPVF9QRVJfRVBPQ0gpIC0gMTtcbiAgICAgIGNvbnN0IGVwb2NoTGVuID0gdGhpcy5nZXRTbG90c0luRXBvY2goZXBvY2gpO1xuICAgICAgY29uc3Qgc2xvdEluZGV4ID0gc2xvdCAtIChlcG9jaExlbiAtIE1JTklNVU1fU0xPVF9QRVJfRVBPQ0gpO1xuICAgICAgcmV0dXJuIFtlcG9jaCwgc2xvdEluZGV4XTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgbm9ybWFsU2xvdEluZGV4ID0gc2xvdCAtIHRoaXMuZmlyc3ROb3JtYWxTbG90O1xuICAgICAgY29uc3Qgbm9ybWFsRXBvY2hJbmRleCA9IE1hdGguZmxvb3Iobm9ybWFsU2xvdEluZGV4IC8gdGhpcy5zbG90c1BlckVwb2NoKTtcbiAgICAgIGNvbnN0IGVwb2NoID0gdGhpcy5maXJzdE5vcm1hbEVwb2NoICsgbm9ybWFsRXBvY2hJbmRleDtcbiAgICAgIGNvbnN0IHNsb3RJbmRleCA9IG5vcm1hbFNsb3RJbmRleCAlIHRoaXMuc2xvdHNQZXJFcG9jaDtcbiAgICAgIHJldHVybiBbZXBvY2gsIHNsb3RJbmRleF07XG4gICAgfVxuICB9XG4gIGdldEZpcnN0U2xvdEluRXBvY2goZXBvY2gpIHtcbiAgICBpZiAoZXBvY2ggPD0gdGhpcy5maXJzdE5vcm1hbEVwb2NoKSB7XG4gICAgICByZXR1cm4gKE1hdGgucG93KDIsIGVwb2NoKSAtIDEpICogTUlOSU1VTV9TTE9UX1BFUl9FUE9DSDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIChlcG9jaCAtIHRoaXMuZmlyc3ROb3JtYWxFcG9jaCkgKiB0aGlzLnNsb3RzUGVyRXBvY2ggKyB0aGlzLmZpcnN0Tm9ybWFsU2xvdDtcbiAgICB9XG4gIH1cbiAgZ2V0TGFzdFNsb3RJbkVwb2NoKGVwb2NoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Rmlyc3RTbG90SW5FcG9jaChlcG9jaCkgKyB0aGlzLmdldFNsb3RzSW5FcG9jaChlcG9jaCkgLSAxO1xuICB9XG4gIGdldFNsb3RzSW5FcG9jaChlcG9jaCkge1xuICAgIGlmIChlcG9jaCA8IHRoaXMuZmlyc3ROb3JtYWxFcG9jaCkge1xuICAgICAgcmV0dXJuIE1hdGgucG93KDIsIGVwb2NoICsgdHJhaWxpbmdaZXJvcyhNSU5JTVVNX1NMT1RfUEVSX0VQT0NIKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnNsb3RzUGVyRXBvY2g7XG4gICAgfVxuICB9XG59XG5cbmNsYXNzIFNlbmRUcmFuc2FjdGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBsb2dzKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5sb2dzID0gdm9pZCAwO1xuICAgIHRoaXMubG9ncyA9IGxvZ3M7XG4gIH1cbn1cblxuLy8gS2VlcCBpbiBzeW5jIHdpdGggY2xpZW50L3NyYy9ycGNfY3VzdG9tX2Vycm9ycy5yc1xuLy8gVHlwZXNjcmlwdCBgZW51bXNgIHRod2FydCB0cmVlLXNoYWtpbmcuIFNlZSBodHRwczovL2JhcmdzdGVuLm9yZy9qc3RzL2VudW1zL1xuY29uc3QgU29sYW5hSlNPTlJQQ0Vycm9yQ29kZSA9IHtcbiAgSlNPTl9SUENfU0VSVkVSX0VSUk9SX0JMT0NLX0NMRUFORURfVVA6IC0zMjAwMSxcbiAgSlNPTl9SUENfU0VSVkVSX0VSUk9SX1NFTkRfVFJBTlNBQ1RJT05fUFJFRkxJR0hUX0ZBSUxVUkU6IC0zMjAwMixcbiAgSlNPTl9SUENfU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX1NJR05BVFVSRV9WRVJJRklDQVRJT05fRkFJTFVSRTogLTMyMDAzLFxuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfQkxPQ0tfTk9UX0FWQUlMQUJMRTogLTMyMDA0LFxuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfTk9ERV9VTkhFQUxUSFk6IC0zMjAwNSxcbiAgSlNPTl9SUENfU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX1BSRUNPTVBJTEVfVkVSSUZJQ0FUSU9OX0ZBSUxVUkU6IC0zMjAwNixcbiAgSlNPTl9SUENfU0VSVkVSX0VSUk9SX1NMT1RfU0tJUFBFRDogLTMyMDA3LFxuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfTk9fU05BUFNIT1Q6IC0zMjAwOCxcbiAgSlNPTl9SUENfU0VSVkVSX0VSUk9SX0xPTkdfVEVSTV9TVE9SQUdFX1NMT1RfU0tJUFBFRDogLTMyMDA5LFxuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfS0VZX0VYQ0xVREVEX0ZST01fU0VDT05EQVJZX0lOREVYOiAtMzIwMTAsXG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9UUkFOU0FDVElPTl9ISVNUT1JZX05PVF9BVkFJTEFCTEU6IC0zMjAxMSxcbiAgSlNPTl9SUENfU0NBTl9FUlJPUjogLTMyMDEyLFxuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fU0lHTkFUVVJFX0xFTl9NSVNNQVRDSDogLTMyMDEzLFxuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfQkxPQ0tfU1RBVFVTX05PVF9BVkFJTEFCTEVfWUVUOiAtMzIwMTQsXG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9VTlNVUFBPUlRFRF9UUkFOU0FDVElPTl9WRVJTSU9OOiAtMzIwMTUsXG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9NSU5fQ09OVEVYVF9TTE9UX05PVF9SRUFDSEVEOiAtMzIwMTZcbn07XG5jbGFzcyBTb2xhbmFKU09OUlBDRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBjb2RlLFxuICAgIG1lc3NhZ2UsXG4gICAgZGF0YVxuICB9LCBjdXN0b21NZXNzYWdlKSB7XG4gICAgc3VwZXIoY3VzdG9tTWVzc2FnZSAhPSBudWxsID8gYCR7Y3VzdG9tTWVzc2FnZX06ICR7bWVzc2FnZX1gIDogbWVzc2FnZSk7XG4gICAgdGhpcy5jb2RlID0gdm9pZCAwO1xuICAgIHRoaXMuZGF0YSA9IHZvaWQgMDtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy5uYW1lID0gJ1NvbGFuYUpTT05SUENFcnJvcic7XG4gIH1cbn1cblxudmFyIGZldGNoSW1wbCA9IHR5cGVvZiBnbG9iYWxUaGlzLmZldGNoID09PSAnZnVuY3Rpb24nID9cbi8vIFRoZSBGZXRjaCBBUEkgaXMgc3VwcG9ydGVkIGV4cGVyaW1lbnRhbGx5IGluIE5vZGUgMTcuNSsgYW5kIG5hdGl2ZWx5IGluIE5vZGUgMTgrLlxuZ2xvYmFsVGhpcy5mZXRjaCA6XG4vLyBPdGhlcndpc2UgdXNlIHRoZSBwb2x5ZmlsbC5cbmFzeW5jIGZ1bmN0aW9uIChpbnB1dCwgaW5pdCkge1xuICBjb25zdCBwcm9jZXNzZWRJbnB1dCA9IHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycgJiYgaW5wdXQuc2xpY2UoMCwgMikgPT09ICcvLycgPyAnaHR0cHM6JyArIGlucHV0IDogaW5wdXQ7XG4gIHJldHVybiBhd2FpdCBub2RlRmV0Y2hfX25hbWVzcGFjZS5kZWZhdWx0KHByb2Nlc3NlZElucHV0LCBpbml0KTtcbn07XG5cbmNsYXNzIFJwY1dlYlNvY2tldENsaWVudCBleHRlbmRzIFJwY1dlYlNvY2tldENvbW1vbkNsaWVudF9fZGVmYXVsdC5kZWZhdWx0IHtcbiAgY29uc3RydWN0b3IoYWRkcmVzcywgb3B0aW9ucywgZ2VuZXJhdGVfcmVxdWVzdF9pZCkge1xuICAgIGNvbnN0IHdlYlNvY2tldEZhY3RvcnkgPSB1cmwgPT4ge1xuICAgICAgY29uc3QgcnBjID0gV2Vic29ja2V0RmFjdG9yeV9fZGVmYXVsdC5kZWZhdWx0KHVybCwge1xuICAgICAgICBhdXRvY29ubmVjdDogdHJ1ZSxcbiAgICAgICAgbWF4X3JlY29ubmVjdHM6IDUsXG4gICAgICAgIHJlY29ubmVjdDogdHJ1ZSxcbiAgICAgICAgcmVjb25uZWN0X2ludGVydmFsOiAxMDAwLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9KTtcbiAgICAgIGlmICgnc29ja2V0JyBpbiBycGMpIHtcbiAgICAgICAgdGhpcy51bmRlcmx5aW5nU29ja2V0ID0gcnBjLnNvY2tldDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudW5kZXJseWluZ1NvY2tldCA9IHJwYztcbiAgICAgIH1cbiAgICAgIHJldHVybiBycGM7XG4gICAgfTtcbiAgICBzdXBlcih3ZWJTb2NrZXRGYWN0b3J5LCBhZGRyZXNzLCBvcHRpb25zLCBnZW5lcmF0ZV9yZXF1ZXN0X2lkKTtcbiAgICB0aGlzLnVuZGVybHlpbmdTb2NrZXQgPSB2b2lkIDA7XG4gIH1cbiAgY2FsbCguLi5hcmdzKSB7XG4gICAgY29uc3QgcmVhZHlTdGF0ZSA9IHRoaXMudW5kZXJseWluZ1NvY2tldD8ucmVhZHlTdGF0ZTtcbiAgICBpZiAocmVhZHlTdGF0ZSA9PT0gMSAvKiBXZWJTb2NrZXQuT1BFTiAqLykge1xuICAgICAgcmV0dXJuIHN1cGVyLmNhbGwoLi4uYXJncyk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ1RyaWVkIHRvIGNhbGwgYSBKU09OLVJQQyBtZXRob2QgYCcgKyBhcmdzWzBdICsgJ2AgYnV0IHRoZSBzb2NrZXQgd2FzIG5vdCBgQ09OTkVDVElOR2Agb3IgYE9QRU5gIChgcmVhZHlTdGF0ZWAgd2FzICcgKyByZWFkeVN0YXRlICsgJyknKSk7XG4gIH1cbiAgbm90aWZ5KC4uLmFyZ3MpIHtcbiAgICBjb25zdCByZWFkeVN0YXRlID0gdGhpcy51bmRlcmx5aW5nU29ja2V0Py5yZWFkeVN0YXRlO1xuICAgIGlmIChyZWFkeVN0YXRlID09PSAxIC8qIFdlYlNvY2tldC5PUEVOICovKSB7XG4gICAgICByZXR1cm4gc3VwZXIubm90aWZ5KC4uLmFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdUcmllZCB0byBzZW5kIGEgSlNPTi1SUEMgbm90aWZpY2F0aW9uIGAnICsgYXJnc1swXSArICdgIGJ1dCB0aGUgc29ja2V0IHdhcyBub3QgYENPTk5FQ1RJTkdgIG9yIGBPUEVOYCAoYHJlYWR5U3RhdGVgIHdhcyAnICsgcmVhZHlTdGF0ZSArICcpJykpO1xuICB9XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cblxuLyoqXG4gKiBEZWNvZGUgYWNjb3VudCBkYXRhIGJ1ZmZlciB1c2luZyBhbiBBY2NvdW50VHlwZVxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGRlY29kZURhdGEodHlwZSwgZGF0YSkge1xuICBsZXQgZGVjb2RlZDtcbiAgdHJ5IHtcbiAgICBkZWNvZGVkID0gdHlwZS5sYXlvdXQuZGVjb2RlKGRhdGEpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5zdHJ1Y3Rpb247ICcgKyBlcnIpO1xuICB9XG4gIGlmIChkZWNvZGVkLnR5cGVJbmRleCAhPT0gdHlwZS5pbmRleCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBhY2NvdW50IGRhdGE7IGFjY291bnQgdHlwZSBtaXNtYXRjaCAke2RlY29kZWQudHlwZUluZGV4fSAhPSAke3R5cGUuaW5kZXh9YCk7XG4gIH1cbiAgcmV0dXJuIGRlY29kZWQ7XG59XG5cbi8vLyBUaGUgc2VyaWFsaXplZCBzaXplIG9mIGxvb2t1cCB0YWJsZSBtZXRhZGF0YVxuY29uc3QgTE9PS1VQX1RBQkxFX01FVEFfU0laRSA9IDU2O1xuY2xhc3MgQWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudCB7XG4gIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICB0aGlzLmtleSA9IHZvaWQgMDtcbiAgICB0aGlzLnN0YXRlID0gdm9pZCAwO1xuICAgIHRoaXMua2V5ID0gYXJncy5rZXk7XG4gICAgdGhpcy5zdGF0ZSA9IGFyZ3Muc3RhdGU7XG4gIH1cbiAgaXNBY3RpdmUoKSB7XG4gICAgY29uc3QgVTY0X01BWCA9IEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmJyk7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuZGVhY3RpdmF0aW9uU2xvdCA9PT0gVTY0X01BWDtcbiAgfVxuICBzdGF0aWMgZGVzZXJpYWxpemUoYWNjb3VudERhdGEpIHtcbiAgICBjb25zdCBtZXRhID0gZGVjb2RlRGF0YShMb29rdXBUYWJsZU1ldGFMYXlvdXQsIGFjY291bnREYXRhKTtcbiAgICBjb25zdCBzZXJpYWxpemVkQWRkcmVzc2VzTGVuID0gYWNjb3VudERhdGEubGVuZ3RoIC0gTE9PS1VQX1RBQkxFX01FVEFfU0laRTtcbiAgICBhc3NlcnQoc2VyaWFsaXplZEFkZHJlc3Nlc0xlbiA+PSAwLCAnbG9va3VwIHRhYmxlIGlzIGludmFsaWQnKTtcbiAgICBhc3NlcnQoc2VyaWFsaXplZEFkZHJlc3Nlc0xlbiAlIDMyID09PSAwLCAnbG9va3VwIHRhYmxlIGlzIGludmFsaWQnKTtcbiAgICBjb25zdCBudW1TZXJpYWxpemVkQWRkcmVzc2VzID0gc2VyaWFsaXplZEFkZHJlc3Nlc0xlbiAvIDMyO1xuICAgIGNvbnN0IHtcbiAgICAgIGFkZHJlc3Nlc1xuICAgIH0gPSBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5zdHJ1Y3QoW0J1ZmZlckxheW91dF9fbmFtZXNwYWNlLnNlcShwdWJsaWNLZXkoKSwgbnVtU2VyaWFsaXplZEFkZHJlc3NlcywgJ2FkZHJlc3NlcycpXSkuZGVjb2RlKGFjY291bnREYXRhLnNsaWNlKExPT0tVUF9UQUJMRV9NRVRBX1NJWkUpKTtcbiAgICByZXR1cm4ge1xuICAgICAgZGVhY3RpdmF0aW9uU2xvdDogbWV0YS5kZWFjdGl2YXRpb25TbG90LFxuICAgICAgbGFzdEV4dGVuZGVkU2xvdDogbWV0YS5sYXN0RXh0ZW5kZWRTbG90LFxuICAgICAgbGFzdEV4dGVuZGVkU2xvdFN0YXJ0SW5kZXg6IG1ldGEubGFzdEV4dGVuZGVkU3RhcnRJbmRleCxcbiAgICAgIGF1dGhvcml0eTogbWV0YS5hdXRob3JpdHkubGVuZ3RoICE9PSAwID8gbmV3IFB1YmxpY0tleShtZXRhLmF1dGhvcml0eVswXSkgOiB1bmRlZmluZWQsXG4gICAgICBhZGRyZXNzZXM6IGFkZHJlc3Nlcy5tYXAoYWRkcmVzcyA9PiBuZXcgUHVibGljS2V5KGFkZHJlc3MpKVxuICAgIH07XG4gIH1cbn1cbmNvbnN0IExvb2t1cFRhYmxlTWV0YUxheW91dCA9IHtcbiAgaW5kZXg6IDEsXG4gIGxheW91dDogQnVmZmVyTGF5b3V0X19uYW1lc3BhY2Uuc3RydWN0KFtCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51MzIoJ3R5cGVJbmRleCcpLCB1NjQoJ2RlYWN0aXZhdGlvblNsb3QnKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UubnU2NCgnbGFzdEV4dGVuZGVkU2xvdCcpLCBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51OCgnbGFzdEV4dGVuZGVkU3RhcnRJbmRleCcpLCBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51OCgpLFxuICAvLyBvcHRpb25cbiAgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2Uuc2VxKHB1YmxpY0tleSgpLCBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5vZmZzZXQoQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTgoKSwgLTEpLCAnYXV0aG9yaXR5JyldKVxufTtcblxuY29uc3QgVVJMX1JFID0gL15bXjpdKzpcXC9cXC8oW146W10rfFxcW1teXFxdXStcXF0pKDpcXGQrKT8oLiopL2k7XG5mdW5jdGlvbiBtYWtlV2Vic29ja2V0VXJsKGVuZHBvaW50KSB7XG4gIGNvbnN0IG1hdGNoZXMgPSBlbmRwb2ludC5tYXRjaChVUkxfUkUpO1xuICBpZiAobWF0Y2hlcyA9PSBudWxsKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKGBGYWlsZWQgdG8gdmFsaWRhdGUgZW5kcG9pbnQgVVJMIFxcYCR7ZW5kcG9pbnR9XFxgYCk7XG4gIH1cbiAgY29uc3QgW18sXG4gIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gIGhvc3Rpc2gsIHBvcnRXaXRoQ29sb24sIHJlc3RdID0gbWF0Y2hlcztcbiAgY29uc3QgcHJvdG9jb2wgPSBlbmRwb2ludC5zdGFydHNXaXRoKCdodHRwczonKSA/ICd3c3M6JyA6ICd3czonO1xuICBjb25zdCBzdGFydFBvcnQgPSBwb3J0V2l0aENvbG9uID09IG51bGwgPyBudWxsIDogcGFyc2VJbnQocG9ydFdpdGhDb2xvbi5zbGljZSgxKSwgMTApO1xuICBjb25zdCB3ZWJzb2NrZXRQb3J0ID1cbiAgLy8gT25seSBzaGlmdCB0aGUgcG9ydCBieSArMSBhcyBhIGNvbnZlbnRpb24gZm9yIHdzKHMpIG9ubHkgaWYgZ2l2ZW4gZW5kcG9pbnRcbiAgLy8gaXMgZXhwbGljaXRseSBzcGVjaWZ5aW5nIHRoZSBlbmRwb2ludCBwb3J0IChIVFRQLWJhc2VkIFJQQyksIGFzc3VtaW5nXG4gIC8vIHdlJ3JlIGRpcmVjdGx5IHRyeWluZyB0byBjb25uZWN0IHRvIHNvbGFuYS12YWxpZGF0b3IncyB3cyBsaXN0ZW5pbmcgcG9ydC5cbiAgLy8gV2hlbiB0aGUgZW5kcG9pbnQgb21pdHMgdGhlIHBvcnQsIHdlJ3JlIGNvbm5lY3RpbmcgdG8gdGhlIHByb3RvY29sXG4gIC8vIGRlZmF1bHQgcG9ydHM6IGh0dHAoODApIG9yIGh0dHBzKDQ0MykgYW5kIGl0J3MgYXNzdW1lZCB3ZSdyZSBiZWhpbmQgYSByZXZlcnNlXG4gIC8vIHByb3h5IHdoaWNoIG1hbmFnZXMgV2ViU29ja2V0IHVwZ3JhZGUgYW5kIGJhY2tlbmQgcG9ydCByZWRpcmVjdGlvbi5cbiAgc3RhcnRQb3J0ID09IG51bGwgPyAnJyA6IGA6JHtzdGFydFBvcnQgKyAxfWA7XG4gIHJldHVybiBgJHtwcm90b2NvbH0vLyR7aG9zdGlzaH0ke3dlYnNvY2tldFBvcnR9JHtyZXN0fWA7XG59XG5cbmNvbnN0IFB1YmxpY0tleUZyb21TdHJpbmcgPSBzdXBlcnN0cnVjdC5jb2VyY2Uoc3VwZXJzdHJ1Y3QuaW5zdGFuY2UoUHVibGljS2V5KSwgc3VwZXJzdHJ1Y3Quc3RyaW5nKCksIHZhbHVlID0+IG5ldyBQdWJsaWNLZXkodmFsdWUpKTtcbmNvbnN0IFJhd0FjY291bnREYXRhUmVzdWx0ID0gc3VwZXJzdHJ1Y3QudHVwbGUoW3N1cGVyc3RydWN0LnN0cmluZygpLCBzdXBlcnN0cnVjdC5saXRlcmFsKCdiYXNlNjQnKV0pO1xuY29uc3QgQnVmZmVyRnJvbVJhd0FjY291bnREYXRhID0gc3VwZXJzdHJ1Y3QuY29lcmNlKHN1cGVyc3RydWN0Lmluc3RhbmNlKGJ1ZmZlci5CdWZmZXIpLCBSYXdBY2NvdW50RGF0YVJlc3VsdCwgdmFsdWUgPT4gYnVmZmVyLkJ1ZmZlci5mcm9tKHZhbHVlWzBdLCAnYmFzZTY0JykpO1xuXG4vKipcbiAqIEF0dGVtcHQgdG8gdXNlIGEgcmVjZW50IGJsb2NraGFzaCBmb3IgdXAgdG8gMzAgc2Vjb25kc1xuICogQGludGVybmFsXG4gKi9cbmNvbnN0IEJMT0NLSEFTSF9DQUNIRV9USU1FT1VUX01TID0gMzAgKiAxMDAwO1xuXG4vKipcbiAqIEhBQ0suXG4gKiBDb3BpZWQgZnJvbSBycGMtd2Vic29ja2V0cy9kaXN0L2xpYi9jbGllbnQuXG4gKiBPdGhlcndpc2UsIGB5YXJuIGJ1aWxkYCBmYWlscyB3aXRoOlxuICogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vc3RldmVsdXNjaGVyL2MwNTdlY2E4MWQ0NzllZjcwNWNkYjUzMTYyZjk5NzFkXG4gKi9cblxuLyoqIEBpbnRlcm5hbCAqL1xuLyoqIEBpbnRlcm5hbCAqL1xuLyoqIEBpbnRlcm5hbCAqL1xuLyoqIEBpbnRlcm5hbCAqL1xuXG4vKiogQGludGVybmFsICovXG4vKipcbiAqIEBpbnRlcm5hbFxuICogRXZlcnkgc3Vic2NyaXB0aW9uIGNvbnRhaW5zIHRoZSBhcmdzIHVzZWQgdG8gb3BlbiB0aGUgc3Vic2NyaXB0aW9uIHdpdGhcbiAqIHRoZSBzZXJ2ZXIsIGFuZCBhIGxpc3Qgb2YgY2FsbGVycyBpbnRlcmVzdGVkIGluIG5vdGlmaWNhdGlvbnMuXG4gKi9cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEEgc3Vic2NyaXB0aW9uIG1heSBiZSBpbiB2YXJpb3VzIHN0YXRlcyBvZiBjb25uZWN0ZWRuZXNzLiBPbmx5IHdoZW4gaXQgaXNcbiAqIGZ1bGx5IGNvbm5lY3RlZCB3aWxsIGl0IGhhdmUgYSBzZXJ2ZXIgc3Vic2NyaXB0aW9uIGlkIGFzc29jaWF0ZWQgd2l0aCBpdC5cbiAqIFRoaXMgaWQgY2FuIGJlIHJldHVybmVkIHRvIHRoZSBzZXJ2ZXIgdG8gdW5zdWJzY3JpYmUgdGhlIGNsaWVudCBlbnRpcmVseS5cbiAqL1xuXG4vKipcbiAqIEEgdHlwZSB0aGF0IGVuY2Fwc3VsYXRlcyBhIHN1YnNjcmlwdGlvbidzIFJQQyBtZXRob2RcbiAqIG5hbWVzIGFuZCBub3RpZmljYXRpb24gKGNhbGxiYWNrKSBzaWduYXR1cmUuXG4gKi9cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIFV0aWxpdHkgdHlwZSB0aGF0IGtlZXBzIHRhZ2dlZCB1bmlvbnMgaW50YWN0IHdoaWxlIG9taXR0aW5nIHByb3BlcnRpZXMuXG4gKi9cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIFRoaXMgdHlwZSByZXByZXNlbnRzIGEgc2luZ2xlIHN1YnNjcmliYWJsZSAndG9waWMuJyBJdCdzIG1hZGUgdXAgb2Y6XG4gKlxuICogLSBUaGUgYXJncyB1c2VkIHRvIG9wZW4gdGhlIHN1YnNjcmlwdGlvbiB3aXRoIHRoZSBzZXJ2ZXIsXG4gKiAtIFRoZSBzdGF0ZSBvZiB0aGUgc3Vic2NyaXB0aW9uLCBpbiB0ZXJtcyBvZiBpdHMgY29ubmVjdGVkbmVzcywgYW5kXG4gKiAtIFRoZSBzZXQgb2YgY2FsbGJhY2tzIHRvIGNhbGwgd2hlbiB0aGUgc2VydmVyIHB1Ymxpc2hlcyBub3RpZmljYXRpb25zXG4gKlxuICogVGhpcyByZWNvcmQgZ2V0cyBpbmRleGVkIGJ5IGBTdWJzY3JpcHRpb25Db25maWdIYXNoYCBhbmQgaXMgdXNlZCB0b1xuICogc2V0IHVwIHN1YnNjcmlwdGlvbnMsIGZhbiBvdXQgbm90aWZpY2F0aW9ucywgYW5kIHRyYWNrIHN1YnNjcmlwdGlvbiBzdGF0ZS5cbiAqL1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5cbi8qKlxuICogRXh0cmEgY29udGV4dHVhbCBpbmZvcm1hdGlvbiBmb3IgUlBDIHJlc3BvbnNlc1xuICovXG5cbi8qKlxuICogT3B0aW9ucyBmb3Igc2VuZGluZyB0cmFuc2FjdGlvbnNcbiAqL1xuXG4vKipcbiAqIE9wdGlvbnMgZm9yIGNvbmZpcm1pbmcgdHJhbnNhY3Rpb25zXG4gKi9cblxuLyoqXG4gKiBPcHRpb25zIGZvciBnZXRDb25maXJtZWRTaWduYXR1cmVzRm9yQWRkcmVzczJcbiAqL1xuXG4vKipcbiAqIE9wdGlvbnMgZm9yIGdldFNpZ25hdHVyZXNGb3JBZGRyZXNzXG4gKi9cblxuLyoqXG4gKiBSUEMgUmVzcG9uc2Ugd2l0aCBleHRyYSBjb250ZXh0dWFsIGluZm9ybWF0aW9uXG4gKi9cblxuLyoqXG4gKiBBIHN0cmF0ZWd5IGZvciBjb25maXJtaW5nIHRyYW5zYWN0aW9ucyB0aGF0IHVzZXMgdGhlIGxhc3QgdmFsaWRcbiAqIGJsb2NrIGhlaWdodCBmb3IgYSBnaXZlbiBibG9ja2hhc2ggdG8gY2hlY2sgZm9yIHRyYW5zYWN0aW9uIGV4cGlyYXRpb24uXG4gKi9cblxuLyoqXG4gKiBBIHN0cmF0ZWd5IGZvciBjb25maXJtaW5nIGR1cmFibGUgbm9uY2UgdHJhbnNhY3Rpb25zLlxuICovXG5cbi8qKlxuICogUHJvcGVydGllcyBzaGFyZWQgYnkgYWxsIHRyYW5zYWN0aW9uIGNvbmZpcm1hdGlvbiBzdHJhdGVnaWVzXG4gKi9cblxuLyoqXG4gKiBUaGlzIHR5cGUgcmVwcmVzZW50cyBhbGwgdHJhbnNhY3Rpb24gY29uZmlybWF0aW9uIHN0cmF0ZWdpZXNcbiAqL1xuXG4vKiBAaW50ZXJuYWwgKi9cbmZ1bmN0aW9uIGFzc2VydEVuZHBvaW50VXJsKHB1dGF0aXZlVXJsKSB7XG4gIGlmICgvXmh0dHBzPzovLnRlc3QocHV0YXRpdmVVcmwpID09PSBmYWxzZSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0VuZHBvaW50IFVSTCBtdXN0IHN0YXJ0IHdpdGggYGh0dHA6YCBvciBgaHR0cHM6YC4nKTtcbiAgfVxuICByZXR1cm4gcHV0YXRpdmVVcmw7XG59XG5cbi8qKiBAaW50ZXJuYWwgKi9cbmZ1bmN0aW9uIGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpIHtcbiAgbGV0IGNvbW1pdG1lbnQ7XG4gIGxldCBjb25maWc7XG4gIGlmICh0eXBlb2YgY29tbWl0bWVudE9yQ29uZmlnID09PSAnc3RyaW5nJykge1xuICAgIGNvbW1pdG1lbnQgPSBjb21taXRtZW50T3JDb25maWc7XG4gIH0gZWxzZSBpZiAoY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudDogc3BlY2lmaWVkQ29tbWl0bWVudCxcbiAgICAgIC4uLnNwZWNpZmllZENvbmZpZ1xuICAgIH0gPSBjb21taXRtZW50T3JDb25maWc7XG4gICAgY29tbWl0bWVudCA9IHNwZWNpZmllZENvbW1pdG1lbnQ7XG4gICAgY29uZmlnID0gc3BlY2lmaWVkQ29uZmlnO1xuICB9XG4gIHJldHVybiB7XG4gICAgY29tbWl0bWVudCxcbiAgICBjb25maWdcbiAgfTtcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gY3JlYXRlUnBjUmVzdWx0KHJlc3VsdCkge1xuICByZXR1cm4gc3VwZXJzdHJ1Y3QudW5pb24oW3N1cGVyc3RydWN0LnR5cGUoe1xuICAgIGpzb25ycGM6IHN1cGVyc3RydWN0LmxpdGVyYWwoJzIuMCcpLFxuICAgIGlkOiBzdXBlcnN0cnVjdC5zdHJpbmcoKSxcbiAgICByZXN1bHRcbiAgfSksIHN1cGVyc3RydWN0LnR5cGUoe1xuICAgIGpzb25ycGM6IHN1cGVyc3RydWN0LmxpdGVyYWwoJzIuMCcpLFxuICAgIGlkOiBzdXBlcnN0cnVjdC5zdHJpbmcoKSxcbiAgICBlcnJvcjogc3VwZXJzdHJ1Y3QudHlwZSh7XG4gICAgICBjb2RlOiBzdXBlcnN0cnVjdC51bmtub3duKCksXG4gICAgICBtZXNzYWdlOiBzdXBlcnN0cnVjdC5zdHJpbmcoKSxcbiAgICAgIGRhdGE6IHN1cGVyc3RydWN0Lm9wdGlvbmFsKHN1cGVyc3RydWN0LmFueSgpKVxuICAgIH0pXG4gIH0pXSk7XG59XG5jb25zdCBVbmtub3duUnBjUmVzdWx0ID0gY3JlYXRlUnBjUmVzdWx0KHN1cGVyc3RydWN0LnVua25vd24oKSk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGpzb25ScGNSZXN1bHQoc2NoZW1hKSB7XG4gIHJldHVybiBzdXBlcnN0cnVjdC5jb2VyY2UoY3JlYXRlUnBjUmVzdWx0KHNjaGVtYSksIFVua25vd25ScGNSZXN1bHQsIHZhbHVlID0+IHtcbiAgICBpZiAoJ2Vycm9yJyBpbiB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi52YWx1ZSxcbiAgICAgICAgcmVzdWx0OiBzdXBlcnN0cnVjdC5jcmVhdGUodmFsdWUucmVzdWx0LCBzY2hlbWEpXG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KHZhbHVlKSB7XG4gIHJldHVybiBqc29uUnBjUmVzdWx0KHN1cGVyc3RydWN0LnR5cGUoe1xuICAgIGNvbnRleHQ6IHN1cGVyc3RydWN0LnR5cGUoe1xuICAgICAgc2xvdDogc3VwZXJzdHJ1Y3QubnVtYmVyKClcbiAgICB9KSxcbiAgICB2YWx1ZVxuICB9KSk7XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIG5vdGlmaWNhdGlvblJlc3VsdEFuZENvbnRleHQodmFsdWUpIHtcbiAgcmV0dXJuIHN1cGVyc3RydWN0LnR5cGUoe1xuICAgIGNvbnRleHQ6IHN1cGVyc3RydWN0LnR5cGUoe1xuICAgICAgc2xvdDogc3VwZXJzdHJ1Y3QubnVtYmVyKClcbiAgICB9KSxcbiAgICB2YWx1ZVxuICB9KTtcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdmVyc2lvbmVkTWVzc2FnZUZyb21SZXNwb25zZSh2ZXJzaW9uLCByZXNwb25zZSkge1xuICBpZiAodmVyc2lvbiA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgTWVzc2FnZVYwKHtcbiAgICAgIGhlYWRlcjogcmVzcG9uc2UuaGVhZGVyLFxuICAgICAgc3RhdGljQWNjb3VudEtleXM6IHJlc3BvbnNlLmFjY291bnRLZXlzLm1hcChhY2NvdW50S2V5ID0+IG5ldyBQdWJsaWNLZXkoYWNjb3VudEtleSkpLFxuICAgICAgcmVjZW50QmxvY2toYXNoOiByZXNwb25zZS5yZWNlbnRCbG9ja2hhc2gsXG4gICAgICBjb21waWxlZEluc3RydWN0aW9uczogcmVzcG9uc2UuaW5zdHJ1Y3Rpb25zLm1hcChpeCA9PiAoe1xuICAgICAgICBwcm9ncmFtSWRJbmRleDogaXgucHJvZ3JhbUlkSW5kZXgsXG4gICAgICAgIGFjY291bnRLZXlJbmRleGVzOiBpeC5hY2NvdW50cyxcbiAgICAgICAgZGF0YTogYnM1OF9fZGVmYXVsdC5kZWZhdWx0LmRlY29kZShpeC5kYXRhKVxuICAgICAgfSkpLFxuICAgICAgYWRkcmVzc1RhYmxlTG9va3VwczogcmVzcG9uc2UuYWRkcmVzc1RhYmxlTG9va3Vwc1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgTWVzc2FnZShyZXNwb25zZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgbGV2ZWwgb2YgY29tbWl0bWVudCBkZXNpcmVkIHdoZW4gcXVlcnlpbmcgc3RhdGVcbiAqIDxwcmU+XG4gKiAgICdwcm9jZXNzZWQnOiBRdWVyeSB0aGUgbW9zdCByZWNlbnQgYmxvY2sgd2hpY2ggaGFzIHJlYWNoZWQgMSBjb25maXJtYXRpb24gYnkgdGhlIGNvbm5lY3RlZCBub2RlXG4gKiAgICdjb25maXJtZWQnOiBRdWVyeSB0aGUgbW9zdCByZWNlbnQgYmxvY2sgd2hpY2ggaGFzIHJlYWNoZWQgMSBjb25maXJtYXRpb24gYnkgdGhlIGNsdXN0ZXJcbiAqICAgJ2ZpbmFsaXplZCc6IFF1ZXJ5IHRoZSBtb3N0IHJlY2VudCBibG9jayB3aGljaCBoYXMgYmVlbiBmaW5hbGl6ZWQgYnkgdGhlIGNsdXN0ZXJcbiAqIDwvcHJlPlxuICovXG5cbi8vIERlcHJlY2F0ZWQgYXMgb2YgdjEuNS41XG5cbi8qKlxuICogQSBzdWJzZXQgb2YgQ29tbWl0bWVudCBsZXZlbHMsIHdoaWNoIGFyZSBhdCBsZWFzdCBvcHRpbWlzdGljYWxseSBjb25maXJtZWRcbiAqIDxwcmU+XG4gKiAgICdjb25maXJtZWQnOiBRdWVyeSB0aGUgbW9zdCByZWNlbnQgYmxvY2sgd2hpY2ggaGFzIHJlYWNoZWQgMSBjb25maXJtYXRpb24gYnkgdGhlIGNsdXN0ZXJcbiAqICAgJ2ZpbmFsaXplZCc6IFF1ZXJ5IHRoZSBtb3N0IHJlY2VudCBibG9jayB3aGljaCBoYXMgYmVlbiBmaW5hbGl6ZWQgYnkgdGhlIGNsdXN0ZXJcbiAqIDwvcHJlPlxuICovXG5cbi8qKlxuICogRmlsdGVyIGZvciBsYXJnZXN0IGFjY291bnRzIHF1ZXJ5XG4gKiA8cHJlPlxuICogICAnY2lyY3VsYXRpbmcnOiAgICBSZXR1cm4gdGhlIGxhcmdlc3QgYWNjb3VudHMgdGhhdCBhcmUgcGFydCBvZiB0aGUgY2lyY3VsYXRpbmcgc3VwcGx5XG4gKiAgICdub25DaXJjdWxhdGluZyc6IFJldHVybiB0aGUgbGFyZ2VzdCBhY2NvdW50cyB0aGF0IGFyZSBub3QgcGFydCBvZiB0aGUgY2lyY3VsYXRpbmcgc3VwcGx5XG4gKiA8L3ByZT5cbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0QWNjb3VudEluZm9gIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldEJhbGFuY2VgIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldEJsb2NrYCBxdWVyeSBiZWhhdmlvclxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRCbG9ja2AgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0U3Rha2VNaW5pbXVtRGVsZWdhdGlvbmAgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0QmxvY2tIZWlnaHRgIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldEVwb2NoSW5mb2AgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0SW5mbGF0aW9uUmV3YXJkYCBxdWVyeSBiZWhhdmlvclxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRMYXRlc3RCbG9ja2hhc2hgIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGlzQmxvY2toYXNoVmFsaWRgIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldFNsb3RgIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldFNsb3RMZWFkZXJgIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldFRyYW5zYWN0aW9uYCBxdWVyeSBiZWhhdmlvclxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRUcmFuc2FjdGlvbmAgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0TGFyZ2VzdEFjY291bnRzYCBxdWVyeSBiZWhhdmlvclxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRTdXBwbHlgIHJlcXVlc3QgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBxdWVyeSBiZWhhdmlvclxuICovXG5cbi8qKlxuICogSW5mb3JtYXRpb24gZGVzY3JpYmluZyBhIGNsdXN0ZXIgbm9kZVxuICovXG5cbi8qKlxuICogSW5mb3JtYXRpb24gZGVzY3JpYmluZyBhIHZvdGUgYWNjb3VudFxuICovXG5cbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIGNsdXN0ZXIgdm90ZSBhY2NvdW50c1xuICovXG5cbi8qKlxuICogTmV0d29yayBJbmZsYXRpb25cbiAqIChzZWUgaHR0cHM6Ly9kb2NzLnNvbGFuYS5jb20vaW1wbGVtZW50ZWQtcHJvcG9zYWxzL2VkX292ZXJ2aWV3KVxuICovXG5cbmNvbnN0IEdldEluZmxhdGlvbkdvdmVybm9yUmVzdWx0ID0gc3VwZXJzdHJ1Y3QudHlwZSh7XG4gIGZvdW5kYXRpb246IHN1cGVyc3RydWN0Lm51bWJlcigpLFxuICBmb3VuZGF0aW9uVGVybTogc3VwZXJzdHJ1Y3QubnVtYmVyKCksXG4gIGluaXRpYWw6IHN1cGVyc3RydWN0Lm51bWJlcigpLFxuICB0YXBlcjogc3VwZXJzdHJ1Y3QubnVtYmVyKCksXG4gIHRlcm1pbmFsOiBzdXBlcnN0cnVjdC5udW1iZXIoKVxufSk7XG5cbi8qKlxuICogVGhlIGluZmxhdGlvbiByZXdhcmQgZm9yIGFuIGVwb2NoXG4gKi9cblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0SW5mbGF0aW9uUmV3YXJkXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRJbmZsYXRpb25SZXdhcmRSZXN1bHQgPSBqc29uUnBjUmVzdWx0KHN1cGVyc3RydWN0LmFycmF5KHN1cGVyc3RydWN0Lm51bGxhYmxlKHN1cGVyc3RydWN0LnR5cGUoe1xuICBlcG9jaDogc3VwZXJzdHJ1Y3QubnVtYmVyKCksXG4gIGVmZmVjdGl2ZVNsb3Q6IHN1cGVyc3RydWN0Lm51bWJlcigpLFxuICBhbW91bnQ6IHN1cGVyc3RydWN0Lm51bWJlcigpLFxuICBwb3N0QmFsYW5jZTogc3VwZXJzdHJ1Y3QubnVtYmVyKCksXG4gIGNvbW1pc3Npb246IHN1cGVyc3RydWN0Lm9wdGlvbmFsKHN1cGVyc3RydWN0Lm51bGxhYmxlKHN1cGVyc3RydWN0Lm51bWJlcigpKSlcbn0pKSkpO1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0UmVjZW50UHJpb3JpdGl6YXRpb25GZWVzYCBxdWVyeSBiZWhhdmlvclxuICovXG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldFJlY2VudFByaW9yaXRpemF0aW9uRmVlc1wiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0UmVjZW50UHJpb3JpdGl6YXRpb25GZWVzUmVzdWx0ID0gc3VwZXJzdHJ1Y3QuYXJyYXkoc3VwZXJzdHJ1Y3QudHlwZSh7XG4gIHNsb3Q6IHN1cGVyc3RydWN0Lm51bWJlcigpLFxuICBwcmlvcml0aXphdGlvbkZlZTogc3VwZXJzdHJ1Y3QubnVtYmVyKClcbn0pKTtcbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEluZmxhdGlvblJhdGVcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldEluZmxhdGlvblJhdGVSZXN1bHQgPSBzdXBlcnN0cnVjdC50eXBlKHtcbiAgdG90YWw6IHN1cGVyc3RydWN0Lm51bWJlcigpLFxuICB2YWxpZGF0b3I6IHN1cGVyc3RydWN0Lm51bWJlcigpLFxuICBmb3VuZGF0aW9uOiBzdXBlcnN0cnVjdC5udW1iZXIoKSxcbiAgZXBvY2g6IHN1cGVyc3RydWN0Lm51bWJlcigpXG59KTtcblxuLyoqXG4gKiBJbmZvcm1hdGlvbiBhYm91dCB0aGUgY3VycmVudCBlcG9jaFxuICovXG5cbmNvbnN0IEdldEVwb2NoSW5mb1Jlc3VsdCA9IHN1cGVyc3RydWN0LnR5cGUoe1xuICBlcG9jaDogc3VwZXJzdHJ1Y3QubnVtYmVyKCksXG4gIHNsb3RJbmRleDogc3VwZXJzdHJ1Y3QubnVtYmVyKCksXG4gIHNsb3RzSW5FcG9jaDogc3VwZXJzdHJ1Y3QubnVtYmVyKCksXG4gIGFic29sdXRlU2xvdDogc3VwZXJzdHJ1Y3QubnVtYmVyKCksXG4gIGJsb2NrSGVpZ2h0OiBzdXBlcnN0cnVjdC5vcHRpb25hbChzdXBlcnN0cnVjdC5udW1iZXIoKSksXG4gIHRyYW5zYWN0aW9uQ291bnQ6IHN1cGVyc3RydWN0Lm9wdGlvbmFsKHN1cGVyc3RydWN0Lm51bWJlcigpKVxufSk7XG5jb25zdCBHZXRFcG9jaFNjaGVkdWxlUmVzdWx0ID0gc3VwZXJzdHJ1Y3QudHlwZSh7XG4gIHNsb3RzUGVyRXBvY2g6IHN1cGVyc3RydWN0Lm51bWJlcigpLFxuICBsZWFkZXJTY2hlZHVsZVNsb3RPZmZzZXQ6IHN1cGVyc3RydWN0Lm51bWJlcigpLFxuICB3YXJtdXA6IHN1cGVyc3RydWN0LmJvb2xlYW4oKSxcbiAgZmlyc3ROb3JtYWxFcG9jaDogc3VwZXJzdHJ1Y3QubnVtYmVyKCksXG4gIGZpcnN0Tm9ybWFsU2xvdDogc3VwZXJzdHJ1Y3QubnVtYmVyKClcbn0pO1xuXG4vKipcbiAqIExlYWRlciBzY2hlZHVsZVxuICogKHNlZSBodHRwczovL2RvY3Muc29sYW5hLmNvbS90ZXJtaW5vbG9neSNsZWFkZXItc2NoZWR1bGUpXG4gKi9cblxuY29uc3QgR2V0TGVhZGVyU2NoZWR1bGVSZXN1bHQgPSBzdXBlcnN0cnVjdC5yZWNvcmQoc3VwZXJzdHJ1Y3Quc3RyaW5nKCksIHN1cGVyc3RydWN0LmFycmF5KHN1cGVyc3RydWN0Lm51bWJlcigpKSk7XG5cbi8qKlxuICogVHJhbnNhY3Rpb24gZXJyb3Igb3IgbnVsbFxuICovXG5jb25zdCBUcmFuc2FjdGlvbkVycm9yUmVzdWx0ID0gc3VwZXJzdHJ1Y3QubnVsbGFibGUoc3VwZXJzdHJ1Y3QudW5pb24oW3N1cGVyc3RydWN0LnR5cGUoe30pLCBzdXBlcnN0cnVjdC5zdHJpbmcoKV0pKTtcblxuLyoqXG4gKiBTaWduYXR1cmUgc3RhdHVzIGZvciBhIHRyYW5zYWN0aW9uXG4gKi9cbmNvbnN0IFNpZ25hdHVyZVN0YXR1c1Jlc3VsdCA9IHN1cGVyc3RydWN0LnR5cGUoe1xuICBlcnI6IFRyYW5zYWN0aW9uRXJyb3JSZXN1bHRcbn0pO1xuXG4vKipcbiAqIFRyYW5zYWN0aW9uIHNpZ25hdHVyZSByZWNlaXZlZCBub3RpZmljYXRpb25cbiAqL1xuY29uc3QgU2lnbmF0dXJlUmVjZWl2ZWRSZXN1bHQgPSBzdXBlcnN0cnVjdC5saXRlcmFsKCdyZWNlaXZlZFNpZ25hdHVyZScpO1xuXG4vKipcbiAqIFZlcnNpb24gaW5mbyBmb3IgYSBub2RlXG4gKi9cblxuY29uc3QgVmVyc2lvblJlc3VsdCA9IHN1cGVyc3RydWN0LnR5cGUoe1xuICAnc29sYW5hLWNvcmUnOiBzdXBlcnN0cnVjdC5zdHJpbmcoKSxcbiAgJ2ZlYXR1cmUtc2V0Jzogc3VwZXJzdHJ1Y3Qub3B0aW9uYWwoc3VwZXJzdHJ1Y3QubnVtYmVyKCkpXG59KTtcbmNvbnN0IFNpbXVsYXRlZFRyYW5zYWN0aW9uUmVzcG9uc2VTdHJ1Y3QgPSBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChzdXBlcnN0cnVjdC50eXBlKHtcbiAgZXJyOiBzdXBlcnN0cnVjdC5udWxsYWJsZShzdXBlcnN0cnVjdC51bmlvbihbc3VwZXJzdHJ1Y3QudHlwZSh7fSksIHN1cGVyc3RydWN0LnN0cmluZygpXSkpLFxuICBsb2dzOiBzdXBlcnN0cnVjdC5udWxsYWJsZShzdXBlcnN0cnVjdC5hcnJheShzdXBlcnN0cnVjdC5zdHJpbmcoKSkpLFxuICBhY2NvdW50czogc3VwZXJzdHJ1Y3Qub3B0aW9uYWwoc3VwZXJzdHJ1Y3QubnVsbGFibGUoc3VwZXJzdHJ1Y3QuYXJyYXkoc3VwZXJzdHJ1Y3QubnVsbGFibGUoc3VwZXJzdHJ1Y3QudHlwZSh7XG4gICAgZXhlY3V0YWJsZTogc3VwZXJzdHJ1Y3QuYm9vbGVhbigpLFxuICAgIG93bmVyOiBzdXBlcnN0cnVjdC5zdHJpbmcoKSxcbiAgICBsYW1wb3J0czogc3VwZXJzdHJ1Y3QubnVtYmVyKCksXG4gICAgZGF0YTogc3VwZXJzdHJ1Y3QuYXJyYXkoc3VwZXJzdHJ1Y3Quc3RyaW5nKCkpLFxuICAgIHJlbnRFcG9jaDogc3VwZXJzdHJ1Y3Qub3B0aW9uYWwoc3VwZXJzdHJ1Y3QubnVtYmVyKCkpXG4gIH0pKSkpKSxcbiAgdW5pdHNDb25zdW1lZDogc3VwZXJzdHJ1Y3Qub3B0aW9uYWwoc3VwZXJzdHJ1Y3QubnVtYmVyKCkpLFxuICByZXR1cm5EYXRhOiBzdXBlcnN0cnVjdC5vcHRpb25hbChzdXBlcnN0cnVjdC5udWxsYWJsZShzdXBlcnN0cnVjdC50eXBlKHtcbiAgICBwcm9ncmFtSWQ6IHN1cGVyc3RydWN0LnN0cmluZygpLFxuICAgIGRhdGE6IHN1cGVyc3RydWN0LnR1cGxlKFtzdXBlcnN0cnVjdC5zdHJpbmcoKSwgc3VwZXJzdHJ1Y3QubGl0ZXJhbCgnYmFzZTY0JyldKVxuICB9KSkpXG59KSk7XG5cbi8qKlxuICogTWV0YWRhdGEgZm9yIGEgcGFyc2VkIGNvbmZpcm1lZCB0cmFuc2FjdGlvbiBvbiB0aGUgbGVkZ2VyXG4gKlxuICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBTb2xhbmEgdjEuOC4wLiBQbGVhc2UgdXNlIHtAbGluayBQYXJzZWRUcmFuc2FjdGlvbk1ldGF9IGluc3RlYWQuXG4gKi9cblxuLyoqXG4gKiBDb2xsZWN0aW9uIG9mIGFkZHJlc3NlcyBsb2FkZWQgYnkgYSB0cmFuc2FjdGlvbiB1c2luZyBhZGRyZXNzIHRhYmxlIGxvb2t1cHNcbiAqL1xuXG4vKipcbiAqIE1ldGFkYXRhIGZvciBhIHBhcnNlZCB0cmFuc2FjdGlvbiBvbiB0aGUgbGVkZ2VyXG4gKi9cblxuLyoqXG4gKiBNZXRhZGF0YSBmb3IgYSBjb25maXJtZWQgdHJhbnNhY3Rpb24gb24gdGhlIGxlZGdlclxuICovXG5cbi8qKlxuICogQSBwcm9jZXNzZWQgdHJhbnNhY3Rpb24gZnJvbSB0aGUgUlBDIEFQSVxuICovXG5cbi8qKlxuICogQSBwcm9jZXNzZWQgdHJhbnNhY3Rpb24gZnJvbSB0aGUgUlBDIEFQSVxuICovXG5cbi8qKlxuICogQSBwcm9jZXNzZWQgdHJhbnNhY3Rpb24gbWVzc2FnZSBmcm9tIHRoZSBSUEMgQVBJXG4gKi9cblxuLyoqXG4gKiBBIGNvbmZpcm1lZCB0cmFuc2FjdGlvbiBvbiB0aGUgbGVkZ2VyXG4gKlxuICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBTb2xhbmEgdjEuOC4wLlxuICovXG5cbi8qKlxuICogQSBwYXJ0aWFsbHkgZGVjb2RlZCB0cmFuc2FjdGlvbiBpbnN0cnVjdGlvblxuICovXG5cbi8qKlxuICogQSBwYXJzZWQgdHJhbnNhY3Rpb24gbWVzc2FnZSBhY2NvdW50XG4gKi9cblxuLyoqXG4gKiBBIHBhcnNlZCB0cmFuc2FjdGlvbiBpbnN0cnVjdGlvblxuICovXG5cbi8qKlxuICogQSBwYXJzZWQgYWRkcmVzcyB0YWJsZSBsb29rdXBcbiAqL1xuXG4vKipcbiAqIEEgcGFyc2VkIHRyYW5zYWN0aW9uIG1lc3NhZ2VcbiAqL1xuXG4vKipcbiAqIEEgcGFyc2VkIHRyYW5zYWN0aW9uXG4gKi9cblxuLyoqXG4gKiBBIHBhcnNlZCBhbmQgY29uZmlybWVkIHRyYW5zYWN0aW9uIG9uIHRoZSBsZWRnZXJcbiAqXG4gKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFNvbGFuYSB2MS44LjAuIFBsZWFzZSB1c2Uge0BsaW5rIFBhcnNlZFRyYW5zYWN0aW9uV2l0aE1ldGF9IGluc3RlYWQuXG4gKi9cblxuLyoqXG4gKiBBIHBhcnNlZCB0cmFuc2FjdGlvbiBvbiB0aGUgbGVkZ2VyIHdpdGggbWV0YVxuICovXG5cbi8qKlxuICogQSBwcm9jZXNzZWQgYmxvY2sgZmV0Y2hlZCBmcm9tIHRoZSBSUEMgQVBJXG4gKi9cblxuLyoqXG4gKiBBIHByb2Nlc3NlZCBibG9jayBmZXRjaGVkIGZyb20gdGhlIFJQQyBBUEkgd2hlcmUgdGhlIGB0cmFuc2FjdGlvbkRldGFpbHNgIG1vZGUgaXMgYGFjY291bnRzYFxuICovXG5cbi8qKlxuICogQSBwcm9jZXNzZWQgYmxvY2sgZmV0Y2hlZCBmcm9tIHRoZSBSUEMgQVBJIHdoZXJlIHRoZSBgdHJhbnNhY3Rpb25EZXRhaWxzYCBtb2RlIGlzIGBub25lYFxuICovXG5cbi8qKlxuICogQSBibG9jayB3aXRoIHBhcnNlZCB0cmFuc2FjdGlvbnNcbiAqL1xuXG4vKipcbiAqIEEgYmxvY2sgd2l0aCBwYXJzZWQgdHJhbnNhY3Rpb25zIHdoZXJlIHRoZSBgdHJhbnNhY3Rpb25EZXRhaWxzYCBtb2RlIGlzIGBhY2NvdW50c2BcbiAqL1xuXG4vKipcbiAqIEEgYmxvY2sgd2l0aCBwYXJzZWQgdHJhbnNhY3Rpb25zIHdoZXJlIHRoZSBgdHJhbnNhY3Rpb25EZXRhaWxzYCBtb2RlIGlzIGBub25lYFxuICovXG5cbi8qKlxuICogQSBwcm9jZXNzZWQgYmxvY2sgZmV0Y2hlZCBmcm9tIHRoZSBSUEMgQVBJXG4gKi9cblxuLyoqXG4gKiBBIHByb2Nlc3NlZCBibG9jayBmZXRjaGVkIGZyb20gdGhlIFJQQyBBUEkgd2hlcmUgdGhlIGB0cmFuc2FjdGlvbkRldGFpbHNgIG1vZGUgaXMgYGFjY291bnRzYFxuICovXG5cbi8qKlxuICogQSBwcm9jZXNzZWQgYmxvY2sgZmV0Y2hlZCBmcm9tIHRoZSBSUEMgQVBJIHdoZXJlIHRoZSBgdHJhbnNhY3Rpb25EZXRhaWxzYCBtb2RlIGlzIGBub25lYFxuICovXG5cbi8qKlxuICogQSBjb25maXJtZWQgYmxvY2sgb24gdGhlIGxlZGdlclxuICpcbiAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgU29sYW5hIHYxLjguMC5cbiAqL1xuXG4vKipcbiAqIEEgQmxvY2sgb24gdGhlIGxlZGdlciB3aXRoIHNpZ25hdHVyZXMgb25seVxuICovXG5cbi8qKlxuICogcmVjZW50IGJsb2NrIHByb2R1Y3Rpb24gaW5mb3JtYXRpb25cbiAqL1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRCbG9ja1Byb2R1Y3Rpb25cIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEJsb2NrUHJvZHVjdGlvblJlc3BvbnNlU3RydWN0ID0ganNvblJwY1Jlc3VsdEFuZENvbnRleHQoc3VwZXJzdHJ1Y3QudHlwZSh7XG4gIGJ5SWRlbnRpdHk6IHN1cGVyc3RydWN0LnJlY29yZChzdXBlcnN0cnVjdC5zdHJpbmcoKSwgc3VwZXJzdHJ1Y3QuYXJyYXkoc3VwZXJzdHJ1Y3QubnVtYmVyKCkpKSxcbiAgcmFuZ2U6IHN1cGVyc3RydWN0LnR5cGUoe1xuICAgIGZpcnN0U2xvdDogc3VwZXJzdHJ1Y3QubnVtYmVyKCksXG4gICAgbGFzdFNsb3Q6IHN1cGVyc3RydWN0Lm51bWJlcigpXG4gIH0pXG59KSk7XG5cbi8qKlxuICogQSBwZXJmb3JtYW5jZSBzYW1wbGVcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVScGNDbGllbnQodXJsLCBodHRwSGVhZGVycywgY3VzdG9tRmV0Y2gsIGZldGNoTWlkZGxld2FyZSwgZGlzYWJsZVJldHJ5T25SYXRlTGltaXQsIGh0dHBBZ2VudCkge1xuICBjb25zdCBmZXRjaCA9IGN1c3RvbUZldGNoID8gY3VzdG9tRmV0Y2ggOiBmZXRjaEltcGw7XG4gIGxldCBhZ2VudDtcbiAge1xuICAgIGlmIChodHRwQWdlbnQgPT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICBjb25zdCBhZ2VudE9wdGlvbnMgPSB7XG4gICAgICAgICAgLy8gT25lIHNlY29uZCBmZXdlciB0aGFuIHRoZSBTb2xhbmEgUlBDJ3Mga2VlcGFsaXZlIHRpbWVvdXQuXG4gICAgICAgICAgLy8gUmVhZCBtb3JlOiBodHRwczovL2dpdGh1Yi5jb20vc29sYW5hLWxhYnMvc29sYW5hL2lzc3Vlcy8yNzg1OSNpc3N1ZWNvbW1lbnQtMTM0MDA5Nzg4OVxuICAgICAgICAgIGZyZWVTb2NrZXRUaW1lb3V0OiAxOTAwMCxcbiAgICAgICAgICBrZWVwQWxpdmU6IHRydWUsXG4gICAgICAgICAgbWF4U29ja2V0czogMjVcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHVybC5zdGFydHNXaXRoKCdodHRwczonKSkge1xuICAgICAgICAgIGFnZW50ID0gbmV3IEh0dHBzQWdlbnQoYWdlbnRPcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZ2VudCA9IG5ldyBIdHRwS2VlcEFsaXZlQWdlbnQoYWdlbnRPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaHR0cEFnZW50ICE9PSBmYWxzZSkge1xuICAgICAgICBjb25zdCBpc0h0dHBzID0gdXJsLnN0YXJ0c1dpdGgoJ2h0dHBzOicpO1xuICAgICAgICBpZiAoaXNIdHRwcyAmJiAhKGh0dHBBZ2VudCBpbnN0YW5jZW9mIHJlcXVpcmUkJDAkMi5BZ2VudCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBlbmRwb2ludCBgJyArIHVybCArICdgIGNhbiBvbmx5IGJlIHBhaXJlZCB3aXRoIGFuIGBodHRwcy5BZ2VudGAuIFlvdSBoYXZlLCBpbnN0ZWFkLCBzdXBwbGllZCBhbiAnICsgJ2BodHRwLkFnZW50YCB0aHJvdWdoIGBodHRwQWdlbnRgLicpO1xuICAgICAgICB9IGVsc2UgaWYgKCFpc0h0dHBzICYmIGh0dHBBZ2VudCBpbnN0YW5jZW9mIHJlcXVpcmUkJDAkMi5BZ2VudCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGVuZHBvaW50IGAnICsgdXJsICsgJ2AgY2FuIG9ubHkgYmUgcGFpcmVkIHdpdGggYW4gYGh0dHAuQWdlbnRgLiBZb3UgaGF2ZSwgaW5zdGVhZCwgc3VwcGxpZWQgYW4gJyArICdgaHR0cHMuQWdlbnRgIHRocm91Z2ggYGh0dHBBZ2VudGAuJyk7XG4gICAgICAgIH1cbiAgICAgICAgYWdlbnQgPSBodHRwQWdlbnQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGxldCBmZXRjaFdpdGhNaWRkbGV3YXJlO1xuICBpZiAoZmV0Y2hNaWRkbGV3YXJlKSB7XG4gICAgZmV0Y2hXaXRoTWlkZGxld2FyZSA9IGFzeW5jIChpbmZvLCBpbml0KSA9PiB7XG4gICAgICBjb25zdCBtb2RpZmllZEZldGNoQXJncyA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmZXRjaE1pZGRsZXdhcmUoaW5mbywgaW5pdCwgKG1vZGlmaWVkSW5mbywgbW9kaWZpZWRJbml0KSA9PiByZXNvbHZlKFttb2RpZmllZEluZm8sIG1vZGlmaWVkSW5pdF0pKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhd2FpdCBmZXRjaCguLi5tb2RpZmllZEZldGNoQXJncyk7XG4gICAgfTtcbiAgfVxuICBjb25zdCBjbGllbnRCcm93c2VyID0gbmV3IFJwY0NsaWVudF9fZGVmYXVsdC5kZWZhdWx0KGFzeW5jIChyZXF1ZXN0LCBjYWxsYmFjaykgPT4ge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGJvZHk6IHJlcXVlc3QsXG4gICAgICBhZ2VudCxcbiAgICAgIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICB9LCBodHRwSGVhZGVycyB8fCB7fSwgQ09NTU9OX0hUVFBfSEVBREVSUylcbiAgICB9O1xuICAgIHRyeSB7XG4gICAgICBsZXQgdG9vX21hbnlfcmVxdWVzdHNfcmV0cmllcyA9IDU7XG4gICAgICBsZXQgcmVzO1xuICAgICAgbGV0IHdhaXRUaW1lID0gNTAwO1xuICAgICAgZm9yICg7Oykge1xuICAgICAgICBpZiAoZmV0Y2hXaXRoTWlkZGxld2FyZSkge1xuICAgICAgICAgIHJlcyA9IGF3YWl0IGZldGNoV2l0aE1pZGRsZXdhcmUodXJsLCBvcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXMgPSBhd2FpdCBmZXRjaCh1cmwsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXMuc3RhdHVzICE9PSA0MjkgLyogVG9vIG1hbnkgcmVxdWVzdHMgKi8pIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlzYWJsZVJldHJ5T25SYXRlTGltaXQgPT09IHRydWUpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0b29fbWFueV9yZXF1ZXN0c19yZXRyaWVzIC09IDE7XG4gICAgICAgIGlmICh0b29fbWFueV9yZXF1ZXN0c19yZXRyaWVzID09PSAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5lcnJvcihgU2VydmVyIHJlc3BvbmRlZCB3aXRoICR7cmVzLnN0YXR1c30gJHtyZXMuc3RhdHVzVGV4dH0uICBSZXRyeWluZyBhZnRlciAke3dhaXRUaW1lfW1zIGRlbGF5Li4uYCk7XG4gICAgICAgIGF3YWl0IHNsZWVwKHdhaXRUaW1lKTtcbiAgICAgICAgd2FpdFRpbWUgKj0gMjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXMudGV4dCgpO1xuICAgICAgaWYgKHJlcy5vaykge1xuICAgICAgICBjYWxsYmFjayhudWxsLCB0ZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcihgJHtyZXMuc3RhdHVzfSAke3Jlcy5zdGF0dXNUZXh0fTogJHt0ZXh0fWApKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikgY2FsbGJhY2soZXJyKTtcbiAgICB9XG4gIH0sIHt9KTtcbiAgcmV0dXJuIGNsaWVudEJyb3dzZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVScGNSZXF1ZXN0KGNsaWVudCkge1xuICByZXR1cm4gKG1ldGhvZCwgYXJncykgPT4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjbGllbnQucmVxdWVzdChtZXRob2QsIGFyZ3MsIChlcnIsIHJlc3BvbnNlKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJwY0JhdGNoUmVxdWVzdChjbGllbnQpIHtcbiAgcmV0dXJuIHJlcXVlc3RzID0+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgLy8gRG8gbm90aGluZyBpZiByZXF1ZXN0cyBpcyBlbXB0eVxuICAgICAgaWYgKHJlcXVlc3RzLmxlbmd0aCA9PT0gMCkgcmVzb2x2ZShbXSk7XG4gICAgICBjb25zdCBiYXRjaCA9IHJlcXVlc3RzLm1hcChwYXJhbXMgPT4ge1xuICAgICAgICByZXR1cm4gY2xpZW50LnJlcXVlc3QocGFyYW1zLm1ldGhvZE5hbWUsIHBhcmFtcy5hcmdzKTtcbiAgICAgIH0pO1xuICAgICAgY2xpZW50LnJlcXVlc3QoYmF0Y2gsIChlcnIsIHJlc3BvbnNlKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbn1cblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0SW5mbGF0aW9uR292ZXJub3JcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldEluZmxhdGlvbkdvdmVybm9yUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChHZXRJbmZsYXRpb25Hb3Zlcm5vclJlc3VsdCk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEluZmxhdGlvblJhdGVcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldEluZmxhdGlvblJhdGVScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KEdldEluZmxhdGlvblJhdGVSZXN1bHQpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRSZWNlbnRQcmlvcml0aXphdGlvbkZlZXNcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldFJlY2VudFByaW9yaXRpemF0aW9uRmVlc1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQoR2V0UmVjZW50UHJpb3JpdGl6YXRpb25GZWVzUmVzdWx0KTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0RXBvY2hJbmZvXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRFcG9jaEluZm9ScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KEdldEVwb2NoSW5mb1Jlc3VsdCk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEVwb2NoU2NoZWR1bGVcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldEVwb2NoU2NoZWR1bGVScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KEdldEVwb2NoU2NoZWR1bGVSZXN1bHQpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRMZWFkZXJTY2hlZHVsZVwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0TGVhZGVyU2NoZWR1bGVScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KEdldExlYWRlclNjaGVkdWxlUmVzdWx0KTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwibWluaW11bUxlZGdlclNsb3RcIiBhbmQgXCJnZXRGaXJzdEF2YWlsYWJsZUJsb2NrXCIgbWVzc2FnZXNcbiAqL1xuY29uc3QgU2xvdFJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQoc3VwZXJzdHJ1Y3QubnVtYmVyKCkpO1xuXG4vKipcbiAqIFN1cHBseVxuICovXG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldFN1cHBseVwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0U3VwcGx5UnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdEFuZENvbnRleHQoc3VwZXJzdHJ1Y3QudHlwZSh7XG4gIHRvdGFsOiBzdXBlcnN0cnVjdC5udW1iZXIoKSxcbiAgY2lyY3VsYXRpbmc6IHN1cGVyc3RydWN0Lm51bWJlcigpLFxuICBub25DaXJjdWxhdGluZzogc3VwZXJzdHJ1Y3QubnVtYmVyKCksXG4gIG5vbkNpcmN1bGF0aW5nQWNjb3VudHM6IHN1cGVyc3RydWN0LmFycmF5KFB1YmxpY0tleUZyb21TdHJpbmcpXG59KSk7XG5cbi8qKlxuICogVG9rZW4gYW1vdW50IG9iamVjdCB3aGljaCByZXR1cm5zIGEgdG9rZW4gYW1vdW50IGluIGRpZmZlcmVudCBmb3JtYXRzXG4gKiBmb3IgdmFyaW91cyBjbGllbnQgdXNlIGNhc2VzLlxuICovXG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgc3RydWN0dXJlIGZvciB0b2tlbiBhbW91bnRzXG4gKi9cbmNvbnN0IFRva2VuQW1vdW50UmVzdWx0ID0gc3VwZXJzdHJ1Y3QudHlwZSh7XG4gIGFtb3VudDogc3VwZXJzdHJ1Y3Quc3RyaW5nKCksXG4gIHVpQW1vdW50OiBzdXBlcnN0cnVjdC5udWxsYWJsZShzdXBlcnN0cnVjdC5udW1iZXIoKSksXG4gIGRlY2ltYWxzOiBzdXBlcnN0cnVjdC5udW1iZXIoKSxcbiAgdWlBbW91bnRTdHJpbmc6IHN1cGVyc3RydWN0Lm9wdGlvbmFsKHN1cGVyc3RydWN0LnN0cmluZygpKVxufSk7XG5cbi8qKlxuICogVG9rZW4gYWRkcmVzcyBhbmQgYmFsYW5jZS5cbiAqL1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRUb2tlbkxhcmdlc3RBY2NvdW50c1wiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0VG9rZW5MYXJnZXN0QWNjb3VudHNSZXN1bHQgPSBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChzdXBlcnN0cnVjdC5hcnJheShzdXBlcnN0cnVjdC50eXBlKHtcbiAgYWRkcmVzczogUHVibGljS2V5RnJvbVN0cmluZyxcbiAgYW1vdW50OiBzdXBlcnN0cnVjdC5zdHJpbmcoKSxcbiAgdWlBbW91bnQ6IHN1cGVyc3RydWN0Lm51bGxhYmxlKHN1cGVyc3RydWN0Lm51bWJlcigpKSxcbiAgZGVjaW1hbHM6IHN1cGVyc3RydWN0Lm51bWJlcigpLFxuICB1aUFtb3VudFN0cmluZzogc3VwZXJzdHJ1Y3Qub3B0aW9uYWwoc3VwZXJzdHJ1Y3Quc3RyaW5nKCkpXG59KSkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRUb2tlbkFjY291bnRzQnlPd25lclwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0VG9rZW5BY2NvdW50c0J5T3duZXIgPSBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChzdXBlcnN0cnVjdC5hcnJheShzdXBlcnN0cnVjdC50eXBlKHtcbiAgcHVia2V5OiBQdWJsaWNLZXlGcm9tU3RyaW5nLFxuICBhY2NvdW50OiBzdXBlcnN0cnVjdC50eXBlKHtcbiAgICBleGVjdXRhYmxlOiBzdXBlcnN0cnVjdC5ib29sZWFuKCksXG4gICAgb3duZXI6IFB1YmxpY0tleUZyb21TdHJpbmcsXG4gICAgbGFtcG9ydHM6IHN1cGVyc3RydWN0Lm51bWJlcigpLFxuICAgIGRhdGE6IEJ1ZmZlckZyb21SYXdBY2NvdW50RGF0YSxcbiAgICByZW50RXBvY2g6IHN1cGVyc3RydWN0Lm51bWJlcigpXG4gIH0pXG59KSkpO1xuY29uc3QgUGFyc2VkQWNjb3VudERhdGFSZXN1bHQgPSBzdXBlcnN0cnVjdC50eXBlKHtcbiAgcHJvZ3JhbTogc3VwZXJzdHJ1Y3Quc3RyaW5nKCksXG4gIHBhcnNlZDogc3VwZXJzdHJ1Y3QudW5rbm93bigpLFxuICBzcGFjZTogc3VwZXJzdHJ1Y3QubnVtYmVyKClcbn0pO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRUb2tlbkFjY291bnRzQnlPd25lclwiIG1lc3NhZ2Ugd2l0aCBwYXJzZWQgZGF0YVxuICovXG5jb25zdCBHZXRQYXJzZWRUb2tlbkFjY291bnRzQnlPd25lciA9IGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KHN1cGVyc3RydWN0LmFycmF5KHN1cGVyc3RydWN0LnR5cGUoe1xuICBwdWJrZXk6IFB1YmxpY0tleUZyb21TdHJpbmcsXG4gIGFjY291bnQ6IHN1cGVyc3RydWN0LnR5cGUoe1xuICAgIGV4ZWN1dGFibGU6IHN1cGVyc3RydWN0LmJvb2xlYW4oKSxcbiAgICBvd25lcjogUHVibGljS2V5RnJvbVN0cmluZyxcbiAgICBsYW1wb3J0czogc3VwZXJzdHJ1Y3QubnVtYmVyKCksXG4gICAgZGF0YTogUGFyc2VkQWNjb3VudERhdGFSZXN1bHQsXG4gICAgcmVudEVwb2NoOiBzdXBlcnN0cnVjdC5udW1iZXIoKVxuICB9KVxufSkpKTtcblxuLyoqXG4gKiBQYWlyIG9mIGFuIGFjY291bnQgYWRkcmVzcyBhbmQgaXRzIGJhbGFuY2VcbiAqL1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRMYXJnZXN0QWNjb3VudHNcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldExhcmdlc3RBY2NvdW50c1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KHN1cGVyc3RydWN0LmFycmF5KHN1cGVyc3RydWN0LnR5cGUoe1xuICBsYW1wb3J0czogc3VwZXJzdHJ1Y3QubnVtYmVyKCksXG4gIGFkZHJlc3M6IFB1YmxpY0tleUZyb21TdHJpbmdcbn0pKSk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IEFjY291bnRJbmZvUmVzdWx0ID0gc3VwZXJzdHJ1Y3QudHlwZSh7XG4gIGV4ZWN1dGFibGU6IHN1cGVyc3RydWN0LmJvb2xlYW4oKSxcbiAgb3duZXI6IFB1YmxpY0tleUZyb21TdHJpbmcsXG4gIGxhbXBvcnRzOiBzdXBlcnN0cnVjdC5udW1iZXIoKSxcbiAgZGF0YTogQnVmZmVyRnJvbVJhd0FjY291bnREYXRhLFxuICByZW50RXBvY2g6IHN1cGVyc3RydWN0Lm51bWJlcigpXG59KTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgS2V5ZWRBY2NvdW50SW5mb1Jlc3VsdCA9IHN1cGVyc3RydWN0LnR5cGUoe1xuICBwdWJrZXk6IFB1YmxpY0tleUZyb21TdHJpbmcsXG4gIGFjY291bnQ6IEFjY291bnRJbmZvUmVzdWx0XG59KTtcbmNvbnN0IFBhcnNlZE9yUmF3QWNjb3VudERhdGEgPSBzdXBlcnN0cnVjdC5jb2VyY2Uoc3VwZXJzdHJ1Y3QudW5pb24oW3N1cGVyc3RydWN0Lmluc3RhbmNlKGJ1ZmZlci5CdWZmZXIpLCBQYXJzZWRBY2NvdW50RGF0YVJlc3VsdF0pLCBzdXBlcnN0cnVjdC51bmlvbihbUmF3QWNjb3VudERhdGFSZXN1bHQsIFBhcnNlZEFjY291bnREYXRhUmVzdWx0XSksIHZhbHVlID0+IHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN1cGVyc3RydWN0LmNyZWF0ZSh2YWx1ZSwgQnVmZmVyRnJvbVJhd0FjY291bnREYXRhKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn0pO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBQYXJzZWRBY2NvdW50SW5mb1Jlc3VsdCA9IHN1cGVyc3RydWN0LnR5cGUoe1xuICBleGVjdXRhYmxlOiBzdXBlcnN0cnVjdC5ib29sZWFuKCksXG4gIG93bmVyOiBQdWJsaWNLZXlGcm9tU3RyaW5nLFxuICBsYW1wb3J0czogc3VwZXJzdHJ1Y3QubnVtYmVyKCksXG4gIGRhdGE6IFBhcnNlZE9yUmF3QWNjb3VudERhdGEsXG4gIHJlbnRFcG9jaDogc3VwZXJzdHJ1Y3QubnVtYmVyKClcbn0pO1xuY29uc3QgS2V5ZWRQYXJzZWRBY2NvdW50SW5mb1Jlc3VsdCA9IHN1cGVyc3RydWN0LnR5cGUoe1xuICBwdWJrZXk6IFB1YmxpY0tleUZyb21TdHJpbmcsXG4gIGFjY291bnQ6IFBhcnNlZEFjY291bnRJbmZvUmVzdWx0XG59KTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgU3Rha2VBY3RpdmF0aW9uUmVzdWx0ID0gc3VwZXJzdHJ1Y3QudHlwZSh7XG4gIHN0YXRlOiBzdXBlcnN0cnVjdC51bmlvbihbc3VwZXJzdHJ1Y3QubGl0ZXJhbCgnYWN0aXZlJyksIHN1cGVyc3RydWN0LmxpdGVyYWwoJ2luYWN0aXZlJyksIHN1cGVyc3RydWN0LmxpdGVyYWwoJ2FjdGl2YXRpbmcnKSwgc3VwZXJzdHJ1Y3QubGl0ZXJhbCgnZGVhY3RpdmF0aW5nJyldKSxcbiAgYWN0aXZlOiBzdXBlcnN0cnVjdC5udW1iZXIoKSxcbiAgaW5hY3RpdmU6IHN1cGVyc3RydWN0Lm51bWJlcigpXG59KTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0Q29uZmlybWVkU2lnbmF0dXJlc0ZvckFkZHJlc3MyXCIgbWVzc2FnZVxuICovXG5cbmNvbnN0IEdldENvbmZpcm1lZFNpZ25hdHVyZXNGb3JBZGRyZXNzMlJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQoc3VwZXJzdHJ1Y3QuYXJyYXkoc3VwZXJzdHJ1Y3QudHlwZSh7XG4gIHNpZ25hdHVyZTogc3VwZXJzdHJ1Y3Quc3RyaW5nKCksXG4gIHNsb3Q6IHN1cGVyc3RydWN0Lm51bWJlcigpLFxuICBlcnI6IFRyYW5zYWN0aW9uRXJyb3JSZXN1bHQsXG4gIG1lbW86IHN1cGVyc3RydWN0Lm51bGxhYmxlKHN1cGVyc3RydWN0LnN0cmluZygpKSxcbiAgYmxvY2tUaW1lOiBzdXBlcnN0cnVjdC5vcHRpb25hbChzdXBlcnN0cnVjdC5udWxsYWJsZShzdXBlcnN0cnVjdC5udW1iZXIoKSkpXG59KSkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRTaWduYXR1cmVzRm9yQWRkcmVzc1wiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0U2lnbmF0dXJlc0ZvckFkZHJlc3NScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KHN1cGVyc3RydWN0LmFycmF5KHN1cGVyc3RydWN0LnR5cGUoe1xuICBzaWduYXR1cmU6IHN1cGVyc3RydWN0LnN0cmluZygpLFxuICBzbG90OiBzdXBlcnN0cnVjdC5udW1iZXIoKSxcbiAgZXJyOiBUcmFuc2FjdGlvbkVycm9yUmVzdWx0LFxuICBtZW1vOiBzdXBlcnN0cnVjdC5udWxsYWJsZShzdXBlcnN0cnVjdC5zdHJpbmcoKSksXG4gIGJsb2NrVGltZTogc3VwZXJzdHJ1Y3Qub3B0aW9uYWwoc3VwZXJzdHJ1Y3QubnVsbGFibGUoc3VwZXJzdHJ1Y3QubnVtYmVyKCkpKVxufSkpKTtcblxuLyoqKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImFjY291bnROb3RpZmljYXRpb25cIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEFjY291bnROb3RpZmljYXRpb25SZXN1bHQgPSBzdXBlcnN0cnVjdC50eXBlKHtcbiAgc3Vic2NyaXB0aW9uOiBzdXBlcnN0cnVjdC5udW1iZXIoKSxcbiAgcmVzdWx0OiBub3RpZmljYXRpb25SZXN1bHRBbmRDb250ZXh0KEFjY291bnRJbmZvUmVzdWx0KVxufSk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IFByb2dyYW1BY2NvdW50SW5mb1Jlc3VsdCA9IHN1cGVyc3RydWN0LnR5cGUoe1xuICBwdWJrZXk6IFB1YmxpY0tleUZyb21TdHJpbmcsXG4gIGFjY291bnQ6IEFjY291bnRJbmZvUmVzdWx0XG59KTtcblxuLyoqKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcInByb2dyYW1Ob3RpZmljYXRpb25cIiBtZXNzYWdlXG4gKi9cbmNvbnN0IFByb2dyYW1BY2NvdW50Tm90aWZpY2F0aW9uUmVzdWx0ID0gc3VwZXJzdHJ1Y3QudHlwZSh7XG4gIHN1YnNjcmlwdGlvbjogc3VwZXJzdHJ1Y3QubnVtYmVyKCksXG4gIHJlc3VsdDogbm90aWZpY2F0aW9uUmVzdWx0QW5kQ29udGV4dChQcm9ncmFtQWNjb3VudEluZm9SZXN1bHQpXG59KTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgU2xvdEluZm9SZXN1bHQgPSBzdXBlcnN0cnVjdC50eXBlKHtcbiAgcGFyZW50OiBzdXBlcnN0cnVjdC5udW1iZXIoKSxcbiAgc2xvdDogc3VwZXJzdHJ1Y3QubnVtYmVyKCksXG4gIHJvb3Q6IHN1cGVyc3RydWN0Lm51bWJlcigpXG59KTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwic2xvdE5vdGlmaWNhdGlvblwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgU2xvdE5vdGlmaWNhdGlvblJlc3VsdCA9IHN1cGVyc3RydWN0LnR5cGUoe1xuICBzdWJzY3JpcHRpb246IHN1cGVyc3RydWN0Lm51bWJlcigpLFxuICByZXN1bHQ6IFNsb3RJbmZvUmVzdWx0XG59KTtcblxuLyoqXG4gKiBTbG90IHVwZGF0ZXMgd2hpY2ggY2FuIGJlIHVzZWQgZm9yIHRyYWNraW5nIHRoZSBsaXZlIHByb2dyZXNzIG9mIGEgY2x1c3Rlci5cbiAqIC0gYFwiZmlyc3RTaHJlZFJlY2VpdmVkXCJgOiBjb25uZWN0ZWQgbm9kZSByZWNlaXZlZCB0aGUgZmlyc3Qgc2hyZWQgb2YgYSBibG9jay5cbiAqIEluZGljYXRlcyB0aGF0IGEgbmV3IGJsb2NrIHRoYXQgaXMgYmVpbmcgcHJvZHVjZWQuXG4gKiAtIGBcImNvbXBsZXRlZFwiYDogY29ubmVjdGVkIG5vZGUgaGFzIHJlY2VpdmVkIGFsbCBzaHJlZHMgb2YgYSBibG9jay4gSW5kaWNhdGVzXG4gKiBhIGJsb2NrIHdhcyByZWNlbnRseSBwcm9kdWNlZC5cbiAqIC0gYFwib3B0aW1pc3RpY0NvbmZpcm1hdGlvblwiYDogYmxvY2sgd2FzIG9wdGltaXN0aWNhbGx5IGNvbmZpcm1lZCBieSB0aGVcbiAqIGNsdXN0ZXIuIEl0IGlzIG5vdCBndWFyYW50ZWVkIHRoYXQgYW4gb3B0aW1pc3RpYyBjb25maXJtYXRpb24gbm90aWZpY2F0aW9uXG4gKiB3aWxsIGJlIHNlbnQgZm9yIGV2ZXJ5IGZpbmFsaXplZCBibG9ja3MuXG4gKiAtIGBcInJvb3RcImA6IHRoZSBjb25uZWN0ZWQgbm9kZSByb290ZWQgdGhpcyBibG9jay5cbiAqIC0gYFwiY3JlYXRlZEJhbmtcImA6IHRoZSBjb25uZWN0ZWQgbm9kZSBoYXMgc3RhcnRlZCB2YWxpZGF0aW5nIHRoaXMgYmxvY2suXG4gKiAtIGBcImZyb3plblwiYDogdGhlIGNvbm5lY3RlZCBub2RlIGhhcyB2YWxpZGF0ZWQgdGhpcyBibG9jay5cbiAqIC0gYFwiZGVhZFwiYDogdGhlIGNvbm5lY3RlZCBub2RlIGZhaWxlZCB0byB2YWxpZGF0ZSB0aGlzIGJsb2NrLlxuICovXG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IFNsb3RVcGRhdGVSZXN1bHQgPSBzdXBlcnN0cnVjdC51bmlvbihbc3VwZXJzdHJ1Y3QudHlwZSh7XG4gIHR5cGU6IHN1cGVyc3RydWN0LnVuaW9uKFtzdXBlcnN0cnVjdC5saXRlcmFsKCdmaXJzdFNocmVkUmVjZWl2ZWQnKSwgc3VwZXJzdHJ1Y3QubGl0ZXJhbCgnY29tcGxldGVkJyksIHN1cGVyc3RydWN0LmxpdGVyYWwoJ29wdGltaXN0aWNDb25maXJtYXRpb24nKSwgc3VwZXJzdHJ1Y3QubGl0ZXJhbCgncm9vdCcpXSksXG4gIHNsb3Q6IHN1cGVyc3RydWN0Lm51bWJlcigpLFxuICB0aW1lc3RhbXA6IHN1cGVyc3RydWN0Lm51bWJlcigpXG59KSwgc3VwZXJzdHJ1Y3QudHlwZSh7XG4gIHR5cGU6IHN1cGVyc3RydWN0LmxpdGVyYWwoJ2NyZWF0ZWRCYW5rJyksXG4gIHBhcmVudDogc3VwZXJzdHJ1Y3QubnVtYmVyKCksXG4gIHNsb3Q6IHN1cGVyc3RydWN0Lm51bWJlcigpLFxuICB0aW1lc3RhbXA6IHN1cGVyc3RydWN0Lm51bWJlcigpXG59KSwgc3VwZXJzdHJ1Y3QudHlwZSh7XG4gIHR5cGU6IHN1cGVyc3RydWN0LmxpdGVyYWwoJ2Zyb3plbicpLFxuICBzbG90OiBzdXBlcnN0cnVjdC5udW1iZXIoKSxcbiAgdGltZXN0YW1wOiBzdXBlcnN0cnVjdC5udW1iZXIoKSxcbiAgc3RhdHM6IHN1cGVyc3RydWN0LnR5cGUoe1xuICAgIG51bVRyYW5zYWN0aW9uRW50cmllczogc3VwZXJzdHJ1Y3QubnVtYmVyKCksXG4gICAgbnVtU3VjY2Vzc2Z1bFRyYW5zYWN0aW9uczogc3VwZXJzdHJ1Y3QubnVtYmVyKCksXG4gICAgbnVtRmFpbGVkVHJhbnNhY3Rpb25zOiBzdXBlcnN0cnVjdC5udW1iZXIoKSxcbiAgICBtYXhUcmFuc2FjdGlvbnNQZXJFbnRyeTogc3VwZXJzdHJ1Y3QubnVtYmVyKClcbiAgfSlcbn0pLCBzdXBlcnN0cnVjdC50eXBlKHtcbiAgdHlwZTogc3VwZXJzdHJ1Y3QubGl0ZXJhbCgnZGVhZCcpLFxuICBzbG90OiBzdXBlcnN0cnVjdC5udW1iZXIoKSxcbiAgdGltZXN0YW1wOiBzdXBlcnN0cnVjdC5udW1iZXIoKSxcbiAgZXJyOiBzdXBlcnN0cnVjdC5zdHJpbmcoKVxufSldKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwic2xvdHNVcGRhdGVzTm90aWZpY2F0aW9uXCIgbWVzc2FnZVxuICovXG5jb25zdCBTbG90VXBkYXRlTm90aWZpY2F0aW9uUmVzdWx0ID0gc3VwZXJzdHJ1Y3QudHlwZSh7XG4gIHN1YnNjcmlwdGlvbjogc3VwZXJzdHJ1Y3QubnVtYmVyKCksXG4gIHJlc3VsdDogU2xvdFVwZGF0ZVJlc3VsdFxufSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcInNpZ25hdHVyZU5vdGlmaWNhdGlvblwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgU2lnbmF0dXJlTm90aWZpY2F0aW9uUmVzdWx0ID0gc3VwZXJzdHJ1Y3QudHlwZSh7XG4gIHN1YnNjcmlwdGlvbjogc3VwZXJzdHJ1Y3QubnVtYmVyKCksXG4gIHJlc3VsdDogbm90aWZpY2F0aW9uUmVzdWx0QW5kQ29udGV4dChzdXBlcnN0cnVjdC51bmlvbihbU2lnbmF0dXJlU3RhdHVzUmVzdWx0LCBTaWduYXR1cmVSZWNlaXZlZFJlc3VsdF0pKVxufSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcInJvb3ROb3RpZmljYXRpb25cIiBtZXNzYWdlXG4gKi9cbmNvbnN0IFJvb3ROb3RpZmljYXRpb25SZXN1bHQgPSBzdXBlcnN0cnVjdC50eXBlKHtcbiAgc3Vic2NyaXB0aW9uOiBzdXBlcnN0cnVjdC5udW1iZXIoKSxcbiAgcmVzdWx0OiBzdXBlcnN0cnVjdC5udW1iZXIoKVxufSk7XG5jb25zdCBDb250YWN0SW5mb1Jlc3VsdCA9IHN1cGVyc3RydWN0LnR5cGUoe1xuICBwdWJrZXk6IHN1cGVyc3RydWN0LnN0cmluZygpLFxuICBnb3NzaXA6IHN1cGVyc3RydWN0Lm51bGxhYmxlKHN1cGVyc3RydWN0LnN0cmluZygpKSxcbiAgdHB1OiBzdXBlcnN0cnVjdC5udWxsYWJsZShzdXBlcnN0cnVjdC5zdHJpbmcoKSksXG4gIHJwYzogc3VwZXJzdHJ1Y3QubnVsbGFibGUoc3VwZXJzdHJ1Y3Quc3RyaW5nKCkpLFxuICB2ZXJzaW9uOiBzdXBlcnN0cnVjdC5udWxsYWJsZShzdXBlcnN0cnVjdC5zdHJpbmcoKSlcbn0pO1xuY29uc3QgVm90ZUFjY291bnRJbmZvUmVzdWx0ID0gc3VwZXJzdHJ1Y3QudHlwZSh7XG4gIHZvdGVQdWJrZXk6IHN1cGVyc3RydWN0LnN0cmluZygpLFxuICBub2RlUHVia2V5OiBzdXBlcnN0cnVjdC5zdHJpbmcoKSxcbiAgYWN0aXZhdGVkU3Rha2U6IHN1cGVyc3RydWN0Lm51bWJlcigpLFxuICBlcG9jaFZvdGVBY2NvdW50OiBzdXBlcnN0cnVjdC5ib29sZWFuKCksXG4gIGVwb2NoQ3JlZGl0czogc3VwZXJzdHJ1Y3QuYXJyYXkoc3VwZXJzdHJ1Y3QudHVwbGUoW3N1cGVyc3RydWN0Lm51bWJlcigpLCBzdXBlcnN0cnVjdC5udW1iZXIoKSwgc3VwZXJzdHJ1Y3QubnVtYmVyKCldKSksXG4gIGNvbW1pc3Npb246IHN1cGVyc3RydWN0Lm51bWJlcigpLFxuICBsYXN0Vm90ZTogc3VwZXJzdHJ1Y3QubnVtYmVyKCksXG4gIHJvb3RTbG90OiBzdXBlcnN0cnVjdC5udWxsYWJsZShzdXBlcnN0cnVjdC5udW1iZXIoKSlcbn0pO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRWb3RlQWNjb3VudHNcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldFZvdGVBY2NvdW50cyA9IGpzb25ScGNSZXN1bHQoc3VwZXJzdHJ1Y3QudHlwZSh7XG4gIGN1cnJlbnQ6IHN1cGVyc3RydWN0LmFycmF5KFZvdGVBY2NvdW50SW5mb1Jlc3VsdCksXG4gIGRlbGlucXVlbnQ6IHN1cGVyc3RydWN0LmFycmF5KFZvdGVBY2NvdW50SW5mb1Jlc3VsdClcbn0pKTtcbmNvbnN0IENvbmZpcm1hdGlvblN0YXR1cyA9IHN1cGVyc3RydWN0LnVuaW9uKFtzdXBlcnN0cnVjdC5saXRlcmFsKCdwcm9jZXNzZWQnKSwgc3VwZXJzdHJ1Y3QubGl0ZXJhbCgnY29uZmlybWVkJyksIHN1cGVyc3RydWN0LmxpdGVyYWwoJ2ZpbmFsaXplZCcpXSk7XG5jb25zdCBTaWduYXR1cmVTdGF0dXNSZXNwb25zZSA9IHN1cGVyc3RydWN0LnR5cGUoe1xuICBzbG90OiBzdXBlcnN0cnVjdC5udW1iZXIoKSxcbiAgY29uZmlybWF0aW9uczogc3VwZXJzdHJ1Y3QubnVsbGFibGUoc3VwZXJzdHJ1Y3QubnVtYmVyKCkpLFxuICBlcnI6IFRyYW5zYWN0aW9uRXJyb3JSZXN1bHQsXG4gIGNvbmZpcm1hdGlvblN0YXR1czogc3VwZXJzdHJ1Y3Qub3B0aW9uYWwoQ29uZmlybWF0aW9uU3RhdHVzKVxufSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldFNpZ25hdHVyZVN0YXR1c2VzXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRTaWduYXR1cmVTdGF0dXNlc1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KHN1cGVyc3RydWN0LmFycmF5KHN1cGVyc3RydWN0Lm51bGxhYmxlKFNpZ25hdHVyZVN0YXR1c1Jlc3BvbnNlKSkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRNaW5pbXVtQmFsYW5jZUZvclJlbnRFeGVtcHRpb25cIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldE1pbmltdW1CYWxhbmNlRm9yUmVudEV4ZW1wdGlvblJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQoc3VwZXJzdHJ1Y3QubnVtYmVyKCkpO1xuY29uc3QgQWRkcmVzc1RhYmxlTG9va3VwU3RydWN0ID0gc3VwZXJzdHJ1Y3QudHlwZSh7XG4gIGFjY291bnRLZXk6IFB1YmxpY0tleUZyb21TdHJpbmcsXG4gIHdyaXRhYmxlSW5kZXhlczogc3VwZXJzdHJ1Y3QuYXJyYXkoc3VwZXJzdHJ1Y3QubnVtYmVyKCkpLFxuICByZWFkb25seUluZGV4ZXM6IHN1cGVyc3RydWN0LmFycmF5KHN1cGVyc3RydWN0Lm51bWJlcigpKVxufSk7XG5jb25zdCBDb25maXJtZWRUcmFuc2FjdGlvblJlc3VsdCA9IHN1cGVyc3RydWN0LnR5cGUoe1xuICBzaWduYXR1cmVzOiBzdXBlcnN0cnVjdC5hcnJheShzdXBlcnN0cnVjdC5zdHJpbmcoKSksXG4gIG1lc3NhZ2U6IHN1cGVyc3RydWN0LnR5cGUoe1xuICAgIGFjY291bnRLZXlzOiBzdXBlcnN0cnVjdC5hcnJheShzdXBlcnN0cnVjdC5zdHJpbmcoKSksXG4gICAgaGVhZGVyOiBzdXBlcnN0cnVjdC50eXBlKHtcbiAgICAgIG51bVJlcXVpcmVkU2lnbmF0dXJlczogc3VwZXJzdHJ1Y3QubnVtYmVyKCksXG4gICAgICBudW1SZWFkb25seVNpZ25lZEFjY291bnRzOiBzdXBlcnN0cnVjdC5udW1iZXIoKSxcbiAgICAgIG51bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50czogc3VwZXJzdHJ1Y3QubnVtYmVyKClcbiAgICB9KSxcbiAgICBpbnN0cnVjdGlvbnM6IHN1cGVyc3RydWN0LmFycmF5KHN1cGVyc3RydWN0LnR5cGUoe1xuICAgICAgYWNjb3VudHM6IHN1cGVyc3RydWN0LmFycmF5KHN1cGVyc3RydWN0Lm51bWJlcigpKSxcbiAgICAgIGRhdGE6IHN1cGVyc3RydWN0LnN0cmluZygpLFxuICAgICAgcHJvZ3JhbUlkSW5kZXg6IHN1cGVyc3RydWN0Lm51bWJlcigpXG4gICAgfSkpLFxuICAgIHJlY2VudEJsb2NraGFzaDogc3VwZXJzdHJ1Y3Quc3RyaW5nKCksXG4gICAgYWRkcmVzc1RhYmxlTG9va3Vwczogc3VwZXJzdHJ1Y3Qub3B0aW9uYWwoc3VwZXJzdHJ1Y3QuYXJyYXkoQWRkcmVzc1RhYmxlTG9va3VwU3RydWN0KSlcbiAgfSlcbn0pO1xuY29uc3QgQW5ub3RhdGVkQWNjb3VudEtleSA9IHN1cGVyc3RydWN0LnR5cGUoe1xuICBwdWJrZXk6IFB1YmxpY0tleUZyb21TdHJpbmcsXG4gIHNpZ25lcjogc3VwZXJzdHJ1Y3QuYm9vbGVhbigpLFxuICB3cml0YWJsZTogc3VwZXJzdHJ1Y3QuYm9vbGVhbigpLFxuICBzb3VyY2U6IHN1cGVyc3RydWN0Lm9wdGlvbmFsKHN1cGVyc3RydWN0LnVuaW9uKFtzdXBlcnN0cnVjdC5saXRlcmFsKCd0cmFuc2FjdGlvbicpLCBzdXBlcnN0cnVjdC5saXRlcmFsKCdsb29rdXBUYWJsZScpXSkpXG59KTtcbmNvbnN0IENvbmZpcm1lZFRyYW5zYWN0aW9uQWNjb3VudHNNb2RlUmVzdWx0ID0gc3VwZXJzdHJ1Y3QudHlwZSh7XG4gIGFjY291bnRLZXlzOiBzdXBlcnN0cnVjdC5hcnJheShBbm5vdGF0ZWRBY2NvdW50S2V5KSxcbiAgc2lnbmF0dXJlczogc3VwZXJzdHJ1Y3QuYXJyYXkoc3VwZXJzdHJ1Y3Quc3RyaW5nKCkpXG59KTtcbmNvbnN0IFBhcnNlZEluc3RydWN0aW9uUmVzdWx0ID0gc3VwZXJzdHJ1Y3QudHlwZSh7XG4gIHBhcnNlZDogc3VwZXJzdHJ1Y3QudW5rbm93bigpLFxuICBwcm9ncmFtOiBzdXBlcnN0cnVjdC5zdHJpbmcoKSxcbiAgcHJvZ3JhbUlkOiBQdWJsaWNLZXlGcm9tU3RyaW5nXG59KTtcbmNvbnN0IFJhd0luc3RydWN0aW9uUmVzdWx0ID0gc3VwZXJzdHJ1Y3QudHlwZSh7XG4gIGFjY291bnRzOiBzdXBlcnN0cnVjdC5hcnJheShQdWJsaWNLZXlGcm9tU3RyaW5nKSxcbiAgZGF0YTogc3VwZXJzdHJ1Y3Quc3RyaW5nKCksXG4gIHByb2dyYW1JZDogUHVibGljS2V5RnJvbVN0cmluZ1xufSk7XG5jb25zdCBJbnN0cnVjdGlvblJlc3VsdCA9IHN1cGVyc3RydWN0LnVuaW9uKFtSYXdJbnN0cnVjdGlvblJlc3VsdCwgUGFyc2VkSW5zdHJ1Y3Rpb25SZXN1bHRdKTtcbmNvbnN0IFVua25vd25JbnN0cnVjdGlvblJlc3VsdCA9IHN1cGVyc3RydWN0LnVuaW9uKFtzdXBlcnN0cnVjdC50eXBlKHtcbiAgcGFyc2VkOiBzdXBlcnN0cnVjdC51bmtub3duKCksXG4gIHByb2dyYW06IHN1cGVyc3RydWN0LnN0cmluZygpLFxuICBwcm9ncmFtSWQ6IHN1cGVyc3RydWN0LnN0cmluZygpXG59KSwgc3VwZXJzdHJ1Y3QudHlwZSh7XG4gIGFjY291bnRzOiBzdXBlcnN0cnVjdC5hcnJheShzdXBlcnN0cnVjdC5zdHJpbmcoKSksXG4gIGRhdGE6IHN1cGVyc3RydWN0LnN0cmluZygpLFxuICBwcm9ncmFtSWQ6IHN1cGVyc3RydWN0LnN0cmluZygpXG59KV0pO1xuY29uc3QgUGFyc2VkT3JSYXdJbnN0cnVjdGlvbiA9IHN1cGVyc3RydWN0LmNvZXJjZShJbnN0cnVjdGlvblJlc3VsdCwgVW5rbm93bkluc3RydWN0aW9uUmVzdWx0LCB2YWx1ZSA9PiB7XG4gIGlmICgnYWNjb3VudHMnIGluIHZhbHVlKSB7XG4gICAgcmV0dXJuIHN1cGVyc3RydWN0LmNyZWF0ZSh2YWx1ZSwgUmF3SW5zdHJ1Y3Rpb25SZXN1bHQpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdXBlcnN0cnVjdC5jcmVhdGUodmFsdWUsIFBhcnNlZEluc3RydWN0aW9uUmVzdWx0KTtcbiAgfVxufSk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IFBhcnNlZENvbmZpcm1lZFRyYW5zYWN0aW9uUmVzdWx0ID0gc3VwZXJzdHJ1Y3QudHlwZSh7XG4gIHNpZ25hdHVyZXM6IHN1cGVyc3RydWN0LmFycmF5KHN1cGVyc3RydWN0LnN0cmluZygpKSxcbiAgbWVzc2FnZTogc3VwZXJzdHJ1Y3QudHlwZSh7XG4gICAgYWNjb3VudEtleXM6IHN1cGVyc3RydWN0LmFycmF5KEFubm90YXRlZEFjY291bnRLZXkpLFxuICAgIGluc3RydWN0aW9uczogc3VwZXJzdHJ1Y3QuYXJyYXkoUGFyc2VkT3JSYXdJbnN0cnVjdGlvbiksXG4gICAgcmVjZW50QmxvY2toYXNoOiBzdXBlcnN0cnVjdC5zdHJpbmcoKSxcbiAgICBhZGRyZXNzVGFibGVMb29rdXBzOiBzdXBlcnN0cnVjdC5vcHRpb25hbChzdXBlcnN0cnVjdC5udWxsYWJsZShzdXBlcnN0cnVjdC5hcnJheShBZGRyZXNzVGFibGVMb29rdXBTdHJ1Y3QpKSlcbiAgfSlcbn0pO1xuY29uc3QgVG9rZW5CYWxhbmNlUmVzdWx0ID0gc3VwZXJzdHJ1Y3QudHlwZSh7XG4gIGFjY291bnRJbmRleDogc3VwZXJzdHJ1Y3QubnVtYmVyKCksXG4gIG1pbnQ6IHN1cGVyc3RydWN0LnN0cmluZygpLFxuICBvd25lcjogc3VwZXJzdHJ1Y3Qub3B0aW9uYWwoc3VwZXJzdHJ1Y3Quc3RyaW5nKCkpLFxuICB1aVRva2VuQW1vdW50OiBUb2tlbkFtb3VudFJlc3VsdFxufSk7XG5jb25zdCBMb2FkZWRBZGRyZXNzZXNSZXN1bHQgPSBzdXBlcnN0cnVjdC50eXBlKHtcbiAgd3JpdGFibGU6IHN1cGVyc3RydWN0LmFycmF5KFB1YmxpY0tleUZyb21TdHJpbmcpLFxuICByZWFkb25seTogc3VwZXJzdHJ1Y3QuYXJyYXkoUHVibGljS2V5RnJvbVN0cmluZylcbn0pO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBDb25maXJtZWRUcmFuc2FjdGlvbk1ldGFSZXN1bHQgPSBzdXBlcnN0cnVjdC50eXBlKHtcbiAgZXJyOiBUcmFuc2FjdGlvbkVycm9yUmVzdWx0LFxuICBmZWU6IHN1cGVyc3RydWN0Lm51bWJlcigpLFxuICBpbm5lckluc3RydWN0aW9uczogc3VwZXJzdHJ1Y3Qub3B0aW9uYWwoc3VwZXJzdHJ1Y3QubnVsbGFibGUoc3VwZXJzdHJ1Y3QuYXJyYXkoc3VwZXJzdHJ1Y3QudHlwZSh7XG4gICAgaW5kZXg6IHN1cGVyc3RydWN0Lm51bWJlcigpLFxuICAgIGluc3RydWN0aW9uczogc3VwZXJzdHJ1Y3QuYXJyYXkoc3VwZXJzdHJ1Y3QudHlwZSh7XG4gICAgICBhY2NvdW50czogc3VwZXJzdHJ1Y3QuYXJyYXkoc3VwZXJzdHJ1Y3QubnVtYmVyKCkpLFxuICAgICAgZGF0YTogc3VwZXJzdHJ1Y3Quc3RyaW5nKCksXG4gICAgICBwcm9ncmFtSWRJbmRleDogc3VwZXJzdHJ1Y3QubnVtYmVyKClcbiAgICB9KSlcbiAgfSkpKSksXG4gIHByZUJhbGFuY2VzOiBzdXBlcnN0cnVjdC5hcnJheShzdXBlcnN0cnVjdC5udW1iZXIoKSksXG4gIHBvc3RCYWxhbmNlczogc3VwZXJzdHJ1Y3QuYXJyYXkoc3VwZXJzdHJ1Y3QubnVtYmVyKCkpLFxuICBsb2dNZXNzYWdlczogc3VwZXJzdHJ1Y3Qub3B0aW9uYWwoc3VwZXJzdHJ1Y3QubnVsbGFibGUoc3VwZXJzdHJ1Y3QuYXJyYXkoc3VwZXJzdHJ1Y3Quc3RyaW5nKCkpKSksXG4gIHByZVRva2VuQmFsYW5jZXM6IHN1cGVyc3RydWN0Lm9wdGlvbmFsKHN1cGVyc3RydWN0Lm51bGxhYmxlKHN1cGVyc3RydWN0LmFycmF5KFRva2VuQmFsYW5jZVJlc3VsdCkpKSxcbiAgcG9zdFRva2VuQmFsYW5jZXM6IHN1cGVyc3RydWN0Lm9wdGlvbmFsKHN1cGVyc3RydWN0Lm51bGxhYmxlKHN1cGVyc3RydWN0LmFycmF5KFRva2VuQmFsYW5jZVJlc3VsdCkpKSxcbiAgbG9hZGVkQWRkcmVzc2VzOiBzdXBlcnN0cnVjdC5vcHRpb25hbChMb2FkZWRBZGRyZXNzZXNSZXN1bHQpLFxuICBjb21wdXRlVW5pdHNDb25zdW1lZDogc3VwZXJzdHJ1Y3Qub3B0aW9uYWwoc3VwZXJzdHJ1Y3QubnVtYmVyKCkpXG59KTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgUGFyc2VkQ29uZmlybWVkVHJhbnNhY3Rpb25NZXRhUmVzdWx0ID0gc3VwZXJzdHJ1Y3QudHlwZSh7XG4gIGVycjogVHJhbnNhY3Rpb25FcnJvclJlc3VsdCxcbiAgZmVlOiBzdXBlcnN0cnVjdC5udW1iZXIoKSxcbiAgaW5uZXJJbnN0cnVjdGlvbnM6IHN1cGVyc3RydWN0Lm9wdGlvbmFsKHN1cGVyc3RydWN0Lm51bGxhYmxlKHN1cGVyc3RydWN0LmFycmF5KHN1cGVyc3RydWN0LnR5cGUoe1xuICAgIGluZGV4OiBzdXBlcnN0cnVjdC5udW1iZXIoKSxcbiAgICBpbnN0cnVjdGlvbnM6IHN1cGVyc3RydWN0LmFycmF5KFBhcnNlZE9yUmF3SW5zdHJ1Y3Rpb24pXG4gIH0pKSkpLFxuICBwcmVCYWxhbmNlczogc3VwZXJzdHJ1Y3QuYXJyYXkoc3VwZXJzdHJ1Y3QubnVtYmVyKCkpLFxuICBwb3N0QmFsYW5jZXM6IHN1cGVyc3RydWN0LmFycmF5KHN1cGVyc3RydWN0Lm51bWJlcigpKSxcbiAgbG9nTWVzc2FnZXM6IHN1cGVyc3RydWN0Lm9wdGlvbmFsKHN1cGVyc3RydWN0Lm51bGxhYmxlKHN1cGVyc3RydWN0LmFycmF5KHN1cGVyc3RydWN0LnN0cmluZygpKSkpLFxuICBwcmVUb2tlbkJhbGFuY2VzOiBzdXBlcnN0cnVjdC5vcHRpb25hbChzdXBlcnN0cnVjdC5udWxsYWJsZShzdXBlcnN0cnVjdC5hcnJheShUb2tlbkJhbGFuY2VSZXN1bHQpKSksXG4gIHBvc3RUb2tlbkJhbGFuY2VzOiBzdXBlcnN0cnVjdC5vcHRpb25hbChzdXBlcnN0cnVjdC5udWxsYWJsZShzdXBlcnN0cnVjdC5hcnJheShUb2tlbkJhbGFuY2VSZXN1bHQpKSksXG4gIGxvYWRlZEFkZHJlc3Nlczogc3VwZXJzdHJ1Y3Qub3B0aW9uYWwoTG9hZGVkQWRkcmVzc2VzUmVzdWx0KSxcbiAgY29tcHV0ZVVuaXRzQ29uc3VtZWQ6IHN1cGVyc3RydWN0Lm9wdGlvbmFsKHN1cGVyc3RydWN0Lm51bWJlcigpKVxufSk7XG5jb25zdCBUcmFuc2FjdGlvblZlcnNpb25TdHJ1Y3QgPSBzdXBlcnN0cnVjdC51bmlvbihbc3VwZXJzdHJ1Y3QubGl0ZXJhbCgwKSwgc3VwZXJzdHJ1Y3QubGl0ZXJhbCgnbGVnYWN5JyldKTtcblxuLyoqIEBpbnRlcm5hbCAqL1xuY29uc3QgUmV3YXJkc1Jlc3VsdCA9IHN1cGVyc3RydWN0LnR5cGUoe1xuICBwdWJrZXk6IHN1cGVyc3RydWN0LnN0cmluZygpLFxuICBsYW1wb3J0czogc3VwZXJzdHJ1Y3QubnVtYmVyKCksXG4gIHBvc3RCYWxhbmNlOiBzdXBlcnN0cnVjdC5udWxsYWJsZShzdXBlcnN0cnVjdC5udW1iZXIoKSksXG4gIHJld2FyZFR5cGU6IHN1cGVyc3RydWN0Lm51bGxhYmxlKHN1cGVyc3RydWN0LnN0cmluZygpKSxcbiAgY29tbWlzc2lvbjogc3VwZXJzdHJ1Y3Qub3B0aW9uYWwoc3VwZXJzdHJ1Y3QubnVsbGFibGUoc3VwZXJzdHJ1Y3QubnVtYmVyKCkpKVxufSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEJsb2NrXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRCbG9ja1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQoc3VwZXJzdHJ1Y3QubnVsbGFibGUoc3VwZXJzdHJ1Y3QudHlwZSh7XG4gIGJsb2NraGFzaDogc3VwZXJzdHJ1Y3Quc3RyaW5nKCksXG4gIHByZXZpb3VzQmxvY2toYXNoOiBzdXBlcnN0cnVjdC5zdHJpbmcoKSxcbiAgcGFyZW50U2xvdDogc3VwZXJzdHJ1Y3QubnVtYmVyKCksXG4gIHRyYW5zYWN0aW9uczogc3VwZXJzdHJ1Y3QuYXJyYXkoc3VwZXJzdHJ1Y3QudHlwZSh7XG4gICAgdHJhbnNhY3Rpb246IENvbmZpcm1lZFRyYW5zYWN0aW9uUmVzdWx0LFxuICAgIG1ldGE6IHN1cGVyc3RydWN0Lm51bGxhYmxlKENvbmZpcm1lZFRyYW5zYWN0aW9uTWV0YVJlc3VsdCksXG4gICAgdmVyc2lvbjogc3VwZXJzdHJ1Y3Qub3B0aW9uYWwoVHJhbnNhY3Rpb25WZXJzaW9uU3RydWN0KVxuICB9KSksXG4gIHJld2FyZHM6IHN1cGVyc3RydWN0Lm9wdGlvbmFsKHN1cGVyc3RydWN0LmFycmF5KFJld2FyZHNSZXN1bHQpKSxcbiAgYmxvY2tUaW1lOiBzdXBlcnN0cnVjdC5udWxsYWJsZShzdXBlcnN0cnVjdC5udW1iZXIoKSksXG4gIGJsb2NrSGVpZ2h0OiBzdXBlcnN0cnVjdC5udWxsYWJsZShzdXBlcnN0cnVjdC5udW1iZXIoKSlcbn0pKSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEJsb2NrXCIgbWVzc2FnZSB3aGVuIGB0cmFuc2FjdGlvbkRldGFpbHNgIGlzIGBub25lYFxuICovXG5jb25zdCBHZXROb25lTW9kZUJsb2NrUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChzdXBlcnN0cnVjdC5udWxsYWJsZShzdXBlcnN0cnVjdC50eXBlKHtcbiAgYmxvY2toYXNoOiBzdXBlcnN0cnVjdC5zdHJpbmcoKSxcbiAgcHJldmlvdXNCbG9ja2hhc2g6IHN1cGVyc3RydWN0LnN0cmluZygpLFxuICBwYXJlbnRTbG90OiBzdXBlcnN0cnVjdC5udW1iZXIoKSxcbiAgcmV3YXJkczogc3VwZXJzdHJ1Y3Qub3B0aW9uYWwoc3VwZXJzdHJ1Y3QuYXJyYXkoUmV3YXJkc1Jlc3VsdCkpLFxuICBibG9ja1RpbWU6IHN1cGVyc3RydWN0Lm51bGxhYmxlKHN1cGVyc3RydWN0Lm51bWJlcigpKSxcbiAgYmxvY2tIZWlnaHQ6IHN1cGVyc3RydWN0Lm51bGxhYmxlKHN1cGVyc3RydWN0Lm51bWJlcigpKVxufSkpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0QmxvY2tcIiBtZXNzYWdlIHdoZW4gYHRyYW5zYWN0aW9uRGV0YWlsc2AgaXMgYGFjY291bnRzYFxuICovXG5jb25zdCBHZXRBY2NvdW50c01vZGVCbG9ja1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQoc3VwZXJzdHJ1Y3QubnVsbGFibGUoc3VwZXJzdHJ1Y3QudHlwZSh7XG4gIGJsb2NraGFzaDogc3VwZXJzdHJ1Y3Quc3RyaW5nKCksXG4gIHByZXZpb3VzQmxvY2toYXNoOiBzdXBlcnN0cnVjdC5zdHJpbmcoKSxcbiAgcGFyZW50U2xvdDogc3VwZXJzdHJ1Y3QubnVtYmVyKCksXG4gIHRyYW5zYWN0aW9uczogc3VwZXJzdHJ1Y3QuYXJyYXkoc3VwZXJzdHJ1Y3QudHlwZSh7XG4gICAgdHJhbnNhY3Rpb246IENvbmZpcm1lZFRyYW5zYWN0aW9uQWNjb3VudHNNb2RlUmVzdWx0LFxuICAgIG1ldGE6IHN1cGVyc3RydWN0Lm51bGxhYmxlKENvbmZpcm1lZFRyYW5zYWN0aW9uTWV0YVJlc3VsdCksXG4gICAgdmVyc2lvbjogc3VwZXJzdHJ1Y3Qub3B0aW9uYWwoVHJhbnNhY3Rpb25WZXJzaW9uU3RydWN0KVxuICB9KSksXG4gIHJld2FyZHM6IHN1cGVyc3RydWN0Lm9wdGlvbmFsKHN1cGVyc3RydWN0LmFycmF5KFJld2FyZHNSZXN1bHQpKSxcbiAgYmxvY2tUaW1lOiBzdXBlcnN0cnVjdC5udWxsYWJsZShzdXBlcnN0cnVjdC5udW1iZXIoKSksXG4gIGJsb2NrSGVpZ2h0OiBzdXBlcnN0cnVjdC5udWxsYWJsZShzdXBlcnN0cnVjdC5udW1iZXIoKSlcbn0pKSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgcGFyc2VkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRCbG9ja1wiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0UGFyc2VkQmxvY2tScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KHN1cGVyc3RydWN0Lm51bGxhYmxlKHN1cGVyc3RydWN0LnR5cGUoe1xuICBibG9ja2hhc2g6IHN1cGVyc3RydWN0LnN0cmluZygpLFxuICBwcmV2aW91c0Jsb2NraGFzaDogc3VwZXJzdHJ1Y3Quc3RyaW5nKCksXG4gIHBhcmVudFNsb3Q6IHN1cGVyc3RydWN0Lm51bWJlcigpLFxuICB0cmFuc2FjdGlvbnM6IHN1cGVyc3RydWN0LmFycmF5KHN1cGVyc3RydWN0LnR5cGUoe1xuICAgIHRyYW5zYWN0aW9uOiBQYXJzZWRDb25maXJtZWRUcmFuc2FjdGlvblJlc3VsdCxcbiAgICBtZXRhOiBzdXBlcnN0cnVjdC5udWxsYWJsZShQYXJzZWRDb25maXJtZWRUcmFuc2FjdGlvbk1ldGFSZXN1bHQpLFxuICAgIHZlcnNpb246IHN1cGVyc3RydWN0Lm9wdGlvbmFsKFRyYW5zYWN0aW9uVmVyc2lvblN0cnVjdClcbiAgfSkpLFxuICByZXdhcmRzOiBzdXBlcnN0cnVjdC5vcHRpb25hbChzdXBlcnN0cnVjdC5hcnJheShSZXdhcmRzUmVzdWx0KSksXG4gIGJsb2NrVGltZTogc3VwZXJzdHJ1Y3QubnVsbGFibGUoc3VwZXJzdHJ1Y3QubnVtYmVyKCkpLFxuICBibG9ja0hlaWdodDogc3VwZXJzdHJ1Y3QubnVsbGFibGUoc3VwZXJzdHJ1Y3QubnVtYmVyKCkpXG59KSkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIHBhcnNlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0QmxvY2tcIiBtZXNzYWdlICB3aGVuIGB0cmFuc2FjdGlvbkRldGFpbHNgIGlzIGBhY2NvdW50c2BcbiAqL1xuY29uc3QgR2V0UGFyc2VkQWNjb3VudHNNb2RlQmxvY2tScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KHN1cGVyc3RydWN0Lm51bGxhYmxlKHN1cGVyc3RydWN0LnR5cGUoe1xuICBibG9ja2hhc2g6IHN1cGVyc3RydWN0LnN0cmluZygpLFxuICBwcmV2aW91c0Jsb2NraGFzaDogc3VwZXJzdHJ1Y3Quc3RyaW5nKCksXG4gIHBhcmVudFNsb3Q6IHN1cGVyc3RydWN0Lm51bWJlcigpLFxuICB0cmFuc2FjdGlvbnM6IHN1cGVyc3RydWN0LmFycmF5KHN1cGVyc3RydWN0LnR5cGUoe1xuICAgIHRyYW5zYWN0aW9uOiBDb25maXJtZWRUcmFuc2FjdGlvbkFjY291bnRzTW9kZVJlc3VsdCxcbiAgICBtZXRhOiBzdXBlcnN0cnVjdC5udWxsYWJsZShQYXJzZWRDb25maXJtZWRUcmFuc2FjdGlvbk1ldGFSZXN1bHQpLFxuICAgIHZlcnNpb246IHN1cGVyc3RydWN0Lm9wdGlvbmFsKFRyYW5zYWN0aW9uVmVyc2lvblN0cnVjdClcbiAgfSkpLFxuICByZXdhcmRzOiBzdXBlcnN0cnVjdC5vcHRpb25hbChzdXBlcnN0cnVjdC5hcnJheShSZXdhcmRzUmVzdWx0KSksXG4gIGJsb2NrVGltZTogc3VwZXJzdHJ1Y3QubnVsbGFibGUoc3VwZXJzdHJ1Y3QubnVtYmVyKCkpLFxuICBibG9ja0hlaWdodDogc3VwZXJzdHJ1Y3QubnVsbGFibGUoc3VwZXJzdHJ1Y3QubnVtYmVyKCkpXG59KSkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIHBhcnNlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0QmxvY2tcIiBtZXNzYWdlICB3aGVuIGB0cmFuc2FjdGlvbkRldGFpbHNgIGlzIGBub25lYFxuICovXG5jb25zdCBHZXRQYXJzZWROb25lTW9kZUJsb2NrUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChzdXBlcnN0cnVjdC5udWxsYWJsZShzdXBlcnN0cnVjdC50eXBlKHtcbiAgYmxvY2toYXNoOiBzdXBlcnN0cnVjdC5zdHJpbmcoKSxcbiAgcHJldmlvdXNCbG9ja2hhc2g6IHN1cGVyc3RydWN0LnN0cmluZygpLFxuICBwYXJlbnRTbG90OiBzdXBlcnN0cnVjdC5udW1iZXIoKSxcbiAgcmV3YXJkczogc3VwZXJzdHJ1Y3Qub3B0aW9uYWwoc3VwZXJzdHJ1Y3QuYXJyYXkoUmV3YXJkc1Jlc3VsdCkpLFxuICBibG9ja1RpbWU6IHN1cGVyc3RydWN0Lm51bGxhYmxlKHN1cGVyc3RydWN0Lm51bWJlcigpKSxcbiAgYmxvY2tIZWlnaHQ6IHN1cGVyc3RydWN0Lm51bGxhYmxlKHN1cGVyc3RydWN0Lm51bWJlcigpKVxufSkpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0Q29uZmlybWVkQmxvY2tcIiBtZXNzYWdlXG4gKlxuICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBTb2xhbmEgdjEuOC4wLiBQbGVhc2UgdXNlIHtAbGluayBHZXRCbG9ja1JwY1Jlc3VsdH0gaW5zdGVhZC5cbiAqL1xuY29uc3QgR2V0Q29uZmlybWVkQmxvY2tScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KHN1cGVyc3RydWN0Lm51bGxhYmxlKHN1cGVyc3RydWN0LnR5cGUoe1xuICBibG9ja2hhc2g6IHN1cGVyc3RydWN0LnN0cmluZygpLFxuICBwcmV2aW91c0Jsb2NraGFzaDogc3VwZXJzdHJ1Y3Quc3RyaW5nKCksXG4gIHBhcmVudFNsb3Q6IHN1cGVyc3RydWN0Lm51bWJlcigpLFxuICB0cmFuc2FjdGlvbnM6IHN1cGVyc3RydWN0LmFycmF5KHN1cGVyc3RydWN0LnR5cGUoe1xuICAgIHRyYW5zYWN0aW9uOiBDb25maXJtZWRUcmFuc2FjdGlvblJlc3VsdCxcbiAgICBtZXRhOiBzdXBlcnN0cnVjdC5udWxsYWJsZShDb25maXJtZWRUcmFuc2FjdGlvbk1ldGFSZXN1bHQpXG4gIH0pKSxcbiAgcmV3YXJkczogc3VwZXJzdHJ1Y3Qub3B0aW9uYWwoc3VwZXJzdHJ1Y3QuYXJyYXkoUmV3YXJkc1Jlc3VsdCkpLFxuICBibG9ja1RpbWU6IHN1cGVyc3RydWN0Lm51bGxhYmxlKHN1cGVyc3RydWN0Lm51bWJlcigpKVxufSkpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0QmxvY2tcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldEJsb2NrU2lnbmF0dXJlc1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQoc3VwZXJzdHJ1Y3QubnVsbGFibGUoc3VwZXJzdHJ1Y3QudHlwZSh7XG4gIGJsb2NraGFzaDogc3VwZXJzdHJ1Y3Quc3RyaW5nKCksXG4gIHByZXZpb3VzQmxvY2toYXNoOiBzdXBlcnN0cnVjdC5zdHJpbmcoKSxcbiAgcGFyZW50U2xvdDogc3VwZXJzdHJ1Y3QubnVtYmVyKCksXG4gIHNpZ25hdHVyZXM6IHN1cGVyc3RydWN0LmFycmF5KHN1cGVyc3RydWN0LnN0cmluZygpKSxcbiAgYmxvY2tUaW1lOiBzdXBlcnN0cnVjdC5udWxsYWJsZShzdXBlcnN0cnVjdC5udW1iZXIoKSlcbn0pKSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldFRyYW5zYWN0aW9uXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRUcmFuc2FjdGlvblJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQoc3VwZXJzdHJ1Y3QubnVsbGFibGUoc3VwZXJzdHJ1Y3QudHlwZSh7XG4gIHNsb3Q6IHN1cGVyc3RydWN0Lm51bWJlcigpLFxuICBtZXRhOiBzdXBlcnN0cnVjdC5udWxsYWJsZShDb25maXJtZWRUcmFuc2FjdGlvbk1ldGFSZXN1bHQpLFxuICBibG9ja1RpbWU6IHN1cGVyc3RydWN0Lm9wdGlvbmFsKHN1cGVyc3RydWN0Lm51bGxhYmxlKHN1cGVyc3RydWN0Lm51bWJlcigpKSksXG4gIHRyYW5zYWN0aW9uOiBDb25maXJtZWRUcmFuc2FjdGlvblJlc3VsdCxcbiAgdmVyc2lvbjogc3VwZXJzdHJ1Y3Qub3B0aW9uYWwoVHJhbnNhY3Rpb25WZXJzaW9uU3RydWN0KVxufSkpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBwYXJzZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldFRyYW5zYWN0aW9uXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRQYXJzZWRUcmFuc2FjdGlvblJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQoc3VwZXJzdHJ1Y3QubnVsbGFibGUoc3VwZXJzdHJ1Y3QudHlwZSh7XG4gIHNsb3Q6IHN1cGVyc3RydWN0Lm51bWJlcigpLFxuICB0cmFuc2FjdGlvbjogUGFyc2VkQ29uZmlybWVkVHJhbnNhY3Rpb25SZXN1bHQsXG4gIG1ldGE6IHN1cGVyc3RydWN0Lm51bGxhYmxlKFBhcnNlZENvbmZpcm1lZFRyYW5zYWN0aW9uTWV0YVJlc3VsdCksXG4gIGJsb2NrVGltZTogc3VwZXJzdHJ1Y3Qub3B0aW9uYWwoc3VwZXJzdHJ1Y3QubnVsbGFibGUoc3VwZXJzdHJ1Y3QubnVtYmVyKCkpKSxcbiAgdmVyc2lvbjogc3VwZXJzdHJ1Y3Qub3B0aW9uYWwoVHJhbnNhY3Rpb25WZXJzaW9uU3RydWN0KVxufSkpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0UmVjZW50QmxvY2toYXNoXCIgbWVzc2FnZVxuICpcbiAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgU29sYW5hIHYxLjguMC4gUGxlYXNlIHVzZSB7QGxpbmsgR2V0TGF0ZXN0QmxvY2toYXNoUnBjUmVzdWx0fSBpbnN0ZWFkLlxuICovXG5jb25zdCBHZXRSZWNlbnRCbG9ja2hhc2hBbmRDb250ZXh0UnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdEFuZENvbnRleHQoc3VwZXJzdHJ1Y3QudHlwZSh7XG4gIGJsb2NraGFzaDogc3VwZXJzdHJ1Y3Quc3RyaW5nKCksXG4gIGZlZUNhbGN1bGF0b3I6IHN1cGVyc3RydWN0LnR5cGUoe1xuICAgIGxhbXBvcnRzUGVyU2lnbmF0dXJlOiBzdXBlcnN0cnVjdC5udW1iZXIoKVxuICB9KVxufSkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRMYXRlc3RCbG9ja2hhc2hcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldExhdGVzdEJsb2NraGFzaFJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KHN1cGVyc3RydWN0LnR5cGUoe1xuICBibG9ja2hhc2g6IHN1cGVyc3RydWN0LnN0cmluZygpLFxuICBsYXN0VmFsaWRCbG9ja0hlaWdodDogc3VwZXJzdHJ1Y3QubnVtYmVyKClcbn0pKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiaXNCbG9ja2hhc2hWYWxpZFwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgSXNCbG9ja2hhc2hWYWxpZFJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KHN1cGVyc3RydWN0LmJvb2xlYW4oKSk7XG5jb25zdCBQZXJmU2FtcGxlUmVzdWx0ID0gc3VwZXJzdHJ1Y3QudHlwZSh7XG4gIHNsb3Q6IHN1cGVyc3RydWN0Lm51bWJlcigpLFxuICBudW1UcmFuc2FjdGlvbnM6IHN1cGVyc3RydWN0Lm51bWJlcigpLFxuICBudW1TbG90czogc3VwZXJzdHJ1Y3QubnVtYmVyKCksXG4gIHNhbXBsZVBlcmlvZFNlY3M6IHN1cGVyc3RydWN0Lm51bWJlcigpXG59KTtcblxuLypcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciBcImdldFJlY2VudFBlcmZvcm1hbmNlU2FtcGxlc1wiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0UmVjZW50UGVyZm9ybWFuY2VTYW1wbGVzUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChzdXBlcnN0cnVjdC5hcnJheShQZXJmU2FtcGxlUmVzdWx0KSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEZlZUNhbGN1bGF0b3JGb3JCbG9ja2hhc2hcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldEZlZUNhbGN1bGF0b3JScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChzdXBlcnN0cnVjdC5udWxsYWJsZShzdXBlcnN0cnVjdC50eXBlKHtcbiAgZmVlQ2FsY3VsYXRvcjogc3VwZXJzdHJ1Y3QudHlwZSh7XG4gICAgbGFtcG9ydHNQZXJTaWduYXR1cmU6IHN1cGVyc3RydWN0Lm51bWJlcigpXG4gIH0pXG59KSkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJyZXF1ZXN0QWlyZHJvcFwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgUmVxdWVzdEFpcmRyb3BScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KHN1cGVyc3RydWN0LnN0cmluZygpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwic2VuZFRyYW5zYWN0aW9uXCIgbWVzc2FnZVxuICovXG5jb25zdCBTZW5kVHJhbnNhY3Rpb25ScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KHN1cGVyc3RydWN0LnN0cmluZygpKTtcblxuLyoqXG4gKiBJbmZvcm1hdGlvbiBhYm91dCB0aGUgbGF0ZXN0IHNsb3QgYmVpbmcgcHJvY2Vzc2VkIGJ5IGEgbm9kZVxuICovXG5cbi8qKlxuICogUGFyc2VkIGFjY291bnQgZGF0YVxuICovXG5cbi8qKlxuICogU3Rha2UgQWN0aXZhdGlvbiBkYXRhXG4gKi9cblxuLyoqXG4gKiBEYXRhIHNsaWNlIGFyZ3VtZW50IGZvciBnZXRQcm9ncmFtQWNjb3VudHNcbiAqL1xuXG4vKipcbiAqIE1lbW9yeSBjb21wYXJpc29uIGZpbHRlciBmb3IgZ2V0UHJvZ3JhbUFjY291bnRzXG4gKi9cblxuLyoqXG4gKiBEYXRhIHNpemUgY29tcGFyaXNvbiBmaWx0ZXIgZm9yIGdldFByb2dyYW1BY2NvdW50c1xuICovXG5cbi8qKlxuICogQSBmaWx0ZXIgb2JqZWN0IGZvciBnZXRQcm9ncmFtQWNjb3VudHNcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBnZXRQcm9ncmFtQWNjb3VudHMgcmVxdWVzdHNcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBnZXRQYXJzZWRQcm9ncmFtQWNjb3VudHNcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBnZXRNdWx0aXBsZUFjY291bnRzXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgYGdldFN0YWtlQWN0aXZhdGlvbmBcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBgZ2V0U3Rha2VBY3RpdmF0aW9uYFxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGBnZXRTdGFrZUFjdGl2YXRpb25gXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgYGdldE5vbmNlYFxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGBnZXROb25jZUFuZENvbnRleHRgXG4gKi9cblxuLyoqXG4gKiBJbmZvcm1hdGlvbiBkZXNjcmliaW5nIGFuIGFjY291bnRcbiAqL1xuXG4vKipcbiAqIEFjY291bnQgaW5mb3JtYXRpb24gaWRlbnRpZmllZCBieSBwdWJrZXlcbiAqL1xuXG4vKipcbiAqIENhbGxiYWNrIGZ1bmN0aW9uIGZvciBhY2NvdW50IGNoYW5nZSBub3RpZmljYXRpb25zXG4gKi9cblxuLyoqXG4gKiBDYWxsYmFjayBmdW5jdGlvbiBmb3IgcHJvZ3JhbSBhY2NvdW50IGNoYW5nZSBub3RpZmljYXRpb25zXG4gKi9cblxuLyoqXG4gKiBDYWxsYmFjayBmdW5jdGlvbiBmb3Igc2xvdCBjaGFuZ2Ugbm90aWZpY2F0aW9uc1xuICovXG5cbi8qKlxuICogQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIHNsb3QgdXBkYXRlIG5vdGlmaWNhdGlvbnNcbiAqL1xuXG4vKipcbiAqIENhbGxiYWNrIGZ1bmN0aW9uIGZvciBzaWduYXR1cmUgc3RhdHVzIG5vdGlmaWNhdGlvbnNcbiAqL1xuXG4vKipcbiAqIFNpZ25hdHVyZSBzdGF0dXMgbm90aWZpY2F0aW9uIHdpdGggdHJhbnNhY3Rpb24gcmVzdWx0XG4gKi9cblxuLyoqXG4gKiBTaWduYXR1cmUgcmVjZWl2ZWQgbm90aWZpY2F0aW9uXG4gKi9cblxuLyoqXG4gKiBDYWxsYmFjayBmdW5jdGlvbiBmb3Igc2lnbmF0dXJlIG5vdGlmaWNhdGlvbnNcbiAqL1xuXG4vKipcbiAqIFNpZ25hdHVyZSBzdWJzY3JpcHRpb24gb3B0aW9uc1xuICovXG5cbi8qKlxuICogQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIHJvb3QgY2hhbmdlIG5vdGlmaWNhdGlvbnNcbiAqL1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBMb2dzUmVzdWx0ID0gc3VwZXJzdHJ1Y3QudHlwZSh7XG4gIGVycjogVHJhbnNhY3Rpb25FcnJvclJlc3VsdCxcbiAgbG9nczogc3VwZXJzdHJ1Y3QuYXJyYXkoc3VwZXJzdHJ1Y3Quc3RyaW5nKCkpLFxuICBzaWduYXR1cmU6IHN1cGVyc3RydWN0LnN0cmluZygpXG59KTtcblxuLyoqXG4gKiBMb2dzIHJlc3VsdC5cbiAqL1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJsb2dzTm90aWZpY2F0aW9uXCIgbWVzc2FnZS5cbiAqL1xuY29uc3QgTG9nc05vdGlmaWNhdGlvblJlc3VsdCA9IHN1cGVyc3RydWN0LnR5cGUoe1xuICByZXN1bHQ6IG5vdGlmaWNhdGlvblJlc3VsdEFuZENvbnRleHQoTG9nc1Jlc3VsdCksXG4gIHN1YnNjcmlwdGlvbjogc3VwZXJzdHJ1Y3QubnVtYmVyKClcbn0pO1xuXG4vKipcbiAqIEZpbHRlciBmb3IgbG9nIHN1YnNjcmlwdGlvbnMuXG4gKi9cblxuLyoqXG4gKiBDYWxsYmFjayBmdW5jdGlvbiBmb3IgbG9nIG5vdGlmaWNhdGlvbnMuXG4gKi9cblxuLyoqXG4gKiBTaWduYXR1cmUgcmVzdWx0XG4gKi9cblxuLyoqXG4gKiBUcmFuc2FjdGlvbiBlcnJvclxuICovXG5cbi8qKlxuICogVHJhbnNhY3Rpb24gY29uZmlybWF0aW9uIHN0YXR1c1xuICogPHByZT5cbiAqICAgJ3Byb2Nlc3NlZCc6IFRyYW5zYWN0aW9uIGxhbmRlZCBpbiBhIGJsb2NrIHdoaWNoIGhhcyByZWFjaGVkIDEgY29uZmlybWF0aW9uIGJ5IHRoZSBjb25uZWN0ZWQgbm9kZVxuICogICAnY29uZmlybWVkJzogVHJhbnNhY3Rpb24gbGFuZGVkIGluIGEgYmxvY2sgd2hpY2ggaGFzIHJlYWNoZWQgMSBjb25maXJtYXRpb24gYnkgdGhlIGNsdXN0ZXJcbiAqICAgJ2ZpbmFsaXplZCc6IFRyYW5zYWN0aW9uIGxhbmRlZCBpbiBhIGJsb2NrIHdoaWNoIGhhcyBiZWVuIGZpbmFsaXplZCBieSB0aGUgY2x1c3RlclxuICogPC9wcmU+XG4gKi9cblxuLyoqXG4gKiBTaWduYXR1cmUgc3RhdHVzXG4gKi9cblxuLyoqXG4gKiBBIGNvbmZpcm1lZCBzaWduYXR1cmUgd2l0aCBpdHMgc3RhdHVzXG4gKi9cblxuLyoqXG4gKiBBbiBvYmplY3QgZGVmaW5pbmcgaGVhZGVycyB0byBiZSBwYXNzZWQgdG8gdGhlIFJQQyBzZXJ2ZXJcbiAqL1xuXG4vKipcbiAqIFRoZSB0eXBlIG9mIHRoZSBKYXZhU2NyaXB0IGBmZXRjaCgpYCBBUElcbiAqL1xuXG4vKipcbiAqIEEgY2FsbGJhY2sgdXNlZCB0byBhdWdtZW50IHRoZSBvdXRnb2luZyBIVFRQIHJlcXVlc3RcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gZm9yIGluc3RhbnRpYXRpbmcgYSBDb25uZWN0aW9uXG4gKi9cblxuLyoqIEBpbnRlcm5hbCAqL1xuY29uc3QgQ09NTU9OX0hUVFBfSEVBREVSUyA9IHtcbiAgJ3NvbGFuYS1jbGllbnQnOiBganMvJHtcIjAuMC4wLWRldmVsb3BtZW50XCIgfWBcbn07XG5cbi8qKlxuICogQSBjb25uZWN0aW9uIHRvIGEgZnVsbG5vZGUgSlNPTiBSUEMgZW5kcG9pbnRcbiAqL1xuY2xhc3MgQ29ubmVjdGlvbiB7XG4gIC8qKlxuICAgKiBFc3RhYmxpc2ggYSBKU09OIFJQQyBjb25uZWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSBlbmRwb2ludCBVUkwgdG8gdGhlIGZ1bGxub2RlIEpTT04gUlBDIGVuZHBvaW50XG4gICAqIEBwYXJhbSBjb21taXRtZW50T3JDb25maWcgb3B0aW9uYWwgZGVmYXVsdCBjb21taXRtZW50IGxldmVsIG9yIG9wdGlvbmFsIENvbm5lY3Rpb25Db25maWcgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICovXG4gIGNvbnN0cnVjdG9yKGVuZHBvaW50LCBfY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX2NvbW1pdG1lbnQgPSB2b2lkIDA7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX2NvbmZpcm1UcmFuc2FjdGlvbkluaXRpYWxUaW1lb3V0ID0gdm9pZCAwO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9ycGNFbmRwb2ludCA9IHZvaWQgMDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fcnBjV3NFbmRwb2ludCA9IHZvaWQgMDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fcnBjQ2xpZW50ID0gdm9pZCAwO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9ycGNSZXF1ZXN0ID0gdm9pZCAwO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9ycGNCYXRjaFJlcXVlc3QgPSB2b2lkIDA7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldCA9IHZvaWQgMDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Q29ubmVjdGVkID0gZmFsc2U7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldEhlYXJ0YmVhdCA9IG51bGw7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldElkbGVUaW1lb3V0ID0gbnVsbDtcbiAgICAvKiogQGludGVybmFsXG4gICAgICogQSBudW1iZXIgdGhhdCB3ZSBpbmNyZW1lbnQgZXZlcnkgdGltZSBhbiBhY3RpdmUgY29ubmVjdGlvbiBjbG9zZXMuXG4gICAgICogVXNlZCB0byBkZXRlcm1pbmUgd2hldGhlciB0aGUgc2FtZSBzb2NrZXQgY29ubmVjdGlvbiB0aGF0IHdhcyBvcGVuXG4gICAgICogd2hlbiBhbiBhc3luYyBvcGVyYXRpb24gc3RhcnRlZCBpcyB0aGUgc2FtZSBvbmUgdGhhdCdzIGFjdGl2ZSB3aGVuXG4gICAgICogaXRzIGNvbnRpbnVhdGlvbiBmaXJlcy5cbiAgICAgKlxuICAgICAqL1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldEdlbmVyYXRpb24gPSAwO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9kaXNhYmxlQmxvY2toYXNoQ2FjaGluZyA9IGZhbHNlO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9wb2xsaW5nQmxvY2toYXNoID0gZmFsc2U7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX2Jsb2NraGFzaEluZm8gPSB7XG4gICAgICBsYXRlc3RCbG9ja2hhc2g6IG51bGwsXG4gICAgICBsYXN0RmV0Y2g6IDAsXG4gICAgICB0cmFuc2FjdGlvblNpZ25hdHVyZXM6IFtdLFxuICAgICAgc2ltdWxhdGVkU2lnbmF0dXJlczogW11cbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9uZXh0Q2xpZW50U3Vic2NyaXB0aW9uSWQgPSAwO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9zdWJzY3JpcHRpb25EaXNwb3NlRnVuY3Rpb25zQnlDbGllbnRTdWJzY3JpcHRpb25JZCA9IHt9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9zdWJzY3JpcHRpb25IYXNoQnlDbGllbnRTdWJzY3JpcHRpb25JZCA9IHt9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9zdWJzY3JpcHRpb25TdGF0ZUNoYW5nZUNhbGxiYWNrc0J5SGFzaCA9IHt9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9zdWJzY3JpcHRpb25DYWxsYmFja3NCeVNlcnZlclN1YnNjcmlwdGlvbklkID0ge307XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbnNCeUhhc2ggPSB7fTtcbiAgICAvKipcbiAgICAgKiBTcGVjaWFsIGNhc2UuXG4gICAgICogQWZ0ZXIgYSBzaWduYXR1cmUgaXMgcHJvY2Vzc2VkLCBSUENzIGF1dG9tYXRpY2FsbHkgZGlzcG9zZSBvZiB0aGVcbiAgICAgKiBzdWJzY3JpcHRpb24gb24gdGhlIHNlcnZlciBzaWRlLiBXZSBuZWVkIHRvIHRyYWNrIHdoaWNoIG9mIHRoZXNlXG4gICAgICogc3Vic2NyaXB0aW9ucyBoYXZlIGJlZW4gZGlzcG9zZWQgaW4gc3VjaCBhIHdheSwgc28gdGhhdCB3ZSBrbm93XG4gICAgICogd2hldGhlciB0aGUgY2xpZW50IGlzIGRlYWxpbmcgd2l0aCBhIG5vdC15ZXQtcHJvY2Vzc2VkIHNpZ25hdHVyZVxuICAgICAqIChpbiB3aGljaCBjYXNlIHdlIG11c3QgdGVhciBkb3duIHRoZSBzZXJ2ZXIgc3Vic2NyaXB0aW9uKSBvciBhblxuICAgICAqIGFscmVhZHktcHJvY2Vzc2VkIHNpZ25hdHVyZSAoaW4gd2hpY2ggY2FzZSB0aGUgY2xpZW50IGNhbiBzaW1wbHlcbiAgICAgKiBjbGVhciBvdXQgdGhlIHN1YnNjcmlwdGlvbiBsb2NhbGx5IHdpdGhvdXQgdGVsbGluZyB0aGUgc2VydmVyKS5cbiAgICAgKlxuICAgICAqIE5PVEU6IFRoZXJlIGlzIGEgcHJvcG9zYWwgdG8gZWxpbWluYXRlIHRoaXMgc3BlY2lhbCBjYXNlLCBoZXJlOlxuICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zb2xhbmEtbGFicy9zb2xhbmEvaXNzdWVzLzE4ODkyXG4gICAgICovXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbnNBdXRvRGlzcG9zZWRCeVJwYyA9IG5ldyBTZXQoKTtcbiAgICAvKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgYmxvY2sgaGVpZ2h0IG9mIHRoZSBub2RlXG4gICAgICovXG4gICAgdGhpcy5nZXRCbG9ja0hlaWdodCA9ICgoKSA9PiB7XG4gICAgICBjb25zdCByZXF1ZXN0UHJvbWlzZXMgPSB7fTtcbiAgICAgIHJldHVybiBhc3luYyBjb21taXRtZW50T3JDb25maWcgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgY29tbWl0bWVudCxcbiAgICAgICAgICBjb25maWdcbiAgICAgICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgICAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtdLCBjb21taXRtZW50LCB1bmRlZmluZWQgLyogZW5jb2RpbmcgKi8sIGNvbmZpZyk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RIYXNoID0gZmFzdFN0YWJsZVN0cmluZ2lmeSQxKGFyZ3MpO1xuICAgICAgICByZXF1ZXN0UHJvbWlzZXNbcmVxdWVzdEhhc2hdID0gcmVxdWVzdFByb21pc2VzW3JlcXVlc3RIYXNoXSA/PyAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRCbG9ja0hlaWdodCcsIGFyZ3MpO1xuICAgICAgICAgICAgY29uc3QgcmVzID0gc3VwZXJzdHJ1Y3QuY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdChzdXBlcnN0cnVjdC5udW1iZXIoKSkpO1xuICAgICAgICAgICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBibG9jayBoZWlnaHQgaW5mb3JtYXRpb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXMucmVzdWx0O1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBkZWxldGUgcmVxdWVzdFByb21pc2VzW3JlcXVlc3RIYXNoXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCByZXF1ZXN0UHJvbWlzZXNbcmVxdWVzdEhhc2hdO1xuICAgICAgfTtcbiAgICB9KSgpO1xuICAgIGxldCB3c0VuZHBvaW50O1xuICAgIGxldCBodHRwSGVhZGVycztcbiAgICBsZXQgZmV0Y2g7XG4gICAgbGV0IGZldGNoTWlkZGxld2FyZTtcbiAgICBsZXQgZGlzYWJsZVJldHJ5T25SYXRlTGltaXQ7XG4gICAgbGV0IGh0dHBBZ2VudDtcbiAgICBpZiAoX2NvbW1pdG1lbnRPckNvbmZpZyAmJiB0eXBlb2YgX2NvbW1pdG1lbnRPckNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuX2NvbW1pdG1lbnQgPSBfY29tbWl0bWVudE9yQ29uZmlnO1xuICAgIH0gZWxzZSBpZiAoX2NvbW1pdG1lbnRPckNvbmZpZykge1xuICAgICAgdGhpcy5fY29tbWl0bWVudCA9IF9jb21taXRtZW50T3JDb25maWcuY29tbWl0bWVudDtcbiAgICAgIHRoaXMuX2NvbmZpcm1UcmFuc2FjdGlvbkluaXRpYWxUaW1lb3V0ID0gX2NvbW1pdG1lbnRPckNvbmZpZy5jb25maXJtVHJhbnNhY3Rpb25Jbml0aWFsVGltZW91dDtcbiAgICAgIHdzRW5kcG9pbnQgPSBfY29tbWl0bWVudE9yQ29uZmlnLndzRW5kcG9pbnQ7XG4gICAgICBodHRwSGVhZGVycyA9IF9jb21taXRtZW50T3JDb25maWcuaHR0cEhlYWRlcnM7XG4gICAgICBmZXRjaCA9IF9jb21taXRtZW50T3JDb25maWcuZmV0Y2g7XG4gICAgICBmZXRjaE1pZGRsZXdhcmUgPSBfY29tbWl0bWVudE9yQ29uZmlnLmZldGNoTWlkZGxld2FyZTtcbiAgICAgIGRpc2FibGVSZXRyeU9uUmF0ZUxpbWl0ID0gX2NvbW1pdG1lbnRPckNvbmZpZy5kaXNhYmxlUmV0cnlPblJhdGVMaW1pdDtcbiAgICAgIGh0dHBBZ2VudCA9IF9jb21taXRtZW50T3JDb25maWcuaHR0cEFnZW50O1xuICAgIH1cbiAgICB0aGlzLl9ycGNFbmRwb2ludCA9IGFzc2VydEVuZHBvaW50VXJsKGVuZHBvaW50KTtcbiAgICB0aGlzLl9ycGNXc0VuZHBvaW50ID0gd3NFbmRwb2ludCB8fCBtYWtlV2Vic29ja2V0VXJsKGVuZHBvaW50KTtcbiAgICB0aGlzLl9ycGNDbGllbnQgPSBjcmVhdGVScGNDbGllbnQoZW5kcG9pbnQsIGh0dHBIZWFkZXJzLCBmZXRjaCwgZmV0Y2hNaWRkbGV3YXJlLCBkaXNhYmxlUmV0cnlPblJhdGVMaW1pdCwgaHR0cEFnZW50KTtcbiAgICB0aGlzLl9ycGNSZXF1ZXN0ID0gY3JlYXRlUnBjUmVxdWVzdCh0aGlzLl9ycGNDbGllbnQpO1xuICAgIHRoaXMuX3JwY0JhdGNoUmVxdWVzdCA9IGNyZWF0ZVJwY0JhdGNoUmVxdWVzdCh0aGlzLl9ycGNDbGllbnQpO1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldCA9IG5ldyBScGNXZWJTb2NrZXRDbGllbnQodGhpcy5fcnBjV3NFbmRwb2ludCwge1xuICAgICAgYXV0b2Nvbm5lY3Q6IGZhbHNlLFxuICAgICAgbWF4X3JlY29ubmVjdHM6IEluZmluaXR5XG4gICAgfSk7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Lm9uKCdvcGVuJywgdGhpcy5fd3NPbk9wZW4uYmluZCh0aGlzKSk7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Lm9uKCdlcnJvcicsIHRoaXMuX3dzT25FcnJvci5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLl9ycGNXZWJTb2NrZXQub24oJ2Nsb3NlJywgdGhpcy5fd3NPbkNsb3NlLmJpbmQodGhpcykpO1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldC5vbignYWNjb3VudE5vdGlmaWNhdGlvbicsIHRoaXMuX3dzT25BY2NvdW50Tm90aWZpY2F0aW9uLmJpbmQodGhpcykpO1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldC5vbigncHJvZ3JhbU5vdGlmaWNhdGlvbicsIHRoaXMuX3dzT25Qcm9ncmFtQWNjb3VudE5vdGlmaWNhdGlvbi5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLl9ycGNXZWJTb2NrZXQub24oJ3Nsb3ROb3RpZmljYXRpb24nLCB0aGlzLl93c09uU2xvdE5vdGlmaWNhdGlvbi5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLl9ycGNXZWJTb2NrZXQub24oJ3Nsb3RzVXBkYXRlc05vdGlmaWNhdGlvbicsIHRoaXMuX3dzT25TbG90VXBkYXRlc05vdGlmaWNhdGlvbi5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLl9ycGNXZWJTb2NrZXQub24oJ3NpZ25hdHVyZU5vdGlmaWNhdGlvbicsIHRoaXMuX3dzT25TaWduYXR1cmVOb3RpZmljYXRpb24uYmluZCh0aGlzKSk7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Lm9uKCdyb290Tm90aWZpY2F0aW9uJywgdGhpcy5fd3NPblJvb3ROb3RpZmljYXRpb24uYmluZCh0aGlzKSk7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Lm9uKCdsb2dzTm90aWZpY2F0aW9uJywgdGhpcy5fd3NPbkxvZ3NOb3RpZmljYXRpb24uYmluZCh0aGlzKSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGRlZmF1bHQgY29tbWl0bWVudCB1c2VkIGZvciByZXF1ZXN0c1xuICAgKi9cbiAgZ2V0IGNvbW1pdG1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbW1pdG1lbnQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIFJQQyBlbmRwb2ludFxuICAgKi9cbiAgZ2V0IHJwY0VuZHBvaW50KCkge1xuICAgIHJldHVybiB0aGlzLl9ycGNFbmRwb2ludDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgYmFsYW5jZSBmb3IgdGhlIHNwZWNpZmllZCBwdWJsaWMga2V5LCByZXR1cm4gd2l0aCBjb250ZXh0XG4gICAqL1xuICBhc3luYyBnZXRCYWxhbmNlQW5kQ29udGV4dChwdWJsaWNLZXksIGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW3B1YmxpY0tleS50b0Jhc2U1OCgpXSwgY29tbWl0bWVudCwgdW5kZWZpbmVkIC8qIGVuY29kaW5nICovLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEJhbGFuY2UnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBzdXBlcnN0cnVjdC5jcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChzdXBlcnN0cnVjdC5udW1iZXIoKSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsIGBmYWlsZWQgdG8gZ2V0IGJhbGFuY2UgZm9yICR7cHVibGljS2V5LnRvQmFzZTU4KCl9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBiYWxhbmNlIGZvciB0aGUgc3BlY2lmaWVkIHB1YmxpYyBrZXlcbiAgICovXG4gIGFzeW5jIGdldEJhbGFuY2UocHVibGljS2V5LCBjb21taXRtZW50T3JDb25maWcpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRCYWxhbmNlQW5kQ29udGV4dChwdWJsaWNLZXksIGNvbW1pdG1lbnRPckNvbmZpZykudGhlbih4ID0+IHgudmFsdWUpLmNhdGNoKGUgPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdmYWlsZWQgdG8gZ2V0IGJhbGFuY2Ugb2YgYWNjb3VudCAnICsgcHVibGljS2V5LnRvQmFzZTU4KCkgKyAnOiAnICsgZSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGVzdGltYXRlZCBwcm9kdWN0aW9uIHRpbWUgb2YgYSBibG9ja1xuICAgKi9cbiAgYXN5bmMgZ2V0QmxvY2tUaW1lKHNsb3QpIHtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRCbG9ja1RpbWUnLCBbc2xvdF0pO1xuICAgIGNvbnN0IHJlcyA9IHN1cGVyc3RydWN0LmNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHQoc3VwZXJzdHJ1Y3QubnVsbGFibGUoc3VwZXJzdHJ1Y3QubnVtYmVyKCkpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgYGZhaWxlZCB0byBnZXQgYmxvY2sgdGltZSBmb3Igc2xvdCAke3Nsb3R9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBsb3dlc3Qgc2xvdCB0aGF0IHRoZSBub2RlIGhhcyBpbmZvcm1hdGlvbiBhYm91dCBpbiBpdHMgbGVkZ2VyLlxuICAgKiBUaGlzIHZhbHVlIG1heSBpbmNyZWFzZSBvdmVyIHRpbWUgaWYgdGhlIG5vZGUgaXMgY29uZmlndXJlZCB0byBwdXJnZSBvbGRlciBsZWRnZXIgZGF0YVxuICAgKi9cbiAgYXN5bmMgZ2V0TWluaW11bUxlZGdlclNsb3QoKSB7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnbWluaW11bUxlZGdlclNsb3QnLCBbXSk7XG4gICAgY29uc3QgcmVzID0gc3VwZXJzdHJ1Y3QuY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdChzdXBlcnN0cnVjdC5udW1iZXIoKSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IG1pbmltdW0gbGVkZ2VyIHNsb3QnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIHNsb3Qgb2YgdGhlIGxvd2VzdCBjb25maXJtZWQgYmxvY2sgdGhhdCBoYXMgbm90IGJlZW4gcHVyZ2VkIGZyb20gdGhlIGxlZGdlclxuICAgKi9cbiAgYXN5bmMgZ2V0Rmlyc3RBdmFpbGFibGVCbG9jaygpIHtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRGaXJzdEF2YWlsYWJsZUJsb2NrJywgW10pO1xuICAgIGNvbnN0IHJlcyA9IHN1cGVyc3RydWN0LmNyZWF0ZSh1bnNhZmVSZXMsIFNsb3RScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGZpcnN0IGF2YWlsYWJsZSBibG9jaycpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY3VycmVudCBzdXBwbHlcbiAgICovXG4gIGFzeW5jIGdldFN1cHBseShjb25maWcpIHtcbiAgICBsZXQgY29uZmlnQXJnID0ge307XG4gICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25maWdBcmcgPSB7XG4gICAgICAgIGNvbW1pdG1lbnQ6IGNvbmZpZ1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGNvbmZpZykge1xuICAgICAgY29uZmlnQXJnID0ge1xuICAgICAgICAuLi5jb25maWcsXG4gICAgICAgIGNvbW1pdG1lbnQ6IGNvbmZpZyAmJiBjb25maWcuY29tbWl0bWVudCB8fCB0aGlzLmNvbW1pdG1lbnRcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbmZpZ0FyZyA9IHtcbiAgICAgICAgY29tbWl0bWVudDogdGhpcy5jb21taXRtZW50XG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRTdXBwbHknLCBbY29uZmlnQXJnXSk7XG4gICAgY29uc3QgcmVzID0gc3VwZXJzdHJ1Y3QuY3JlYXRlKHVuc2FmZVJlcywgR2V0U3VwcGx5UnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBzdXBwbHknKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGN1cnJlbnQgc3VwcGx5IG9mIGEgdG9rZW4gbWludFxuICAgKi9cbiAgYXN5bmMgZ2V0VG9rZW5TdXBwbHkodG9rZW5NaW50QWRkcmVzcywgY29tbWl0bWVudCkge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW3Rva2VuTWludEFkZHJlc3MudG9CYXNlNTgoKV0sIGNvbW1pdG1lbnQpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFRva2VuU3VwcGx5JywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gc3VwZXJzdHJ1Y3QuY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdEFuZENvbnRleHQoVG9rZW5BbW91bnRSZXN1bHQpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCB0b2tlbiBzdXBwbHknKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGN1cnJlbnQgYmFsYW5jZSBvZiBhIHRva2VuIGFjY291bnRcbiAgICovXG4gIGFzeW5jIGdldFRva2VuQWNjb3VudEJhbGFuY2UodG9rZW5BZGRyZXNzLCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbdG9rZW5BZGRyZXNzLnRvQmFzZTU4KCldLCBjb21taXRtZW50KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRUb2tlbkFjY291bnRCYWxhbmNlJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gc3VwZXJzdHJ1Y3QuY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdEFuZENvbnRleHQoVG9rZW5BbW91bnRSZXN1bHQpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCB0b2tlbiBhY2NvdW50IGJhbGFuY2UnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYWxsIHRoZSB0b2tlbiBhY2NvdW50cyBvd25lZCBieSB0aGUgc3BlY2lmaWVkIGFjY291bnRcbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZTxScGNSZXNwb25zZUFuZENvbnRleHQ8R2V0UHJvZ3JhbUFjY291bnRzUmVzcG9uc2U+fVxuICAgKi9cbiAgYXN5bmMgZ2V0VG9rZW5BY2NvdW50c0J5T3duZXIob3duZXJBZGRyZXNzLCBmaWx0ZXIsIGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgbGV0IF9hcmdzID0gW293bmVyQWRkcmVzcy50b0Jhc2U1OCgpXTtcbiAgICBpZiAoJ21pbnQnIGluIGZpbHRlcikge1xuICAgICAgX2FyZ3MucHVzaCh7XG4gICAgICAgIG1pbnQ6IGZpbHRlci5taW50LnRvQmFzZTU4KClcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBfYXJncy5wdXNoKHtcbiAgICAgICAgcHJvZ3JhbUlkOiBmaWx0ZXIucHJvZ3JhbUlkLnRvQmFzZTU4KClcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKF9hcmdzLCBjb21taXRtZW50LCAnYmFzZTY0JywgY29uZmlnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRUb2tlbkFjY291bnRzQnlPd25lcicsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IHN1cGVyc3RydWN0LmNyZWF0ZSh1bnNhZmVSZXMsIEdldFRva2VuQWNjb3VudHNCeU93bmVyKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCBgZmFpbGVkIHRvIGdldCB0b2tlbiBhY2NvdW50cyBvd25lZCBieSBhY2NvdW50ICR7b3duZXJBZGRyZXNzLnRvQmFzZTU4KCl9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHBhcnNlZCB0b2tlbiBhY2NvdW50cyBvd25lZCBieSB0aGUgc3BlY2lmaWVkIGFjY291bnRcbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZTxScGNSZXNwb25zZUFuZENvbnRleHQ8QXJyYXk8e3B1YmtleTogUHVibGljS2V5LCBhY2NvdW50OiBBY2NvdW50SW5mbzxQYXJzZWRBY2NvdW50RGF0YT59Pj4+fVxuICAgKi9cbiAgYXN5bmMgZ2V0UGFyc2VkVG9rZW5BY2NvdW50c0J5T3duZXIob3duZXJBZGRyZXNzLCBmaWx0ZXIsIGNvbW1pdG1lbnQpIHtcbiAgICBsZXQgX2FyZ3MgPSBbb3duZXJBZGRyZXNzLnRvQmFzZTU4KCldO1xuICAgIGlmICgnbWludCcgaW4gZmlsdGVyKSB7XG4gICAgICBfYXJncy5wdXNoKHtcbiAgICAgICAgbWludDogZmlsdGVyLm1pbnQudG9CYXNlNTgoKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9hcmdzLnB1c2goe1xuICAgICAgICBwcm9ncmFtSWQ6IGZpbHRlci5wcm9ncmFtSWQudG9CYXNlNTgoKVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoX2FyZ3MsIGNvbW1pdG1lbnQsICdqc29uUGFyc2VkJyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0VG9rZW5BY2NvdW50c0J5T3duZXInLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBzdXBlcnN0cnVjdC5jcmVhdGUodW5zYWZlUmVzLCBHZXRQYXJzZWRUb2tlbkFjY291bnRzQnlPd25lcik7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgYGZhaWxlZCB0byBnZXQgdG9rZW4gYWNjb3VudHMgb3duZWQgYnkgYWNjb3VudCAke293bmVyQWRkcmVzcy50b0Jhc2U1OCgpfWApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgMjAgbGFyZ2VzdCBhY2NvdW50cyB3aXRoIHRoZWlyIGN1cnJlbnQgYmFsYW5jZXNcbiAgICovXG4gIGFzeW5jIGdldExhcmdlc3RBY2NvdW50cyhjb25maWcpIHtcbiAgICBjb25zdCBhcmcgPSB7XG4gICAgICAuLi5jb25maWcsXG4gICAgICBjb21taXRtZW50OiBjb25maWcgJiYgY29uZmlnLmNvbW1pdG1lbnQgfHwgdGhpcy5jb21taXRtZW50XG4gICAgfTtcbiAgICBjb25zdCBhcmdzID0gYXJnLmZpbHRlciB8fCBhcmcuY29tbWl0bWVudCA/IFthcmddIDogW107XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0TGFyZ2VzdEFjY291bnRzJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gc3VwZXJzdHJ1Y3QuY3JlYXRlKHVuc2FmZVJlcywgR2V0TGFyZ2VzdEFjY291bnRzUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBsYXJnZXN0IGFjY291bnRzJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSAyMCBsYXJnZXN0IHRva2VuIGFjY291bnRzIHdpdGggdGhlaXIgY3VycmVudCBiYWxhbmNlc1xuICAgKiBmb3IgYSBnaXZlbiBtaW50LlxuICAgKi9cbiAgYXN5bmMgZ2V0VG9rZW5MYXJnZXN0QWNjb3VudHMobWludEFkZHJlc3MsIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFttaW50QWRkcmVzcy50b0Jhc2U1OCgpXSwgY29tbWl0bWVudCk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0VG9rZW5MYXJnZXN0QWNjb3VudHMnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBzdXBlcnN0cnVjdC5jcmVhdGUodW5zYWZlUmVzLCBHZXRUb2tlbkxhcmdlc3RBY2NvdW50c1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgdG9rZW4gbGFyZ2VzdCBhY2NvdW50cycpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhbGwgdGhlIGFjY291bnQgaW5mbyBmb3IgdGhlIHNwZWNpZmllZCBwdWJsaWMga2V5LCByZXR1cm4gd2l0aCBjb250ZXh0XG4gICAqL1xuICBhc3luYyBnZXRBY2NvdW50SW5mb0FuZENvbnRleHQocHVibGljS2V5LCBjb21taXRtZW50T3JDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW3B1YmxpY0tleS50b0Jhc2U1OCgpXSwgY29tbWl0bWVudCwgJ2Jhc2U2NCcsIGNvbmZpZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0QWNjb3VudEluZm8nLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBzdXBlcnN0cnVjdC5jcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChzdXBlcnN0cnVjdC5udWxsYWJsZShBY2NvdW50SW5mb1Jlc3VsdCkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCBgZmFpbGVkIHRvIGdldCBpbmZvIGFib3V0IGFjY291bnQgJHtwdWJsaWNLZXkudG9CYXNlNTgoKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggcGFyc2VkIGFjY291bnQgaW5mbyBmb3IgdGhlIHNwZWNpZmllZCBwdWJsaWMga2V5XG4gICAqL1xuICBhc3luYyBnZXRQYXJzZWRBY2NvdW50SW5mbyhwdWJsaWNLZXksIGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbcHVibGljS2V5LnRvQmFzZTU4KCldLCBjb21taXRtZW50LCAnanNvblBhcnNlZCcsIGNvbmZpZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0QWNjb3VudEluZm8nLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBzdXBlcnN0cnVjdC5jcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChzdXBlcnN0cnVjdC5udWxsYWJsZShQYXJzZWRBY2NvdW50SW5mb1Jlc3VsdCkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCBgZmFpbGVkIHRvIGdldCBpbmZvIGFib3V0IGFjY291bnQgJHtwdWJsaWNLZXkudG9CYXNlNTgoKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYWxsIHRoZSBhY2NvdW50IGluZm8gZm9yIHRoZSBzcGVjaWZpZWQgcHVibGljIGtleVxuICAgKi9cbiAgYXN5bmMgZ2V0QWNjb3VudEluZm8ocHVibGljS2V5LCBjb21taXRtZW50T3JDb25maWcpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5nZXRBY2NvdW50SW5mb0FuZENvbnRleHQocHVibGljS2V5LCBjb21taXRtZW50T3JDb25maWcpO1xuICAgICAgcmV0dXJuIHJlcy52YWx1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZhaWxlZCB0byBnZXQgaW5mbyBhYm91dCBhY2NvdW50ICcgKyBwdWJsaWNLZXkudG9CYXNlNTgoKSArICc6ICcgKyBlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYWxsIHRoZSBhY2NvdW50IGluZm8gZm9yIG11bHRpcGxlIGFjY291bnRzIHNwZWNpZmllZCBieSBhbiBhcnJheSBvZiBwdWJsaWMga2V5cywgcmV0dXJuIHdpdGggY29udGV4dFxuICAgKi9cbiAgYXN5bmMgZ2V0TXVsdGlwbGVQYXJzZWRBY2NvdW50cyhwdWJsaWNLZXlzLCByYXdDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhyYXdDb25maWcpO1xuICAgIGNvbnN0IGtleXMgPSBwdWJsaWNLZXlzLm1hcChrZXkgPT4ga2V5LnRvQmFzZTU4KCkpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW2tleXNdLCBjb21taXRtZW50LCAnanNvblBhcnNlZCcsIGNvbmZpZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0TXVsdGlwbGVBY2NvdW50cycsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IHN1cGVyc3RydWN0LmNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KHN1cGVyc3RydWN0LmFycmF5KHN1cGVyc3RydWN0Lm51bGxhYmxlKFBhcnNlZEFjY291bnRJbmZvUmVzdWx0KSkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCBgZmFpbGVkIHRvIGdldCBpbmZvIGZvciBhY2NvdW50cyAke2tleXN9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGFsbCB0aGUgYWNjb3VudCBpbmZvIGZvciBtdWx0aXBsZSBhY2NvdW50cyBzcGVjaWZpZWQgYnkgYW4gYXJyYXkgb2YgcHVibGljIGtleXMsIHJldHVybiB3aXRoIGNvbnRleHRcbiAgICovXG4gIGFzeW5jIGdldE11bHRpcGxlQWNjb3VudHNJbmZvQW5kQ29udGV4dChwdWJsaWNLZXlzLCBjb21taXRtZW50T3JDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGtleXMgPSBwdWJsaWNLZXlzLm1hcChrZXkgPT4ga2V5LnRvQmFzZTU4KCkpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW2tleXNdLCBjb21taXRtZW50LCAnYmFzZTY0JywgY29uZmlnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRNdWx0aXBsZUFjY291bnRzJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gc3VwZXJzdHJ1Y3QuY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdEFuZENvbnRleHQoc3VwZXJzdHJ1Y3QuYXJyYXkoc3VwZXJzdHJ1Y3QubnVsbGFibGUoQWNjb3VudEluZm9SZXN1bHQpKSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsIGBmYWlsZWQgdG8gZ2V0IGluZm8gZm9yIGFjY291bnRzICR7a2V5c31gKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYWxsIHRoZSBhY2NvdW50IGluZm8gZm9yIG11bHRpcGxlIGFjY291bnRzIHNwZWNpZmllZCBieSBhbiBhcnJheSBvZiBwdWJsaWMga2V5c1xuICAgKi9cbiAgYXN5bmMgZ2V0TXVsdGlwbGVBY2NvdW50c0luZm8ocHVibGljS2V5cywgY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5nZXRNdWx0aXBsZUFjY291bnRzSW5mb0FuZENvbnRleHQocHVibGljS2V5cywgY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICByZXR1cm4gcmVzLnZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZXBvY2ggYWN0aXZhdGlvbiBpbmZvcm1hdGlvbiBmb3IgYSBzdGFrZSBhY2NvdW50IHRoYXQgaGFzIGJlZW4gZGVsZWdhdGVkXG4gICAqL1xuICBhc3luYyBnZXRTdGFrZUFjdGl2YXRpb24ocHVibGljS2V5LCBjb21taXRtZW50T3JDb25maWcsIGVwb2NoKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtwdWJsaWNLZXkudG9CYXNlNTgoKV0sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCAvKiBlbmNvZGluZyAqLywge1xuICAgICAgLi4uY29uZmlnLFxuICAgICAgZXBvY2g6IGVwb2NoICE9IG51bGwgPyBlcG9jaCA6IGNvbmZpZz8uZXBvY2hcbiAgICB9KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRTdGFrZUFjdGl2YXRpb24nLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBzdXBlcnN0cnVjdC5jcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0KFN0YWtlQWN0aXZhdGlvblJlc3VsdCkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsIGBmYWlsZWQgdG8gZ2V0IFN0YWtlIEFjdGl2YXRpb24gJHtwdWJsaWNLZXkudG9CYXNlNTgoKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYWxsIHRoZSBhY2NvdW50cyBvd25lZCBieSB0aGUgc3BlY2lmaWVkIHByb2dyYW0gaWRcbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZTxBcnJheTx7cHVia2V5OiBQdWJsaWNLZXksIGFjY291bnQ6IEFjY291bnRJbmZvPEJ1ZmZlcj59Pj59XG4gICAqL1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG4gIGFzeW5jIGdldFByb2dyYW1BY2NvdW50cyhwcm9ncmFtSWQsIGNvbmZpZ09yQ29tbWl0bWVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbmZpZ09yQ29tbWl0bWVudCk7XG4gICAgY29uc3Qge1xuICAgICAgZW5jb2RpbmcsXG4gICAgICAuLi5jb25maWdXaXRob3V0RW5jb2RpbmdcbiAgICB9ID0gY29uZmlnIHx8IHt9O1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW3Byb2dyYW1JZC50b0Jhc2U1OCgpXSwgY29tbWl0bWVudCwgZW5jb2RpbmcgfHwgJ2Jhc2U2NCcsIGNvbmZpZ1dpdGhvdXRFbmNvZGluZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0UHJvZ3JhbUFjY291bnRzJywgYXJncyk7XG4gICAgY29uc3QgYmFzZVNjaGVtYSA9IHN1cGVyc3RydWN0LmFycmF5KEtleWVkQWNjb3VudEluZm9SZXN1bHQpO1xuICAgIGNvbnN0IHJlcyA9IGNvbmZpZ1dpdGhvdXRFbmNvZGluZy53aXRoQ29udGV4dCA9PT0gdHJ1ZSA/IHN1cGVyc3RydWN0LmNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KGJhc2VTY2hlbWEpKSA6IHN1cGVyc3RydWN0LmNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHQoYmFzZVNjaGVtYSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsIGBmYWlsZWQgdG8gZ2V0IGFjY291bnRzIG93bmVkIGJ5IHByb2dyYW0gJHtwcm9ncmFtSWQudG9CYXNlNTgoKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYW5kIHBhcnNlIGFsbCB0aGUgYWNjb3VudHMgb3duZWQgYnkgdGhlIHNwZWNpZmllZCBwcm9ncmFtIGlkXG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2U8QXJyYXk8e3B1YmtleTogUHVibGljS2V5LCBhY2NvdW50OiBBY2NvdW50SW5mbzxCdWZmZXIgfCBQYXJzZWRBY2NvdW50RGF0YT59Pj59XG4gICAqL1xuICBhc3luYyBnZXRQYXJzZWRQcm9ncmFtQWNjb3VudHMocHJvZ3JhbUlkLCBjb25maWdPckNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb25maWdPckNvbW1pdG1lbnQpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW3Byb2dyYW1JZC50b0Jhc2U1OCgpXSwgY29tbWl0bWVudCwgJ2pzb25QYXJzZWQnLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFByb2dyYW1BY2NvdW50cycsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IHN1cGVyc3RydWN0LmNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHQoc3VwZXJzdHJ1Y3QuYXJyYXkoS2V5ZWRQYXJzZWRBY2NvdW50SW5mb1Jlc3VsdCkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCBgZmFpbGVkIHRvIGdldCBhY2NvdW50cyBvd25lZCBieSBwcm9ncmFtICR7cHJvZ3JhbUlkLnRvQmFzZTU4KCl9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqIEBkZXByZWNhdGVkIEluc3RlYWQsIGNhbGwgYGNvbmZpcm1UcmFuc2FjdGlvbmAgYW5kIHBhc3MgaW4ge0BsaW5rIFRyYW5zYWN0aW9uQ29uZmlybWF0aW9uU3RyYXRlZ3l9ICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG4gIGFzeW5jIGNvbmZpcm1UcmFuc2FjdGlvbihzdHJhdGVneSwgY29tbWl0bWVudCkge1xuICAgIGxldCByYXdTaWduYXR1cmU7XG4gICAgaWYgKHR5cGVvZiBzdHJhdGVneSA9PSAnc3RyaW5nJykge1xuICAgICAgcmF3U2lnbmF0dXJlID0gc3RyYXRlZ3k7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IHN0cmF0ZWd5O1xuICAgICAgaWYgKGNvbmZpZy5hYm9ydFNpZ25hbD8uYWJvcnRlZCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoY29uZmlnLmFib3J0U2lnbmFsLnJlYXNvbik7XG4gICAgICB9XG4gICAgICByYXdTaWduYXR1cmUgPSBjb25maWcuc2lnbmF0dXJlO1xuICAgIH1cbiAgICBsZXQgZGVjb2RlZFNpZ25hdHVyZTtcbiAgICB0cnkge1xuICAgICAgZGVjb2RlZFNpZ25hdHVyZSA9IGJzNThfX2RlZmF1bHQuZGVmYXVsdC5kZWNvZGUocmF3U2lnbmF0dXJlKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbmF0dXJlIG11c3QgYmUgYmFzZTU4IGVuY29kZWQ6ICcgKyByYXdTaWduYXR1cmUpO1xuICAgIH1cbiAgICBhc3NlcnQoZGVjb2RlZFNpZ25hdHVyZS5sZW5ndGggPT09IDY0LCAnc2lnbmF0dXJlIGhhcyBpbnZhbGlkIGxlbmd0aCcpO1xuICAgIGlmICh0eXBlb2Ygc3RyYXRlZ3kgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5jb25maXJtVHJhbnNhY3Rpb25Vc2luZ0xlZ2FjeVRpbWVvdXRTdHJhdGVneSh7XG4gICAgICAgIGNvbW1pdG1lbnQ6IGNvbW1pdG1lbnQgfHwgdGhpcy5jb21taXRtZW50LFxuICAgICAgICBzaWduYXR1cmU6IHJhd1NpZ25hdHVyZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICgnbGFzdFZhbGlkQmxvY2tIZWlnaHQnIGluIHN0cmF0ZWd5KSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5jb25maXJtVHJhbnNhY3Rpb25Vc2luZ0Jsb2NrSGVpZ2h0RXhjZWVkYW5jZVN0cmF0ZWd5KHtcbiAgICAgICAgY29tbWl0bWVudDogY29tbWl0bWVudCB8fCB0aGlzLmNvbW1pdG1lbnQsXG4gICAgICAgIHN0cmF0ZWd5XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY29uZmlybVRyYW5zYWN0aW9uVXNpbmdEdXJhYmxlTm9uY2VTdHJhdGVneSh7XG4gICAgICAgIGNvbW1pdG1lbnQ6IGNvbW1pdG1lbnQgfHwgdGhpcy5jb21taXRtZW50LFxuICAgICAgICBzdHJhdGVneVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGdldENhbmNlbGxhdGlvblByb21pc2Uoc2lnbmFsKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICAgIGlmIChzaWduYWwgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgcmVqZWN0KHNpZ25hbC5yZWFzb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgKCkgPT4ge1xuICAgICAgICAgIHJlamVjdChzaWduYWwucmVhc29uKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZ2V0VHJhbnNhY3Rpb25Db25maXJtYXRpb25Qcm9taXNlKHtcbiAgICBjb21taXRtZW50LFxuICAgIHNpZ25hdHVyZVxuICB9KSB7XG4gICAgbGV0IHNpZ25hdHVyZVN1YnNjcmlwdGlvbklkO1xuICAgIGxldCBkaXNwb3NlU2lnbmF0dXJlU3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2VPYnNlcnZlcjtcbiAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgIGNvbnN0IGNvbmZpcm1hdGlvblByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBzaWduYXR1cmVTdWJzY3JpcHRpb25JZCA9IHRoaXMub25TaWduYXR1cmUoc2lnbmF0dXJlLCAocmVzdWx0LCBjb250ZXh0KSA9PiB7XG4gICAgICAgICAgc2lnbmF0dXJlU3Vic2NyaXB0aW9uSWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB7XG4gICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgdmFsdWU6IHJlc3VsdFxuICAgICAgICAgIH07XG4gICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICBfX3R5cGU6IFRyYW5zYWN0aW9uU3RhdHVzLlBST0NFU1NFRCxcbiAgICAgICAgICAgIHJlc3BvbnNlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIGNvbW1pdG1lbnQpO1xuICAgICAgICBjb25zdCBzdWJzY3JpcHRpb25TZXR1cFByb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlU3Vic2NyaXB0aW9uU2V0dXAgPT4ge1xuICAgICAgICAgIGlmIChzaWduYXR1cmVTdWJzY3JpcHRpb25JZCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXNvbHZlU3Vic2NyaXB0aW9uU2V0dXAoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGlzcG9zZVNpZ25hdHVyZVN1YnNjcmlwdGlvblN0YXRlQ2hhbmdlT2JzZXJ2ZXIgPSB0aGlzLl9vblN1YnNjcmlwdGlvblN0YXRlQ2hhbmdlKHNpZ25hdHVyZVN1YnNjcmlwdGlvbklkLCBuZXh0U3RhdGUgPT4ge1xuICAgICAgICAgICAgICBpZiAobmV4dFN0YXRlID09PSAnc3Vic2NyaWJlZCcpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlU3Vic2NyaXB0aW9uU2V0dXAoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICBhd2FpdCBzdWJzY3JpcHRpb25TZXR1cFByb21pc2U7XG4gICAgICAgICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZ2V0U2lnbmF0dXJlU3RhdHVzKHNpZ25hdHVyZSk7XG4gICAgICAgICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICAgICAgICBpZiAocmVzcG9uc2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICB9ID0gcmVzcG9uc2U7XG4gICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbHVlPy5lcnIpIHtcbiAgICAgICAgICAgIHJlamVjdCh2YWx1ZS5lcnIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGNvbW1pdG1lbnQpIHtcbiAgICAgICAgICAgICAgY2FzZSAnY29uZmlybWVkJzpcbiAgICAgICAgICAgICAgY2FzZSAnc2luZ2xlJzpcbiAgICAgICAgICAgICAgY2FzZSAnc2luZ2xlR29zc2lwJzpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBpZiAodmFsdWUuY29uZmlybWF0aW9uU3RhdHVzID09PSAncHJvY2Vzc2VkJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgJ2ZpbmFsaXplZCc6XG4gICAgICAgICAgICAgIGNhc2UgJ21heCc6XG4gICAgICAgICAgICAgIGNhc2UgJ3Jvb3QnOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5jb25maXJtYXRpb25TdGF0dXMgPT09ICdwcm9jZXNzZWQnIHx8IHZhbHVlLmNvbmZpcm1hdGlvblN0YXR1cyA9PT0gJ2NvbmZpcm1lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBleGhhdXN0IGVudW1zIHRvIGVuc3VyZSBmdWxsIGNvdmVyYWdlXG4gICAgICAgICAgICAgIGNhc2UgJ3Byb2Nlc3NlZCc6XG4gICAgICAgICAgICAgIGNhc2UgJ3JlY2VudCc6XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICBfX3R5cGU6IFRyYW5zYWN0aW9uU3RhdHVzLlBST0NFU1NFRCxcbiAgICAgICAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBhYm9ydENvbmZpcm1hdGlvbiA9ICgpID0+IHtcbiAgICAgIGlmIChkaXNwb3NlU2lnbmF0dXJlU3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2VPYnNlcnZlcikge1xuICAgICAgICBkaXNwb3NlU2lnbmF0dXJlU3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2VPYnNlcnZlcigpO1xuICAgICAgICBkaXNwb3NlU2lnbmF0dXJlU3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2VPYnNlcnZlciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmIChzaWduYXR1cmVTdWJzY3JpcHRpb25JZCAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlU2lnbmF0dXJlTGlzdGVuZXIoc2lnbmF0dXJlU3Vic2NyaXB0aW9uSWQpO1xuICAgICAgICBzaWduYXR1cmVTdWJzY3JpcHRpb25JZCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICBhYm9ydENvbmZpcm1hdGlvbixcbiAgICAgIGNvbmZpcm1hdGlvblByb21pc2VcbiAgICB9O1xuICB9XG4gIGFzeW5jIGNvbmZpcm1UcmFuc2FjdGlvblVzaW5nQmxvY2tIZWlnaHRFeGNlZWRhbmNlU3RyYXRlZ3koe1xuICAgIGNvbW1pdG1lbnQsXG4gICAgc3RyYXRlZ3k6IHtcbiAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgbGFzdFZhbGlkQmxvY2tIZWlnaHQsXG4gICAgICBzaWduYXR1cmVcbiAgICB9XG4gIH0pIHtcbiAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgIGNvbnN0IGV4cGlyeVByb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGNvbnN0IGNoZWNrQmxvY2tIZWlnaHQgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgYmxvY2tIZWlnaHQgPSBhd2FpdCB0aGlzLmdldEJsb2NrSGVpZ2h0KGNvbW1pdG1lbnQpO1xuICAgICAgICAgIHJldHVybiBibG9ja0hlaWdodDtcbiAgICAgICAgfSBjYXRjaCAoX2UpIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICBsZXQgY3VycmVudEJsb2NrSGVpZ2h0ID0gYXdhaXQgY2hlY2tCbG9ja0hlaWdodCgpO1xuICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICB3aGlsZSAoY3VycmVudEJsb2NrSGVpZ2h0IDw9IGxhc3RWYWxpZEJsb2NrSGVpZ2h0KSB7XG4gICAgICAgICAgYXdhaXQgc2xlZXAoMTAwMCk7XG4gICAgICAgICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICAgICAgICBjdXJyZW50QmxvY2tIZWlnaHQgPSBhd2FpdCBjaGVja0Jsb2NrSGVpZ2h0KCk7XG4gICAgICAgICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICBfX3R5cGU6IFRyYW5zYWN0aW9uU3RhdHVzLkJMT0NLSEVJR0hUX0VYQ0VFREVEXG4gICAgICAgIH0pO1xuICAgICAgfSkoKTtcbiAgICB9KTtcbiAgICBjb25zdCB7XG4gICAgICBhYm9ydENvbmZpcm1hdGlvbixcbiAgICAgIGNvbmZpcm1hdGlvblByb21pc2VcbiAgICB9ID0gdGhpcy5nZXRUcmFuc2FjdGlvbkNvbmZpcm1hdGlvblByb21pc2Uoe1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIHNpZ25hdHVyZVxuICAgIH0pO1xuICAgIGNvbnN0IGNhbmNlbGxhdGlvblByb21pc2UgPSB0aGlzLmdldENhbmNlbGxhdGlvblByb21pc2UoYWJvcnRTaWduYWwpO1xuICAgIGxldCByZXN1bHQ7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG91dGNvbWUgPSBhd2FpdCBQcm9taXNlLnJhY2UoW2NhbmNlbGxhdGlvblByb21pc2UsIGNvbmZpcm1hdGlvblByb21pc2UsIGV4cGlyeVByb21pc2VdKTtcbiAgICAgIGlmIChvdXRjb21lLl9fdHlwZSA9PT0gVHJhbnNhY3Rpb25TdGF0dXMuUFJPQ0VTU0VEKSB7XG4gICAgICAgIHJlc3VsdCA9IG91dGNvbWUucmVzcG9uc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgVHJhbnNhY3Rpb25FeHBpcmVkQmxvY2toZWlnaHRFeGNlZWRlZEVycm9yKHNpZ25hdHVyZSk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgYWJvcnRDb25maXJtYXRpb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBhc3luYyBjb25maXJtVHJhbnNhY3Rpb25Vc2luZ0R1cmFibGVOb25jZVN0cmF0ZWd5KHtcbiAgICBjb21taXRtZW50LFxuICAgIHN0cmF0ZWd5OiB7XG4gICAgICBhYm9ydFNpZ25hbCxcbiAgICAgIG1pbkNvbnRleHRTbG90LFxuICAgICAgbm9uY2VBY2NvdW50UHVia2V5LFxuICAgICAgbm9uY2VWYWx1ZSxcbiAgICAgIHNpZ25hdHVyZVxuICAgIH1cbiAgfSkge1xuICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgY29uc3QgZXhwaXJ5UHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgbGV0IGN1cnJlbnROb25jZVZhbHVlID0gbm9uY2VWYWx1ZTtcbiAgICAgIGxldCBsYXN0Q2hlY2tlZFNsb3QgPSBudWxsO1xuICAgICAgY29uc3QgZ2V0Q3VycmVudE5vbmNlVmFsdWUgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgIHZhbHVlOiBub25jZUFjY291bnRcbiAgICAgICAgICB9ID0gYXdhaXQgdGhpcy5nZXROb25jZUFuZENvbnRleHQobm9uY2VBY2NvdW50UHVia2V5LCB7XG4gICAgICAgICAgICBjb21taXRtZW50LFxuICAgICAgICAgICAgbWluQ29udGV4dFNsb3RcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBsYXN0Q2hlY2tlZFNsb3QgPSBjb250ZXh0LnNsb3Q7XG4gICAgICAgICAgcmV0dXJuIG5vbmNlQWNjb3VudD8ubm9uY2U7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBJZiBmb3Igd2hhdGV2ZXIgcmVhc29uIHdlIGNhbid0IHJlYWNoL3JlYWQgdGhlIG5vbmNlXG4gICAgICAgICAgLy8gYWNjb3VudCwganVzdCBrZWVwIHVzaW5nIHRoZSBsYXN0LWtub3duIHZhbHVlLlxuICAgICAgICAgIHJldHVybiBjdXJyZW50Tm9uY2VWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgIGN1cnJlbnROb25jZVZhbHVlID0gYXdhaXQgZ2V0Q3VycmVudE5vbmNlVmFsdWUoKTtcbiAgICAgICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICAgICAgd2hpbGUgKHRydWUgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKG5vbmNlVmFsdWUgIT09IGN1cnJlbnROb25jZVZhbHVlKSB7XG4gICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgX190eXBlOiBUcmFuc2FjdGlvblN0YXR1cy5OT05DRV9JTlZBTElELFxuICAgICAgICAgICAgICBzbG90SW5XaGljaE5vbmNlRGlkQWR2YW5jZTogbGFzdENoZWNrZWRTbG90XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXdhaXQgc2xlZXAoMjAwMCk7XG4gICAgICAgICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICAgICAgICBjdXJyZW50Tm9uY2VWYWx1ZSA9IGF3YWl0IGdldEN1cnJlbnROb25jZVZhbHVlKCk7XG4gICAgICAgICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSkoKTtcbiAgICB9KTtcbiAgICBjb25zdCB7XG4gICAgICBhYm9ydENvbmZpcm1hdGlvbixcbiAgICAgIGNvbmZpcm1hdGlvblByb21pc2VcbiAgICB9ID0gdGhpcy5nZXRUcmFuc2FjdGlvbkNvbmZpcm1hdGlvblByb21pc2Uoe1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIHNpZ25hdHVyZVxuICAgIH0pO1xuICAgIGNvbnN0IGNhbmNlbGxhdGlvblByb21pc2UgPSB0aGlzLmdldENhbmNlbGxhdGlvblByb21pc2UoYWJvcnRTaWduYWwpO1xuICAgIGxldCByZXN1bHQ7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG91dGNvbWUgPSBhd2FpdCBQcm9taXNlLnJhY2UoW2NhbmNlbGxhdGlvblByb21pc2UsIGNvbmZpcm1hdGlvblByb21pc2UsIGV4cGlyeVByb21pc2VdKTtcbiAgICAgIGlmIChvdXRjb21lLl9fdHlwZSA9PT0gVHJhbnNhY3Rpb25TdGF0dXMuUFJPQ0VTU0VEKSB7XG4gICAgICAgIHJlc3VsdCA9IG91dGNvbWUucmVzcG9uc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBEb3VibGUgY2hlY2sgdGhhdCB0aGUgdHJhbnNhY3Rpb24gaXMgaW5kZWVkIHVuY29uZmlybWVkLlxuICAgICAgICBsZXQgc2lnbmF0dXJlU3RhdHVzO1xuICAgICAgICB3aGlsZSAodHJ1ZSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgICAgICApIHtcbiAgICAgICAgICBjb25zdCBzdGF0dXMgPSBhd2FpdCB0aGlzLmdldFNpZ25hdHVyZVN0YXR1cyhzaWduYXR1cmUpO1xuICAgICAgICAgIGlmIChzdGF0dXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGF0dXMuY29udGV4dC5zbG90IDwgKG91dGNvbWUuc2xvdEluV2hpY2hOb25jZURpZEFkdmFuY2UgPz8gbWluQ29udGV4dFNsb3QpKSB7XG4gICAgICAgICAgICBhd2FpdCBzbGVlcCg0MDApO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNpZ25hdHVyZVN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2lnbmF0dXJlU3RhdHVzPy52YWx1ZSkge1xuICAgICAgICAgIGNvbnN0IGNvbW1pdG1lbnRGb3JTdGF0dXMgPSBjb21taXRtZW50IHx8ICdmaW5hbGl6ZWQnO1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGNvbmZpcm1hdGlvblN0YXR1c1xuICAgICAgICAgIH0gPSBzaWduYXR1cmVTdGF0dXMudmFsdWU7XG4gICAgICAgICAgc3dpdGNoIChjb21taXRtZW50Rm9yU3RhdHVzKSB7XG4gICAgICAgICAgICBjYXNlICdwcm9jZXNzZWQnOlxuICAgICAgICAgICAgY2FzZSAncmVjZW50JzpcbiAgICAgICAgICAgICAgaWYgKGNvbmZpcm1hdGlvblN0YXR1cyAhPT0gJ3Byb2Nlc3NlZCcgJiYgY29uZmlybWF0aW9uU3RhdHVzICE9PSAnY29uZmlybWVkJyAmJiBjb25maXJtYXRpb25TdGF0dXMgIT09ICdmaW5hbGl6ZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRyYW5zYWN0aW9uRXhwaXJlZE5vbmNlSW52YWxpZEVycm9yKHNpZ25hdHVyZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjb25maXJtZWQnOlxuICAgICAgICAgICAgY2FzZSAnc2luZ2xlJzpcbiAgICAgICAgICAgIGNhc2UgJ3NpbmdsZUdvc3NpcCc6XG4gICAgICAgICAgICAgIGlmIChjb25maXJtYXRpb25TdGF0dXMgIT09ICdjb25maXJtZWQnICYmIGNvbmZpcm1hdGlvblN0YXR1cyAhPT0gJ2ZpbmFsaXplZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHJhbnNhY3Rpb25FeHBpcmVkTm9uY2VJbnZhbGlkRXJyb3Ioc2lnbmF0dXJlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2ZpbmFsaXplZCc6XG4gICAgICAgICAgICBjYXNlICdtYXgnOlxuICAgICAgICAgICAgY2FzZSAncm9vdCc6XG4gICAgICAgICAgICAgIGlmIChjb25maXJtYXRpb25TdGF0dXMgIT09ICdmaW5hbGl6ZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRyYW5zYWN0aW9uRXhwaXJlZE5vbmNlSW52YWxpZEVycm9yKHNpZ25hdHVyZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAvLyBFeGhhdXN0aXZlIHN3aXRjaC5cbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgICAgICAgICAgICAoXyA9PiB7fSkoY29tbWl0bWVudEZvclN0YXR1cyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgICAgIGNvbnRleHQ6IHNpZ25hdHVyZVN0YXR1cy5jb250ZXh0LFxuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgZXJyOiBzaWduYXR1cmVTdGF0dXMudmFsdWUuZXJyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHJhbnNhY3Rpb25FeHBpcmVkTm9uY2VJbnZhbGlkRXJyb3Ioc2lnbmF0dXJlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBkb25lID0gdHJ1ZTtcbiAgICAgIGFib3J0Q29uZmlybWF0aW9uKCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgYXN5bmMgY29uZmlybVRyYW5zYWN0aW9uVXNpbmdMZWdhY3lUaW1lb3V0U3RyYXRlZ3koe1xuICAgIGNvbW1pdG1lbnQsXG4gICAgc2lnbmF0dXJlXG4gIH0pIHtcbiAgICBsZXQgdGltZW91dElkO1xuICAgIGNvbnN0IGV4cGlyeVByb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGxldCB0aW1lb3V0TXMgPSB0aGlzLl9jb25maXJtVHJhbnNhY3Rpb25Jbml0aWFsVGltZW91dCB8fCA2MCAqIDEwMDA7XG4gICAgICBzd2l0Y2ggKGNvbW1pdG1lbnQpIHtcbiAgICAgICAgY2FzZSAncHJvY2Vzc2VkJzpcbiAgICAgICAgY2FzZSAncmVjZW50JzpcbiAgICAgICAgY2FzZSAnc2luZ2xlJzpcbiAgICAgICAgY2FzZSAnY29uZmlybWVkJzpcbiAgICAgICAgY2FzZSAnc2luZ2xlR29zc2lwJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aW1lb3V0TXMgPSB0aGlzLl9jb25maXJtVHJhbnNhY3Rpb25Jbml0aWFsVGltZW91dCB8fCAzMCAqIDEwMDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHJlc29sdmUoe1xuICAgICAgICBfX3R5cGU6IFRyYW5zYWN0aW9uU3RhdHVzLlRJTUVEX09VVCxcbiAgICAgICAgdGltZW91dE1zXG4gICAgICB9KSwgdGltZW91dE1zKTtcbiAgICB9KTtcbiAgICBjb25zdCB7XG4gICAgICBhYm9ydENvbmZpcm1hdGlvbixcbiAgICAgIGNvbmZpcm1hdGlvblByb21pc2VcbiAgICB9ID0gdGhpcy5nZXRUcmFuc2FjdGlvbkNvbmZpcm1hdGlvblByb21pc2Uoe1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIHNpZ25hdHVyZVxuICAgIH0pO1xuICAgIGxldCByZXN1bHQ7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG91dGNvbWUgPSBhd2FpdCBQcm9taXNlLnJhY2UoW2NvbmZpcm1hdGlvblByb21pc2UsIGV4cGlyeVByb21pc2VdKTtcbiAgICAgIGlmIChvdXRjb21lLl9fdHlwZSA9PT0gVHJhbnNhY3Rpb25TdGF0dXMuUFJPQ0VTU0VEKSB7XG4gICAgICAgIHJlc3VsdCA9IG91dGNvbWUucmVzcG9uc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgVHJhbnNhY3Rpb25FeHBpcmVkVGltZW91dEVycm9yKHNpZ25hdHVyZSwgb3V0Y29tZS50aW1lb3V0TXMgLyAxMDAwKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICBhYm9ydENvbmZpcm1hdGlvbigpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbGlzdCBvZiBub2RlcyB0aGF0IGFyZSBjdXJyZW50bHkgcGFydGljaXBhdGluZyBpbiB0aGUgY2x1c3RlclxuICAgKi9cbiAgYXN5bmMgZ2V0Q2x1c3Rlck5vZGVzKCkge1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldENsdXN0ZXJOb2RlcycsIFtdKTtcbiAgICBjb25zdCByZXMgPSBzdXBlcnN0cnVjdC5jcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0KHN1cGVyc3RydWN0LmFycmF5KENvbnRhY3RJbmZvUmVzdWx0KSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGNsdXN0ZXIgbm9kZXMnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBsaXN0IG9mIG5vZGVzIHRoYXQgYXJlIGN1cnJlbnRseSBwYXJ0aWNpcGF0aW5nIGluIHRoZSBjbHVzdGVyXG4gICAqL1xuICBhc3luYyBnZXRWb3RlQWNjb3VudHMoY29tbWl0bWVudCkge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW10sIGNvbW1pdG1lbnQpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFZvdGVBY2NvdW50cycsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IHN1cGVyc3RydWN0LmNyZWF0ZSh1bnNhZmVSZXMsIEdldFZvdGVBY2NvdW50cyk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgdm90ZSBhY2NvdW50cycpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgY3VycmVudCBzbG90IHRoYXQgdGhlIG5vZGUgaXMgcHJvY2Vzc2luZ1xuICAgKi9cbiAgYXN5bmMgZ2V0U2xvdChjb21taXRtZW50T3JDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW10sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCAvKiBlbmNvZGluZyAqLywgY29uZmlnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRTbG90JywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gc3VwZXJzdHJ1Y3QuY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdChzdXBlcnN0cnVjdC5udW1iZXIoKSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHNsb3QnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGN1cnJlbnQgc2xvdCBsZWFkZXIgb2YgdGhlIGNsdXN0ZXJcbiAgICovXG4gIGFzeW5jIGdldFNsb3RMZWFkZXIoY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtdLCBjb21taXRtZW50LCB1bmRlZmluZWQgLyogZW5jb2RpbmcgKi8sIGNvbmZpZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0U2xvdExlYWRlcicsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IHN1cGVyc3RydWN0LmNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHQoc3VwZXJzdHJ1Y3Quc3RyaW5nKCkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBzbG90IGxlYWRlcicpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBgbGltaXRgIG51bWJlciBvZiBzbG90IGxlYWRlcnMgc3RhcnRpbmcgZnJvbSBgc3RhcnRTbG90YFxuICAgKlxuICAgKiBAcGFyYW0gc3RhcnRTbG90IGZldGNoIHNsb3QgbGVhZGVycyBzdGFydGluZyBmcm9tIHRoaXMgc2xvdFxuICAgKiBAcGFyYW0gbGltaXQgbnVtYmVyIG9mIHNsb3QgbGVhZGVycyB0byByZXR1cm5cbiAgICovXG4gIGFzeW5jIGdldFNsb3RMZWFkZXJzKHN0YXJ0U2xvdCwgbGltaXQpIHtcbiAgICBjb25zdCBhcmdzID0gW3N0YXJ0U2xvdCwgbGltaXRdO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFNsb3RMZWFkZXJzJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gc3VwZXJzdHJ1Y3QuY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdChzdXBlcnN0cnVjdC5hcnJheShQdWJsaWNLZXlGcm9tU3RyaW5nKSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHNsb3QgbGVhZGVycycpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgY3VycmVudCBzdGF0dXMgb2YgYSBzaWduYXR1cmVcbiAgICovXG4gIGFzeW5jIGdldFNpZ25hdHVyZVN0YXR1cyhzaWduYXR1cmUsIGNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRleHQsXG4gICAgICB2YWx1ZTogdmFsdWVzXG4gICAgfSA9IGF3YWl0IHRoaXMuZ2V0U2lnbmF0dXJlU3RhdHVzZXMoW3NpZ25hdHVyZV0sIGNvbmZpZyk7XG4gICAgYXNzZXJ0KHZhbHVlcy5sZW5ndGggPT09IDEpO1xuICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICBjb250ZXh0LFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBjdXJyZW50IHN0YXR1c2VzIG9mIGEgYmF0Y2ggb2Ygc2lnbmF0dXJlc1xuICAgKi9cbiAgYXN5bmMgZ2V0U2lnbmF0dXJlU3RhdHVzZXMoc2lnbmF0dXJlcywgY29uZmlnKSB7XG4gICAgY29uc3QgcGFyYW1zID0gW3NpZ25hdHVyZXNdO1xuICAgIGlmIChjb25maWcpIHtcbiAgICAgIHBhcmFtcy5wdXNoKGNvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFNpZ25hdHVyZVN0YXR1c2VzJywgcGFyYW1zKTtcbiAgICBjb25zdCByZXMgPSBzdXBlcnN0cnVjdC5jcmVhdGUodW5zYWZlUmVzLCBHZXRTaWduYXR1cmVTdGF0dXNlc1JwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgc2lnbmF0dXJlIHN0YXR1cycpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgY3VycmVudCB0cmFuc2FjdGlvbiBjb3VudCBvZiB0aGUgY2x1c3RlclxuICAgKi9cbiAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25Db3VudChjb21taXRtZW50T3JDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW10sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCAvKiBlbmNvZGluZyAqLywgY29uZmlnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRUcmFuc2FjdGlvbkNvdW50JywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gc3VwZXJzdHJ1Y3QuY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdChzdXBlcnN0cnVjdC5udW1iZXIoKSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHRyYW5zYWN0aW9uIGNvdW50Jyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBjdXJyZW50IHRvdGFsIGN1cnJlbmN5IHN1cHBseSBvZiB0aGUgY2x1c3RlciBpbiBsYW1wb3J0c1xuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIHYxLjIuOC4gUGxlYXNlIHVzZSB7QGxpbmsgZ2V0U3VwcGx5fSBpbnN0ZWFkLlxuICAgKi9cbiAgYXN5bmMgZ2V0VG90YWxTdXBwbHkoY29tbWl0bWVudCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuZ2V0U3VwcGx5KHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBleGNsdWRlTm9uQ2lyY3VsYXRpbmdBY2NvdW50c0xpc3Q6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0LnZhbHVlLnRvdGFsO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBjbHVzdGVyIEluZmxhdGlvbkdvdmVybm9yIHBhcmFtZXRlcnNcbiAgICovXG4gIGFzeW5jIGdldEluZmxhdGlvbkdvdmVybm9yKGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtdLCBjb21taXRtZW50KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRJbmZsYXRpb25Hb3Zlcm5vcicsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IHN1cGVyc3RydWN0LmNyZWF0ZSh1bnNhZmVSZXMsIEdldEluZmxhdGlvbkdvdmVybm9yUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBpbmZsYXRpb24nKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGluZmxhdGlvbiByZXdhcmQgZm9yIGEgbGlzdCBvZiBhZGRyZXNzZXMgZm9yIGFuIGVwb2NoXG4gICAqL1xuICBhc3luYyBnZXRJbmZsYXRpb25SZXdhcmQoYWRkcmVzc2VzLCBlcG9jaCwgY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFthZGRyZXNzZXMubWFwKHB1YmtleSA9PiBwdWJrZXkudG9CYXNlNTgoKSldLCBjb21taXRtZW50LCB1bmRlZmluZWQgLyogZW5jb2RpbmcgKi8sIHtcbiAgICAgIC4uLmNvbmZpZyxcbiAgICAgIGVwb2NoOiBlcG9jaCAhPSBudWxsID8gZXBvY2ggOiBjb25maWc/LmVwb2NoXG4gICAgfSk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0SW5mbGF0aW9uUmV3YXJkJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gc3VwZXJzdHJ1Y3QuY3JlYXRlKHVuc2FmZVJlcywgR2V0SW5mbGF0aW9uUmV3YXJkUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBpbmZsYXRpb24gcmV3YXJkJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBzcGVjaWZpYyBpbmZsYXRpb24gdmFsdWVzIGZvciB0aGUgY3VycmVudCBlcG9jaFxuICAgKi9cbiAgYXN5bmMgZ2V0SW5mbGF0aW9uUmF0ZSgpIHtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRJbmZsYXRpb25SYXRlJywgW10pO1xuICAgIGNvbnN0IHJlcyA9IHN1cGVyc3RydWN0LmNyZWF0ZSh1bnNhZmVSZXMsIEdldEluZmxhdGlvblJhdGVScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGluZmxhdGlvbiByYXRlJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBFcG9jaCBJbmZvIHBhcmFtZXRlcnNcbiAgICovXG4gIGFzeW5jIGdldEVwb2NoSW5mbyhjb21taXRtZW50T3JDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW10sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCAvKiBlbmNvZGluZyAqLywgY29uZmlnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRFcG9jaEluZm8nLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBzdXBlcnN0cnVjdC5jcmVhdGUodW5zYWZlUmVzLCBHZXRFcG9jaEluZm9ScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGVwb2NoIGluZm8nKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIEVwb2NoIFNjaGVkdWxlIHBhcmFtZXRlcnNcbiAgICovXG4gIGFzeW5jIGdldEVwb2NoU2NoZWR1bGUoKSB7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0RXBvY2hTY2hlZHVsZScsIFtdKTtcbiAgICBjb25zdCByZXMgPSBzdXBlcnN0cnVjdC5jcmVhdGUodW5zYWZlUmVzLCBHZXRFcG9jaFNjaGVkdWxlUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBlcG9jaCBzY2hlZHVsZScpO1xuICAgIH1cbiAgICBjb25zdCBlcG9jaFNjaGVkdWxlID0gcmVzLnJlc3VsdDtcbiAgICByZXR1cm4gbmV3IEVwb2NoU2NoZWR1bGUoZXBvY2hTY2hlZHVsZS5zbG90c1BlckVwb2NoLCBlcG9jaFNjaGVkdWxlLmxlYWRlclNjaGVkdWxlU2xvdE9mZnNldCwgZXBvY2hTY2hlZHVsZS53YXJtdXAsIGVwb2NoU2NoZWR1bGUuZmlyc3ROb3JtYWxFcG9jaCwgZXBvY2hTY2hlZHVsZS5maXJzdE5vcm1hbFNsb3QpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBsZWFkZXIgc2NoZWR1bGUgZm9yIHRoZSBjdXJyZW50IGVwb2NoXG4gICAqIEByZXR1cm4ge1Byb21pc2U8UnBjUmVzcG9uc2VBbmRDb250ZXh0PExlYWRlclNjaGVkdWxlPj59XG4gICAqL1xuICBhc3luYyBnZXRMZWFkZXJTY2hlZHVsZSgpIHtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRMZWFkZXJTY2hlZHVsZScsIFtdKTtcbiAgICBjb25zdCByZXMgPSBzdXBlcnN0cnVjdC5jcmVhdGUodW5zYWZlUmVzLCBHZXRMZWFkZXJTY2hlZHVsZVJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgbGVhZGVyIHNjaGVkdWxlJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBtaW5pbXVtIGJhbGFuY2UgbmVlZGVkIHRvIGV4ZW1wdCBhbiBhY2NvdW50IG9mIGBkYXRhTGVuZ3RoYFxuICAgKiBzaXplIGZyb20gcmVudFxuICAgKi9cbiAgYXN5bmMgZ2V0TWluaW11bUJhbGFuY2VGb3JSZW50RXhlbXB0aW9uKGRhdGFMZW5ndGgsIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtkYXRhTGVuZ3RoXSwgY29tbWl0bWVudCk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0TWluaW11bUJhbGFuY2VGb3JSZW50RXhlbXB0aW9uJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gc3VwZXJzdHJ1Y3QuY3JlYXRlKHVuc2FmZVJlcywgR2V0TWluaW11bUJhbGFuY2VGb3JSZW50RXhlbXB0aW9uUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIGNvbnNvbGUud2FybignVW5hYmxlIHRvIGZldGNoIG1pbmltdW0gYmFsYW5jZSBmb3IgcmVudCBleGVtcHRpb24nKTtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhIHJlY2VudCBibG9ja2hhc2ggZnJvbSB0aGUgY2x1c3RlciwgcmV0dXJuIHdpdGggY29udGV4dFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPFJwY1Jlc3BvbnNlQW5kQ29udGV4dDx7YmxvY2toYXNoOiBCbG9ja2hhc2gsIGZlZUNhbGN1bGF0b3I6IEZlZUNhbGN1bGF0b3J9Pj59XG4gICAqXG4gICAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgU29sYW5hIHYxLjguMC4gUGxlYXNlIHVzZSB7QGxpbmsgZ2V0TGF0ZXN0QmxvY2toYXNofSBpbnN0ZWFkLlxuICAgKi9cbiAgYXN5bmMgZ2V0UmVjZW50QmxvY2toYXNoQW5kQ29udGV4dChjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbXSwgY29tbWl0bWVudCk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0UmVjZW50QmxvY2toYXNoJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gc3VwZXJzdHJ1Y3QuY3JlYXRlKHVuc2FmZVJlcywgR2V0UmVjZW50QmxvY2toYXNoQW5kQ29udGV4dFJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgcmVjZW50IGJsb2NraGFzaCcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCByZWNlbnQgcGVyZm9ybWFuY2Ugc2FtcGxlc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5PFBlcmZTYW1wbGU+Pn1cbiAgICovXG4gIGFzeW5jIGdldFJlY2VudFBlcmZvcm1hbmNlU2FtcGxlcyhsaW1pdCkge1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFJlY2VudFBlcmZvcm1hbmNlU2FtcGxlcycsIGxpbWl0ID8gW2xpbWl0XSA6IFtdKTtcbiAgICBjb25zdCByZXMgPSBzdXBlcnN0cnVjdC5jcmVhdGUodW5zYWZlUmVzLCBHZXRSZWNlbnRQZXJmb3JtYW5jZVNhbXBsZXNScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHJlY2VudCBwZXJmb3JtYW5jZSBzYW1wbGVzJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBmZWUgY2FsY3VsYXRvciBmb3IgYSByZWNlbnQgYmxvY2toYXNoIGZyb20gdGhlIGNsdXN0ZXIsIHJldHVybiB3aXRoIGNvbnRleHRcbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBTb2xhbmEgdjEuOC4wLiBQbGVhc2UgdXNlIHtAbGluayBnZXRGZWVGb3JNZXNzYWdlfSBpbnN0ZWFkLlxuICAgKi9cbiAgYXN5bmMgZ2V0RmVlQ2FsY3VsYXRvckZvckJsb2NraGFzaChibG9ja2hhc2gsIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtibG9ja2hhc2hdLCBjb21taXRtZW50KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRGZWVDYWxjdWxhdG9yRm9yQmxvY2toYXNoJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gc3VwZXJzdHJ1Y3QuY3JlYXRlKHVuc2FmZVJlcywgR2V0RmVlQ2FsY3VsYXRvclJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgZmVlIGNhbGN1bGF0b3InKTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgY29udGV4dCxcbiAgICAgIHZhbHVlXG4gICAgfSA9IHJlcy5yZXN1bHQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRleHQsXG4gICAgICB2YWx1ZTogdmFsdWUgIT09IG51bGwgPyB2YWx1ZS5mZWVDYWxjdWxhdG9yIDogbnVsbFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGZlZSBmb3IgYSBtZXNzYWdlIGZyb20gdGhlIGNsdXN0ZXIsIHJldHVybiB3aXRoIGNvbnRleHRcbiAgICovXG4gIGFzeW5jIGdldEZlZUZvck1lc3NhZ2UobWVzc2FnZSwgY29tbWl0bWVudCkge1xuICAgIGNvbnN0IHdpcmVNZXNzYWdlID0gdG9CdWZmZXIobWVzc2FnZS5zZXJpYWxpemUoKSkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW3dpcmVNZXNzYWdlXSwgY29tbWl0bWVudCk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0RmVlRm9yTWVzc2FnZScsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IHN1cGVyc3RydWN0LmNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KHN1cGVyc3RydWN0Lm51bGxhYmxlKHN1cGVyc3RydWN0Lm51bWJlcigpKSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGZlZSBmb3IgbWVzc2FnZScpO1xuICAgIH1cbiAgICBpZiAocmVzLnJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGJsb2NraGFzaCcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhIGxpc3Qgb2YgcHJpb3JpdGl6YXRpb24gZmVlcyBmcm9tIHJlY2VudCBibG9ja3MuXG4gICAqL1xuICBhc3luYyBnZXRSZWNlbnRQcmlvcml0aXphdGlvbkZlZXMoY29uZmlnKSB7XG4gICAgY29uc3QgYWNjb3VudHMgPSBjb25maWc/LmxvY2tlZFdyaXRhYmxlQWNjb3VudHM/Lm1hcChrZXkgPT4ga2V5LnRvQmFzZTU4KCkpO1xuICAgIGNvbnN0IGFyZ3MgPSBhY2NvdW50cz8ubGVuZ3RoID8gW2FjY291bnRzXSA6IFtdO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFJlY2VudFByaW9yaXRpemF0aW9uRmVlcycsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IHN1cGVyc3RydWN0LmNyZWF0ZSh1bnNhZmVSZXMsIEdldFJlY2VudFByaW9yaXRpemF0aW9uRmVlc1JwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgcmVjZW50IHByaW9yaXRpemF0aW9uIGZlZXMnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cbiAgLyoqXG4gICAqIEZldGNoIGEgcmVjZW50IGJsb2NraGFzaCBmcm9tIHRoZSBjbHVzdGVyXG4gICAqIEByZXR1cm4ge1Byb21pc2U8e2Jsb2NraGFzaDogQmxvY2toYXNoLCBmZWVDYWxjdWxhdG9yOiBGZWVDYWxjdWxhdG9yfT59XG4gICAqXG4gICAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgU29sYW5hIHYxLjguMC4gUGxlYXNlIHVzZSB7QGxpbmsgZ2V0TGF0ZXN0QmxvY2toYXNofSBpbnN0ZWFkLlxuICAgKi9cbiAgYXN5bmMgZ2V0UmVjZW50QmxvY2toYXNoKGNvbW1pdG1lbnQpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5nZXRSZWNlbnRCbG9ja2hhc2hBbmRDb250ZXh0KGNvbW1pdG1lbnQpO1xuICAgICAgcmV0dXJuIHJlcy52YWx1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZhaWxlZCB0byBnZXQgcmVjZW50IGJsb2NraGFzaDogJyArIGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgbGF0ZXN0IGJsb2NraGFzaCBmcm9tIHRoZSBjbHVzdGVyXG4gICAqIEByZXR1cm4ge1Byb21pc2U8QmxvY2toYXNoV2l0aEV4cGlyeUJsb2NrSGVpZ2h0Pn1cbiAgICovXG4gIGFzeW5jIGdldExhdGVzdEJsb2NraGFzaChjb21taXRtZW50T3JDb25maWcpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5nZXRMYXRlc3RCbG9ja2hhc2hBbmRDb250ZXh0KGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgICByZXR1cm4gcmVzLnZhbHVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZmFpbGVkIHRvIGdldCByZWNlbnQgYmxvY2toYXNoOiAnICsgZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBsYXRlc3QgYmxvY2toYXNoIGZyb20gdGhlIGNsdXN0ZXJcbiAgICogQHJldHVybiB7UHJvbWlzZTxCbG9ja2hhc2hXaXRoRXhwaXJ5QmxvY2tIZWlnaHQ+fVxuICAgKi9cbiAgYXN5bmMgZ2V0TGF0ZXN0QmxvY2toYXNoQW5kQ29udGV4dChjb21taXRtZW50T3JDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW10sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCAvKiBlbmNvZGluZyAqLywgY29uZmlnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRMYXRlc3RCbG9ja2hhc2gnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBzdXBlcnN0cnVjdC5jcmVhdGUodW5zYWZlUmVzLCBHZXRMYXRlc3RCbG9ja2hhc2hScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGxhdGVzdCBibG9ja2hhc2gnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIGEgYmxvY2toYXNoIGlzIHN0aWxsIHZhbGlkIG9yIG5vdFxuICAgKi9cbiAgYXN5bmMgaXNCbG9ja2hhc2hWYWxpZChibG9ja2hhc2gsIHJhd0NvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKHJhd0NvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbYmxvY2toYXNoXSwgY29tbWl0bWVudCwgdW5kZWZpbmVkIC8qIGVuY29kaW5nICovLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2lzQmxvY2toYXNoVmFsaWQnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBzdXBlcnN0cnVjdC5jcmVhdGUodW5zYWZlUmVzLCBJc0Jsb2NraGFzaFZhbGlkUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGRldGVybWluZSBpZiB0aGUgYmxvY2toYXNoIGAnICsgYmxvY2toYXNoICsgJ2BpcyB2YWxpZCcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgbm9kZSB2ZXJzaW9uXG4gICAqL1xuICBhc3luYyBnZXRWZXJzaW9uKCkge1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFZlcnNpb24nLCBbXSk7XG4gICAgY29uc3QgcmVzID0gc3VwZXJzdHJ1Y3QuY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdChWZXJzaW9uUmVzdWx0KSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgdmVyc2lvbicpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgZ2VuZXNpcyBoYXNoXG4gICAqL1xuICBhc3luYyBnZXRHZW5lc2lzSGFzaCgpIHtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRHZW5lc2lzSGFzaCcsIFtdKTtcbiAgICBjb25zdCByZXMgPSBzdXBlcnN0cnVjdC5jcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0KHN1cGVyc3RydWN0LnN0cmluZygpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgZ2VuZXNpcyBoYXNoJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGEgcHJvY2Vzc2VkIGJsb2NrIGZyb20gdGhlIGNsdXN0ZXIuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIEluc3RlYWQsIGNhbGwgYGdldEJsb2NrYCB1c2luZyBhIGBHZXRWZXJzaW9uZWRCbG9ja0NvbmZpZ2AgYnlcbiAgICogc2V0dGluZyB0aGUgYG1heFN1cHBvcnRlZFRyYW5zYWN0aW9uVmVyc2lvbmAgcHJvcGVydHkuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBJbnN0ZWFkLCBjYWxsIGBnZXRCbG9ja2AgdXNpbmcgYSBgR2V0VmVyc2lvbmVkQmxvY2tDb25maWdgIGJ5XG4gICAqIHNldHRpbmcgdGhlIGBtYXhTdXBwb3J0ZWRUcmFuc2FjdGlvblZlcnNpb25gIHByb3BlcnR5LlxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBJbnN0ZWFkLCBjYWxsIGBnZXRCbG9ja2AgdXNpbmcgYSBgR2V0VmVyc2lvbmVkQmxvY2tDb25maWdgIGJ5XG4gICAqIHNldHRpbmcgdGhlIGBtYXhTdXBwb3J0ZWRUcmFuc2FjdGlvblZlcnNpb25gIHByb3BlcnR5LlxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuXG4gIC8qKlxuICAgKiBGZXRjaCBhIHByb2Nlc3NlZCBibG9jayBmcm9tIHRoZSBjbHVzdGVyLlxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG5cbiAgLyoqXG4gICAqIEZldGNoIGEgcHJvY2Vzc2VkIGJsb2NrIGZyb20gdGhlIGNsdXN0ZXIuXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG4gIGFzeW5jIGdldEJsb2NrKHNsb3QsIHJhd0NvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKHJhd0NvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoW3Nsb3RdLCBjb21taXRtZW50LCB1bmRlZmluZWQgLyogZW5jb2RpbmcgKi8sIGNvbmZpZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0QmxvY2snLCBhcmdzKTtcbiAgICB0cnkge1xuICAgICAgc3dpdGNoIChjb25maWc/LnRyYW5zYWN0aW9uRGV0YWlscykge1xuICAgICAgICBjYXNlICdhY2NvdW50cyc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gc3VwZXJzdHJ1Y3QuY3JlYXRlKHVuc2FmZVJlcywgR2V0QWNjb3VudHNNb2RlQmxvY2tScGNSZXN1bHQpO1xuICAgICAgICAgICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICAgICAgICAgIHRocm93IHJlcy5lcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXMucmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnbm9uZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gc3VwZXJzdHJ1Y3QuY3JlYXRlKHVuc2FmZVJlcywgR2V0Tm9uZU1vZGVCbG9ja1JwY1Jlc3VsdCk7XG4gICAgICAgICAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgICAgICAgICAgdGhyb3cgcmVzLmVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IHN1cGVyc3RydWN0LmNyZWF0ZSh1bnNhZmVSZXMsIEdldEJsb2NrUnBjUmVzdWx0KTtcbiAgICAgICAgICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgICAgICAgICB0aHJvdyByZXMuZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIHJlc3VsdFxuICAgICAgICAgICAgfSA9IHJlcztcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQgPyB7XG4gICAgICAgICAgICAgIC4uLnJlc3VsdCxcbiAgICAgICAgICAgICAgdHJhbnNhY3Rpb25zOiByZXN1bHQudHJhbnNhY3Rpb25zLm1hcCgoe1xuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgICAgIG1ldGEsXG4gICAgICAgICAgICAgICAgdmVyc2lvblxuICAgICAgICAgICAgICB9KSA9PiAoe1xuICAgICAgICAgICAgICAgIG1ldGEsXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IHtcbiAgICAgICAgICAgICAgICAgIC4uLnRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogdmVyc2lvbmVkTWVzc2FnZUZyb21SZXNwb25zZSh2ZXJzaW9uLCB0cmFuc2FjdGlvbi5tZXNzYWdlKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdmVyc2lvblxuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIH0gOiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKGUsICdmYWlsZWQgdG8gZ2V0IGNvbmZpcm1lZCBibG9jaycpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBwYXJzZWQgdHJhbnNhY3Rpb24gZGV0YWlscyBmb3IgYSBjb25maXJtZWQgb3IgZmluYWxpemVkIGJsb2NrXG4gICAqL1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuICBhc3luYyBnZXRQYXJzZWRCbG9jayhzbG90LCByYXdDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhyYXdDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKFtzbG90XSwgY29tbWl0bWVudCwgJ2pzb25QYXJzZWQnLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEJsb2NrJywgYXJncyk7XG4gICAgdHJ5IHtcbiAgICAgIHN3aXRjaCAoY29uZmlnPy50cmFuc2FjdGlvbkRldGFpbHMpIHtcbiAgICAgICAgY2FzZSAnYWNjb3VudHMnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IHN1cGVyc3RydWN0LmNyZWF0ZSh1bnNhZmVSZXMsIEdldFBhcnNlZEFjY291bnRzTW9kZUJsb2NrUnBjUmVzdWx0KTtcbiAgICAgICAgICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgICAgICAgICB0aHJvdyByZXMuZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ25vbmUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IHN1cGVyc3RydWN0LmNyZWF0ZSh1bnNhZmVSZXMsIEdldFBhcnNlZE5vbmVNb2RlQmxvY2tScGNSZXN1bHQpO1xuICAgICAgICAgICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICAgICAgICAgIHRocm93IHJlcy5lcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXMucmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBzdXBlcnN0cnVjdC5jcmVhdGUodW5zYWZlUmVzLCBHZXRQYXJzZWRCbG9ja1JwY1Jlc3VsdCk7XG4gICAgICAgICAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgICAgICAgICAgdGhyb3cgcmVzLmVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IoZSwgJ2ZhaWxlZCB0byBnZXQgYmxvY2snKTtcbiAgICB9XG4gIH1cbiAgLypcbiAgICogUmV0dXJucyByZWNlbnQgYmxvY2sgcHJvZHVjdGlvbiBpbmZvcm1hdGlvbiBmcm9tIHRoZSBjdXJyZW50IG9yIHByZXZpb3VzIGVwb2NoXG4gICAqL1xuICBhc3luYyBnZXRCbG9ja1Byb2R1Y3Rpb24oY29uZmlnT3JDb21taXRtZW50KSB7XG4gICAgbGV0IGV4dHJhO1xuICAgIGxldCBjb21taXRtZW50O1xuICAgIGlmICh0eXBlb2YgY29uZmlnT3JDb21taXRtZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgY29tbWl0bWVudCA9IGNvbmZpZ09yQ29tbWl0bWVudDtcbiAgICB9IGVsc2UgaWYgKGNvbmZpZ09yQ29tbWl0bWVudCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjb21taXRtZW50OiBjLFxuICAgICAgICAuLi5yZXN0XG4gICAgICB9ID0gY29uZmlnT3JDb21taXRtZW50O1xuICAgICAgY29tbWl0bWVudCA9IGM7XG4gICAgICBleHRyYSA9IHJlc3Q7XG4gICAgfVxuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW10sIGNvbW1pdG1lbnQsICdiYXNlNjQnLCBleHRyYSk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0QmxvY2tQcm9kdWN0aW9uJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gc3VwZXJzdHJ1Y3QuY3JlYXRlKHVuc2FmZVJlcywgQmxvY2tQcm9kdWN0aW9uUmVzcG9uc2VTdHJ1Y3QpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGJsb2NrIHByb2R1Y3Rpb24gaW5mb3JtYXRpb24nKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYSBjb25maXJtZWQgb3IgZmluYWxpemVkIHRyYW5zYWN0aW9uIGZyb20gdGhlIGNsdXN0ZXIuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIEluc3RlYWQsIGNhbGwgYGdldFRyYW5zYWN0aW9uYCB1c2luZyBhXG4gICAqIGBHZXRWZXJzaW9uZWRUcmFuc2FjdGlvbkNvbmZpZ2AgYnkgc2V0dGluZyB0aGVcbiAgICogYG1heFN1cHBvcnRlZFRyYW5zYWN0aW9uVmVyc2lvbmAgcHJvcGVydHkuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBGZXRjaCBhIGNvbmZpcm1lZCBvciBmaW5hbGl6ZWQgdHJhbnNhY3Rpb24gZnJvbSB0aGUgY2x1c3Rlci5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcblxuICAvKipcbiAgICogRmV0Y2ggYSBjb25maXJtZWQgb3IgZmluYWxpemVkIHRyYW5zYWN0aW9uIGZyb20gdGhlIGNsdXN0ZXIuXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG4gIGFzeW5jIGdldFRyYW5zYWN0aW9uKHNpZ25hdHVyZSwgcmF3Q29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcocmF3Q29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChbc2lnbmF0dXJlXSwgY29tbWl0bWVudCwgdW5kZWZpbmVkIC8qIGVuY29kaW5nICovLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFRyYW5zYWN0aW9uJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gc3VwZXJzdHJ1Y3QuY3JlYXRlKHVuc2FmZVJlcywgR2V0VHJhbnNhY3Rpb25ScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHRyYW5zYWN0aW9uJyk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHJlcy5yZXN1bHQ7XG4gICAgaWYgKCFyZXN1bHQpIHJldHVybiByZXN1bHQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnJlc3VsdCxcbiAgICAgIHRyYW5zYWN0aW9uOiB7XG4gICAgICAgIC4uLnJlc3VsdC50cmFuc2FjdGlvbixcbiAgICAgICAgbWVzc2FnZTogdmVyc2lvbmVkTWVzc2FnZUZyb21SZXNwb25zZShyZXN1bHQudmVyc2lvbiwgcmVzdWx0LnRyYW5zYWN0aW9uLm1lc3NhZ2UpXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBwYXJzZWQgdHJhbnNhY3Rpb24gZGV0YWlscyBmb3IgYSBjb25maXJtZWQgb3IgZmluYWxpemVkIHRyYW5zYWN0aW9uXG4gICAqL1xuICBhc3luYyBnZXRQYXJzZWRUcmFuc2FjdGlvbihzaWduYXR1cmUsIGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoW3NpZ25hdHVyZV0sIGNvbW1pdG1lbnQsICdqc29uUGFyc2VkJywgY29uZmlnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRUcmFuc2FjdGlvbicsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IHN1cGVyc3RydWN0LmNyZWF0ZSh1bnNhZmVSZXMsIEdldFBhcnNlZFRyYW5zYWN0aW9uUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCB0cmFuc2FjdGlvbicpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBwYXJzZWQgdHJhbnNhY3Rpb24gZGV0YWlscyBmb3IgYSBiYXRjaCBvZiBjb25maXJtZWQgdHJhbnNhY3Rpb25zXG4gICAqL1xuICBhc3luYyBnZXRQYXJzZWRUcmFuc2FjdGlvbnMoc2lnbmF0dXJlcywgY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICBjb25zdCBiYXRjaCA9IHNpZ25hdHVyZXMubWFwKHNpZ25hdHVyZSA9PiB7XG4gICAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChbc2lnbmF0dXJlXSwgY29tbWl0bWVudCwgJ2pzb25QYXJzZWQnLCBjb25maWcpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWV0aG9kTmFtZTogJ2dldFRyYW5zYWN0aW9uJyxcbiAgICAgICAgYXJnc1xuICAgICAgfTtcbiAgICB9KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNCYXRjaFJlcXVlc3QoYmF0Y2gpO1xuICAgIGNvbnN0IHJlcyA9IHVuc2FmZVJlcy5tYXAodW5zYWZlUmVzID0+IHtcbiAgICAgIGNvbnN0IHJlcyA9IHN1cGVyc3RydWN0LmNyZWF0ZSh1bnNhZmVSZXMsIEdldFBhcnNlZFRyYW5zYWN0aW9uUnBjUmVzdWx0KTtcbiAgICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgdHJhbnNhY3Rpb25zJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRyYW5zYWN0aW9uIGRldGFpbHMgZm9yIGEgYmF0Y2ggb2YgY29uZmlybWVkIHRyYW5zYWN0aW9ucy5cbiAgICogU2ltaWxhciB0byB7QGxpbmsgZ2V0UGFyc2VkVHJhbnNhY3Rpb25zfSBidXQgcmV0dXJucyBhIHtAbGluayBUcmFuc2FjdGlvblJlc3BvbnNlfS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgSW5zdGVhZCwgY2FsbCBgZ2V0VHJhbnNhY3Rpb25zYCB1c2luZyBhXG4gICAqIGBHZXRWZXJzaW9uZWRUcmFuc2FjdGlvbkNvbmZpZ2AgYnkgc2V0dGluZyB0aGVcbiAgICogYG1heFN1cHBvcnRlZFRyYW5zYWN0aW9uVmVyc2lvbmAgcHJvcGVydHkuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBGZXRjaCB0cmFuc2FjdGlvbiBkZXRhaWxzIGZvciBhIGJhdGNoIG9mIGNvbmZpcm1lZCB0cmFuc2FjdGlvbnMuXG4gICAqIFNpbWlsYXIgdG8ge0BsaW5rIGdldFBhcnNlZFRyYW5zYWN0aW9uc30gYnV0IHJldHVybnMgYSB7QGxpbmtcbiAgICogVmVyc2lvbmVkVHJhbnNhY3Rpb25SZXNwb25zZX0uXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG5cbiAgLyoqXG4gICAqIEZldGNoIHRyYW5zYWN0aW9uIGRldGFpbHMgZm9yIGEgYmF0Y2ggb2YgY29uZmlybWVkIHRyYW5zYWN0aW9ucy5cbiAgICogU2ltaWxhciB0byB7QGxpbmsgZ2V0UGFyc2VkVHJhbnNhY3Rpb25zfSBidXQgcmV0dXJucyBhIHtAbGlua1xuICAgKiBWZXJzaW9uZWRUcmFuc2FjdGlvblJlc3BvbnNlfS5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcbiAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25zKHNpZ25hdHVyZXMsIGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgY29uc3QgYmF0Y2ggPSBzaWduYXR1cmVzLm1hcChzaWduYXR1cmUgPT4ge1xuICAgICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoW3NpZ25hdHVyZV0sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCAvKiBlbmNvZGluZyAqLywgY29uZmlnKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1ldGhvZE5hbWU6ICdnZXRUcmFuc2FjdGlvbicsXG4gICAgICAgIGFyZ3NcbiAgICAgIH07XG4gICAgfSk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjQmF0Y2hSZXF1ZXN0KGJhdGNoKTtcbiAgICBjb25zdCByZXMgPSB1bnNhZmVSZXMubWFwKHVuc2FmZVJlcyA9PiB7XG4gICAgICBjb25zdCByZXMgPSBzdXBlcnN0cnVjdC5jcmVhdGUodW5zYWZlUmVzLCBHZXRUcmFuc2FjdGlvblJwY1Jlc3VsdCk7XG4gICAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHRyYW5zYWN0aW9ucycpO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0ID0gcmVzLnJlc3VsdDtcbiAgICAgIGlmICghcmVzdWx0KSByZXR1cm4gcmVzdWx0O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ucmVzdWx0LFxuICAgICAgICB0cmFuc2FjdGlvbjoge1xuICAgICAgICAgIC4uLnJlc3VsdC50cmFuc2FjdGlvbixcbiAgICAgICAgICBtZXNzYWdlOiB2ZXJzaW9uZWRNZXNzYWdlRnJvbVJlc3BvbnNlKHJlc3VsdC52ZXJzaW9uLCByZXN1bHQudHJhbnNhY3Rpb24ubWVzc2FnZSlcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGEgbGlzdCBvZiBUcmFuc2FjdGlvbnMgYW5kIHRyYW5zYWN0aW9uIHN0YXR1c2VzIGZyb20gdGhlIGNsdXN0ZXJcbiAgICogZm9yIGEgY29uZmlybWVkIGJsb2NrLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIHYxLjEzLjAuIFBsZWFzZSB1c2Uge0BsaW5rIGdldEJsb2NrfSBpbnN0ZWFkLlxuICAgKi9cbiAgYXN5bmMgZ2V0Q29uZmlybWVkQmxvY2soc2xvdCwgY29tbWl0bWVudCkge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKFtzbG90XSwgY29tbWl0bWVudCk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0Q29uZmlybWVkQmxvY2snLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBzdXBlcnN0cnVjdC5jcmVhdGUodW5zYWZlUmVzLCBHZXRDb25maXJtZWRCbG9ja1JwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgY29uZmlybWVkIGJsb2NrJyk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHJlcy5yZXN1bHQ7XG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ29uZmlybWVkIGJsb2NrICcgKyBzbG90ICsgJyBub3QgZm91bmQnKTtcbiAgICB9XG4gICAgY29uc3QgYmxvY2sgPSB7XG4gICAgICAuLi5yZXN1bHQsXG4gICAgICB0cmFuc2FjdGlvbnM6IHJlc3VsdC50cmFuc2FjdGlvbnMubWFwKCh7XG4gICAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgICBtZXRhXG4gICAgICB9KSA9PiB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBuZXcgTWVzc2FnZSh0cmFuc2FjdGlvbi5tZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtZXRhLFxuICAgICAgICAgIHRyYW5zYWN0aW9uOiB7XG4gICAgICAgICAgICAuLi50cmFuc2FjdGlvbixcbiAgICAgICAgICAgIG1lc3NhZ2VcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KVxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmJsb2NrLFxuICAgICAgdHJhbnNhY3Rpb25zOiBibG9jay50cmFuc2FjdGlvbnMubWFwKCh7XG4gICAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgICBtZXRhXG4gICAgICB9KSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbWV0YSxcbiAgICAgICAgICB0cmFuc2FjdGlvbjogVHJhbnNhY3Rpb24ucG9wdWxhdGUodHJhbnNhY3Rpb24ubWVzc2FnZSwgdHJhbnNhY3Rpb24uc2lnbmF0dXJlcylcbiAgICAgICAgfTtcbiAgICAgIH0pXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBjb25maXJtZWQgYmxvY2tzIGJldHdlZW4gdHdvIHNsb3RzXG4gICAqL1xuICBhc3luYyBnZXRCbG9ja3Moc3RhcnRTbG90LCBlbmRTbG90LCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoZW5kU2xvdCAhPT0gdW5kZWZpbmVkID8gW3N0YXJ0U2xvdCwgZW5kU2xvdF0gOiBbc3RhcnRTbG90XSwgY29tbWl0bWVudCk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0QmxvY2tzJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gc3VwZXJzdHJ1Y3QuY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdChzdXBlcnN0cnVjdC5hcnJheShzdXBlcnN0cnVjdC5udW1iZXIoKSkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBibG9ja3MnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYSBsaXN0IG9mIFNpZ25hdHVyZXMgZnJvbSB0aGUgY2x1c3RlciBmb3IgYSBibG9jaywgZXhjbHVkaW5nIHJld2FyZHNcbiAgICovXG4gIGFzeW5jIGdldEJsb2NrU2lnbmF0dXJlcyhzbG90LCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoW3Nsb3RdLCBjb21taXRtZW50LCB1bmRlZmluZWQsIHtcbiAgICAgIHRyYW5zYWN0aW9uRGV0YWlsczogJ3NpZ25hdHVyZXMnLFxuICAgICAgcmV3YXJkczogZmFsc2VcbiAgICB9KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRCbG9jaycsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IHN1cGVyc3RydWN0LmNyZWF0ZSh1bnNhZmVSZXMsIEdldEJsb2NrU2lnbmF0dXJlc1JwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgYmxvY2snKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gcmVzLnJlc3VsdDtcbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdCbG9jayAnICsgc2xvdCArICcgbm90IGZvdW5kJyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYSBsaXN0IG9mIFNpZ25hdHVyZXMgZnJvbSB0aGUgY2x1c3RlciBmb3IgYSBjb25maXJtZWQgYmxvY2ssIGV4Y2x1ZGluZyByZXdhcmRzXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgU29sYW5hIHYxLjguMC4gUGxlYXNlIHVzZSB7QGxpbmsgZ2V0QmxvY2tTaWduYXR1cmVzfSBpbnN0ZWFkLlxuICAgKi9cbiAgYXN5bmMgZ2V0Q29uZmlybWVkQmxvY2tTaWduYXR1cmVzKHNsb3QsIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChbc2xvdF0sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCwge1xuICAgICAgdHJhbnNhY3Rpb25EZXRhaWxzOiAnc2lnbmF0dXJlcycsXG4gICAgICByZXdhcmRzOiBmYWxzZVxuICAgIH0pO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldENvbmZpcm1lZEJsb2NrJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gc3VwZXJzdHJ1Y3QuY3JlYXRlKHVuc2FmZVJlcywgR2V0QmxvY2tTaWduYXR1cmVzUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBjb25maXJtZWQgYmxvY2snKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gcmVzLnJlc3VsdDtcbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb25maXJtZWQgYmxvY2sgJyArIHNsb3QgKyAnIG5vdCBmb3VuZCcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGEgdHJhbnNhY3Rpb24gZGV0YWlscyBmb3IgYSBjb25maXJtZWQgdHJhbnNhY3Rpb25cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBTb2xhbmEgdjEuOC4wLiBQbGVhc2UgdXNlIHtAbGluayBnZXRUcmFuc2FjdGlvbn0gaW5zdGVhZC5cbiAgICovXG4gIGFzeW5jIGdldENvbmZpcm1lZFRyYW5zYWN0aW9uKHNpZ25hdHVyZSwgY29tbWl0bWVudCkge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKFtzaWduYXR1cmVdLCBjb21taXRtZW50KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRDb25maXJtZWRUcmFuc2FjdGlvbicsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IHN1cGVyc3RydWN0LmNyZWF0ZSh1bnNhZmVSZXMsIEdldFRyYW5zYWN0aW9uUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCB0cmFuc2FjdGlvbicpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSByZXMucmVzdWx0O1xuICAgIGlmICghcmVzdWx0KSByZXR1cm4gcmVzdWx0O1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBuZXcgTWVzc2FnZShyZXN1bHQudHJhbnNhY3Rpb24ubWVzc2FnZSk7XG4gICAgY29uc3Qgc2lnbmF0dXJlcyA9IHJlc3VsdC50cmFuc2FjdGlvbi5zaWduYXR1cmVzO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5yZXN1bHQsXG4gICAgICB0cmFuc2FjdGlvbjogVHJhbnNhY3Rpb24ucG9wdWxhdGUobWVzc2FnZSwgc2lnbmF0dXJlcylcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHBhcnNlZCB0cmFuc2FjdGlvbiBkZXRhaWxzIGZvciBhIGNvbmZpcm1lZCB0cmFuc2FjdGlvblxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFNvbGFuYSB2MS44LjAuIFBsZWFzZSB1c2Uge0BsaW5rIGdldFBhcnNlZFRyYW5zYWN0aW9ufSBpbnN0ZWFkLlxuICAgKi9cbiAgYXN5bmMgZ2V0UGFyc2VkQ29uZmlybWVkVHJhbnNhY3Rpb24oc2lnbmF0dXJlLCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoW3NpZ25hdHVyZV0sIGNvbW1pdG1lbnQsICdqc29uUGFyc2VkJyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0Q29uZmlybWVkVHJhbnNhY3Rpb24nLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBzdXBlcnN0cnVjdC5jcmVhdGUodW5zYWZlUmVzLCBHZXRQYXJzZWRUcmFuc2FjdGlvblJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgY29uZmlybWVkIHRyYW5zYWN0aW9uJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHBhcnNlZCB0cmFuc2FjdGlvbiBkZXRhaWxzIGZvciBhIGJhdGNoIG9mIGNvbmZpcm1lZCB0cmFuc2FjdGlvbnNcbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBTb2xhbmEgdjEuOC4wLiBQbGVhc2UgdXNlIHtAbGluayBnZXRQYXJzZWRUcmFuc2FjdGlvbnN9IGluc3RlYWQuXG4gICAqL1xuICBhc3luYyBnZXRQYXJzZWRDb25maXJtZWRUcmFuc2FjdGlvbnMoc2lnbmF0dXJlcywgY29tbWl0bWVudCkge1xuICAgIGNvbnN0IGJhdGNoID0gc2lnbmF0dXJlcy5tYXAoc2lnbmF0dXJlID0+IHtcbiAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKFtzaWduYXR1cmVdLCBjb21taXRtZW50LCAnanNvblBhcnNlZCcpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWV0aG9kTmFtZTogJ2dldENvbmZpcm1lZFRyYW5zYWN0aW9uJyxcbiAgICAgICAgYXJnc1xuICAgICAgfTtcbiAgICB9KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNCYXRjaFJlcXVlc3QoYmF0Y2gpO1xuICAgIGNvbnN0IHJlcyA9IHVuc2FmZVJlcy5tYXAodW5zYWZlUmVzID0+IHtcbiAgICAgIGNvbnN0IHJlcyA9IHN1cGVyc3RydWN0LmNyZWF0ZSh1bnNhZmVSZXMsIEdldFBhcnNlZFRyYW5zYWN0aW9uUnBjUmVzdWx0KTtcbiAgICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgY29uZmlybWVkIHRyYW5zYWN0aW9ucycpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhIGxpc3Qgb2YgYWxsIHRoZSBjb25maXJtZWQgc2lnbmF0dXJlcyBmb3IgdHJhbnNhY3Rpb25zIGludm9sdmluZyBhbiBhZGRyZXNzXG4gICAqIHdpdGhpbiBhIHNwZWNpZmllZCBzbG90IHJhbmdlLiBNYXggcmFuZ2UgYWxsb3dlZCBpcyAxMCwwMDAgc2xvdHMuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgdjEuMy4gUGxlYXNlIHVzZSB7QGxpbmsgZ2V0Q29uZmlybWVkU2lnbmF0dXJlc0ZvckFkZHJlc3MyfSBpbnN0ZWFkLlxuICAgKlxuICAgKiBAcGFyYW0gYWRkcmVzcyBxdWVyaWVkIGFkZHJlc3NcbiAgICogQHBhcmFtIHN0YXJ0U2xvdCBzdGFydCBzbG90LCBpbmNsdXNpdmVcbiAgICogQHBhcmFtIGVuZFNsb3QgZW5kIHNsb3QsIGluY2x1c2l2ZVxuICAgKi9cbiAgYXN5bmMgZ2V0Q29uZmlybWVkU2lnbmF0dXJlc0ZvckFkZHJlc3MoYWRkcmVzcywgc3RhcnRTbG90LCBlbmRTbG90KSB7XG4gICAgbGV0IG9wdGlvbnMgPSB7fTtcbiAgICBsZXQgZmlyc3RBdmFpbGFibGVCbG9jayA9IGF3YWl0IHRoaXMuZ2V0Rmlyc3RBdmFpbGFibGVCbG9jaygpO1xuICAgIHdoaWxlICghKCd1bnRpbCcgaW4gb3B0aW9ucykpIHtcbiAgICAgIHN0YXJ0U2xvdC0tO1xuICAgICAgaWYgKHN0YXJ0U2xvdCA8PSAwIHx8IHN0YXJ0U2xvdCA8IGZpcnN0QXZhaWxhYmxlQmxvY2spIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBibG9jayA9IGF3YWl0IHRoaXMuZ2V0Q29uZmlybWVkQmxvY2tTaWduYXR1cmVzKHN0YXJ0U2xvdCwgJ2ZpbmFsaXplZCcpO1xuICAgICAgICBpZiAoYmxvY2suc2lnbmF0dXJlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgb3B0aW9ucy51bnRpbCA9IGJsb2NrLnNpZ25hdHVyZXNbYmxvY2suc2lnbmF0dXJlcy5sZW5ndGggLSAxXS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yICYmIGVyci5tZXNzYWdlLmluY2x1ZGVzKCdza2lwcGVkJykpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGhpZ2hlc3RDb25maXJtZWRSb290ID0gYXdhaXQgdGhpcy5nZXRTbG90KCdmaW5hbGl6ZWQnKTtcbiAgICB3aGlsZSAoISgnYmVmb3JlJyBpbiBvcHRpb25zKSkge1xuICAgICAgZW5kU2xvdCsrO1xuICAgICAgaWYgKGVuZFNsb3QgPiBoaWdoZXN0Q29uZmlybWVkUm9vdCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGJsb2NrID0gYXdhaXQgdGhpcy5nZXRDb25maXJtZWRCbG9ja1NpZ25hdHVyZXMoZW5kU2xvdCk7XG4gICAgICAgIGlmIChibG9jay5zaWduYXR1cmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBvcHRpb25zLmJlZm9yZSA9IGJsb2NrLnNpZ25hdHVyZXNbYmxvY2suc2lnbmF0dXJlcy5sZW5ndGggLSAxXS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yICYmIGVyci5tZXNzYWdlLmluY2x1ZGVzKCdza2lwcGVkJykpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgY29uZmlybWVkU2lnbmF0dXJlSW5mbyA9IGF3YWl0IHRoaXMuZ2V0Q29uZmlybWVkU2lnbmF0dXJlc0ZvckFkZHJlc3MyKGFkZHJlc3MsIG9wdGlvbnMpO1xuICAgIHJldHVybiBjb25maXJtZWRTaWduYXR1cmVJbmZvLm1hcChpbmZvID0+IGluZm8uc2lnbmF0dXJlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGNvbmZpcm1lZCBzaWduYXR1cmVzIGZvciB0cmFuc2FjdGlvbnMgaW52b2x2aW5nIGFuXG4gICAqIGFkZHJlc3MgYmFja3dhcmRzIGluIHRpbWUgZnJvbSB0aGUgcHJvdmlkZWQgc2lnbmF0dXJlIG9yIG1vc3QgcmVjZW50IGNvbmZpcm1lZCBibG9ja1xuICAgKlxuICAgKlxuICAgKiBAcGFyYW0gYWRkcmVzcyBxdWVyaWVkIGFkZHJlc3NcbiAgICogQHBhcmFtIG9wdGlvbnNcbiAgICovXG4gIGFzeW5jIGdldENvbmZpcm1lZFNpZ25hdHVyZXNGb3JBZGRyZXNzMihhZGRyZXNzLCBvcHRpb25zLCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoW2FkZHJlc3MudG9CYXNlNTgoKV0sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCwgb3B0aW9ucyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0Q29uZmlybWVkU2lnbmF0dXJlc0ZvckFkZHJlc3MyJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gc3VwZXJzdHJ1Y3QuY3JlYXRlKHVuc2FmZVJlcywgR2V0Q29uZmlybWVkU2lnbmF0dXJlc0ZvckFkZHJlc3MyUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBjb25maXJtZWQgc2lnbmF0dXJlcyBmb3IgYWRkcmVzcycpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGNvbmZpcm1lZCBzaWduYXR1cmVzIGZvciB0cmFuc2FjdGlvbnMgaW52b2x2aW5nIGFuXG4gICAqIGFkZHJlc3MgYmFja3dhcmRzIGluIHRpbWUgZnJvbSB0aGUgcHJvdmlkZWQgc2lnbmF0dXJlIG9yIG1vc3QgcmVjZW50IGNvbmZpcm1lZCBibG9ja1xuICAgKlxuICAgKlxuICAgKiBAcGFyYW0gYWRkcmVzcyBxdWVyaWVkIGFkZHJlc3NcbiAgICogQHBhcmFtIG9wdGlvbnNcbiAgICovXG4gIGFzeW5jIGdldFNpZ25hdHVyZXNGb3JBZGRyZXNzKGFkZHJlc3MsIG9wdGlvbnMsIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChbYWRkcmVzcy50b0Jhc2U1OCgpXSwgY29tbWl0bWVudCwgdW5kZWZpbmVkLCBvcHRpb25zKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRTaWduYXR1cmVzRm9yQWRkcmVzcycsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IHN1cGVyc3RydWN0LmNyZWF0ZSh1bnNhZmVSZXMsIEdldFNpZ25hdHVyZXNGb3JBZGRyZXNzUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBzaWduYXR1cmVzIGZvciBhZGRyZXNzJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG4gIGFzeW5jIGdldEFkZHJlc3NMb29rdXBUYWJsZShhY2NvdW50S2V5LCBjb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb250ZXh0LFxuICAgICAgdmFsdWU6IGFjY291bnRJbmZvXG4gICAgfSA9IGF3YWl0IHRoaXMuZ2V0QWNjb3VudEluZm9BbmRDb250ZXh0KGFjY291bnRLZXksIGNvbmZpZyk7XG4gICAgbGV0IHZhbHVlID0gbnVsbDtcbiAgICBpZiAoYWNjb3VudEluZm8gIT09IG51bGwpIHtcbiAgICAgIHZhbHVlID0gbmV3IEFkZHJlc3NMb29rdXBUYWJsZUFjY291bnQoe1xuICAgICAgICBrZXk6IGFjY291bnRLZXksXG4gICAgICAgIHN0YXRlOiBBZGRyZXNzTG9va3VwVGFibGVBY2NvdW50LmRlc2VyaWFsaXplKGFjY291bnRJbmZvLmRhdGEpXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRleHQsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGNvbnRlbnRzIG9mIGEgTm9uY2UgYWNjb3VudCBmcm9tIHRoZSBjbHVzdGVyLCByZXR1cm4gd2l0aCBjb250ZXh0XG4gICAqL1xuICBhc3luYyBnZXROb25jZUFuZENvbnRleHQobm9uY2VBY2NvdW50LCBjb21taXRtZW50T3JDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb250ZXh0LFxuICAgICAgdmFsdWU6IGFjY291bnRJbmZvXG4gICAgfSA9IGF3YWl0IHRoaXMuZ2V0QWNjb3VudEluZm9BbmRDb250ZXh0KG5vbmNlQWNjb3VudCwgY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICBsZXQgdmFsdWUgPSBudWxsO1xuICAgIGlmIChhY2NvdW50SW5mbyAhPT0gbnVsbCkge1xuICAgICAgdmFsdWUgPSBOb25jZUFjY291bnQuZnJvbUFjY291bnREYXRhKGFjY291bnRJbmZvLmRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgY29udGV4dCxcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgY29udGVudHMgb2YgYSBOb25jZSBhY2NvdW50IGZyb20gdGhlIGNsdXN0ZXJcbiAgICovXG4gIGFzeW5jIGdldE5vbmNlKG5vbmNlQWNjb3VudCwgY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0Tm9uY2VBbmRDb250ZXh0KG5vbmNlQWNjb3VudCwgY29tbWl0bWVudE9yQ29uZmlnKS50aGVuKHggPT4geC52YWx1ZSkuY2F0Y2goZSA9PiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZhaWxlZCB0byBnZXQgbm9uY2UgZm9yIGFjY291bnQgJyArIG5vbmNlQWNjb3VudC50b0Jhc2U1OCgpICsgJzogJyArIGUpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgYW4gYWxsb2NhdGlvbiBvZiBsYW1wb3J0cyB0byB0aGUgc3BlY2lmaWVkIGFkZHJlc3NcbiAgICpcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBpbXBvcnQgeyBDb25uZWN0aW9uLCBQdWJsaWNLZXksIExBTVBPUlRTX1BFUl9TT0wgfSBmcm9tIFwiQHNvbGFuYS93ZWIzLmpzXCI7XG4gICAqXG4gICAqIChhc3luYyAoKSA9PiB7XG4gICAqICAgY29uc3QgY29ubmVjdGlvbiA9IG5ldyBDb25uZWN0aW9uKFwiaHR0cHM6Ly9hcGkudGVzdG5ldC5zb2xhbmEuY29tXCIsIFwiY29uZmlybWVkXCIpO1xuICAgKiAgIGNvbnN0IG15QWRkcmVzcyA9IG5ldyBQdWJsaWNLZXkoXCIybnIxYkhGVDg2Vzl0R255dm1ZVzR2Y0hLc1FCM3NWUWZuZGRhc3o0a0V4TVwiKTtcbiAgICogICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBjb25uZWN0aW9uLnJlcXVlc3RBaXJkcm9wKG15QWRkcmVzcywgTEFNUE9SVFNfUEVSX1NPTCk7XG4gICAqICAgYXdhaXQgY29ubmVjdGlvbi5jb25maXJtVHJhbnNhY3Rpb24oc2lnbmF0dXJlKTtcbiAgICogfSkoKTtcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyByZXF1ZXN0QWlyZHJvcCh0bywgbGFtcG9ydHMpIHtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdyZXF1ZXN0QWlyZHJvcCcsIFt0by50b0Jhc2U1OCgpLCBsYW1wb3J0c10pO1xuICAgIGNvbnN0IHJlcyA9IHN1cGVyc3RydWN0LmNyZWF0ZSh1bnNhZmVSZXMsIFJlcXVlc3RBaXJkcm9wUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCBgYWlyZHJvcCB0byAke3RvLnRvQmFzZTU4KCl9IGZhaWxlZGApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGFzeW5jIF9ibG9ja2hhc2hXaXRoRXhwaXJ5QmxvY2tIZWlnaHQoZGlzYWJsZUNhY2hlKSB7XG4gICAgaWYgKCFkaXNhYmxlQ2FjaGUpIHtcbiAgICAgIC8vIFdhaXQgZm9yIHBvbGxpbmcgdG8gZmluaXNoXG4gICAgICB3aGlsZSAodGhpcy5fcG9sbGluZ0Jsb2NraGFzaCkge1xuICAgICAgICBhd2FpdCBzbGVlcCgxMDApO1xuICAgICAgfVxuICAgICAgY29uc3QgdGltZVNpbmNlRmV0Y2ggPSBEYXRlLm5vdygpIC0gdGhpcy5fYmxvY2toYXNoSW5mby5sYXN0RmV0Y2g7XG4gICAgICBjb25zdCBleHBpcmVkID0gdGltZVNpbmNlRmV0Y2ggPj0gQkxPQ0tIQVNIX0NBQ0hFX1RJTUVPVVRfTVM7XG4gICAgICBpZiAodGhpcy5fYmxvY2toYXNoSW5mby5sYXRlc3RCbG9ja2hhc2ggIT09IG51bGwgJiYgIWV4cGlyZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Jsb2NraGFzaEluZm8ubGF0ZXN0QmxvY2toYXNoO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5fcG9sbE5ld0Jsb2NraGFzaCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgYXN5bmMgX3BvbGxOZXdCbG9ja2hhc2goKSB7XG4gICAgdGhpcy5fcG9sbGluZ0Jsb2NraGFzaCA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICBjb25zdCBjYWNoZWRMYXRlc3RCbG9ja2hhc2ggPSB0aGlzLl9ibG9ja2hhc2hJbmZvLmxhdGVzdEJsb2NraGFzaDtcbiAgICAgIGNvbnN0IGNhY2hlZEJsb2NraGFzaCA9IGNhY2hlZExhdGVzdEJsb2NraGFzaCA/IGNhY2hlZExhdGVzdEJsb2NraGFzaC5ibG9ja2hhc2ggOiBudWxsO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1MDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGxhdGVzdEJsb2NraGFzaCA9IGF3YWl0IHRoaXMuZ2V0TGF0ZXN0QmxvY2toYXNoKCdmaW5hbGl6ZWQnKTtcbiAgICAgICAgaWYgKGNhY2hlZEJsb2NraGFzaCAhPT0gbGF0ZXN0QmxvY2toYXNoLmJsb2NraGFzaCkge1xuICAgICAgICAgIHRoaXMuX2Jsb2NraGFzaEluZm8gPSB7XG4gICAgICAgICAgICBsYXRlc3RCbG9ja2hhc2gsXG4gICAgICAgICAgICBsYXN0RmV0Y2g6IERhdGUubm93KCksXG4gICAgICAgICAgICB0cmFuc2FjdGlvblNpZ25hdHVyZXM6IFtdLFxuICAgICAgICAgICAgc2ltdWxhdGVkU2lnbmF0dXJlczogW11cbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiBsYXRlc3RCbG9ja2hhc2g7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTbGVlcCBmb3IgYXBwcm94aW1hdGVseSBoYWxmIGEgc2xvdFxuICAgICAgICBhd2FpdCBzbGVlcChNU19QRVJfU0xPVCAvIDIpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gb2J0YWluIGEgbmV3IGJsb2NraGFzaCBhZnRlciAke0RhdGUubm93KCkgLSBzdGFydFRpbWV9bXNgKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5fcG9sbGluZ0Jsb2NraGFzaCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgdGhlIHN0YWtlIG1pbmltdW0gZGVsZWdhdGlvblxuICAgKi9cbiAgYXN5bmMgZ2V0U3Rha2VNaW5pbXVtRGVsZWdhdGlvbihjb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnOiBjb25maWdBcmdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbXSwgY29tbWl0bWVudCwgJ2Jhc2U2NCcsIGNvbmZpZ0FyZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0U3Rha2VNaW5pbXVtRGVsZWdhdGlvbicsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IHN1cGVyc3RydWN0LmNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KHN1cGVyc3RydWN0Lm51bWJlcigpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgYGZhaWxlZCB0byBnZXQgc3Rha2UgbWluaW11bSBkZWxlZ2F0aW9uYCk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFNpbXVsYXRlIGEgdHJhbnNhY3Rpb25cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgSW5zdGVhZCwgY2FsbCB7QGxpbmsgc2ltdWxhdGVUcmFuc2FjdGlvbn0gd2l0aCB7QGxpbmtcbiAgICogVmVyc2lvbmVkVHJhbnNhY3Rpb259IGFuZCB7QGxpbmsgU2ltdWxhdGVUcmFuc2FjdGlvbkNvbmZpZ30gcGFyYW1ldGVyc1xuICAgKi9cblxuICAvKipcbiAgICogU2ltdWxhdGUgYSB0cmFuc2FjdGlvblxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuXG4gIC8qKlxuICAgKiBTaW11bGF0ZSBhIHRyYW5zYWN0aW9uXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG4gIGFzeW5jIHNpbXVsYXRlVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25Pck1lc3NhZ2UsIGNvbmZpZ09yU2lnbmVycywgaW5jbHVkZUFjY291bnRzKSB7XG4gICAgaWYgKCdtZXNzYWdlJyBpbiB0cmFuc2FjdGlvbk9yTWVzc2FnZSkge1xuICAgICAgY29uc3QgdmVyc2lvbmVkVHggPSB0cmFuc2FjdGlvbk9yTWVzc2FnZTtcbiAgICAgIGNvbnN0IHdpcmVUcmFuc2FjdGlvbiA9IHZlcnNpb25lZFR4LnNlcmlhbGl6ZSgpO1xuICAgICAgY29uc3QgZW5jb2RlZFRyYW5zYWN0aW9uID0gYnVmZmVyLkJ1ZmZlci5mcm9tKHdpcmVUcmFuc2FjdGlvbikudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29uZmlnT3JTaWduZXJzKSB8fCBpbmNsdWRlQWNjb3VudHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzJyk7XG4gICAgICB9XG4gICAgICBjb25zdCBjb25maWcgPSBjb25maWdPclNpZ25lcnMgfHwge307XG4gICAgICBjb25maWcuZW5jb2RpbmcgPSAnYmFzZTY0JztcbiAgICAgIGlmICghKCdjb21taXRtZW50JyBpbiBjb25maWcpKSB7XG4gICAgICAgIGNvbmZpZy5jb21taXRtZW50ID0gdGhpcy5jb21taXRtZW50O1xuICAgICAgfVxuICAgICAgY29uc3QgYXJncyA9IFtlbmNvZGVkVHJhbnNhY3Rpb24sIGNvbmZpZ107XG4gICAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdzaW11bGF0ZVRyYW5zYWN0aW9uJywgYXJncyk7XG4gICAgICBjb25zdCByZXMgPSBzdXBlcnN0cnVjdC5jcmVhdGUodW5zYWZlUmVzLCBTaW11bGF0ZWRUcmFuc2FjdGlvblJlc3BvbnNlU3RydWN0KTtcbiAgICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZhaWxlZCB0byBzaW11bGF0ZSB0cmFuc2FjdGlvbjogJyArIHJlcy5lcnJvci5tZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXMucmVzdWx0O1xuICAgIH1cbiAgICBsZXQgdHJhbnNhY3Rpb247XG4gICAgaWYgKHRyYW5zYWN0aW9uT3JNZXNzYWdlIGluc3RhbmNlb2YgVHJhbnNhY3Rpb24pIHtcbiAgICAgIGxldCBvcmlnaW5hbFR4ID0gdHJhbnNhY3Rpb25Pck1lc3NhZ2U7XG4gICAgICB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbigpO1xuICAgICAgdHJhbnNhY3Rpb24uZmVlUGF5ZXIgPSBvcmlnaW5hbFR4LmZlZVBheWVyO1xuICAgICAgdHJhbnNhY3Rpb24uaW5zdHJ1Y3Rpb25zID0gdHJhbnNhY3Rpb25Pck1lc3NhZ2UuaW5zdHJ1Y3Rpb25zO1xuICAgICAgdHJhbnNhY3Rpb24ubm9uY2VJbmZvID0gb3JpZ2luYWxUeC5ub25jZUluZm87XG4gICAgICB0cmFuc2FjdGlvbi5zaWduYXR1cmVzID0gb3JpZ2luYWxUeC5zaWduYXR1cmVzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmFuc2FjdGlvbiA9IFRyYW5zYWN0aW9uLnBvcHVsYXRlKHRyYW5zYWN0aW9uT3JNZXNzYWdlKTtcbiAgICAgIC8vIEhBQ0s6IHRoaXMgZnVuY3Rpb24gcmVsaWVzIG9uIG11dGF0aW5nIHRoZSBwb3B1bGF0ZWQgdHJhbnNhY3Rpb25cbiAgICAgIHRyYW5zYWN0aW9uLl9tZXNzYWdlID0gdHJhbnNhY3Rpb24uX2pzb24gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChjb25maWdPclNpZ25lcnMgIT09IHVuZGVmaW5lZCAmJiAhQXJyYXkuaXNBcnJheShjb25maWdPclNpZ25lcnMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzJyk7XG4gICAgfVxuICAgIGNvbnN0IHNpZ25lcnMgPSBjb25maWdPclNpZ25lcnM7XG4gICAgaWYgKHRyYW5zYWN0aW9uLm5vbmNlSW5mbyAmJiBzaWduZXJzKSB7XG4gICAgICB0cmFuc2FjdGlvbi5zaWduKC4uLnNpZ25lcnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZGlzYWJsZUNhY2hlID0gdGhpcy5fZGlzYWJsZUJsb2NraGFzaENhY2hpbmc7XG4gICAgICBmb3IgKDs7KSB7XG4gICAgICAgIGNvbnN0IGxhdGVzdEJsb2NraGFzaCA9IGF3YWl0IHRoaXMuX2Jsb2NraGFzaFdpdGhFeHBpcnlCbG9ja0hlaWdodChkaXNhYmxlQ2FjaGUpO1xuICAgICAgICB0cmFuc2FjdGlvbi5sYXN0VmFsaWRCbG9ja0hlaWdodCA9IGxhdGVzdEJsb2NraGFzaC5sYXN0VmFsaWRCbG9ja0hlaWdodDtcbiAgICAgICAgdHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoID0gbGF0ZXN0QmxvY2toYXNoLmJsb2NraGFzaDtcbiAgICAgICAgaWYgKCFzaWduZXJzKSBicmVhaztcbiAgICAgICAgdHJhbnNhY3Rpb24uc2lnbiguLi5zaWduZXJzKTtcbiAgICAgICAgaWYgKCF0cmFuc2FjdGlvbi5zaWduYXR1cmUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJyFzaWduYXR1cmUnKTsgLy8gc2hvdWxkIG5ldmVyIGhhcHBlblxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHRyYW5zYWN0aW9uLnNpZ25hdHVyZS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgICAgIGlmICghdGhpcy5fYmxvY2toYXNoSW5mby5zaW11bGF0ZWRTaWduYXR1cmVzLmluY2x1ZGVzKHNpZ25hdHVyZSkgJiYgIXRoaXMuX2Jsb2NraGFzaEluZm8udHJhbnNhY3Rpb25TaWduYXR1cmVzLmluY2x1ZGVzKHNpZ25hdHVyZSkpIHtcbiAgICAgICAgICAvLyBUaGUgc2lnbmF0dXJlIG9mIHRoaXMgdHJhbnNhY3Rpb24gaGFzIG5vdCBiZWVuIHNlZW4gYmVmb3JlIHdpdGggdGhlXG4gICAgICAgICAgLy8gY3VycmVudCByZWNlbnRCbG9ja2hhc2gsIGFsbCBkb25lLiBMZXQncyBicmVha1xuICAgICAgICAgIHRoaXMuX2Jsb2NraGFzaEluZm8uc2ltdWxhdGVkU2lnbmF0dXJlcy5wdXNoKHNpZ25hdHVyZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVGhpcyB0cmFuc2FjdGlvbiB3b3VsZCBiZSB0cmVhdGVkIGFzIGR1cGxpY2F0ZSAoaXRzIGRlcml2ZWQgc2lnbmF0dXJlXG4gICAgICAgICAgLy8gbWF0Y2hlZCB0byBvbmUgb2YgYWxyZWFkeSByZWNvcmRlZCBzaWduYXR1cmVzKS5cbiAgICAgICAgICAvLyBTbywgd2UgbXVzdCBmZXRjaCBhIG5ldyBibG9ja2hhc2ggZm9yIGEgZGlmZmVyZW50IHNpZ25hdHVyZSBieSBkaXNhYmxpbmdcbiAgICAgICAgICAvLyBvdXIgY2FjaGUgbm90IHRvIHdhaXQgZm9yIHRoZSBjYWNoZSBleHBpcmF0aW9uIChCTE9DS0hBU0hfQ0FDSEVfVElNRU9VVF9NUykuXG4gICAgICAgICAgZGlzYWJsZUNhY2hlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlID0gdHJhbnNhY3Rpb24uX2NvbXBpbGUoKTtcbiAgICBjb25zdCBzaWduRGF0YSA9IG1lc3NhZ2Uuc2VyaWFsaXplKCk7XG4gICAgY29uc3Qgd2lyZVRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb24uX3NlcmlhbGl6ZShzaWduRGF0YSk7XG4gICAgY29uc3QgZW5jb2RlZFRyYW5zYWN0aW9uID0gd2lyZVRyYW5zYWN0aW9uLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICBlbmNvZGluZzogJ2Jhc2U2NCcsXG4gICAgICBjb21taXRtZW50OiB0aGlzLmNvbW1pdG1lbnRcbiAgICB9O1xuICAgIGlmIChpbmNsdWRlQWNjb3VudHMpIHtcbiAgICAgIGNvbnN0IGFkZHJlc3NlcyA9IChBcnJheS5pc0FycmF5KGluY2x1ZGVBY2NvdW50cykgPyBpbmNsdWRlQWNjb3VudHMgOiBtZXNzYWdlLm5vblByb2dyYW1JZHMoKSkubWFwKGtleSA9PiBrZXkudG9CYXNlNTgoKSk7XG4gICAgICBjb25maWdbJ2FjY291bnRzJ10gPSB7XG4gICAgICAgIGVuY29kaW5nOiAnYmFzZTY0JyxcbiAgICAgICAgYWRkcmVzc2VzXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoc2lnbmVycykge1xuICAgICAgY29uZmlnLnNpZ1ZlcmlmeSA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGFyZ3MgPSBbZW5jb2RlZFRyYW5zYWN0aW9uLCBjb25maWddO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ3NpbXVsYXRlVHJhbnNhY3Rpb24nLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBzdXBlcnN0cnVjdC5jcmVhdGUodW5zYWZlUmVzLCBTaW11bGF0ZWRUcmFuc2FjdGlvblJlc3BvbnNlU3RydWN0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIGxldCBsb2dzO1xuICAgICAgaWYgKCdkYXRhJyBpbiByZXMuZXJyb3IpIHtcbiAgICAgICAgbG9ncyA9IHJlcy5lcnJvci5kYXRhLmxvZ3M7XG4gICAgICAgIGlmIChsb2dzICYmIEFycmF5LmlzQXJyYXkobG9ncykpIHtcbiAgICAgICAgICBjb25zdCB0cmFjZUluZGVudCA9ICdcXG4gICAgJztcbiAgICAgICAgICBjb25zdCBsb2dUcmFjZSA9IHRyYWNlSW5kZW50ICsgbG9ncy5qb2luKHRyYWNlSW5kZW50KTtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKHJlcy5lcnJvci5tZXNzYWdlLCBsb2dUcmFjZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBTZW5kVHJhbnNhY3Rpb25FcnJvcignZmFpbGVkIHRvIHNpbXVsYXRlIHRyYW5zYWN0aW9uOiAnICsgcmVzLmVycm9yLm1lc3NhZ2UsIGxvZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaWduIGFuZCBzZW5kIGEgdHJhbnNhY3Rpb25cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgSW5zdGVhZCwgY2FsbCB7QGxpbmsgc2VuZFRyYW5zYWN0aW9ufSB3aXRoIGEge0BsaW5rXG4gICAqIFZlcnNpb25lZFRyYW5zYWN0aW9ufVxuICAgKi9cblxuICAvKipcbiAgICogU2VuZCBhIHNpZ25lZCB0cmFuc2FjdGlvblxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuXG4gIC8qKlxuICAgKiBTaWduIGFuZCBzZW5kIGEgdHJhbnNhY3Rpb25cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcbiAgYXN5bmMgc2VuZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBzaWduZXJzT3JPcHRpb25zLCBvcHRpb25zKSB7XG4gICAgaWYgKCd2ZXJzaW9uJyBpbiB0cmFuc2FjdGlvbikge1xuICAgICAgaWYgKHNpZ25lcnNPck9wdGlvbnMgJiYgQXJyYXkuaXNBcnJheShzaWduZXJzT3JPcHRpb25zKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzJyk7XG4gICAgICB9XG4gICAgICBjb25zdCB3aXJlVHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbi5zZXJpYWxpemUoKTtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNlbmRSYXdUcmFuc2FjdGlvbih3aXJlVHJhbnNhY3Rpb24sIHNpZ25lcnNPck9wdGlvbnMpO1xuICAgIH1cbiAgICBpZiAoc2lnbmVyc09yT3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8ICFBcnJheS5pc0FycmF5KHNpZ25lcnNPck9wdGlvbnMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzJyk7XG4gICAgfVxuICAgIGNvbnN0IHNpZ25lcnMgPSBzaWduZXJzT3JPcHRpb25zO1xuICAgIGlmICh0cmFuc2FjdGlvbi5ub25jZUluZm8pIHtcbiAgICAgIHRyYW5zYWN0aW9uLnNpZ24oLi4uc2lnbmVycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBkaXNhYmxlQ2FjaGUgPSB0aGlzLl9kaXNhYmxlQmxvY2toYXNoQ2FjaGluZztcbiAgICAgIGZvciAoOzspIHtcbiAgICAgICAgY29uc3QgbGF0ZXN0QmxvY2toYXNoID0gYXdhaXQgdGhpcy5fYmxvY2toYXNoV2l0aEV4cGlyeUJsb2NrSGVpZ2h0KGRpc2FibGVDYWNoZSk7XG4gICAgICAgIHRyYW5zYWN0aW9uLmxhc3RWYWxpZEJsb2NrSGVpZ2h0ID0gbGF0ZXN0QmxvY2toYXNoLmxhc3RWYWxpZEJsb2NrSGVpZ2h0O1xuICAgICAgICB0cmFuc2FjdGlvbi5yZWNlbnRCbG9ja2hhc2ggPSBsYXRlc3RCbG9ja2hhc2guYmxvY2toYXNoO1xuICAgICAgICB0cmFuc2FjdGlvbi5zaWduKC4uLnNpZ25lcnMpO1xuICAgICAgICBpZiAoIXRyYW5zYWN0aW9uLnNpZ25hdHVyZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignIXNpZ25hdHVyZScpOyAvLyBzaG91bGQgbmV2ZXIgaGFwcGVuXG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gdHJhbnNhY3Rpb24uc2lnbmF0dXJlLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICAgICAgaWYgKCF0aGlzLl9ibG9ja2hhc2hJbmZvLnRyYW5zYWN0aW9uU2lnbmF0dXJlcy5pbmNsdWRlcyhzaWduYXR1cmUpKSB7XG4gICAgICAgICAgLy8gVGhlIHNpZ25hdHVyZSBvZiB0aGlzIHRyYW5zYWN0aW9uIGhhcyBub3QgYmVlbiBzZWVuIGJlZm9yZSB3aXRoIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgcmVjZW50QmxvY2toYXNoLCBhbGwgZG9uZS4gTGV0J3MgYnJlYWtcbiAgICAgICAgICB0aGlzLl9ibG9ja2hhc2hJbmZvLnRyYW5zYWN0aW9uU2lnbmF0dXJlcy5wdXNoKHNpZ25hdHVyZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVGhpcyB0cmFuc2FjdGlvbiB3b3VsZCBiZSB0cmVhdGVkIGFzIGR1cGxpY2F0ZSAoaXRzIGRlcml2ZWQgc2lnbmF0dXJlXG4gICAgICAgICAgLy8gbWF0Y2hlZCB0byBvbmUgb2YgYWxyZWFkeSByZWNvcmRlZCBzaWduYXR1cmVzKS5cbiAgICAgICAgICAvLyBTbywgd2UgbXVzdCBmZXRjaCBhIG5ldyBibG9ja2hhc2ggZm9yIGEgZGlmZmVyZW50IHNpZ25hdHVyZSBieSBkaXNhYmxpbmdcbiAgICAgICAgICAvLyBvdXIgY2FjaGUgbm90IHRvIHdhaXQgZm9yIHRoZSBjYWNoZSBleHBpcmF0aW9uIChCTE9DS0hBU0hfQ0FDSEVfVElNRU9VVF9NUykuXG4gICAgICAgICAgZGlzYWJsZUNhY2hlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB3aXJlVHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbi5zZXJpYWxpemUoKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZW5kUmF3VHJhbnNhY3Rpb24od2lyZVRyYW5zYWN0aW9uLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIGEgdHJhbnNhY3Rpb24gdGhhdCBoYXMgYWxyZWFkeSBiZWVuIHNpZ25lZCBhbmQgc2VyaWFsaXplZCBpbnRvIHRoZVxuICAgKiB3aXJlIGZvcm1hdFxuICAgKi9cbiAgYXN5bmMgc2VuZFJhd1RyYW5zYWN0aW9uKHJhd1RyYW5zYWN0aW9uLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZW5jb2RlZFRyYW5zYWN0aW9uID0gdG9CdWZmZXIocmF3VHJhbnNhY3Rpb24pLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnNlbmRFbmNvZGVkVHJhbnNhY3Rpb24oZW5jb2RlZFRyYW5zYWN0aW9uLCBvcHRpb25zKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYSB0cmFuc2FjdGlvbiB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gc2lnbmVkLCBzZXJpYWxpemVkIGludG8gdGhlXG4gICAqIHdpcmUgZm9ybWF0LCBhbmQgZW5jb2RlZCBhcyBhIGJhc2U2NCBzdHJpbmdcbiAgICovXG4gIGFzeW5jIHNlbmRFbmNvZGVkVHJhbnNhY3Rpb24oZW5jb2RlZFRyYW5zYWN0aW9uLCBvcHRpb25zKSB7XG4gICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgZW5jb2Rpbmc6ICdiYXNlNjQnXG4gICAgfTtcbiAgICBjb25zdCBza2lwUHJlZmxpZ2h0ID0gb3B0aW9ucyAmJiBvcHRpb25zLnNraXBQcmVmbGlnaHQ7XG4gICAgY29uc3QgcHJlZmxpZ2h0Q29tbWl0bWVudCA9IHNraXBQcmVmbGlnaHQgPT09IHRydWUgPyAncHJvY2Vzc2VkJyAvLyBGSVhNRSBSZW1vdmUgd2hlbiBodHRwczovL2dpdGh1Yi5jb20vYW56YS14eXovYWdhdmUvcHVsbC80ODMgaXMgZGVwbG95ZWQuXG4gICAgOiBvcHRpb25zICYmIG9wdGlvbnMucHJlZmxpZ2h0Q29tbWl0bWVudCB8fCB0aGlzLmNvbW1pdG1lbnQ7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5tYXhSZXRyaWVzICE9IG51bGwpIHtcbiAgICAgIGNvbmZpZy5tYXhSZXRyaWVzID0gb3B0aW9ucy5tYXhSZXRyaWVzO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLm1pbkNvbnRleHRTbG90ICE9IG51bGwpIHtcbiAgICAgIGNvbmZpZy5taW5Db250ZXh0U2xvdCA9IG9wdGlvbnMubWluQ29udGV4dFNsb3Q7XG4gICAgfVxuICAgIGlmIChza2lwUHJlZmxpZ2h0KSB7XG4gICAgICBjb25maWcuc2tpcFByZWZsaWdodCA9IHNraXBQcmVmbGlnaHQ7XG4gICAgfVxuICAgIGlmIChwcmVmbGlnaHRDb21taXRtZW50KSB7XG4gICAgICBjb25maWcucHJlZmxpZ2h0Q29tbWl0bWVudCA9IHByZWZsaWdodENvbW1pdG1lbnQ7XG4gICAgfVxuICAgIGNvbnN0IGFyZ3MgPSBbZW5jb2RlZFRyYW5zYWN0aW9uLCBjb25maWddO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ3NlbmRUcmFuc2FjdGlvbicsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IHN1cGVyc3RydWN0LmNyZWF0ZSh1bnNhZmVSZXMsIFNlbmRUcmFuc2FjdGlvblJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICBsZXQgbG9ncztcbiAgICAgIGlmICgnZGF0YScgaW4gcmVzLmVycm9yKSB7XG4gICAgICAgIGxvZ3MgPSByZXMuZXJyb3IuZGF0YS5sb2dzO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IFNlbmRUcmFuc2FjdGlvbkVycm9yKCdmYWlsZWQgdG8gc2VuZCB0cmFuc2FjdGlvbjogJyArIHJlcy5lcnJvci5tZXNzYWdlLCBsb2dzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfd3NPbk9wZW4oKSB7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Q29ubmVjdGVkID0gdHJ1ZTtcbiAgICB0aGlzLl9ycGNXZWJTb2NrZXRIZWFydGJlYXQgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAvLyBQaW5nIHNlcnZlciBldmVyeSA1cyB0byBwcmV2ZW50IGlkbGUgdGltZW91dHNcbiAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5fcnBjV2ViU29ja2V0Lm5vdGlmeSgncGluZycpO1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICAgICAgICB9IGNhdGNoIHt9XG4gICAgICB9KSgpO1xuICAgIH0sIDUwMDApO1xuICAgIHRoaXMuX3VwZGF0ZVN1YnNjcmlwdGlvbnMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF93c09uRXJyb3IoZXJyKSB7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Q29ubmVjdGVkID0gZmFsc2U7XG4gICAgY29uc29sZS5lcnJvcignd3MgZXJyb3I6JywgZXJyLm1lc3NhZ2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3dzT25DbG9zZShjb2RlKSB7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Q29ubmVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0R2VuZXJhdGlvbiA9ICh0aGlzLl9ycGNXZWJTb2NrZXRHZW5lcmF0aW9uICsgMSkgJSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICBpZiAodGhpcy5fcnBjV2ViU29ja2V0SWRsZVRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9ycGNXZWJTb2NrZXRJZGxlVGltZW91dCk7XG4gICAgICB0aGlzLl9ycGNXZWJTb2NrZXRJZGxlVGltZW91dCA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLl9ycGNXZWJTb2NrZXRIZWFydGJlYXQpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fcnBjV2ViU29ja2V0SGVhcnRiZWF0KTtcbiAgICAgIHRoaXMuX3JwY1dlYlNvY2tldEhlYXJ0YmVhdCA9IG51bGw7XG4gICAgfVxuICAgIGlmIChjb2RlID09PSAxMDAwKSB7XG4gICAgICAvLyBleHBsaWNpdCBjbG9zZSwgY2hlY2sgaWYgYW55IHN1YnNjcmlwdGlvbnMgaGF2ZSBiZWVuIG1hZGUgc2luY2UgY2xvc2VcbiAgICAgIHRoaXMuX3VwZGF0ZVN1YnNjcmlwdGlvbnMoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBpbXBsaWNpdCBjbG9zZSwgcHJlcGFyZSBzdWJzY3JpcHRpb25zIGZvciBhdXRvLXJlY29ubmVjdFxuICAgIHRoaXMuX3N1YnNjcmlwdGlvbkNhbGxiYWNrc0J5U2VydmVyU3Vic2NyaXB0aW9uSWQgPSB7fTtcbiAgICBPYmplY3QuZW50cmllcyh0aGlzLl9zdWJzY3JpcHRpb25zQnlIYXNoKS5mb3JFYWNoKChbaGFzaCwgc3Vic2NyaXB0aW9uXSkgPT4ge1xuICAgICAgdGhpcy5fc2V0U3Vic2NyaXB0aW9uKGhhc2gsIHtcbiAgICAgICAgLi4uc3Vic2NyaXB0aW9uLFxuICAgICAgICBzdGF0ZTogJ3BlbmRpbmcnXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9zZXRTdWJzY3JpcHRpb24oaGFzaCwgbmV4dFN1YnNjcmlwdGlvbikge1xuICAgIGNvbnN0IHByZXZTdGF0ZSA9IHRoaXMuX3N1YnNjcmlwdGlvbnNCeUhhc2hbaGFzaF0/LnN0YXRlO1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbnNCeUhhc2hbaGFzaF0gPSBuZXh0U3Vic2NyaXB0aW9uO1xuICAgIGlmIChwcmV2U3RhdGUgIT09IG5leHRTdWJzY3JpcHRpb24uc3RhdGUpIHtcbiAgICAgIGNvbnN0IHN0YXRlQ2hhbmdlQ2FsbGJhY2tzID0gdGhpcy5fc3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2VDYWxsYmFja3NCeUhhc2hbaGFzaF07XG4gICAgICBpZiAoc3RhdGVDaGFuZ2VDYWxsYmFja3MpIHtcbiAgICAgICAgc3RhdGVDaGFuZ2VDYWxsYmFja3MuZm9yRWFjaChjYiA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNiKG5leHRTdWJzY3JpcHRpb24uc3RhdGUpO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gICAgICAgICAgfSBjYXRjaCB7fVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfb25TdWJzY3JpcHRpb25TdGF0ZUNoYW5nZShjbGllbnRTdWJzY3JpcHRpb25JZCwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBoYXNoID0gdGhpcy5fc3Vic2NyaXB0aW9uSGFzaEJ5Q2xpZW50U3Vic2NyaXB0aW9uSWRbY2xpZW50U3Vic2NyaXB0aW9uSWRdO1xuICAgIGlmIChoYXNoID09IG51bGwpIHtcbiAgICAgIHJldHVybiAoKSA9PiB7fTtcbiAgICB9XG4gICAgY29uc3Qgc3RhdGVDaGFuZ2VDYWxsYmFja3MgPSB0aGlzLl9zdWJzY3JpcHRpb25TdGF0ZUNoYW5nZUNhbGxiYWNrc0J5SGFzaFtoYXNoXSB8fD0gbmV3IFNldCgpO1xuICAgIHN0YXRlQ2hhbmdlQ2FsbGJhY2tzLmFkZChjYWxsYmFjayk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHN0YXRlQ2hhbmdlQ2FsbGJhY2tzLmRlbGV0ZShjYWxsYmFjayk7XG4gICAgICBpZiAoc3RhdGVDaGFuZ2VDYWxsYmFja3Muc2l6ZSA9PT0gMCkge1xuICAgICAgICBkZWxldGUgdGhpcy5fc3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2VDYWxsYmFja3NCeUhhc2hbaGFzaF07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGFzeW5jIF91cGRhdGVTdWJzY3JpcHRpb25zKCkge1xuICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLl9zdWJzY3JpcHRpb25zQnlIYXNoKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGlmICh0aGlzLl9ycGNXZWJTb2NrZXRDb25uZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5fcnBjV2ViU29ja2V0Q29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3JwY1dlYlNvY2tldElkbGVUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fcnBjV2ViU29ja2V0SWRsZVRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl9ycGNXZWJTb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIC8vIHN3YWxsb3cgZXJyb3IgaWYgc29ja2V0IGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkLlxuICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBFcnJvciB3aGVuIGNsb3Npbmcgc29ja2V0IGNvbm5lY3Rpb246ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCA1MDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcnBjV2ViU29ja2V0SWRsZVRpbWVvdXQgIT09IG51bGwpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9ycGNXZWJTb2NrZXRJZGxlVGltZW91dCk7XG4gICAgICB0aGlzLl9ycGNXZWJTb2NrZXRJZGxlVGltZW91dCA9IG51bGw7XG4gICAgICB0aGlzLl9ycGNXZWJTb2NrZXRDb25uZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX3JwY1dlYlNvY2tldENvbm5lY3RlZCkge1xuICAgICAgdGhpcy5fcnBjV2ViU29ja2V0LmNvbm5lY3QoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYWN0aXZlV2ViU29ja2V0R2VuZXJhdGlvbiA9IHRoaXMuX3JwY1dlYlNvY2tldEdlbmVyYXRpb247XG4gICAgY29uc3QgaXNDdXJyZW50Q29ubmVjdGlvblN0aWxsQWN0aXZlID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIGFjdGl2ZVdlYlNvY2tldEdlbmVyYXRpb24gPT09IHRoaXMuX3JwY1dlYlNvY2tldEdlbmVyYXRpb247XG4gICAgfTtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAvLyBEb24ndCBiZSB0ZW1wdGVkIHRvIGNoYW5nZSB0aGlzIHRvIGBPYmplY3QuZW50cmllc2AuIFdlIGNhbGxcbiAgICAvLyBgX3VwZGF0ZVN1YnNjcmlwdGlvbnNgIHJlY3Vyc2l2ZWx5IHdoZW4gcHJvY2Vzc2luZyB0aGUgc3RhdGUsXG4gICAgLy8gc28gaXQncyBpbXBvcnRhbnQgdGhhdCB3ZSBsb29rIHVwIHRoZSAqY3VycmVudCogdmVyc2lvbiBvZlxuICAgIC8vIGVhY2ggc3Vic2NyaXB0aW9uLCBldmVyeSB0aW1lIHdlIHByb2Nlc3MgYSBoYXNoLlxuICAgIE9iamVjdC5rZXlzKHRoaXMuX3N1YnNjcmlwdGlvbnNCeUhhc2gpLm1hcChhc3luYyBoYXNoID0+IHtcbiAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHRoaXMuX3N1YnNjcmlwdGlvbnNCeUhhc2hbaGFzaF07XG4gICAgICBpZiAoc3Vic2NyaXB0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gVGhpcyBlbnRyeSBoYXMgc2luY2UgYmVlbiBkZWxldGVkLiBTa2lwLlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHN1YnNjcmlwdGlvbi5zdGF0ZSkge1xuICAgICAgICBjYXNlICdwZW5kaW5nJzpcbiAgICAgICAgY2FzZSAndW5zdWJzY3JpYmVkJzpcbiAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9uLmNhbGxiYWNrcy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFlvdSBjYW4gZW5kIHVwIGhlcmUgd2hlbjpcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAtIGEgc3Vic2NyaXB0aW9uIGhhcyByZWNlbnRseSB1bnN1YnNjcmliZWRcbiAgICAgICAgICAgICAqICAgd2l0aG91dCBoYXZpbmcgbmV3IGNhbGxiYWNrcyBhZGRlZCB0byBpdFxuICAgICAgICAgICAgICogICB3aGlsZSB0aGUgdW5zdWJzY3JpYmUgd2FzIGluIGZsaWdodCwgb3JcbiAgICAgICAgICAgICAqIC0gd2hlbiBhIHBlbmRpbmcgc3Vic2NyaXB0aW9uIGhhcyBpdHNcbiAgICAgICAgICAgICAqICAgbGlzdGVuZXJzIHJlbW92ZWQgYmVmb3JlIGEgcmVxdWVzdCB3YXNcbiAgICAgICAgICAgICAqICAgc2VudCB0byB0aGUgc2VydmVyLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEJlaW5nIHRoYXQgbm9ib2R5IGlzIGludGVyZXN0ZWQgaW4gdGhpc1xuICAgICAgICAgICAgICogc3Vic2NyaXB0aW9uIGFueSBsb25nZXIsIGRlbGV0ZSBpdC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3N1YnNjcmlwdGlvbnNCeUhhc2hbaGFzaF07XG4gICAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9uLnN0YXRlID09PSAndW5zdWJzY3JpYmVkJykge1xuICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fc3Vic2NyaXB0aW9uQ2FsbGJhY2tzQnlTZXJ2ZXJTdWJzY3JpcHRpb25JZFtzdWJzY3JpcHRpb24uc2VydmVyU3Vic2NyaXB0aW9uSWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5fdXBkYXRlU3Vic2NyaXB0aW9ucygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhd2FpdCAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAgICBtZXRob2RcbiAgICAgICAgICAgIH0gPSBzdWJzY3JpcHRpb247XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB0aGlzLl9zZXRTdWJzY3JpcHRpb24oaGFzaCwge1xuICAgICAgICAgICAgICAgIC4uLnN1YnNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ3N1YnNjcmliaW5nJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY29uc3Qgc2VydmVyU3Vic2NyaXB0aW9uSWQgPSBhd2FpdCB0aGlzLl9ycGNXZWJTb2NrZXQuY2FsbChtZXRob2QsIGFyZ3MpO1xuICAgICAgICAgICAgICB0aGlzLl9zZXRTdWJzY3JpcHRpb24oaGFzaCwge1xuICAgICAgICAgICAgICAgIC4uLnN1YnNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICBzZXJ2ZXJTdWJzY3JpcHRpb25JZCxcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ3N1YnNjcmliZWQnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25DYWxsYmFja3NCeVNlcnZlclN1YnNjcmlwdGlvbklkW3NlcnZlclN1YnNjcmlwdGlvbklkXSA9IHN1YnNjcmlwdGlvbi5jYWxsYmFja3M7XG4gICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3VwZGF0ZVN1YnNjcmlwdGlvbnMoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYCR7bWV0aG9kfSBlcnJvciBmb3IgYXJndW1lbnRgLCBhcmdzLCBlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghaXNDdXJyZW50Q29ubmVjdGlvblN0aWxsQWN0aXZlKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gVE9ETzogTWF5YmUgYWRkIGFuICdlcnJvcmVkJyBzdGF0ZSBvciBhIHJldHJ5IGxpbWl0P1xuICAgICAgICAgICAgICB0aGlzLl9zZXRTdWJzY3JpcHRpb24oaGFzaCwge1xuICAgICAgICAgICAgICAgIC4uLnN1YnNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ3BlbmRpbmcnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBhd2FpdCB0aGlzLl91cGRhdGVTdWJzY3JpcHRpb25zKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc3Vic2NyaWJlZCc6XG4gICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbi5jYWxsYmFja3Muc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgLy8gQnkgdGhlIHRpbWUgd2Ugc3VjY2Vzc2Z1bGx5IHNldCB1cCBhIHN1YnNjcmlwdGlvblxuICAgICAgICAgICAgLy8gd2l0aCB0aGUgc2VydmVyLCB0aGUgY2xpZW50IHN0b3BwZWQgY2FyaW5nIGFib3V0IGl0LlxuICAgICAgICAgICAgLy8gVGVhciBpdCBkb3duIG5vdy5cbiAgICAgICAgICAgIGF3YWl0IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICBzZXJ2ZXJTdWJzY3JpcHRpb25JZCxcbiAgICAgICAgICAgICAgICB1bnN1YnNjcmliZU1ldGhvZFxuICAgICAgICAgICAgICB9ID0gc3Vic2NyaXB0aW9uO1xuICAgICAgICAgICAgICBpZiAodGhpcy5fc3Vic2NyaXB0aW9uc0F1dG9EaXNwb3NlZEJ5UnBjLmhhcyhzZXJ2ZXJTdWJzY3JpcHRpb25JZCkpIHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBTcGVjaWFsIGNhc2UuXG4gICAgICAgICAgICAgICAgICogSWYgd2UncmUgZGVhbGluZyB3aXRoIGEgc3Vic2NyaXB0aW9uIHRoYXQgaGFzIGJlZW4gYXV0by1cbiAgICAgICAgICAgICAgICAgKiBkaXNwb3NlZCBieSB0aGUgUlBDLCB0aGVuIHdlIGNhbiBza2lwIHRoZSBSUEMgY2FsbCB0b1xuICAgICAgICAgICAgICAgICAqIHRlYXIgZG93biB0aGUgc3Vic2NyaXB0aW9uIGhlcmUuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBOT1RFOiBUaGVyZSBpcyBhIHByb3Bvc2FsIHRvIGVsaW1pbmF0ZSB0aGlzIHNwZWNpYWwgY2FzZSwgaGVyZTpcbiAgICAgICAgICAgICAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vc29sYW5hLWxhYnMvc29sYW5hL2lzc3Vlcy8xODg5MlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnNBdXRvRGlzcG9zZWRCeVJwYy5kZWxldGUoc2VydmVyU3Vic2NyaXB0aW9uSWQpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldFN1YnNjcmlwdGlvbihoYXNoLCB7XG4gICAgICAgICAgICAgICAgICAuLi5zdWJzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICBzdGF0ZTogJ3Vuc3Vic2NyaWJpbmcnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0U3Vic2NyaXB0aW9uKGhhc2gsIHtcbiAgICAgICAgICAgICAgICAgIC4uLnN1YnNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgIHN0YXRlOiAndW5zdWJzY3JpYmluZydcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fcnBjV2ViU29ja2V0LmNhbGwodW5zdWJzY3JpYmVNZXRob2QsIFtzZXJ2ZXJTdWJzY3JpcHRpb25JZF0pO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgJHt1bnN1YnNjcmliZU1ldGhvZH0gZXJyb3I6YCwgZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmICghaXNDdXJyZW50Q29ubmVjdGlvblN0aWxsQWN0aXZlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgLy8gVE9ETzogTWF5YmUgYWRkIGFuICdlcnJvcmVkJyBzdGF0ZSBvciBhIHJldHJ5IGxpbWl0P1xuICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0U3Vic2NyaXB0aW9uKGhhc2gsIHtcbiAgICAgICAgICAgICAgICAgICAgLi4uc3Vic2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZTogJ3N1YnNjcmliZWQnXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3VwZGF0ZVN1YnNjcmlwdGlvbnMoKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5fc2V0U3Vic2NyaXB0aW9uKGhhc2gsIHtcbiAgICAgICAgICAgICAgICAuLi5zdWJzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgc3RhdGU6ICd1bnN1YnNjcmliZWQnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBhd2FpdCB0aGlzLl91cGRhdGVTdWJzY3JpcHRpb25zKCk7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9KSk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfaGFuZGxlU2VydmVyTm90aWZpY2F0aW9uKHNlcnZlclN1YnNjcmlwdGlvbklkLCBjYWxsYmFja0FyZ3MpIHtcbiAgICBjb25zdCBjYWxsYmFja3MgPSB0aGlzLl9zdWJzY3JpcHRpb25DYWxsYmFja3NCeVNlcnZlclN1YnNjcmlwdGlvbklkW3NlcnZlclN1YnNjcmlwdGlvbklkXTtcbiAgICBpZiAoY2FsbGJhY2tzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGJhY2tzLmZvckVhY2goY2IgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2IoXG4gICAgICAgIC8vIEkgZmFpbGVkIHRvIGZpbmQgYSB3YXkgdG8gY29udmluY2UgVHlwZVNjcmlwdCB0aGF0IGBjYmAgaXMgb2YgdHlwZVxuICAgICAgICAvLyBgVENhbGxiYWNrYCB3aGljaCBpcyBjZXJ0YWlubHkgY29tcGF0aWJsZSB3aXRoIGBQYXJhbWV0ZXJzPFRDYWxsYmFjaz5gLlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy80NzYxNVxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIC4uLmNhbGxiYWNrQXJncyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfd3NPbkFjY291bnROb3RpZmljYXRpb24obm90aWZpY2F0aW9uKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmVzdWx0LFxuICAgICAgc3Vic2NyaXB0aW9uXG4gICAgfSA9IHN1cGVyc3RydWN0LmNyZWF0ZShub3RpZmljYXRpb24sIEFjY291bnROb3RpZmljYXRpb25SZXN1bHQpO1xuICAgIHRoaXMuX2hhbmRsZVNlcnZlck5vdGlmaWNhdGlvbihzdWJzY3JpcHRpb24sIFtyZXN1bHQudmFsdWUsIHJlc3VsdC5jb250ZXh0XSk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfbWFrZVN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb25Db25maWcsXG4gIC8qKlxuICAgKiBXaGVuIHByZXBhcmluZyBgYXJnc2AgZm9yIGEgY2FsbCB0byBgX21ha2VTdWJzY3JpcHRpb25gLCBiZSBzdXJlXG4gICAqIHRvIGNhcmVmdWxseSBhcHBseSBhIGRlZmF1bHQgYGNvbW1pdG1lbnRgIHByb3BlcnR5LCBpZiBuZWNlc3NhcnkuXG4gICAqXG4gICAqIC0gSWYgdGhlIHVzZXIgc3VwcGxpZWQgYSBgY29tbWl0bWVudGAgdXNlIHRoYXQuXG4gICAqIC0gT3RoZXJ3aXNlLCBpZiB0aGUgYENvbm5lY3Rpb246OmNvbW1pdG1lbnRgIGlzIHNldCwgdXNlIHRoYXQuXG4gICAqIC0gT3RoZXJ3aXNlLCBzZXQgaXQgdG8gdGhlIFJQQyBzZXJ2ZXIgZGVmYXVsdDogYGZpbmFsaXplZGAuXG4gICAqXG4gICAqIFRoaXMgaXMgZXh0cmVtZWx5IGltcG9ydGFudCB0byBlbnN1cmUgdGhhdCB0aGVzZSB0d28gZnVuZGFtZW50YWxseVxuICAgKiBpZGVudGljYWwgc3Vic2NyaXB0aW9ucyBwcm9kdWNlIHRoZSBzYW1lIGlkZW50aWZ5aW5nIGhhc2g6XG4gICAqXG4gICAqIC0gQSBzdWJzY3JpcHRpb24gbWFkZSB3aXRob3V0IHNwZWNpZnlpbmcgYSBjb21taXRtZW50LlxuICAgKiAtIEEgc3Vic2NyaXB0aW9uIG1hZGUgd2hlcmUgdGhlIGNvbW1pdG1lbnQgc3BlY2lmaWVkIGlzIHRoZSBzYW1lXG4gICAqICAgYXMgdGhlIGRlZmF1bHQgYXBwbGllZCB0byB0aGUgc3Vic2NyaXB0aW9uIGFib3ZlLlxuICAgKlxuICAgKiBFeGFtcGxlOyB0aGVzZSB0d28gc3Vic2NyaXB0aW9ucyBtdXN0IHByb2R1Y2UgdGhlIHNhbWUgaGFzaDpcbiAgICpcbiAgICogLSBBbiBgYWNjb3VudFN1YnNjcmliZWAgc3Vic2NyaXB0aW9uIGZvciBgJ1BVQktFWSdgXG4gICAqIC0gQW4gYGFjY291bnRTdWJzY3JpYmVgIHN1YnNjcmlwdGlvbiBmb3IgYCdQVUJLRVknYCB3aXRoIGNvbW1pdG1lbnRcbiAgICogICBgJ2ZpbmFsaXplZCdgLlxuICAgKlxuICAgKiBTZWUgdGhlICdtYWtpbmcgYSBzdWJzY3JpcHRpb24gd2l0aCBkZWZhdWx0ZWQgcGFyYW1zIG9taXR0ZWQnIHRlc3RcbiAgICogaW4gYGNvbm5lY3Rpb24tc3Vic2NyaXB0aW9ucy50c2AgZm9yIG1vcmUuXG4gICAqL1xuICBhcmdzKSB7XG4gICAgY29uc3QgY2xpZW50U3Vic2NyaXB0aW9uSWQgPSB0aGlzLl9uZXh0Q2xpZW50U3Vic2NyaXB0aW9uSWQrKztcbiAgICBjb25zdCBoYXNoID0gZmFzdFN0YWJsZVN0cmluZ2lmeSQxKFtzdWJzY3JpcHRpb25Db25maWcubWV0aG9kLCBhcmdzXSwgdHJ1ZSAvKiBpc0FycmF5UHJvcCAqLyk7XG4gICAgY29uc3QgZXhpc3RpbmdTdWJzY3JpcHRpb24gPSB0aGlzLl9zdWJzY3JpcHRpb25zQnlIYXNoW2hhc2hdO1xuICAgIGlmIChleGlzdGluZ1N1YnNjcmlwdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9zdWJzY3JpcHRpb25zQnlIYXNoW2hhc2hdID0ge1xuICAgICAgICAuLi5zdWJzY3JpcHRpb25Db25maWcsXG4gICAgICAgIGFyZ3MsXG4gICAgICAgIGNhbGxiYWNrczogbmV3IFNldChbc3Vic2NyaXB0aW9uQ29uZmlnLmNhbGxiYWNrXSksXG4gICAgICAgIHN0YXRlOiAncGVuZGluZydcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4aXN0aW5nU3Vic2NyaXB0aW9uLmNhbGxiYWNrcy5hZGQoc3Vic2NyaXB0aW9uQ29uZmlnLmNhbGxiYWNrKTtcbiAgICB9XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uSGFzaEJ5Q2xpZW50U3Vic2NyaXB0aW9uSWRbY2xpZW50U3Vic2NyaXB0aW9uSWRdID0gaGFzaDtcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25EaXNwb3NlRnVuY3Rpb25zQnlDbGllbnRTdWJzY3JpcHRpb25JZFtjbGllbnRTdWJzY3JpcHRpb25JZF0gPSBhc3luYyAoKSA9PiB7XG4gICAgICBkZWxldGUgdGhpcy5fc3Vic2NyaXB0aW9uRGlzcG9zZUZ1bmN0aW9uc0J5Q2xpZW50U3Vic2NyaXB0aW9uSWRbY2xpZW50U3Vic2NyaXB0aW9uSWRdO1xuICAgICAgZGVsZXRlIHRoaXMuX3N1YnNjcmlwdGlvbkhhc2hCeUNsaWVudFN1YnNjcmlwdGlvbklkW2NsaWVudFN1YnNjcmlwdGlvbklkXTtcbiAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHRoaXMuX3N1YnNjcmlwdGlvbnNCeUhhc2hbaGFzaF07XG4gICAgICBhc3NlcnQoc3Vic2NyaXB0aW9uICE9PSB1bmRlZmluZWQsIGBDb3VsZCBub3QgZmluZCBhIFxcYFN1YnNjcmlwdGlvblxcYCB3aGVuIHRlYXJpbmcgZG93biBjbGllbnQgc3Vic2NyaXB0aW9uICMke2NsaWVudFN1YnNjcmlwdGlvbklkfWApO1xuICAgICAgc3Vic2NyaXB0aW9uLmNhbGxiYWNrcy5kZWxldGUoc3Vic2NyaXB0aW9uQ29uZmlnLmNhbGxiYWNrKTtcbiAgICAgIGF3YWl0IHRoaXMuX3VwZGF0ZVN1YnNjcmlwdGlvbnMoKTtcbiAgICB9O1xuICAgIHRoaXMuX3VwZGF0ZVN1YnNjcmlwdGlvbnMoKTtcbiAgICByZXR1cm4gY2xpZW50U3Vic2NyaXB0aW9uSWQ7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBjYWxsYmFjayB0byBiZSBpbnZva2VkIHdoZW5ldmVyIHRoZSBzcGVjaWZpZWQgYWNjb3VudCBjaGFuZ2VzXG4gICAqXG4gICAqIEBwYXJhbSBwdWJsaWNLZXkgUHVibGljIGtleSBvZiB0aGUgYWNjb3VudCB0byBtb25pdG9yXG4gICAqIEBwYXJhbSBjYWxsYmFjayBGdW5jdGlvbiB0byBpbnZva2Ugd2hlbmV2ZXIgdGhlIGFjY291bnQgaXMgY2hhbmdlZFxuICAgKiBAcGFyYW0gY29tbWl0bWVudCBTcGVjaWZ5IHRoZSBjb21taXRtZW50IGxldmVsIGFjY291bnQgY2hhbmdlcyBtdXN0IHJlYWNoIGJlZm9yZSBub3RpZmljYXRpb25cbiAgICogQHJldHVybiBzdWJzY3JpcHRpb24gaWRcbiAgICovXG4gIG9uQWNjb3VudENoYW5nZShwdWJsaWNLZXksIGNhbGxiYWNrLCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbcHVibGljS2V5LnRvQmFzZTU4KCldLCBjb21taXRtZW50IHx8IHRoaXMuX2NvbW1pdG1lbnQgfHwgJ2ZpbmFsaXplZCcsXG4gICAgLy8gQXBwbHkgY29ubmVjdGlvbi9zZXJ2ZXIgZGVmYXVsdC5cbiAgICAnYmFzZTY0Jyk7XG4gICAgcmV0dXJuIHRoaXMuX21ha2VTdWJzY3JpcHRpb24oe1xuICAgICAgY2FsbGJhY2ssXG4gICAgICBtZXRob2Q6ICdhY2NvdW50U3Vic2NyaWJlJyxcbiAgICAgIHVuc3Vic2NyaWJlTWV0aG9kOiAnYWNjb3VudFVuc3Vic2NyaWJlJ1xuICAgIH0sIGFyZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcmVnaXN0ZXIgYW4gYWNjb3VudCBub3RpZmljYXRpb24gY2FsbGJhY2tcbiAgICpcbiAgICogQHBhcmFtIGNsaWVudFN1YnNjcmlwdGlvbklkIGNsaWVudCBzdWJzY3JpcHRpb24gaWQgdG8gZGVyZWdpc3RlclxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlQWNjb3VudENoYW5nZUxpc3RlbmVyKGNsaWVudFN1YnNjcmlwdGlvbklkKSB7XG4gICAgYXdhaXQgdGhpcy5fdW5zdWJzY3JpYmVDbGllbnRTdWJzY3JpcHRpb24oY2xpZW50U3Vic2NyaXB0aW9uSWQsICdhY2NvdW50IGNoYW5nZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3dzT25Qcm9ncmFtQWNjb3VudE5vdGlmaWNhdGlvbihub3RpZmljYXRpb24pIHtcbiAgICBjb25zdCB7XG4gICAgICByZXN1bHQsXG4gICAgICBzdWJzY3JpcHRpb25cbiAgICB9ID0gc3VwZXJzdHJ1Y3QuY3JlYXRlKG5vdGlmaWNhdGlvbiwgUHJvZ3JhbUFjY291bnROb3RpZmljYXRpb25SZXN1bHQpO1xuICAgIHRoaXMuX2hhbmRsZVNlcnZlck5vdGlmaWNhdGlvbihzdWJzY3JpcHRpb24sIFt7XG4gICAgICBhY2NvdW50SWQ6IHJlc3VsdC52YWx1ZS5wdWJrZXksXG4gICAgICBhY2NvdW50SW5mbzogcmVzdWx0LnZhbHVlLmFjY291bnRcbiAgICB9LCByZXN1bHQuY29udGV4dF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aGVuZXZlciBhY2NvdW50cyBvd25lZCBieSB0aGVcbiAgICogc3BlY2lmaWVkIHByb2dyYW0gY2hhbmdlXG4gICAqXG4gICAqIEBwYXJhbSBwcm9ncmFtSWQgUHVibGljIGtleSBvZiB0aGUgcHJvZ3JhbSB0byBtb25pdG9yXG4gICAqIEBwYXJhbSBjYWxsYmFjayBGdW5jdGlvbiB0byBpbnZva2Ugd2hlbmV2ZXIgdGhlIGFjY291bnQgaXMgY2hhbmdlZFxuICAgKiBAcGFyYW0gY29tbWl0bWVudCBTcGVjaWZ5IHRoZSBjb21taXRtZW50IGxldmVsIGFjY291bnQgY2hhbmdlcyBtdXN0IHJlYWNoIGJlZm9yZSBub3RpZmljYXRpb25cbiAgICogQHBhcmFtIGZpbHRlcnMgVGhlIHByb2dyYW0gYWNjb3VudCBmaWx0ZXJzIHRvIHBhc3MgaW50byB0aGUgUlBDIG1ldGhvZFxuICAgKiBAcmV0dXJuIHN1YnNjcmlwdGlvbiBpZFxuICAgKi9cbiAgb25Qcm9ncmFtQWNjb3VudENoYW5nZShwcm9ncmFtSWQsIGNhbGxiYWNrLCBjb21taXRtZW50LCBmaWx0ZXJzKSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbcHJvZ3JhbUlkLnRvQmFzZTU4KCldLCBjb21taXRtZW50IHx8IHRoaXMuX2NvbW1pdG1lbnQgfHwgJ2ZpbmFsaXplZCcsXG4gICAgLy8gQXBwbHkgY29ubmVjdGlvbi9zZXJ2ZXIgZGVmYXVsdC5cbiAgICAnYmFzZTY0JyAvKiBlbmNvZGluZyAqLywgZmlsdGVycyA/IHtcbiAgICAgIGZpbHRlcnM6IGZpbHRlcnNcbiAgICB9IDogdW5kZWZpbmVkIC8qIGV4dHJhICovKTtcbiAgICByZXR1cm4gdGhpcy5fbWFrZVN1YnNjcmlwdGlvbih7XG4gICAgICBjYWxsYmFjayxcbiAgICAgIG1ldGhvZDogJ3Byb2dyYW1TdWJzY3JpYmUnLFxuICAgICAgdW5zdWJzY3JpYmVNZXRob2Q6ICdwcm9ncmFtVW5zdWJzY3JpYmUnXG4gICAgfSwgYXJncyk7XG4gIH1cblxuICAvKipcbiAgICogRGVyZWdpc3RlciBhbiBhY2NvdW50IG5vdGlmaWNhdGlvbiBjYWxsYmFja1xuICAgKlxuICAgKiBAcGFyYW0gY2xpZW50U3Vic2NyaXB0aW9uSWQgY2xpZW50IHN1YnNjcmlwdGlvbiBpZCB0byBkZXJlZ2lzdGVyXG4gICAqL1xuICBhc3luYyByZW1vdmVQcm9ncmFtQWNjb3VudENoYW5nZUxpc3RlbmVyKGNsaWVudFN1YnNjcmlwdGlvbklkKSB7XG4gICAgYXdhaXQgdGhpcy5fdW5zdWJzY3JpYmVDbGllbnRTdWJzY3JpcHRpb24oY2xpZW50U3Vic2NyaXB0aW9uSWQsICdwcm9ncmFtIGFjY291bnQgY2hhbmdlJyk7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aGVuZXZlciBsb2dzIGFyZSBlbWl0dGVkLlxuICAgKi9cbiAgb25Mb2dzKGZpbHRlciwgY2FsbGJhY2ssIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFt0eXBlb2YgZmlsdGVyID09PSAnb2JqZWN0JyA/IHtcbiAgICAgIG1lbnRpb25zOiBbZmlsdGVyLnRvU3RyaW5nKCldXG4gICAgfSA6IGZpbHRlcl0sIGNvbW1pdG1lbnQgfHwgdGhpcy5fY29tbWl0bWVudCB8fCAnZmluYWxpemVkJyAvLyBBcHBseSBjb25uZWN0aW9uL3NlcnZlciBkZWZhdWx0LlxuICAgICk7XG4gICAgcmV0dXJuIHRoaXMuX21ha2VTdWJzY3JpcHRpb24oe1xuICAgICAgY2FsbGJhY2ssXG4gICAgICBtZXRob2Q6ICdsb2dzU3Vic2NyaWJlJyxcbiAgICAgIHVuc3Vic2NyaWJlTWV0aG9kOiAnbG9nc1Vuc3Vic2NyaWJlJ1xuICAgIH0sIGFyZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcmVnaXN0ZXIgYSBsb2dzIGNhbGxiYWNrLlxuICAgKlxuICAgKiBAcGFyYW0gY2xpZW50U3Vic2NyaXB0aW9uSWQgY2xpZW50IHN1YnNjcmlwdGlvbiBpZCB0byBkZXJlZ2lzdGVyLlxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlT25Mb2dzTGlzdGVuZXIoY2xpZW50U3Vic2NyaXB0aW9uSWQpIHtcbiAgICBhd2FpdCB0aGlzLl91bnN1YnNjcmliZUNsaWVudFN1YnNjcmlwdGlvbihjbGllbnRTdWJzY3JpcHRpb25JZCwgJ2xvZ3MnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF93c09uTG9nc05vdGlmaWNhdGlvbihub3RpZmljYXRpb24pIHtcbiAgICBjb25zdCB7XG4gICAgICByZXN1bHQsXG4gICAgICBzdWJzY3JpcHRpb25cbiAgICB9ID0gc3VwZXJzdHJ1Y3QuY3JlYXRlKG5vdGlmaWNhdGlvbiwgTG9nc05vdGlmaWNhdGlvblJlc3VsdCk7XG4gICAgdGhpcy5faGFuZGxlU2VydmVyTm90aWZpY2F0aW9uKHN1YnNjcmlwdGlvbiwgW3Jlc3VsdC52YWx1ZSwgcmVzdWx0LmNvbnRleHRdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF93c09uU2xvdE5vdGlmaWNhdGlvbihub3RpZmljYXRpb24pIHtcbiAgICBjb25zdCB7XG4gICAgICByZXN1bHQsXG4gICAgICBzdWJzY3JpcHRpb25cbiAgICB9ID0gc3VwZXJzdHJ1Y3QuY3JlYXRlKG5vdGlmaWNhdGlvbiwgU2xvdE5vdGlmaWNhdGlvblJlc3VsdCk7XG4gICAgdGhpcy5faGFuZGxlU2VydmVyTm90aWZpY2F0aW9uKHN1YnNjcmlwdGlvbiwgW3Jlc3VsdF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB1cG9uIHNsb3QgY2hhbmdlc1xuICAgKlxuICAgKiBAcGFyYW0gY2FsbGJhY2sgRnVuY3Rpb24gdG8gaW52b2tlIHdoZW5ldmVyIHRoZSBzbG90IGNoYW5nZXNcbiAgICogQHJldHVybiBzdWJzY3JpcHRpb24gaWRcbiAgICovXG4gIG9uU2xvdENoYW5nZShjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLl9tYWtlU3Vic2NyaXB0aW9uKHtcbiAgICAgIGNhbGxiYWNrLFxuICAgICAgbWV0aG9kOiAnc2xvdFN1YnNjcmliZScsXG4gICAgICB1bnN1YnNjcmliZU1ldGhvZDogJ3Nsb3RVbnN1YnNjcmliZSdcbiAgICB9LCBbXSAvKiBhcmdzICovKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXJlZ2lzdGVyIGEgc2xvdCBub3RpZmljYXRpb24gY2FsbGJhY2tcbiAgICpcbiAgICogQHBhcmFtIGNsaWVudFN1YnNjcmlwdGlvbklkIGNsaWVudCBzdWJzY3JpcHRpb24gaWQgdG8gZGVyZWdpc3RlclxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlU2xvdENoYW5nZUxpc3RlbmVyKGNsaWVudFN1YnNjcmlwdGlvbklkKSB7XG4gICAgYXdhaXQgdGhpcy5fdW5zdWJzY3JpYmVDbGllbnRTdWJzY3JpcHRpb24oY2xpZW50U3Vic2NyaXB0aW9uSWQsICdzbG90IGNoYW5nZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3dzT25TbG90VXBkYXRlc05vdGlmaWNhdGlvbihub3RpZmljYXRpb24pIHtcbiAgICBjb25zdCB7XG4gICAgICByZXN1bHQsXG4gICAgICBzdWJzY3JpcHRpb25cbiAgICB9ID0gc3VwZXJzdHJ1Y3QuY3JlYXRlKG5vdGlmaWNhdGlvbiwgU2xvdFVwZGF0ZU5vdGlmaWNhdGlvblJlc3VsdCk7XG4gICAgdGhpcy5faGFuZGxlU2VydmVyTm90aWZpY2F0aW9uKHN1YnNjcmlwdGlvbiwgW3Jlc3VsdF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB1cG9uIHNsb3QgdXBkYXRlcy4ge0BsaW5rIFNsb3RVcGRhdGV9J3NcbiAgICogbWF5IGJlIHVzZWZ1bCB0byB0cmFjayBsaXZlIHByb2dyZXNzIG9mIGEgY2x1c3Rlci5cbiAgICpcbiAgICogQHBhcmFtIGNhbGxiYWNrIEZ1bmN0aW9uIHRvIGludm9rZSB3aGVuZXZlciB0aGUgc2xvdCB1cGRhdGVzXG4gICAqIEByZXR1cm4gc3Vic2NyaXB0aW9uIGlkXG4gICAqL1xuICBvblNsb3RVcGRhdGUoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5fbWFrZVN1YnNjcmlwdGlvbih7XG4gICAgICBjYWxsYmFjayxcbiAgICAgIG1ldGhvZDogJ3Nsb3RzVXBkYXRlc1N1YnNjcmliZScsXG4gICAgICB1bnN1YnNjcmliZU1ldGhvZDogJ3Nsb3RzVXBkYXRlc1Vuc3Vic2NyaWJlJ1xuICAgIH0sIFtdIC8qIGFyZ3MgKi8pO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcmVnaXN0ZXIgYSBzbG90IHVwZGF0ZSBub3RpZmljYXRpb24gY2FsbGJhY2tcbiAgICpcbiAgICogQHBhcmFtIGNsaWVudFN1YnNjcmlwdGlvbklkIGNsaWVudCBzdWJzY3JpcHRpb24gaWQgdG8gZGVyZWdpc3RlclxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlU2xvdFVwZGF0ZUxpc3RlbmVyKGNsaWVudFN1YnNjcmlwdGlvbklkKSB7XG4gICAgYXdhaXQgdGhpcy5fdW5zdWJzY3JpYmVDbGllbnRTdWJzY3JpcHRpb24oY2xpZW50U3Vic2NyaXB0aW9uSWQsICdzbG90IHVwZGF0ZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuICBhc3luYyBfdW5zdWJzY3JpYmVDbGllbnRTdWJzY3JpcHRpb24oY2xpZW50U3Vic2NyaXB0aW9uSWQsIHN1YnNjcmlwdGlvbk5hbWUpIHtcbiAgICBjb25zdCBkaXNwb3NlID0gdGhpcy5fc3Vic2NyaXB0aW9uRGlzcG9zZUZ1bmN0aW9uc0J5Q2xpZW50U3Vic2NyaXB0aW9uSWRbY2xpZW50U3Vic2NyaXB0aW9uSWRdO1xuICAgIGlmIChkaXNwb3NlKSB7XG4gICAgICBhd2FpdCBkaXNwb3NlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybignSWdub3JlZCB1bnN1YnNjcmliZSByZXF1ZXN0IGJlY2F1c2UgYW4gYWN0aXZlIHN1YnNjcmlwdGlvbiB3aXRoIGlkICcgKyBgXFxgJHtjbGllbnRTdWJzY3JpcHRpb25JZH1cXGAgZm9yICcke3N1YnNjcmlwdGlvbk5hbWV9JyBldmVudHMgYCArICdjb3VsZCBub3QgYmUgZm91bmQuJyk7XG4gICAgfVxuICB9XG4gIF9idWlsZEFyZ3MoYXJncywgb3ZlcnJpZGUsIGVuY29kaW5nLCBleHRyYSkge1xuICAgIGNvbnN0IGNvbW1pdG1lbnQgPSBvdmVycmlkZSB8fCB0aGlzLl9jb21taXRtZW50O1xuICAgIGlmIChjb21taXRtZW50IHx8IGVuY29kaW5nIHx8IGV4dHJhKSB7XG4gICAgICBsZXQgb3B0aW9ucyA9IHt9O1xuICAgICAgaWYgKGVuY29kaW5nKSB7XG4gICAgICAgIG9wdGlvbnMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgICAgIH1cbiAgICAgIGlmIChjb21taXRtZW50KSB7XG4gICAgICAgIG9wdGlvbnMuY29tbWl0bWVudCA9IGNvbW1pdG1lbnQ7XG4gICAgICB9XG4gICAgICBpZiAoZXh0cmEpIHtcbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24ob3B0aW9ucywgZXh0cmEpO1xuICAgICAgfVxuICAgICAgYXJncy5wdXNoKG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gYXJncztcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKGFyZ3MsIG92ZXJyaWRlLCBlbmNvZGluZywgZXh0cmEpIHtcbiAgICBjb25zdCBjb21taXRtZW50ID0gb3ZlcnJpZGUgfHwgdGhpcy5fY29tbWl0bWVudDtcbiAgICBpZiAoY29tbWl0bWVudCAmJiAhWydjb25maXJtZWQnLCAnZmluYWxpemVkJ10uaW5jbHVkZXMoY29tbWl0bWVudCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVXNpbmcgQ29ubmVjdGlvbiB3aXRoIGRlZmF1bHQgY29tbWl0bWVudDogYCcgKyB0aGlzLl9jb21taXRtZW50ICsgJ2AsIGJ1dCBtZXRob2QgcmVxdWlyZXMgYXQgbGVhc3QgYGNvbmZpcm1lZGAnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2J1aWxkQXJncyhhcmdzLCBvdmVycmlkZSwgZW5jb2RpbmcsIGV4dHJhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF93c09uU2lnbmF0dXJlTm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbikge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlc3VsdCxcbiAgICAgIHN1YnNjcmlwdGlvblxuICAgIH0gPSBzdXBlcnN0cnVjdC5jcmVhdGUobm90aWZpY2F0aW9uLCBTaWduYXR1cmVOb3RpZmljYXRpb25SZXN1bHQpO1xuICAgIGlmIChyZXN1bHQudmFsdWUgIT09ICdyZWNlaXZlZFNpZ25hdHVyZScpIHtcbiAgICAgIC8qKlxuICAgICAgICogU3BlY2lhbCBjYXNlLlxuICAgICAgICogQWZ0ZXIgYSBzaWduYXR1cmUgaXMgcHJvY2Vzc2VkLCBSUENzIGF1dG9tYXRpY2FsbHkgZGlzcG9zZSBvZiB0aGVcbiAgICAgICAqIHN1YnNjcmlwdGlvbiBvbiB0aGUgc2VydmVyIHNpZGUuIFdlIG5lZWQgdG8gdHJhY2sgd2hpY2ggb2YgdGhlc2VcbiAgICAgICAqIHN1YnNjcmlwdGlvbnMgaGF2ZSBiZWVuIGRpc3Bvc2VkIGluIHN1Y2ggYSB3YXksIHNvIHRoYXQgd2Uga25vd1xuICAgICAgICogd2hldGhlciB0aGUgY2xpZW50IGlzIGRlYWxpbmcgd2l0aCBhIG5vdC15ZXQtcHJvY2Vzc2VkIHNpZ25hdHVyZVxuICAgICAgICogKGluIHdoaWNoIGNhc2Ugd2UgbXVzdCB0ZWFyIGRvd24gdGhlIHNlcnZlciBzdWJzY3JpcHRpb24pIG9yIGFuXG4gICAgICAgKiBhbHJlYWR5LXByb2Nlc3NlZCBzaWduYXR1cmUgKGluIHdoaWNoIGNhc2UgdGhlIGNsaWVudCBjYW4gc2ltcGx5XG4gICAgICAgKiBjbGVhciBvdXQgdGhlIHN1YnNjcmlwdGlvbiBsb2NhbGx5IHdpdGhvdXQgdGVsbGluZyB0aGUgc2VydmVyKS5cbiAgICAgICAqXG4gICAgICAgKiBOT1RFOiBUaGVyZSBpcyBhIHByb3Bvc2FsIHRvIGVsaW1pbmF0ZSB0aGlzIHNwZWNpYWwgY2FzZSwgaGVyZTpcbiAgICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zb2xhbmEtbGFicy9zb2xhbmEvaXNzdWVzLzE4ODkyXG4gICAgICAgKi9cbiAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnNBdXRvRGlzcG9zZWRCeVJwYy5hZGQoc3Vic2NyaXB0aW9uKTtcbiAgICB9XG4gICAgdGhpcy5faGFuZGxlU2VydmVyTm90aWZpY2F0aW9uKHN1YnNjcmlwdGlvbiwgcmVzdWx0LnZhbHVlID09PSAncmVjZWl2ZWRTaWduYXR1cmUnID8gW3tcbiAgICAgIHR5cGU6ICdyZWNlaXZlZCdcbiAgICB9LCByZXN1bHQuY29udGV4dF0gOiBbe1xuICAgICAgdHlwZTogJ3N0YXR1cycsXG4gICAgICByZXN1bHQ6IHJlc3VsdC52YWx1ZVxuICAgIH0sIHJlc3VsdC5jb250ZXh0XSk7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBjYWxsYmFjayB0byBiZSBpbnZva2VkIHVwb24gc2lnbmF0dXJlIHVwZGF0ZXNcbiAgICpcbiAgICogQHBhcmFtIHNpZ25hdHVyZSBUcmFuc2FjdGlvbiBzaWduYXR1cmUgc3RyaW5nIGluIGJhc2UgNThcbiAgICogQHBhcmFtIGNhbGxiYWNrIEZ1bmN0aW9uIHRvIGludm9rZSBvbiBzaWduYXR1cmUgbm90aWZpY2F0aW9uc1xuICAgKiBAcGFyYW0gY29tbWl0bWVudCBTcGVjaWZ5IHRoZSBjb21taXRtZW50IGxldmVsIHNpZ25hdHVyZSBtdXN0IHJlYWNoIGJlZm9yZSBub3RpZmljYXRpb25cbiAgICogQHJldHVybiBzdWJzY3JpcHRpb24gaWRcbiAgICovXG4gIG9uU2lnbmF0dXJlKHNpZ25hdHVyZSwgY2FsbGJhY2ssIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtzaWduYXR1cmVdLCBjb21taXRtZW50IHx8IHRoaXMuX2NvbW1pdG1lbnQgfHwgJ2ZpbmFsaXplZCcgLy8gQXBwbHkgY29ubmVjdGlvbi9zZXJ2ZXIgZGVmYXVsdC5cbiAgICApO1xuICAgIGNvbnN0IGNsaWVudFN1YnNjcmlwdGlvbklkID0gdGhpcy5fbWFrZVN1YnNjcmlwdGlvbih7XG4gICAgICBjYWxsYmFjazogKG5vdGlmaWNhdGlvbiwgY29udGV4dCkgPT4ge1xuICAgICAgICBpZiAobm90aWZpY2F0aW9uLnR5cGUgPT09ICdzdGF0dXMnKSB7XG4gICAgICAgICAgY2FsbGJhY2sobm90aWZpY2F0aW9uLnJlc3VsdCwgY29udGV4dCk7XG4gICAgICAgICAgLy8gU2lnbmF0dXJlcyBzdWJzY3JpcHRpb25zIGFyZSBhdXRvLXJlbW92ZWQgYnkgdGhlIFJQQyBzZXJ2aWNlXG4gICAgICAgICAgLy8gc28gbm8gbmVlZCB0byBleHBsaWNpdGx5IHNlbmQgYW4gdW5zdWJzY3JpYmUgbWVzc2FnZS5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVTaWduYXR1cmVMaXN0ZW5lcihjbGllbnRTdWJzY3JpcHRpb25JZCk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgICAgICAgICB9IGNhdGNoIChfZXJyKSB7XG4gICAgICAgICAgICAvLyBBbHJlYWR5IHJlbW92ZWQuXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbWV0aG9kOiAnc2lnbmF0dXJlU3Vic2NyaWJlJyxcbiAgICAgIHVuc3Vic2NyaWJlTWV0aG9kOiAnc2lnbmF0dXJlVW5zdWJzY3JpYmUnXG4gICAgfSwgYXJncyk7XG4gICAgcmV0dXJuIGNsaWVudFN1YnNjcmlwdGlvbklkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aGVuIGEgdHJhbnNhY3Rpb24gaXNcbiAgICogcmVjZWl2ZWQgYW5kL29yIHByb2Nlc3NlZC5cbiAgICpcbiAgICogQHBhcmFtIHNpZ25hdHVyZSBUcmFuc2FjdGlvbiBzaWduYXR1cmUgc3RyaW5nIGluIGJhc2UgNThcbiAgICogQHBhcmFtIGNhbGxiYWNrIEZ1bmN0aW9uIHRvIGludm9rZSBvbiBzaWduYXR1cmUgbm90aWZpY2F0aW9uc1xuICAgKiBAcGFyYW0gb3B0aW9ucyBFbmFibGUgcmVjZWl2ZWQgbm90aWZpY2F0aW9ucyBhbmQgc2V0IHRoZSBjb21taXRtZW50XG4gICAqICAgbGV2ZWwgdGhhdCBzaWduYXR1cmUgbXVzdCByZWFjaCBiZWZvcmUgbm90aWZpY2F0aW9uXG4gICAqIEByZXR1cm4gc3Vic2NyaXB0aW9uIGlkXG4gICAqL1xuICBvblNpZ25hdHVyZVdpdGhPcHRpb25zKHNpZ25hdHVyZSwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgLi4uZXh0cmFcbiAgICB9ID0ge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGNvbW1pdG1lbnQ6IG9wdGlvbnMgJiYgb3B0aW9ucy5jb21taXRtZW50IHx8IHRoaXMuX2NvbW1pdG1lbnQgfHwgJ2ZpbmFsaXplZCcgLy8gQXBwbHkgY29ubmVjdGlvbi9zZXJ2ZXIgZGVmYXVsdC5cbiAgICB9O1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW3NpZ25hdHVyZV0sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCAvKiBlbmNvZGluZyAqLywgZXh0cmEpO1xuICAgIGNvbnN0IGNsaWVudFN1YnNjcmlwdGlvbklkID0gdGhpcy5fbWFrZVN1YnNjcmlwdGlvbih7XG4gICAgICBjYWxsYmFjazogKG5vdGlmaWNhdGlvbiwgY29udGV4dCkgPT4ge1xuICAgICAgICBjYWxsYmFjayhub3RpZmljYXRpb24sIGNvbnRleHQpO1xuICAgICAgICAvLyBTaWduYXR1cmVzIHN1YnNjcmlwdGlvbnMgYXJlIGF1dG8tcmVtb3ZlZCBieSB0aGUgUlBDIHNlcnZpY2VcbiAgICAgICAgLy8gc28gbm8gbmVlZCB0byBleHBsaWNpdGx5IHNlbmQgYW4gdW5zdWJzY3JpYmUgbWVzc2FnZS5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLnJlbW92ZVNpZ25hdHVyZUxpc3RlbmVyKGNsaWVudFN1YnNjcmlwdGlvbklkKTtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgICAgICAgfSBjYXRjaCAoX2Vycikge1xuICAgICAgICAgIC8vIEFscmVhZHkgcmVtb3ZlZC5cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG1ldGhvZDogJ3NpZ25hdHVyZVN1YnNjcmliZScsXG4gICAgICB1bnN1YnNjcmliZU1ldGhvZDogJ3NpZ25hdHVyZVVuc3Vic2NyaWJlJ1xuICAgIH0sIGFyZ3MpO1xuICAgIHJldHVybiBjbGllbnRTdWJzY3JpcHRpb25JZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXJlZ2lzdGVyIGEgc2lnbmF0dXJlIG5vdGlmaWNhdGlvbiBjYWxsYmFja1xuICAgKlxuICAgKiBAcGFyYW0gY2xpZW50U3Vic2NyaXB0aW9uSWQgY2xpZW50IHN1YnNjcmlwdGlvbiBpZCB0byBkZXJlZ2lzdGVyXG4gICAqL1xuICBhc3luYyByZW1vdmVTaWduYXR1cmVMaXN0ZW5lcihjbGllbnRTdWJzY3JpcHRpb25JZCkge1xuICAgIGF3YWl0IHRoaXMuX3Vuc3Vic2NyaWJlQ2xpZW50U3Vic2NyaXB0aW9uKGNsaWVudFN1YnNjcmlwdGlvbklkLCAnc2lnbmF0dXJlIHJlc3VsdCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3dzT25Sb290Tm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbikge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlc3VsdCxcbiAgICAgIHN1YnNjcmlwdGlvblxuICAgIH0gPSBzdXBlcnN0cnVjdC5jcmVhdGUobm90aWZpY2F0aW9uLCBSb290Tm90aWZpY2F0aW9uUmVzdWx0KTtcbiAgICB0aGlzLl9oYW5kbGVTZXJ2ZXJOb3RpZmljYXRpb24oc3Vic2NyaXB0aW9uLCBbcmVzdWx0XSk7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBjYWxsYmFjayB0byBiZSBpbnZva2VkIHVwb24gcm9vdCBjaGFuZ2VzXG4gICAqXG4gICAqIEBwYXJhbSBjYWxsYmFjayBGdW5jdGlvbiB0byBpbnZva2Ugd2hlbmV2ZXIgdGhlIHJvb3QgY2hhbmdlc1xuICAgKiBAcmV0dXJuIHN1YnNjcmlwdGlvbiBpZFxuICAgKi9cbiAgb25Sb290Q2hhbmdlKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuX21ha2VTdWJzY3JpcHRpb24oe1xuICAgICAgY2FsbGJhY2ssXG4gICAgICBtZXRob2Q6ICdyb290U3Vic2NyaWJlJyxcbiAgICAgIHVuc3Vic2NyaWJlTWV0aG9kOiAncm9vdFVuc3Vic2NyaWJlJ1xuICAgIH0sIFtdIC8qIGFyZ3MgKi8pO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcmVnaXN0ZXIgYSByb290IG5vdGlmaWNhdGlvbiBjYWxsYmFja1xuICAgKlxuICAgKiBAcGFyYW0gY2xpZW50U3Vic2NyaXB0aW9uSWQgY2xpZW50IHN1YnNjcmlwdGlvbiBpZCB0byBkZXJlZ2lzdGVyXG4gICAqL1xuICBhc3luYyByZW1vdmVSb290Q2hhbmdlTGlzdGVuZXIoY2xpZW50U3Vic2NyaXB0aW9uSWQpIHtcbiAgICBhd2FpdCB0aGlzLl91bnN1YnNjcmliZUNsaWVudFN1YnNjcmlwdGlvbihjbGllbnRTdWJzY3JpcHRpb25JZCwgJ3Jvb3QgY2hhbmdlJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBLZXlwYWlyIHNpZ25lciBpbnRlcmZhY2VcbiAqL1xuXG4vKipcbiAqIEFuIGFjY291bnQga2V5cGFpciB1c2VkIGZvciBzaWduaW5nIHRyYW5zYWN0aW9ucy5cbiAqL1xuY2xhc3MgS2V5cGFpciB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcga2V5cGFpciBpbnN0YW5jZS5cbiAgICogR2VuZXJhdGUgcmFuZG9tIGtleXBhaXIgaWYgbm8ge0BsaW5rIEVkMjU1MTlLZXlwYWlyfSBpcyBwcm92aWRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtFZDI1NTE5S2V5cGFpcn0ga2V5cGFpciBlZDI1NTE5IGtleXBhaXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKGtleXBhaXIpIHtcbiAgICB0aGlzLl9rZXlwYWlyID0gdm9pZCAwO1xuICAgIHRoaXMuX2tleXBhaXIgPSBrZXlwYWlyID8/IGdlbmVyYXRlS2V5cGFpcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgbmV3IHJhbmRvbSBrZXlwYWlyXG4gICAqXG4gICAqIEByZXR1cm5zIHtLZXlwYWlyfSBLZXlwYWlyXG4gICAqL1xuICBzdGF0aWMgZ2VuZXJhdGUoKSB7XG4gICAgcmV0dXJuIG5ldyBLZXlwYWlyKGdlbmVyYXRlS2V5cGFpcigpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBrZXlwYWlyIGZyb20gYSByYXcgc2VjcmV0IGtleSBieXRlIGFycmF5LlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSB1c2VkIHRvIHJlY3JlYXRlIGEga2V5cGFpciBmcm9tIGEgcHJldmlvdXNseVxuICAgKiBnZW5lcmF0ZWQgc2VjcmV0IGtleS4gR2VuZXJhdGluZyBrZXlwYWlycyBmcm9tIGEgcmFuZG9tIHNlZWQgc2hvdWxkIGJlIGRvbmVcbiAgICogd2l0aCB0aGUge0BsaW5rIEtleXBhaXIuZnJvbVNlZWR9IG1ldGhvZC5cbiAgICpcbiAgICogQHRocm93cyBlcnJvciBpZiB0aGUgcHJvdmlkZWQgc2VjcmV0IGtleSBpcyBpbnZhbGlkIGFuZCB2YWxpZGF0aW9uIGlzIG5vdCBza2lwcGVkLlxuICAgKlxuICAgKiBAcGFyYW0gc2VjcmV0S2V5IHNlY3JldCBrZXkgYnl0ZSBhcnJheVxuICAgKiBAcGFyYW0gb3B0aW9ucyBza2lwIHNlY3JldCBrZXkgdmFsaWRhdGlvblxuICAgKlxuICAgKiBAcmV0dXJucyB7S2V5cGFpcn0gS2V5cGFpclxuICAgKi9cbiAgc3RhdGljIGZyb21TZWNyZXRLZXkoc2VjcmV0S2V5LCBvcHRpb25zKSB7XG4gICAgaWYgKHNlY3JldEtleS5ieXRlTGVuZ3RoICE9PSA2NCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgc2VjcmV0IGtleSBzaXplJyk7XG4gICAgfVxuICAgIGNvbnN0IHB1YmxpY0tleSA9IHNlY3JldEtleS5zbGljZSgzMiwgNjQpO1xuICAgIGlmICghb3B0aW9ucyB8fCAhb3B0aW9ucy5za2lwVmFsaWRhdGlvbikge1xuICAgICAgY29uc3QgcHJpdmF0ZVNjYWxhciA9IHNlY3JldEtleS5zbGljZSgwLCAzMik7XG4gICAgICBjb25zdCBjb21wdXRlZFB1YmxpY0tleSA9IGdldFB1YmxpY0tleShwcml2YXRlU2NhbGFyKTtcbiAgICAgIGZvciAobGV0IGlpID0gMDsgaWkgPCAzMjsgaWkrKykge1xuICAgICAgICBpZiAocHVibGljS2V5W2lpXSAhPT0gY29tcHV0ZWRQdWJsaWNLZXlbaWldKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcm92aWRlZCBzZWNyZXRLZXkgaXMgaW52YWxpZCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgS2V5cGFpcih7XG4gICAgICBwdWJsaWNLZXksXG4gICAgICBzZWNyZXRLZXlcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIGtleXBhaXIgZnJvbSBhIDMyIGJ5dGUgc2VlZC5cbiAgICpcbiAgICogQHBhcmFtIHNlZWQgc2VlZCBieXRlIGFycmF5XG4gICAqXG4gICAqIEByZXR1cm5zIHtLZXlwYWlyfSBLZXlwYWlyXG4gICAqL1xuICBzdGF0aWMgZnJvbVNlZWQoc2VlZCkge1xuICAgIGNvbnN0IHB1YmxpY0tleSA9IGdldFB1YmxpY0tleShzZWVkKTtcbiAgICBjb25zdCBzZWNyZXRLZXkgPSBuZXcgVWludDhBcnJheSg2NCk7XG4gICAgc2VjcmV0S2V5LnNldChzZWVkKTtcbiAgICBzZWNyZXRLZXkuc2V0KHB1YmxpY0tleSwgMzIpO1xuICAgIHJldHVybiBuZXcgS2V5cGFpcih7XG4gICAgICBwdWJsaWNLZXksXG4gICAgICBzZWNyZXRLZXlcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgcHVibGljIGtleSBmb3IgdGhpcyBrZXlwYWlyXG4gICAqXG4gICAqIEByZXR1cm5zIHtQdWJsaWNLZXl9IFB1YmxpY0tleVxuICAgKi9cbiAgZ2V0IHB1YmxpY0tleSgpIHtcbiAgICByZXR1cm4gbmV3IFB1YmxpY0tleSh0aGlzLl9rZXlwYWlyLnB1YmxpY0tleSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHJhdyBzZWNyZXQga2V5IGZvciB0aGlzIGtleXBhaXJcbiAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9IFNlY3JldCBrZXkgaW4gYW4gYXJyYXkgb2YgVWludDggYnl0ZXNcbiAgICovXG4gIGdldCBzZWNyZXRLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHRoaXMuX2tleXBhaXIuc2VjcmV0S2V5KTtcbiAgfVxufVxuXG4vKipcbiAqIEFuIGVudW1lcmF0aW9uIG9mIHZhbGlkIExvb2t1cFRhYmxlSW5zdHJ1Y3Rpb25UeXBlJ3NcbiAqL1xuXG4vKipcbiAqIEFuIGVudW1lcmF0aW9uIG9mIHZhbGlkIGFkZHJlc3MgbG9va3VwIHRhYmxlIEluc3RydWN0aW9uVHlwZSdzXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgTE9PS1VQX1RBQkxFX0lOU1RSVUNUSU9OX0xBWU9VVFMgPSBPYmplY3QuZnJlZXplKHtcbiAgQ3JlYXRlTG9va3VwVGFibGU6IHtcbiAgICBpbmRleDogMCxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnN0cnVjdChbQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTMyKCdpbnN0cnVjdGlvbicpLCB1NjQoJ3JlY2VudFNsb3QnKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTgoJ2J1bXBTZWVkJyldKVxuICB9LFxuICBGcmVlemVMb29rdXBUYWJsZToge1xuICAgIGluZGV4OiAxLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0X19uYW1lc3BhY2Uuc3RydWN0KFtCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51MzIoJ2luc3RydWN0aW9uJyldKVxuICB9LFxuICBFeHRlbmRMb29rdXBUYWJsZToge1xuICAgIGluZGV4OiAyLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0X19uYW1lc3BhY2Uuc3RydWN0KFtCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51MzIoJ2luc3RydWN0aW9uJyksIHU2NCgpLCBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5zZXEocHVibGljS2V5KCksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLm9mZnNldChCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51MzIoKSwgLTgpLCAnYWRkcmVzc2VzJyldKVxuICB9LFxuICBEZWFjdGl2YXRlTG9va3VwVGFibGU6IHtcbiAgICBpbmRleDogMyxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnN0cnVjdChbQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTMyKCdpbnN0cnVjdGlvbicpXSlcbiAgfSxcbiAgQ2xvc2VMb29rdXBUYWJsZToge1xuICAgIGluZGV4OiA0LFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0X19uYW1lc3BhY2Uuc3RydWN0KFtCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51MzIoJ2luc3RydWN0aW9uJyldKVxuICB9XG59KTtcbmNsYXNzIEFkZHJlc3NMb29rdXBUYWJsZUluc3RydWN0aW9uIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7fVxuICBzdGF0aWMgZGVjb2RlSW5zdHJ1Y3Rpb25UeXBlKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIGNvbnN0IGluc3RydWN0aW9uVHlwZUxheW91dCA9IEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnUzMignaW5zdHJ1Y3Rpb24nKTtcbiAgICBjb25zdCBpbmRleCA9IGluc3RydWN0aW9uVHlwZUxheW91dC5kZWNvZGUoaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgbGV0IHR5cGU7XG4gICAgZm9yIChjb25zdCBbbGF5b3V0VHlwZSwgbGF5b3V0XSBvZiBPYmplY3QuZW50cmllcyhMT09LVVBfVEFCTEVfSU5TVFJVQ1RJT05fTEFZT1VUUykpIHtcbiAgICAgIGlmIChsYXlvdXQuaW5kZXggPT0gaW5kZXgpIHtcbiAgICAgICAgdHlwZSA9IGxheW91dFR5cGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBJbnN0cnVjdGlvbi4gU2hvdWxkIGJlIGEgTG9va3VwVGFibGUgSW5zdHJ1Y3Rpb24nKTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbiAgc3RhdGljIGRlY29kZUNyZWF0ZUxvb2t1cFRhYmxlKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlzTGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDQpO1xuICAgIGNvbnN0IHtcbiAgICAgIHJlY2VudFNsb3RcbiAgICB9ID0gZGVjb2RlRGF0YSQxKExPT0tVUF9UQUJMRV9JTlNUUlVDVElPTl9MQVlPVVRTLkNyZWF0ZUxvb2t1cFRhYmxlLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgYXV0aG9yaXR5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleSxcbiAgICAgIHBheWVyOiBpbnN0cnVjdGlvbi5rZXlzWzJdLnB1YmtleSxcbiAgICAgIHJlY2VudFNsb3Q6IE51bWJlcihyZWNlbnRTbG90KVxuICAgIH07XG4gIH1cbiAgc3RhdGljIGRlY29kZUV4dGVuZExvb2t1cFRhYmxlKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIGlmIChpbnN0cnVjdGlvbi5rZXlzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBpbnN0cnVjdGlvbjsgZm91bmQgJHtpbnN0cnVjdGlvbi5rZXlzLmxlbmd0aH0ga2V5cywgZXhwZWN0ZWQgYXQgbGVhc3QgMmApO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBhZGRyZXNzZXNcbiAgICB9ID0gZGVjb2RlRGF0YSQxKExPT0tVUF9UQUJMRV9JTlNUUlVDVElPTl9MQVlPVVRTLkV4dGVuZExvb2t1cFRhYmxlLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgbG9va3VwVGFibGU6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgYXV0aG9yaXR5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleSxcbiAgICAgIHBheWVyOiBpbnN0cnVjdGlvbi5rZXlzLmxlbmd0aCA+IDIgPyBpbnN0cnVjdGlvbi5rZXlzWzJdLnB1YmtleSA6IHVuZGVmaW5lZCxcbiAgICAgIGFkZHJlc3NlczogYWRkcmVzc2VzLm1hcChidWZmZXIgPT4gbmV3IFB1YmxpY0tleShidWZmZXIpKVxuICAgIH07XG4gIH1cbiAgc3RhdGljIGRlY29kZUNsb3NlTG9va3VwVGFibGUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleXNMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxvb2t1cFRhYmxlOiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGF1dGhvcml0eTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICByZWNpcGllbnQ6IGluc3RydWN0aW9uLmtleXNbMl0ucHVia2V5XG4gICAgfTtcbiAgfVxuICBzdGF0aWMgZGVjb2RlRnJlZXplTG9va3VwVGFibGUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleXNMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMik7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxvb2t1cFRhYmxlOiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGF1dGhvcml0eTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXlcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBkZWNvZGVEZWFjdGl2YXRlTG9va3VwVGFibGUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleXNMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMik7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxvb2t1cFRhYmxlOiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGF1dGhvcml0eTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXlcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc3RhdGljIGNoZWNrUHJvZ3JhbUlkKHByb2dyYW1JZCkge1xuICAgIGlmICghcHJvZ3JhbUlkLmVxdWFscyhBZGRyZXNzTG9va3VwVGFibGVQcm9ncmFtLnByb2dyYW1JZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbnN0cnVjdGlvbjsgcHJvZ3JhbUlkIGlzIG5vdCBBZGRyZXNzTG9va3VwVGFibGUgUHJvZ3JhbScpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzdGF0aWMgY2hlY2tLZXlzTGVuZ3RoKGtleXMsIGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgaWYgKGtleXMubGVuZ3RoIDwgZXhwZWN0ZWRMZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBpbnN0cnVjdGlvbjsgZm91bmQgJHtrZXlzLmxlbmd0aH0ga2V5cywgZXhwZWN0ZWQgYXQgbGVhc3QgJHtleHBlY3RlZExlbmd0aH1gKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIEFkZHJlc3NMb29rdXBUYWJsZVByb2dyYW0ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHt9XG4gIHN0YXRpYyBjcmVhdGVMb29rdXBUYWJsZShwYXJhbXMpIHtcbiAgICBjb25zdCBbbG9va3VwVGFibGVBZGRyZXNzLCBidW1wU2VlZF0gPSBQdWJsaWNLZXkuZmluZFByb2dyYW1BZGRyZXNzU3luYyhbcGFyYW1zLmF1dGhvcml0eS50b0J1ZmZlcigpLCBiaWdpbnRCdWZmZXIudG9CdWZmZXJMRShCaWdJbnQocGFyYW1zLnJlY2VudFNsb3QpLCA4KV0sIHRoaXMucHJvZ3JhbUlkKTtcbiAgICBjb25zdCB0eXBlID0gTE9PS1VQX1RBQkxFX0lOU1RSVUNUSU9OX0xBWU9VVFMuQ3JlYXRlTG9va3VwVGFibGU7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgcmVjZW50U2xvdDogQmlnSW50KHBhcmFtcy5yZWNlbnRTbG90KSxcbiAgICAgIGJ1bXBTZWVkOiBidW1wU2VlZFxuICAgIH0pO1xuICAgIGNvbnN0IGtleXMgPSBbe1xuICAgICAgcHVia2V5OiBsb29rdXBUYWJsZUFkZHJlc3MsXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBwYXJhbXMuYXV0aG9yaXR5LFxuICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogcGFyYW1zLnBheWVyLFxuICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBTeXN0ZW1Qcm9ncmFtLnByb2dyYW1JZCxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfV07XG4gICAgcmV0dXJuIFtuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAga2V5czoga2V5cyxcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9KSwgbG9va3VwVGFibGVBZGRyZXNzXTtcbiAgfVxuICBzdGF0aWMgZnJlZXplTG9va3VwVGFibGUocGFyYW1zKSB7XG4gICAgY29uc3QgdHlwZSA9IExPT0tVUF9UQUJMRV9JTlNUUlVDVElPTl9MQVlPVVRTLkZyZWV6ZUxvb2t1cFRhYmxlO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUpO1xuICAgIGNvbnN0IGtleXMgPSBbe1xuICAgICAgcHVia2V5OiBwYXJhbXMubG9va3VwVGFibGUsXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBwYXJhbXMuYXV0aG9yaXR5LFxuICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH1dO1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAga2V5czoga2V5cyxcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZXh0ZW5kTG9va3VwVGFibGUocGFyYW1zKSB7XG4gICAgY29uc3QgdHlwZSA9IExPT0tVUF9UQUJMRV9JTlNUUlVDVElPTl9MQVlPVVRTLkV4dGVuZExvb2t1cFRhYmxlO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIGFkZHJlc3NlczogcGFyYW1zLmFkZHJlc3Nlcy5tYXAoYWRkciA9PiBhZGRyLnRvQnl0ZXMoKSlcbiAgICB9KTtcbiAgICBjb25zdCBrZXlzID0gW3tcbiAgICAgIHB1YmtleTogcGFyYW1zLmxvb2t1cFRhYmxlLFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogcGFyYW1zLmF1dGhvcml0eSxcbiAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9XTtcbiAgICBpZiAocGFyYW1zLnBheWVyKSB7XG4gICAgICBrZXlzLnB1c2goe1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5wYXllcixcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBTeXN0ZW1Qcm9ncmFtLnByb2dyYW1JZCxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAga2V5czoga2V5cyxcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZGVhY3RpdmF0ZUxvb2t1cFRhYmxlKHBhcmFtcykge1xuICAgIGNvbnN0IHR5cGUgPSBMT09LVVBfVEFCTEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5EZWFjdGl2YXRlTG9va3VwVGFibGU7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSk7XG4gICAgY29uc3Qga2V5cyA9IFt7XG4gICAgICBwdWJrZXk6IHBhcmFtcy5sb29rdXBUYWJsZSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IHBhcmFtcy5hdXRob3JpdHksXG4gICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfV07XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBrZXlzOiBrZXlzLFxuICAgICAgZGF0YTogZGF0YVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBjbG9zZUxvb2t1cFRhYmxlKHBhcmFtcykge1xuICAgIGNvbnN0IHR5cGUgPSBMT09LVVBfVEFCTEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5DbG9zZUxvb2t1cFRhYmxlO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUpO1xuICAgIGNvbnN0IGtleXMgPSBbe1xuICAgICAgcHVia2V5OiBwYXJhbXMubG9va3VwVGFibGUsXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBwYXJhbXMuYXV0aG9yaXR5LFxuICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogcGFyYW1zLnJlY2lwaWVudCxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9XTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGtleXM6IGtleXMsXG4gICAgICBkYXRhOiBkYXRhXG4gICAgfSk7XG4gIH1cbn1cbkFkZHJlc3NMb29rdXBUYWJsZVByb2dyYW0ucHJvZ3JhbUlkID0gbmV3IFB1YmxpY0tleSgnQWRkcmVzc0xvb2t1cFRhYjFlMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuXG4vKipcbiAqIENvbXB1dGUgQnVkZ2V0IEluc3RydWN0aW9uIGNsYXNzXG4gKi9cbmNsYXNzIENvbXB1dGVCdWRnZXRJbnN0cnVjdGlvbiB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge31cblxuICAvKipcbiAgICogRGVjb2RlIGEgY29tcHV0ZSBidWRnZXQgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiB0eXBlLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZUluc3RydWN0aW9uVHlwZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICBjb25zdCBpbnN0cnVjdGlvblR5cGVMYXlvdXQgPSBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51OCgnaW5zdHJ1Y3Rpb24nKTtcbiAgICBjb25zdCB0eXBlSW5kZXggPSBpbnN0cnVjdGlvblR5cGVMYXlvdXQuZGVjb2RlKGluc3RydWN0aW9uLmRhdGEpO1xuICAgIGxldCB0eXBlO1xuICAgIGZvciAoY29uc3QgW2l4VHlwZSwgbGF5b3V0XSBvZiBPYmplY3QuZW50cmllcyhDT01QVVRFX0JVREdFVF9JTlNUUlVDVElPTl9MQVlPVVRTKSkge1xuICAgICAgaWYgKGxheW91dC5pbmRleCA9PSB0eXBlSW5kZXgpIHtcbiAgICAgICAgdHlwZSA9IGl4VHlwZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdHlwZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnN0cnVjdGlvbiB0eXBlIGluY29ycmVjdDsgbm90IGEgQ29tcHV0ZUJ1ZGdldEluc3RydWN0aW9uJyk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSByZXF1ZXN0IHVuaXRzIGNvbXB1dGUgYnVkZ2V0IGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZVJlcXVlc3RVbml0cyhpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICBjb25zdCB7XG4gICAgICB1bml0cyxcbiAgICAgIGFkZGl0aW9uYWxGZWVcbiAgICB9ID0gZGVjb2RlRGF0YSQxKENPTVBVVEVfQlVER0VUX0lOU1RSVUNUSU9OX0xBWU9VVFMuUmVxdWVzdFVuaXRzLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgdW5pdHMsXG4gICAgICBhZGRpdGlvbmFsRmVlXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgcmVxdWVzdCBoZWFwIGZyYW1lIGNvbXB1dGUgYnVkZ2V0IGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZVJlcXVlc3RIZWFwRnJhbWUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgY29uc3Qge1xuICAgICAgYnl0ZXNcbiAgICB9ID0gZGVjb2RlRGF0YSQxKENPTVBVVEVfQlVER0VUX0lOU1RSVUNUSU9OX0xBWU9VVFMuUmVxdWVzdEhlYXBGcmFtZSwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJ5dGVzXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgc2V0IGNvbXB1dGUgdW5pdCBsaW1pdCBjb21wdXRlIGJ1ZGdldCBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVTZXRDb21wdXRlVW5pdExpbWl0KGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIGNvbnN0IHtcbiAgICAgIHVuaXRzXG4gICAgfSA9IGRlY29kZURhdGEkMShDT01QVVRFX0JVREdFVF9JTlNUUlVDVElPTl9MQVlPVVRTLlNldENvbXB1dGVVbml0TGltaXQsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICB1bml0c1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIHNldCBjb21wdXRlIHVuaXQgcHJpY2UgY29tcHV0ZSBidWRnZXQgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlU2V0Q29tcHV0ZVVuaXRQcmljZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICBjb25zdCB7XG4gICAgICBtaWNyb0xhbXBvcnRzXG4gICAgfSA9IGRlY29kZURhdGEkMShDT01QVVRFX0JVREdFVF9JTlNUUlVDVElPTl9MQVlPVVRTLlNldENvbXB1dGVVbml0UHJpY2UsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBtaWNyb0xhbXBvcnRzXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHN0YXRpYyBjaGVja1Byb2dyYW1JZChwcm9ncmFtSWQpIHtcbiAgICBpZiAoIXByb2dyYW1JZC5lcXVhbHMoQ29tcHV0ZUJ1ZGdldFByb2dyYW0ucHJvZ3JhbUlkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGluc3RydWN0aW9uOyBwcm9ncmFtSWQgaXMgbm90IENvbXB1dGVCdWRnZXRQcm9ncmFtJyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQW4gZW51bWVyYXRpb24gb2YgdmFsaWQgQ29tcHV0ZUJ1ZGdldEluc3RydWN0aW9uVHlwZSdzXG4gKi9cblxuLyoqXG4gKiBSZXF1ZXN0IHVuaXRzIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogUmVxdWVzdCBoZWFwIGZyYW1lIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogU2V0IGNvbXB1dGUgdW5pdCBsaW1pdCBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIFNldCBjb21wdXRlIHVuaXQgcHJpY2UgaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBBbiBlbnVtZXJhdGlvbiBvZiB2YWxpZCBDb21wdXRlQnVkZ2V0IEluc3RydWN0aW9uVHlwZSdzXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgQ09NUFVURV9CVURHRVRfSU5TVFJVQ1RJT05fTEFZT1VUUyA9IE9iamVjdC5mcmVlemUoe1xuICBSZXF1ZXN0VW5pdHM6IHtcbiAgICBpbmRleDogMCxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnN0cnVjdChbQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTgoJ2luc3RydWN0aW9uJyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnUzMigndW5pdHMnKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTMyKCdhZGRpdGlvbmFsRmVlJyldKVxuICB9LFxuICBSZXF1ZXN0SGVhcEZyYW1lOiB7XG4gICAgaW5kZXg6IDEsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5zdHJ1Y3QoW0J1ZmZlckxheW91dF9fbmFtZXNwYWNlLnU4KCdpbnN0cnVjdGlvbicpLCBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51MzIoJ2J5dGVzJyldKVxuICB9LFxuICBTZXRDb21wdXRlVW5pdExpbWl0OiB7XG4gICAgaW5kZXg6IDIsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5zdHJ1Y3QoW0J1ZmZlckxheW91dF9fbmFtZXNwYWNlLnU4KCdpbnN0cnVjdGlvbicpLCBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51MzIoJ3VuaXRzJyldKVxuICB9LFxuICBTZXRDb21wdXRlVW5pdFByaWNlOiB7XG4gICAgaW5kZXg6IDMsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5zdHJ1Y3QoW0J1ZmZlckxheW91dF9fbmFtZXNwYWNlLnU4KCdpbnN0cnVjdGlvbicpLCB1NjQoJ21pY3JvTGFtcG9ydHMnKV0pXG4gIH1cbn0pO1xuXG4vKipcbiAqIEZhY3RvcnkgY2xhc3MgZm9yIHRyYW5zYWN0aW9uIGluc3RydWN0aW9ucyB0byBpbnRlcmFjdCB3aXRoIHRoZSBDb21wdXRlIEJ1ZGdldCBwcm9ncmFtXG4gKi9cbmNsYXNzIENvbXB1dGVCdWRnZXRQcm9ncmFtIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7fVxuXG4gIC8qKlxuICAgKiBQdWJsaWMga2V5IHRoYXQgaWRlbnRpZmllcyB0aGUgQ29tcHV0ZSBCdWRnZXQgcHJvZ3JhbVxuICAgKi9cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgSW5zdGVhZCwgY2FsbCB7QGxpbmsgc2V0Q29tcHV0ZVVuaXRMaW1pdH0gYW5kL29yIHtAbGluayBzZXRDb21wdXRlVW5pdFByaWNlfVxuICAgKi9cbiAgc3RhdGljIHJlcXVlc3RVbml0cyhwYXJhbXMpIHtcbiAgICBjb25zdCB0eXBlID0gQ09NUFVURV9CVURHRVRfSU5TVFJVQ1RJT05fTEFZT1VUUy5SZXF1ZXN0VW5pdHM7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwgcGFyYW1zKTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5czogW10sXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyByZXF1ZXN0SGVhcEZyYW1lKHBhcmFtcykge1xuICAgIGNvbnN0IHR5cGUgPSBDT01QVVRFX0JVREdFVF9JTlNUUlVDVElPTl9MQVlPVVRTLlJlcXVlc3RIZWFwRnJhbWU7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwgcGFyYW1zKTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5czogW10sXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBzZXRDb21wdXRlVW5pdExpbWl0KHBhcmFtcykge1xuICAgIGNvbnN0IHR5cGUgPSBDT01QVVRFX0JVREdFVF9JTlNUUlVDVElPTl9MQVlPVVRTLlNldENvbXB1dGVVbml0TGltaXQ7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwgcGFyYW1zKTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5czogW10sXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBzZXRDb21wdXRlVW5pdFByaWNlKHBhcmFtcykge1xuICAgIGNvbnN0IHR5cGUgPSBDT01QVVRFX0JVREdFVF9JTlNUUlVDVElPTl9MQVlPVVRTLlNldENvbXB1dGVVbml0UHJpY2U7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgbWljcm9MYW1wb3J0czogQmlnSW50KHBhcmFtcy5taWNyb0xhbXBvcnRzKVxuICAgIH0pO1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBrZXlzOiBbXSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cbn1cbkNvbXB1dGVCdWRnZXRQcm9ncmFtLnByb2dyYW1JZCA9IG5ldyBQdWJsaWNLZXkoJ0NvbXB1dGVCdWRnZXQxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcblxuY29uc3QgUFJJVkFURV9LRVlfQllURVMkMSA9IDY0O1xuY29uc3QgUFVCTElDX0tFWV9CWVRFUyQxID0gMzI7XG5jb25zdCBTSUdOQVRVUkVfQllURVMgPSA2NDtcblxuLyoqXG4gKiBQYXJhbXMgZm9yIGNyZWF0aW5nIGFuIGVkMjU1MTkgaW5zdHJ1Y3Rpb24gdXNpbmcgYSBwdWJsaWMga2V5XG4gKi9cblxuLyoqXG4gKiBQYXJhbXMgZm9yIGNyZWF0aW5nIGFuIGVkMjU1MTkgaW5zdHJ1Y3Rpb24gdXNpbmcgYSBwcml2YXRlIGtleVxuICovXG5cbmNvbnN0IEVEMjU1MTlfSU5TVFJVQ1RJT05fTEFZT1VUID0gQnVmZmVyTGF5b3V0X19uYW1lc3BhY2Uuc3RydWN0KFtCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51OCgnbnVtU2lnbmF0dXJlcycpLCBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51OCgncGFkZGluZycpLCBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51MTYoJ3NpZ25hdHVyZU9mZnNldCcpLCBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51MTYoJ3NpZ25hdHVyZUluc3RydWN0aW9uSW5kZXgnKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTE2KCdwdWJsaWNLZXlPZmZzZXQnKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTE2KCdwdWJsaWNLZXlJbnN0cnVjdGlvbkluZGV4JyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnUxNignbWVzc2FnZURhdGFPZmZzZXQnKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTE2KCdtZXNzYWdlRGF0YVNpemUnKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTE2KCdtZXNzYWdlSW5zdHJ1Y3Rpb25JbmRleCcpXSk7XG5jbGFzcyBFZDI1NTE5UHJvZ3JhbSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge31cblxuICAvKipcbiAgICogUHVibGljIGtleSB0aGF0IGlkZW50aWZpZXMgdGhlIGVkMjU1MTkgcHJvZ3JhbVxuICAgKi9cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGVkMjU1MTkgaW5zdHJ1Y3Rpb24gd2l0aCBhIHB1YmxpYyBrZXkgYW5kIHNpZ25hdHVyZS4gVGhlXG4gICAqIHB1YmxpYyBrZXkgbXVzdCBiZSBhIGJ1ZmZlciB0aGF0IGlzIDMyIGJ5dGVzIGxvbmcsIGFuZCB0aGUgc2lnbmF0dXJlXG4gICAqIG11c3QgYmUgYSBidWZmZXIgb2YgNjQgYnl0ZXMuXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlSW5zdHJ1Y3Rpb25XaXRoUHVibGljS2V5KHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHB1YmxpY0tleSxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBzaWduYXR1cmUsXG4gICAgICBpbnN0cnVjdGlvbkluZGV4XG4gICAgfSA9IHBhcmFtcztcbiAgICBhc3NlcnQocHVibGljS2V5Lmxlbmd0aCA9PT0gUFVCTElDX0tFWV9CWVRFUyQxLCBgUHVibGljIEtleSBtdXN0IGJlICR7UFVCTElDX0tFWV9CWVRFUyQxfSBieXRlcyBidXQgcmVjZWl2ZWQgJHtwdWJsaWNLZXkubGVuZ3RofSBieXRlc2ApO1xuICAgIGFzc2VydChzaWduYXR1cmUubGVuZ3RoID09PSBTSUdOQVRVUkVfQllURVMsIGBTaWduYXR1cmUgbXVzdCBiZSAke1NJR05BVFVSRV9CWVRFU30gYnl0ZXMgYnV0IHJlY2VpdmVkICR7c2lnbmF0dXJlLmxlbmd0aH0gYnl0ZXNgKTtcbiAgICBjb25zdCBwdWJsaWNLZXlPZmZzZXQgPSBFRDI1NTE5X0lOU1RSVUNUSU9OX0xBWU9VVC5zcGFuO1xuICAgIGNvbnN0IHNpZ25hdHVyZU9mZnNldCA9IHB1YmxpY0tleU9mZnNldCArIHB1YmxpY0tleS5sZW5ndGg7XG4gICAgY29uc3QgbWVzc2FnZURhdGFPZmZzZXQgPSBzaWduYXR1cmVPZmZzZXQgKyBzaWduYXR1cmUubGVuZ3RoO1xuICAgIGNvbnN0IG51bVNpZ25hdHVyZXMgPSAxO1xuICAgIGNvbnN0IGluc3RydWN0aW9uRGF0YSA9IGJ1ZmZlci5CdWZmZXIuYWxsb2MobWVzc2FnZURhdGFPZmZzZXQgKyBtZXNzYWdlLmxlbmd0aCk7XG4gICAgY29uc3QgaW5kZXggPSBpbnN0cnVjdGlvbkluZGV4ID09IG51bGwgPyAweGZmZmYgLy8gQW4gaW5kZXggb2YgYHUxNjo6TUFYYCBtYWtlcyBpdCBkZWZhdWx0IHRvIHRoZSBjdXJyZW50IGluc3RydWN0aW9uLlxuICAgIDogaW5zdHJ1Y3Rpb25JbmRleDtcbiAgICBFRDI1NTE5X0lOU1RSVUNUSU9OX0xBWU9VVC5lbmNvZGUoe1xuICAgICAgbnVtU2lnbmF0dXJlcyxcbiAgICAgIHBhZGRpbmc6IDAsXG4gICAgICBzaWduYXR1cmVPZmZzZXQsXG4gICAgICBzaWduYXR1cmVJbnN0cnVjdGlvbkluZGV4OiBpbmRleCxcbiAgICAgIHB1YmxpY0tleU9mZnNldCxcbiAgICAgIHB1YmxpY0tleUluc3RydWN0aW9uSW5kZXg6IGluZGV4LFxuICAgICAgbWVzc2FnZURhdGFPZmZzZXQsXG4gICAgICBtZXNzYWdlRGF0YVNpemU6IG1lc3NhZ2UubGVuZ3RoLFxuICAgICAgbWVzc2FnZUluc3RydWN0aW9uSW5kZXg6IGluZGV4XG4gICAgfSwgaW5zdHJ1Y3Rpb25EYXRhKTtcbiAgICBpbnN0cnVjdGlvbkRhdGEuZmlsbChwdWJsaWNLZXksIHB1YmxpY0tleU9mZnNldCk7XG4gICAgaW5zdHJ1Y3Rpb25EYXRhLmZpbGwoc2lnbmF0dXJlLCBzaWduYXR1cmVPZmZzZXQpO1xuICAgIGluc3RydWN0aW9uRGF0YS5maWxsKG1lc3NhZ2UsIG1lc3NhZ2VEYXRhT2Zmc2V0KTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5czogW10sXG4gICAgICBwcm9ncmFtSWQ6IEVkMjU1MTlQcm9ncmFtLnByb2dyYW1JZCxcbiAgICAgIGRhdGE6IGluc3RydWN0aW9uRGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBlZDI1NTE5IGluc3RydWN0aW9uIHdpdGggYSBwcml2YXRlIGtleS4gVGhlIHByaXZhdGUga2V5XG4gICAqIG11c3QgYmUgYSBidWZmZXIgdGhhdCBpcyA2NCBieXRlcyBsb25nLlxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUluc3RydWN0aW9uV2l0aFByaXZhdGVLZXkocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgcHJpdmF0ZUtleSxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBpbnN0cnVjdGlvbkluZGV4XG4gICAgfSA9IHBhcmFtcztcbiAgICBhc3NlcnQocHJpdmF0ZUtleS5sZW5ndGggPT09IFBSSVZBVEVfS0VZX0JZVEVTJDEsIGBQcml2YXRlIGtleSBtdXN0IGJlICR7UFJJVkFURV9LRVlfQllURVMkMX0gYnl0ZXMgYnV0IHJlY2VpdmVkICR7cHJpdmF0ZUtleS5sZW5ndGh9IGJ5dGVzYCk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGtleXBhaXIgPSBLZXlwYWlyLmZyb21TZWNyZXRLZXkocHJpdmF0ZUtleSk7XG4gICAgICBjb25zdCBwdWJsaWNLZXkgPSBrZXlwYWlyLnB1YmxpY0tleS50b0J5dGVzKCk7XG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBzaWduKG1lc3NhZ2UsIGtleXBhaXIuc2VjcmV0S2V5KTtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUluc3RydWN0aW9uV2l0aFB1YmxpY0tleSh7XG4gICAgICAgIHB1YmxpY0tleSxcbiAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgc2lnbmF0dXJlLFxuICAgICAgICBpbnN0cnVjdGlvbkluZGV4XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBjcmVhdGluZyBpbnN0cnVjdGlvbjsgJHtlcnJvcn1gKTtcbiAgICB9XG4gIH1cbn1cbkVkMjU1MTlQcm9ncmFtLnByb2dyYW1JZCA9IG5ldyBQdWJsaWNLZXkoJ0VkMjU1MTlTaWdWZXJpZnkxMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcblxuY29uc3QgZWNkc2FTaWduID0gKG1zZ0hhc2gsIHByaXZLZXkpID0+IHtcbiAgY29uc3Qgc2lnbmF0dXJlID0gc2VjcDI1NmsxLnNlY3AyNTZrMS5zaWduKG1zZ0hhc2gsIHByaXZLZXkpO1xuICByZXR1cm4gW3NpZ25hdHVyZS50b0NvbXBhY3RSYXdCeXRlcygpLCBzaWduYXR1cmUucmVjb3ZlcnldO1xufTtcbnNlY3AyNTZrMS5zZWNwMjU2azEudXRpbHMuaXNWYWxpZFByaXZhdGVLZXk7XG5jb25zdCBwdWJsaWNLZXlDcmVhdGUgPSBzZWNwMjU2azEuc2VjcDI1NmsxLmdldFB1YmxpY0tleTtcblxuY29uc3QgUFJJVkFURV9LRVlfQllURVMgPSAzMjtcbmNvbnN0IEVUSEVSRVVNX0FERFJFU1NfQllURVMgPSAyMDtcbmNvbnN0IFBVQkxJQ19LRVlfQllURVMgPSA2NDtcbmNvbnN0IFNJR05BVFVSRV9PRkZTRVRTX1NFUklBTElaRURfU0laRSA9IDExO1xuXG4vKipcbiAqIFBhcmFtcyBmb3IgY3JlYXRpbmcgYW4gc2VjcDI1NmsxIGluc3RydWN0aW9uIHVzaW5nIGEgcHVibGljIGtleVxuICovXG5cbi8qKlxuICogUGFyYW1zIGZvciBjcmVhdGluZyBhbiBzZWNwMjU2azEgaW5zdHJ1Y3Rpb24gdXNpbmcgYW4gRXRoZXJldW0gYWRkcmVzc1xuICovXG5cbi8qKlxuICogUGFyYW1zIGZvciBjcmVhdGluZyBhbiBzZWNwMjU2azEgaW5zdHJ1Y3Rpb24gdXNpbmcgYSBwcml2YXRlIGtleVxuICovXG5cbmNvbnN0IFNFQ1AyNTZLMV9JTlNUUlVDVElPTl9MQVlPVVQgPSBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5zdHJ1Y3QoW0J1ZmZlckxheW91dF9fbmFtZXNwYWNlLnU4KCdudW1TaWduYXR1cmVzJyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnUxNignc2lnbmF0dXJlT2Zmc2V0JyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnU4KCdzaWduYXR1cmVJbnN0cnVjdGlvbkluZGV4JyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnUxNignZXRoQWRkcmVzc09mZnNldCcpLCBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51OCgnZXRoQWRkcmVzc0luc3RydWN0aW9uSW5kZXgnKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTE2KCdtZXNzYWdlRGF0YU9mZnNldCcpLCBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51MTYoJ21lc3NhZ2VEYXRhU2l6ZScpLCBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51OCgnbWVzc2FnZUluc3RydWN0aW9uSW5kZXgnKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UuYmxvYigyMCwgJ2V0aEFkZHJlc3MnKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UuYmxvYig2NCwgJ3NpZ25hdHVyZScpLCBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51OCgncmVjb3ZlcnlJZCcpXSk7XG5jbGFzcyBTZWNwMjU2azFQcm9ncmFtIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7fVxuXG4gIC8qKlxuICAgKiBQdWJsaWMga2V5IHRoYXQgaWRlbnRpZmllcyB0aGUgc2VjcDI1NmsxIHByb2dyYW1cbiAgICovXG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhbiBFdGhlcmV1bSBhZGRyZXNzIGZyb20gYSBzZWNwMjU2azEgcHVibGljIGtleSBidWZmZXIuXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBwdWJsaWNLZXkgYSA2NCBieXRlIHNlY3AyNTZrMSBwdWJsaWMga2V5IGJ1ZmZlclxuICAgKi9cbiAgc3RhdGljIHB1YmxpY0tleVRvRXRoQWRkcmVzcyhwdWJsaWNLZXkpIHtcbiAgICBhc3NlcnQocHVibGljS2V5Lmxlbmd0aCA9PT0gUFVCTElDX0tFWV9CWVRFUywgYFB1YmxpYyBrZXkgbXVzdCBiZSAke1BVQkxJQ19LRVlfQllURVN9IGJ5dGVzIGJ1dCByZWNlaXZlZCAke3B1YmxpY0tleS5sZW5ndGh9IGJ5dGVzYCk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBidWZmZXIuQnVmZmVyLmZyb20oc2hhMy5rZWNjYWtfMjU2KHRvQnVmZmVyKHB1YmxpY0tleSkpKS5zbGljZSgtRVRIRVJFVU1fQUREUkVTU19CWVRFUyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgY29uc3RydWN0aW5nIEV0aGVyZXVtIGFkZHJlc3M6ICR7ZXJyb3J9YCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBzZWNwMjU2azEgaW5zdHJ1Y3Rpb24gd2l0aCBhIHB1YmxpYyBrZXkuIFRoZSBwdWJsaWMga2V5XG4gICAqIG11c3QgYmUgYSBidWZmZXIgdGhhdCBpcyA2NCBieXRlcyBsb25nLlxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUluc3RydWN0aW9uV2l0aFB1YmxpY0tleShwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBwdWJsaWNLZXksXG4gICAgICBtZXNzYWdlLFxuICAgICAgc2lnbmF0dXJlLFxuICAgICAgcmVjb3ZlcnlJZCxcbiAgICAgIGluc3RydWN0aW9uSW5kZXhcbiAgICB9ID0gcGFyYW1zO1xuICAgIHJldHVybiBTZWNwMjU2azFQcm9ncmFtLmNyZWF0ZUluc3RydWN0aW9uV2l0aEV0aEFkZHJlc3Moe1xuICAgICAgZXRoQWRkcmVzczogU2VjcDI1NmsxUHJvZ3JhbS5wdWJsaWNLZXlUb0V0aEFkZHJlc3MocHVibGljS2V5KSxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBzaWduYXR1cmUsXG4gICAgICByZWNvdmVyeUlkLFxuICAgICAgaW5zdHJ1Y3Rpb25JbmRleFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBzZWNwMjU2azEgaW5zdHJ1Y3Rpb24gd2l0aCBhbiBFdGhlcmV1bSBhZGRyZXNzLiBUaGUgYWRkcmVzc1xuICAgKiBtdXN0IGJlIGEgaGV4IHN0cmluZyBvciBhIGJ1ZmZlciB0aGF0IGlzIDIwIGJ5dGVzIGxvbmcuXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlSW5zdHJ1Y3Rpb25XaXRoRXRoQWRkcmVzcyhwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBldGhBZGRyZXNzOiByYXdBZGRyZXNzLFxuICAgICAgbWVzc2FnZSxcbiAgICAgIHNpZ25hdHVyZSxcbiAgICAgIHJlY292ZXJ5SWQsXG4gICAgICBpbnN0cnVjdGlvbkluZGV4ID0gMFxuICAgIH0gPSBwYXJhbXM7XG4gICAgbGV0IGV0aEFkZHJlc3M7XG4gICAgaWYgKHR5cGVvZiByYXdBZGRyZXNzID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKHJhd0FkZHJlc3Muc3RhcnRzV2l0aCgnMHgnKSkge1xuICAgICAgICBldGhBZGRyZXNzID0gYnVmZmVyLkJ1ZmZlci5mcm9tKHJhd0FkZHJlc3Muc3Vic3RyKDIpLCAnaGV4Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBldGhBZGRyZXNzID0gYnVmZmVyLkJ1ZmZlci5mcm9tKHJhd0FkZHJlc3MsICdoZXgnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZXRoQWRkcmVzcyA9IHJhd0FkZHJlc3M7XG4gICAgfVxuICAgIGFzc2VydChldGhBZGRyZXNzLmxlbmd0aCA9PT0gRVRIRVJFVU1fQUREUkVTU19CWVRFUywgYEFkZHJlc3MgbXVzdCBiZSAke0VUSEVSRVVNX0FERFJFU1NfQllURVN9IGJ5dGVzIGJ1dCByZWNlaXZlZCAke2V0aEFkZHJlc3MubGVuZ3RofSBieXRlc2ApO1xuICAgIGNvbnN0IGRhdGFTdGFydCA9IDEgKyBTSUdOQVRVUkVfT0ZGU0VUU19TRVJJQUxJWkVEX1NJWkU7XG4gICAgY29uc3QgZXRoQWRkcmVzc09mZnNldCA9IGRhdGFTdGFydDtcbiAgICBjb25zdCBzaWduYXR1cmVPZmZzZXQgPSBkYXRhU3RhcnQgKyBldGhBZGRyZXNzLmxlbmd0aDtcbiAgICBjb25zdCBtZXNzYWdlRGF0YU9mZnNldCA9IHNpZ25hdHVyZU9mZnNldCArIHNpZ25hdHVyZS5sZW5ndGggKyAxO1xuICAgIGNvbnN0IG51bVNpZ25hdHVyZXMgPSAxO1xuICAgIGNvbnN0IGluc3RydWN0aW9uRGF0YSA9IGJ1ZmZlci5CdWZmZXIuYWxsb2MoU0VDUDI1NksxX0lOU1RSVUNUSU9OX0xBWU9VVC5zcGFuICsgbWVzc2FnZS5sZW5ndGgpO1xuICAgIFNFQ1AyNTZLMV9JTlNUUlVDVElPTl9MQVlPVVQuZW5jb2RlKHtcbiAgICAgIG51bVNpZ25hdHVyZXMsXG4gICAgICBzaWduYXR1cmVPZmZzZXQsXG4gICAgICBzaWduYXR1cmVJbnN0cnVjdGlvbkluZGV4OiBpbnN0cnVjdGlvbkluZGV4LFxuICAgICAgZXRoQWRkcmVzc09mZnNldCxcbiAgICAgIGV0aEFkZHJlc3NJbnN0cnVjdGlvbkluZGV4OiBpbnN0cnVjdGlvbkluZGV4LFxuICAgICAgbWVzc2FnZURhdGFPZmZzZXQsXG4gICAgICBtZXNzYWdlRGF0YVNpemU6IG1lc3NhZ2UubGVuZ3RoLFxuICAgICAgbWVzc2FnZUluc3RydWN0aW9uSW5kZXg6IGluc3RydWN0aW9uSW5kZXgsXG4gICAgICBzaWduYXR1cmU6IHRvQnVmZmVyKHNpZ25hdHVyZSksXG4gICAgICBldGhBZGRyZXNzOiB0b0J1ZmZlcihldGhBZGRyZXNzKSxcbiAgICAgIHJlY292ZXJ5SWRcbiAgICB9LCBpbnN0cnVjdGlvbkRhdGEpO1xuICAgIGluc3RydWN0aW9uRGF0YS5maWxsKHRvQnVmZmVyKG1lc3NhZ2UpLCBTRUNQMjU2SzFfSU5TVFJVQ1RJT05fTEFZT1VULnNwYW4pO1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBrZXlzOiBbXSxcbiAgICAgIHByb2dyYW1JZDogU2VjcDI1NmsxUHJvZ3JhbS5wcm9ncmFtSWQsXG4gICAgICBkYXRhOiBpbnN0cnVjdGlvbkRhdGFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gc2VjcDI1NmsxIGluc3RydWN0aW9uIHdpdGggYSBwcml2YXRlIGtleS4gVGhlIHByaXZhdGUga2V5XG4gICAqIG11c3QgYmUgYSBidWZmZXIgdGhhdCBpcyAzMiBieXRlcyBsb25nLlxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUluc3RydWN0aW9uV2l0aFByaXZhdGVLZXkocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgcHJpdmF0ZUtleTogcGtleSxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBpbnN0cnVjdGlvbkluZGV4XG4gICAgfSA9IHBhcmFtcztcbiAgICBhc3NlcnQocGtleS5sZW5ndGggPT09IFBSSVZBVEVfS0VZX0JZVEVTLCBgUHJpdmF0ZSBrZXkgbXVzdCBiZSAke1BSSVZBVEVfS0VZX0JZVEVTfSBieXRlcyBidXQgcmVjZWl2ZWQgJHtwa2V5Lmxlbmd0aH0gYnl0ZXNgKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcHJpdmF0ZUtleSA9IHRvQnVmZmVyKHBrZXkpO1xuICAgICAgY29uc3QgcHVibGljS2V5ID0gcHVibGljS2V5Q3JlYXRlKHByaXZhdGVLZXksIGZhbHNlIC8qIGlzQ29tcHJlc3NlZCAqLykuc2xpY2UoMSk7IC8vIHRocm93IGF3YXkgbGVhZGluZyBieXRlXG4gICAgICBjb25zdCBtZXNzYWdlSGFzaCA9IGJ1ZmZlci5CdWZmZXIuZnJvbShzaGEzLmtlY2Nha18yNTYodG9CdWZmZXIobWVzc2FnZSkpKTtcbiAgICAgIGNvbnN0IFtzaWduYXR1cmUsIHJlY292ZXJ5SWRdID0gZWNkc2FTaWduKG1lc3NhZ2VIYXNoLCBwcml2YXRlS2V5KTtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUluc3RydWN0aW9uV2l0aFB1YmxpY0tleSh7XG4gICAgICAgIHB1YmxpY0tleSxcbiAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgc2lnbmF0dXJlLFxuICAgICAgICByZWNvdmVyeUlkLFxuICAgICAgICBpbnN0cnVjdGlvbkluZGV4XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBjcmVhdGluZyBpbnN0cnVjdGlvbjsgJHtlcnJvcn1gKTtcbiAgICB9XG4gIH1cbn1cblNlY3AyNTZrMVByb2dyYW0ucHJvZ3JhbUlkID0gbmV3IFB1YmxpY0tleSgnS2VjY2FrU2VjcDI1NmsxMTExMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuXG52YXIgX2NsYXNzMjtcblxuLyoqXG4gKiBBZGRyZXNzIG9mIHRoZSBzdGFrZSBjb25maWcgYWNjb3VudCB3aGljaCBjb25maWd1cmVzIHRoZSByYXRlXG4gKiBvZiBzdGFrZSB3YXJtdXAgYW5kIGNvb2xkb3duIGFzIHdlbGwgYXMgdGhlIHNsYXNoaW5nIHBlbmFsdHkuXG4gKi9cbmNvbnN0IFNUQUtFX0NPTkZJR19JRCA9IG5ldyBQdWJsaWNLZXkoJ1N0YWtlQ29uZmlnMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcblxuLyoqXG4gKiBTdGFrZSBhY2NvdW50IGF1dGhvcml0eSBpbmZvXG4gKi9cbmNsYXNzIEF1dGhvcml6ZWQge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IEF1dGhvcml6ZWQgb2JqZWN0XG4gICAqIEBwYXJhbSBzdGFrZXIgdGhlIHN0YWtlIGF1dGhvcml0eVxuICAgKiBAcGFyYW0gd2l0aGRyYXdlciB0aGUgd2l0aGRyYXcgYXV0aG9yaXR5XG4gICAqL1xuICBjb25zdHJ1Y3RvcihzdGFrZXIsIHdpdGhkcmF3ZXIpIHtcbiAgICAvKiogc3Rha2UgYXV0aG9yaXR5ICovXG4gICAgdGhpcy5zdGFrZXIgPSB2b2lkIDA7XG4gICAgLyoqIHdpdGhkcmF3IGF1dGhvcml0eSAqL1xuICAgIHRoaXMud2l0aGRyYXdlciA9IHZvaWQgMDtcbiAgICB0aGlzLnN0YWtlciA9IHN0YWtlcjtcbiAgICB0aGlzLndpdGhkcmF3ZXIgPSB3aXRoZHJhd2VyO1xuICB9XG59XG4vKipcbiAqIFN0YWtlIGFjY291bnQgbG9ja3VwIGluZm9cbiAqL1xuY2xhc3MgTG9ja3VwIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBMb2NrdXAgb2JqZWN0XG4gICAqL1xuICBjb25zdHJ1Y3Rvcih1bml4VGltZXN0YW1wLCBlcG9jaCwgY3VzdG9kaWFuKSB7XG4gICAgLyoqIFVuaXggdGltZXN0YW1wIG9mIGxvY2t1cCBleHBpcmF0aW9uICovXG4gICAgdGhpcy51bml4VGltZXN0YW1wID0gdm9pZCAwO1xuICAgIC8qKiBFcG9jaCBvZiBsb2NrdXAgZXhwaXJhdGlvbiAqL1xuICAgIHRoaXMuZXBvY2ggPSB2b2lkIDA7XG4gICAgLyoqIExvY2t1cCBjdXN0b2RpYW4gYXV0aG9yaXR5ICovXG4gICAgdGhpcy5jdXN0b2RpYW4gPSB2b2lkIDA7XG4gICAgdGhpcy51bml4VGltZXN0YW1wID0gdW5peFRpbWVzdGFtcDtcbiAgICB0aGlzLmVwb2NoID0gZXBvY2g7XG4gICAgdGhpcy5jdXN0b2RpYW4gPSBjdXN0b2RpYW47XG4gIH1cblxuICAvKipcbiAgICogRGVmYXVsdCwgaW5hY3RpdmUgTG9ja3VwIHZhbHVlXG4gICAqL1xufVxuX2NsYXNzMiA9IExvY2t1cDtcbkxvY2t1cC5kZWZhdWx0ID0gbmV3IF9jbGFzczIoMCwgMCwgUHVibGljS2V5LmRlZmF1bHQpO1xuLyoqXG4gKiBDcmVhdGUgc3Rha2UgYWNjb3VudCB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuLyoqXG4gKiBDcmVhdGUgc3Rha2UgYWNjb3VudCB3aXRoIHNlZWQgdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cbi8qKlxuICogSW5pdGlhbGl6ZSBzdGFrZSBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuLyoqXG4gKiBEZWxlZ2F0ZSBzdGFrZSBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuLyoqXG4gKiBBdXRob3JpemUgc3Rha2UgaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cbi8qKlxuICogQXV0aG9yaXplIHN0YWtlIGluc3RydWN0aW9uIHBhcmFtcyB1c2luZyBhIGRlcml2ZWQga2V5XG4gKi9cbi8qKlxuICogU3BsaXQgc3Rha2UgaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cbi8qKlxuICogU3BsaXQgd2l0aCBzZWVkIHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG4vKipcbiAqIFdpdGhkcmF3IHN0YWtlIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG4vKipcbiAqIERlYWN0aXZhdGUgc3Rha2UgaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cbi8qKlxuICogTWVyZ2Ugc3Rha2UgaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cbi8qKlxuICogU3Rha2UgSW5zdHJ1Y3Rpb24gY2xhc3NcbiAqL1xuY2xhc3MgU3Rha2VJbnN0cnVjdGlvbiB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge31cblxuICAvKipcbiAgICogRGVjb2RlIGEgc3Rha2UgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiB0eXBlLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZUluc3RydWN0aW9uVHlwZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICBjb25zdCBpbnN0cnVjdGlvblR5cGVMYXlvdXQgPSBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51MzIoJ2luc3RydWN0aW9uJyk7XG4gICAgY29uc3QgdHlwZUluZGV4ID0gaW5zdHJ1Y3Rpb25UeXBlTGF5b3V0LmRlY29kZShpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICBsZXQgdHlwZTtcbiAgICBmb3IgKGNvbnN0IFtpeFR5cGUsIGxheW91dF0gb2YgT2JqZWN0LmVudHJpZXMoU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUykpIHtcbiAgICAgIGlmIChsYXlvdXQuaW5kZXggPT0gdHlwZUluZGV4KSB7XG4gICAgICAgIHR5cGUgPSBpeFR5cGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5zdHJ1Y3Rpb24gdHlwZSBpbmNvcnJlY3Q7IG5vdCBhIFN0YWtlSW5zdHJ1Y3Rpb24nKTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGEgaW5pdGlhbGl6ZSBzdGFrZSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVJbml0aWFsaXplKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMik7XG4gICAgY29uc3Qge1xuICAgICAgYXV0aG9yaXplZCxcbiAgICAgIGxvY2t1cFxuICAgIH0gPSBkZWNvZGVEYXRhJDEoU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5Jbml0aWFsaXplLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3Rha2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgYXV0aG9yaXplZDogbmV3IEF1dGhvcml6ZWQobmV3IFB1YmxpY0tleShhdXRob3JpemVkLnN0YWtlciksIG5ldyBQdWJsaWNLZXkoYXV0aG9yaXplZC53aXRoZHJhd2VyKSksXG4gICAgICBsb2NrdXA6IG5ldyBMb2NrdXAobG9ja3VwLnVuaXhUaW1lc3RhbXAsIGxvY2t1cC5lcG9jaCwgbmV3IFB1YmxpY0tleShsb2NrdXAuY3VzdG9kaWFuKSlcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIGRlbGVnYXRlIHN0YWtlIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZURlbGVnYXRlKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgNik7XG4gICAgZGVjb2RlRGF0YSQxKFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuRGVsZWdhdGUsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBzdGFrZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICB2b3RlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbNV0ucHVia2V5XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYW4gYXV0aG9yaXplIHN0YWtlIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZUF1dGhvcml6ZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDMpO1xuICAgIGNvbnN0IHtcbiAgICAgIG5ld0F1dGhvcml6ZWQsXG4gICAgICBzdGFrZUF1dGhvcml6YXRpb25UeXBlXG4gICAgfSA9IGRlY29kZURhdGEkMShTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLkF1dGhvcml6ZSwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgY29uc3QgbyA9IHtcbiAgICAgIHN0YWtlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMl0ucHVia2V5LFxuICAgICAgbmV3QXV0aG9yaXplZFB1YmtleTogbmV3IFB1YmxpY0tleShuZXdBdXRob3JpemVkKSxcbiAgICAgIHN0YWtlQXV0aG9yaXphdGlvblR5cGU6IHtcbiAgICAgICAgaW5kZXg6IHN0YWtlQXV0aG9yaXphdGlvblR5cGVcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChpbnN0cnVjdGlvbi5rZXlzLmxlbmd0aCA+IDMpIHtcbiAgICAgIG8uY3VzdG9kaWFuUHVia2V5ID0gaW5zdHJ1Y3Rpb24ua2V5c1szXS5wdWJrZXk7XG4gICAgfVxuICAgIHJldHVybiBvO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhbiBhdXRob3JpemUtd2l0aC1zZWVkIHN0YWtlIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZUF1dGhvcml6ZVdpdGhTZWVkKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMik7XG4gICAgY29uc3Qge1xuICAgICAgbmV3QXV0aG9yaXplZCxcbiAgICAgIHN0YWtlQXV0aG9yaXphdGlvblR5cGUsXG4gICAgICBhdXRob3JpdHlTZWVkLFxuICAgICAgYXV0aG9yaXR5T3duZXJcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuQXV0aG9yaXplV2l0aFNlZWQsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIGNvbnN0IG8gPSB7XG4gICAgICBzdGFrZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBhdXRob3JpdHlCYXNlOiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleSxcbiAgICAgIGF1dGhvcml0eVNlZWQ6IGF1dGhvcml0eVNlZWQsXG4gICAgICBhdXRob3JpdHlPd25lcjogbmV3IFB1YmxpY0tleShhdXRob3JpdHlPd25lciksXG4gICAgICBuZXdBdXRob3JpemVkUHVia2V5OiBuZXcgUHVibGljS2V5KG5ld0F1dGhvcml6ZWQpLFxuICAgICAgc3Rha2VBdXRob3JpemF0aW9uVHlwZToge1xuICAgICAgICBpbmRleDogc3Rha2VBdXRob3JpemF0aW9uVHlwZVxuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGluc3RydWN0aW9uLmtleXMubGVuZ3RoID4gMykge1xuICAgICAgby5jdXN0b2RpYW5QdWJrZXkgPSBpbnN0cnVjdGlvbi5rZXlzWzNdLnB1YmtleTtcbiAgICB9XG4gICAgcmV0dXJuIG87XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGEgc3BsaXQgc3Rha2UgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlU3BsaXQoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAzKTtcbiAgICBjb25zdCB7XG4gICAgICBsYW1wb3J0c1xuICAgIH0gPSBkZWNvZGVEYXRhJDEoU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5TcGxpdCwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YWtlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIHNwbGl0U3Rha2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1syXS5wdWJrZXksXG4gICAgICBsYW1wb3J0c1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGEgbWVyZ2Ugc3Rha2UgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlTWVyZ2UoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAzKTtcbiAgICBkZWNvZGVEYXRhJDEoU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5NZXJnZSwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YWtlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIHNvdXJjZVN0YWtlUHViS2V5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbNF0ucHVia2V5XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSB3aXRoZHJhdyBzdGFrZSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVXaXRoZHJhdyhpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDUpO1xuICAgIGNvbnN0IHtcbiAgICAgIGxhbXBvcnRzXG4gICAgfSA9IGRlY29kZURhdGEkMShTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLldpdGhkcmF3LCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICBjb25zdCBvID0ge1xuICAgICAgc3Rha2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgdG9QdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1s0XS5wdWJrZXksXG4gICAgICBsYW1wb3J0c1xuICAgIH07XG4gICAgaWYgKGluc3RydWN0aW9uLmtleXMubGVuZ3RoID4gNSkge1xuICAgICAgby5jdXN0b2RpYW5QdWJrZXkgPSBpbnN0cnVjdGlvbi5rZXlzWzVdLnB1YmtleTtcbiAgICB9XG4gICAgcmV0dXJuIG87XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGEgZGVhY3RpdmF0ZSBzdGFrZSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVEZWFjdGl2YXRlKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMyk7XG4gICAgZGVjb2RlRGF0YSQxKFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuRGVhY3RpdmF0ZSwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YWtlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMl0ucHVia2V5XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHN0YXRpYyBjaGVja1Byb2dyYW1JZChwcm9ncmFtSWQpIHtcbiAgICBpZiAoIXByb2dyYW1JZC5lcXVhbHMoU3Rha2VQcm9ncmFtLnByb2dyYW1JZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbnN0cnVjdGlvbjsgcHJvZ3JhbUlkIGlzIG5vdCBTdGFrZVByb2dyYW0nKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzdGF0aWMgY2hlY2tLZXlMZW5ndGgoa2V5cywgZXhwZWN0ZWRMZW5ndGgpIHtcbiAgICBpZiAoa2V5cy5sZW5ndGggPCBleHBlY3RlZExlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGluc3RydWN0aW9uOyBmb3VuZCAke2tleXMubGVuZ3RofSBrZXlzLCBleHBlY3RlZCBhdCBsZWFzdCAke2V4cGVjdGVkTGVuZ3RofWApO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFuIGVudW1lcmF0aW9uIG9mIHZhbGlkIFN0YWtlSW5zdHJ1Y3Rpb25UeXBlJ3NcbiAqL1xuXG4vKipcbiAqIEFuIGVudW1lcmF0aW9uIG9mIHZhbGlkIHN0YWtlIEluc3RydWN0aW9uVHlwZSdzXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUyA9IE9iamVjdC5mcmVlemUoe1xuICBJbml0aWFsaXplOiB7XG4gICAgaW5kZXg6IDAsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5zdHJ1Y3QoW0J1ZmZlckxheW91dF9fbmFtZXNwYWNlLnUzMignaW5zdHJ1Y3Rpb24nKSwgYXV0aG9yaXplZCgpLCBsb2NrdXAoKV0pXG4gIH0sXG4gIEF1dGhvcml6ZToge1xuICAgIGluZGV4OiAxLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0X19uYW1lc3BhY2Uuc3RydWN0KFtCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51MzIoJ2luc3RydWN0aW9uJyksIHB1YmxpY0tleSgnbmV3QXV0aG9yaXplZCcpLCBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51MzIoJ3N0YWtlQXV0aG9yaXphdGlvblR5cGUnKV0pXG4gIH0sXG4gIERlbGVnYXRlOiB7XG4gICAgaW5kZXg6IDIsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5zdHJ1Y3QoW0J1ZmZlckxheW91dF9fbmFtZXNwYWNlLnUzMignaW5zdHJ1Y3Rpb24nKV0pXG4gIH0sXG4gIFNwbGl0OiB7XG4gICAgaW5kZXg6IDMsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5zdHJ1Y3QoW0J1ZmZlckxheW91dF9fbmFtZXNwYWNlLnUzMignaW5zdHJ1Y3Rpb24nKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UubnM2NCgnbGFtcG9ydHMnKV0pXG4gIH0sXG4gIFdpdGhkcmF3OiB7XG4gICAgaW5kZXg6IDQsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5zdHJ1Y3QoW0J1ZmZlckxheW91dF9fbmFtZXNwYWNlLnUzMignaW5zdHJ1Y3Rpb24nKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UubnM2NCgnbGFtcG9ydHMnKV0pXG4gIH0sXG4gIERlYWN0aXZhdGU6IHtcbiAgICBpbmRleDogNSxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnN0cnVjdChbQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTMyKCdpbnN0cnVjdGlvbicpXSlcbiAgfSxcbiAgTWVyZ2U6IHtcbiAgICBpbmRleDogNyxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnN0cnVjdChbQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTMyKCdpbnN0cnVjdGlvbicpXSlcbiAgfSxcbiAgQXV0aG9yaXplV2l0aFNlZWQ6IHtcbiAgICBpbmRleDogOCxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnN0cnVjdChbQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTMyKCdpbnN0cnVjdGlvbicpLCBwdWJsaWNLZXkoJ25ld0F1dGhvcml6ZWQnKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTMyKCdzdGFrZUF1dGhvcml6YXRpb25UeXBlJyksIHJ1c3RTdHJpbmcoJ2F1dGhvcml0eVNlZWQnKSwgcHVibGljS2V5KCdhdXRob3JpdHlPd25lcicpXSlcbiAgfVxufSk7XG5cbi8qKlxuICogU3Rha2UgYXV0aG9yaXphdGlvbiB0eXBlXG4gKi9cblxuLyoqXG4gKiBBbiBlbnVtZXJhdGlvbiBvZiB2YWxpZCBTdGFrZUF1dGhvcml6YXRpb25MYXlvdXQnc1xuICovXG5jb25zdCBTdGFrZUF1dGhvcml6YXRpb25MYXlvdXQgPSBPYmplY3QuZnJlZXplKHtcbiAgU3Rha2VyOiB7XG4gICAgaW5kZXg6IDBcbiAgfSxcbiAgV2l0aGRyYXdlcjoge1xuICAgIGluZGV4OiAxXG4gIH1cbn0pO1xuXG4vKipcbiAqIEZhY3RvcnkgY2xhc3MgZm9yIHRyYW5zYWN0aW9ucyB0byBpbnRlcmFjdCB3aXRoIHRoZSBTdGFrZSBwcm9ncmFtXG4gKi9cbmNsYXNzIFN0YWtlUHJvZ3JhbSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge31cblxuICAvKipcbiAgICogUHVibGljIGtleSB0aGF0IGlkZW50aWZpZXMgdGhlIFN0YWtlIHByb2dyYW1cbiAgICovXG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGFuIEluaXRpYWxpemUgaW5zdHJ1Y3Rpb24gdG8gYWRkIHRvIGEgU3Rha2UgQ3JlYXRlIHRyYW5zYWN0aW9uXG4gICAqL1xuICBzdGF0aWMgaW5pdGlhbGl6ZShwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGFrZVB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWQsXG4gICAgICBsb2NrdXA6IG1heWJlTG9ja3VwXG4gICAgfSA9IHBhcmFtcztcbiAgICBjb25zdCBsb2NrdXAgPSBtYXliZUxvY2t1cCB8fCBMb2NrdXAuZGVmYXVsdDtcbiAgICBjb25zdCB0eXBlID0gU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5Jbml0aWFsaXplO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIGF1dGhvcml6ZWQ6IHtcbiAgICAgICAgc3Rha2VyOiB0b0J1ZmZlcihhdXRob3JpemVkLnN0YWtlci50b0J1ZmZlcigpKSxcbiAgICAgICAgd2l0aGRyYXdlcjogdG9CdWZmZXIoYXV0aG9yaXplZC53aXRoZHJhd2VyLnRvQnVmZmVyKCkpXG4gICAgICB9LFxuICAgICAgbG9ja3VwOiB7XG4gICAgICAgIHVuaXhUaW1lc3RhbXA6IGxvY2t1cC51bml4VGltZXN0YW1wLFxuICAgICAgICBlcG9jaDogbG9ja3VwLmVwb2NoLFxuICAgICAgICBjdXN0b2RpYW46IHRvQnVmZmVyKGxvY2t1cC5jdXN0b2RpYW4udG9CdWZmZXIoKSlcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBpbnN0cnVjdGlvbkRhdGEgPSB7XG4gICAgICBrZXlzOiBbe1xuICAgICAgICBwdWJrZXk6IHN0YWtlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBTWVNWQVJfUkVOVF9QVUJLRVksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH1dLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9O1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbihpbnN0cnVjdGlvbkRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgVHJhbnNhY3Rpb24gdGhhdCBjcmVhdGVzIGEgbmV3IFN0YWtlIGFjY291bnQgYXRcbiAgICogICBhbiBhZGRyZXNzIGdlbmVyYXRlZCB3aXRoIGBmcm9tYCwgYSBzZWVkLCBhbmQgdGhlIFN0YWtlIHByb2dyYW1JZFxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUFjY291bnRXaXRoU2VlZChwYXJhbXMpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbigpO1xuICAgIHRyYW5zYWN0aW9uLmFkZChTeXN0ZW1Qcm9ncmFtLmNyZWF0ZUFjY291bnRXaXRoU2VlZCh7XG4gICAgICBmcm9tUHVia2V5OiBwYXJhbXMuZnJvbVB1YmtleSxcbiAgICAgIG5ld0FjY291bnRQdWJrZXk6IHBhcmFtcy5zdGFrZVB1YmtleSxcbiAgICAgIGJhc2VQdWJrZXk6IHBhcmFtcy5iYXNlUHVia2V5LFxuICAgICAgc2VlZDogcGFyYW1zLnNlZWQsXG4gICAgICBsYW1wb3J0czogcGFyYW1zLmxhbXBvcnRzLFxuICAgICAgc3BhY2U6IHRoaXMuc3BhY2UsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkXG4gICAgfSkpO1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YWtlUHVia2V5LFxuICAgICAgYXV0aG9yaXplZCxcbiAgICAgIGxvY2t1cFxuICAgIH0gPSBwYXJhbXM7XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uLmFkZCh0aGlzLmluaXRpYWxpemUoe1xuICAgICAgc3Rha2VQdWJrZXksXG4gICAgICBhdXRob3JpemVkLFxuICAgICAgbG9ja3VwXG4gICAgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgVHJhbnNhY3Rpb24gdGhhdCBjcmVhdGVzIGEgbmV3IFN0YWtlIGFjY291bnRcbiAgICovXG4gIHN0YXRpYyBjcmVhdGVBY2NvdW50KHBhcmFtcykge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCk7XG4gICAgdHJhbnNhY3Rpb24uYWRkKFN5c3RlbVByb2dyYW0uY3JlYXRlQWNjb3VudCh7XG4gICAgICBmcm9tUHVia2V5OiBwYXJhbXMuZnJvbVB1YmtleSxcbiAgICAgIG5ld0FjY291bnRQdWJrZXk6IHBhcmFtcy5zdGFrZVB1YmtleSxcbiAgICAgIGxhbXBvcnRzOiBwYXJhbXMubGFtcG9ydHMsXG4gICAgICBzcGFjZTogdGhpcy5zcGFjZSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWRcbiAgICB9KSk7XG4gICAgY29uc3Qge1xuICAgICAgc3Rha2VQdWJrZXksXG4gICAgICBhdXRob3JpemVkLFxuICAgICAgbG9ja3VwXG4gICAgfSA9IHBhcmFtcztcbiAgICByZXR1cm4gdHJhbnNhY3Rpb24uYWRkKHRoaXMuaW5pdGlhbGl6ZSh7XG4gICAgICBzdGFrZVB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWQsXG4gICAgICBsb2NrdXBcbiAgICB9KSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBUcmFuc2FjdGlvbiB0aGF0IGRlbGVnYXRlcyBTdGFrZSB0b2tlbnMgdG8gYSB2YWxpZGF0b3JcbiAgICogVm90ZSBQdWJsaWNLZXkuIFRoaXMgdHJhbnNhY3Rpb24gY2FuIGFsc28gYmUgdXNlZCB0byByZWRlbGVnYXRlIFN0YWtlXG4gICAqIHRvIGEgbmV3IHZhbGlkYXRvciBWb3RlIFB1YmxpY0tleS5cbiAgICovXG4gIHN0YXRpYyBkZWxlZ2F0ZShwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGFrZVB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXksXG4gICAgICB2b3RlUHVia2V5XG4gICAgfSA9IHBhcmFtcztcbiAgICBjb25zdCB0eXBlID0gU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5EZWxlZ2F0ZTtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlKTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKHtcbiAgICAgIGtleXM6IFt7XG4gICAgICAgIHB1YmtleTogc3Rha2VQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IHZvdGVQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBTWVNWQVJfQ0xPQ0tfUFVCS0VZLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU1lTVkFSX1NUQUtFX0hJU1RPUllfUFVCS0VZLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU1RBS0VfQ09ORklHX0lELFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogYXV0aG9yaXplZFB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9XSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBUcmFuc2FjdGlvbiB0aGF0IGF1dGhvcml6ZXMgYSBuZXcgUHVibGljS2V5IGFzIFN0YWtlclxuICAgKiBvciBXaXRoZHJhd2VyIG9uIHRoZSBTdGFrZSBhY2NvdW50LlxuICAgKi9cbiAgc3RhdGljIGF1dGhvcml6ZShwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGFrZVB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXksXG4gICAgICBuZXdBdXRob3JpemVkUHVia2V5LFxuICAgICAgc3Rha2VBdXRob3JpemF0aW9uVHlwZSxcbiAgICAgIGN1c3RvZGlhblB1YmtleVxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHlwZSA9IFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuQXV0aG9yaXplO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIG5ld0F1dGhvcml6ZWQ6IHRvQnVmZmVyKG5ld0F1dGhvcml6ZWRQdWJrZXkudG9CdWZmZXIoKSksXG4gICAgICBzdGFrZUF1dGhvcml6YXRpb25UeXBlOiBzdGFrZUF1dGhvcml6YXRpb25UeXBlLmluZGV4XG4gICAgfSk7XG4gICAgY29uc3Qga2V5cyA9IFt7XG4gICAgICBwdWJrZXk6IHN0YWtlUHVia2V5LFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogU1lTVkFSX0NMT0NLX1BVQktFWSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IGF1dGhvcml6ZWRQdWJrZXksXG4gICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfV07XG4gICAgaWYgKGN1c3RvZGlhblB1YmtleSkge1xuICAgICAga2V5cy5wdXNoKHtcbiAgICAgICAgcHVia2V5OiBjdXN0b2RpYW5QdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoe1xuICAgICAga2V5cyxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBUcmFuc2FjdGlvbiB0aGF0IGF1dGhvcml6ZXMgYSBuZXcgUHVibGljS2V5IGFzIFN0YWtlclxuICAgKiBvciBXaXRoZHJhd2VyIG9uIHRoZSBTdGFrZSBhY2NvdW50LlxuICAgKi9cbiAgc3RhdGljIGF1dGhvcml6ZVdpdGhTZWVkKHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YWtlUHVia2V5LFxuICAgICAgYXV0aG9yaXR5QmFzZSxcbiAgICAgIGF1dGhvcml0eVNlZWQsXG4gICAgICBhdXRob3JpdHlPd25lcixcbiAgICAgIG5ld0F1dGhvcml6ZWRQdWJrZXksXG4gICAgICBzdGFrZUF1dGhvcml6YXRpb25UeXBlLFxuICAgICAgY3VzdG9kaWFuUHVia2V5XG4gICAgfSA9IHBhcmFtcztcbiAgICBjb25zdCB0eXBlID0gU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5BdXRob3JpemVXaXRoU2VlZDtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICBuZXdBdXRob3JpemVkOiB0b0J1ZmZlcihuZXdBdXRob3JpemVkUHVia2V5LnRvQnVmZmVyKCkpLFxuICAgICAgc3Rha2VBdXRob3JpemF0aW9uVHlwZTogc3Rha2VBdXRob3JpemF0aW9uVHlwZS5pbmRleCxcbiAgICAgIGF1dGhvcml0eVNlZWQ6IGF1dGhvcml0eVNlZWQsXG4gICAgICBhdXRob3JpdHlPd25lcjogdG9CdWZmZXIoYXV0aG9yaXR5T3duZXIudG9CdWZmZXIoKSlcbiAgICB9KTtcbiAgICBjb25zdCBrZXlzID0gW3tcbiAgICAgIHB1YmtleTogc3Rha2VQdWJrZXksXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBhdXRob3JpdHlCYXNlLFxuICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogU1lTVkFSX0NMT0NLX1BVQktFWSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfV07XG4gICAgaWYgKGN1c3RvZGlhblB1YmtleSkge1xuICAgICAga2V5cy5wdXNoKHtcbiAgICAgICAgcHVia2V5OiBjdXN0b2RpYW5QdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoe1xuICAgICAga2V5cyxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzdGF0aWMgc3BsaXRJbnN0cnVjdGlvbihwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGFrZVB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXksXG4gICAgICBzcGxpdFN0YWtlUHVia2V5LFxuICAgICAgbGFtcG9ydHNcbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHR5cGUgPSBTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLlNwbGl0O1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIGxhbXBvcnRzXG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXM6IFt7XG4gICAgICAgIHB1YmtleTogc3Rha2VQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IHNwbGl0U3Rha2VQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IGF1dGhvcml6ZWRQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfV0sXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgVHJhbnNhY3Rpb24gdGhhdCBzcGxpdHMgU3Rha2UgdG9rZW5zIGludG8gYW5vdGhlciBzdGFrZSBhY2NvdW50XG4gICAqL1xuICBzdGF0aWMgc3BsaXQocGFyYW1zLFxuICAvLyBDb21wdXRlIHRoZSBjb3N0IG9mIGFsbG9jYXRpbmcgdGhlIG5ldyBzdGFrZSBhY2NvdW50IGluIGxhbXBvcnRzXG4gIHJlbnRFeGVtcHRSZXNlcnZlKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICB0cmFuc2FjdGlvbi5hZGQoU3lzdGVtUHJvZ3JhbS5jcmVhdGVBY2NvdW50KHtcbiAgICAgIGZyb21QdWJrZXk6IHBhcmFtcy5hdXRob3JpemVkUHVia2V5LFxuICAgICAgbmV3QWNjb3VudFB1YmtleTogcGFyYW1zLnNwbGl0U3Rha2VQdWJrZXksXG4gICAgICBsYW1wb3J0czogcmVudEV4ZW1wdFJlc2VydmUsXG4gICAgICBzcGFjZTogdGhpcy5zcGFjZSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWRcbiAgICB9KSk7XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uLmFkZCh0aGlzLnNwbGl0SW5zdHJ1Y3Rpb24ocGFyYW1zKSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBUcmFuc2FjdGlvbiB0aGF0IHNwbGl0cyBTdGFrZSB0b2tlbnMgaW50byBhbm90aGVyIGFjY291bnRcbiAgICogZGVyaXZlZCBmcm9tIGEgYmFzZSBwdWJsaWMga2V5IGFuZCBzZWVkXG4gICAqL1xuICBzdGF0aWMgc3BsaXRXaXRoU2VlZChwYXJhbXMsXG4gIC8vIElmIHRoaXMgc3Rha2UgYWNjb3VudCBpcyBuZXcsIGNvbXB1dGUgdGhlIGNvc3Qgb2YgYWxsb2NhdGluZyBpdCBpbiBsYW1wb3J0c1xuICByZW50RXhlbXB0UmVzZXJ2ZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YWtlUHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleSxcbiAgICAgIHNwbGl0U3Rha2VQdWJrZXksXG4gICAgICBiYXNlUHVia2V5LFxuICAgICAgc2VlZCxcbiAgICAgIGxhbXBvcnRzXG4gICAgfSA9IHBhcmFtcztcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbigpO1xuICAgIHRyYW5zYWN0aW9uLmFkZChTeXN0ZW1Qcm9ncmFtLmFsbG9jYXRlKHtcbiAgICAgIGFjY291bnRQdWJrZXk6IHNwbGl0U3Rha2VQdWJrZXksXG4gICAgICBiYXNlUHVia2V5LFxuICAgICAgc2VlZCxcbiAgICAgIHNwYWNlOiB0aGlzLnNwYWNlLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZFxuICAgIH0pKTtcbiAgICBpZiAocmVudEV4ZW1wdFJlc2VydmUgJiYgcmVudEV4ZW1wdFJlc2VydmUgPiAwKSB7XG4gICAgICB0cmFuc2FjdGlvbi5hZGQoU3lzdGVtUHJvZ3JhbS50cmFuc2Zlcih7XG4gICAgICAgIGZyb21QdWJrZXk6IHBhcmFtcy5hdXRob3JpemVkUHVia2V5LFxuICAgICAgICB0b1B1YmtleTogc3BsaXRTdGFrZVB1YmtleSxcbiAgICAgICAgbGFtcG9ydHM6IHJlbnRFeGVtcHRSZXNlcnZlXG4gICAgICB9KSk7XG4gICAgfVxuICAgIHJldHVybiB0cmFuc2FjdGlvbi5hZGQodGhpcy5zcGxpdEluc3RydWN0aW9uKHtcbiAgICAgIHN0YWtlUHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleSxcbiAgICAgIHNwbGl0U3Rha2VQdWJrZXksXG4gICAgICBsYW1wb3J0c1xuICAgIH0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIFRyYW5zYWN0aW9uIHRoYXQgbWVyZ2VzIFN0YWtlIGFjY291bnRzLlxuICAgKi9cbiAgc3RhdGljIG1lcmdlKHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YWtlUHVia2V5LFxuICAgICAgc291cmNlU3Rha2VQdWJLZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5XG4gICAgfSA9IHBhcmFtcztcbiAgICBjb25zdCB0eXBlID0gU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5NZXJnZTtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlKTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKHtcbiAgICAgIGtleXM6IFt7XG4gICAgICAgIHB1YmtleTogc3Rha2VQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IHNvdXJjZVN0YWtlUHViS2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBTWVNWQVJfQ0xPQ0tfUFVCS0VZLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU1lTVkFSX1NUQUtFX0hJU1RPUllfUFVCS0VZLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogYXV0aG9yaXplZFB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9XSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBUcmFuc2FjdGlvbiB0aGF0IHdpdGhkcmF3cyBkZWFjdGl2YXRlZCBTdGFrZSB0b2tlbnMuXG4gICAqL1xuICBzdGF0aWMgd2l0aGRyYXcocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3Rha2VQdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5LFxuICAgICAgdG9QdWJrZXksXG4gICAgICBsYW1wb3J0cyxcbiAgICAgIGN1c3RvZGlhblB1YmtleVxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHlwZSA9IFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuV2l0aGRyYXc7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgbGFtcG9ydHNcbiAgICB9KTtcbiAgICBjb25zdCBrZXlzID0gW3tcbiAgICAgIHB1YmtleTogc3Rha2VQdWJrZXksXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiB0b1B1YmtleSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IFNZU1ZBUl9DTE9DS19QVUJLRVksXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogU1lTVkFSX1NUQUtFX0hJU1RPUllfUFVCS0VZLFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IGF1dGhvcml6ZWRQdWJrZXksXG4gICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfV07XG4gICAgaWYgKGN1c3RvZGlhblB1YmtleSkge1xuICAgICAga2V5cy5wdXNoKHtcbiAgICAgICAgcHVia2V5OiBjdXN0b2RpYW5QdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoe1xuICAgICAga2V5cyxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBUcmFuc2FjdGlvbiB0aGF0IGRlYWN0aXZhdGVzIFN0YWtlIHRva2Vucy5cbiAgICovXG4gIHN0YXRpYyBkZWFjdGl2YXRlKHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YWtlUHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleVxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHlwZSA9IFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuRGVhY3RpdmF0ZTtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlKTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKHtcbiAgICAgIGtleXM6IFt7XG4gICAgICAgIHB1YmtleTogc3Rha2VQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IFNZU1ZBUl9DTE9DS19QVUJLRVksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBhdXRob3JpemVkUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH1dLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxufVxuU3Rha2VQcm9ncmFtLnByb2dyYW1JZCA9IG5ldyBQdWJsaWNLZXkoJ1N0YWtlMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcbi8qKlxuICogTWF4IHNwYWNlIG9mIGEgU3Rha2UgYWNjb3VudFxuICpcbiAqIFRoaXMgaXMgZ2VuZXJhdGVkIGZyb20gdGhlIHNvbGFuYS1zdGFrZS1wcm9ncmFtIFN0YWtlU3RhdGUgc3RydWN0IGFzXG4gKiBgU3Rha2VTdGF0ZVYyOjpzaXplX29mKClgOlxuICogaHR0cHM6Ly9kb2NzLnJzL3NvbGFuYS1zdGFrZS1wcm9ncmFtL2xhdGVzdC9zb2xhbmFfc3Rha2VfcHJvZ3JhbS9zdGFrZV9zdGF0ZS9lbnVtLlN0YWtlU3RhdGVWMi5odG1sXG4gKi9cblN0YWtlUHJvZ3JhbS5zcGFjZSA9IDIwMDtcblxuLyoqXG4gKiBWb3RlIGFjY291bnQgaW5mb1xuICovXG5jbGFzcyBWb3RlSW5pdCB7XG4gIC8qKiBbMCwgMTAwXSAqL1xuXG4gIGNvbnN0cnVjdG9yKG5vZGVQdWJrZXksIGF1dGhvcml6ZWRWb3RlciwgYXV0aG9yaXplZFdpdGhkcmF3ZXIsIGNvbW1pc3Npb24pIHtcbiAgICB0aGlzLm5vZGVQdWJrZXkgPSB2b2lkIDA7XG4gICAgdGhpcy5hdXRob3JpemVkVm90ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5hdXRob3JpemVkV2l0aGRyYXdlciA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbW1pc3Npb24gPSB2b2lkIDA7XG4gICAgdGhpcy5ub2RlUHVia2V5ID0gbm9kZVB1YmtleTtcbiAgICB0aGlzLmF1dGhvcml6ZWRWb3RlciA9IGF1dGhvcml6ZWRWb3RlcjtcbiAgICB0aGlzLmF1dGhvcml6ZWRXaXRoZHJhd2VyID0gYXV0aG9yaXplZFdpdGhkcmF3ZXI7XG4gICAgdGhpcy5jb21taXNzaW9uID0gY29tbWlzc2lvbjtcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSB2b3RlIGFjY291bnQgdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBJbml0aWFsaXplQWNjb3VudCBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIEF1dGhvcml6ZSBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIEF1dGhvcml6ZVdpdGhTZWVkIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogV2l0aGRyYXcgZnJvbSB2b3RlIGFjY291bnQgdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBVcGRhdGUgdmFsaWRhdG9yIGlkZW50aXR5IChub2RlIHB1YmtleSkgdm90ZSBhY2NvdW50IGluc3RydWN0aW9uIHBhcmFtcy5cbiAqL1xuXG4vKipcbiAqIFZvdGUgSW5zdHJ1Y3Rpb24gY2xhc3NcbiAqL1xuY2xhc3MgVm90ZUluc3RydWN0aW9uIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7fVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSB2b3RlIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gdHlwZS5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVJbnN0cnVjdGlvblR5cGUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25UeXBlTGF5b3V0ID0gQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTMyKCdpbnN0cnVjdGlvbicpO1xuICAgIGNvbnN0IHR5cGVJbmRleCA9IGluc3RydWN0aW9uVHlwZUxheW91dC5kZWNvZGUoaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgbGV0IHR5cGU7XG4gICAgZm9yIChjb25zdCBbaXhUeXBlLCBsYXlvdXRdIG9mIE9iamVjdC5lbnRyaWVzKFZPVEVfSU5TVFJVQ1RJT05fTEFZT1VUUykpIHtcbiAgICAgIGlmIChsYXlvdXQuaW5kZXggPT0gdHlwZUluZGV4KSB7XG4gICAgICAgIHR5cGUgPSBpeFR5cGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5zdHJ1Y3Rpb24gdHlwZSBpbmNvcnJlY3Q7IG5vdCBhIFZvdGVJbnN0cnVjdGlvbicpO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYW4gaW5pdGlhbGl6ZSB2b3RlIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZUluaXRpYWxpemVBY2NvdW50KGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgNCk7XG4gICAgY29uc3Qge1xuICAgICAgdm90ZUluaXRcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFZPVEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5Jbml0aWFsaXplQWNjb3VudCwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZvdGVQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgbm9kZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1szXS5wdWJrZXksXG4gICAgICB2b3RlSW5pdDogbmV3IFZvdGVJbml0KG5ldyBQdWJsaWNLZXkodm90ZUluaXQubm9kZVB1YmtleSksIG5ldyBQdWJsaWNLZXkodm90ZUluaXQuYXV0aG9yaXplZFZvdGVyKSwgbmV3IFB1YmxpY0tleSh2b3RlSW5pdC5hdXRob3JpemVkV2l0aGRyYXdlciksIHZvdGVJbml0LmNvbW1pc3Npb24pXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYW4gYXV0aG9yaXplIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZUF1dGhvcml6ZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDMpO1xuICAgIGNvbnN0IHtcbiAgICAgIG5ld0F1dGhvcml6ZWQsXG4gICAgICB2b3RlQXV0aG9yaXphdGlvblR5cGVcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFZPVEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5BdXRob3JpemUsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICB2b3RlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMl0ucHVia2V5LFxuICAgICAgbmV3QXV0aG9yaXplZFB1YmtleTogbmV3IFB1YmxpY0tleShuZXdBdXRob3JpemVkKSxcbiAgICAgIHZvdGVBdXRob3JpemF0aW9uVHlwZToge1xuICAgICAgICBpbmRleDogdm90ZUF1dGhvcml6YXRpb25UeXBlXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYW4gYXV0aG9yaXplIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZUF1dGhvcml6ZVdpdGhTZWVkKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMyk7XG4gICAgY29uc3Qge1xuICAgICAgdm90ZUF1dGhvcml6ZVdpdGhTZWVkQXJnczoge1xuICAgICAgICBjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleU93bmVyUHVia2V5LFxuICAgICAgICBjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleVNlZWQsXG4gICAgICAgIG5ld0F1dGhvcml6ZWQsXG4gICAgICAgIHZvdGVBdXRob3JpemF0aW9uVHlwZVxuICAgICAgfVxuICAgIH0gPSBkZWNvZGVEYXRhJDEoVk9URV9JTlNUUlVDVElPTl9MQVlPVVRTLkF1dGhvcml6ZVdpdGhTZWVkLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlCYXNlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzJdLnB1YmtleSxcbiAgICAgIGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5T3duZXJQdWJrZXk6IG5ldyBQdWJsaWNLZXkoY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlPd25lclB1YmtleSksXG4gICAgICBjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleVNlZWQ6IGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5U2VlZCxcbiAgICAgIG5ld0F1dGhvcml6ZWRQdWJrZXk6IG5ldyBQdWJsaWNLZXkobmV3QXV0aG9yaXplZCksXG4gICAgICB2b3RlQXV0aG9yaXphdGlvblR5cGU6IHtcbiAgICAgICAgaW5kZXg6IHZvdGVBdXRob3JpemF0aW9uVHlwZVxuICAgICAgfSxcbiAgICAgIHZvdGVQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSB3aXRoZHJhdyBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVXaXRoZHJhdyhpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDMpO1xuICAgIGNvbnN0IHtcbiAgICAgIGxhbXBvcnRzXG4gICAgfSA9IGRlY29kZURhdGEkMShWT1RFX0lOU1RSVUNUSU9OX0xBWU9VVFMuV2l0aGRyYXcsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICB2b3RlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRXaXRoZHJhd2VyUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzJdLnB1YmtleSxcbiAgICAgIGxhbXBvcnRzLFxuICAgICAgdG9QdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHN0YXRpYyBjaGVja1Byb2dyYW1JZChwcm9ncmFtSWQpIHtcbiAgICBpZiAoIXByb2dyYW1JZC5lcXVhbHMoVm90ZVByb2dyYW0ucHJvZ3JhbUlkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGluc3RydWN0aW9uOyBwcm9ncmFtSWQgaXMgbm90IFZvdGVQcm9ncmFtJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc3RhdGljIGNoZWNrS2V5TGVuZ3RoKGtleXMsIGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgaWYgKGtleXMubGVuZ3RoIDwgZXhwZWN0ZWRMZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBpbnN0cnVjdGlvbjsgZm91bmQgJHtrZXlzLmxlbmd0aH0ga2V5cywgZXhwZWN0ZWQgYXQgbGVhc3QgJHtleHBlY3RlZExlbmd0aH1gKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBbiBlbnVtZXJhdGlvbiBvZiB2YWxpZCBWb3RlSW5zdHJ1Y3Rpb25UeXBlJ3NcbiAqL1xuXG4vKiogQGludGVybmFsICovXG5cbmNvbnN0IFZPVEVfSU5TVFJVQ1RJT05fTEFZT1VUUyA9IE9iamVjdC5mcmVlemUoe1xuICBJbml0aWFsaXplQWNjb3VudDoge1xuICAgIGluZGV4OiAwLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0X19uYW1lc3BhY2Uuc3RydWN0KFtCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51MzIoJ2luc3RydWN0aW9uJyksIHZvdGVJbml0KCldKVxuICB9LFxuICBBdXRob3JpemU6IHtcbiAgICBpbmRleDogMSxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnN0cnVjdChbQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTMyKCdpbnN0cnVjdGlvbicpLCBwdWJsaWNLZXkoJ25ld0F1dGhvcml6ZWQnKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTMyKCd2b3RlQXV0aG9yaXphdGlvblR5cGUnKV0pXG4gIH0sXG4gIFdpdGhkcmF3OiB7XG4gICAgaW5kZXg6IDMsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5zdHJ1Y3QoW0J1ZmZlckxheW91dF9fbmFtZXNwYWNlLnUzMignaW5zdHJ1Y3Rpb24nKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UubnM2NCgnbGFtcG9ydHMnKV0pXG4gIH0sXG4gIFVwZGF0ZVZhbGlkYXRvcklkZW50aXR5OiB7XG4gICAgaW5kZXg6IDQsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5zdHJ1Y3QoW0J1ZmZlckxheW91dF9fbmFtZXNwYWNlLnUzMignaW5zdHJ1Y3Rpb24nKV0pXG4gIH0sXG4gIEF1dGhvcml6ZVdpdGhTZWVkOiB7XG4gICAgaW5kZXg6IDEwLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0X19uYW1lc3BhY2Uuc3RydWN0KFtCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51MzIoJ2luc3RydWN0aW9uJyksIHZvdGVBdXRob3JpemVXaXRoU2VlZEFyZ3MoKV0pXG4gIH1cbn0pO1xuXG4vKipcbiAqIFZvdGVBdXRob3JpemUgdHlwZVxuICovXG5cbi8qKlxuICogQW4gZW51bWVyYXRpb24gb2YgdmFsaWQgVm90ZUF1dGhvcml6YXRpb24gbGF5b3V0cy5cbiAqL1xuY29uc3QgVm90ZUF1dGhvcml6YXRpb25MYXlvdXQgPSBPYmplY3QuZnJlZXplKHtcbiAgVm90ZXI6IHtcbiAgICBpbmRleDogMFxuICB9LFxuICBXaXRoZHJhd2VyOiB7XG4gICAgaW5kZXg6IDFcbiAgfVxufSk7XG5cbi8qKlxuICogRmFjdG9yeSBjbGFzcyBmb3IgdHJhbnNhY3Rpb25zIHRvIGludGVyYWN0IHdpdGggdGhlIFZvdGUgcHJvZ3JhbVxuICovXG5jbGFzcyBWb3RlUHJvZ3JhbSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge31cblxuICAvKipcbiAgICogUHVibGljIGtleSB0aGF0IGlkZW50aWZpZXMgdGhlIFZvdGUgcHJvZ3JhbVxuICAgKi9cblxuICAvKipcbiAgICogR2VuZXJhdGUgYW4gSW5pdGlhbGl6ZSBpbnN0cnVjdGlvbi5cbiAgICovXG4gIHN0YXRpYyBpbml0aWFsaXplQWNjb3VudChwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICB2b3RlUHVia2V5LFxuICAgICAgbm9kZVB1YmtleSxcbiAgICAgIHZvdGVJbml0XG4gICAgfSA9IHBhcmFtcztcbiAgICBjb25zdCB0eXBlID0gVk9URV9JTlNUUlVDVElPTl9MQVlPVVRTLkluaXRpYWxpemVBY2NvdW50O1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIHZvdGVJbml0OiB7XG4gICAgICAgIG5vZGVQdWJrZXk6IHRvQnVmZmVyKHZvdGVJbml0Lm5vZGVQdWJrZXkudG9CdWZmZXIoKSksXG4gICAgICAgIGF1dGhvcml6ZWRWb3RlcjogdG9CdWZmZXIodm90ZUluaXQuYXV0aG9yaXplZFZvdGVyLnRvQnVmZmVyKCkpLFxuICAgICAgICBhdXRob3JpemVkV2l0aGRyYXdlcjogdG9CdWZmZXIodm90ZUluaXQuYXV0aG9yaXplZFdpdGhkcmF3ZXIudG9CdWZmZXIoKSksXG4gICAgICAgIGNvbW1pc3Npb246IHZvdGVJbml0LmNvbW1pc3Npb25cbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBpbnN0cnVjdGlvbkRhdGEgPSB7XG4gICAgICBrZXlzOiBbe1xuICAgICAgICBwdWJrZXk6IHZvdGVQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IFNZU1ZBUl9SRU5UX1BVQktFWSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IFNZU1ZBUl9DTE9DS19QVUJLRVksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBub2RlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH1dLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9O1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbihpbnN0cnVjdGlvbkRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdHJhbnNhY3Rpb24gdGhhdCBjcmVhdGVzIGEgbmV3IFZvdGUgYWNjb3VudC5cbiAgICovXG4gIHN0YXRpYyBjcmVhdGVBY2NvdW50KHBhcmFtcykge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCk7XG4gICAgdHJhbnNhY3Rpb24uYWRkKFN5c3RlbVByb2dyYW0uY3JlYXRlQWNjb3VudCh7XG4gICAgICBmcm9tUHVia2V5OiBwYXJhbXMuZnJvbVB1YmtleSxcbiAgICAgIG5ld0FjY291bnRQdWJrZXk6IHBhcmFtcy52b3RlUHVia2V5LFxuICAgICAgbGFtcG9ydHM6IHBhcmFtcy5sYW1wb3J0cyxcbiAgICAgIHNwYWNlOiB0aGlzLnNwYWNlLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZFxuICAgIH0pKTtcbiAgICByZXR1cm4gdHJhbnNhY3Rpb24uYWRkKHRoaXMuaW5pdGlhbGl6ZUFjY291bnQoe1xuICAgICAgdm90ZVB1YmtleTogcGFyYW1zLnZvdGVQdWJrZXksXG4gICAgICBub2RlUHVia2V5OiBwYXJhbXMudm90ZUluaXQubm9kZVB1YmtleSxcbiAgICAgIHZvdGVJbml0OiBwYXJhbXMudm90ZUluaXRcbiAgICB9KSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0cmFuc2FjdGlvbiB0aGF0IGF1dGhvcml6ZXMgYSBuZXcgVm90ZXIgb3IgV2l0aGRyYXdlciBvbiB0aGUgVm90ZSBhY2NvdW50LlxuICAgKi9cbiAgc3RhdGljIGF1dGhvcml6ZShwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICB2b3RlUHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleSxcbiAgICAgIG5ld0F1dGhvcml6ZWRQdWJrZXksXG4gICAgICB2b3RlQXV0aG9yaXphdGlvblR5cGVcbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHR5cGUgPSBWT1RFX0lOU1RSVUNUSU9OX0xBWU9VVFMuQXV0aG9yaXplO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIG5ld0F1dGhvcml6ZWQ6IHRvQnVmZmVyKG5ld0F1dGhvcml6ZWRQdWJrZXkudG9CdWZmZXIoKSksXG4gICAgICB2b3RlQXV0aG9yaXphdGlvblR5cGU6IHZvdGVBdXRob3JpemF0aW9uVHlwZS5pbmRleFxuICAgIH0pO1xuICAgIGNvbnN0IGtleXMgPSBbe1xuICAgICAgcHVia2V5OiB2b3RlUHVia2V5LFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogU1lTVkFSX0NMT0NLX1BVQktFWSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBhdXRob3JpemVkUHVia2V5LFxuICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH1dO1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoe1xuICAgICAga2V5cyxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0cmFuc2FjdGlvbiB0aGF0IGF1dGhvcml6ZXMgYSBuZXcgVm90ZXIgb3IgV2l0aGRyYXdlciBvbiB0aGUgVm90ZSBhY2NvdW50XG4gICAqIHdoZXJlIHRoZSBjdXJyZW50IFZvdGVyIG9yIFdpdGhkcmF3ZXIgYXV0aG9yaXR5IGlzIGEgZGVyaXZlZCBrZXkuXG4gICAqL1xuICBzdGF0aWMgYXV0aG9yaXplV2l0aFNlZWQocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlCYXNlUHVia2V5LFxuICAgICAgY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlPd25lclB1YmtleSxcbiAgICAgIGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5U2VlZCxcbiAgICAgIG5ld0F1dGhvcml6ZWRQdWJrZXksXG4gICAgICB2b3RlQXV0aG9yaXphdGlvblR5cGUsXG4gICAgICB2b3RlUHVia2V5XG4gICAgfSA9IHBhcmFtcztcbiAgICBjb25zdCB0eXBlID0gVk9URV9JTlNUUlVDVElPTl9MQVlPVVRTLkF1dGhvcml6ZVdpdGhTZWVkO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIHZvdGVBdXRob3JpemVXaXRoU2VlZEFyZ3M6IHtcbiAgICAgICAgY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlPd25lclB1YmtleTogdG9CdWZmZXIoY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlPd25lclB1YmtleS50b0J1ZmZlcigpKSxcbiAgICAgICAgY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlTZWVkOiBjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleVNlZWQsXG4gICAgICAgIG5ld0F1dGhvcml6ZWQ6IHRvQnVmZmVyKG5ld0F1dGhvcml6ZWRQdWJrZXkudG9CdWZmZXIoKSksXG4gICAgICAgIHZvdGVBdXRob3JpemF0aW9uVHlwZTogdm90ZUF1dGhvcml6YXRpb25UeXBlLmluZGV4XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3Qga2V5cyA9IFt7XG4gICAgICBwdWJrZXk6IHZvdGVQdWJrZXksXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBTWVNWQVJfQ0xPQ0tfUFVCS0VZLFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5QmFzZVB1YmtleSxcbiAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9XTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKHtcbiAgICAgIGtleXMsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdHJhbnNhY3Rpb24gdG8gd2l0aGRyYXcgZnJvbSBhIFZvdGUgYWNjb3VudC5cbiAgICovXG4gIHN0YXRpYyB3aXRoZHJhdyhwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICB2b3RlUHVia2V5LFxuICAgICAgYXV0aG9yaXplZFdpdGhkcmF3ZXJQdWJrZXksXG4gICAgICBsYW1wb3J0cyxcbiAgICAgIHRvUHVia2V5XG4gICAgfSA9IHBhcmFtcztcbiAgICBjb25zdCB0eXBlID0gVk9URV9JTlNUUlVDVElPTl9MQVlPVVRTLldpdGhkcmF3O1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIGxhbXBvcnRzXG4gICAgfSk7XG4gICAgY29uc3Qga2V5cyA9IFt7XG4gICAgICBwdWJrZXk6IHZvdGVQdWJrZXksXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiB0b1B1YmtleSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IGF1dGhvcml6ZWRXaXRoZHJhd2VyUHVia2V5LFxuICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH1dO1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoe1xuICAgICAga2V5cyxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0cmFuc2FjdGlvbiB0byB3aXRoZHJhdyBzYWZlbHkgZnJvbSBhIFZvdGUgYWNjb3VudC5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiB3YXMgY3JlYXRlZCBhcyBhIHNhZmVndWFyZCBmb3Igdm90ZSBhY2NvdW50cyBydW5uaW5nIHZhbGlkYXRvcnMsIGBzYWZlV2l0aGRyYXdgXG4gICAqIGNoZWNrcyB0aGF0IHRoZSB3aXRoZHJhdyBhbW91bnQgd2lsbCBub3QgZXhjZWVkIHRoZSBzcGVjaWZpZWQgYmFsYW5jZSB3aGlsZSBsZWF2aW5nIGVub3VnaCBsZWZ0XG4gICAqIHRvIGNvdmVyIHJlbnQuIElmIHlvdSB3aXNoIHRvIGNsb3NlIHRoZSB2b3RlIGFjY291bnQgYnkgd2l0aGRyYXdpbmcgdGhlIGZ1bGwgYW1vdW50LCBjYWxsIHRoZVxuICAgKiBgd2l0aGRyYXdgIG1ldGhvZCBkaXJlY3RseS5cbiAgICovXG4gIHN0YXRpYyBzYWZlV2l0aGRyYXcocGFyYW1zLCBjdXJyZW50Vm90ZUFjY291bnRCYWxhbmNlLCByZW50RXhlbXB0TWluaW11bSkge1xuICAgIGlmIChwYXJhbXMubGFtcG9ydHMgPiBjdXJyZW50Vm90ZUFjY291bnRCYWxhbmNlIC0gcmVudEV4ZW1wdE1pbmltdW0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2l0aGRyYXcgd2lsbCBsZWF2ZSB2b3RlIGFjY291bnQgd2l0aCBpbnN1ZmZpY2llbnQgZnVuZHMuJyk7XG4gICAgfVxuICAgIHJldHVybiBWb3RlUHJvZ3JhbS53aXRoZHJhdyhwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdHJhbnNhY3Rpb24gdG8gdXBkYXRlIHRoZSB2YWxpZGF0b3IgaWRlbnRpdHkgKG5vZGUgcHVia2V5KSBvZiBhIFZvdGUgYWNjb3VudC5cbiAgICovXG4gIHN0YXRpYyB1cGRhdGVWYWxpZGF0b3JJZGVudGl0eShwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICB2b3RlUHVia2V5LFxuICAgICAgYXV0aG9yaXplZFdpdGhkcmF3ZXJQdWJrZXksXG4gICAgICBub2RlUHVia2V5XG4gICAgfSA9IHBhcmFtcztcbiAgICBjb25zdCB0eXBlID0gVk9URV9JTlNUUlVDVElPTl9MQVlPVVRTLlVwZGF0ZVZhbGlkYXRvcklkZW50aXR5O1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUpO1xuICAgIGNvbnN0IGtleXMgPSBbe1xuICAgICAgcHVia2V5OiB2b3RlUHVia2V5LFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogbm9kZVB1YmtleSxcbiAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IGF1dGhvcml6ZWRXaXRoZHJhd2VyUHVia2V5LFxuICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH1dO1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoe1xuICAgICAga2V5cyxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cbn1cblZvdGVQcm9ncmFtLnByb2dyYW1JZCA9IG5ldyBQdWJsaWNLZXkoJ1ZvdGUxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcbi8qKlxuICogTWF4IHNwYWNlIG9mIGEgVm90ZSBhY2NvdW50XG4gKlxuICogVGhpcyBpcyBnZW5lcmF0ZWQgZnJvbSB0aGUgc29sYW5hLXZvdGUtcHJvZ3JhbSBWb3RlU3RhdGUgc3RydWN0IGFzXG4gKiBgVm90ZVN0YXRlOjpzaXplX29mKClgOlxuICogaHR0cHM6Ly9kb2NzLnJzL3NvbGFuYS12b3RlLXByb2dyYW0vMS45LjUvc29sYW5hX3ZvdGVfcHJvZ3JhbS92b3RlX3N0YXRlL3N0cnVjdC5Wb3RlU3RhdGUuaHRtbCNtZXRob2Quc2l6ZV9vZlxuICpcbiAqIEtFRVAgSU4gU1lOQyBXSVRIIGBWb3RlU3RhdGU6OnNpemVfb2YoKWAgaW4gaHR0cHM6Ly9naXRodWIuY29tL3NvbGFuYS1sYWJzL3NvbGFuYS9ibG9iL2E0NzRjYjI0YjkyMzhmNWVkY2M5ODJmNjVjMGIzN2Q0YTEwNDZmN2Uvc2RrL3Byb2dyYW0vc3JjL3ZvdGUvc3RhdGUvbW9kLnJzI0wzNDAtTDM0MlxuICovXG5Wb3RlUHJvZ3JhbS5zcGFjZSA9IDM3NjI7XG5cbmNvbnN0IFZBTElEQVRPUl9JTkZPX0tFWSA9IG5ldyBQdWJsaWNLZXkoJ1ZhMWlkYXRvcjFuZm8xMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG4vKipcbiAqIEluZm8gdXNlZCB0byBpZGVudGl0eSB2YWxpZGF0b3JzLlxuICovXG5cbmNvbnN0IEluZm9TdHJpbmcgPSBzdXBlcnN0cnVjdC50eXBlKHtcbiAgbmFtZTogc3VwZXJzdHJ1Y3Quc3RyaW5nKCksXG4gIHdlYnNpdGU6IHN1cGVyc3RydWN0Lm9wdGlvbmFsKHN1cGVyc3RydWN0LnN0cmluZygpKSxcbiAgZGV0YWlsczogc3VwZXJzdHJ1Y3Qub3B0aW9uYWwoc3VwZXJzdHJ1Y3Quc3RyaW5nKCkpLFxuICBrZXliYXNlVXNlcm5hbWU6IHN1cGVyc3RydWN0Lm9wdGlvbmFsKHN1cGVyc3RydWN0LnN0cmluZygpKVxufSk7XG5cbi8qKlxuICogVmFsaWRhdG9ySW5mbyBjbGFzc1xuICovXG5jbGFzcyBWYWxpZGF0b3JJbmZvIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIHZhbGlkIFZhbGlkYXRvckluZm9cbiAgICpcbiAgICogQHBhcmFtIGtleSB2YWxpZGF0b3IgcHVibGljIGtleVxuICAgKiBAcGFyYW0gaW5mbyB2YWxpZGF0b3IgaW5mb3JtYXRpb25cbiAgICovXG4gIGNvbnN0cnVjdG9yKGtleSwgaW5mbykge1xuICAgIC8qKlxuICAgICAqIHZhbGlkYXRvciBwdWJsaWMga2V5XG4gICAgICovXG4gICAgdGhpcy5rZXkgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogdmFsaWRhdG9yIGluZm9ybWF0aW9uXG4gICAgICovXG4gICAgdGhpcy5pbmZvID0gdm9pZCAwO1xuICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIHRoaXMuaW5mbyA9IGluZm87XG4gIH1cblxuICAvKipcbiAgICogRGVzZXJpYWxpemUgVmFsaWRhdG9ySW5mbyBmcm9tIHRoZSBjb25maWcgYWNjb3VudCBkYXRhLiBFeGFjdGx5IHR3byBjb25maWdcbiAgICoga2V5cyBhcmUgcmVxdWlyZWQgaW4gdGhlIGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSBidWZmZXIgY29uZmlnIGFjY291bnQgZGF0YVxuICAgKiBAcmV0dXJuIG51bGwgaWYgaW5mbyB3YXMgbm90IGZvdW5kXG4gICAqL1xuICBzdGF0aWMgZnJvbUNvbmZpZ0RhdGEoYnVmZmVyJDEpIHtcbiAgICBsZXQgYnl0ZUFycmF5ID0gWy4uLmJ1ZmZlciQxXTtcbiAgICBjb25zdCBjb25maWdLZXlDb3VudCA9IGRlY29kZUxlbmd0aChieXRlQXJyYXkpO1xuICAgIGlmIChjb25maWdLZXlDb3VudCAhPT0gMikgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgY29uZmlnS2V5cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjsgaSsrKSB7XG4gICAgICBjb25zdCBwdWJsaWNLZXkgPSBuZXcgUHVibGljS2V5KGd1YXJkZWRTcGxpY2UoYnl0ZUFycmF5LCAwLCBQVUJMSUNfS0VZX0xFTkdUSCkpO1xuICAgICAgY29uc3QgaXNTaWduZXIgPSBndWFyZGVkU2hpZnQoYnl0ZUFycmF5KSA9PT0gMTtcbiAgICAgIGNvbmZpZ0tleXMucHVzaCh7XG4gICAgICAgIHB1YmxpY0tleSxcbiAgICAgICAgaXNTaWduZXJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoY29uZmlnS2V5c1swXS5wdWJsaWNLZXkuZXF1YWxzKFZBTElEQVRPUl9JTkZPX0tFWSkpIHtcbiAgICAgIGlmIChjb25maWdLZXlzWzFdLmlzU2lnbmVyKSB7XG4gICAgICAgIGNvbnN0IHJhd0luZm8gPSBydXN0U3RyaW5nKCkuZGVjb2RlKGJ1ZmZlci5CdWZmZXIuZnJvbShieXRlQXJyYXkpKTtcbiAgICAgICAgY29uc3QgaW5mbyA9IEpTT04ucGFyc2UocmF3SW5mbyk7XG4gICAgICAgIHN1cGVyc3RydWN0LmFzc2VydChpbmZvLCBJbmZvU3RyaW5nKTtcbiAgICAgICAgcmV0dXJuIG5ldyBWYWxpZGF0b3JJbmZvKGNvbmZpZ0tleXNbMV0ucHVibGljS2V5LCBpbmZvKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuY29uc3QgVk9URV9QUk9HUkFNX0lEID0gbmV3IFB1YmxpY0tleSgnVm90ZTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuXG4vKipcbiAqIEhpc3Rvcnkgb2YgaG93IG1hbnkgY3JlZGl0cyBlYXJuZWQgYnkgdGhlIGVuZCBvZiBlYWNoIGVwb2NoXG4gKi9cblxuLyoqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3NvbGFuYS1sYWJzL3NvbGFuYS9ibG9iLzhhMTJlZDAyOWNmYTM4ZDRhNDU0MDA5MTZjMjQ2M2ZiODJiYmVjOGMvcHJvZ3JhbXMvdm90ZV9hcGkvc3JjL3ZvdGVfc3RhdGUucnMjTDY4LUw4OFxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBWb3RlQWNjb3VudExheW91dCA9IEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnN0cnVjdChbcHVibGljS2V5KCdub2RlUHVia2V5JyksIHB1YmxpY0tleSgnYXV0aG9yaXplZFdpdGhkcmF3ZXInKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTgoJ2NvbW1pc3Npb24nKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UubnU2NCgpLFxuLy8gdm90ZXMubGVuZ3RoXG5CdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5zZXEoQnVmZmVyTGF5b3V0X19uYW1lc3BhY2Uuc3RydWN0KFtCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5udTY0KCdzbG90JyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnUzMignY29uZmlybWF0aW9uQ291bnQnKV0pLCBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5vZmZzZXQoQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTMyKCksIC04KSwgJ3ZvdGVzJyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnU4KCdyb290U2xvdFZhbGlkJyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLm51NjQoJ3Jvb3RTbG90JyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLm51NjQoKSxcbi8vIGF1dGhvcml6ZWRWb3RlcnMubGVuZ3RoXG5CdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5zZXEoQnVmZmVyTGF5b3V0X19uYW1lc3BhY2Uuc3RydWN0KFtCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5udTY0KCdlcG9jaCcpLCBwdWJsaWNLZXkoJ2F1dGhvcml6ZWRWb3RlcicpXSksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLm9mZnNldChCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51MzIoKSwgLTgpLCAnYXV0aG9yaXplZFZvdGVycycpLCBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5zdHJ1Y3QoW0J1ZmZlckxheW91dF9fbmFtZXNwYWNlLnNlcShCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5zdHJ1Y3QoW3B1YmxpY0tleSgnYXV0aG9yaXplZFB1YmtleScpLCBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5udTY0KCdlcG9jaE9mTGFzdEF1dGhvcml6ZWRTd2l0Y2gnKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UubnU2NCgndGFyZ2V0RXBvY2gnKV0pLCAzMiwgJ2J1ZicpLCBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5udTY0KCdpZHgnKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTgoJ2lzRW1wdHknKV0sICdwcmlvclZvdGVycycpLCBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5udTY0KCksXG4vLyBlcG9jaENyZWRpdHMubGVuZ3RoXG5CdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5zZXEoQnVmZmVyTGF5b3V0X19uYW1lc3BhY2Uuc3RydWN0KFtCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5udTY0KCdlcG9jaCcpLCBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5udTY0KCdjcmVkaXRzJyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLm51NjQoJ3ByZXZDcmVkaXRzJyldKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2Uub2Zmc2V0KEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnUzMigpLCAtOCksICdlcG9jaENyZWRpdHMnKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2Uuc3RydWN0KFtCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5udTY0KCdzbG90JyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLm51NjQoJ3RpbWVzdGFtcCcpXSwgJ2xhc3RUaW1lc3RhbXAnKV0pO1xuLyoqXG4gKiBWb3RlQWNjb3VudCBjbGFzc1xuICovXG5jbGFzcyBWb3RlQWNjb3VudCB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICB0aGlzLm5vZGVQdWJrZXkgPSB2b2lkIDA7XG4gICAgdGhpcy5hdXRob3JpemVkV2l0aGRyYXdlciA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbW1pc3Npb24gPSB2b2lkIDA7XG4gICAgdGhpcy5yb290U2xvdCA9IHZvaWQgMDtcbiAgICB0aGlzLnZvdGVzID0gdm9pZCAwO1xuICAgIHRoaXMuYXV0aG9yaXplZFZvdGVycyA9IHZvaWQgMDtcbiAgICB0aGlzLnByaW9yVm90ZXJzID0gdm9pZCAwO1xuICAgIHRoaXMuZXBvY2hDcmVkaXRzID0gdm9pZCAwO1xuICAgIHRoaXMubGFzdFRpbWVzdGFtcCA9IHZvaWQgMDtcbiAgICB0aGlzLm5vZGVQdWJrZXkgPSBhcmdzLm5vZGVQdWJrZXk7XG4gICAgdGhpcy5hdXRob3JpemVkV2l0aGRyYXdlciA9IGFyZ3MuYXV0aG9yaXplZFdpdGhkcmF3ZXI7XG4gICAgdGhpcy5jb21taXNzaW9uID0gYXJncy5jb21taXNzaW9uO1xuICAgIHRoaXMucm9vdFNsb3QgPSBhcmdzLnJvb3RTbG90O1xuICAgIHRoaXMudm90ZXMgPSBhcmdzLnZvdGVzO1xuICAgIHRoaXMuYXV0aG9yaXplZFZvdGVycyA9IGFyZ3MuYXV0aG9yaXplZFZvdGVycztcbiAgICB0aGlzLnByaW9yVm90ZXJzID0gYXJncy5wcmlvclZvdGVycztcbiAgICB0aGlzLmVwb2NoQ3JlZGl0cyA9IGFyZ3MuZXBvY2hDcmVkaXRzO1xuICAgIHRoaXMubGFzdFRpbWVzdGFtcCA9IGFyZ3MubGFzdFRpbWVzdGFtcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXNlcmlhbGl6ZSBWb3RlQWNjb3VudCBmcm9tIHRoZSBhY2NvdW50IGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSBidWZmZXIgYWNjb3VudCBkYXRhXG4gICAqIEByZXR1cm4gVm90ZUFjY291bnRcbiAgICovXG4gIHN0YXRpYyBmcm9tQWNjb3VudERhdGEoYnVmZmVyKSB7XG4gICAgY29uc3QgdmVyc2lvbk9mZnNldCA9IDQ7XG4gICAgY29uc3QgdmEgPSBWb3RlQWNjb3VudExheW91dC5kZWNvZGUodG9CdWZmZXIoYnVmZmVyKSwgdmVyc2lvbk9mZnNldCk7XG4gICAgbGV0IHJvb3RTbG90ID0gdmEucm9vdFNsb3Q7XG4gICAgaWYgKCF2YS5yb290U2xvdFZhbGlkKSB7XG4gICAgICByb290U2xvdCA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVm90ZUFjY291bnQoe1xuICAgICAgbm9kZVB1YmtleTogbmV3IFB1YmxpY0tleSh2YS5ub2RlUHVia2V5KSxcbiAgICAgIGF1dGhvcml6ZWRXaXRoZHJhd2VyOiBuZXcgUHVibGljS2V5KHZhLmF1dGhvcml6ZWRXaXRoZHJhd2VyKSxcbiAgICAgIGNvbW1pc3Npb246IHZhLmNvbW1pc3Npb24sXG4gICAgICB2b3RlczogdmEudm90ZXMsXG4gICAgICByb290U2xvdCxcbiAgICAgIGF1dGhvcml6ZWRWb3RlcnM6IHZhLmF1dGhvcml6ZWRWb3RlcnMubWFwKHBhcnNlQXV0aG9yaXplZFZvdGVyKSxcbiAgICAgIHByaW9yVm90ZXJzOiBnZXRQcmlvclZvdGVycyh2YS5wcmlvclZvdGVycyksXG4gICAgICBlcG9jaENyZWRpdHM6IHZhLmVwb2NoQ3JlZGl0cyxcbiAgICAgIGxhc3RUaW1lc3RhbXA6IHZhLmxhc3RUaW1lc3RhbXBcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gcGFyc2VBdXRob3JpemVkVm90ZXIoe1xuICBhdXRob3JpemVkVm90ZXIsXG4gIGVwb2NoXG59KSB7XG4gIHJldHVybiB7XG4gICAgZXBvY2gsXG4gICAgYXV0aG9yaXplZFZvdGVyOiBuZXcgUHVibGljS2V5KGF1dGhvcml6ZWRWb3RlcilcbiAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlUHJpb3JWb3RlcnMoe1xuICBhdXRob3JpemVkUHVia2V5LFxuICBlcG9jaE9mTGFzdEF1dGhvcml6ZWRTd2l0Y2gsXG4gIHRhcmdldEVwb2NoXG59KSB7XG4gIHJldHVybiB7XG4gICAgYXV0aG9yaXplZFB1YmtleTogbmV3IFB1YmxpY0tleShhdXRob3JpemVkUHVia2V5KSxcbiAgICBlcG9jaE9mTGFzdEF1dGhvcml6ZWRTd2l0Y2gsXG4gICAgdGFyZ2V0RXBvY2hcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFByaW9yVm90ZXJzKHtcbiAgYnVmLFxuICBpZHgsXG4gIGlzRW1wdHlcbn0pIHtcbiAgaWYgKGlzRW1wdHkpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgcmV0dXJuIFsuLi5idWYuc2xpY2UoaWR4ICsgMSkubWFwKHBhcnNlUHJpb3JWb3RlcnMpLCAuLi5idWYuc2xpY2UoMCwgaWR4KS5tYXAocGFyc2VQcmlvclZvdGVycyldO1xufVxuXG5jb25zdCBlbmRwb2ludCA9IHtcbiAgaHR0cDoge1xuICAgIGRldm5ldDogJ2h0dHA6Ly9hcGkuZGV2bmV0LnNvbGFuYS5jb20nLFxuICAgIHRlc3RuZXQ6ICdodHRwOi8vYXBpLnRlc3RuZXQuc29sYW5hLmNvbScsXG4gICAgJ21haW5uZXQtYmV0YSc6ICdodHRwOi8vYXBpLm1haW5uZXQtYmV0YS5zb2xhbmEuY29tLydcbiAgfSxcbiAgaHR0cHM6IHtcbiAgICBkZXZuZXQ6ICdodHRwczovL2FwaS5kZXZuZXQuc29sYW5hLmNvbScsXG4gICAgdGVzdG5ldDogJ2h0dHBzOi8vYXBpLnRlc3RuZXQuc29sYW5hLmNvbScsXG4gICAgJ21haW5uZXQtYmV0YSc6ICdodHRwczovL2FwaS5tYWlubmV0LWJldGEuc29sYW5hLmNvbS8nXG4gIH1cbn07XG4vKipcbiAqIFJldHJpZXZlcyB0aGUgUlBDIEFQSSBVUkwgZm9yIHRoZSBzcGVjaWZpZWQgY2x1c3RlclxuICogQHBhcmFtIHtDbHVzdGVyfSBbY2x1c3Rlcj1cImRldm5ldFwiXSAtIFRoZSBjbHVzdGVyIG5hbWUgb2YgdGhlIFJQQyBBUEkgVVJMIHRvIHVzZS4gUG9zc2libGUgb3B0aW9uczogJ2Rldm5ldCcgfCAndGVzdG5ldCcgfCAnbWFpbm5ldC1iZXRhJ1xuICogQHBhcmFtIHtib29sZWFufSBbdGxzPVwiaHR0cFwiXSAtIFVzZSBUTFMgd2hlbiBjb25uZWN0aW5nIHRvIGNsdXN0ZXIuXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gVVJMIHN0cmluZyBvZiB0aGUgUlBDIGVuZHBvaW50XG4gKi9cbmZ1bmN0aW9uIGNsdXN0ZXJBcGlVcmwoY2x1c3RlciwgdGxzKSB7XG4gIGNvbnN0IGtleSA9IHRscyA9PT0gZmFsc2UgPyAnaHR0cCcgOiAnaHR0cHMnO1xuICBpZiAoIWNsdXN0ZXIpIHtcbiAgICByZXR1cm4gZW5kcG9pbnRba2V5XVsnZGV2bmV0J107XG4gIH1cbiAgY29uc3QgdXJsID0gZW5kcG9pbnRba2V5XVtjbHVzdGVyXTtcbiAgaWYgKCF1cmwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gJHtrZXl9IGNsdXN0ZXI6ICR7Y2x1c3Rlcn1gKTtcbiAgfVxuICByZXR1cm4gdXJsO1xufVxuXG4vKipcbiAqIFNlbmQgYW5kIGNvbmZpcm0gYSByYXcgdHJhbnNhY3Rpb25cbiAqXG4gKiBJZiBgY29tbWl0bWVudGAgb3B0aW9uIGlzIG5vdCBzcGVjaWZpZWQsIGRlZmF1bHRzIHRvICdtYXgnIGNvbW1pdG1lbnQuXG4gKlxuICogQHBhcmFtIHtDb25uZWN0aW9ufSBjb25uZWN0aW9uXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcmF3VHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb25Db25maXJtYXRpb25TdHJhdGVneX0gY29uZmlybWF0aW9uU3RyYXRlZ3lcbiAqIEBwYXJhbSB7Q29uZmlybU9wdGlvbnN9IFtvcHRpb25zXVxuICogQHJldHVybnMge1Byb21pc2U8VHJhbnNhY3Rpb25TaWduYXR1cmU+fVxuICovXG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgQ2FsbGluZyBgc2VuZEFuZENvbmZpcm1SYXdUcmFuc2FjdGlvbigpYCB3aXRob3V0IGEgYGNvbmZpcm1hdGlvblN0cmF0ZWd5YFxuICogaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuYXN5bmMgZnVuY3Rpb24gc2VuZEFuZENvbmZpcm1SYXdUcmFuc2FjdGlvbihjb25uZWN0aW9uLCByYXdUcmFuc2FjdGlvbiwgY29uZmlybWF0aW9uU3RyYXRlZ3lPckNvbmZpcm1PcHRpb25zLCBtYXliZUNvbmZpcm1PcHRpb25zKSB7XG4gIGxldCBjb25maXJtYXRpb25TdHJhdGVneTtcbiAgbGV0IG9wdGlvbnM7XG4gIGlmIChjb25maXJtYXRpb25TdHJhdGVneU9yQ29uZmlybU9wdGlvbnMgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpcm1hdGlvblN0cmF0ZWd5T3JDb25maXJtT3B0aW9ucywgJ2xhc3RWYWxpZEJsb2NrSGVpZ2h0JykpIHtcbiAgICBjb25maXJtYXRpb25TdHJhdGVneSA9IGNvbmZpcm1hdGlvblN0cmF0ZWd5T3JDb25maXJtT3B0aW9ucztcbiAgICBvcHRpb25zID0gbWF5YmVDb25maXJtT3B0aW9ucztcbiAgfSBlbHNlIGlmIChjb25maXJtYXRpb25TdHJhdGVneU9yQ29uZmlybU9wdGlvbnMgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpcm1hdGlvblN0cmF0ZWd5T3JDb25maXJtT3B0aW9ucywgJ25vbmNlVmFsdWUnKSkge1xuICAgIGNvbmZpcm1hdGlvblN0cmF0ZWd5ID0gY29uZmlybWF0aW9uU3RyYXRlZ3lPckNvbmZpcm1PcHRpb25zO1xuICAgIG9wdGlvbnMgPSBtYXliZUNvbmZpcm1PcHRpb25zO1xuICB9IGVsc2Uge1xuICAgIG9wdGlvbnMgPSBjb25maXJtYXRpb25TdHJhdGVneU9yQ29uZmlybU9wdGlvbnM7XG4gIH1cbiAgY29uc3Qgc2VuZE9wdGlvbnMgPSBvcHRpb25zICYmIHtcbiAgICBza2lwUHJlZmxpZ2h0OiBvcHRpb25zLnNraXBQcmVmbGlnaHQsXG4gICAgcHJlZmxpZ2h0Q29tbWl0bWVudDogb3B0aW9ucy5wcmVmbGlnaHRDb21taXRtZW50IHx8IG9wdGlvbnMuY29tbWl0bWVudCxcbiAgICBtaW5Db250ZXh0U2xvdDogb3B0aW9ucy5taW5Db250ZXh0U2xvdFxuICB9O1xuICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBjb25uZWN0aW9uLnNlbmRSYXdUcmFuc2FjdGlvbihyYXdUcmFuc2FjdGlvbiwgc2VuZE9wdGlvbnMpO1xuICBjb25zdCBjb21taXRtZW50ID0gb3B0aW9ucyAmJiBvcHRpb25zLmNvbW1pdG1lbnQ7XG4gIGNvbnN0IGNvbmZpcm1hdGlvblByb21pc2UgPSBjb25maXJtYXRpb25TdHJhdGVneSA/IGNvbm5lY3Rpb24uY29uZmlybVRyYW5zYWN0aW9uKGNvbmZpcm1hdGlvblN0cmF0ZWd5LCBjb21taXRtZW50KSA6IGNvbm5lY3Rpb24uY29uZmlybVRyYW5zYWN0aW9uKHNpZ25hdHVyZSwgY29tbWl0bWVudCk7XG4gIGNvbnN0IHN0YXR1cyA9IChhd2FpdCBjb25maXJtYXRpb25Qcm9taXNlKS52YWx1ZTtcbiAgaWYgKHN0YXR1cy5lcnIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFJhdyB0cmFuc2FjdGlvbiAke3NpZ25hdHVyZX0gZmFpbGVkICgke0pTT04uc3RyaW5naWZ5KHN0YXR1cyl9KWApO1xuICB9XG4gIHJldHVybiBzaWduYXR1cmU7XG59XG5cbi8qKlxuICogVGhlcmUgYXJlIDEtYmlsbGlvbiBsYW1wb3J0cyBpbiBvbmUgU09MXG4gKi9cbmNvbnN0IExBTVBPUlRTX1BFUl9TT0wgPSAxMDAwMDAwMDAwO1xuXG5leHBvcnRzLkFjY291bnQgPSBBY2NvdW50O1xuZXhwb3J0cy5BZGRyZXNzTG9va3VwVGFibGVBY2NvdW50ID0gQWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudDtcbmV4cG9ydHMuQWRkcmVzc0xvb2t1cFRhYmxlSW5zdHJ1Y3Rpb24gPSBBZGRyZXNzTG9va3VwVGFibGVJbnN0cnVjdGlvbjtcbmV4cG9ydHMuQWRkcmVzc0xvb2t1cFRhYmxlUHJvZ3JhbSA9IEFkZHJlc3NMb29rdXBUYWJsZVByb2dyYW07XG5leHBvcnRzLkF1dGhvcml6ZWQgPSBBdXRob3JpemVkO1xuZXhwb3J0cy5CTE9DS0hBU0hfQ0FDSEVfVElNRU9VVF9NUyA9IEJMT0NLSEFTSF9DQUNIRV9USU1FT1VUX01TO1xuZXhwb3J0cy5CUEZfTE9BREVSX0RFUFJFQ0FURURfUFJPR1JBTV9JRCA9IEJQRl9MT0FERVJfREVQUkVDQVRFRF9QUk9HUkFNX0lEO1xuZXhwb3J0cy5CUEZfTE9BREVSX1BST0dSQU1fSUQgPSBCUEZfTE9BREVSX1BST0dSQU1fSUQ7XG5leHBvcnRzLkJwZkxvYWRlciA9IEJwZkxvYWRlcjtcbmV4cG9ydHMuQ09NUFVURV9CVURHRVRfSU5TVFJVQ1RJT05fTEFZT1VUUyA9IENPTVBVVEVfQlVER0VUX0lOU1RSVUNUSU9OX0xBWU9VVFM7XG5leHBvcnRzLkNvbXB1dGVCdWRnZXRJbnN0cnVjdGlvbiA9IENvbXB1dGVCdWRnZXRJbnN0cnVjdGlvbjtcbmV4cG9ydHMuQ29tcHV0ZUJ1ZGdldFByb2dyYW0gPSBDb21wdXRlQnVkZ2V0UHJvZ3JhbTtcbmV4cG9ydHMuQ29ubmVjdGlvbiA9IENvbm5lY3Rpb247XG5leHBvcnRzLkVkMjU1MTlQcm9ncmFtID0gRWQyNTUxOVByb2dyYW07XG5leHBvcnRzLkVudW0gPSBFbnVtO1xuZXhwb3J0cy5FcG9jaFNjaGVkdWxlID0gRXBvY2hTY2hlZHVsZTtcbmV4cG9ydHMuRmVlQ2FsY3VsYXRvckxheW91dCA9IEZlZUNhbGN1bGF0b3JMYXlvdXQ7XG5leHBvcnRzLktleXBhaXIgPSBLZXlwYWlyO1xuZXhwb3J0cy5MQU1QT1JUU19QRVJfU09MID0gTEFNUE9SVFNfUEVSX1NPTDtcbmV4cG9ydHMuTE9PS1VQX1RBQkxFX0lOU1RSVUNUSU9OX0xBWU9VVFMgPSBMT09LVVBfVEFCTEVfSU5TVFJVQ1RJT05fTEFZT1VUUztcbmV4cG9ydHMuTG9hZGVyID0gTG9hZGVyO1xuZXhwb3J0cy5Mb2NrdXAgPSBMb2NrdXA7XG5leHBvcnRzLk1BWF9TRUVEX0xFTkdUSCA9IE1BWF9TRUVEX0xFTkdUSDtcbmV4cG9ydHMuTWVzc2FnZSA9IE1lc3NhZ2U7XG5leHBvcnRzLk1lc3NhZ2VBY2NvdW50S2V5cyA9IE1lc3NhZ2VBY2NvdW50S2V5cztcbmV4cG9ydHMuTWVzc2FnZVYwID0gTWVzc2FnZVYwO1xuZXhwb3J0cy5OT05DRV9BQ0NPVU5UX0xFTkdUSCA9IE5PTkNFX0FDQ09VTlRfTEVOR1RIO1xuZXhwb3J0cy5Ob25jZUFjY291bnQgPSBOb25jZUFjY291bnQ7XG5leHBvcnRzLlBBQ0tFVF9EQVRBX1NJWkUgPSBQQUNLRVRfREFUQV9TSVpFO1xuZXhwb3J0cy5QVUJMSUNfS0VZX0xFTkdUSCA9IFBVQkxJQ19LRVlfTEVOR1RIO1xuZXhwb3J0cy5QdWJsaWNLZXkgPSBQdWJsaWNLZXk7XG5leHBvcnRzLlNJR05BVFVSRV9MRU5HVEhfSU5fQllURVMgPSBTSUdOQVRVUkVfTEVOR1RIX0lOX0JZVEVTO1xuZXhwb3J0cy5TT0xBTkFfU0NIRU1BID0gU09MQU5BX1NDSEVNQTtcbmV4cG9ydHMuU1RBS0VfQ09ORklHX0lEID0gU1RBS0VfQ09ORklHX0lEO1xuZXhwb3J0cy5TVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTID0gU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUztcbmV4cG9ydHMuU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMgPSBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUztcbmV4cG9ydHMuU1lTVkFSX0NMT0NLX1BVQktFWSA9IFNZU1ZBUl9DTE9DS19QVUJLRVk7XG5leHBvcnRzLlNZU1ZBUl9FUE9DSF9TQ0hFRFVMRV9QVUJLRVkgPSBTWVNWQVJfRVBPQ0hfU0NIRURVTEVfUFVCS0VZO1xuZXhwb3J0cy5TWVNWQVJfSU5TVFJVQ1RJT05TX1BVQktFWSA9IFNZU1ZBUl9JTlNUUlVDVElPTlNfUFVCS0VZO1xuZXhwb3J0cy5TWVNWQVJfUkVDRU5UX0JMT0NLSEFTSEVTX1BVQktFWSA9IFNZU1ZBUl9SRUNFTlRfQkxPQ0tIQVNIRVNfUFVCS0VZO1xuZXhwb3J0cy5TWVNWQVJfUkVOVF9QVUJLRVkgPSBTWVNWQVJfUkVOVF9QVUJLRVk7XG5leHBvcnRzLlNZU1ZBUl9SRVdBUkRTX1BVQktFWSA9IFNZU1ZBUl9SRVdBUkRTX1BVQktFWTtcbmV4cG9ydHMuU1lTVkFSX1NMT1RfSEFTSEVTX1BVQktFWSA9IFNZU1ZBUl9TTE9UX0hBU0hFU19QVUJLRVk7XG5leHBvcnRzLlNZU1ZBUl9TTE9UX0hJU1RPUllfUFVCS0VZID0gU1lTVkFSX1NMT1RfSElTVE9SWV9QVUJLRVk7XG5leHBvcnRzLlNZU1ZBUl9TVEFLRV9ISVNUT1JZX1BVQktFWSA9IFNZU1ZBUl9TVEFLRV9ISVNUT1JZX1BVQktFWTtcbmV4cG9ydHMuU2VjcDI1NmsxUHJvZ3JhbSA9IFNlY3AyNTZrMVByb2dyYW07XG5leHBvcnRzLlNlbmRUcmFuc2FjdGlvbkVycm9yID0gU2VuZFRyYW5zYWN0aW9uRXJyb3I7XG5leHBvcnRzLlNvbGFuYUpTT05SUENFcnJvciA9IFNvbGFuYUpTT05SUENFcnJvcjtcbmV4cG9ydHMuU29sYW5hSlNPTlJQQ0Vycm9yQ29kZSA9IFNvbGFuYUpTT05SUENFcnJvckNvZGU7XG5leHBvcnRzLlN0YWtlQXV0aG9yaXphdGlvbkxheW91dCA9IFN0YWtlQXV0aG9yaXphdGlvbkxheW91dDtcbmV4cG9ydHMuU3Rha2VJbnN0cnVjdGlvbiA9IFN0YWtlSW5zdHJ1Y3Rpb247XG5leHBvcnRzLlN0YWtlUHJvZ3JhbSA9IFN0YWtlUHJvZ3JhbTtcbmV4cG9ydHMuU3RydWN0ID0gU3RydWN0O1xuZXhwb3J0cy5TeXN0ZW1JbnN0cnVjdGlvbiA9IFN5c3RlbUluc3RydWN0aW9uO1xuZXhwb3J0cy5TeXN0ZW1Qcm9ncmFtID0gU3lzdGVtUHJvZ3JhbTtcbmV4cG9ydHMuVHJhbnNhY3Rpb24gPSBUcmFuc2FjdGlvbjtcbmV4cG9ydHMuVHJhbnNhY3Rpb25FeHBpcmVkQmxvY2toZWlnaHRFeGNlZWRlZEVycm9yID0gVHJhbnNhY3Rpb25FeHBpcmVkQmxvY2toZWlnaHRFeGNlZWRlZEVycm9yO1xuZXhwb3J0cy5UcmFuc2FjdGlvbkV4cGlyZWROb25jZUludmFsaWRFcnJvciA9IFRyYW5zYWN0aW9uRXhwaXJlZE5vbmNlSW52YWxpZEVycm9yO1xuZXhwb3J0cy5UcmFuc2FjdGlvbkV4cGlyZWRUaW1lb3V0RXJyb3IgPSBUcmFuc2FjdGlvbkV4cGlyZWRUaW1lb3V0RXJyb3I7XG5leHBvcnRzLlRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24gPSBUcmFuc2FjdGlvbkluc3RydWN0aW9uO1xuZXhwb3J0cy5UcmFuc2FjdGlvbk1lc3NhZ2UgPSBUcmFuc2FjdGlvbk1lc3NhZ2U7XG5leHBvcnRzLlRyYW5zYWN0aW9uU3RhdHVzID0gVHJhbnNhY3Rpb25TdGF0dXM7XG5leHBvcnRzLlZBTElEQVRPUl9JTkZPX0tFWSA9IFZBTElEQVRPUl9JTkZPX0tFWTtcbmV4cG9ydHMuVkVSU0lPTl9QUkVGSVhfTUFTSyA9IFZFUlNJT05fUFJFRklYX01BU0s7XG5leHBvcnRzLlZPVEVfUFJPR1JBTV9JRCA9IFZPVEVfUFJPR1JBTV9JRDtcbmV4cG9ydHMuVmFsaWRhdG9ySW5mbyA9IFZhbGlkYXRvckluZm87XG5leHBvcnRzLlZlcnNpb25lZE1lc3NhZ2UgPSBWZXJzaW9uZWRNZXNzYWdlO1xuZXhwb3J0cy5WZXJzaW9uZWRUcmFuc2FjdGlvbiA9IFZlcnNpb25lZFRyYW5zYWN0aW9uO1xuZXhwb3J0cy5Wb3RlQWNjb3VudCA9IFZvdGVBY2NvdW50O1xuZXhwb3J0cy5Wb3RlQXV0aG9yaXphdGlvbkxheW91dCA9IFZvdGVBdXRob3JpemF0aW9uTGF5b3V0O1xuZXhwb3J0cy5Wb3RlSW5pdCA9IFZvdGVJbml0O1xuZXhwb3J0cy5Wb3RlSW5zdHJ1Y3Rpb24gPSBWb3RlSW5zdHJ1Y3Rpb247XG5leHBvcnRzLlZvdGVQcm9ncmFtID0gVm90ZVByb2dyYW07XG5leHBvcnRzLmNsdXN0ZXJBcGlVcmwgPSBjbHVzdGVyQXBpVXJsO1xuZXhwb3J0cy5zZW5kQW5kQ29uZmlybVJhd1RyYW5zYWN0aW9uID0gc2VuZEFuZENvbmZpcm1SYXdUcmFuc2FjdGlvbjtcbmV4cG9ydHMuc2VuZEFuZENvbmZpcm1UcmFuc2FjdGlvbiA9IHNlbmRBbmRDb25maXJtVHJhbnNhY3Rpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5janMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/solana/node_modules/@solana/web3.js/lib/index.cjs.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/solana/node_modules/jayson/lib/client/browser/index.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@turnkey/solana/node_modules/jayson/lib/client/browser/index.js ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst uuid = (__webpack_require__(/*! uuid */ \"(ssr)/./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/index.js\").v4);\nconst generateRequest = __webpack_require__(/*! ../../generateRequest */ \"(ssr)/./node_modules/@turnkey/solana/node_modules/jayson/lib/generateRequest.js\");\n\n/**\n * Constructor for a Jayson Browser Client that does not depend any node.js core libraries\n * @class ClientBrowser\n * @param {Function} callServer Method that calls the server, receives the stringified request and a regular node-style callback\n * @param {Object} [options]\n * @param {Function} [options.reviver] Reviver function for JSON\n * @param {Function} [options.replacer] Replacer function for JSON\n * @param {Number} [options.version=2] JSON-RPC version to use (1|2)\n * @param {Function} [options.generator] Function to use for generating request IDs\n *  @param {Boolean} [options.notificationIdNull=false] When true, version 2 requests will set id to null instead of omitting it\n * @return {ClientBrowser}\n */\nconst ClientBrowser = function(callServer, options) {\n  if(!(this instanceof ClientBrowser)) {\n    return new ClientBrowser(callServer, options);\n  }\n\n  if (!options) {\n    options = {};\n  }\n\n  this.options = {\n    reviver: typeof options.reviver !== 'undefined' ? options.reviver : null,\n    replacer: typeof options.replacer !== 'undefined' ? options.replacer : null,\n    generator: typeof options.generator !== 'undefined' ? options.generator : function() { return uuid(); },\n    version: typeof options.version !== 'undefined' ? options.version : 2,\n    notificationIdNull: typeof options.notificationIdNull === 'boolean' ? options.notificationIdNull : false,\n  };\n\n  this.callServer = callServer;\n};\n\nmodule.exports = ClientBrowser;\n\n/**\n *  Creates a request and dispatches it if given a callback.\n *  @param {String|Array} method A batch request if passed an Array, or a method name if passed a String\n *  @param {Array|Object} [params] Parameters for the method\n *  @param {String|Number} [id] Optional id. If undefined an id will be generated. If null it creates a notification request\n *  @param {Function} [callback] Request callback. If specified, executes the request rather than only returning it.\n *  @throws {TypeError} Invalid parameters\n *  @return {Object} JSON-RPC 1.0 or 2.0 compatible request\n */\nClientBrowser.prototype.request = function(method, params, id, callback) {\n  const self = this;\n  let request = null;\n\n  // is this a batch request?\n  const isBatch = Array.isArray(method) && typeof params === 'function';\n\n  if (this.options.version === 1 && isBatch) {\n    throw new TypeError('JSON-RPC 1.0 does not support batching');\n  }\n\n  // is this a raw request?\n  const isRaw = !isBatch && method && typeof method === 'object' && typeof params === 'function';\n\n  if(isBatch || isRaw) {\n    callback = params;\n    request = method;\n  } else {\n    if(typeof id === 'function') {\n      callback = id;\n      // specifically undefined because \"null\" is a notification request\n      id = undefined;\n    }\n\n    const hasCallback = typeof callback === 'function';\n\n    try {\n      request = generateRequest(method, params, id, {\n        generator: this.options.generator,\n        version: this.options.version,\n        notificationIdNull: this.options.notificationIdNull,\n      });\n    } catch(err) {\n      if(hasCallback) {\n        return callback(err);\n      }\n      throw err;\n    }\n\n    // no callback means we should just return a raw request\n    if(!hasCallback) {\n      return request;\n    }\n\n  }\n\n  let message;\n  try {\n    message = JSON.stringify(request, this.options.replacer);\n  } catch(err) {\n    return callback(err);\n  }\n\n  this.callServer(message, function(err, response) {\n    self._parseResponse(err, response, callback);\n  });\n\n  // always return the raw request\n  return request;\n};\n\n/**\n * Parses a response from a server\n * @param {Object} err Error to pass on that is unrelated to the actual response\n * @param {String} responseText JSON-RPC 1.0 or 2.0 response\n * @param {Function} callback Callback that will receive different arguments depending on the amount of parameters\n * @private\n */\nClientBrowser.prototype._parseResponse = function(err, responseText, callback) {\n  if(err) {\n    callback(err);\n    return;\n  }\n\n  if(!responseText) {\n    // empty response text, assume that is correct because it could be a\n    // notification which jayson does not give any body for\n    return callback();\n  }\n\n  let response;\n  try {\n    response = JSON.parse(responseText, this.options.reviver);\n  } catch(err) {\n    return callback(err);\n  }\n\n  if(callback.length === 3) {\n    // if callback length is 3, we split callback arguments on error and response\n\n    // is batch response?\n    if(Array.isArray(response)) {\n\n      // neccesary to split strictly on validity according to spec here\n      const isError = function(res) {\n        return typeof res.error !== 'undefined';\n      };\n\n      const isNotError = function (res) {\n        return !isError(res);\n      };\n\n      return callback(null, response.filter(isError), response.filter(isNotError));\n    \n    } else {\n\n      // split regardless of validity\n      return callback(null, response.error, response.result);\n    \n    }\n  \n  }\n\n  callback(null, response);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvc29sYW5hL25vZGVfbW9kdWxlcy9qYXlzb24vbGliL2NsaWVudC9icm93c2VyL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGFBQWEscUhBQWtCO0FBQy9CLHdCQUF3QixtQkFBTyxDQUFDLDhHQUF1Qjs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsWUFBWSxTQUFTO0FBQ3JCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyRkFBMkYsZ0JBQWdCO0FBQzNHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUIsWUFBWSxjQUFjO0FBQzFCLFlBQVksZUFBZTtBQUMzQixZQUFZLFVBQVU7QUFDdEIsYUFBYSxXQUFXO0FBQ3hCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9udXJzZWJsb2MvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvc29sYW5hL25vZGVfbW9kdWxlcy9qYXlzb24vbGliL2NsaWVudC9icm93c2VyL2luZGV4LmpzP2Q0MzQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB1dWlkID0gcmVxdWlyZSgndXVpZCcpLnY0O1xuY29uc3QgZ2VuZXJhdGVSZXF1ZXN0ID0gcmVxdWlyZSgnLi4vLi4vZ2VuZXJhdGVSZXF1ZXN0Jyk7XG5cbi8qKlxuICogQ29uc3RydWN0b3IgZm9yIGEgSmF5c29uIEJyb3dzZXIgQ2xpZW50IHRoYXQgZG9lcyBub3QgZGVwZW5kIGFueSBub2RlLmpzIGNvcmUgbGlicmFyaWVzXG4gKiBAY2xhc3MgQ2xpZW50QnJvd3NlclxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbFNlcnZlciBNZXRob2QgdGhhdCBjYWxscyB0aGUgc2VydmVyLCByZWNlaXZlcyB0aGUgc3RyaW5naWZpZWQgcmVxdWVzdCBhbmQgYSByZWd1bGFyIG5vZGUtc3R5bGUgY2FsbGJhY2tcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLnJldml2ZXJdIFJldml2ZXIgZnVuY3Rpb24gZm9yIEpTT05cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLnJlcGxhY2VyXSBSZXBsYWNlciBmdW5jdGlvbiBmb3IgSlNPTlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnZlcnNpb249Ml0gSlNPTi1SUEMgdmVyc2lvbiB0byB1c2UgKDF8MilcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmdlbmVyYXRvcl0gRnVuY3Rpb24gdG8gdXNlIGZvciBnZW5lcmF0aW5nIHJlcXVlc3QgSURzXG4gKiAgQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5ub3RpZmljYXRpb25JZE51bGw9ZmFsc2VdIFdoZW4gdHJ1ZSwgdmVyc2lvbiAyIHJlcXVlc3RzIHdpbGwgc2V0IGlkIHRvIG51bGwgaW5zdGVhZCBvZiBvbWl0dGluZyBpdFxuICogQHJldHVybiB7Q2xpZW50QnJvd3Nlcn1cbiAqL1xuY29uc3QgQ2xpZW50QnJvd3NlciA9IGZ1bmN0aW9uKGNhbGxTZXJ2ZXIsIG9wdGlvbnMpIHtcbiAgaWYoISh0aGlzIGluc3RhbmNlb2YgQ2xpZW50QnJvd3NlcikpIHtcbiAgICByZXR1cm4gbmV3IENsaWVudEJyb3dzZXIoY2FsbFNlcnZlciwgb3B0aW9ucyk7XG4gIH1cblxuICBpZiAoIW9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgcmV2aXZlcjogdHlwZW9mIG9wdGlvbnMucmV2aXZlciAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLnJldml2ZXIgOiBudWxsLFxuICAgIHJlcGxhY2VyOiB0eXBlb2Ygb3B0aW9ucy5yZXBsYWNlciAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLnJlcGxhY2VyIDogbnVsbCxcbiAgICBnZW5lcmF0b3I6IHR5cGVvZiBvcHRpb25zLmdlbmVyYXRvciAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmdlbmVyYXRvciA6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdXVpZCgpOyB9LFxuICAgIHZlcnNpb246IHR5cGVvZiBvcHRpb25zLnZlcnNpb24gIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy52ZXJzaW9uIDogMixcbiAgICBub3RpZmljYXRpb25JZE51bGw6IHR5cGVvZiBvcHRpb25zLm5vdGlmaWNhdGlvbklkTnVsbCA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucy5ub3RpZmljYXRpb25JZE51bGwgOiBmYWxzZSxcbiAgfTtcblxuICB0aGlzLmNhbGxTZXJ2ZXIgPSBjYWxsU2VydmVyO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDbGllbnRCcm93c2VyO1xuXG4vKipcbiAqICBDcmVhdGVzIGEgcmVxdWVzdCBhbmQgZGlzcGF0Y2hlcyBpdCBpZiBnaXZlbiBhIGNhbGxiYWNrLlxuICogIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBtZXRob2QgQSBiYXRjaCByZXF1ZXN0IGlmIHBhc3NlZCBhbiBBcnJheSwgb3IgYSBtZXRob2QgbmFtZSBpZiBwYXNzZWQgYSBTdHJpbmdcbiAqICBAcGFyYW0ge0FycmF5fE9iamVjdH0gW3BhcmFtc10gUGFyYW1ldGVycyBmb3IgdGhlIG1ldGhvZFxuICogIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gW2lkXSBPcHRpb25hbCBpZC4gSWYgdW5kZWZpbmVkIGFuIGlkIHdpbGwgYmUgZ2VuZXJhdGVkLiBJZiBudWxsIGl0IGNyZWF0ZXMgYSBub3RpZmljYXRpb24gcmVxdWVzdFxuICogIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gUmVxdWVzdCBjYWxsYmFjay4gSWYgc3BlY2lmaWVkLCBleGVjdXRlcyB0aGUgcmVxdWVzdCByYXRoZXIgdGhhbiBvbmx5IHJldHVybmluZyBpdC5cbiAqICBAdGhyb3dzIHtUeXBlRXJyb3J9IEludmFsaWQgcGFyYW1ldGVyc1xuICogIEByZXR1cm4ge09iamVjdH0gSlNPTi1SUEMgMS4wIG9yIDIuMCBjb21wYXRpYmxlIHJlcXVlc3RcbiAqL1xuQ2xpZW50QnJvd3Nlci5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uKG1ldGhvZCwgcGFyYW1zLCBpZCwgY2FsbGJhY2spIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gIGxldCByZXF1ZXN0ID0gbnVsbDtcblxuICAvLyBpcyB0aGlzIGEgYmF0Y2ggcmVxdWVzdD9cbiAgY29uc3QgaXNCYXRjaCA9IEFycmF5LmlzQXJyYXkobWV0aG9kKSAmJiB0eXBlb2YgcGFyYW1zID09PSAnZnVuY3Rpb24nO1xuXG4gIGlmICh0aGlzLm9wdGlvbnMudmVyc2lvbiA9PT0gMSAmJiBpc0JhdGNoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSlNPTi1SUEMgMS4wIGRvZXMgbm90IHN1cHBvcnQgYmF0Y2hpbmcnKTtcbiAgfVxuXG4gIC8vIGlzIHRoaXMgYSByYXcgcmVxdWVzdD9cbiAgY29uc3QgaXNSYXcgPSAhaXNCYXRjaCAmJiBtZXRob2QgJiYgdHlwZW9mIG1ldGhvZCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHBhcmFtcyA9PT0gJ2Z1bmN0aW9uJztcblxuICBpZihpc0JhdGNoIHx8IGlzUmF3KSB7XG4gICAgY2FsbGJhY2sgPSBwYXJhbXM7XG4gICAgcmVxdWVzdCA9IG1ldGhvZDtcbiAgfSBlbHNlIHtcbiAgICBpZih0eXBlb2YgaWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gaWQ7XG4gICAgICAvLyBzcGVjaWZpY2FsbHkgdW5kZWZpbmVkIGJlY2F1c2UgXCJudWxsXCIgaXMgYSBub3RpZmljYXRpb24gcmVxdWVzdFxuICAgICAgaWQgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgY29uc3QgaGFzQ2FsbGJhY2sgPSB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbic7XG5cbiAgICB0cnkge1xuICAgICAgcmVxdWVzdCA9IGdlbmVyYXRlUmVxdWVzdChtZXRob2QsIHBhcmFtcywgaWQsIHtcbiAgICAgICAgZ2VuZXJhdG9yOiB0aGlzLm9wdGlvbnMuZ2VuZXJhdG9yLFxuICAgICAgICB2ZXJzaW9uOiB0aGlzLm9wdGlvbnMudmVyc2lvbixcbiAgICAgICAgbm90aWZpY2F0aW9uSWROdWxsOiB0aGlzLm9wdGlvbnMubm90aWZpY2F0aW9uSWROdWxsLFxuICAgICAgfSk7XG4gICAgfSBjYXRjaChlcnIpIHtcbiAgICAgIGlmKGhhc0NhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgfVxuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cblxuICAgIC8vIG5vIGNhbGxiYWNrIG1lYW5zIHdlIHNob3VsZCBqdXN0IHJldHVybiBhIHJhdyByZXF1ZXN0XG4gICAgaWYoIWhhc0NhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICB9XG5cbiAgfVxuXG4gIGxldCBtZXNzYWdlO1xuICB0cnkge1xuICAgIG1lc3NhZ2UgPSBKU09OLnN0cmluZ2lmeShyZXF1ZXN0LCB0aGlzLm9wdGlvbnMucmVwbGFjZXIpO1xuICB9IGNhdGNoKGVycikge1xuICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICB9XG5cbiAgdGhpcy5jYWxsU2VydmVyKG1lc3NhZ2UsIGZ1bmN0aW9uKGVyciwgcmVzcG9uc2UpIHtcbiAgICBzZWxmLl9wYXJzZVJlc3BvbnNlKGVyciwgcmVzcG9uc2UsIGNhbGxiYWNrKTtcbiAgfSk7XG5cbiAgLy8gYWx3YXlzIHJldHVybiB0aGUgcmF3IHJlcXVlc3RcbiAgcmV0dXJuIHJlcXVlc3Q7XG59O1xuXG4vKipcbiAqIFBhcnNlcyBhIHJlc3BvbnNlIGZyb20gYSBzZXJ2ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBlcnIgRXJyb3IgdG8gcGFzcyBvbiB0aGF0IGlzIHVucmVsYXRlZCB0byB0aGUgYWN0dWFsIHJlc3BvbnNlXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVzcG9uc2VUZXh0IEpTT04tUlBDIDEuMCBvciAyLjAgcmVzcG9uc2VcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRoYXQgd2lsbCByZWNlaXZlIGRpZmZlcmVudCBhcmd1bWVudHMgZGVwZW5kaW5nIG9uIHRoZSBhbW91bnQgb2YgcGFyYW1ldGVyc1xuICogQHByaXZhdGVcbiAqL1xuQ2xpZW50QnJvd3Nlci5wcm90b3R5cGUuX3BhcnNlUmVzcG9uc2UgPSBmdW5jdGlvbihlcnIsIHJlc3BvbnNlVGV4dCwgY2FsbGJhY2spIHtcbiAgaWYoZXJyKSB7XG4gICAgY2FsbGJhY2soZXJyKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZighcmVzcG9uc2VUZXh0KSB7XG4gICAgLy8gZW1wdHkgcmVzcG9uc2UgdGV4dCwgYXNzdW1lIHRoYXQgaXMgY29ycmVjdCBiZWNhdXNlIGl0IGNvdWxkIGJlIGFcbiAgICAvLyBub3RpZmljYXRpb24gd2hpY2ggamF5c29uIGRvZXMgbm90IGdpdmUgYW55IGJvZHkgZm9yXG4gICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gIH1cblxuICBsZXQgcmVzcG9uc2U7XG4gIHRyeSB7XG4gICAgcmVzcG9uc2UgPSBKU09OLnBhcnNlKHJlc3BvbnNlVGV4dCwgdGhpcy5vcHRpb25zLnJldml2ZXIpO1xuICB9IGNhdGNoKGVycikge1xuICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICB9XG5cbiAgaWYoY2FsbGJhY2subGVuZ3RoID09PSAzKSB7XG4gICAgLy8gaWYgY2FsbGJhY2sgbGVuZ3RoIGlzIDMsIHdlIHNwbGl0IGNhbGxiYWNrIGFyZ3VtZW50cyBvbiBlcnJvciBhbmQgcmVzcG9uc2VcblxuICAgIC8vIGlzIGJhdGNoIHJlc3BvbnNlP1xuICAgIGlmKEFycmF5LmlzQXJyYXkocmVzcG9uc2UpKSB7XG5cbiAgICAgIC8vIG5lY2Nlc2FyeSB0byBzcGxpdCBzdHJpY3RseSBvbiB2YWxpZGl0eSBhY2NvcmRpbmcgdG8gc3BlYyBoZXJlXG4gICAgICBjb25zdCBpc0Vycm9yID0gZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgcmVzLmVycm9yICE9PSAndW5kZWZpbmVkJztcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGlzTm90RXJyb3IgPSBmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgIHJldHVybiAhaXNFcnJvcihyZXMpO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHJlc3BvbnNlLmZpbHRlcihpc0Vycm9yKSwgcmVzcG9uc2UuZmlsdGVyKGlzTm90RXJyb3IpKTtcbiAgICBcbiAgICB9IGVsc2Uge1xuXG4gICAgICAvLyBzcGxpdCByZWdhcmRsZXNzIG9mIHZhbGlkaXR5XG4gICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgcmVzcG9uc2UuZXJyb3IsIHJlc3BvbnNlLnJlc3VsdCk7XG4gICAgXG4gICAgfVxuICBcbiAgfVxuXG4gIGNhbGxiYWNrKG51bGwsIHJlc3BvbnNlKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/solana/node_modules/jayson/lib/client/browser/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/solana/node_modules/jayson/lib/generateRequest.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@turnkey/solana/node_modules/jayson/lib/generateRequest.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst uuid = (__webpack_require__(/*! uuid */ \"(ssr)/./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/index.js\").v4);\n\n/**\n *  Generates a JSON-RPC 1.0 or 2.0 request\n *  @param {String} method Name of method to call\n *  @param {Array|Object} params Array of parameters passed to the method as specified, or an object of parameter names and corresponding value\n *  @param {String|Number|null} [id] Request ID can be a string, number, null for explicit notification or left out for automatic generation\n *  @param {Object} [options]\n *  @param {Number} [options.version=2] JSON-RPC version to use (1 or 2)\n *  @param {Boolean} [options.notificationIdNull=false] When true, version 2 requests will set id to null instead of omitting it\n *  @param {Function} [options.generator] Passed the request, and the options object and is expected to return a request ID\n *  @throws {TypeError} If any of the parameters are invalid\n *  @return {Object} A JSON-RPC 1.0 or 2.0 request\n *  @memberOf Utils\n */\nconst generateRequest = function(method, params, id, options) {\n  if(typeof method !== 'string') {\n    throw new TypeError(method + ' must be a string');\n  }\n\n  options = options || {};\n\n  // check valid version provided\n  const version = typeof options.version === 'number' ? options.version : 2;\n  if (version !== 1 && version !== 2) {\n    throw new TypeError(version + ' must be 1 or 2');\n  }\n\n  const request = {\n    method: method\n  };\n\n  if(version === 2) {\n    request.jsonrpc = '2.0';\n  }\n\n  if(params) {\n    // params given, but invalid?\n    if(typeof params !== 'object' && !Array.isArray(params)) {\n      throw new TypeError(params + ' must be an object, array or omitted');\n    }\n    request.params = params;\n  }\n\n  // if id was left out, generate one (null means explicit notification)\n  if(typeof(id) === 'undefined') {\n    const generator = typeof options.generator === 'function' ? options.generator : function() { return uuid(); };\n    request.id = generator(request, options);\n  } else if (version === 2 && id === null) {\n    // we have a version 2 notification\n    if (options.notificationIdNull) {\n      request.id = null; // id will not be set at all unless option provided\n    }\n  } else {\n    request.id = id;\n  }\n\n  return request;\n};\n\nmodule.exports = generateRequest;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvc29sYW5hL25vZGVfbW9kdWxlcy9qYXlzb24vbGliL2dlbmVyYXRlUmVxdWVzdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixhQUFhLHFIQUFrQjs7QUFFL0I7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLGNBQWM7QUFDMUIsWUFBWSxvQkFBb0I7QUFDaEMsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFNBQVM7QUFDckIsWUFBWSxVQUFVO0FBQ3RCLGFBQWEsV0FBVztBQUN4QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUdBQWlHO0FBQ2pHO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbnVyc2VibG9jLy4vbm9kZV9tb2R1bGVzL0B0dXJua2V5L3NvbGFuYS9ub2RlX21vZHVsZXMvamF5c29uL2xpYi9nZW5lcmF0ZVJlcXVlc3QuanM/Y2NmNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHV1aWQgPSByZXF1aXJlKCd1dWlkJykudjQ7XG5cbi8qKlxuICogIEdlbmVyYXRlcyBhIEpTT04tUlBDIDEuMCBvciAyLjAgcmVxdWVzdFxuICogIEBwYXJhbSB7U3RyaW5nfSBtZXRob2QgTmFtZSBvZiBtZXRob2QgdG8gY2FsbFxuICogIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBwYXJhbXMgQXJyYXkgb2YgcGFyYW1ldGVycyBwYXNzZWQgdG8gdGhlIG1ldGhvZCBhcyBzcGVjaWZpZWQsIG9yIGFuIG9iamVjdCBvZiBwYXJhbWV0ZXIgbmFtZXMgYW5kIGNvcnJlc3BvbmRpbmcgdmFsdWVcbiAqICBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ8bnVsbH0gW2lkXSBSZXF1ZXN0IElEIGNhbiBiZSBhIHN0cmluZywgbnVtYmVyLCBudWxsIGZvciBleHBsaWNpdCBub3RpZmljYXRpb24gb3IgbGVmdCBvdXQgZm9yIGF1dG9tYXRpYyBnZW5lcmF0aW9uXG4gKiAgQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy52ZXJzaW9uPTJdIEpTT04tUlBDIHZlcnNpb24gdG8gdXNlICgxIG9yIDIpXG4gKiAgQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5ub3RpZmljYXRpb25JZE51bGw9ZmFsc2VdIFdoZW4gdHJ1ZSwgdmVyc2lvbiAyIHJlcXVlc3RzIHdpbGwgc2V0IGlkIHRvIG51bGwgaW5zdGVhZCBvZiBvbWl0dGluZyBpdFxuICogIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmdlbmVyYXRvcl0gUGFzc2VkIHRoZSByZXF1ZXN0LCBhbmQgdGhlIG9wdGlvbnMgb2JqZWN0IGFuZCBpcyBleHBlY3RlZCB0byByZXR1cm4gYSByZXF1ZXN0IElEXG4gKiAgQHRocm93cyB7VHlwZUVycm9yfSBJZiBhbnkgb2YgdGhlIHBhcmFtZXRlcnMgYXJlIGludmFsaWRcbiAqICBAcmV0dXJuIHtPYmplY3R9IEEgSlNPTi1SUEMgMS4wIG9yIDIuMCByZXF1ZXN0XG4gKiAgQG1lbWJlck9mIFV0aWxzXG4gKi9cbmNvbnN0IGdlbmVyYXRlUmVxdWVzdCA9IGZ1bmN0aW9uKG1ldGhvZCwgcGFyYW1zLCBpZCwgb3B0aW9ucykge1xuICBpZih0eXBlb2YgbWV0aG9kICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IobWV0aG9kICsgJyBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBjaGVjayB2YWxpZCB2ZXJzaW9uIHByb3ZpZGVkXG4gIGNvbnN0IHZlcnNpb24gPSB0eXBlb2Ygb3B0aW9ucy52ZXJzaW9uID09PSAnbnVtYmVyJyA/IG9wdGlvbnMudmVyc2lvbiA6IDI7XG4gIGlmICh2ZXJzaW9uICE9PSAxICYmIHZlcnNpb24gIT09IDIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHZlcnNpb24gKyAnIG11c3QgYmUgMSBvciAyJyk7XG4gIH1cblxuICBjb25zdCByZXF1ZXN0ID0ge1xuICAgIG1ldGhvZDogbWV0aG9kXG4gIH07XG5cbiAgaWYodmVyc2lvbiA9PT0gMikge1xuICAgIHJlcXVlc3QuanNvbnJwYyA9ICcyLjAnO1xuICB9XG5cbiAgaWYocGFyYW1zKSB7XG4gICAgLy8gcGFyYW1zIGdpdmVuLCBidXQgaW52YWxpZD9cbiAgICBpZih0eXBlb2YgcGFyYW1zICE9PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXMpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHBhcmFtcyArICcgbXVzdCBiZSBhbiBvYmplY3QsIGFycmF5IG9yIG9taXR0ZWQnKTtcbiAgICB9XG4gICAgcmVxdWVzdC5wYXJhbXMgPSBwYXJhbXM7XG4gIH1cblxuICAvLyBpZiBpZCB3YXMgbGVmdCBvdXQsIGdlbmVyYXRlIG9uZSAobnVsbCBtZWFucyBleHBsaWNpdCBub3RpZmljYXRpb24pXG4gIGlmKHR5cGVvZihpZCkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc3QgZ2VuZXJhdG9yID0gdHlwZW9mIG9wdGlvbnMuZ2VuZXJhdG9yID09PSAnZnVuY3Rpb24nID8gb3B0aW9ucy5nZW5lcmF0b3IgOiBmdW5jdGlvbigpIHsgcmV0dXJuIHV1aWQoKTsgfTtcbiAgICByZXF1ZXN0LmlkID0gZ2VuZXJhdG9yKHJlcXVlc3QsIG9wdGlvbnMpO1xuICB9IGVsc2UgaWYgKHZlcnNpb24gPT09IDIgJiYgaWQgPT09IG51bGwpIHtcbiAgICAvLyB3ZSBoYXZlIGEgdmVyc2lvbiAyIG5vdGlmaWNhdGlvblxuICAgIGlmIChvcHRpb25zLm5vdGlmaWNhdGlvbklkTnVsbCkge1xuICAgICAgcmVxdWVzdC5pZCA9IG51bGw7IC8vIGlkIHdpbGwgbm90IGJlIHNldCBhdCBhbGwgdW5sZXNzIG9wdGlvbiBwcm92aWRlZFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXF1ZXN0LmlkID0gaWQ7XG4gIH1cblxuICByZXR1cm4gcmVxdWVzdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZ2VuZXJhdGVSZXF1ZXN0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/solana/node_modules/jayson/lib/generateRequest.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/index.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NIL: () => (/* reexport safe */ _nil_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]),\n/* harmony export */   parse: () => (/* reexport safe */ _parse_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"]),\n/* harmony export */   stringify: () => (/* reexport safe */ _stringify_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"]),\n/* harmony export */   v1: () => (/* reexport safe */ _v1_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   v3: () => (/* reexport safe */ _v3_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   v4: () => (/* reexport safe */ _v4_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   v5: () => (/* reexport safe */ _v5_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]),\n/* harmony export */   validate: () => (/* reexport safe */ _validate_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]),\n/* harmony export */   version: () => (/* reexport safe */ _version_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _v1_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v1.js */ \"(ssr)/./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/v1.js\");\n/* harmony import */ var _v3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./v3.js */ \"(ssr)/./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/v3.js\");\n/* harmony import */ var _v4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./v4.js */ \"(ssr)/./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/v4.js\");\n/* harmony import */ var _v5_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./v5.js */ \"(ssr)/./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/v5.js\");\n/* harmony import */ var _nil_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./nil.js */ \"(ssr)/./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/nil.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./version.js */ \"(ssr)/./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/version.js\");\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./validate.js */ \"(ssr)/./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/validate.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./stringify.js */ \"(ssr)/./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/stringify.js\");\n/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./parse.js */ \"(ssr)/./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/parse.js\");\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvc29sYW5hL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDUTtBQUNFO0FBQ0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9udXJzZWJsb2MvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvc29sYW5hL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvaW5kZXguanM/Y2FhNiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBkZWZhdWx0IGFzIHYxIH0gZnJvbSAnLi92MS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHYzIH0gZnJvbSAnLi92My5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHY0IH0gZnJvbSAnLi92NC5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHY1IH0gZnJvbSAnLi92NS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIE5JTCB9IGZyb20gJy4vbmlsLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdmVyc2lvbiB9IGZyb20gJy4vdmVyc2lvbi5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHZhbGlkYXRlIH0gZnJvbSAnLi92YWxpZGF0ZS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHN0cmluZ2lmeSB9IGZyb20gJy4vc3RyaW5naWZ5LmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgcGFyc2UgfSBmcm9tICcuL3BhcnNlLmpzJzsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/md5.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/md5.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);\n\n\nfunction md5(bytes) {\n  if (Array.isArray(bytes)) {\n    bytes = Buffer.from(bytes);\n  } else if (typeof bytes === 'string') {\n    bytes = Buffer.from(bytes, 'utf8');\n  }\n\n  return crypto__WEBPACK_IMPORTED_MODULE_0___default().createHash('md5').update(bytes).digest();\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (md5);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvc29sYW5hL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvbWQ1LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUEsU0FBUyx3REFBaUI7QUFDMUI7O0FBRUEsaUVBQWUsR0FBRyIsInNvdXJjZXMiOlsid2VicGFjazovL251cnNlYmxvYy8uL25vZGVfbW9kdWxlcy9AdHVybmtleS9zb2xhbmEvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9tZDUuanM/ZDE0OCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY3J5cHRvIGZyb20gJ2NyeXB0byc7XG5cbmZ1bmN0aW9uIG1kNShieXRlcykge1xuICBpZiAoQXJyYXkuaXNBcnJheShieXRlcykpIHtcbiAgICBieXRlcyA9IEJ1ZmZlci5mcm9tKGJ5dGVzKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgYnl0ZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgYnl0ZXMgPSBCdWZmZXIuZnJvbShieXRlcywgJ3V0ZjgnKTtcbiAgfVxuXG4gIHJldHVybiBjcnlwdG8uY3JlYXRlSGFzaCgnbWQ1JykudXBkYXRlKGJ5dGVzKS5kaWdlc3QoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWQ1OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/md5.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/nil.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/nil.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ('00000000-0000-0000-0000-000000000000');//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvc29sYW5hL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvbmlsLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9udXJzZWJsb2MvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvc29sYW5hL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvbmlsLmpzPzU4OTQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgJzAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMCc7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/nil.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/parse.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/parse.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"(ssr)/./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/validate.js\");\n\n\nfunction parse(uuid) {\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  let v;\n  const arr = new Uint8Array(16); // Parse ########-....-....-....-............\n\n  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n  arr[1] = v >>> 16 & 0xff;\n  arr[2] = v >>> 8 & 0xff;\n  arr[3] = v & 0xff; // Parse ........-####-....-....-............\n\n  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n  arr[5] = v & 0xff; // Parse ........-....-####-....-............\n\n  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n  arr[7] = v & 0xff; // Parse ........-....-....-####-............\n\n  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n  arr[9] = v & 0xff; // Parse ........-....-....-....-############\n  // (Use \"/\" to avoid 32-bit truncation when bit-shifting high-order bytes)\n\n  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;\n  arr[11] = v / 0x100000000 & 0xff;\n  arr[12] = v >>> 24 & 0xff;\n  arr[13] = v >>> 16 & 0xff;\n  arr[14] = v >>> 8 & 0xff;\n  arr[15] = v & 0xff;\n  return arr;\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (parse);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvc29sYW5hL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvcGFyc2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBcUM7O0FBRXJDO0FBQ0EsT0FBTyx3REFBUTtBQUNmO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLEtBQUsiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9udXJzZWJsb2MvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvc29sYW5hL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvcGFyc2UuanM/Mjg2NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdmFsaWRhdGUgZnJvbSAnLi92YWxpZGF0ZS5qcyc7XG5cbmZ1bmN0aW9uIHBhcnNlKHV1aWQpIHtcbiAgaWYgKCF2YWxpZGF0ZSh1dWlkKSkge1xuICAgIHRocm93IFR5cGVFcnJvcignSW52YWxpZCBVVUlEJyk7XG4gIH1cblxuICBsZXQgdjtcbiAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMTYpOyAvLyBQYXJzZSAjIyMjIyMjIy0uLi4uLS4uLi4tLi4uLi0uLi4uLi4uLi4uLi5cblxuICBhcnJbMF0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoMCwgOCksIDE2KSkgPj4+IDI0O1xuICBhcnJbMV0gPSB2ID4+PiAxNiAmIDB4ZmY7XG4gIGFyclsyXSA9IHYgPj4+IDggJiAweGZmO1xuICBhcnJbM10gPSB2ICYgMHhmZjsgLy8gUGFyc2UgLi4uLi4uLi4tIyMjIy0uLi4uLS4uLi4tLi4uLi4uLi4uLi4uXG5cbiAgYXJyWzRdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDksIDEzKSwgMTYpKSA+Pj4gODtcbiAgYXJyWzVdID0gdiAmIDB4ZmY7IC8vIFBhcnNlIC4uLi4uLi4uLS4uLi4tIyMjIy0uLi4uLS4uLi4uLi4uLi4uLlxuXG4gIGFycls2XSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSgxNCwgMTgpLCAxNikpID4+PiA4O1xuICBhcnJbN10gPSB2ICYgMHhmZjsgLy8gUGFyc2UgLi4uLi4uLi4tLi4uLi0uLi4uLSMjIyMtLi4uLi4uLi4uLi4uXG5cbiAgYXJyWzhdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDE5LCAyMyksIDE2KSkgPj4+IDg7XG4gIGFycls5XSA9IHYgJiAweGZmOyAvLyBQYXJzZSAuLi4uLi4uLi0uLi4uLS4uLi4tLi4uLi0jIyMjIyMjIyMjIyNcbiAgLy8gKFVzZSBcIi9cIiB0byBhdm9pZCAzMi1iaXQgdHJ1bmNhdGlvbiB3aGVuIGJpdC1zaGlmdGluZyBoaWdoLW9yZGVyIGJ5dGVzKVxuXG4gIGFyclsxMF0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoMjQsIDM2KSwgMTYpKSAvIDB4MTAwMDAwMDAwMDAgJiAweGZmO1xuICBhcnJbMTFdID0gdiAvIDB4MTAwMDAwMDAwICYgMHhmZjtcbiAgYXJyWzEyXSA9IHYgPj4+IDI0ICYgMHhmZjtcbiAgYXJyWzEzXSA9IHYgPj4+IDE2ICYgMHhmZjtcbiAgYXJyWzE0XSA9IHYgPj4+IDggJiAweGZmO1xuICBhcnJbMTVdID0gdiAmIDB4ZmY7XG4gIHJldHVybiBhcnI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHBhcnNlOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/parse.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/regex.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/regex.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvc29sYW5hL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvcmVnZXguanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWMsRUFBRSxVQUFVLEVBQUUsZUFBZSxFQUFFLGdCQUFnQixFQUFFLFVBQVUsR0FBRyx5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9udXJzZWJsb2MvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvc29sYW5hL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvcmVnZXguanM/ZDE5MSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCAvXig/OlswLTlhLWZdezh9LVswLTlhLWZdezR9LVsxLTVdWzAtOWEtZl17M30tWzg5YWJdWzAtOWEtZl17M30tWzAtOWEtZl17MTJ9fDAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMCkkL2k7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/regex.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/rng.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/rng.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ rng)\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);\n\nconst rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate\n\nlet poolPtr = rnds8Pool.length;\nfunction rng() {\n  if (poolPtr > rnds8Pool.length - 16) {\n    crypto__WEBPACK_IMPORTED_MODULE_0___default().randomFillSync(rnds8Pool);\n    poolPtr = 0;\n  }\n\n  return rnds8Pool.slice(poolPtr, poolPtr += 16);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvc29sYW5hL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvcm5nLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE0QjtBQUM1Qix1Q0FBdUM7O0FBRXZDO0FBQ2U7QUFDZjtBQUNBLElBQUksNERBQXFCO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL251cnNlYmxvYy8uL25vZGVfbW9kdWxlcy9AdHVybmtleS9zb2xhbmEvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9ybmcuanM/ZWFhNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY3J5cHRvIGZyb20gJ2NyeXB0byc7XG5jb25zdCBybmRzOFBvb2wgPSBuZXcgVWludDhBcnJheSgyNTYpOyAvLyAjIG9mIHJhbmRvbSB2YWx1ZXMgdG8gcHJlLWFsbG9jYXRlXG5cbmxldCBwb29sUHRyID0gcm5kczhQb29sLmxlbmd0aDtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJuZygpIHtcbiAgaWYgKHBvb2xQdHIgPiBybmRzOFBvb2wubGVuZ3RoIC0gMTYpIHtcbiAgICBjcnlwdG8ucmFuZG9tRmlsbFN5bmMocm5kczhQb29sKTtcbiAgICBwb29sUHRyID0gMDtcbiAgfVxuXG4gIHJldHVybiBybmRzOFBvb2wuc2xpY2UocG9vbFB0ciwgcG9vbFB0ciArPSAxNik7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/rng.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/sha1.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/sha1.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);\n\n\nfunction sha1(bytes) {\n  if (Array.isArray(bytes)) {\n    bytes = Buffer.from(bytes);\n  } else if (typeof bytes === 'string') {\n    bytes = Buffer.from(bytes, 'utf8');\n  }\n\n  return crypto__WEBPACK_IMPORTED_MODULE_0___default().createHash('sha1').update(bytes).digest();\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sha1);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvc29sYW5hL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvc2hhMS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBLFNBQVMsd0RBQWlCO0FBQzFCOztBQUVBLGlFQUFlLElBQUkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9udXJzZWJsb2MvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvc29sYW5hL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvc2hhMS5qcz83YzQwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcnlwdG8gZnJvbSAnY3J5cHRvJztcblxuZnVuY3Rpb24gc2hhMShieXRlcykge1xuICBpZiAoQXJyYXkuaXNBcnJheShieXRlcykpIHtcbiAgICBieXRlcyA9IEJ1ZmZlci5mcm9tKGJ5dGVzKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgYnl0ZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgYnl0ZXMgPSBCdWZmZXIuZnJvbShieXRlcywgJ3V0ZjgnKTtcbiAgfVxuXG4gIHJldHVybiBjcnlwdG8uY3JlYXRlSGFzaCgnc2hhMScpLnVwZGF0ZShieXRlcykuZGlnZXN0KCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHNoYTE7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/sha1.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/stringify.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/stringify.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"(ssr)/./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/validate.js\");\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).substr(1));\n}\n\nfunction stringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stringify);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvc29sYW5hL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvc3RyaW5naWZ5LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNGdCQUE0Z0I7QUFDNWdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU8sd0RBQVE7QUFDZjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUVBQWUsU0FBUyIsInNvdXJjZXMiOlsid2VicGFjazovL251cnNlYmxvYy8uL25vZGVfbW9kdWxlcy9AdHVybmtleS9zb2xhbmEvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9zdHJpbmdpZnkuanM/MDA3OCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdmFsaWRhdGUgZnJvbSAnLi92YWxpZGF0ZS5qcyc7XG4vKipcbiAqIENvbnZlcnQgYXJyYXkgb2YgMTYgYnl0ZSB2YWx1ZXMgdG8gVVVJRCBzdHJpbmcgZm9ybWF0IG9mIHRoZSBmb3JtOlxuICogWFhYWFhYWFgtWFhYWC1YWFhYLVhYWFgtWFhYWFhYWFhYWFhYXG4gKi9cblxuY29uc3QgYnl0ZVRvSGV4ID0gW107XG5cbmZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgYnl0ZVRvSGV4LnB1c2goKGkgKyAweDEwMCkudG9TdHJpbmcoMTYpLnN1YnN0cigxKSk7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeShhcnIsIG9mZnNldCA9IDApIHtcbiAgLy8gTm90ZTogQmUgY2FyZWZ1bCBlZGl0aW5nIHRoaXMgY29kZSEgIEl0J3MgYmVlbiB0dW5lZCBmb3IgcGVyZm9ybWFuY2VcbiAgLy8gYW5kIHdvcmtzIGluIHdheXMgeW91IG1heSBub3QgZXhwZWN0LiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkL3B1bGwvNDM0XG4gIGNvbnN0IHV1aWQgPSAoYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAwXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDFdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAzXV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDRdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNV1dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA2XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDddXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgOF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA5XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEwXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDExXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEyXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEzXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDE0XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDE1XV0pLnRvTG93ZXJDYXNlKCk7IC8vIENvbnNpc3RlbmN5IGNoZWNrIGZvciB2YWxpZCBVVUlELiAgSWYgdGhpcyB0aHJvd3MsIGl0J3MgbGlrZWx5IGR1ZSB0byBvbmVcbiAgLy8gb2YgdGhlIGZvbGxvd2luZzpcbiAgLy8gLSBPbmUgb3IgbW9yZSBpbnB1dCBhcnJheSB2YWx1ZXMgZG9uJ3QgbWFwIHRvIGEgaGV4IG9jdGV0IChsZWFkaW5nIHRvXG4gIC8vIFwidW5kZWZpbmVkXCIgaW4gdGhlIHV1aWQpXG4gIC8vIC0gSW52YWxpZCBpbnB1dCB2YWx1ZXMgZm9yIHRoZSBSRkMgYHZlcnNpb25gIG9yIGB2YXJpYW50YCBmaWVsZHNcblxuICBpZiAoIXZhbGlkYXRlKHV1aWQpKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKCdTdHJpbmdpZmllZCBVVUlEIGlzIGludmFsaWQnKTtcbiAgfVxuXG4gIHJldHVybiB1dWlkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzdHJpbmdpZnk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/stringify.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/v1.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/v1.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rng.js */ \"(ssr)/./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/rng.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"(ssr)/./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/stringify.js\");\n\n // **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nlet _nodeId;\n\nlet _clockseq; // Previous uuid creation time\n\n\nlet _lastMSecs = 0;\nlet _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details\n\nfunction v1(options, buf, offset) {\n  let i = buf && offset || 0;\n  const b = buf || new Array(16);\n  options = options || {};\n  let node = options.node || _nodeId;\n  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n\n  if (node == null || clockseq == null) {\n    const seedBytes = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];\n    }\n\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n\n\n  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n\n  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)\n\n  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression\n\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n\n\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  } // Per 4.2.1.2 Throw error if too many uuids are requested\n\n\n  if (nsecs >= 10000) {\n    throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n\n  msecs += 12219292800000; // `time_low`\n\n  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff; // `time_mid`\n\n  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff; // `time_high_and_version`\n\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n\n  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n\n  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`\n\n  b[i++] = clockseq & 0xff; // `node`\n\n  for (let n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf || (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(b);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v1);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvc29sYW5hL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTJCO0FBQ1ksQ0FBQztBQUN4QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZUFBZTs7O0FBR2Y7QUFDQSxvQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0Y7QUFDaEY7QUFDQTs7QUFFQTtBQUNBLHdEQUF3RCwrQ0FBRzs7QUFFM0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOzs7QUFHQSx3RUFBd0U7QUFDeEU7O0FBRUEsNEVBQTRFOztBQUU1RSxnRUFBZ0U7O0FBRWhFO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7OztBQUdBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3Qjs7QUFFeEIsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBLHVCQUF1Qjs7QUFFdkIsb0NBQW9DOztBQUVwQyw4QkFBOEI7O0FBRTlCLGtDQUFrQzs7QUFFbEMsNEJBQTRCOztBQUU1QixrQkFBa0IsT0FBTztBQUN6QjtBQUNBOztBQUVBLGdCQUFnQix5REFBUztBQUN6Qjs7QUFFQSxpRUFBZSxFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbnVyc2VibG9jLy4vbm9kZV9tb2R1bGVzL0B0dXJua2V5L3NvbGFuYS9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3YxLmpzPzRkY2YiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHJuZyBmcm9tICcuL3JuZy5qcyc7XG5pbXBvcnQgc3RyaW5naWZ5IGZyb20gJy4vc3RyaW5naWZ5LmpzJzsgLy8gKipgdjEoKWAgLSBHZW5lcmF0ZSB0aW1lLWJhc2VkIFVVSUQqKlxuLy9cbi8vIEluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9MaW9zSy9VVUlELmpzXG4vLyBhbmQgaHR0cDovL2RvY3MucHl0aG9uLm9yZy9saWJyYXJ5L3V1aWQuaHRtbFxuXG5sZXQgX25vZGVJZDtcblxubGV0IF9jbG9ja3NlcTsgLy8gUHJldmlvdXMgdXVpZCBjcmVhdGlvbiB0aW1lXG5cblxubGV0IF9sYXN0TVNlY3MgPSAwO1xubGV0IF9sYXN0TlNlY3MgPSAwOyAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkIGZvciBBUEkgZGV0YWlsc1xuXG5mdW5jdGlvbiB2MShvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICBsZXQgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMDtcbiAgY29uc3QgYiA9IGJ1ZiB8fCBuZXcgQXJyYXkoMTYpO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgbGV0IG5vZGUgPSBvcHRpb25zLm5vZGUgfHwgX25vZGVJZDtcbiAgbGV0IGNsb2Nrc2VxID0gb3B0aW9ucy5jbG9ja3NlcSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jbG9ja3NlcSA6IF9jbG9ja3NlcTsgLy8gbm9kZSBhbmQgY2xvY2tzZXEgbmVlZCB0byBiZSBpbml0aWFsaXplZCB0byByYW5kb20gdmFsdWVzIGlmIHRoZXkncmUgbm90XG4gIC8vIHNwZWNpZmllZC4gIFdlIGRvIHRoaXMgbGF6aWx5IHRvIG1pbmltaXplIGlzc3VlcyByZWxhdGVkIHRvIGluc3VmZmljaWVudFxuICAvLyBzeXN0ZW0gZW50cm9weS4gIFNlZSAjMTg5XG5cbiAgaWYgKG5vZGUgPT0gbnVsbCB8fCBjbG9ja3NlcSA9PSBudWxsKSB7XG4gICAgY29uc3Qgc2VlZEJ5dGVzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IHJuZykoKTtcblxuICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgIC8vIFBlciA0LjUsIGNyZWF0ZSBhbmQgNDgtYml0IG5vZGUgaWQsICg0NyByYW5kb20gYml0cyArIG11bHRpY2FzdCBiaXQgPSAxKVxuICAgICAgbm9kZSA9IF9ub2RlSWQgPSBbc2VlZEJ5dGVzWzBdIHwgMHgwMSwgc2VlZEJ5dGVzWzFdLCBzZWVkQnl0ZXNbMl0sIHNlZWRCeXRlc1szXSwgc2VlZEJ5dGVzWzRdLCBzZWVkQnl0ZXNbNV1dO1xuICAgIH1cblxuICAgIGlmIChjbG9ja3NlcSA9PSBudWxsKSB7XG4gICAgICAvLyBQZXIgNC4yLjIsIHJhbmRvbWl6ZSAoMTQgYml0KSBjbG9ja3NlcVxuICAgICAgY2xvY2tzZXEgPSBfY2xvY2tzZXEgPSAoc2VlZEJ5dGVzWzZdIDw8IDggfCBzZWVkQnl0ZXNbN10pICYgMHgzZmZmO1xuICAgIH1cbiAgfSAvLyBVVUlEIHRpbWVzdGFtcHMgYXJlIDEwMCBuYW5vLXNlY29uZCB1bml0cyBzaW5jZSB0aGUgR3JlZ29yaWFuIGVwb2NoLFxuICAvLyAoMTU4Mi0xMC0xNSAwMDowMCkuICBKU051bWJlcnMgYXJlbid0IHByZWNpc2UgZW5vdWdoIGZvciB0aGlzLCBzb1xuICAvLyB0aW1lIGlzIGhhbmRsZWQgaW50ZXJuYWxseSBhcyAnbXNlY3MnIChpbnRlZ2VyIG1pbGxpc2Vjb25kcykgYW5kICduc2VjcydcbiAgLy8gKDEwMC1uYW5vc2Vjb25kcyBvZmZzZXQgZnJvbSBtc2Vjcykgc2luY2UgdW5peCBlcG9jaCwgMTk3MC0wMS0wMSAwMDowMC5cblxuXG4gIGxldCBtc2VjcyA9IG9wdGlvbnMubXNlY3MgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubXNlY3MgOiBEYXRlLm5vdygpOyAvLyBQZXIgNC4yLjEuMiwgdXNlIGNvdW50IG9mIHV1aWQncyBnZW5lcmF0ZWQgZHVyaW5nIHRoZSBjdXJyZW50IGNsb2NrXG4gIC8vIGN5Y2xlIHRvIHNpbXVsYXRlIGhpZ2hlciByZXNvbHV0aW9uIGNsb2NrXG5cbiAgbGV0IG5zZWNzID0gb3B0aW9ucy5uc2VjcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5uc2VjcyA6IF9sYXN0TlNlY3MgKyAxOyAvLyBUaW1lIHNpbmNlIGxhc3QgdXVpZCBjcmVhdGlvbiAoaW4gbXNlY3MpXG5cbiAgY29uc3QgZHQgPSBtc2VjcyAtIF9sYXN0TVNlY3MgKyAobnNlY3MgLSBfbGFzdE5TZWNzKSAvIDEwMDAwOyAvLyBQZXIgNC4yLjEuMiwgQnVtcCBjbG9ja3NlcSBvbiBjbG9jayByZWdyZXNzaW9uXG5cbiAgaWYgKGR0IDwgMCAmJiBvcHRpb25zLmNsb2Nrc2VxID09PSB1bmRlZmluZWQpIHtcbiAgICBjbG9ja3NlcSA9IGNsb2Nrc2VxICsgMSAmIDB4M2ZmZjtcbiAgfSAvLyBSZXNldCBuc2VjcyBpZiBjbG9jayByZWdyZXNzZXMgKG5ldyBjbG9ja3NlcSkgb3Igd2UndmUgbW92ZWQgb250byBhIG5ld1xuICAvLyB0aW1lIGludGVydmFsXG5cblxuICBpZiAoKGR0IDwgMCB8fCBtc2VjcyA+IF9sYXN0TVNlY3MpICYmIG9wdGlvbnMubnNlY3MgPT09IHVuZGVmaW5lZCkge1xuICAgIG5zZWNzID0gMDtcbiAgfSAvLyBQZXIgNC4yLjEuMiBUaHJvdyBlcnJvciBpZiB0b28gbWFueSB1dWlkcyBhcmUgcmVxdWVzdGVkXG5cblxuICBpZiAobnNlY3MgPj0gMTAwMDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1dWlkLnYxKCk6IENhbid0IGNyZWF0ZSBtb3JlIHRoYW4gMTBNIHV1aWRzL3NlY1wiKTtcbiAgfVxuXG4gIF9sYXN0TVNlY3MgPSBtc2VjcztcbiAgX2xhc3ROU2VjcyA9IG5zZWNzO1xuICBfY2xvY2tzZXEgPSBjbG9ja3NlcTsgLy8gUGVyIDQuMS40IC0gQ29udmVydCBmcm9tIHVuaXggZXBvY2ggdG8gR3JlZ29yaWFuIGVwb2NoXG5cbiAgbXNlY3MgKz0gMTIyMTkyOTI4MDAwMDA7IC8vIGB0aW1lX2xvd2BcblxuICBjb25zdCB0bCA9ICgobXNlY3MgJiAweGZmZmZmZmYpICogMTAwMDAgKyBuc2VjcykgJSAweDEwMDAwMDAwMDtcbiAgYltpKytdID0gdGwgPj4+IDI0ICYgMHhmZjtcbiAgYltpKytdID0gdGwgPj4+IDE2ICYgMHhmZjtcbiAgYltpKytdID0gdGwgPj4+IDggJiAweGZmO1xuICBiW2krK10gPSB0bCAmIDB4ZmY7IC8vIGB0aW1lX21pZGBcblxuICBjb25zdCB0bWggPSBtc2VjcyAvIDB4MTAwMDAwMDAwICogMTAwMDAgJiAweGZmZmZmZmY7XG4gIGJbaSsrXSA9IHRtaCA+Pj4gOCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRtaCAmIDB4ZmY7IC8vIGB0aW1lX2hpZ2hfYW5kX3ZlcnNpb25gXG5cbiAgYltpKytdID0gdG1oID4+PiAyNCAmIDB4ZiB8IDB4MTA7IC8vIGluY2x1ZGUgdmVyc2lvblxuXG4gIGJbaSsrXSA9IHRtaCA+Pj4gMTYgJiAweGZmOyAvLyBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGAgKFBlciA0LjIuMiAtIGluY2x1ZGUgdmFyaWFudClcblxuICBiW2krK10gPSBjbG9ja3NlcSA+Pj4gOCB8IDB4ODA7IC8vIGBjbG9ja19zZXFfbG93YFxuXG4gIGJbaSsrXSA9IGNsb2Nrc2VxICYgMHhmZjsgLy8gYG5vZGVgXG5cbiAgZm9yIChsZXQgbiA9IDA7IG4gPCA2OyArK24pIHtcbiAgICBiW2kgKyBuXSA9IG5vZGVbbl07XG4gIH1cblxuICByZXR1cm4gYnVmIHx8IHN0cmluZ2lmeShiKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdjE7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/v1.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/v3.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/v3.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v35.js */ \"(ssr)/./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/v35.js\");\n/* harmony import */ var _md5_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./md5.js */ \"(ssr)/./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/md5.js\");\n\n\nconst v3 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])('v3', 0x30, _md5_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v3);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvc29sYW5hL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTJCO0FBQ0E7QUFDM0IsV0FBVyxtREFBRyxhQUFhLCtDQUFHO0FBQzlCLGlFQUFlLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9udXJzZWJsb2MvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvc29sYW5hL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjMuanM/NjI2ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdjM1IGZyb20gJy4vdjM1LmpzJztcbmltcG9ydCBtZDUgZnJvbSAnLi9tZDUuanMnO1xuY29uc3QgdjMgPSB2MzUoJ3YzJywgMHgzMCwgbWQ1KTtcbmV4cG9ydCBkZWZhdWx0IHYzOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/v3.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/v35.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/v35.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DNS: () => (/* binding */ DNS),\n/* harmony export */   URL: () => (/* binding */ URL),\n/* harmony export */   \"default\": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"(ssr)/./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/stringify.js\");\n/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse.js */ \"(ssr)/./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/parse.js\");\n\n\n\nfunction stringToBytes(str) {\n  str = unescape(encodeURIComponent(str)); // UTF8 escape\n\n  const bytes = [];\n\n  for (let i = 0; i < str.length; ++i) {\n    bytes.push(str.charCodeAt(i));\n  }\n\n  return bytes;\n}\n\nconst DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nconst URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\n/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, version, hashfunc) {\n  function generateUUID(value, namespace, buf, offset) {\n    if (typeof value === 'string') {\n      value = stringToBytes(value);\n    }\n\n    if (typeof namespace === 'string') {\n      namespace = (0,_parse_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(namespace);\n    }\n\n    if (namespace.length !== 16) {\n      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    } // Compute hash of namespace and value, Per 4.3\n    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =\n    // hashfunc([...namespace, ... value])`\n\n\n    let bytes = new Uint8Array(16 + value.length);\n    bytes.set(namespace);\n    bytes.set(value, namespace.length);\n    bytes = hashfunc(bytes);\n    bytes[6] = bytes[6] & 0x0f | version;\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n\n    if (buf) {\n      offset = offset || 0;\n\n      for (let i = 0; i < 16; ++i) {\n        buf[offset + i] = bytes[i];\n      }\n\n      return buf;\n    }\n\n    return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(bytes);\n  } // Function#name is not settable on some platforms (#270)\n\n\n  try {\n    generateUUID.name = name; // eslint-disable-next-line no-empty\n  } catch (err) {} // For CommonJS default export support\n\n\n  generateUUID.DNS = DNS;\n  generateUUID.URL = URL;\n  return generateUUID;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvc29sYW5hL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjM1LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXVDO0FBQ1I7O0FBRS9CO0FBQ0EsMkNBQTJDOztBQUUzQzs7QUFFQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFTztBQUNBO0FBQ1AsNkJBQWUsb0NBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IscURBQUs7QUFDdkI7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0IsUUFBUTtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsV0FBVyx5REFBUztBQUNwQixJQUFJOzs7QUFHSjtBQUNBLDhCQUE4QjtBQUM5QixJQUFJLGVBQWU7OztBQUduQjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL251cnNlYmxvYy8uL25vZGVfbW9kdWxlcy9AdHVybmtleS9zb2xhbmEvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS92MzUuanM/OTBjNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgc3RyaW5naWZ5IGZyb20gJy4vc3RyaW5naWZ5LmpzJztcbmltcG9ydCBwYXJzZSBmcm9tICcuL3BhcnNlLmpzJztcblxuZnVuY3Rpb24gc3RyaW5nVG9CeXRlcyhzdHIpIHtcbiAgc3RyID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpOyAvLyBVVEY4IGVzY2FwZVxuXG4gIGNvbnN0IGJ5dGVzID0gW107XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBieXRlcy5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpKTtcbiAgfVxuXG4gIHJldHVybiBieXRlcztcbn1cblxuZXhwb3J0IGNvbnN0IEROUyA9ICc2YmE3YjgxMC05ZGFkLTExZDEtODBiNC0wMGMwNGZkNDMwYzgnO1xuZXhwb3J0IGNvbnN0IFVSTCA9ICc2YmE3YjgxMS05ZGFkLTExZDEtODBiNC0wMGMwNGZkNDMwYzgnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKG5hbWUsIHZlcnNpb24sIGhhc2hmdW5jKSB7XG4gIGZ1bmN0aW9uIGdlbmVyYXRlVVVJRCh2YWx1ZSwgbmFtZXNwYWNlLCBidWYsIG9mZnNldCkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YWx1ZSA9IHN0cmluZ1RvQnl0ZXModmFsdWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmFtZXNwYWNlID09PSAnc3RyaW5nJykge1xuICAgICAgbmFtZXNwYWNlID0gcGFyc2UobmFtZXNwYWNlKTtcbiAgICB9XG5cbiAgICBpZiAobmFtZXNwYWNlLmxlbmd0aCAhPT0gMTYpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcignTmFtZXNwYWNlIG11c3QgYmUgYXJyYXktbGlrZSAoMTYgaXRlcmFibGUgaW50ZWdlciB2YWx1ZXMsIDAtMjU1KScpO1xuICAgIH0gLy8gQ29tcHV0ZSBoYXNoIG9mIG5hbWVzcGFjZSBhbmQgdmFsdWUsIFBlciA0LjNcbiAgICAvLyBGdXR1cmU6IFVzZSBzcHJlYWQgc3ludGF4IHdoZW4gc3VwcG9ydGVkIG9uIGFsbCBwbGF0Zm9ybXMsIGUuZy4gYGJ5dGVzID1cbiAgICAvLyBoYXNoZnVuYyhbLi4ubmFtZXNwYWNlLCAuLi4gdmFsdWVdKWBcblxuXG4gICAgbGV0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoMTYgKyB2YWx1ZS5sZW5ndGgpO1xuICAgIGJ5dGVzLnNldChuYW1lc3BhY2UpO1xuICAgIGJ5dGVzLnNldCh2YWx1ZSwgbmFtZXNwYWNlLmxlbmd0aCk7XG4gICAgYnl0ZXMgPSBoYXNoZnVuYyhieXRlcyk7XG4gICAgYnl0ZXNbNl0gPSBieXRlc1s2XSAmIDB4MGYgfCB2ZXJzaW9uO1xuICAgIGJ5dGVzWzhdID0gYnl0ZXNbOF0gJiAweDNmIHwgMHg4MDtcblxuICAgIGlmIChidWYpIHtcbiAgICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICAgICAgYnVmW29mZnNldCArIGldID0gYnl0ZXNbaV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBidWY7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmluZ2lmeShieXRlcyk7XG4gIH0gLy8gRnVuY3Rpb24jbmFtZSBpcyBub3Qgc2V0dGFibGUgb24gc29tZSBwbGF0Zm9ybXMgKCMyNzApXG5cblxuICB0cnkge1xuICAgIGdlbmVyYXRlVVVJRC5uYW1lID0gbmFtZTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gIH0gY2F0Y2ggKGVycikge30gLy8gRm9yIENvbW1vbkpTIGRlZmF1bHQgZXhwb3J0IHN1cHBvcnRcblxuXG4gIGdlbmVyYXRlVVVJRC5ETlMgPSBETlM7XG4gIGdlbmVyYXRlVVVJRC5VUkwgPSBVUkw7XG4gIHJldHVybiBnZW5lcmF0ZVVVSUQ7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/v35.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/v4.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/v4.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rng.js */ \"(ssr)/./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/rng.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"(ssr)/./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/stringify.js\");\n\n\n\nfunction v4(options, buf, offset) {\n  options = options || {};\n  const rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(rnds);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v4);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvc29sYW5hL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTJCO0FBQ1k7O0FBRXZDO0FBQ0E7QUFDQSxpREFBaUQsK0NBQUcsS0FBSzs7QUFFekQ7QUFDQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7O0FBRUEsb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFNBQVMseURBQVM7QUFDbEI7O0FBRUEsaUVBQWUsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL251cnNlYmxvYy8uL25vZGVfbW9kdWxlcy9AdHVybmtleS9zb2xhbmEvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS92NC5qcz8zOWE5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBybmcgZnJvbSAnLi9ybmcuanMnO1xuaW1wb3J0IHN0cmluZ2lmeSBmcm9tICcuL3N0cmluZ2lmeS5qcyc7XG5cbmZ1bmN0aW9uIHY0KG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBybmRzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IHJuZykoKTsgLy8gUGVyIDQuNCwgc2V0IGJpdHMgZm9yIHZlcnNpb24gYW5kIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYFxuXG4gIHJuZHNbNl0gPSBybmRzWzZdICYgMHgwZiB8IDB4NDA7XG4gIHJuZHNbOF0gPSBybmRzWzhdICYgMHgzZiB8IDB4ODA7IC8vIENvcHkgYnl0ZXMgdG8gYnVmZmVyLCBpZiBwcm92aWRlZFxuXG4gIGlmIChidWYpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgYnVmW29mZnNldCArIGldID0gcm5kc1tpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVmO1xuICB9XG5cbiAgcmV0dXJuIHN0cmluZ2lmeShybmRzKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdjQ7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/v4.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/v5.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/v5.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v35.js */ \"(ssr)/./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/v35.js\");\n/* harmony import */ var _sha1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sha1.js */ \"(ssr)/./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/sha1.js\");\n\n\nconst v5 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])('v5', 0x50, _sha1_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v5);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvc29sYW5hL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTJCO0FBQ0U7QUFDN0IsV0FBVyxtREFBRyxhQUFhLGdEQUFJO0FBQy9CLGlFQUFlLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9udXJzZWJsb2MvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvc29sYW5hL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjUuanM/NDU5ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdjM1IGZyb20gJy4vdjM1LmpzJztcbmltcG9ydCBzaGExIGZyb20gJy4vc2hhMS5qcyc7XG5jb25zdCB2NSA9IHYzNSgndjUnLCAweDUwLCBzaGExKTtcbmV4cG9ydCBkZWZhdWx0IHY1OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/v5.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/validate.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/validate.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regex.js */ \"(ssr)/./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/regex.js\");\n\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && _regex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].test(uuid);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (validate);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvc29sYW5hL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdmFsaWRhdGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBK0I7O0FBRS9CO0FBQ0EscUNBQXFDLGlEQUFLO0FBQzFDOztBQUVBLGlFQUFlLFFBQVEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9udXJzZWJsb2MvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvc29sYW5hL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdmFsaWRhdGUuanM/YjEzMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUkVHRVggZnJvbSAnLi9yZWdleC5qcyc7XG5cbmZ1bmN0aW9uIHZhbGlkYXRlKHV1aWQpIHtcbiAgcmV0dXJuIHR5cGVvZiB1dWlkID09PSAnc3RyaW5nJyAmJiBSRUdFWC50ZXN0KHV1aWQpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB2YWxpZGF0ZTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/validate.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/version.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/version.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"(ssr)/./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/validate.js\");\n\n\nfunction version(uuid) {\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  return parseInt(uuid.substr(14, 1), 16);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (version);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvc29sYW5hL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFxQzs7QUFFckM7QUFDQSxPQUFPLHdEQUFRO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlFQUFlLE9BQU8iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9udXJzZWJsb2MvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvc29sYW5hL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdmVyc2lvbi5qcz82NGJkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB2YWxpZGF0ZSBmcm9tICcuL3ZhbGlkYXRlLmpzJztcblxuZnVuY3Rpb24gdmVyc2lvbih1dWlkKSB7XG4gIGlmICghdmFsaWRhdGUodXVpZCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ0ludmFsaWQgVVVJRCcpO1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlSW50KHV1aWQuc3Vic3RyKDE0LCAxKSwgMTYpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB2ZXJzaW9uOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/solana/node_modules/uuid/dist/esm-node/version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/api-key-stamper/dist/index.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@turnkey/api-key-stamper/dist/index.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ApiKeyStamper: () => (/* binding */ ApiKeyStamper),\n/* harmony export */   signWithApiKey: () => (/* binding */ signWithApiKey)\n/* harmony export */ });\n/* harmony import */ var _turnkey_encoding__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @turnkey/encoding */ \"(ssr)/./node_modules/@turnkey/encoding/dist/index.mjs\");\n\n\n/// <reference lib=\"dom\" />\n// Header name for an API key stamp\nconst stampHeaderName = \"X-Stamp\";\n// `window.document` ensures that we're in a browser context\n// and `crypto.subtle` ensures that it supports the web crypto APIs\n// Inspired by https://github.com/flexdinesh/browser-or-node/blob/master/src/index.ts\nconst isCryptoEnabledBrowser = typeof window !== \"undefined\" &&\n    typeof window.document !== \"undefined\" &&\n    typeof crypto !== \"undefined\" &&\n    typeof crypto.subtle !== \"undefined\";\n// We check `process.versions.node`\n// Taken from https://github.com/flexdinesh/browser-or-node/blob/master/src/index.ts\nconst isNode = typeof process !== \"undefined\" &&\n    process.versions != null &&\n    process.versions.node != null;\n/**\n * Signature function abstracting the differences between NodeJS and web environments for signing with API keys.\n */\nconst signWithApiKey = async (input) => {\n    if (isCryptoEnabledBrowser) {\n        const fn = await __webpack_require__.e(/*! import() */ \"vendor-chunks/@turnkey\").then(__webpack_require__.bind(__webpack_require__, /*! ./webcrypto.mjs */ \"(ssr)/./node_modules/@turnkey/api-key-stamper/dist/webcrypto.mjs\")).then((m) => m.signWithApiKey);\n        return fn(input);\n    }\n    else if (isNode) {\n        const fn = await __webpack_require__.e(/*! import() */ \"vendor-chunks/@turnkey\").then(__webpack_require__.bind(__webpack_require__, /*! ./nodecrypto.mjs */ \"(ssr)/./node_modules/@turnkey/api-key-stamper/dist/nodecrypto.mjs\")).then((m) => m.signWithApiKey);\n        return fn(input);\n    }\n    else {\n        // If we don't have NodeJS or web crypto at our disposal, default to pure JS implementation\n        // This is the case for old browsers and react native environments\n        const fn = await Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/@turnkey\"), __webpack_require__.e(\"vendor-chunks/sha256-uint8array\")]).then(__webpack_require__.bind(__webpack_require__, /*! ./purejs.mjs */ \"(ssr)/./node_modules/@turnkey/api-key-stamper/dist/purejs.mjs\")).then((m) => m.signWithApiKey);\n        return fn(input);\n    }\n};\n/**\n * Stamper to use with `@turnkey/http`'s `TurnkeyClient`\n */\nclass ApiKeyStamper {\n    constructor(config) {\n        this.apiPublicKey = config.apiPublicKey;\n        this.apiPrivateKey = config.apiPrivateKey;\n    }\n    async stamp(payload) {\n        const signature = await signWithApiKey({\n            publicKey: this.apiPublicKey,\n            privateKey: this.apiPrivateKey,\n            content: payload,\n        });\n        const stamp = {\n            publicKey: this.apiPublicKey,\n            scheme: \"SIGNATURE_SCHEME_TK_API_P256\",\n            signature: signature,\n        };\n        return {\n            stampHeaderName: stampHeaderName,\n            stampHeaderValue: (0,_turnkey_encoding__WEBPACK_IMPORTED_MODULE_0__.stringToBase64urlString)(JSON.stringify(stamp)),\n        };\n    }\n}\n\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvYXBpLWtleS1zdGFtcGVyL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE0RDs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw4TUFBeUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdOQUEwQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdSQUFzQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwwRUFBdUI7QUFDckQ7QUFDQTtBQUNBOztBQUV5QztBQUN6QyIsInNvdXJjZXMiOlsid2VicGFjazovL251cnNlYmxvYy8uL25vZGVfbW9kdWxlcy9AdHVybmtleS9hcGkta2V5LXN0YW1wZXIvZGlzdC9pbmRleC5tanM/NThkMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzdHJpbmdUb0Jhc2U2NHVybFN0cmluZyB9IGZyb20gJ0B0dXJua2V5L2VuY29kaW5nJztcblxuLy8vIDxyZWZlcmVuY2UgbGliPVwiZG9tXCIgLz5cbi8vIEhlYWRlciBuYW1lIGZvciBhbiBBUEkga2V5IHN0YW1wXG5jb25zdCBzdGFtcEhlYWRlck5hbWUgPSBcIlgtU3RhbXBcIjtcbi8vIGB3aW5kb3cuZG9jdW1lbnRgIGVuc3VyZXMgdGhhdCB3ZSdyZSBpbiBhIGJyb3dzZXIgY29udGV4dFxuLy8gYW5kIGBjcnlwdG8uc3VidGxlYCBlbnN1cmVzIHRoYXQgaXQgc3VwcG9ydHMgdGhlIHdlYiBjcnlwdG8gQVBJc1xuLy8gSW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL2ZsZXhkaW5lc2gvYnJvd3Nlci1vci1ub2RlL2Jsb2IvbWFzdGVyL3NyYy9pbmRleC50c1xuY29uc3QgaXNDcnlwdG9FbmFibGVkQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgdHlwZW9mIGNyeXB0byAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgIHR5cGVvZiBjcnlwdG8uc3VidGxlICE9PSBcInVuZGVmaW5lZFwiO1xuLy8gV2UgY2hlY2sgYHByb2Nlc3MudmVyc2lvbnMubm9kZWBcbi8vIFRha2VuIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2ZsZXhkaW5lc2gvYnJvd3Nlci1vci1ub2RlL2Jsb2IvbWFzdGVyL3NyYy9pbmRleC50c1xuY29uc3QgaXNOb2RlID0gdHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICBwcm9jZXNzLnZlcnNpb25zICE9IG51bGwgJiZcbiAgICBwcm9jZXNzLnZlcnNpb25zLm5vZGUgIT0gbnVsbDtcbi8qKlxuICogU2lnbmF0dXJlIGZ1bmN0aW9uIGFic3RyYWN0aW5nIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIE5vZGVKUyBhbmQgd2ViIGVudmlyb25tZW50cyBmb3Igc2lnbmluZyB3aXRoIEFQSSBrZXlzLlxuICovXG5jb25zdCBzaWduV2l0aEFwaUtleSA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgIGlmIChpc0NyeXB0b0VuYWJsZWRCcm93c2VyKSB7XG4gICAgICAgIGNvbnN0IGZuID0gYXdhaXQgaW1wb3J0KCcuL3dlYmNyeXB0by5tanMnKS50aGVuKChtKSA9PiBtLnNpZ25XaXRoQXBpS2V5KTtcbiAgICAgICAgcmV0dXJuIGZuKGlucHV0KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNOb2RlKSB7XG4gICAgICAgIGNvbnN0IGZuID0gYXdhaXQgaW1wb3J0KCcuL25vZGVjcnlwdG8ubWpzJykudGhlbigobSkgPT4gbS5zaWduV2l0aEFwaUtleSk7XG4gICAgICAgIHJldHVybiBmbihpbnB1dCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIE5vZGVKUyBvciB3ZWIgY3J5cHRvIGF0IG91ciBkaXNwb3NhbCwgZGVmYXVsdCB0byBwdXJlIEpTIGltcGxlbWVudGF0aW9uXG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIGNhc2UgZm9yIG9sZCBicm93c2VycyBhbmQgcmVhY3QgbmF0aXZlIGVudmlyb25tZW50c1xuICAgICAgICBjb25zdCBmbiA9IGF3YWl0IGltcG9ydCgnLi9wdXJlanMubWpzJykudGhlbigobSkgPT4gbS5zaWduV2l0aEFwaUtleSk7XG4gICAgICAgIHJldHVybiBmbihpbnB1dCk7XG4gICAgfVxufTtcbi8qKlxuICogU3RhbXBlciB0byB1c2Ugd2l0aCBgQHR1cm5rZXkvaHR0cGAncyBgVHVybmtleUNsaWVudGBcbiAqL1xuY2xhc3MgQXBpS2V5U3RhbXBlciB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHRoaXMuYXBpUHVibGljS2V5ID0gY29uZmlnLmFwaVB1YmxpY0tleTtcbiAgICAgICAgdGhpcy5hcGlQcml2YXRlS2V5ID0gY29uZmlnLmFwaVByaXZhdGVLZXk7XG4gICAgfVxuICAgIGFzeW5jIHN0YW1wKHBheWxvYWQpIHtcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgc2lnbldpdGhBcGlLZXkoe1xuICAgICAgICAgICAgcHVibGljS2V5OiB0aGlzLmFwaVB1YmxpY0tleSxcbiAgICAgICAgICAgIHByaXZhdGVLZXk6IHRoaXMuYXBpUHJpdmF0ZUtleSxcbiAgICAgICAgICAgIGNvbnRlbnQ6IHBheWxvYWQsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBzdGFtcCA9IHtcbiAgICAgICAgICAgIHB1YmxpY0tleTogdGhpcy5hcGlQdWJsaWNLZXksXG4gICAgICAgICAgICBzY2hlbWU6IFwiU0lHTkFUVVJFX1NDSEVNRV9US19BUElfUDI1NlwiLFxuICAgICAgICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmUsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGFtcEhlYWRlck5hbWU6IHN0YW1wSGVhZGVyTmFtZSxcbiAgICAgICAgICAgIHN0YW1wSGVhZGVyVmFsdWU6IHN0cmluZ1RvQmFzZTY0dXJsU3RyaW5nKEpTT04uc3RyaW5naWZ5KHN0YW1wKSksXG4gICAgICAgIH07XG4gICAgfVxufVxuXG5leHBvcnQgeyBBcGlLZXlTdGFtcGVyLCBzaWduV2l0aEFwaUtleSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/api-key-stamper/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/api-key-stamper/dist/nodecrypto.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@turnkey/api-key-stamper/dist/nodecrypto.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   signWithApiKey: () => (/* binding */ signWithApiKey)\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var _utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.mjs */ \"(ssr)/./node_modules/@turnkey/api-key-stamper/dist/utils.mjs\");\n\n\n\nconst signWithApiKey = async (input) => {\n    const { content, publicKey, privateKey } = input;\n    const privateKeyObject = crypto__WEBPACK_IMPORTED_MODULE_0__.createPrivateKey({\n        // @ts-expect-error -- the key can be a JWK object since Node v15.12.0\n        // https://nodejs.org/api/crypto.html#cryptocreateprivatekeykey\n        key: (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.convertTurnkeyApiKeyToJwk)({\n            uncompressedPrivateKeyHex: privateKey,\n            compressedPublicKeyHex: publicKey,\n        }),\n        format: \"jwk\",\n    });\n    const sign = crypto__WEBPACK_IMPORTED_MODULE_0__.createSign(\"SHA256\");\n    sign.write(Buffer.from(content));\n    sign.end();\n    return sign.sign(privateKeyObject, \"hex\");\n};\n\n\n//# sourceMappingURL=nodecrypto.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvYXBpLWtleS1zdGFtcGVyL2Rpc3Qvbm9kZWNyeXB0by5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWlDO0FBQ3VCOztBQUV4RDtBQUNBLFlBQVksaUNBQWlDO0FBQzdDLDZCQUE2QixvREFBdUI7QUFDcEQ7QUFDQTtBQUNBLGFBQWEscUVBQXlCO0FBQ3RDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0wsaUJBQWlCLDhDQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFMEI7QUFDMUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9udXJzZWJsb2MvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvYXBpLWtleS1zdGFtcGVyL2Rpc3Qvbm9kZWNyeXB0by5tanM/ZDAxNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBjcnlwdG8gZnJvbSAnY3J5cHRvJztcbmltcG9ydCB7IGNvbnZlcnRUdXJua2V5QXBpS2V5VG9Kd2sgfSBmcm9tICcuL3V0aWxzLm1qcyc7XG5cbmNvbnN0IHNpZ25XaXRoQXBpS2V5ID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgY29uc3QgeyBjb250ZW50LCBwdWJsaWNLZXksIHByaXZhdGVLZXkgfSA9IGlucHV0O1xuICAgIGNvbnN0IHByaXZhdGVLZXlPYmplY3QgPSBjcnlwdG8uY3JlYXRlUHJpdmF0ZUtleSh7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLS0gdGhlIGtleSBjYW4gYmUgYSBKV0sgb2JqZWN0IHNpbmNlIE5vZGUgdjE1LjEyLjBcbiAgICAgICAgLy8gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9jcnlwdG8uaHRtbCNjcnlwdG9jcmVhdGVwcml2YXRla2V5a2V5XG4gICAgICAgIGtleTogY29udmVydFR1cm5rZXlBcGlLZXlUb0p3ayh7XG4gICAgICAgICAgICB1bmNvbXByZXNzZWRQcml2YXRlS2V5SGV4OiBwcml2YXRlS2V5LFxuICAgICAgICAgICAgY29tcHJlc3NlZFB1YmxpY0tleUhleDogcHVibGljS2V5LFxuICAgICAgICB9KSxcbiAgICAgICAgZm9ybWF0OiBcImp3a1wiLFxuICAgIH0pO1xuICAgIGNvbnN0IHNpZ24gPSBjcnlwdG8uY3JlYXRlU2lnbihcIlNIQTI1NlwiKTtcbiAgICBzaWduLndyaXRlKEJ1ZmZlci5mcm9tKGNvbnRlbnQpKTtcbiAgICBzaWduLmVuZCgpO1xuICAgIHJldHVybiBzaWduLnNpZ24ocHJpdmF0ZUtleU9iamVjdCwgXCJoZXhcIik7XG59O1xuXG5leHBvcnQgeyBzaWduV2l0aEFwaUtleSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bm9kZWNyeXB0by5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/api-key-stamper/dist/nodecrypto.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/api-key-stamper/dist/purejs.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@turnkey/api-key-stamper/dist/purejs.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   signWithApiKey: () => (/* binding */ signWithApiKey)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_p256__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/curves/p256 */ \"(ssr)/./node_modules/@turnkey/api-key-stamper/node_modules/@noble/curves/esm/p256.js\");\n/* harmony import */ var sha256_uint8array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! sha256-uint8array */ \"(ssr)/./node_modules/sha256-uint8array/dist/sha256-uint8array.mjs\");\n/* harmony import */ var _turnkey_encoding__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @turnkey/encoding */ \"(ssr)/./node_modules/@turnkey/encoding/dist/index.mjs\");\n\n\n\n\nconst signWithApiKey = async (input) => {\n    const publicKey = _noble_curves_p256__WEBPACK_IMPORTED_MODULE_2__.p256.getPublicKey(input.privateKey, true);\n    // Public key in the usual 02 or 03 + 64 hex digits\n    const publicKeyString = (0,_turnkey_encoding__WEBPACK_IMPORTED_MODULE_1__.uint8ArrayToHexString)(publicKey);\n    if (publicKeyString != input.publicKey) {\n        throw new Error(`Bad API key. Expected to get public key ${input.publicKey}, got ${publicKeyString}`);\n    }\n    const hash = (0,sha256_uint8array__WEBPACK_IMPORTED_MODULE_0__.createHash)().update(input.content).digest();\n    const signature = _noble_curves_p256__WEBPACK_IMPORTED_MODULE_2__.p256.sign(hash, input.privateKey);\n    return signature.toDERHex();\n};\n\n\n//# sourceMappingURL=purejs.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvYXBpLWtleS1zdGFtcGVyL2Rpc3QvcHVyZWpzLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTBDO0FBQ0s7QUFDVzs7QUFFMUQ7QUFDQSxzQkFBc0Isb0RBQUk7QUFDMUI7QUFDQSw0QkFBNEIsd0VBQXFCO0FBQ2pEO0FBQ0EsbUVBQW1FLGdCQUFnQixRQUFRLGdCQUFnQjtBQUMzRztBQUNBLGlCQUFpQiw2REFBVTtBQUMzQixzQkFBc0Isb0RBQUk7QUFDMUI7QUFDQTs7QUFFMEI7QUFDMUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9udXJzZWJsb2MvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvYXBpLWtleS1zdGFtcGVyL2Rpc3QvcHVyZWpzLm1qcz9kODAwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHAyNTYgfSBmcm9tICdAbm9ibGUvY3VydmVzL3AyNTYnO1xuaW1wb3J0IHsgY3JlYXRlSGFzaCB9IGZyb20gJ3NoYTI1Ni11aW50OGFycmF5JztcbmltcG9ydCB7IHVpbnQ4QXJyYXlUb0hleFN0cmluZyB9IGZyb20gJ0B0dXJua2V5L2VuY29kaW5nJztcblxuY29uc3Qgc2lnbldpdGhBcGlLZXkgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICBjb25zdCBwdWJsaWNLZXkgPSBwMjU2LmdldFB1YmxpY0tleShpbnB1dC5wcml2YXRlS2V5LCB0cnVlKTtcbiAgICAvLyBQdWJsaWMga2V5IGluIHRoZSB1c3VhbCAwMiBvciAwMyArIDY0IGhleCBkaWdpdHNcbiAgICBjb25zdCBwdWJsaWNLZXlTdHJpbmcgPSB1aW50OEFycmF5VG9IZXhTdHJpbmcocHVibGljS2V5KTtcbiAgICBpZiAocHVibGljS2V5U3RyaW5nICE9IGlucHV0LnB1YmxpY0tleSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEJhZCBBUEkga2V5LiBFeHBlY3RlZCB0byBnZXQgcHVibGljIGtleSAke2lucHV0LnB1YmxpY0tleX0sIGdvdCAke3B1YmxpY0tleVN0cmluZ31gKTtcbiAgICB9XG4gICAgY29uc3QgaGFzaCA9IGNyZWF0ZUhhc2goKS51cGRhdGUoaW5wdXQuY29udGVudCkuZGlnZXN0KCk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gcDI1Ni5zaWduKGhhc2gsIGlucHV0LnByaXZhdGVLZXkpO1xuICAgIHJldHVybiBzaWduYXR1cmUudG9ERVJIZXgoKTtcbn07XG5cbmV4cG9ydCB7IHNpZ25XaXRoQXBpS2V5IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wdXJlanMubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/api-key-stamper/dist/purejs.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/api-key-stamper/dist/tink/bytes.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@turnkey/api-key-stamper/dist/tink/bytes.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromHex: () => (/* binding */ fromHex),\n/* harmony export */   toBase64: () => (/* binding */ toBase64),\n/* harmony export */   toByteString: () => (/* binding */ toByteString),\n/* harmony export */   toHex: () => (/* binding */ toHex)\n/* harmony export */ });\n/**\n * Code modified from https://github.com/google/tink/blob/6f74b99a2bfe6677e3670799116a57268fd067fa/javascript/subtle/bytes.ts\n *\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * Converts the hex string to a byte array.\n *\n * @param hex the input\n * @return the byte array output\n * @throws {!Error}\n * @static\n */\nfunction fromHex(hex) {\n    if (hex.length % 2 != 0) {\n        throw new Error(\"Hex string length must be multiple of 2\");\n    }\n    const arr = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < hex.length; i += 2) {\n        arr[i / 2] = parseInt(hex.substring(i, i + 2), 16);\n    }\n    return arr;\n}\n/**\n * Converts a byte array to hex.\n *\n * @param bytes the byte array input\n * @return hex the output\n * @static\n */\nfunction toHex(bytes) {\n    let result = \"\";\n    for (let i = 0; i < bytes.length; i++) {\n        const hexByte = bytes[i].toString(16);\n        result += hexByte.length > 1 ? hexByte : \"0\" + hexByte;\n    }\n    return result;\n}\n/**\n * Base64 encode a byte array.\n *\n * @param bytes the byte array input\n * @param opt_webSafe True indicates we should use the alternative\n *     alphabet, which does not require escaping for use in URLs.\n * @return base64 output\n * @static\n */\nfunction toBase64(bytes, opt_webSafe) {\n    const encoded = btoa(\n    /* padding */\n    toByteString(bytes)).replace(/=/g, \"\");\n    if (opt_webSafe) {\n        return encoded.replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n    }\n    return encoded;\n}\n/**\n * Turns a byte array into the string given by the concatenation of the\n * characters to which the numbers correspond. Each byte is corresponding to a\n * character. Does not support multi-byte characters.\n *\n * @param bytes Array of numbers representing\n *     characters.\n * @return Stringification of the array.\n */\nfunction toByteString(bytes) {\n    let str = \"\";\n    for (let i = 0; i < bytes.length; i += 1) {\n        str += String.fromCharCode(bytes[i]);\n    }\n    return str;\n}\n\n\n//# sourceMappingURL=bytes.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvYXBpLWtleS1zdGFtcGVyL2Rpc3QvdGluay9ieXRlcy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFa0Q7QUFDbEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9udXJzZWJsb2MvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvYXBpLWtleS1zdGFtcGVyL2Rpc3QvdGluay9ieXRlcy5tanM/N2QwOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvZGUgbW9kaWZpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL3RpbmsvYmxvYi82Zjc0Yjk5YTJiZmU2Njc3ZTM2NzA3OTkxMTZhNTcyNjhmZDA2N2ZhL2phdmFzY3JpcHQvc3VidGxlL2J5dGVzLnRzXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbi8qKlxuICogQ29udmVydHMgdGhlIGhleCBzdHJpbmcgdG8gYSBieXRlIGFycmF5LlxuICpcbiAqIEBwYXJhbSBoZXggdGhlIGlucHV0XG4gKiBAcmV0dXJuIHRoZSBieXRlIGFycmF5IG91dHB1dFxuICogQHRocm93cyB7IUVycm9yfVxuICogQHN0YXRpY1xuICovXG5mdW5jdGlvbiBmcm9tSGV4KGhleCkge1xuICAgIGlmIChoZXgubGVuZ3RoICUgMiAhPSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkhleCBzdHJpbmcgbGVuZ3RoIG11c3QgYmUgbXVsdGlwbGUgb2YgMlwiKTtcbiAgICB9XG4gICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoaGV4Lmxlbmd0aCAvIDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGV4Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIGFycltpIC8gMl0gPSBwYXJzZUludChoZXguc3Vic3RyaW5nKGksIGkgKyAyKSwgMTYpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIGJ5dGUgYXJyYXkgdG8gaGV4LlxuICpcbiAqIEBwYXJhbSBieXRlcyB0aGUgYnl0ZSBhcnJheSBpbnB1dFxuICogQHJldHVybiBoZXggdGhlIG91dHB1dFxuICogQHN0YXRpY1xuICovXG5mdW5jdGlvbiB0b0hleChieXRlcykge1xuICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaGV4Qnl0ZSA9IGJ5dGVzW2ldLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgcmVzdWx0ICs9IGhleEJ5dGUubGVuZ3RoID4gMSA/IGhleEJ5dGUgOiBcIjBcIiArIGhleEJ5dGU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEJhc2U2NCBlbmNvZGUgYSBieXRlIGFycmF5LlxuICpcbiAqIEBwYXJhbSBieXRlcyB0aGUgYnl0ZSBhcnJheSBpbnB1dFxuICogQHBhcmFtIG9wdF93ZWJTYWZlIFRydWUgaW5kaWNhdGVzIHdlIHNob3VsZCB1c2UgdGhlIGFsdGVybmF0aXZlXG4gKiAgICAgYWxwaGFiZXQsIHdoaWNoIGRvZXMgbm90IHJlcXVpcmUgZXNjYXBpbmcgZm9yIHVzZSBpbiBVUkxzLlxuICogQHJldHVybiBiYXNlNjQgb3V0cHV0XG4gKiBAc3RhdGljXG4gKi9cbmZ1bmN0aW9uIHRvQmFzZTY0KGJ5dGVzLCBvcHRfd2ViU2FmZSkge1xuICAgIGNvbnN0IGVuY29kZWQgPSBidG9hKFxuICAgIC8qIHBhZGRpbmcgKi9cbiAgICB0b0J5dGVTdHJpbmcoYnl0ZXMpKS5yZXBsYWNlKC89L2csIFwiXCIpO1xuICAgIGlmIChvcHRfd2ViU2FmZSkge1xuICAgICAgICByZXR1cm4gZW5jb2RlZC5yZXBsYWNlKC9cXCsvZywgXCItXCIpLnJlcGxhY2UoL1xcLy9nLCBcIl9cIik7XG4gICAgfVxuICAgIHJldHVybiBlbmNvZGVkO1xufVxuLyoqXG4gKiBUdXJucyBhIGJ5dGUgYXJyYXkgaW50byB0aGUgc3RyaW5nIGdpdmVuIGJ5IHRoZSBjb25jYXRlbmF0aW9uIG9mIHRoZVxuICogY2hhcmFjdGVycyB0byB3aGljaCB0aGUgbnVtYmVycyBjb3JyZXNwb25kLiBFYWNoIGJ5dGUgaXMgY29ycmVzcG9uZGluZyB0byBhXG4gKiBjaGFyYWN0ZXIuIERvZXMgbm90IHN1cHBvcnQgbXVsdGktYnl0ZSBjaGFyYWN0ZXJzLlxuICpcbiAqIEBwYXJhbSBieXRlcyBBcnJheSBvZiBudW1iZXJzIHJlcHJlc2VudGluZ1xuICogICAgIGNoYXJhY3RlcnMuXG4gKiBAcmV0dXJuIFN0cmluZ2lmaWNhdGlvbiBvZiB0aGUgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHRvQnl0ZVN0cmluZyhieXRlcykge1xuICAgIGxldCBzdHIgPSBcIlwiO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufVxuXG5leHBvcnQgeyBmcm9tSGV4LCB0b0Jhc2U2NCwgdG9CeXRlU3RyaW5nLCB0b0hleCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ynl0ZXMubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/api-key-stamper/dist/tink/bytes.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/api-key-stamper/dist/tink/elliptic_curves.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/@turnkey/api-key-stamper/dist/tink/elliptic_curves.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   pointDecode: () => (/* binding */ pointDecode)\n/* harmony export */ });\n/* harmony import */ var _bytes_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bytes.mjs */ \"(ssr)/./node_modules/@turnkey/api-key-stamper/dist/tink/bytes.mjs\");\n\n\n/**\n * Code modified from https://github.com/google/tink/blob/6f74b99a2bfe6677e3670799116a57268fd067fa/javascript/subtle/elliptic_curves.ts\n *\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * P-256 only\n */\nfunction getModulus() {\n    // https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf (Appendix D).\n    return BigInt(\"115792089210356248762697446949407573530086143415290314195533631308\" +\n        \"867097853951\");\n}\n/**\n * P-256 only\n */\nfunction getB() {\n    // https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf (Appendix D).\n    return BigInt(\"0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b\");\n}\n/** Converts byte array to bigint. */\nfunction byteArrayToInteger(bytes) {\n    return BigInt(\"0x\" + (0,_bytes_mjs__WEBPACK_IMPORTED_MODULE_0__.toHex)(bytes));\n}\n/** Converts bigint to byte array. */\nfunction integerToByteArray(i) {\n    let input = i.toString(16);\n    // If necessary, prepend leading zero to ensure that input length is even.\n    input = input.length % 2 === 0 ? input : \"0\" + input;\n    return (0,_bytes_mjs__WEBPACK_IMPORTED_MODULE_0__.fromHex)(input);\n}\n/** Returns true iff the ith bit (in lsb order) of n is set. */\nfunction testBit(n, i) {\n    const m = BigInt(1) << BigInt(i);\n    return (n & m) !== BigInt(0);\n}\n/**\n * Computes a modular exponent.  Since JavaScript BigInt operations are not\n * constant-time, information about the inputs could leak.  Therefore, THIS\n * METHOD SHOULD ONLY BE USED FOR POINT DECOMPRESSION.\n *\n * @param b base\n * @param exp exponent\n * @param p modulus\n * @return b^exp modulo p\n */\nfunction modPow(b, exp, p) {\n    if (exp === BigInt(0)) {\n        return BigInt(1);\n    }\n    let result = b;\n    const exponentBitString = exp.toString(2);\n    for (let i = 1; i < exponentBitString.length; ++i) {\n        result = (result * result) % p;\n        if (exponentBitString[i] === \"1\") {\n            result = (result * b) % p;\n        }\n    }\n    return result;\n}\n/**\n * Computes a square root modulo an odd prime.  Since timing and exceptions can\n * leak information about the inputs, THIS METHOD SHOULD ONLY BE USED FOR\n * POINT DECOMPRESSION.\n *\n * @param x square\n * @param p prime modulus\n * @return square root of x modulo p\n */\nfunction modSqrt(x, p) {\n    if (p <= BigInt(0)) {\n        throw new Error(\"p must be positive\");\n    }\n    const base = x % p;\n    // The currently supported NIST curves P-256, P-384, and P-521 all satisfy\n    // p % 4 == 3.  However, although currently a no-op, the following check\n    // should be left in place in case other curves are supported in the future.\n    if (testBit(p, 0) && /* istanbul ignore next */ testBit(p, 1)) {\n        // Case p % 4 == 3 (applies to NIST curves P-256, P-384, and P-521)\n        // q = (p + 1) / 4\n        const q = (p + BigInt(1)) >> BigInt(2);\n        const squareRoot = modPow(base, q, p);\n        if ((squareRoot * squareRoot) % p !== base) {\n            throw new Error(\"could not find a modular square root\");\n        }\n        return squareRoot;\n    }\n    // Skipping other elliptic curve types that require Cipolla's algorithm.\n    throw new Error(\"unsupported modulus value\");\n}\n/**\n * Computes the y-coordinate of a point on an elliptic curve given its\n * x-coordinate.  Since timing and exceptions can leak information about the\n * inputs, THIS METHOD SHOULD ONLY BE USED FOR POINT DECOMPRESSION.\n *\n * P-256 only\n *\n * @param x x-coordinate\n * @param lsb least significant bit of the y-coordinate\n * @return y-coordinate\n */\nfunction getY(x, lsb) {\n    const p = getModulus();\n    const a = p - BigInt(3);\n    const b = getB();\n    const rhs = ((x * x + a) * x + b) % p;\n    let y = modSqrt(rhs, p);\n    if (lsb !== testBit(y, 0)) {\n        y = (p - y) % p;\n    }\n    return y;\n}\n/**\n * Decodes a public key in _compressed_ format.\n *\n * P-256 only\n */\nfunction pointDecode(point) {\n    const fieldSize = fieldSizeInBytes();\n    if (point.length !== 1 + fieldSize) {\n        throw new Error(\"compressed point has wrong length\");\n    }\n    if (point[0] !== 2 && point[0] !== 3) {\n        throw new Error(\"invalid format\");\n    }\n    const lsb = point[0] === 3; // point[0] must be 2 (false) or 3 (true).\n    const x = byteArrayToInteger(point.subarray(1, point.length));\n    const p = getModulus();\n    if (x < BigInt(0) || x >= p) {\n        throw new Error(\"x is out of range\");\n    }\n    const y = getY(x, lsb);\n    const result = {\n        kty: \"EC\",\n        crv: \"P-256\",\n        x: (0,_bytes_mjs__WEBPACK_IMPORTED_MODULE_0__.toBase64)(integerToByteArray(x), /* websafe */ true),\n        y: (0,_bytes_mjs__WEBPACK_IMPORTED_MODULE_0__.toBase64)(integerToByteArray(y), /* websafe */ true),\n        ext: true,\n    };\n    return result;\n}\n/**\n * P-256 only\n */\nfunction fieldSizeInBytes() {\n    return 32;\n}\n\n\n//# sourceMappingURL=elliptic_curves.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvYXBpLWtleS1zdGFtcGVyL2Rpc3QvdGluay9lbGxpcHRpY19jdXJ2ZXMubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXVEOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsaURBQUs7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtREFBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw4QkFBOEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsb0RBQVE7QUFDbkIsV0FBVyxvREFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFdUI7QUFDdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9udXJzZWJsb2MvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvYXBpLWtleS1zdGFtcGVyL2Rpc3QvdGluay9lbGxpcHRpY19jdXJ2ZXMubWpzPzhjOWIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdG9CYXNlNjQsIHRvSGV4LCBmcm9tSGV4IH0gZnJvbSAnLi9ieXRlcy5tanMnO1xuXG4vKipcbiAqIENvZGUgbW9kaWZpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL3RpbmsvYmxvYi82Zjc0Yjk5YTJiZmU2Njc3ZTM2NzA3OTkxMTZhNTcyNjhmZDA2N2ZhL2phdmFzY3JpcHQvc3VidGxlL2VsbGlwdGljX2N1cnZlcy50c1xuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG4vKipcbiAqIFAtMjU2IG9ubHlcbiAqL1xuZnVuY3Rpb24gZ2V0TW9kdWx1cygpIHtcbiAgICAvLyBodHRwczovL252bHB1YnMubmlzdC5nb3YvbmlzdHB1YnMvRklQUy9OSVNULkZJUFMuMTg2LTQucGRmIChBcHBlbmRpeCBEKS5cbiAgICByZXR1cm4gQmlnSW50KFwiMTE1NzkyMDg5MjEwMzU2MjQ4NzYyNjk3NDQ2OTQ5NDA3NTczNTMwMDg2MTQzNDE1MjkwMzE0MTk1NTMzNjMxMzA4XCIgK1xuICAgICAgICBcIjg2NzA5Nzg1Mzk1MVwiKTtcbn1cbi8qKlxuICogUC0yNTYgb25seVxuICovXG5mdW5jdGlvbiBnZXRCKCkge1xuICAgIC8vIGh0dHBzOi8vbnZscHVicy5uaXN0Lmdvdi9uaXN0cHVicy9GSVBTL05JU1QuRklQUy4xODYtNC5wZGYgKEFwcGVuZGl4IEQpLlxuICAgIHJldHVybiBCaWdJbnQoXCIweDVhYzYzNWQ4YWEzYTkzZTdiM2ViYmQ1NTc2OTg4NmJjNjUxZDA2YjBjYzUzYjBmNjNiY2UzYzNlMjdkMjYwNGJcIik7XG59XG4vKiogQ29udmVydHMgYnl0ZSBhcnJheSB0byBiaWdpbnQuICovXG5mdW5jdGlvbiBieXRlQXJyYXlUb0ludGVnZXIoYnl0ZXMpIHtcbiAgICByZXR1cm4gQmlnSW50KFwiMHhcIiArIHRvSGV4KGJ5dGVzKSk7XG59XG4vKiogQ29udmVydHMgYmlnaW50IHRvIGJ5dGUgYXJyYXkuICovXG5mdW5jdGlvbiBpbnRlZ2VyVG9CeXRlQXJyYXkoaSkge1xuICAgIGxldCBpbnB1dCA9IGkudG9TdHJpbmcoMTYpO1xuICAgIC8vIElmIG5lY2Vzc2FyeSwgcHJlcGVuZCBsZWFkaW5nIHplcm8gdG8gZW5zdXJlIHRoYXQgaW5wdXQgbGVuZ3RoIGlzIGV2ZW4uXG4gICAgaW5wdXQgPSBpbnB1dC5sZW5ndGggJSAyID09PSAwID8gaW5wdXQgOiBcIjBcIiArIGlucHV0O1xuICAgIHJldHVybiBmcm9tSGV4KGlucHV0KTtcbn1cbi8qKiBSZXR1cm5zIHRydWUgaWZmIHRoZSBpdGggYml0IChpbiBsc2Igb3JkZXIpIG9mIG4gaXMgc2V0LiAqL1xuZnVuY3Rpb24gdGVzdEJpdChuLCBpKSB7XG4gICAgY29uc3QgbSA9IEJpZ0ludCgxKSA8PCBCaWdJbnQoaSk7XG4gICAgcmV0dXJuIChuICYgbSkgIT09IEJpZ0ludCgwKTtcbn1cbi8qKlxuICogQ29tcHV0ZXMgYSBtb2R1bGFyIGV4cG9uZW50LiAgU2luY2UgSmF2YVNjcmlwdCBCaWdJbnQgb3BlcmF0aW9ucyBhcmUgbm90XG4gKiBjb25zdGFudC10aW1lLCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgaW5wdXRzIGNvdWxkIGxlYWsuICBUaGVyZWZvcmUsIFRISVNcbiAqIE1FVEhPRCBTSE9VTEQgT05MWSBCRSBVU0VEIEZPUiBQT0lOVCBERUNPTVBSRVNTSU9OLlxuICpcbiAqIEBwYXJhbSBiIGJhc2VcbiAqIEBwYXJhbSBleHAgZXhwb25lbnRcbiAqIEBwYXJhbSBwIG1vZHVsdXNcbiAqIEByZXR1cm4gYl5leHAgbW9kdWxvIHBcbiAqL1xuZnVuY3Rpb24gbW9kUG93KGIsIGV4cCwgcCkge1xuICAgIGlmIChleHAgPT09IEJpZ0ludCgwKSkge1xuICAgICAgICByZXR1cm4gQmlnSW50KDEpO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0ID0gYjtcbiAgICBjb25zdCBleHBvbmVudEJpdFN0cmluZyA9IGV4cC50b1N0cmluZygyKTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGV4cG9uZW50Qml0U3RyaW5nLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHJlc3VsdCA9IChyZXN1bHQgKiByZXN1bHQpICUgcDtcbiAgICAgICAgaWYgKGV4cG9uZW50Qml0U3RyaW5nW2ldID09PSBcIjFcIikge1xuICAgICAgICAgICAgcmVzdWx0ID0gKHJlc3VsdCAqIGIpICUgcDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBDb21wdXRlcyBhIHNxdWFyZSByb290IG1vZHVsbyBhbiBvZGQgcHJpbWUuICBTaW5jZSB0aW1pbmcgYW5kIGV4Y2VwdGlvbnMgY2FuXG4gKiBsZWFrIGluZm9ybWF0aW9uIGFib3V0IHRoZSBpbnB1dHMsIFRISVMgTUVUSE9EIFNIT1VMRCBPTkxZIEJFIFVTRUQgRk9SXG4gKiBQT0lOVCBERUNPTVBSRVNTSU9OLlxuICpcbiAqIEBwYXJhbSB4IHNxdWFyZVxuICogQHBhcmFtIHAgcHJpbWUgbW9kdWx1c1xuICogQHJldHVybiBzcXVhcmUgcm9vdCBvZiB4IG1vZHVsbyBwXG4gKi9cbmZ1bmN0aW9uIG1vZFNxcnQoeCwgcCkge1xuICAgIGlmIChwIDw9IEJpZ0ludCgwKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwIG11c3QgYmUgcG9zaXRpdmVcIik7XG4gICAgfVxuICAgIGNvbnN0IGJhc2UgPSB4ICUgcDtcbiAgICAvLyBUaGUgY3VycmVudGx5IHN1cHBvcnRlZCBOSVNUIGN1cnZlcyBQLTI1NiwgUC0zODQsIGFuZCBQLTUyMSBhbGwgc2F0aXNmeVxuICAgIC8vIHAgJSA0ID09IDMuICBIb3dldmVyLCBhbHRob3VnaCBjdXJyZW50bHkgYSBuby1vcCwgdGhlIGZvbGxvd2luZyBjaGVja1xuICAgIC8vIHNob3VsZCBiZSBsZWZ0IGluIHBsYWNlIGluIGNhc2Ugb3RoZXIgY3VydmVzIGFyZSBzdXBwb3J0ZWQgaW4gdGhlIGZ1dHVyZS5cbiAgICBpZiAodGVzdEJpdChwLCAwKSAmJiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB0ZXN0Qml0KHAsIDEpKSB7XG4gICAgICAgIC8vIENhc2UgcCAlIDQgPT0gMyAoYXBwbGllcyB0byBOSVNUIGN1cnZlcyBQLTI1NiwgUC0zODQsIGFuZCBQLTUyMSlcbiAgICAgICAgLy8gcSA9IChwICsgMSkgLyA0XG4gICAgICAgIGNvbnN0IHEgPSAocCArIEJpZ0ludCgxKSkgPj4gQmlnSW50KDIpO1xuICAgICAgICBjb25zdCBzcXVhcmVSb290ID0gbW9kUG93KGJhc2UsIHEsIHApO1xuICAgICAgICBpZiAoKHNxdWFyZVJvb3QgKiBzcXVhcmVSb290KSAlIHAgIT09IGJhc2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNvdWxkIG5vdCBmaW5kIGEgbW9kdWxhciBzcXVhcmUgcm9vdFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3F1YXJlUm9vdDtcbiAgICB9XG4gICAgLy8gU2tpcHBpbmcgb3RoZXIgZWxsaXB0aWMgY3VydmUgdHlwZXMgdGhhdCByZXF1aXJlIENpcG9sbGEncyBhbGdvcml0aG0uXG4gICAgdGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgbW9kdWx1cyB2YWx1ZVwiKTtcbn1cbi8qKlxuICogQ29tcHV0ZXMgdGhlIHktY29vcmRpbmF0ZSBvZiBhIHBvaW50IG9uIGFuIGVsbGlwdGljIGN1cnZlIGdpdmVuIGl0c1xuICogeC1jb29yZGluYXRlLiAgU2luY2UgdGltaW5nIGFuZCBleGNlcHRpb25zIGNhbiBsZWFrIGluZm9ybWF0aW9uIGFib3V0IHRoZVxuICogaW5wdXRzLCBUSElTIE1FVEhPRCBTSE9VTEQgT05MWSBCRSBVU0VEIEZPUiBQT0lOVCBERUNPTVBSRVNTSU9OLlxuICpcbiAqIFAtMjU2IG9ubHlcbiAqXG4gKiBAcGFyYW0geCB4LWNvb3JkaW5hdGVcbiAqIEBwYXJhbSBsc2IgbGVhc3Qgc2lnbmlmaWNhbnQgYml0IG9mIHRoZSB5LWNvb3JkaW5hdGVcbiAqIEByZXR1cm4geS1jb29yZGluYXRlXG4gKi9cbmZ1bmN0aW9uIGdldFkoeCwgbHNiKSB7XG4gICAgY29uc3QgcCA9IGdldE1vZHVsdXMoKTtcbiAgICBjb25zdCBhID0gcCAtIEJpZ0ludCgzKTtcbiAgICBjb25zdCBiID0gZ2V0QigpO1xuICAgIGNvbnN0IHJocyA9ICgoeCAqIHggKyBhKSAqIHggKyBiKSAlIHA7XG4gICAgbGV0IHkgPSBtb2RTcXJ0KHJocywgcCk7XG4gICAgaWYgKGxzYiAhPT0gdGVzdEJpdCh5LCAwKSkge1xuICAgICAgICB5ID0gKHAgLSB5KSAlIHA7XG4gICAgfVxuICAgIHJldHVybiB5O1xufVxuLyoqXG4gKiBEZWNvZGVzIGEgcHVibGljIGtleSBpbiBfY29tcHJlc3NlZF8gZm9ybWF0LlxuICpcbiAqIFAtMjU2IG9ubHlcbiAqL1xuZnVuY3Rpb24gcG9pbnREZWNvZGUocG9pbnQpIHtcbiAgICBjb25zdCBmaWVsZFNpemUgPSBmaWVsZFNpemVJbkJ5dGVzKCk7XG4gICAgaWYgKHBvaW50Lmxlbmd0aCAhPT0gMSArIGZpZWxkU2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb21wcmVzc2VkIHBvaW50IGhhcyB3cm9uZyBsZW5ndGhcIik7XG4gICAgfVxuICAgIGlmIChwb2ludFswXSAhPT0gMiAmJiBwb2ludFswXSAhPT0gMykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGZvcm1hdFwiKTtcbiAgICB9XG4gICAgY29uc3QgbHNiID0gcG9pbnRbMF0gPT09IDM7IC8vIHBvaW50WzBdIG11c3QgYmUgMiAoZmFsc2UpIG9yIDMgKHRydWUpLlxuICAgIGNvbnN0IHggPSBieXRlQXJyYXlUb0ludGVnZXIocG9pbnQuc3ViYXJyYXkoMSwgcG9pbnQubGVuZ3RoKSk7XG4gICAgY29uc3QgcCA9IGdldE1vZHVsdXMoKTtcbiAgICBpZiAoeCA8IEJpZ0ludCgwKSB8fCB4ID49IHApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwieCBpcyBvdXQgb2YgcmFuZ2VcIik7XG4gICAgfVxuICAgIGNvbnN0IHkgPSBnZXRZKHgsIGxzYik7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICBrdHk6IFwiRUNcIixcbiAgICAgICAgY3J2OiBcIlAtMjU2XCIsXG4gICAgICAgIHg6IHRvQmFzZTY0KGludGVnZXJUb0J5dGVBcnJheSh4KSwgLyogd2Vic2FmZSAqLyB0cnVlKSxcbiAgICAgICAgeTogdG9CYXNlNjQoaW50ZWdlclRvQnl0ZUFycmF5KHkpLCAvKiB3ZWJzYWZlICovIHRydWUpLFxuICAgICAgICBleHQ6IHRydWUsXG4gICAgfTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBQLTI1NiBvbmx5XG4gKi9cbmZ1bmN0aW9uIGZpZWxkU2l6ZUluQnl0ZXMoKSB7XG4gICAgcmV0dXJuIDMyO1xufVxuXG5leHBvcnQgeyBwb2ludERlY29kZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZWxsaXB0aWNfY3VydmVzLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/api-key-stamper/dist/tink/elliptic_curves.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/api-key-stamper/dist/utils.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@turnkey/api-key-stamper/dist/utils.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   convertTurnkeyApiKeyToJwk: () => (/* binding */ convertTurnkeyApiKeyToJwk)\n/* harmony export */ });\n/* harmony import */ var _tink_elliptic_curves_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tink/elliptic_curves.mjs */ \"(ssr)/./node_modules/@turnkey/api-key-stamper/dist/tink/elliptic_curves.mjs\");\n/* harmony import */ var _turnkey_encoding__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @turnkey/encoding */ \"(ssr)/./node_modules/@turnkey/encoding/dist/index.mjs\");\n\n\n\nfunction convertTurnkeyApiKeyToJwk(input) {\n    const { uncompressedPrivateKeyHex, compressedPublicKeyHex } = input;\n    const jwk = (0,_tink_elliptic_curves_mjs__WEBPACK_IMPORTED_MODULE_0__.pointDecode)(hexStringToUint8Array(compressedPublicKeyHex));\n    jwk.d = hexStringToBase64urlString(uncompressedPrivateKeyHex);\n    return jwk;\n}\nfunction hexStringToUint8Array(input) {\n    if (input.length === 0 ||\n        input.length % 2 !== 0 ||\n        /[^a-fA-F0-9]/u.test(input)) {\n        throw new Error(`Invalid hex string: ${JSON.stringify(input)}`);\n    }\n    return Uint8Array.from(input\n        .match(/.{2}/g // Split string by every two characters\n    )\n        .map((byte) => parseInt(byte, 16)));\n}\nfunction hexStringToBase64urlString(input) {\n    const buffer = hexStringToUint8Array(input);\n    return (0,_turnkey_encoding__WEBPACK_IMPORTED_MODULE_1__.stringToBase64urlString)(buffer.reduce((result, x) => result + String.fromCharCode(x), \"\"));\n}\n\n\n//# sourceMappingURL=utils.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvYXBpLWtleS1zdGFtcGVyL2Rpc3QvdXRpbHMubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF5RDtBQUNHOztBQUU1RDtBQUNBLFlBQVksb0RBQW9EO0FBQ2hFLGdCQUFnQixzRUFBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxzQkFBc0I7QUFDckU7QUFDQTtBQUNBLGtCQUFrQixFQUFFO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDBFQUF1QjtBQUNsQzs7QUFFcUM7QUFDckMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9udXJzZWJsb2MvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvYXBpLWtleS1zdGFtcGVyL2Rpc3QvdXRpbHMubWpzPzgyNDQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcG9pbnREZWNvZGUgfSBmcm9tICcuL3RpbmsvZWxsaXB0aWNfY3VydmVzLm1qcyc7XG5pbXBvcnQgeyBzdHJpbmdUb0Jhc2U2NHVybFN0cmluZyB9IGZyb20gJ0B0dXJua2V5L2VuY29kaW5nJztcblxuZnVuY3Rpb24gY29udmVydFR1cm5rZXlBcGlLZXlUb0p3ayhpbnB1dCkge1xuICAgIGNvbnN0IHsgdW5jb21wcmVzc2VkUHJpdmF0ZUtleUhleCwgY29tcHJlc3NlZFB1YmxpY0tleUhleCB9ID0gaW5wdXQ7XG4gICAgY29uc3QgandrID0gcG9pbnREZWNvZGUoaGV4U3RyaW5nVG9VaW50OEFycmF5KGNvbXByZXNzZWRQdWJsaWNLZXlIZXgpKTtcbiAgICBqd2suZCA9IGhleFN0cmluZ1RvQmFzZTY0dXJsU3RyaW5nKHVuY29tcHJlc3NlZFByaXZhdGVLZXlIZXgpO1xuICAgIHJldHVybiBqd2s7XG59XG5mdW5jdGlvbiBoZXhTdHJpbmdUb1VpbnQ4QXJyYXkoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQubGVuZ3RoID09PSAwIHx8XG4gICAgICAgIGlucHV0Lmxlbmd0aCAlIDIgIT09IDAgfHxcbiAgICAgICAgL1teYS1mQS1GMC05XS91LnRlc3QoaW5wdXQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBoZXggc3RyaW5nOiAke0pTT04uc3RyaW5naWZ5KGlucHV0KX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShpbnB1dFxuICAgICAgICAubWF0Y2goLy57Mn0vZyAvLyBTcGxpdCBzdHJpbmcgYnkgZXZlcnkgdHdvIGNoYXJhY3RlcnNcbiAgICApXG4gICAgICAgIC5tYXAoKGJ5dGUpID0+IHBhcnNlSW50KGJ5dGUsIDE2KSkpO1xufVxuZnVuY3Rpb24gaGV4U3RyaW5nVG9CYXNlNjR1cmxTdHJpbmcoaW5wdXQpIHtcbiAgICBjb25zdCBidWZmZXIgPSBoZXhTdHJpbmdUb1VpbnQ4QXJyYXkoaW5wdXQpO1xuICAgIHJldHVybiBzdHJpbmdUb0Jhc2U2NHVybFN0cmluZyhidWZmZXIucmVkdWNlKChyZXN1bHQsIHgpID0+IHJlc3VsdCArIFN0cmluZy5mcm9tQ2hhckNvZGUoeCksIFwiXCIpKTtcbn1cblxuZXhwb3J0IHsgY29udmVydFR1cm5rZXlBcGlLZXlUb0p3ayB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/api-key-stamper/dist/utils.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/api-key-stamper/dist/webcrypto.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@turnkey/api-key-stamper/dist/webcrypto.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   signWithApiKey: () => (/* binding */ signWithApiKey)\n/* harmony export */ });\n/* harmony import */ var _utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.mjs */ \"(ssr)/./node_modules/@turnkey/api-key-stamper/dist/utils.mjs\");\n/* harmony import */ var _turnkey_encoding__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @turnkey/encoding */ \"(ssr)/./node_modules/@turnkey/encoding/dist/index.mjs\");\n\n\n\n/// <reference lib=\"dom\" />\nconst signWithApiKey = async (input) => {\n    const { content, publicKey, privateKey } = input;\n    const key = await importTurnkeyApiKey({\n        uncompressedPrivateKeyHex: privateKey,\n        compressedPublicKeyHex: publicKey,\n    });\n    return await signMessage({ key, content });\n};\nasync function importTurnkeyApiKey(input) {\n    const { uncompressedPrivateKeyHex, compressedPublicKeyHex } = input;\n    const jwk = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.convertTurnkeyApiKeyToJwk)({\n        uncompressedPrivateKeyHex,\n        compressedPublicKeyHex,\n    });\n    return await crypto.subtle.importKey(\"jwk\", jwk, {\n        name: \"ECDSA\",\n        namedCurve: \"P-256\",\n    }, false, // not extractable\n    [\"sign\"] // allow signing\n    );\n}\nasync function signMessage(input) {\n    const { key, content } = input;\n    const signatureIeee1363 = await crypto.subtle.sign({\n        name: \"ECDSA\",\n        hash: \"SHA-256\",\n    }, key, new TextEncoder().encode(content));\n    const signatureDer = convertEcdsaIeee1363ToDer(new Uint8Array(signatureIeee1363));\n    return (0,_turnkey_encoding__WEBPACK_IMPORTED_MODULE_1__.uint8ArrayToHexString)(signatureDer);\n}\n/**\n * `SubtleCrypto.sign(...)` outputs signature in IEEE P1363 format:\n * - https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/sign#ecdsa\n *\n * Turnkey expects the signature encoding to be DER-encoded ASN.1:\n * - https://github.com/tkhq/tkcli/blob/7f0159af5a73387ff050647180d1db4d3a3aa033/src/internal/apikey/apikey.go#L149\n *\n * Code modified from https://github.com/google/tink/blob/6f74b99a2bfe6677e3670799116a57268fd067fa/javascript/subtle/elliptic_curves.ts#L114\n *\n * Transform an ECDSA signature in IEEE 1363 encoding to DER encoding.\n *\n * @param ieee the ECDSA signature in IEEE encoding\n * @return ECDSA signature in DER encoding\n */\nfunction convertEcdsaIeee1363ToDer(ieee) {\n    if (ieee.length % 2 != 0 || ieee.length == 0 || ieee.length > 132) {\n        throw new Error(\"Invalid IEEE P1363 signature encoding. Length: \" + ieee.length);\n    }\n    const r = toUnsignedBigNum(ieee.subarray(0, ieee.length / 2));\n    const s = toUnsignedBigNum(ieee.subarray(ieee.length / 2, ieee.length));\n    let offset = 0;\n    const length = 1 + 1 + r.length + 1 + 1 + s.length;\n    let der;\n    if (length >= 128) {\n        der = new Uint8Array(length + 3);\n        der[offset++] = 48;\n        der[offset++] = 128 + 1;\n        der[offset++] = length;\n    }\n    else {\n        der = new Uint8Array(length + 2);\n        der[offset++] = 48;\n        der[offset++] = length;\n    }\n    der[offset++] = 2;\n    der[offset++] = r.length;\n    der.set(r, offset);\n    offset += r.length;\n    der[offset++] = 2;\n    der[offset++] = s.length;\n    der.set(s, offset);\n    return der;\n}\n/**\n * Code modified from https://github.com/google/tink/blob/6f74b99a2bfe6677e3670799116a57268fd067fa/javascript/subtle/elliptic_curves.ts#L311\n *\n * Transform a big integer in big endian to minimal unsigned form which has\n * no extra zero at the beginning except when the highest bit is set.\n */\nfunction toUnsignedBigNum(bytes) {\n    // Remove zero prefixes.\n    let start = 0;\n    while (start < bytes.length && bytes[start] == 0) {\n        start++;\n    }\n    if (start == bytes.length) {\n        start = bytes.length - 1;\n    }\n    let extraZero = 0;\n    // If the 1st bit is not zero, add 1 zero byte.\n    if ((bytes[start] & 128) == 128) {\n        // Add extra zero.\n        extraZero = 1;\n    }\n    const res = new Uint8Array(bytes.length - start + extraZero);\n    res.set(bytes.subarray(start), extraZero);\n    return res;\n}\n\n\n//# sourceMappingURL=webcrypto.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvYXBpLWtleS1zdGFtcGVyL2Rpc3Qvd2ViY3J5cHRvLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBd0Q7QUFDRTs7QUFFMUQ7QUFDQTtBQUNBLFlBQVksaUNBQWlDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCwrQkFBK0IsY0FBYztBQUM3QztBQUNBO0FBQ0EsWUFBWSxvREFBb0Q7QUFDaEUsZ0JBQWdCLHFFQUF5QjtBQUN6QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxXQUFXLHdFQUFxQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTBCO0FBQzFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbnVyc2VibG9jLy4vbm9kZV9tb2R1bGVzL0B0dXJua2V5L2FwaS1rZXktc3RhbXBlci9kaXN0L3dlYmNyeXB0by5tanM/YzFhNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjb252ZXJ0VHVybmtleUFwaUtleVRvSndrIH0gZnJvbSAnLi91dGlscy5tanMnO1xuaW1wb3J0IHsgdWludDhBcnJheVRvSGV4U3RyaW5nIH0gZnJvbSAnQHR1cm5rZXkvZW5jb2RpbmcnO1xuXG4vLy8gPHJlZmVyZW5jZSBsaWI9XCJkb21cIiAvPlxuY29uc3Qgc2lnbldpdGhBcGlLZXkgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICBjb25zdCB7IGNvbnRlbnQsIHB1YmxpY0tleSwgcHJpdmF0ZUtleSB9ID0gaW5wdXQ7XG4gICAgY29uc3Qga2V5ID0gYXdhaXQgaW1wb3J0VHVybmtleUFwaUtleSh7XG4gICAgICAgIHVuY29tcHJlc3NlZFByaXZhdGVLZXlIZXg6IHByaXZhdGVLZXksXG4gICAgICAgIGNvbXByZXNzZWRQdWJsaWNLZXlIZXg6IHB1YmxpY0tleSxcbiAgICB9KTtcbiAgICByZXR1cm4gYXdhaXQgc2lnbk1lc3NhZ2UoeyBrZXksIGNvbnRlbnQgfSk7XG59O1xuYXN5bmMgZnVuY3Rpb24gaW1wb3J0VHVybmtleUFwaUtleShpbnB1dCkge1xuICAgIGNvbnN0IHsgdW5jb21wcmVzc2VkUHJpdmF0ZUtleUhleCwgY29tcHJlc3NlZFB1YmxpY0tleUhleCB9ID0gaW5wdXQ7XG4gICAgY29uc3QgandrID0gY29udmVydFR1cm5rZXlBcGlLZXlUb0p3ayh7XG4gICAgICAgIHVuY29tcHJlc3NlZFByaXZhdGVLZXlIZXgsXG4gICAgICAgIGNvbXByZXNzZWRQdWJsaWNLZXlIZXgsXG4gICAgfSk7XG4gICAgcmV0dXJuIGF3YWl0IGNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KFwiandrXCIsIGp3aywge1xuICAgICAgICBuYW1lOiBcIkVDRFNBXCIsXG4gICAgICAgIG5hbWVkQ3VydmU6IFwiUC0yNTZcIixcbiAgICB9LCBmYWxzZSwgLy8gbm90IGV4dHJhY3RhYmxlXG4gICAgW1wic2lnblwiXSAvLyBhbGxvdyBzaWduaW5nXG4gICAgKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNpZ25NZXNzYWdlKGlucHV0KSB7XG4gICAgY29uc3QgeyBrZXksIGNvbnRlbnQgfSA9IGlucHV0O1xuICAgIGNvbnN0IHNpZ25hdHVyZUllZWUxMzYzID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5zaWduKHtcbiAgICAgICAgbmFtZTogXCJFQ0RTQVwiLFxuICAgICAgICBoYXNoOiBcIlNIQS0yNTZcIixcbiAgICB9LCBrZXksIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShjb250ZW50KSk7XG4gICAgY29uc3Qgc2lnbmF0dXJlRGVyID0gY29udmVydEVjZHNhSWVlZTEzNjNUb0RlcihuZXcgVWludDhBcnJheShzaWduYXR1cmVJZWVlMTM2MykpO1xuICAgIHJldHVybiB1aW50OEFycmF5VG9IZXhTdHJpbmcoc2lnbmF0dXJlRGVyKTtcbn1cbi8qKlxuICogYFN1YnRsZUNyeXB0by5zaWduKC4uLilgIG91dHB1dHMgc2lnbmF0dXJlIGluIElFRUUgUDEzNjMgZm9ybWF0OlxuICogLSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvU3VidGxlQ3J5cHRvL3NpZ24jZWNkc2FcbiAqXG4gKiBUdXJua2V5IGV4cGVjdHMgdGhlIHNpZ25hdHVyZSBlbmNvZGluZyB0byBiZSBERVItZW5jb2RlZCBBU04uMTpcbiAqIC0gaHR0cHM6Ly9naXRodWIuY29tL3RraHEvdGtjbGkvYmxvYi83ZjAxNTlhZjVhNzMzODdmZjA1MDY0NzE4MGQxZGI0ZDNhM2FhMDMzL3NyYy9pbnRlcm5hbC9hcGlrZXkvYXBpa2V5LmdvI0wxNDlcbiAqXG4gKiBDb2RlIG1vZGlmaWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS90aW5rL2Jsb2IvNmY3NGI5OWEyYmZlNjY3N2UzNjcwNzk5MTE2YTU3MjY4ZmQwNjdmYS9qYXZhc2NyaXB0L3N1YnRsZS9lbGxpcHRpY19jdXJ2ZXMudHMjTDExNFxuICpcbiAqIFRyYW5zZm9ybSBhbiBFQ0RTQSBzaWduYXR1cmUgaW4gSUVFRSAxMzYzIGVuY29kaW5nIHRvIERFUiBlbmNvZGluZy5cbiAqXG4gKiBAcGFyYW0gaWVlZSB0aGUgRUNEU0Egc2lnbmF0dXJlIGluIElFRUUgZW5jb2RpbmdcbiAqIEByZXR1cm4gRUNEU0Egc2lnbmF0dXJlIGluIERFUiBlbmNvZGluZ1xuICovXG5mdW5jdGlvbiBjb252ZXJ0RWNkc2FJZWVlMTM2M1RvRGVyKGllZWUpIHtcbiAgICBpZiAoaWVlZS5sZW5ndGggJSAyICE9IDAgfHwgaWVlZS5sZW5ndGggPT0gMCB8fCBpZWVlLmxlbmd0aCA+IDEzMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIElFRUUgUDEzNjMgc2lnbmF0dXJlIGVuY29kaW5nLiBMZW5ndGg6IFwiICsgaWVlZS5sZW5ndGgpO1xuICAgIH1cbiAgICBjb25zdCByID0gdG9VbnNpZ25lZEJpZ051bShpZWVlLnN1YmFycmF5KDAsIGllZWUubGVuZ3RoIC8gMikpO1xuICAgIGNvbnN0IHMgPSB0b1Vuc2lnbmVkQmlnTnVtKGllZWUuc3ViYXJyYXkoaWVlZS5sZW5ndGggLyAyLCBpZWVlLmxlbmd0aCkpO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGNvbnN0IGxlbmd0aCA9IDEgKyAxICsgci5sZW5ndGggKyAxICsgMSArIHMubGVuZ3RoO1xuICAgIGxldCBkZXI7XG4gICAgaWYgKGxlbmd0aCA+PSAxMjgpIHtcbiAgICAgICAgZGVyID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoICsgMyk7XG4gICAgICAgIGRlcltvZmZzZXQrK10gPSA0ODtcbiAgICAgICAgZGVyW29mZnNldCsrXSA9IDEyOCArIDE7XG4gICAgICAgIGRlcltvZmZzZXQrK10gPSBsZW5ndGg7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBkZXIgPSBuZXcgVWludDhBcnJheShsZW5ndGggKyAyKTtcbiAgICAgICAgZGVyW29mZnNldCsrXSA9IDQ4O1xuICAgICAgICBkZXJbb2Zmc2V0KytdID0gbGVuZ3RoO1xuICAgIH1cbiAgICBkZXJbb2Zmc2V0KytdID0gMjtcbiAgICBkZXJbb2Zmc2V0KytdID0gci5sZW5ndGg7XG4gICAgZGVyLnNldChyLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSByLmxlbmd0aDtcbiAgICBkZXJbb2Zmc2V0KytdID0gMjtcbiAgICBkZXJbb2Zmc2V0KytdID0gcy5sZW5ndGg7XG4gICAgZGVyLnNldChzLCBvZmZzZXQpO1xuICAgIHJldHVybiBkZXI7XG59XG4vKipcbiAqIENvZGUgbW9kaWZpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL3RpbmsvYmxvYi82Zjc0Yjk5YTJiZmU2Njc3ZTM2NzA3OTkxMTZhNTcyNjhmZDA2N2ZhL2phdmFzY3JpcHQvc3VidGxlL2VsbGlwdGljX2N1cnZlcy50cyNMMzExXG4gKlxuICogVHJhbnNmb3JtIGEgYmlnIGludGVnZXIgaW4gYmlnIGVuZGlhbiB0byBtaW5pbWFsIHVuc2lnbmVkIGZvcm0gd2hpY2ggaGFzXG4gKiBubyBleHRyYSB6ZXJvIGF0IHRoZSBiZWdpbm5pbmcgZXhjZXB0IHdoZW4gdGhlIGhpZ2hlc3QgYml0IGlzIHNldC5cbiAqL1xuZnVuY3Rpb24gdG9VbnNpZ25lZEJpZ051bShieXRlcykge1xuICAgIC8vIFJlbW92ZSB6ZXJvIHByZWZpeGVzLlxuICAgIGxldCBzdGFydCA9IDA7XG4gICAgd2hpbGUgKHN0YXJ0IDwgYnl0ZXMubGVuZ3RoICYmIGJ5dGVzW3N0YXJ0XSA9PSAwKSB7XG4gICAgICAgIHN0YXJ0Kys7XG4gICAgfVxuICAgIGlmIChzdGFydCA9PSBieXRlcy5sZW5ndGgpIHtcbiAgICAgICAgc3RhcnQgPSBieXRlcy5sZW5ndGggLSAxO1xuICAgIH1cbiAgICBsZXQgZXh0cmFaZXJvID0gMDtcbiAgICAvLyBJZiB0aGUgMXN0IGJpdCBpcyBub3QgemVybywgYWRkIDEgemVybyBieXRlLlxuICAgIGlmICgoYnl0ZXNbc3RhcnRdICYgMTI4KSA9PSAxMjgpIHtcbiAgICAgICAgLy8gQWRkIGV4dHJhIHplcm8uXG4gICAgICAgIGV4dHJhWmVybyA9IDE7XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KGJ5dGVzLmxlbmd0aCAtIHN0YXJ0ICsgZXh0cmFaZXJvKTtcbiAgICByZXMuc2V0KGJ5dGVzLnN1YmFycmF5KHN0YXJ0KSwgZXh0cmFaZXJvKTtcbiAgICByZXR1cm4gcmVzO1xufVxuXG5leHBvcnQgeyBzaWduV2l0aEFwaUtleSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2ViY3J5cHRvLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/api-key-stamper/dist/webcrypto.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/api-key-stamper/node_modules/@noble/curves/esm/_shortw_utils.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@turnkey/api-key-stamper/node_modules/@noble/curves/esm/_shortw_utils.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createCurve: () => (/* binding */ createCurve),\n/* harmony export */   getHash: () => (/* binding */ getHash)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/hmac */ \"(ssr)/./node_modules/@turnkey/api-key-stamper/node_modules/@noble/hashes/esm/hmac.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@turnkey/api-key-stamper/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(ssr)/./node_modules/@turnkey/api-key-stamper/node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\n\n// connects noble-curves to noble-hashes\nfunction getHash(hash) {\n    return {\n        hash,\n        hmac: (key, ...msgs) => (0,_noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__.hmac)(hash, key, (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(...msgs)),\n        randomBytes: _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.randomBytes,\n    };\n}\nfunction createCurve(curveDef, defHash) {\n    const create = (hash) => (0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__.weierstrass)({ ...curveDef, ...getHash(hash) });\n    return Object.freeze({ ...create(defHash), create });\n}\n//# sourceMappingURL=_shortw_utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvYXBpLWtleS1zdGFtcGVyL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9fc2hvcnR3X3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDMEM7QUFDcUI7QUFDUDtBQUN4RDtBQUNPO0FBQ1A7QUFDQTtBQUNBLGdDQUFnQyx3REFBSSxZQUFZLGdFQUFXO0FBQzNELG1CQUFtQjtBQUNuQjtBQUNBO0FBQ087QUFDUCw2QkFBNkIscUVBQVcsR0FBRywrQkFBK0I7QUFDMUUsMkJBQTJCLDRCQUE0QjtBQUN2RDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbnVyc2VibG9jLy4vbm9kZV9tb2R1bGVzL0B0dXJua2V5L2FwaS1rZXktc3RhbXBlci9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vX3Nob3J0d191dGlscy5qcz8zMDFkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmltcG9ydCB7IGhtYWMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL2htYWMnO1xuaW1wb3J0IHsgY29uY2F0Qnl0ZXMsIHJhbmRvbUJ5dGVzIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy91dGlscyc7XG5pbXBvcnQgeyB3ZWllcnN0cmFzcyB9IGZyb20gJy4vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanMnO1xuLy8gY29ubmVjdHMgbm9ibGUtY3VydmVzIHRvIG5vYmxlLWhhc2hlc1xuZXhwb3J0IGZ1bmN0aW9uIGdldEhhc2goaGFzaCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGhhc2gsXG4gICAgICAgIGhtYWM6IChrZXksIC4uLm1zZ3MpID0+IGhtYWMoaGFzaCwga2V5LCBjb25jYXRCeXRlcyguLi5tc2dzKSksXG4gICAgICAgIHJhbmRvbUJ5dGVzLFxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ3VydmUoY3VydmVEZWYsIGRlZkhhc2gpIHtcbiAgICBjb25zdCBjcmVhdGUgPSAoaGFzaCkgPT4gd2VpZXJzdHJhc3MoeyAuLi5jdXJ2ZURlZiwgLi4uZ2V0SGFzaChoYXNoKSB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IC4uLmNyZWF0ZShkZWZIYXNoKSwgY3JlYXRlIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3Nob3J0d191dGlscy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/api-key-stamper/node_modules/@noble/curves/esm/_shortw_utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/api-key-stamper/node_modules/@noble/curves/esm/abstract/curve.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@turnkey/api-key-stamper/node_modules/@noble/curves/esm/abstract/curve.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   validateBasic: () => (/* binding */ validateBasic),\n/* harmony export */   wNAF: () => (/* binding */ wNAF)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/@turnkey/api-key-stamper/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@turnkey/api-key-stamper/node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Abelian group utilities\n\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n// Elliptic curve multiplication of Point by scalar. Fragile.\n// Scalars should always be less than curve order: this should be checked inside of a curve itself.\n// Creates precomputation tables for fast multiplication:\n// - private scalar is split by fixed size windows of W bits\n// - every window point is collected from window's table & added to accumulator\n// - since windows are different, same point inside tables won't be accessed more than once per calc\n// - each multiplication is 'Math.ceil(CURVE_ORDER / 𝑊) + 1' point additions (fixed for any scalar)\n// - +1 window is neccessary for wNAF\n// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow\n// windows to be in different memory locations\nfunction wNAF(c, bits) {\n    const constTimeNegate = (condition, item) => {\n        const neg = item.negate();\n        return condition ? neg : item;\n    };\n    const opts = (W) => {\n        const windows = Math.ceil(bits / W) + 1; // +1, because\n        const windowSize = 2 ** (W - 1); // -1 because we skip zero\n        return { windows, windowSize };\n    };\n    return {\n        constTimeNegate,\n        // non-const time multiplication ladder\n        unsafeLadder(elm, n) {\n            let p = c.ZERO;\n            let d = elm;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:\n         * - 𝑊 is the window size\n         * - 𝑛 is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @returns precomputed point tables flattened to a single array\n         */\n        precomputeWindow(elm, W) {\n            const { windows, windowSize } = opts(W);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for (let window = 0; window < windows; window++) {\n                base = p;\n                points.push(base);\n                // =1, because we skip zero\n                for (let i = 1; i < windowSize; i++) {\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */\n        wNAF(W, precomputes, n) {\n            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n            // But need to carefully remove other checks before wNAF. ORDER == bits here\n            const { windows, windowSize } = opts(W);\n            let p = c.ZERO;\n            let f = c.BASE;\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for (let window = 0; window < windows; window++) {\n                const offset = window * windowSize;\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n                // there is negate now: it is possible that negated element from low value\n                // would be the same as high element, which will create carry into next window.\n                // It's not obvious how this can fail, but still worth investigating later.\n                // Check if we're onto Zero point.\n                // Add random point inside current window to f.\n                const offset1 = offset;\n                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n                const cond1 = window % 2 !== 0;\n                const cond2 = wbits < 0;\n                if (wbits === 0) {\n                    // The most important part for const-time getPublicKey\n                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n                }\n                else {\n                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n                }\n            }\n            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n            // Even if the variable is still unused, there are some checks which will\n            // throw an exception, so compiler needs to prove they won't happen, which is hard.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return { p, f };\n        },\n        wNAFCached(P, precomputesMap, n, transform) {\n            // @ts-ignore\n            const W = P._WINDOW_SIZE || 1;\n            // Calculate precomputes on a first run, reuse them after\n            let comp = precomputesMap.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1) {\n                    precomputesMap.set(P, transform(comp));\n                }\n            }\n            return this.wNAF(W, comp, n);\n        },\n    };\n}\nfunction validateBasic(curve) {\n    (0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.validateField)(curve.Fp);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject)(curve, {\n        n: 'bigint',\n        h: 'bigint',\n        Gx: 'field',\n        Gy: 'field',\n    }, {\n        nBitLength: 'isSafeInteger',\n        nByteLength: 'isSafeInteger',\n    });\n    // Set defaults\n    return Object.freeze({\n        ...(0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.nLength)(curve.n, curve.nBitLength),\n        ...curve,\n        ...{ p: curve.Fp.ORDER },\n    });\n}\n//# sourceMappingURL=curve.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvYXBpLWtleS1zdGFtcGVyL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9jdXJ2ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNzRDtBQUNWO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pELHlDQUF5QztBQUN6QyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsa0JBQWtCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxnQkFBZ0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQSxpQ0FBaUMsa0JBQWtCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDTztBQUNQLElBQUksMERBQWE7QUFDakIsSUFBSSx5REFBYztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxXQUFXLG9EQUFPO0FBQ2xCO0FBQ0EsYUFBYSxtQkFBbUI7QUFDaEMsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9udXJzZWJsb2MvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvYXBpLWtleS1zdGFtcGVyL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9jdXJ2ZS5qcz8zYTJkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIEFiZWxpYW4gZ3JvdXAgdXRpbGl0aWVzXG5pbXBvcnQgeyB2YWxpZGF0ZUZpZWxkLCBuTGVuZ3RoIH0gZnJvbSAnLi9tb2R1bGFyLmpzJztcbmltcG9ydCB7IHZhbGlkYXRlT2JqZWN0IH0gZnJvbSAnLi91dGlscy5qcyc7XG5jb25zdCBfMG4gPSBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSBCaWdJbnQoMSk7XG4vLyBFbGxpcHRpYyBjdXJ2ZSBtdWx0aXBsaWNhdGlvbiBvZiBQb2ludCBieSBzY2FsYXIuIEZyYWdpbGUuXG4vLyBTY2FsYXJzIHNob3VsZCBhbHdheXMgYmUgbGVzcyB0aGFuIGN1cnZlIG9yZGVyOiB0aGlzIHNob3VsZCBiZSBjaGVja2VkIGluc2lkZSBvZiBhIGN1cnZlIGl0c2VsZi5cbi8vIENyZWF0ZXMgcHJlY29tcHV0YXRpb24gdGFibGVzIGZvciBmYXN0IG11bHRpcGxpY2F0aW9uOlxuLy8gLSBwcml2YXRlIHNjYWxhciBpcyBzcGxpdCBieSBmaXhlZCBzaXplIHdpbmRvd3Mgb2YgVyBiaXRzXG4vLyAtIGV2ZXJ5IHdpbmRvdyBwb2ludCBpcyBjb2xsZWN0ZWQgZnJvbSB3aW5kb3cncyB0YWJsZSAmIGFkZGVkIHRvIGFjY3VtdWxhdG9yXG4vLyAtIHNpbmNlIHdpbmRvd3MgYXJlIGRpZmZlcmVudCwgc2FtZSBwb2ludCBpbnNpZGUgdGFibGVzIHdvbid0IGJlIGFjY2Vzc2VkIG1vcmUgdGhhbiBvbmNlIHBlciBjYWxjXG4vLyAtIGVhY2ggbXVsdGlwbGljYXRpb24gaXMgJ01hdGguY2VpbChDVVJWRV9PUkRFUiAvIPCdkYopICsgMScgcG9pbnQgYWRkaXRpb25zIChmaXhlZCBmb3IgYW55IHNjYWxhcilcbi8vIC0gKzEgd2luZG93IGlzIG5lY2Nlc3NhcnkgZm9yIHdOQUZcbi8vIC0gd05BRiByZWR1Y2VzIHRhYmxlIHNpemU6IDJ4IGxlc3MgbWVtb3J5ICsgMnggZmFzdGVyIGdlbmVyYXRpb24sIGJ1dCAxMCUgc2xvd2VyIG11bHRpcGxpY2F0aW9uXG4vLyBUT0RPOiBSZXNlYXJjaCByZXR1cm5pbmcgMmQgSlMgYXJyYXkgb2Ygd2luZG93cywgaW5zdGVhZCBvZiBhIHNpbmdsZSB3aW5kb3cuIFRoaXMgd291bGQgYWxsb3dcbi8vIHdpbmRvd3MgdG8gYmUgaW4gZGlmZmVyZW50IG1lbW9yeSBsb2NhdGlvbnNcbmV4cG9ydCBmdW5jdGlvbiB3TkFGKGMsIGJpdHMpIHtcbiAgICBjb25zdCBjb25zdFRpbWVOZWdhdGUgPSAoY29uZGl0aW9uLCBpdGVtKSA9PiB7XG4gICAgICAgIGNvbnN0IG5lZyA9IGl0ZW0ubmVnYXRlKCk7XG4gICAgICAgIHJldHVybiBjb25kaXRpb24gPyBuZWcgOiBpdGVtO1xuICAgIH07XG4gICAgY29uc3Qgb3B0cyA9IChXKSA9PiB7XG4gICAgICAgIGNvbnN0IHdpbmRvd3MgPSBNYXRoLmNlaWwoYml0cyAvIFcpICsgMTsgLy8gKzEsIGJlY2F1c2VcbiAgICAgICAgY29uc3Qgd2luZG93U2l6ZSA9IDIgKiogKFcgLSAxKTsgLy8gLTEgYmVjYXVzZSB3ZSBza2lwIHplcm9cbiAgICAgICAgcmV0dXJuIHsgd2luZG93cywgd2luZG93U2l6ZSB9O1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29uc3RUaW1lTmVnYXRlLFxuICAgICAgICAvLyBub24tY29uc3QgdGltZSBtdWx0aXBsaWNhdGlvbiBsYWRkZXJcbiAgICAgICAgdW5zYWZlTGFkZGVyKGVsbSwgbikge1xuICAgICAgICAgICAgbGV0IHAgPSBjLlpFUk87XG4gICAgICAgICAgICBsZXQgZCA9IGVsbTtcbiAgICAgICAgICAgIHdoaWxlIChuID4gXzBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKG4gJiBfMW4pXG4gICAgICAgICAgICAgICAgICAgIHAgPSBwLmFkZChkKTtcbiAgICAgICAgICAgICAgICBkID0gZC5kb3VibGUoKTtcbiAgICAgICAgICAgICAgICBuID4+PSBfMW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSB3TkFGIHByZWNvbXB1dGF0aW9uIHdpbmRvdy4gVXNlZCBmb3IgY2FjaGluZy5cbiAgICAgICAgICogRGVmYXVsdCB3aW5kb3cgc2l6ZSBpcyBzZXQgYnkgYHV0aWxzLnByZWNvbXB1dGUoKWAgYW5kIGlzIGVxdWFsIHRvIDguXG4gICAgICAgICAqIE51bWJlciBvZiBwcmVjb21wdXRlZCBwb2ludHMgZGVwZW5kcyBvbiB0aGUgY3VydmUgc2l6ZTpcbiAgICAgICAgICogMl4o8J2RiuKIkjEpICogKE1hdGguY2VpbCjwnZGbIC8g8J2RiikgKyAxKSwgd2hlcmU6XG4gICAgICAgICAqIC0g8J2RiiBpcyB0aGUgd2luZG93IHNpemVcbiAgICAgICAgICogLSDwnZGbIGlzIHRoZSBiaXRsZW5ndGggb2YgdGhlIGN1cnZlIG9yZGVyLlxuICAgICAgICAgKiBGb3IgYSAyNTYtYml0IGN1cnZlIGFuZCB3aW5kb3cgc2l6ZSA4LCB0aGUgbnVtYmVyIG9mIHByZWNvbXB1dGVkIHBvaW50cyBpcyAxMjggKiAzMyA9IDQyMjQuXG4gICAgICAgICAqIEByZXR1cm5zIHByZWNvbXB1dGVkIHBvaW50IHRhYmxlcyBmbGF0dGVuZWQgdG8gYSBzaW5nbGUgYXJyYXlcbiAgICAgICAgICovXG4gICAgICAgIHByZWNvbXB1dGVXaW5kb3coZWxtLCBXKSB7XG4gICAgICAgICAgICBjb25zdCB7IHdpbmRvd3MsIHdpbmRvd1NpemUgfSA9IG9wdHMoVyk7XG4gICAgICAgICAgICBjb25zdCBwb2ludHMgPSBbXTtcbiAgICAgICAgICAgIGxldCBwID0gZWxtO1xuICAgICAgICAgICAgbGV0IGJhc2UgPSBwO1xuICAgICAgICAgICAgZm9yIChsZXQgd2luZG93ID0gMDsgd2luZG93IDwgd2luZG93czsgd2luZG93KyspIHtcbiAgICAgICAgICAgICAgICBiYXNlID0gcDtcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaChiYXNlKTtcbiAgICAgICAgICAgICAgICAvLyA9MSwgYmVjYXVzZSB3ZSBza2lwIHplcm9cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHdpbmRvd1NpemU7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBiYXNlID0gYmFzZS5hZGQocCk7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGJhc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwID0gYmFzZS5kb3VibGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwb2ludHM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbXBsZW1lbnRzIGVjIG11bHRpcGxpY2F0aW9uIHVzaW5nIHByZWNvbXB1dGVkIHRhYmxlcyBhbmQgdy1hcnkgbm9uLWFkamFjZW50IGZvcm0uXG4gICAgICAgICAqIEBwYXJhbSBXIHdpbmRvdyBzaXplXG4gICAgICAgICAqIEBwYXJhbSBwcmVjb21wdXRlcyBwcmVjb21wdXRlZCB0YWJsZXNcbiAgICAgICAgICogQHBhcmFtIG4gc2NhbGFyICh3ZSBkb24ndCBjaGVjayBoZXJlLCBidXQgc2hvdWxkIGJlIGxlc3MgdGhhbiBjdXJ2ZSBvcmRlcilcbiAgICAgICAgICogQHJldHVybnMgcmVhbCBhbmQgZmFrZSAoZm9yIGNvbnN0LXRpbWUpIHBvaW50c1xuICAgICAgICAgKi9cbiAgICAgICAgd05BRihXLCBwcmVjb21wdXRlcywgbikge1xuICAgICAgICAgICAgLy8gVE9ETzogbWF5YmUgY2hlY2sgdGhhdCBzY2FsYXIgaXMgbGVzcyB0aGFuIGdyb3VwIG9yZGVyPyB3TkFGIGJlaGF2aW91cyBpcyB1bmRlZmluZWQgb3RoZXJ3aXNlXG4gICAgICAgICAgICAvLyBCdXQgbmVlZCB0byBjYXJlZnVsbHkgcmVtb3ZlIG90aGVyIGNoZWNrcyBiZWZvcmUgd05BRi4gT1JERVIgPT0gYml0cyBoZXJlXG4gICAgICAgICAgICBjb25zdCB7IHdpbmRvd3MsIHdpbmRvd1NpemUgfSA9IG9wdHMoVyk7XG4gICAgICAgICAgICBsZXQgcCA9IGMuWkVSTztcbiAgICAgICAgICAgIGxldCBmID0gYy5CQVNFO1xuICAgICAgICAgICAgY29uc3QgbWFzayA9IEJpZ0ludCgyICoqIFcgLSAxKTsgLy8gQ3JlYXRlIG1hc2sgd2l0aCBXIG9uZXM6IDBiMTExMSBmb3IgVz00IGV0Yy5cbiAgICAgICAgICAgIGNvbnN0IG1heE51bWJlciA9IDIgKiogVztcbiAgICAgICAgICAgIGNvbnN0IHNoaWZ0QnkgPSBCaWdJbnQoVyk7XG4gICAgICAgICAgICBmb3IgKGxldCB3aW5kb3cgPSAwOyB3aW5kb3cgPCB3aW5kb3dzOyB3aW5kb3crKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHdpbmRvdyAqIHdpbmRvd1NpemU7XG4gICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBXIGJpdHMuXG4gICAgICAgICAgICAgICAgbGV0IHdiaXRzID0gTnVtYmVyKG4gJiBtYXNrKTtcbiAgICAgICAgICAgICAgICAvLyBTaGlmdCBudW1iZXIgYnkgVyBiaXRzLlxuICAgICAgICAgICAgICAgIG4gPj49IHNoaWZ0Qnk7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGJpdHMgYXJlIGJpZ2dlciB0aGFuIG1heCBzaXplLCB3ZSdsbCBzcGxpdCB0aG9zZS5cbiAgICAgICAgICAgICAgICAvLyArMjI0ID0+IDI1NiAtIDMyXG4gICAgICAgICAgICAgICAgaWYgKHdiaXRzID4gd2luZG93U2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICB3Yml0cyAtPSBtYXhOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgIG4gKz0gXzFuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGNvZGUgd2FzIGZpcnN0IHdyaXR0ZW4gd2l0aCBhc3N1bXB0aW9uIHRoYXQgJ2YnIGFuZCAncCcgd2lsbCBuZXZlciBiZSBpbmZpbml0eSBwb2ludDpcbiAgICAgICAgICAgICAgICAvLyBzaW5jZSBlYWNoIGFkZGl0aW9uIGlzIG11bHRpcGxpZWQgYnkgMiAqKiBXLCBpdCBjYW5ub3QgY2FuY2VsIGVhY2ggb3RoZXIuIEhvd2V2ZXIsXG4gICAgICAgICAgICAgICAgLy8gdGhlcmUgaXMgbmVnYXRlIG5vdzogaXQgaXMgcG9zc2libGUgdGhhdCBuZWdhdGVkIGVsZW1lbnQgZnJvbSBsb3cgdmFsdWVcbiAgICAgICAgICAgICAgICAvLyB3b3VsZCBiZSB0aGUgc2FtZSBhcyBoaWdoIGVsZW1lbnQsIHdoaWNoIHdpbGwgY3JlYXRlIGNhcnJ5IGludG8gbmV4dCB3aW5kb3cuXG4gICAgICAgICAgICAgICAgLy8gSXQncyBub3Qgb2J2aW91cyBob3cgdGhpcyBjYW4gZmFpbCwgYnV0IHN0aWxsIHdvcnRoIGludmVzdGlnYXRpbmcgbGF0ZXIuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2UncmUgb250byBaZXJvIHBvaW50LlxuICAgICAgICAgICAgICAgIC8vIEFkZCByYW5kb20gcG9pbnQgaW5zaWRlIGN1cnJlbnQgd2luZG93IHRvIGYuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0MSA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQyID0gb2Zmc2V0ICsgTWF0aC5hYnMod2JpdHMpIC0gMTsgLy8gLTEgYmVjYXVzZSB3ZSBza2lwIHplcm9cbiAgICAgICAgICAgICAgICBjb25zdCBjb25kMSA9IHdpbmRvdyAlIDIgIT09IDA7XG4gICAgICAgICAgICAgICAgY29uc3QgY29uZDIgPSB3Yml0cyA8IDA7XG4gICAgICAgICAgICAgICAgaWYgKHdiaXRzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBtb3N0IGltcG9ydGFudCBwYXJ0IGZvciBjb25zdC10aW1lIGdldFB1YmxpY0tleVxuICAgICAgICAgICAgICAgICAgICBmID0gZi5hZGQoY29uc3RUaW1lTmVnYXRlKGNvbmQxLCBwcmVjb21wdXRlc1tvZmZzZXQxXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAuYWRkKGNvbnN0VGltZU5lZ2F0ZShjb25kMiwgcHJlY29tcHV0ZXNbb2Zmc2V0Ml0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBKSVQtY29tcGlsZXIgc2hvdWxkIG5vdCBlbGltaW5hdGUgZiBoZXJlLCBzaW5jZSBpdCB3aWxsIGxhdGVyIGJlIHVzZWQgaW4gbm9ybWFsaXplWigpXG4gICAgICAgICAgICAvLyBFdmVuIGlmIHRoZSB2YXJpYWJsZSBpcyBzdGlsbCB1bnVzZWQsIHRoZXJlIGFyZSBzb21lIGNoZWNrcyB3aGljaCB3aWxsXG4gICAgICAgICAgICAvLyB0aHJvdyBhbiBleGNlcHRpb24sIHNvIGNvbXBpbGVyIG5lZWRzIHRvIHByb3ZlIHRoZXkgd29uJ3QgaGFwcGVuLCB3aGljaCBpcyBoYXJkLlxuICAgICAgICAgICAgLy8gQXQgdGhpcyBwb2ludCB0aGVyZSBpcyBhIHdheSB0byBGIGJlIGluZmluaXR5LXBvaW50IGV2ZW4gaWYgcCBpcyBub3QsXG4gICAgICAgICAgICAvLyB3aGljaCBtYWtlcyBpdCBsZXNzIGNvbnN0LXRpbWU6IGFyb3VuZCAxIGJpZ2ludCBtdWx0aXBseS5cbiAgICAgICAgICAgIHJldHVybiB7IHAsIGYgfTtcbiAgICAgICAgfSxcbiAgICAgICAgd05BRkNhY2hlZChQLCBwcmVjb21wdXRlc01hcCwgbiwgdHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBjb25zdCBXID0gUC5fV0lORE9XX1NJWkUgfHwgMTtcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBwcmVjb21wdXRlcyBvbiBhIGZpcnN0IHJ1biwgcmV1c2UgdGhlbSBhZnRlclxuICAgICAgICAgICAgbGV0IGNvbXAgPSBwcmVjb21wdXRlc01hcC5nZXQoUCk7XG4gICAgICAgICAgICBpZiAoIWNvbXApIHtcbiAgICAgICAgICAgICAgICBjb21wID0gdGhpcy5wcmVjb21wdXRlV2luZG93KFAsIFcpO1xuICAgICAgICAgICAgICAgIGlmIChXICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZWNvbXB1dGVzTWFwLnNldChQLCB0cmFuc2Zvcm0oY29tcCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLndOQUYoVywgY29tcCwgbik7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUJhc2ljKGN1cnZlKSB7XG4gICAgdmFsaWRhdGVGaWVsZChjdXJ2ZS5GcCk7XG4gICAgdmFsaWRhdGVPYmplY3QoY3VydmUsIHtcbiAgICAgICAgbjogJ2JpZ2ludCcsXG4gICAgICAgIGg6ICdiaWdpbnQnLFxuICAgICAgICBHeDogJ2ZpZWxkJyxcbiAgICAgICAgR3k6ICdmaWVsZCcsXG4gICAgfSwge1xuICAgICAgICBuQml0TGVuZ3RoOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgICAgIG5CeXRlTGVuZ3RoOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgfSk7XG4gICAgLy8gU2V0IGRlZmF1bHRzXG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuICAgICAgICAuLi5uTGVuZ3RoKGN1cnZlLm4sIGN1cnZlLm5CaXRMZW5ndGgpLFxuICAgICAgICAuLi5jdXJ2ZSxcbiAgICAgICAgLi4ueyBwOiBjdXJ2ZS5GcC5PUkRFUiB9LFxuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3VydmUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/api-key-stamper/node_modules/@noble/curves/esm/abstract/curve.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/api-key-stamper/node_modules/@noble/curves/esm/abstract/hash-to-curve.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/@turnkey/api-key-stamper/node_modules/@noble/curves/esm/abstract/hash-to-curve.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createHasher: () => (/* binding */ createHasher),\n/* harmony export */   expand_message_xmd: () => (/* binding */ expand_message_xmd),\n/* harmony export */   expand_message_xof: () => (/* binding */ expand_message_xof),\n/* harmony export */   hash_to_field: () => (/* binding */ hash_to_field),\n/* harmony export */   isogenyMap: () => (/* binding */ isogenyMap)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/@turnkey/api-key-stamper/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@turnkey/api-key-stamper/node_modules/@noble/curves/esm/abstract/utils.js\");\n\n\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE;\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value, length) {\n    if (value < 0 || value >= 1 << (8 * length)) {\n        throw new Error(`bad I2OSP call: value=${value} length=${length}`);\n    }\n    const res = Array.from({ length }).fill(0);\n    for (let i = length - 1; i >= 0; i--) {\n        res[i] = value & 0xff;\n        value >>>= 8;\n    }\n    return new Uint8Array(res);\n}\nfunction strxor(a, b) {\n    const arr = new Uint8Array(a.length);\n    for (let i = 0; i < a.length; i++) {\n        arr[i] = a[i] ^ b[i];\n    }\n    return arr;\n}\nfunction anum(item) {\n    if (!Number.isSafeInteger(item))\n        throw new Error('number expected');\n}\n// Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1\nfunction expand_message_xmd(msg, DST, lenInBytes, H) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(DST);\n    anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    if (DST.length > 255)\n        DST = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)('H2C-OVERSIZE-DST-'), DST));\n    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n    const ell = Math.ceil(lenInBytes / b_in_bytes);\n    if (ell > 255)\n        throw new Error('Invalid xmd length');\n    const DST_prime = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(DST, i2osp(DST.length, 1));\n    const Z_pad = i2osp(0, r_in_bytes);\n    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n    const b = new Array(ell);\n    const b_0 = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n    b[0] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(b_0, i2osp(1, 1), DST_prime));\n    for (let i = 1; i <= ell; i++) {\n        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];\n        b[i] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...args));\n    }\n    const pseudo_random_bytes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...b);\n    return pseudo_random_bytes.slice(0, lenInBytes);\n}\n// Produces a uniformly random byte string using an extendable-output function (XOF) H.\n// 1. The collision resistance of H MUST be at least k bits.\n// 2. H MUST be an XOF that has been proved indifferentiable from\n//    a random oracle under a reasonable cryptographic assumption.\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2\nfunction expand_message_xof(msg, DST, lenInBytes, k, H) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(DST);\n    anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n    if (DST.length > 255) {\n        const dkLen = Math.ceil((2 * k) / 8);\n        DST = H.create({ dkLen }).update((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)('H2C-OVERSIZE-DST-')).update(DST).digest();\n    }\n    if (lenInBytes > 65535 || DST.length > 255)\n        throw new Error('expand_message_xof: invalid lenInBytes');\n    return (H.create({ dkLen: lenInBytes })\n        .update(msg)\n        .update(i2osp(lenInBytes, 2))\n        // 2. DST_prime = DST || I2OSP(len(DST), 1)\n        .update(DST)\n        .update(i2osp(DST.length, 1))\n        .digest());\n}\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F\n * https://www.rfc-editor.org/rfc/rfc9380#section-5.2\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */\nfunction hash_to_field(msg, count, options) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(options, {\n        DST: 'stringOrUint8Array',\n        p: 'bigint',\n        m: 'isSafeInteger',\n        k: 'isSafeInteger',\n        hash: 'hash',\n    });\n    const { p, k, m, hash, expand, DST: _DST } = options;\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    anum(count);\n    const DST = typeof _DST === 'string' ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)(_DST) : _DST;\n    const log2p = p.toString(2).length;\n    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n    const len_in_bytes = count * m * L;\n    let prb; // pseudo_random_bytes\n    if (expand === 'xmd') {\n        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n    }\n    else if (expand === 'xof') {\n        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n    }\n    else if (expand === '_internal_pass') {\n        // for internal tests only\n        prb = msg;\n    }\n    else {\n        throw new Error('expand must be \"xmd\" or \"xof\"');\n    }\n    const u = new Array(count);\n    for (let i = 0; i < count; i++) {\n        const e = new Array(m);\n        for (let j = 0; j < m; j++) {\n            const elm_offset = L * (j + i * m);\n            const tv = prb.subarray(elm_offset, elm_offset + L);\n            e[j] = (0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.mod)(os2ip(tv), p);\n        }\n        u[i] = e;\n    }\n    return u;\n}\nfunction isogenyMap(field, map) {\n    // Make same order as in spec\n    const COEFF = map.map((i) => Array.from(i).reverse());\n    return (x, y) => {\n        const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));\n        x = field.div(xNum, xDen); // xNum / xDen\n        y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)\n        return { x, y };\n    };\n}\nfunction createHasher(Point, mapToCurve, def) {\n    if (typeof mapToCurve !== 'function')\n        throw new Error('mapToCurve() must be defined');\n    return {\n        // Encodes byte string to elliptic curve.\n        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        hashToCurve(msg, options) {\n            const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });\n            const u0 = Point.fromAffine(mapToCurve(u[0]));\n            const u1 = Point.fromAffine(mapToCurve(u[1]));\n            const P = u0.add(u1).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n        // Encodes byte string to elliptic curve.\n        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        encodeToCurve(msg, options) {\n            const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });\n            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n    };\n}\n//# sourceMappingURL=hash-to-curve.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvYXBpLWtleS1zdGFtcGVyL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBbUM7QUFDNEQ7QUFDL0Y7QUFDQSxjQUFjLHNEQUFlO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxPQUFPLFNBQVMsT0FBTztBQUN4RTtBQUNBLDZCQUE2QixRQUFRO0FBQ3JDLDZCQUE2QixRQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLElBQUksaURBQU07QUFDVixJQUFJLGlEQUFNO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNEQUFXLENBQUMsc0RBQVc7QUFDdkMsWUFBWSw4Q0FBOEM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNEQUFXO0FBQ2pDO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0Esa0JBQWtCLHNEQUFXO0FBQzdCLGFBQWEsc0RBQVc7QUFDeEIsb0JBQW9CLFVBQVU7QUFDOUI7QUFDQSxpQkFBaUIsc0RBQVc7QUFDNUI7QUFDQSxnQ0FBZ0Msc0RBQVc7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLElBQUksaURBQU07QUFDVixJQUFJLGlEQUFNO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixPQUFPLFNBQVMsc0RBQVc7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkVBQTZFO0FBQ2pHO0FBQ0E7QUFDTztBQUNQLElBQUkseURBQWM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxZQUFZLG1DQUFtQztBQUMvQyxJQUFJLGlEQUFNO0FBQ1Y7QUFDQSwyQ0FBMkMsc0RBQVc7QUFDdEQ7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBLG1CQUFtQixnREFBRztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxpREFBaUQ7QUFDakQsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxrQ0FBa0M7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsd0NBQXdDO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9udXJzZWJsb2MvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvYXBpLWtleS1zdGFtcGVyL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzPzc1MGUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbW9kIH0gZnJvbSAnLi9tb2R1bGFyLmpzJztcbmltcG9ydCB7IGJ5dGVzVG9OdW1iZXJCRSwgYWJ5dGVzLCBjb25jYXRCeXRlcywgdXRmOFRvQnl0ZXMsIHZhbGlkYXRlT2JqZWN0IH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBPY3RldCBTdHJlYW0gdG8gSW50ZWdlci4gXCJzcGVjXCIgaW1wbGVtZW50YXRpb24gb2Ygb3MyaXAgaXMgMi41eCBzbG93ZXIgdnMgYnl0ZXNUb051bWJlckJFLlxuY29uc3Qgb3MyaXAgPSBieXRlc1RvTnVtYmVyQkU7XG4vLyBJbnRlZ2VyIHRvIE9jdGV0IFN0cmVhbSAobnVtYmVyVG9CeXRlc0JFKVxuZnVuY3Rpb24gaTJvc3AodmFsdWUsIGxlbmd0aCkge1xuICAgIGlmICh2YWx1ZSA8IDAgfHwgdmFsdWUgPj0gMSA8PCAoOCAqIGxlbmd0aCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBiYWQgSTJPU1AgY2FsbDogdmFsdWU9JHt2YWx1ZX0gbGVuZ3RoPSR7bGVuZ3RofWApO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoIH0pLmZpbGwoMCk7XG4gICAgZm9yIChsZXQgaSA9IGxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHJlc1tpXSA9IHZhbHVlICYgMHhmZjtcbiAgICAgICAgdmFsdWUgPj4+PSA4O1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkocmVzKTtcbn1cbmZ1bmN0aW9uIHN0cnhvcihhLCBiKSB7XG4gICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYS5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJbaV0gPSBhW2ldIF4gYltpXTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbn1cbmZ1bmN0aW9uIGFudW0oaXRlbSkge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoaXRlbSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbnVtYmVyIGV4cGVjdGVkJyk7XG59XG4vLyBQcm9kdWNlcyBhIHVuaWZvcm1seSByYW5kb20gYnl0ZSBzdHJpbmcgdXNpbmcgYSBjcnlwdG9ncmFwaGljIGhhc2ggZnVuY3Rpb24gSCB0aGF0IG91dHB1dHMgYiBiaXRzXG4vLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMy4xXG5leHBvcnQgZnVuY3Rpb24gZXhwYW5kX21lc3NhZ2VfeG1kKG1zZywgRFNULCBsZW5JbkJ5dGVzLCBIKSB7XG4gICAgYWJ5dGVzKG1zZyk7XG4gICAgYWJ5dGVzKERTVCk7XG4gICAgYW51bShsZW5JbkJ5dGVzKTtcbiAgICAvLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMy4zXG4gICAgaWYgKERTVC5sZW5ndGggPiAyNTUpXG4gICAgICAgIERTVCA9IEgoY29uY2F0Qnl0ZXModXRmOFRvQnl0ZXMoJ0gyQy1PVkVSU0laRS1EU1QtJyksIERTVCkpO1xuICAgIGNvbnN0IHsgb3V0cHV0TGVuOiBiX2luX2J5dGVzLCBibG9ja0xlbjogcl9pbl9ieXRlcyB9ID0gSDtcbiAgICBjb25zdCBlbGwgPSBNYXRoLmNlaWwobGVuSW5CeXRlcyAvIGJfaW5fYnl0ZXMpO1xuICAgIGlmIChlbGwgPiAyNTUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB4bWQgbGVuZ3RoJyk7XG4gICAgY29uc3QgRFNUX3ByaW1lID0gY29uY2F0Qnl0ZXMoRFNULCBpMm9zcChEU1QubGVuZ3RoLCAxKSk7XG4gICAgY29uc3QgWl9wYWQgPSBpMm9zcCgwLCByX2luX2J5dGVzKTtcbiAgICBjb25zdCBsX2lfYl9zdHIgPSBpMm9zcChsZW5JbkJ5dGVzLCAyKTsgLy8gbGVuX2luX2J5dGVzX3N0clxuICAgIGNvbnN0IGIgPSBuZXcgQXJyYXkoZWxsKTtcbiAgICBjb25zdCBiXzAgPSBIKGNvbmNhdEJ5dGVzKFpfcGFkLCBtc2csIGxfaV9iX3N0ciwgaTJvc3AoMCwgMSksIERTVF9wcmltZSkpO1xuICAgIGJbMF0gPSBIKGNvbmNhdEJ5dGVzKGJfMCwgaTJvc3AoMSwgMSksIERTVF9wcmltZSkpO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IGVsbDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBbc3RyeG9yKGJfMCwgYltpIC0gMV0pLCBpMm9zcChpICsgMSwgMSksIERTVF9wcmltZV07XG4gICAgICAgIGJbaV0gPSBIKGNvbmNhdEJ5dGVzKC4uLmFyZ3MpKTtcbiAgICB9XG4gICAgY29uc3QgcHNldWRvX3JhbmRvbV9ieXRlcyA9IGNvbmNhdEJ5dGVzKC4uLmIpO1xuICAgIHJldHVybiBwc2V1ZG9fcmFuZG9tX2J5dGVzLnNsaWNlKDAsIGxlbkluQnl0ZXMpO1xufVxuLy8gUHJvZHVjZXMgYSB1bmlmb3JtbHkgcmFuZG9tIGJ5dGUgc3RyaW5nIHVzaW5nIGFuIGV4dGVuZGFibGUtb3V0cHV0IGZ1bmN0aW9uIChYT0YpIEguXG4vLyAxLiBUaGUgY29sbGlzaW9uIHJlc2lzdGFuY2Ugb2YgSCBNVVNUIGJlIGF0IGxlYXN0IGsgYml0cy5cbi8vIDIuIEggTVVTVCBiZSBhbiBYT0YgdGhhdCBoYXMgYmVlbiBwcm92ZWQgaW5kaWZmZXJlbnRpYWJsZSBmcm9tXG4vLyAgICBhIHJhbmRvbSBvcmFjbGUgdW5kZXIgYSByZWFzb25hYmxlIGNyeXB0b2dyYXBoaWMgYXNzdW1wdGlvbi5cbi8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4zLjJcbmV4cG9ydCBmdW5jdGlvbiBleHBhbmRfbWVzc2FnZV94b2YobXNnLCBEU1QsIGxlbkluQnl0ZXMsIGssIEgpIHtcbiAgICBhYnl0ZXMobXNnKTtcbiAgICBhYnl0ZXMoRFNUKTtcbiAgICBhbnVtKGxlbkluQnl0ZXMpO1xuICAgIC8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4zLjNcbiAgICAvLyBEU1QgPSBIKCdIMkMtT1ZFUlNJWkUtRFNULScgfHwgYV92ZXJ5X2xvbmdfRFNULCBNYXRoLmNlaWwoKGxlbkluQnl0ZXMgKiBrKSAvIDgpKTtcbiAgICBpZiAoRFNULmxlbmd0aCA+IDI1NSkge1xuICAgICAgICBjb25zdCBka0xlbiA9IE1hdGguY2VpbCgoMiAqIGspIC8gOCk7XG4gICAgICAgIERTVCA9IEguY3JlYXRlKHsgZGtMZW4gfSkudXBkYXRlKHV0ZjhUb0J5dGVzKCdIMkMtT1ZFUlNJWkUtRFNULScpKS51cGRhdGUoRFNUKS5kaWdlc3QoKTtcbiAgICB9XG4gICAgaWYgKGxlbkluQnl0ZXMgPiA2NTUzNSB8fCBEU1QubGVuZ3RoID4gMjU1KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGFuZF9tZXNzYWdlX3hvZjogaW52YWxpZCBsZW5JbkJ5dGVzJyk7XG4gICAgcmV0dXJuIChILmNyZWF0ZSh7IGRrTGVuOiBsZW5JbkJ5dGVzIH0pXG4gICAgICAgIC51cGRhdGUobXNnKVxuICAgICAgICAudXBkYXRlKGkyb3NwKGxlbkluQnl0ZXMsIDIpKVxuICAgICAgICAvLyAyLiBEU1RfcHJpbWUgPSBEU1QgfHwgSTJPU1AobGVuKERTVCksIDEpXG4gICAgICAgIC51cGRhdGUoRFNUKVxuICAgICAgICAudXBkYXRlKGkyb3NwKERTVC5sZW5ndGgsIDEpKVxuICAgICAgICAuZGlnZXN0KCkpO1xufVxuLyoqXG4gKiBIYXNoZXMgYXJiaXRyYXJ5LWxlbmd0aCBieXRlIHN0cmluZ3MgdG8gYSBsaXN0IG9mIG9uZSBvciBtb3JlIGVsZW1lbnRzIG9mIGEgZmluaXRlIGZpZWxkIEZcbiAqIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4yXG4gKiBAcGFyYW0gbXNnIGEgYnl0ZSBzdHJpbmcgY29udGFpbmluZyB0aGUgbWVzc2FnZSB0byBoYXNoXG4gKiBAcGFyYW0gY291bnQgdGhlIG51bWJlciBvZiBlbGVtZW50cyBvZiBGIHRvIG91dHB1dFxuICogQHBhcmFtIG9wdGlvbnMgYHtEU1Q6IHN0cmluZywgcDogYmlnaW50LCBtOiBudW1iZXIsIGs6IG51bWJlciwgZXhwYW5kOiAneG1kJyB8ICd4b2YnLCBoYXNoOiBIfWAsIHNlZSBhYm92ZVxuICogQHJldHVybnMgW3VfMCwgLi4uLCB1Xyhjb3VudCAtIDEpXSwgYSBsaXN0IG9mIGZpZWxkIGVsZW1lbnRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzaF90b19maWVsZChtc2csIGNvdW50LCBvcHRpb25zKSB7XG4gICAgdmFsaWRhdGVPYmplY3Qob3B0aW9ucywge1xuICAgICAgICBEU1Q6ICdzdHJpbmdPclVpbnQ4QXJyYXknLFxuICAgICAgICBwOiAnYmlnaW50JyxcbiAgICAgICAgbTogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBrOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgICAgIGhhc2g6ICdoYXNoJyxcbiAgICB9KTtcbiAgICBjb25zdCB7IHAsIGssIG0sIGhhc2gsIGV4cGFuZCwgRFNUOiBfRFNUIH0gPSBvcHRpb25zO1xuICAgIGFieXRlcyhtc2cpO1xuICAgIGFudW0oY291bnQpO1xuICAgIGNvbnN0IERTVCA9IHR5cGVvZiBfRFNUID09PSAnc3RyaW5nJyA/IHV0ZjhUb0J5dGVzKF9EU1QpIDogX0RTVDtcbiAgICBjb25zdCBsb2cycCA9IHAudG9TdHJpbmcoMikubGVuZ3RoO1xuICAgIGNvbnN0IEwgPSBNYXRoLmNlaWwoKGxvZzJwICsgaykgLyA4KTsgLy8gc2VjdGlvbiA1LjEgb2YgaWV0ZiBkcmFmdCBsaW5rIGFib3ZlXG4gICAgY29uc3QgbGVuX2luX2J5dGVzID0gY291bnQgKiBtICogTDtcbiAgICBsZXQgcHJiOyAvLyBwc2V1ZG9fcmFuZG9tX2J5dGVzXG4gICAgaWYgKGV4cGFuZCA9PT0gJ3htZCcpIHtcbiAgICAgICAgcHJiID0gZXhwYW5kX21lc3NhZ2VfeG1kKG1zZywgRFNULCBsZW5faW5fYnl0ZXMsIGhhc2gpO1xuICAgIH1cbiAgICBlbHNlIGlmIChleHBhbmQgPT09ICd4b2YnKSB7XG4gICAgICAgIHByYiA9IGV4cGFuZF9tZXNzYWdlX3hvZihtc2csIERTVCwgbGVuX2luX2J5dGVzLCBrLCBoYXNoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXhwYW5kID09PSAnX2ludGVybmFsX3Bhc3MnKSB7XG4gICAgICAgIC8vIGZvciBpbnRlcm5hbCB0ZXN0cyBvbmx5XG4gICAgICAgIHByYiA9IG1zZztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwYW5kIG11c3QgYmUgXCJ4bWRcIiBvciBcInhvZlwiJyk7XG4gICAgfVxuICAgIGNvbnN0IHUgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICBjb25zdCBlID0gbmV3IEFycmF5KG0pO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG07IGorKykge1xuICAgICAgICAgICAgY29uc3QgZWxtX29mZnNldCA9IEwgKiAoaiArIGkgKiBtKTtcbiAgICAgICAgICAgIGNvbnN0IHR2ID0gcHJiLnN1YmFycmF5KGVsbV9vZmZzZXQsIGVsbV9vZmZzZXQgKyBMKTtcbiAgICAgICAgICAgIGVbal0gPSBtb2Qob3MyaXAodHYpLCBwKTtcbiAgICAgICAgfVxuICAgICAgICB1W2ldID0gZTtcbiAgICB9XG4gICAgcmV0dXJuIHU7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNvZ2VueU1hcChmaWVsZCwgbWFwKSB7XG4gICAgLy8gTWFrZSBzYW1lIG9yZGVyIGFzIGluIHNwZWNcbiAgICBjb25zdCBDT0VGRiA9IG1hcC5tYXAoKGkpID0+IEFycmF5LmZyb20oaSkucmV2ZXJzZSgpKTtcbiAgICByZXR1cm4gKHgsIHkpID0+IHtcbiAgICAgICAgY29uc3QgW3hOdW0sIHhEZW4sIHlOdW0sIHlEZW5dID0gQ09FRkYubWFwKCh2YWwpID0+IHZhbC5yZWR1Y2UoKGFjYywgaSkgPT4gZmllbGQuYWRkKGZpZWxkLm11bChhY2MsIHgpLCBpKSkpO1xuICAgICAgICB4ID0gZmllbGQuZGl2KHhOdW0sIHhEZW4pOyAvLyB4TnVtIC8geERlblxuICAgICAgICB5ID0gZmllbGQubXVsKHksIGZpZWxkLmRpdih5TnVtLCB5RGVuKSk7IC8vIHkgKiAoeU51bSAvIHlEZXYpXG4gICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUhhc2hlcihQb2ludCwgbWFwVG9DdXJ2ZSwgZGVmKSB7XG4gICAgaWYgKHR5cGVvZiBtYXBUb0N1cnZlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcFRvQ3VydmUoKSBtdXN0IGJlIGRlZmluZWQnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvLyBFbmNvZGVzIGJ5dGUgc3RyaW5nIHRvIGVsbGlwdGljIGN1cnZlLlxuICAgICAgICAvLyBoYXNoX3RvX2N1cnZlIGZyb20gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi0zXG4gICAgICAgIGhhc2hUb0N1cnZlKG1zZywgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgdSA9IGhhc2hfdG9fZmllbGQobXNnLCAyLCB7IC4uLmRlZiwgRFNUOiBkZWYuRFNULCAuLi5vcHRpb25zIH0pO1xuICAgICAgICAgICAgY29uc3QgdTAgPSBQb2ludC5mcm9tQWZmaW5lKG1hcFRvQ3VydmUodVswXSkpO1xuICAgICAgICAgICAgY29uc3QgdTEgPSBQb2ludC5mcm9tQWZmaW5lKG1hcFRvQ3VydmUodVsxXSkpO1xuICAgICAgICAgICAgY29uc3QgUCA9IHUwLmFkZCh1MSkuY2xlYXJDb2ZhY3RvcigpO1xuICAgICAgICAgICAgUC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFA7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEVuY29kZXMgYnl0ZSBzdHJpbmcgdG8gZWxsaXB0aWMgY3VydmUuXG4gICAgICAgIC8vIGVuY29kZV90b19jdXJ2ZSBmcm9tIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tM1xuICAgICAgICBlbmNvZGVUb0N1cnZlKG1zZywgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgdSA9IGhhc2hfdG9fZmllbGQobXNnLCAxLCB7IC4uLmRlZiwgRFNUOiBkZWYuZW5jb2RlRFNULCAuLi5vcHRpb25zIH0pO1xuICAgICAgICAgICAgY29uc3QgUCA9IFBvaW50LmZyb21BZmZpbmUobWFwVG9DdXJ2ZSh1WzBdKSkuY2xlYXJDb2ZhY3RvcigpO1xuICAgICAgICAgICAgUC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFA7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhc2gtdG8tY3VydmUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/api-key-stamper/node_modules/@noble/curves/esm/abstract/hash-to-curve.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/api-key-stamper/node_modules/@noble/curves/esm/abstract/modular.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@turnkey/api-key-stamper/node_modules/@noble/curves/esm/abstract/modular.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Field: () => (/* binding */ Field),\n/* harmony export */   FpDiv: () => (/* binding */ FpDiv),\n/* harmony export */   FpInvertBatch: () => (/* binding */ FpInvertBatch),\n/* harmony export */   FpIsSquare: () => (/* binding */ FpIsSquare),\n/* harmony export */   FpPow: () => (/* binding */ FpPow),\n/* harmony export */   FpSqrt: () => (/* binding */ FpSqrt),\n/* harmony export */   FpSqrtEven: () => (/* binding */ FpSqrtEven),\n/* harmony export */   FpSqrtOdd: () => (/* binding */ FpSqrtOdd),\n/* harmony export */   getFieldBytesLength: () => (/* binding */ getFieldBytesLength),\n/* harmony export */   getMinHashLength: () => (/* binding */ getMinHashLength),\n/* harmony export */   hashToPrivateScalar: () => (/* binding */ hashToPrivateScalar),\n/* harmony export */   invert: () => (/* binding */ invert),\n/* harmony export */   isNegativeLE: () => (/* binding */ isNegativeLE),\n/* harmony export */   mapHashToField: () => (/* binding */ mapHashToField),\n/* harmony export */   mod: () => (/* binding */ mod),\n/* harmony export */   nLength: () => (/* binding */ nLength),\n/* harmony export */   pow: () => (/* binding */ pow),\n/* harmony export */   pow2: () => (/* binding */ pow2),\n/* harmony export */   tonelliShanks: () => (/* binding */ tonelliShanks),\n/* harmony export */   validateField: () => (/* binding */ validateField)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@turnkey/api-key-stamper/node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Utilities for modular arithmetics and finite fields\n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);\n// prettier-ignore\nconst _9n = BigInt(9), _16n = BigInt(16);\n// Calculates a modulo b\nfunction mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\n// TODO: use field version && remove\nfunction pow(num, power, modulo) {\n    if (modulo <= _0n || power < _0n)\n        throw new Error('Expected power/modulo > 0');\n    if (modulo === _1n)\n        return _0n;\n    let res = _1n;\n    while (power > _0n) {\n        if (power & _1n)\n            res = (res * num) % modulo;\n        num = (num * num) % modulo;\n        power >>= _1n;\n    }\n    return res;\n}\n// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)\nfunction pow2(x, power, modulo) {\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n// Inverses number over modulo\nfunction invert(number, modulo) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * Will start an infinite loop if field order P is not prime.\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nfunction tonelliShanks(P) {\n    // Legendre constant: used to calculate Legendre symbol (a | p),\n    // which denotes the value of a^((p-1)/2) (mod p).\n    // (a | p) ≡ 1    if a is a square (mod p)\n    // (a | p) ≡ -1   if a is not a square (mod p)\n    // (a | p) ≡ 0    if a ≡ 0 (mod p)\n    const legendreC = (P - _1n) / _2n;\n    let Q, S, Z;\n    // Step 1: By factoring out powers of 2 from p - 1,\n    // find q and s such that p - 1 = q*(2^s) with q odd\n    for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)\n        ;\n    // Step 2: Select a non-square z such that (z | p) ≡ -1 and set c ≡ zq\n    for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++)\n        ;\n    // Fast-path\n    if (S === 1) {\n        const p1div4 = (P + _1n) / _4n;\n        return function tonelliFast(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Slow-path\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        // Step 0: Check that n is indeed a square: (n | p) should not be ≡ -1\n        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))\n            throw new Error('Cannot find square root');\n        let r = S;\n        // TODO: will fail at Fp2/etc\n        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n        let x = Fp.pow(n, Q1div2); // first guess at the square root\n        let b = Fp.pow(n, Q); // first guess at the fudge factor\n        while (!Fp.eql(b, Fp.ONE)) {\n            if (Fp.eql(b, Fp.ZERO))\n                return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n            // Find m such b^(2^m)==1\n            let m = 1;\n            for (let t2 = Fp.sqr(b); m < r; m++) {\n                if (Fp.eql(t2, Fp.ONE))\n                    break;\n                t2 = Fp.sqr(t2); // t2 *= t2\n            }\n            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n            g = Fp.sqr(ge); // g = ge * ge\n            x = Fp.mul(x, ge); // x *= ge\n            b = Fp.mul(b, g); // b *= g\n            r = m;\n        }\n        return x;\n    };\n}\nfunction FpSqrt(P) {\n    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.\n    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n    // P ≡ 3 (mod 4)\n    // √n = n^((P+1)/4)\n    if (P % _4n === _3n) {\n        // Not all roots possible!\n        // const ORDER =\n        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n        // const NUM = 72057594037927816n;\n        const p1div4 = (P + _1n) / _4n;\n        return function sqrt3mod4(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            // Throw if root**2 != n\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Atkin algorithm for q ≡ 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n    if (P % _8n === _5n) {\n        const c1 = (P - _5n) / _8n;\n        return function sqrt5mod8(Fp, n) {\n            const n2 = Fp.mul(n, _2n);\n            const v = Fp.pow(n2, c1);\n            const nv = Fp.mul(n, v);\n            const i = Fp.mul(Fp.mul(nv, _2n), v);\n            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // P ≡ 9 (mod 16)\n    if (P % _16n === _9n) {\n        // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n        // Means we cannot use sqrt for constants at all!\n        //\n        // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n        // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n        // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n        // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n        // sqrt = (x) => {\n        //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n        //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n        //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n        //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n        //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n        //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n        //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n        //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n        //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n        //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n        // }\n    }\n    // Other cases: Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nconst isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n    'eql', 'add', 'sub', 'mul', 'pow', 'div',\n    'addN', 'subN', 'mulN', 'sqrN'\n];\nfunction validateField(field) {\n    const initial = {\n        ORDER: 'bigint',\n        MASK: 'bigint',\n        BYTES: 'isSafeInteger',\n        BITS: 'isSafeInteger',\n    };\n    const opts = FIELD_FIELDS.reduce((map, val) => {\n        map[val] = 'function';\n        return map;\n    }, initial);\n    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(field, opts);\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nfunction FpPow(f, num, power) {\n    // Should have same speed as pow for bigints\n    // TODO: benchmark!\n    if (power < _0n)\n        throw new Error('Expected power > 0');\n    if (power === _0n)\n        return f.ONE;\n    if (power === _1n)\n        return num;\n    let p = f.ONE;\n    let d = num;\n    while (power > _0n) {\n        if (power & _1n)\n            p = f.mul(p, d);\n        d = f.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * `inv(0)` will return `undefined` here: make sure to throw an error.\n */\nfunction FpInvertBatch(f, nums) {\n    const tmp = new Array(nums.length);\n    // Walk from first to last, multiply them by each other MOD p\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = acc;\n        return f.mul(acc, num);\n    }, f.ONE);\n    // Invert last element\n    const inverted = f.inv(lastMultiplied);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = f.mul(acc, tmp[i]);\n        return f.mul(acc, num);\n    }, inverted);\n    return tmp;\n}\nfunction FpDiv(f, lhs, rhs) {\n    return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\n// This function returns True whenever the value x is a square in the field F.\nfunction FpIsSquare(f) {\n    const legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic\n    return (x) => {\n        const p = f.pow(x, legendreConst);\n        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n    };\n}\n// CURVE.n lengths\nfunction nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return { nBitLength: _nBitLength, nByteLength };\n}\n/**\n * Initializes a finite field over prime. **Non-primes are not supported.**\n * Do not init in loop: slow. Very fragile: always run a benchmark on a change.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nfunction Field(ORDER, bitLen, isLE = false, redef = {}) {\n    if (ORDER <= _0n)\n        throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n    if (BYTES > 2048)\n        throw new Error('Field lengths over 2048 bytes are not supported');\n    const sqrtP = FpSqrt(ORDER);\n    const f = Object.freeze({\n        ORDER,\n        BITS,\n        BYTES,\n        MASK: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        create: (num) => mod(num, ORDER),\n        isValid: (num) => {\n            if (typeof num !== 'bigint')\n                throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num) => num === _0n,\n        isOdd: (num) => (num & _1n) === _1n,\n        neg: (num) => mod(-num, ORDER),\n        eql: (lhs, rhs) => lhs === rhs,\n        sqr: (num) => mod(num * num, ORDER),\n        add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n        pow: (num, power) => FpPow(f, num, power),\n        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num) => num * num,\n        addN: (lhs, rhs) => lhs + rhs,\n        subN: (lhs, rhs) => lhs - rhs,\n        mulN: (lhs, rhs) => lhs * rhs,\n        inv: (num) => invert(num, ORDER),\n        sqrt: redef.sqrt || ((n) => sqrtP(f, n)),\n        invertBatch: (lst) => FpInvertBatch(f, lst),\n        // TODO: do we really need constant cmov?\n        // We don't have const-time bigints anyway, so probably will be not very useful\n        cmov: (a, b, c) => (c ? b : a),\n        toBytes: (num) => (isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(num, BYTES) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(num, BYTES)),\n        fromBytes: (bytes) => {\n            if (bytes.length !== BYTES)\n                throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);\n            return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(bytes) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(bytes);\n        },\n    });\n    return Object.freeze(f);\n}\nfunction FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nfunction FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use mapKeyToField instead\n */\nfunction hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('privateHash', hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n        throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(hash) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nfunction getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== 'bigint')\n        throw new Error('field order must be bigint');\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nfunction getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nfunction mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024)\n        throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(key) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(reduced, fieldLen) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(reduced, fieldLen);\n}\n//# sourceMappingURL=modular.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvYXBpLWtleS1zdGFtcGVyL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9tb2R1bGFyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDdUk7QUFDdkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLHFFQUFxRSxRQUFRLE1BQU0sT0FBTztBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpQkFBaUI7QUFDOUM7QUFDQTtBQUNBLGtCQUFrQiwyQ0FBMkM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUMsbUNBQW1DO0FBQ25DLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQsNEJBQTRCO0FBQzVCLCtCQUErQjtBQUMvQiw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQsa0RBQWtEO0FBQ2xELGtEQUFrRDtBQUNsRCxrREFBa0Q7QUFDbEQ7QUFDQSxrREFBa0Q7QUFDbEQsa0RBQWtEO0FBQ2xELGtEQUFrRDtBQUNsRCxrREFBa0Q7QUFDbEQsc0RBQXNEO0FBQ3RELHNEQUFzRDtBQUN0RCwwQ0FBMEM7QUFDMUMsMENBQTBDO0FBQzFDLHNEQUFzRDtBQUN0RCwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxXQUFXLHlEQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUCxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxzREFBc0Q7QUFDN0Q7QUFDQSx5REFBeUQsTUFBTTtBQUMvRCxZQUFZLHVDQUF1QztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsa0RBQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxXQUFXO0FBQzFGLDhDQUE4QztBQUM5QyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDBEQUFlLGVBQWUsMERBQWU7QUFDL0U7QUFDQTtBQUNBLDBEQUEwRCxNQUFNLFFBQVEsYUFBYTtBQUNyRiwwQkFBMEIsMERBQWUsVUFBVSwwREFBZTtBQUNsRSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFdBQVcsc0RBQVc7QUFDdEI7QUFDQTtBQUNBO0FBQ0EseURBQXlELE9BQU8sNEJBQTRCLFFBQVE7QUFDcEcsdUJBQXVCLDBEQUFlLFNBQVMsMERBQWU7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPLDRCQUE0QixJQUFJO0FBQzNFLHVCQUF1QiwwREFBZSxRQUFRLDBEQUFlO0FBQzdEO0FBQ0E7QUFDQSxrQkFBa0IsMERBQWUsc0JBQXNCLDBEQUFlO0FBQ3RFO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9udXJzZWJsb2MvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvYXBpLWtleS1zdGFtcGVyL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9tb2R1bGFyLmpzP2Y5MDQiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gVXRpbGl0aWVzIGZvciBtb2R1bGFyIGFyaXRobWV0aWNzIGFuZCBmaW5pdGUgZmllbGRzXG5pbXBvcnQgeyBiaXRNYXNrLCBudW1iZXJUb0J5dGVzQkUsIG51bWJlclRvQnl0ZXNMRSwgYnl0ZXNUb051bWJlckJFLCBieXRlc1RvTnVtYmVyTEUsIGVuc3VyZUJ5dGVzLCB2YWxpZGF0ZU9iamVjdCwgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzBuID0gQmlnSW50KDApLCBfMW4gPSBCaWdJbnQoMSksIF8ybiA9IEJpZ0ludCgyKSwgXzNuID0gQmlnSW50KDMpO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfNG4gPSBCaWdJbnQoNCksIF81biA9IEJpZ0ludCg1KSwgXzhuID0gQmlnSW50KDgpO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfOW4gPSBCaWdJbnQoOSksIF8xNm4gPSBCaWdJbnQoMTYpO1xuLy8gQ2FsY3VsYXRlcyBhIG1vZHVsbyBiXG5leHBvcnQgZnVuY3Rpb24gbW9kKGEsIGIpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhICUgYjtcbiAgICByZXR1cm4gcmVzdWx0ID49IF8wbiA/IHJlc3VsdCA6IGIgKyByZXN1bHQ7XG59XG4vKipcbiAqIEVmZmljaWVudGx5IHJhaXNlIG51bSB0byBwb3dlciBhbmQgZG8gbW9kdWxhciBkaXZpc2lvbi5cbiAqIFVuc2FmZSBpbiBzb21lIGNvbnRleHRzOiB1c2VzIGxhZGRlciwgc28gY2FuIGV4cG9zZSBiaWdpbnQgYml0cy5cbiAqIEBleGFtcGxlXG4gKiBwb3coMm4sIDZuLCAxMW4pIC8vIDY0biAlIDExbiA9PSA5blxuICovXG4vLyBUT0RPOiB1c2UgZmllbGQgdmVyc2lvbiAmJiByZW1vdmVcbmV4cG9ydCBmdW5jdGlvbiBwb3cobnVtLCBwb3dlciwgbW9kdWxvKSB7XG4gICAgaWYgKG1vZHVsbyA8PSBfMG4gfHwgcG93ZXIgPCBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcG93ZXIvbW9kdWxvID4gMCcpO1xuICAgIGlmIChtb2R1bG8gPT09IF8xbilcbiAgICAgICAgcmV0dXJuIF8wbjtcbiAgICBsZXQgcmVzID0gXzFuO1xuICAgIHdoaWxlIChwb3dlciA+IF8wbikge1xuICAgICAgICBpZiAocG93ZXIgJiBfMW4pXG4gICAgICAgICAgICByZXMgPSAocmVzICogbnVtKSAlIG1vZHVsbztcbiAgICAgICAgbnVtID0gKG51bSAqIG51bSkgJSBtb2R1bG87XG4gICAgICAgIHBvd2VyID4+PSBfMW47XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vLyBEb2VzIHggXiAoMiBeIHBvd2VyKSBtb2QgcC4gcG93MigzMCwgNCkgPT0gMzAgXiAoMiBeIDQpXG5leHBvcnQgZnVuY3Rpb24gcG93Mih4LCBwb3dlciwgbW9kdWxvKSB7XG4gICAgbGV0IHJlcyA9IHg7XG4gICAgd2hpbGUgKHBvd2VyLS0gPiBfMG4pIHtcbiAgICAgICAgcmVzICo9IHJlcztcbiAgICAgICAgcmVzICU9IG1vZHVsbztcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbi8vIEludmVyc2VzIG51bWJlciBvdmVyIG1vZHVsb1xuZXhwb3J0IGZ1bmN0aW9uIGludmVydChudW1iZXIsIG1vZHVsbykge1xuICAgIGlmIChudW1iZXIgPT09IF8wbiB8fCBtb2R1bG8gPD0gXzBuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52ZXJ0OiBleHBlY3RlZCBwb3NpdGl2ZSBpbnRlZ2VycywgZ290IG49JHtudW1iZXJ9IG1vZD0ke21vZHVsb31gKTtcbiAgICB9XG4gICAgLy8gRXVjbGlkZWFuIEdDRCBodHRwczovL2JyaWxsaWFudC5vcmcvd2lraS9leHRlbmRlZC1ldWNsaWRlYW4tYWxnb3JpdGhtL1xuICAgIC8vIEZlcm1hdCdzIGxpdHRsZSB0aGVvcmVtIFwiQ1QtbGlrZVwiIHZlcnNpb24gaW52KG4pID0gbl4obS0yKSBtb2QgbSBpcyAzMHggc2xvd2VyLlxuICAgIGxldCBhID0gbW9kKG51bWJlciwgbW9kdWxvKTtcbiAgICBsZXQgYiA9IG1vZHVsbztcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBsZXQgeCA9IF8wbiwgeSA9IF8xbiwgdSA9IF8xbiwgdiA9IF8wbjtcbiAgICB3aGlsZSAoYSAhPT0gXzBuKSB7XG4gICAgICAgIC8vIEpJVCBhcHBsaWVzIG9wdGltaXphdGlvbiBpZiB0aG9zZSB0d28gbGluZXMgZm9sbG93IGVhY2ggb3RoZXJcbiAgICAgICAgY29uc3QgcSA9IGIgLyBhO1xuICAgICAgICBjb25zdCByID0gYiAlIGE7XG4gICAgICAgIGNvbnN0IG0gPSB4IC0gdSAqIHE7XG4gICAgICAgIGNvbnN0IG4gPSB5IC0gdiAqIHE7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBiID0gYSwgYSA9IHIsIHggPSB1LCB5ID0gdiwgdSA9IG0sIHYgPSBuO1xuICAgIH1cbiAgICBjb25zdCBnY2QgPSBiO1xuICAgIGlmIChnY2QgIT09IF8xbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZlcnQ6IGRvZXMgbm90IGV4aXN0Jyk7XG4gICAgcmV0dXJuIG1vZCh4LCBtb2R1bG8pO1xufVxuLyoqXG4gKiBUb25lbGxpLVNoYW5rcyBzcXVhcmUgcm9vdCBzZWFyY2ggYWxnb3JpdGhtLlxuICogMS4gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxMi82ODUucGRmIChwYWdlIDEyKVxuICogMi4gU3F1YXJlIFJvb3RzIGZyb20gMTsgMjQsIDUxLCAxMCB0byBEYW4gU2hhbmtzXG4gKiBXaWxsIHN0YXJ0IGFuIGluZmluaXRlIGxvb3AgaWYgZmllbGQgb3JkZXIgUCBpcyBub3QgcHJpbWUuXG4gKiBAcGFyYW0gUCBmaWVsZCBvcmRlclxuICogQHJldHVybnMgZnVuY3Rpb24gdGhhdCB0YWtlcyBmaWVsZCBGcCAoY3JlYXRlZCBmcm9tIFApIGFuZCBudW1iZXIgblxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9uZWxsaVNoYW5rcyhQKSB7XG4gICAgLy8gTGVnZW5kcmUgY29uc3RhbnQ6IHVzZWQgdG8gY2FsY3VsYXRlIExlZ2VuZHJlIHN5bWJvbCAoYSB8IHApLFxuICAgIC8vIHdoaWNoIGRlbm90ZXMgdGhlIHZhbHVlIG9mIGFeKChwLTEpLzIpIChtb2QgcCkuXG4gICAgLy8gKGEgfCBwKSDiiaEgMSAgICBpZiBhIGlzIGEgc3F1YXJlIChtb2QgcClcbiAgICAvLyAoYSB8IHApIOKJoSAtMSAgIGlmIGEgaXMgbm90IGEgc3F1YXJlIChtb2QgcClcbiAgICAvLyAoYSB8IHApIOKJoSAwICAgIGlmIGEg4omhIDAgKG1vZCBwKVxuICAgIGNvbnN0IGxlZ2VuZHJlQyA9IChQIC0gXzFuKSAvIF8ybjtcbiAgICBsZXQgUSwgUywgWjtcbiAgICAvLyBTdGVwIDE6IEJ5IGZhY3RvcmluZyBvdXQgcG93ZXJzIG9mIDIgZnJvbSBwIC0gMSxcbiAgICAvLyBmaW5kIHEgYW5kIHMgc3VjaCB0aGF0IHAgLSAxID0gcSooMl5zKSB3aXRoIHEgb2RkXG4gICAgZm9yIChRID0gUCAtIF8xbiwgUyA9IDA7IFEgJSBfMm4gPT09IF8wbjsgUSAvPSBfMm4sIFMrKylcbiAgICAgICAgO1xuICAgIC8vIFN0ZXAgMjogU2VsZWN0IGEgbm9uLXNxdWFyZSB6IHN1Y2ggdGhhdCAoeiB8IHApIOKJoSAtMSBhbmQgc2V0IGMg4omhIHpxXG4gICAgZm9yIChaID0gXzJuOyBaIDwgUCAmJiBwb3coWiwgbGVnZW5kcmVDLCBQKSAhPT0gUCAtIF8xbjsgWisrKVxuICAgICAgICA7XG4gICAgLy8gRmFzdC1wYXRoXG4gICAgaWYgKFMgPT09IDEpIHtcbiAgICAgICAgY29uc3QgcDFkaXY0ID0gKFAgKyBfMW4pIC8gXzRuO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gdG9uZWxsaUZhc3QoRnAsIG4pIHtcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSBGcC5wb3cobiwgcDFkaXY0KTtcbiAgICAgICAgICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgbikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIFNsb3ctcGF0aFxuICAgIGNvbnN0IFExZGl2MiA9IChRICsgXzFuKSAvIF8ybjtcbiAgICByZXR1cm4gZnVuY3Rpb24gdG9uZWxsaVNsb3coRnAsIG4pIHtcbiAgICAgICAgLy8gU3RlcCAwOiBDaGVjayB0aGF0IG4gaXMgaW5kZWVkIGEgc3F1YXJlOiAobiB8IHApIHNob3VsZCBub3QgYmUg4omhIC0xXG4gICAgICAgIGlmIChGcC5wb3cobiwgbGVnZW5kcmVDKSA9PT0gRnAubmVnKEZwLk9ORSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgIGxldCByID0gUztcbiAgICAgICAgLy8gVE9ETzogd2lsbCBmYWlsIGF0IEZwMi9ldGNcbiAgICAgICAgbGV0IGcgPSBGcC5wb3coRnAubXVsKEZwLk9ORSwgWiksIFEpOyAvLyB3aWxsIHVwZGF0ZSBib3RoIHggYW5kIGJcbiAgICAgICAgbGV0IHggPSBGcC5wb3cobiwgUTFkaXYyKTsgLy8gZmlyc3QgZ3Vlc3MgYXQgdGhlIHNxdWFyZSByb290XG4gICAgICAgIGxldCBiID0gRnAucG93KG4sIFEpOyAvLyBmaXJzdCBndWVzcyBhdCB0aGUgZnVkZ2UgZmFjdG9yXG4gICAgICAgIHdoaWxlICghRnAuZXFsKGIsIEZwLk9ORSkpIHtcbiAgICAgICAgICAgIGlmIChGcC5lcWwoYiwgRnAuWkVSTykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIEZwLlpFUk87IC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RvbmVsbGklRTIlODAlOTNTaGFua3NfYWxnb3JpdGhtICg0LiBJZiB0ID0gMCwgcmV0dXJuIHIgPSAwKVxuICAgICAgICAgICAgLy8gRmluZCBtIHN1Y2ggYl4oMl5tKT09MVxuICAgICAgICAgICAgbGV0IG0gPSAxO1xuICAgICAgICAgICAgZm9yIChsZXQgdDIgPSBGcC5zcXIoYik7IG0gPCByOyBtKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoRnAuZXFsKHQyLCBGcC5PTkUpKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB0MiA9IEZwLnNxcih0Mik7IC8vIHQyICo9IHQyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOT1RFOiByLW0tMSBjYW4gYmUgYmlnZ2VyIHRoYW4gMzIsIG5lZWQgdG8gY29udmVydCB0byBiaWdpbnQgYmVmb3JlIHNoaWZ0LCBvdGhlcndpc2UgdGhlcmUgd2lsbCBiZSBvdmVyZmxvd1xuICAgICAgICAgICAgY29uc3QgZ2UgPSBGcC5wb3coZywgXzFuIDw8IEJpZ0ludChyIC0gbSAtIDEpKTsgLy8gZ2UgPSAyXihyLW0tMSlcbiAgICAgICAgICAgIGcgPSBGcC5zcXIoZ2UpOyAvLyBnID0gZ2UgKiBnZVxuICAgICAgICAgICAgeCA9IEZwLm11bCh4LCBnZSk7IC8vIHggKj0gZ2VcbiAgICAgICAgICAgIGIgPSBGcC5tdWwoYiwgZyk7IC8vIGIgKj0gZ1xuICAgICAgICAgICAgciA9IG07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBGcFNxcnQoUCkge1xuICAgIC8vIE5PVEU6IGRpZmZlcmVudCBhbGdvcml0aG1zIGNhbiBnaXZlIGRpZmZlcmVudCByb290cywgaXQgaXMgdXAgdG8gdXNlciB0byBkZWNpZGUgd2hpY2ggb25lIHRoZXkgd2FudC5cbiAgICAvLyBGb3IgZXhhbXBsZSB0aGVyZSBpcyBGcFNxcnRPZGQvRnBTcXJ0RXZlbiB0byBjaG9pY2Ugcm9vdCBiYXNlZCBvbiBvZGRuZXNzICh1c2VkIGZvciBoYXNoLXRvLWN1cnZlKS5cbiAgICAvLyBQIOKJoSAzIChtb2QgNClcbiAgICAvLyDiiJpuID0gbl4oKFArMSkvNClcbiAgICBpZiAoUCAlIF80biA9PT0gXzNuKSB7XG4gICAgICAgIC8vIE5vdCBhbGwgcm9vdHMgcG9zc2libGUhXG4gICAgICAgIC8vIGNvbnN0IE9SREVSID1cbiAgICAgICAgLy8gICAweDFhMDExMWVhMzk3ZmU2OWE0YjFiYTdiNjQzNGJhY2Q3NjQ3NzRiODRmMzg1MTJiZjY3MzBkMmEwZjZiMGY2MjQxZWFiZmZmZWIxNTNmZmZmYjlmZWZmZmZmZmZmYWFhYm47XG4gICAgICAgIC8vIGNvbnN0IE5VTSA9IDcyMDU3NTk0MDM3OTI3ODE2bjtcbiAgICAgICAgY29uc3QgcDFkaXY0ID0gKFAgKyBfMW4pIC8gXzRuO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gc3FydDNtb2Q0KEZwLCBuKSB7XG4gICAgICAgICAgICBjb25zdCByb290ID0gRnAucG93KG4sIHAxZGl2NCk7XG4gICAgICAgICAgICAvLyBUaHJvdyBpZiByb290KioyICE9IG5cbiAgICAgICAgICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgbikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIEF0a2luIGFsZ29yaXRobSBmb3IgcSDiiaEgNSAobW9kIDgpLCBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDEyLzY4NS5wZGYgKHBhZ2UgMTApXG4gICAgaWYgKFAgJSBfOG4gPT09IF81bikge1xuICAgICAgICBjb25zdCBjMSA9IChQIC0gXzVuKSAvIF84bjtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNxcnQ1bW9kOChGcCwgbikge1xuICAgICAgICAgICAgY29uc3QgbjIgPSBGcC5tdWwobiwgXzJuKTtcbiAgICAgICAgICAgIGNvbnN0IHYgPSBGcC5wb3cobjIsIGMxKTtcbiAgICAgICAgICAgIGNvbnN0IG52ID0gRnAubXVsKG4sIHYpO1xuICAgICAgICAgICAgY29uc3QgaSA9IEZwLm11bChGcC5tdWwobnYsIF8ybiksIHYpO1xuICAgICAgICAgICAgY29uc3Qgcm9vdCA9IEZwLm11bChudiwgRnAuc3ViKGksIEZwLk9ORSkpO1xuICAgICAgICAgICAgaWYgKCFGcC5lcWwoRnAuc3FyKHJvb3QpLCBuKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gUCDiiaEgOSAobW9kIDE2KVxuICAgIGlmIChQICUgXzE2biA9PT0gXzluKSB7XG4gICAgICAgIC8vIE5PVEU6IHRvbmVsbGkgaXMgdG9vIHNsb3cgZm9yIGJscy1GcDIgY2FsY3VsYXRpb25zIGV2ZW4gb24gc3RhcnRcbiAgICAgICAgLy8gTWVhbnMgd2UgY2Fubm90IHVzZSBzcXJ0IGZvciBjb25zdGFudHMgYXQgYWxsIVxuICAgICAgICAvL1xuICAgICAgICAvLyBjb25zdCBjMSA9IEZwLnNxcnQoRnAubmVnYXRlKEZwLk9ORSkpOyAvLyAgMS4gYzEgPSBzcXJ0KC0xKSBpbiBGLCBpLmUuLCAoYzFeMikgPT0gLTEgaW4gRlxuICAgICAgICAvLyBjb25zdCBjMiA9IEZwLnNxcnQoYzEpOyAgICAgICAgICAgICAgICAvLyAgMi4gYzIgPSBzcXJ0KGMxKSBpbiBGLCBpLmUuLCAoYzJeMikgPT0gYzEgaW4gRlxuICAgICAgICAvLyBjb25zdCBjMyA9IEZwLnNxcnQoRnAubmVnYXRlKGMxKSk7ICAgICAvLyAgMy4gYzMgPSBzcXJ0KC1jMSkgaW4gRiwgaS5lLiwgKGMzXjIpID09IC1jMSBpbiBGXG4gICAgICAgIC8vIGNvbnN0IGM0ID0gKFAgKyBfN24pIC8gXzE2bjsgICAgICAgICAgIC8vICA0LiBjNCA9IChxICsgNykgLyAxNiAgICAgICAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcbiAgICAgICAgLy8gc3FydCA9ICh4KSA9PiB7XG4gICAgICAgIC8vICAgbGV0IHR2MSA9IEZwLnBvdyh4LCBjNCk7ICAgICAgICAgICAgIC8vICAxLiB0djEgPSB4XmM0XG4gICAgICAgIC8vICAgbGV0IHR2MiA9IEZwLm11bChjMSwgdHYxKTsgICAgICAgICAgIC8vICAyLiB0djIgPSBjMSAqIHR2MVxuICAgICAgICAvLyAgIGNvbnN0IHR2MyA9IEZwLm11bChjMiwgdHYxKTsgICAgICAgICAvLyAgMy4gdHYzID0gYzIgKiB0djFcbiAgICAgICAgLy8gICBsZXQgdHY0ID0gRnAubXVsKGMzLCB0djEpOyAgICAgICAgICAgLy8gIDQuIHR2NCA9IGMzICogdHYxXG4gICAgICAgIC8vICAgY29uc3QgZTEgPSBGcC5lcXVhbHMoRnAuc3F1YXJlKHR2MiksIHgpOyAvLyAgNS4gIGUxID0gKHR2Ml4yKSA9PSB4XG4gICAgICAgIC8vICAgY29uc3QgZTIgPSBGcC5lcXVhbHMoRnAuc3F1YXJlKHR2MyksIHgpOyAvLyAgNi4gIGUyID0gKHR2M14yKSA9PSB4XG4gICAgICAgIC8vICAgdHYxID0gRnAuY21vdih0djEsIHR2MiwgZTEpOyAvLyAgNy4gdHYxID0gQ01PVih0djEsIHR2MiwgZTEpICAjIFNlbGVjdCB0djIgaWYgKHR2Ml4yKSA9PSB4XG4gICAgICAgIC8vICAgdHYyID0gRnAuY21vdih0djQsIHR2MywgZTIpOyAvLyAgOC4gdHYyID0gQ01PVih0djQsIHR2MywgZTIpICAjIFNlbGVjdCB0djMgaWYgKHR2M14yKSA9PSB4XG4gICAgICAgIC8vICAgY29uc3QgZTMgPSBGcC5lcXVhbHMoRnAuc3F1YXJlKHR2MiksIHgpOyAvLyAgOS4gIGUzID0gKHR2Ml4yKSA9PSB4XG4gICAgICAgIC8vICAgcmV0dXJuIEZwLmNtb3YodHYxLCB0djIsIGUzKTsgLy8gIDEwLiAgeiA9IENNT1YodHYxLCB0djIsIGUzKSAgIyBTZWxlY3QgdGhlIHNxcnQgZnJvbSB0djEgYW5kIHR2MlxuICAgICAgICAvLyB9XG4gICAgfVxuICAgIC8vIE90aGVyIGNhc2VzOiBUb25lbGxpLVNoYW5rcyBhbGdvcml0aG1cbiAgICByZXR1cm4gdG9uZWxsaVNoYW5rcyhQKTtcbn1cbi8vIExpdHRsZS1lbmRpYW4gY2hlY2sgZm9yIGZpcnN0IExFIGJpdCAobGFzdCBCRSBiaXQpO1xuZXhwb3J0IGNvbnN0IGlzTmVnYXRpdmVMRSA9IChudW0sIG1vZHVsbykgPT4gKG1vZChudW0sIG1vZHVsbykgJiBfMW4pID09PSBfMW47XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IEZJRUxEX0ZJRUxEUyA9IFtcbiAgICAnY3JlYXRlJywgJ2lzVmFsaWQnLCAnaXMwJywgJ25lZycsICdpbnYnLCAnc3FydCcsICdzcXInLFxuICAgICdlcWwnLCAnYWRkJywgJ3N1YicsICdtdWwnLCAncG93JywgJ2RpdicsXG4gICAgJ2FkZE4nLCAnc3ViTicsICdtdWxOJywgJ3Nxck4nXG5dO1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlRmllbGQoZmllbGQpIHtcbiAgICBjb25zdCBpbml0aWFsID0ge1xuICAgICAgICBPUkRFUjogJ2JpZ2ludCcsXG4gICAgICAgIE1BU0s6ICdiaWdpbnQnLFxuICAgICAgICBCWVRFUzogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBCSVRTOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgfTtcbiAgICBjb25zdCBvcHRzID0gRklFTERfRklFTERTLnJlZHVjZSgobWFwLCB2YWwpID0+IHtcbiAgICAgICAgbWFwW3ZhbF0gPSAnZnVuY3Rpb24nO1xuICAgICAgICByZXR1cm4gbWFwO1xuICAgIH0sIGluaXRpYWwpO1xuICAgIHJldHVybiB2YWxpZGF0ZU9iamVjdChmaWVsZCwgb3B0cyk7XG59XG4vLyBHZW5lcmljIGZpZWxkIGZ1bmN0aW9uc1xuLyoqXG4gKiBTYW1lIGFzIGBwb3dgIGJ1dCBmb3IgRnA6IG5vbi1jb25zdGFudC10aW1lLlxuICogVW5zYWZlIGluIHNvbWUgY29udGV4dHM6IHVzZXMgbGFkZGVyLCBzbyBjYW4gZXhwb3NlIGJpZ2ludCBiaXRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gRnBQb3coZiwgbnVtLCBwb3dlcikge1xuICAgIC8vIFNob3VsZCBoYXZlIHNhbWUgc3BlZWQgYXMgcG93IGZvciBiaWdpbnRzXG4gICAgLy8gVE9ETzogYmVuY2htYXJrIVxuICAgIGlmIChwb3dlciA8IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBwb3dlciA+IDAnKTtcbiAgICBpZiAocG93ZXIgPT09IF8wbilcbiAgICAgICAgcmV0dXJuIGYuT05FO1xuICAgIGlmIChwb3dlciA9PT0gXzFuKVxuICAgICAgICByZXR1cm4gbnVtO1xuICAgIGxldCBwID0gZi5PTkU7XG4gICAgbGV0IGQgPSBudW07XG4gICAgd2hpbGUgKHBvd2VyID4gXzBuKSB7XG4gICAgICAgIGlmIChwb3dlciAmIF8xbilcbiAgICAgICAgICAgIHAgPSBmLm11bChwLCBkKTtcbiAgICAgICAgZCA9IGYuc3FyKGQpO1xuICAgICAgICBwb3dlciA+Pj0gXzFuO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbn1cbi8qKlxuICogRWZmaWNpZW50bHkgaW52ZXJ0IGFuIGFycmF5IG9mIEZpZWxkIGVsZW1lbnRzLlxuICogYGludigwKWAgd2lsbCByZXR1cm4gYHVuZGVmaW5lZGAgaGVyZTogbWFrZSBzdXJlIHRvIHRocm93IGFuIGVycm9yLlxuICovXG5leHBvcnQgZnVuY3Rpb24gRnBJbnZlcnRCYXRjaChmLCBudW1zKSB7XG4gICAgY29uc3QgdG1wID0gbmV3IEFycmF5KG51bXMubGVuZ3RoKTtcbiAgICAvLyBXYWxrIGZyb20gZmlyc3QgdG8gbGFzdCwgbXVsdGlwbHkgdGhlbSBieSBlYWNoIG90aGVyIE1PRCBwXG4gICAgY29uc3QgbGFzdE11bHRpcGxpZWQgPSBudW1zLnJlZHVjZSgoYWNjLCBudW0sIGkpID0+IHtcbiAgICAgICAgaWYgKGYuaXMwKG51bSkpXG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB0bXBbaV0gPSBhY2M7XG4gICAgICAgIHJldHVybiBmLm11bChhY2MsIG51bSk7XG4gICAgfSwgZi5PTkUpO1xuICAgIC8vIEludmVydCBsYXN0IGVsZW1lbnRcbiAgICBjb25zdCBpbnZlcnRlZCA9IGYuaW52KGxhc3RNdWx0aXBsaWVkKTtcbiAgICAvLyBXYWxrIGZyb20gbGFzdCB0byBmaXJzdCwgbXVsdGlwbHkgdGhlbSBieSBpbnZlcnRlZCBlYWNoIG90aGVyIE1PRCBwXG4gICAgbnVtcy5yZWR1Y2VSaWdodCgoYWNjLCBudW0sIGkpID0+IHtcbiAgICAgICAgaWYgKGYuaXMwKG51bSkpXG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB0bXBbaV0gPSBmLm11bChhY2MsIHRtcFtpXSk7XG4gICAgICAgIHJldHVybiBmLm11bChhY2MsIG51bSk7XG4gICAgfSwgaW52ZXJ0ZWQpO1xuICAgIHJldHVybiB0bXA7XG59XG5leHBvcnQgZnVuY3Rpb24gRnBEaXYoZiwgbGhzLCByaHMpIHtcbiAgICByZXR1cm4gZi5tdWwobGhzLCB0eXBlb2YgcmhzID09PSAnYmlnaW50JyA/IGludmVydChyaHMsIGYuT1JERVIpIDogZi5pbnYocmhzKSk7XG59XG4vLyBUaGlzIGZ1bmN0aW9uIHJldHVybnMgVHJ1ZSB3aGVuZXZlciB0aGUgdmFsdWUgeCBpcyBhIHNxdWFyZSBpbiB0aGUgZmllbGQgRi5cbmV4cG9ydCBmdW5jdGlvbiBGcElzU3F1YXJlKGYpIHtcbiAgICBjb25zdCBsZWdlbmRyZUNvbnN0ID0gKGYuT1JERVIgLSBfMW4pIC8gXzJuOyAvLyBJbnRlZ2VyIGFyaXRobWV0aWNcbiAgICByZXR1cm4gKHgpID0+IHtcbiAgICAgICAgY29uc3QgcCA9IGYucG93KHgsIGxlZ2VuZHJlQ29uc3QpO1xuICAgICAgICByZXR1cm4gZi5lcWwocCwgZi5aRVJPKSB8fCBmLmVxbChwLCBmLk9ORSk7XG4gICAgfTtcbn1cbi8vIENVUlZFLm4gbGVuZ3Roc1xuZXhwb3J0IGZ1bmN0aW9uIG5MZW5ndGgobiwgbkJpdExlbmd0aCkge1xuICAgIC8vIEJpdCBzaXplLCBieXRlIHNpemUgb2YgQ1VSVkUublxuICAgIGNvbnN0IF9uQml0TGVuZ3RoID0gbkJpdExlbmd0aCAhPT0gdW5kZWZpbmVkID8gbkJpdExlbmd0aCA6IG4udG9TdHJpbmcoMikubGVuZ3RoO1xuICAgIGNvbnN0IG5CeXRlTGVuZ3RoID0gTWF0aC5jZWlsKF9uQml0TGVuZ3RoIC8gOCk7XG4gICAgcmV0dXJuIHsgbkJpdExlbmd0aDogX25CaXRMZW5ndGgsIG5CeXRlTGVuZ3RoIH07XG59XG4vKipcbiAqIEluaXRpYWxpemVzIGEgZmluaXRlIGZpZWxkIG92ZXIgcHJpbWUuICoqTm9uLXByaW1lcyBhcmUgbm90IHN1cHBvcnRlZC4qKlxuICogRG8gbm90IGluaXQgaW4gbG9vcDogc2xvdy4gVmVyeSBmcmFnaWxlOiBhbHdheXMgcnVuIGEgYmVuY2htYXJrIG9uIGEgY2hhbmdlLlxuICogTWFqb3IgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uczpcbiAqICogYSkgZGVub3JtYWxpemVkIG9wZXJhdGlvbnMgbGlrZSBtdWxOIGluc3RlYWQgb2YgbXVsXG4gKiAqIGIpIHNhbWUgb2JqZWN0IHNoYXBlOiBuZXZlciBhZGQgb3IgcmVtb3ZlIGtleXNcbiAqICogYykgT2JqZWN0LmZyZWV6ZVxuICogQHBhcmFtIE9SREVSIHByaW1lIHBvc2l0aXZlIGJpZ2ludFxuICogQHBhcmFtIGJpdExlbiBob3cgbWFueSBiaXRzIHRoZSBmaWVsZCBjb25zdW1lc1xuICogQHBhcmFtIGlzTEUgKGRlZjogZmFsc2UpIGlmIGVuY29kaW5nIC8gZGVjb2Rpbmcgc2hvdWxkIGJlIGluIGxpdHRsZS1lbmRpYW5cbiAqIEBwYXJhbSByZWRlZiBvcHRpb25hbCBmYXN0ZXIgcmVkZWZpbml0aW9ucyBvZiBzcXJ0IGFuZCBvdGhlciBtZXRob2RzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBGaWVsZChPUkRFUiwgYml0TGVuLCBpc0xFID0gZmFsc2UsIHJlZGVmID0ge30pIHtcbiAgICBpZiAoT1JERVIgPD0gXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIEZpZWxkIE9SREVSID4gMCwgZ290ICR7T1JERVJ9YCk7XG4gICAgY29uc3QgeyBuQml0TGVuZ3RoOiBCSVRTLCBuQnl0ZUxlbmd0aDogQllURVMgfSA9IG5MZW5ndGgoT1JERVIsIGJpdExlbik7XG4gICAgaWYgKEJZVEVTID4gMjA0OClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaWVsZCBsZW5ndGhzIG92ZXIgMjA0OCBieXRlcyBhcmUgbm90IHN1cHBvcnRlZCcpO1xuICAgIGNvbnN0IHNxcnRQID0gRnBTcXJ0KE9SREVSKTtcbiAgICBjb25zdCBmID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIE9SREVSLFxuICAgICAgICBCSVRTLFxuICAgICAgICBCWVRFUyxcbiAgICAgICAgTUFTSzogYml0TWFzayhCSVRTKSxcbiAgICAgICAgWkVSTzogXzBuLFxuICAgICAgICBPTkU6IF8xbixcbiAgICAgICAgY3JlYXRlOiAobnVtKSA9PiBtb2QobnVtLCBPUkRFUiksXG4gICAgICAgIGlzVmFsaWQ6IChudW0pID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbnVtICE9PSAnYmlnaW50JylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZmllbGQgZWxlbWVudDogZXhwZWN0ZWQgYmlnaW50LCBnb3QgJHt0eXBlb2YgbnVtfWApO1xuICAgICAgICAgICAgcmV0dXJuIF8wbiA8PSBudW0gJiYgbnVtIDwgT1JERVI7IC8vIDAgaXMgdmFsaWQgZWxlbWVudCwgYnV0IGl0J3Mgbm90IGludmVydGlibGVcbiAgICAgICAgfSxcbiAgICAgICAgaXMwOiAobnVtKSA9PiBudW0gPT09IF8wbixcbiAgICAgICAgaXNPZGQ6IChudW0pID0+IChudW0gJiBfMW4pID09PSBfMW4sXG4gICAgICAgIG5lZzogKG51bSkgPT4gbW9kKC1udW0sIE9SREVSKSxcbiAgICAgICAgZXFsOiAobGhzLCByaHMpID0+IGxocyA9PT0gcmhzLFxuICAgICAgICBzcXI6IChudW0pID0+IG1vZChudW0gKiBudW0sIE9SREVSKSxcbiAgICAgICAgYWRkOiAobGhzLCByaHMpID0+IG1vZChsaHMgKyByaHMsIE9SREVSKSxcbiAgICAgICAgc3ViOiAobGhzLCByaHMpID0+IG1vZChsaHMgLSByaHMsIE9SREVSKSxcbiAgICAgICAgbXVsOiAobGhzLCByaHMpID0+IG1vZChsaHMgKiByaHMsIE9SREVSKSxcbiAgICAgICAgcG93OiAobnVtLCBwb3dlcikgPT4gRnBQb3coZiwgbnVtLCBwb3dlciksXG4gICAgICAgIGRpdjogKGxocywgcmhzKSA9PiBtb2QobGhzICogaW52ZXJ0KHJocywgT1JERVIpLCBPUkRFUiksXG4gICAgICAgIC8vIFNhbWUgYXMgYWJvdmUsIGJ1dCBkb2Vzbid0IG5vcm1hbGl6ZVxuICAgICAgICBzcXJOOiAobnVtKSA9PiBudW0gKiBudW0sXG4gICAgICAgIGFkZE46IChsaHMsIHJocykgPT4gbGhzICsgcmhzLFxuICAgICAgICBzdWJOOiAobGhzLCByaHMpID0+IGxocyAtIHJocyxcbiAgICAgICAgbXVsTjogKGxocywgcmhzKSA9PiBsaHMgKiByaHMsXG4gICAgICAgIGludjogKG51bSkgPT4gaW52ZXJ0KG51bSwgT1JERVIpLFxuICAgICAgICBzcXJ0OiByZWRlZi5zcXJ0IHx8ICgobikgPT4gc3FydFAoZiwgbikpLFxuICAgICAgICBpbnZlcnRCYXRjaDogKGxzdCkgPT4gRnBJbnZlcnRCYXRjaChmLCBsc3QpLFxuICAgICAgICAvLyBUT0RPOiBkbyB3ZSByZWFsbHkgbmVlZCBjb25zdGFudCBjbW92P1xuICAgICAgICAvLyBXZSBkb24ndCBoYXZlIGNvbnN0LXRpbWUgYmlnaW50cyBhbnl3YXksIHNvIHByb2JhYmx5IHdpbGwgYmUgbm90IHZlcnkgdXNlZnVsXG4gICAgICAgIGNtb3Y6IChhLCBiLCBjKSA9PiAoYyA/IGIgOiBhKSxcbiAgICAgICAgdG9CeXRlczogKG51bSkgPT4gKGlzTEUgPyBudW1iZXJUb0J5dGVzTEUobnVtLCBCWVRFUykgOiBudW1iZXJUb0J5dGVzQkUobnVtLCBCWVRFUykpLFxuICAgICAgICBmcm9tQnl0ZXM6IChieXRlcykgPT4ge1xuICAgICAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCAhPT0gQllURVMpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGcC5mcm9tQnl0ZXM6IGV4cGVjdGVkICR7QllURVN9LCBnb3QgJHtieXRlcy5sZW5ndGh9YCk7XG4gICAgICAgICAgICByZXR1cm4gaXNMRSA/IGJ5dGVzVG9OdW1iZXJMRShieXRlcykgOiBieXRlc1RvTnVtYmVyQkUoYnl0ZXMpO1xuICAgICAgICB9LFxuICAgIH0pO1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKGYpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIEZwU3FydE9kZChGcCwgZWxtKSB7XG4gICAgaWYgKCFGcC5pc09kZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGaWVsZCBkb2Vzbid0IGhhdmUgaXNPZGRgKTtcbiAgICBjb25zdCByb290ID0gRnAuc3FydChlbG0pO1xuICAgIHJldHVybiBGcC5pc09kZChyb290KSA/IHJvb3QgOiBGcC5uZWcocm9vdCk7XG59XG5leHBvcnQgZnVuY3Rpb24gRnBTcXJ0RXZlbihGcCwgZWxtKSB7XG4gICAgaWYgKCFGcC5pc09kZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGaWVsZCBkb2Vzbid0IGhhdmUgaXNPZGRgKTtcbiAgICBjb25zdCByb290ID0gRnAuc3FydChlbG0pO1xuICAgIHJldHVybiBGcC5pc09kZChyb290KSA/IEZwLm5lZyhyb290KSA6IHJvb3Q7XG59XG4vKipcbiAqIFwiQ29uc3RhbnQtdGltZVwiIHByaXZhdGUga2V5IGdlbmVyYXRpb24gdXRpbGl0eS5cbiAqIFNhbWUgYXMgbWFwS2V5VG9GaWVsZCwgYnV0IGFjY2VwdHMgbGVzcyBieXRlcyAoNDAgaW5zdGVhZCBvZiA0OCBmb3IgMzItYnl0ZSBmaWVsZCkuXG4gKiBXaGljaCBtYWtlcyBpdCBzbGlnaHRseSBtb3JlIGJpYXNlZCwgbGVzcyBzZWN1cmUuXG4gKiBAZGVwcmVjYXRlZCB1c2UgbWFwS2V5VG9GaWVsZCBpbnN0ZWFkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNoVG9Qcml2YXRlU2NhbGFyKGhhc2gsIGdyb3VwT3JkZXIsIGlzTEUgPSBmYWxzZSkge1xuICAgIGhhc2ggPSBlbnN1cmVCeXRlcygncHJpdmF0ZUhhc2gnLCBoYXNoKTtcbiAgICBjb25zdCBoYXNoTGVuID0gaGFzaC5sZW5ndGg7XG4gICAgY29uc3QgbWluTGVuID0gbkxlbmd0aChncm91cE9yZGVyKS5uQnl0ZUxlbmd0aCArIDg7XG4gICAgaWYgKG1pbkxlbiA8IDI0IHx8IGhhc2hMZW4gPCBtaW5MZW4gfHwgaGFzaExlbiA+IDEwMjQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaGFzaFRvUHJpdmF0ZVNjYWxhcjogZXhwZWN0ZWQgJHttaW5MZW59LTEwMjQgYnl0ZXMgb2YgaW5wdXQsIGdvdCAke2hhc2hMZW59YCk7XG4gICAgY29uc3QgbnVtID0gaXNMRSA/IGJ5dGVzVG9OdW1iZXJMRShoYXNoKSA6IGJ5dGVzVG9OdW1iZXJCRShoYXNoKTtcbiAgICByZXR1cm4gbW9kKG51bSwgZ3JvdXBPcmRlciAtIF8xbikgKyBfMW47XG59XG4vKipcbiAqIFJldHVybnMgdG90YWwgbnVtYmVyIG9mIGJ5dGVzIGNvbnN1bWVkIGJ5IHRoZSBmaWVsZCBlbGVtZW50LlxuICogRm9yIGV4YW1wbGUsIDMyIGJ5dGVzIGZvciB1c3VhbCAyNTYtYml0IHdlaWVyc3RyYXNzIGN1cnZlLlxuICogQHBhcmFtIGZpZWxkT3JkZXIgbnVtYmVyIG9mIGZpZWxkIGVsZW1lbnRzLCB1c3VhbGx5IENVUlZFLm5cbiAqIEByZXR1cm5zIGJ5dGUgbGVuZ3RoIG9mIGZpZWxkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRGaWVsZEJ5dGVzTGVuZ3RoKGZpZWxkT3JkZXIpIHtcbiAgICBpZiAodHlwZW9mIGZpZWxkT3JkZXIgIT09ICdiaWdpbnQnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpZWxkIG9yZGVyIG11c3QgYmUgYmlnaW50Jyk7XG4gICAgY29uc3QgYml0TGVuZ3RoID0gZmllbGRPcmRlci50b1N0cmluZygyKS5sZW5ndGg7XG4gICAgcmV0dXJuIE1hdGguY2VpbChiaXRMZW5ndGggLyA4KTtcbn1cbi8qKlxuICogUmV0dXJucyBtaW5pbWFsIGFtb3VudCBvZiBieXRlcyB0aGF0IGNhbiBiZSBzYWZlbHkgcmVkdWNlZFxuICogYnkgZmllbGQgb3JkZXIuXG4gKiBTaG91bGQgYmUgMl4tMTI4IGZvciAxMjgtYml0IGN1cnZlIHN1Y2ggYXMgUDI1Ni5cbiAqIEBwYXJhbSBmaWVsZE9yZGVyIG51bWJlciBvZiBmaWVsZCBlbGVtZW50cywgdXN1YWxseSBDVVJWRS5uXG4gKiBAcmV0dXJucyBieXRlIGxlbmd0aCBvZiB0YXJnZXQgaGFzaFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWluSGFzaExlbmd0aChmaWVsZE9yZGVyKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gZ2V0RmllbGRCeXRlc0xlbmd0aChmaWVsZE9yZGVyKTtcbiAgICByZXR1cm4gbGVuZ3RoICsgTWF0aC5jZWlsKGxlbmd0aCAvIDIpO1xufVxuLyoqXG4gKiBcIkNvbnN0YW50LXRpbWVcIiBwcml2YXRlIGtleSBnZW5lcmF0aW9uIHV0aWxpdHkuXG4gKiBDYW4gdGFrZSAobiArIG4vMikgb3IgbW9yZSBieXRlcyBvZiB1bmlmb3JtIGlucHV0IGUuZy4gZnJvbSBDU1BSTkcgb3IgS0RGXG4gKiBhbmQgY29udmVydCB0aGVtIGludG8gcHJpdmF0ZSBzY2FsYXIsIHdpdGggdGhlIG1vZHVsbyBiaWFzIGJlaW5nIG5lZ2xpZ2libGUuXG4gKiBOZWVkcyBhdCBsZWFzdCA0OCBieXRlcyBvZiBpbnB1dCBmb3IgMzItYnl0ZSBwcml2YXRlIGtleS5cbiAqIGh0dHBzOi8vcmVzZWFyY2gua3VkZWxza2lzZWN1cml0eS5jb20vMjAyMC8wNy8yOC90aGUtZGVmaW5pdGl2ZS1ndWlkZS10by1tb2R1bG8tYmlhcy1hbmQtaG93LXRvLWF2b2lkLWl0L1xuICogRklQUyAxODYtNSwgQS4yIGh0dHBzOi8vY3NyYy5uaXN0Lmdvdi9wdWJsaWNhdGlvbnMvZGV0YWlsL2ZpcHMvMTg2LzUvZmluYWxcbiAqIFJGQyA5MzgwLCBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTVcbiAqIEBwYXJhbSBoYXNoIGhhc2ggb3V0cHV0IGZyb20gU0hBMyBvciBhIHNpbWlsYXIgZnVuY3Rpb25cbiAqIEBwYXJhbSBncm91cE9yZGVyIHNpemUgb2Ygc3ViZ3JvdXAgLSAoZS5nLiBzZWNwMjU2azEuQ1VSVkUubilcbiAqIEBwYXJhbSBpc0xFIGludGVycHJldCBoYXNoIGJ5dGVzIGFzIExFIG51bVxuICogQHJldHVybnMgdmFsaWQgcHJpdmF0ZSBzY2FsYXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcEhhc2hUb0ZpZWxkKGtleSwgZmllbGRPcmRlciwgaXNMRSA9IGZhbHNlKSB7XG4gICAgY29uc3QgbGVuID0ga2V5Lmxlbmd0aDtcbiAgICBjb25zdCBmaWVsZExlbiA9IGdldEZpZWxkQnl0ZXNMZW5ndGgoZmllbGRPcmRlcik7XG4gICAgY29uc3QgbWluTGVuID0gZ2V0TWluSGFzaExlbmd0aChmaWVsZE9yZGVyKTtcbiAgICAvLyBObyBzbWFsbCBudW1iZXJzOiBuZWVkIHRvIHVuZGVyc3RhbmQgYmlhcyBzdG9yeS4gTm8gaHVnZSBudW1iZXJzOiBlYXNpZXIgdG8gZGV0ZWN0IEpTIHRpbWluZ3MuXG4gICAgaWYgKGxlbiA8IDE2IHx8IGxlbiA8IG1pbkxlbiB8fCBsZW4gPiAxMDI0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkICR7bWluTGVufS0xMDI0IGJ5dGVzIG9mIGlucHV0LCBnb3QgJHtsZW59YCk7XG4gICAgY29uc3QgbnVtID0gaXNMRSA/IGJ5dGVzVG9OdW1iZXJCRShrZXkpIDogYnl0ZXNUb051bWJlckxFKGtleSk7XG4gICAgLy8gYG1vZCh4LCAxMSlgIGNhbiBzb21ldGltZXMgcHJvZHVjZSAwLiBgbW9kKHgsIDEwKSArIDFgIGlzIHRoZSBzYW1lLCBidXQgbm8gMFxuICAgIGNvbnN0IHJlZHVjZWQgPSBtb2QobnVtLCBmaWVsZE9yZGVyIC0gXzFuKSArIF8xbjtcbiAgICByZXR1cm4gaXNMRSA/IG51bWJlclRvQnl0ZXNMRShyZWR1Y2VkLCBmaWVsZExlbikgOiBudW1iZXJUb0J5dGVzQkUocmVkdWNlZCwgZmllbGRMZW4pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxhci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/api-key-stamper/node_modules/@noble/curves/esm/abstract/modular.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/api-key-stamper/node_modules/@noble/curves/esm/abstract/utils.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@turnkey/api-key-stamper/node_modules/@noble/curves/esm/abstract/utils.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   abytes: () => (/* binding */ abytes),\n/* harmony export */   bitGet: () => (/* binding */ bitGet),\n/* harmony export */   bitLen: () => (/* binding */ bitLen),\n/* harmony export */   bitMask: () => (/* binding */ bitMask),\n/* harmony export */   bitSet: () => (/* binding */ bitSet),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   bytesToNumberBE: () => (/* binding */ bytesToNumberBE),\n/* harmony export */   bytesToNumberLE: () => (/* binding */ bytesToNumberLE),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createHmacDrbg: () => (/* binding */ createHmacDrbg),\n/* harmony export */   ensureBytes: () => (/* binding */ ensureBytes),\n/* harmony export */   equalBytes: () => (/* binding */ equalBytes),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   hexToNumber: () => (/* binding */ hexToNumber),\n/* harmony export */   isBytes: () => (/* binding */ isBytes),\n/* harmony export */   numberToBytesBE: () => (/* binding */ numberToBytesBE),\n/* harmony export */   numberToBytesLE: () => (/* binding */ numberToBytesLE),\n/* harmony export */   numberToHexUnpadded: () => (/* binding */ numberToHexUnpadded),\n/* harmony export */   numberToVarBytesBE: () => (/* binding */ numberToVarBytesBE),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   validateObject: () => (/* binding */ validateObject)\n/* harmony export */ });\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\nfunction abytes(item) {\n    if (!isBytes(item))\n        throw new Error('Uint8Array expected');\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    abytes(bytes);\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // Big Endian\n    return BigInt(hex === '' ? '0' : `0x${hex}`);\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9)\n        return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F)\n        return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f)\n        return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction bytesToNumberLE(bytes) {\n    abytes(bytes);\n    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nfunction numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nfunction numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nfunction numberToVarBytesBE(n) {\n    return hexToBytes(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nfunction ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === 'string') {\n        try {\n            res = hexToBytes(hex);\n        }\n        catch (e) {\n            throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`);\n        }\n    }\n    else if (isBytes(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    }\n    else {\n        throw new Error(`${title} must be hex string or Uint8Array`);\n    }\n    const len = res.length;\n    if (typeof expectedLength === 'number' && len !== expectedLength)\n        throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);\n    return res;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// Compares 2 u8a-s in kinda constant time\nfunction equalBytes(a, b) {\n    if (a.length !== b.length)\n        return false;\n    let diff = 0;\n    for (let i = 0; i < a.length; i++)\n        diff |= a[i] ^ b[i];\n    return diff === 0;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */\nfunction bitLen(n) {\n    let len;\n    for (len = 0; n > _0n; n >>= _1n, len += 1)\n        ;\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nfunction bitGet(n, pos) {\n    return (n >> BigInt(pos)) & _1n;\n}\n/**\n * Sets single bit at position.\n */\nfunction bitSet(n, pos, value) {\n    return n | ((value ? _1n : _0n) << BigInt(pos));\n}\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nconst bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;\n// DRBG\nconst u8n = (data) => new Uint8Array(data); // creates Uint8Array\nconst u8fr = (arr) => Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nfunction createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== 'number' || hashLen < 2)\n        throw new Error('hashLen must be a number');\n    if (typeof qByteLen !== 'number' || qByteLen < 2)\n        throw new Error('qByteLen must be a number');\n    if (typeof hmacFn !== 'function')\n        throw new Error('hmacFn must be a function');\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = () => {\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n()) => {\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0)\n            return;\n        k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = () => {\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000)\n            throw new Error('drbg: tried 1000 values');\n        let len = 0;\n        const out = [];\n        while (len < qByteLen) {\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes(...out);\n    };\n    const genUntil = (seed, pred) => {\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while (!(res = pred(gen())))\n            reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val) => typeof val === 'bigint',\n    function: (val) => typeof val === 'function',\n    boolean: (val) => typeof val === 'boolean',\n    string: (val) => typeof val === 'string',\n    stringOrUint8Array: (val) => typeof val === 'string' || isBytes(val),\n    isSafeInteger: (val) => Number.isSafeInteger(val),\n    array: (val) => Array.isArray(val),\n    field: (val, object) => object.Fp.isValid(val),\n    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nfunction validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional) => {\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== 'function')\n            throw new Error(`Invalid validator \"${type}\", expected function`);\n        const val = object[fieldName];\n        if (isOptional && val === undefined)\n            return;\n        if (!checkVal(val, object)) {\n            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))\n        checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))\n        checkField(fieldName, type, true);\n    return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvYXBpLWtleS1zdGFtcGVyL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGFBQWE7QUFDeEQ7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsSUFBSTtBQUM5QztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsU0FBUztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE9BQU8saUNBQWlDLElBQUksWUFBWSxFQUFFO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTyxXQUFXLGdCQUFnQixhQUFhLElBQUk7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsbUJBQW1CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsNERBQTRELFdBQVc7QUFDdkUsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw0QkFBNEI7QUFDbkQ7QUFDTztBQUNQO0FBQ0EsNENBQTRDO0FBQzVDLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0Qiw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDbkQsOERBQThEO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxLQUFLO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGtCQUFrQixHQUFHLEtBQUssR0FBRyxXQUFXLGNBQWMsS0FBSztBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFdBQVcsV0FBVyxZQUFZLElBQUk7QUFDcEQsa0NBQWtDLG9CQUFvQixJQUFJLGFBQWEsR0FBRztBQUMxRTtBQUNBLGtDQUFrQyxVQUFVLElBQUksU0FBUztBQUN6RCxrQ0FBa0Msb0JBQW9CLElBQUksU0FBUztBQUNuRSxrQ0FBa0MsMkJBQTJCO0FBQzdELGtDQUFrQyx3QkFBd0I7QUFDMUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9udXJzZWJsb2MvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvYXBpLWtleS1zdGFtcGVyL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC91dGlscy5qcz82M2VmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIDEwMCBsaW5lcyBvZiBjb2RlIGluIHRoZSBmaWxlIGFyZSBkdXBsaWNhdGVkIGZyb20gbm9ibGUtaGFzaGVzICh1dGlscykuXG4vLyBUaGlzIGlzIE9LOiBgYWJzdHJhY3RgIGRpcmVjdG9yeSBkb2VzIG5vdCB1c2Ugbm9ibGUtaGFzaGVzLlxuLy8gVXNlciBtYXkgb3B0LWluIGludG8gdXNpbmcgZGlmZmVyZW50IGhhc2hpbmcgbGlicmFyeS4gVGhpcyB3YXksIG5vYmxlLWhhc2hlc1xuLy8gd29uJ3QgYmUgaW5jbHVkZWQgaW50byB0aGVpciBidW5kbGUuXG5jb25zdCBfMG4gPSBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSBCaWdJbnQoMSk7XG5jb25zdCBfMm4gPSBCaWdJbnQoMik7XG5leHBvcnQgZnVuY3Rpb24gaXNCeXRlcyhhKSB7XG4gICAgcmV0dXJuIChhIGluc3RhbmNlb2YgVWludDhBcnJheSB8fFxuICAgICAgICAoYSAhPSBudWxsICYmIHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiBhLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdVaW50OEFycmF5JykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFieXRlcyhpdGVtKSB7XG4gICAgaWYgKCFpc0J5dGVzKGl0ZW0pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbn1cbi8vIEFycmF5IHdoZXJlIGluZGV4IDB4ZjAgKDI0MCkgaXMgbWFwcGVkIHRvIHN0cmluZyAnZjAnXG5jb25zdCBoZXhlcyA9IC8qIEBfX1BVUkVfXyAqLyBBcnJheS5mcm9tKHsgbGVuZ3RoOiAyNTYgfSwgKF8sIGkpID0+IGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuLyoqXG4gKiBAZXhhbXBsZSBieXRlc1RvSGV4KFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pKSAvLyAnY2FmZTAxMjMnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvSGV4KGJ5dGVzKSB7XG4gICAgYWJ5dGVzKGJ5dGVzKTtcbiAgICAvLyBwcmUtY2FjaGluZyBpbXByb3ZlcyB0aGUgc3BlZWQgNnhcbiAgICBsZXQgaGV4ID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBoZXggKz0gaGV4ZXNbYnl0ZXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufVxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlclRvSGV4VW5wYWRkZWQobnVtKSB7XG4gICAgY29uc3QgaGV4ID0gbnVtLnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gaGV4Lmxlbmd0aCAmIDEgPyBgMCR7aGV4fWAgOiBoZXg7XG59XG5leHBvcnQgZnVuY3Rpb24gaGV4VG9OdW1iZXIoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgLy8gQmlnIEVuZGlhblxuICAgIHJldHVybiBCaWdJbnQoaGV4ID09PSAnJyA/ICcwJyA6IGAweCR7aGV4fWApO1xufVxuLy8gV2UgdXNlIG9wdGltaXplZCB0ZWNobmlxdWUgdG8gY29udmVydCBoZXggc3RyaW5nIHRvIGJ5dGUgYXJyYXlcbmNvbnN0IGFzY2lpcyA9IHsgXzA6IDQ4LCBfOTogNTcsIF9BOiA2NSwgX0Y6IDcwLCBfYTogOTcsIF9mOiAxMDIgfTtcbmZ1bmN0aW9uIGFzY2lpVG9CYXNlMTYoY2hhcikge1xuICAgIGlmIChjaGFyID49IGFzY2lpcy5fMCAmJiBjaGFyIDw9IGFzY2lpcy5fOSlcbiAgICAgICAgcmV0dXJuIGNoYXIgLSBhc2NpaXMuXzA7XG4gICAgaWYgKGNoYXIgPj0gYXNjaWlzLl9BICYmIGNoYXIgPD0gYXNjaWlzLl9GKVxuICAgICAgICByZXR1cm4gY2hhciAtIChhc2NpaXMuX0EgLSAxMCk7XG4gICAgaWYgKGNoYXIgPj0gYXNjaWlzLl9hICYmIGNoYXIgPD0gYXNjaWlzLl9mKVxuICAgICAgICByZXR1cm4gY2hhciAtIChhc2NpaXMuX2EgLSAxMCk7XG4gICAgcmV0dXJuO1xufVxuLyoqXG4gKiBAZXhhbXBsZSBoZXhUb0J5dGVzKCdjYWZlMDEyMycpIC8vIFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb0J5dGVzKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIGNvbnN0IGhsID0gaGV4Lmxlbmd0aDtcbiAgICBjb25zdCBhbCA9IGhsIC8gMjtcbiAgICBpZiAoaGwgJSAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRlZCBoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgdW5wYWRkZWQgaGV4IG9mIGxlbmd0aCAnICsgaGwpO1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYWwpO1xuICAgIGZvciAobGV0IGFpID0gMCwgaGkgPSAwOyBhaSA8IGFsOyBhaSsrLCBoaSArPSAyKSB7XG4gICAgICAgIGNvbnN0IG4xID0gYXNjaWlUb0Jhc2UxNihoZXguY2hhckNvZGVBdChoaSkpO1xuICAgICAgICBjb25zdCBuMiA9IGFzY2lpVG9CYXNlMTYoaGV4LmNoYXJDb2RlQXQoaGkgKyAxKSk7XG4gICAgICAgIGlmIChuMSA9PT0gdW5kZWZpbmVkIHx8IG4yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYXIgPSBoZXhbaGldICsgaGV4W2hpICsgMV07XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCBub24taGV4IGNoYXJhY3RlciBcIicgKyBjaGFyICsgJ1wiIGF0IGluZGV4ICcgKyBoaSk7XG4gICAgICAgIH1cbiAgICAgICAgYXJyYXlbYWldID0gbjEgKiAxNiArIG4yO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG4vLyBCRTogQmlnIEVuZGlhbiwgTEU6IExpdHRsZSBFbmRpYW5cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvTnVtYmVyQkUoYnl0ZXMpIHtcbiAgICByZXR1cm4gaGV4VG9OdW1iZXIoYnl0ZXNUb0hleChieXRlcykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9OdW1iZXJMRShieXRlcykge1xuICAgIGFieXRlcyhieXRlcyk7XG4gICAgcmV0dXJuIGhleFRvTnVtYmVyKGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKGJ5dGVzKS5yZXZlcnNlKCkpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb0J5dGVzQkUobiwgbGVuKSB7XG4gICAgcmV0dXJuIGhleFRvQnl0ZXMobi50b1N0cmluZygxNikucGFkU3RhcnQobGVuICogMiwgJzAnKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9CeXRlc0xFKG4sIGxlbikge1xuICAgIHJldHVybiBudW1iZXJUb0J5dGVzQkUobiwgbGVuKS5yZXZlcnNlKCk7XG59XG4vLyBVbnBhZGRlZCwgcmFyZWx5IHVzZWRcbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb1ZhckJ5dGVzQkUobikge1xuICAgIHJldHVybiBoZXhUb0J5dGVzKG51bWJlclRvSGV4VW5wYWRkZWQobikpO1xufVxuLyoqXG4gKiBUYWtlcyBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXksIGNvbnZlcnRzIHRvIFVpbnQ4QXJyYXkuXG4gKiBWYWxpZGF0ZXMgb3V0cHV0IGxlbmd0aC5cbiAqIFdpbGwgdGhyb3cgZXJyb3IgZm9yIG90aGVyIHR5cGVzLlxuICogQHBhcmFtIHRpdGxlIGRlc2NyaXB0aXZlIHRpdGxlIGZvciBhbiBlcnJvciBlLmcuICdwcml2YXRlIGtleSdcbiAqIEBwYXJhbSBoZXggaGV4IHN0cmluZyBvciBVaW50OEFycmF5XG4gKiBAcGFyYW0gZXhwZWN0ZWRMZW5ndGggb3B0aW9uYWwsIHdpbGwgY29tcGFyZSB0byByZXN1bHQgYXJyYXkncyBsZW5ndGhcbiAqIEByZXR1cm5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVCeXRlcyh0aXRsZSwgaGV4LCBleHBlY3RlZExlbmd0aCkge1xuICAgIGxldCByZXM7XG4gICAgaWYgKHR5cGVvZiBoZXggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXMgPSBoZXhUb0J5dGVzKGhleCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aXRsZX0gbXVzdCBiZSB2YWxpZCBoZXggc3RyaW5nLCBnb3QgXCIke2hleH1cIi4gQ2F1c2U6ICR7ZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpc0J5dGVzKGhleCkpIHtcbiAgICAgICAgLy8gVWludDhBcnJheS5mcm9tKCkgaW5zdGVhZCBvZiBoYXNoLnNsaWNlKCkgYmVjYXVzZSBub2RlLmpzIEJ1ZmZlclxuICAgICAgICAvLyBpcyBpbnN0YW5jZSBvZiBVaW50OEFycmF5LCBhbmQgaXRzIHNsaWNlKCkgY3JlYXRlcyAqKm11dGFibGUqKiBjb3B5XG4gICAgICAgIHJlcyA9IFVpbnQ4QXJyYXkuZnJvbShoZXgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RpdGxlfSBtdXN0IGJlIGhleCBzdHJpbmcgb3IgVWludDhBcnJheWApO1xuICAgIH1cbiAgICBjb25zdCBsZW4gPSByZXMubGVuZ3RoO1xuICAgIGlmICh0eXBlb2YgZXhwZWN0ZWRMZW5ndGggPT09ICdudW1iZXInICYmIGxlbiAhPT0gZXhwZWN0ZWRMZW5ndGgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aXRsZX0gZXhwZWN0ZWQgJHtleHBlY3RlZExlbmd0aH0gYnl0ZXMsIGdvdCAke2xlbn1gKTtcbiAgICByZXR1cm4gcmVzO1xufVxuLyoqXG4gKiBDb3BpZXMgc2V2ZXJhbCBVaW50OEFycmF5cyBpbnRvIG9uZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5cykge1xuICAgIGxldCBzdW0gPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBhcnJheXNbaV07XG4gICAgICAgIGFieXRlcyhhKTtcbiAgICAgICAgc3VtICs9IGEubGVuZ3RoO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheShzdW0pO1xuICAgIGZvciAobGV0IGkgPSAwLCBwYWQgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBhcnJheXNbaV07XG4gICAgICAgIHJlcy5zZXQoYSwgcGFkKTtcbiAgICAgICAgcGFkICs9IGEubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLy8gQ29tcGFyZXMgMiB1OGEtcyBpbiBraW5kYSBjb25zdGFudCB0aW1lXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxCeXRlcyhhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBkaWZmID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspXG4gICAgICAgIGRpZmYgfD0gYVtpXSBeIGJbaV07XG4gICAgcmV0dXJuIGRpZmYgPT09IDA7XG59XG4vKipcbiAqIEBleGFtcGxlIHV0ZjhUb0J5dGVzKCdhYmMnKSAvLyBuZXcgVWludDhBcnJheShbOTcsIDk4LCA5OV0pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdXRmOFRvQnl0ZXMgZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygc3RyfWApO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSk7IC8vIGh0dHBzOi8vYnVnemlsLmxhLzE2ODE4MDlcbn1cbi8vIEJpdCBvcGVyYXRpb25zXG4vKipcbiAqIENhbGN1bGF0ZXMgYW1vdW50IG9mIGJpdHMgaW4gYSBiaWdpbnQuXG4gKiBTYW1lIGFzIGBuLnRvU3RyaW5nKDIpLmxlbmd0aGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpdExlbihuKSB7XG4gICAgbGV0IGxlbjtcbiAgICBmb3IgKGxlbiA9IDA7IG4gPiBfMG47IG4gPj49IF8xbiwgbGVuICs9IDEpXG4gICAgICAgIDtcbiAgICByZXR1cm4gbGVuO1xufVxuLyoqXG4gKiBHZXRzIHNpbmdsZSBiaXQgYXQgcG9zaXRpb24uXG4gKiBOT1RFOiBmaXJzdCBiaXQgcG9zaXRpb24gaXMgMCAoc2FtZSBhcyBhcnJheXMpXG4gKiBTYW1lIGFzIGAhIStBcnJheS5mcm9tKG4udG9TdHJpbmcoMikpLnJldmVyc2UoKVtwb3NdYFxuICovXG5leHBvcnQgZnVuY3Rpb24gYml0R2V0KG4sIHBvcykge1xuICAgIHJldHVybiAobiA+PiBCaWdJbnQocG9zKSkgJiBfMW47XG59XG4vKipcbiAqIFNldHMgc2luZ2xlIGJpdCBhdCBwb3NpdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpdFNldChuLCBwb3MsIHZhbHVlKSB7XG4gICAgcmV0dXJuIG4gfCAoKHZhbHVlID8gXzFuIDogXzBuKSA8PCBCaWdJbnQocG9zKSk7XG59XG4vKipcbiAqIENhbGN1bGF0ZSBtYXNrIGZvciBOIGJpdHMuIE5vdCB1c2luZyAqKiBvcGVyYXRvciB3aXRoIGJpZ2ludHMgYmVjYXVzZSBvZiBvbGQgZW5naW5lcy5cbiAqIFNhbWUgYXMgQmlnSW50KGAwYiR7QXJyYXkoaSkuZmlsbCgnMScpLmpvaW4oJycpfWApXG4gKi9cbmV4cG9ydCBjb25zdCBiaXRNYXNrID0gKG4pID0+IChfMm4gPDwgQmlnSW50KG4gLSAxKSkgLSBfMW47XG4vLyBEUkJHXG5jb25zdCB1OG4gPSAoZGF0YSkgPT4gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7IC8vIGNyZWF0ZXMgVWludDhBcnJheVxuY29uc3QgdThmciA9IChhcnIpID0+IFVpbnQ4QXJyYXkuZnJvbShhcnIpOyAvLyBhbm90aGVyIHNob3J0Y3V0XG4vKipcbiAqIE1pbmltYWwgSE1BQy1EUkJHIGZyb20gTklTVCA4MDAtOTAgZm9yIFJGQzY5Nzkgc2lncy5cbiAqIEByZXR1cm5zIGZ1bmN0aW9uIHRoYXQgd2lsbCBjYWxsIERSQkcgdW50aWwgMm5kIGFyZyByZXR1cm5zIHNvbWV0aGluZyBtZWFuaW5nZnVsXG4gKiBAZXhhbXBsZVxuICogICBjb25zdCBkcmJnID0gY3JlYXRlSG1hY0RSQkc8S2V5PigzMiwgMzIsIGhtYWMpO1xuICogICBkcmJnKHNlZWQsIGJ5dGVzVG9LZXkpOyAvLyBieXRlc1RvS2V5IG11c3QgcmV0dXJuIEtleSBvciB1bmRlZmluZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUhtYWNEcmJnKGhhc2hMZW4sIHFCeXRlTGVuLCBobWFjRm4pIHtcbiAgICBpZiAodHlwZW9mIGhhc2hMZW4gIT09ICdudW1iZXInIHx8IGhhc2hMZW4gPCAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hhc2hMZW4gbXVzdCBiZSBhIG51bWJlcicpO1xuICAgIGlmICh0eXBlb2YgcUJ5dGVMZW4gIT09ICdudW1iZXInIHx8IHFCeXRlTGVuIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdxQnl0ZUxlbiBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgaWYgKHR5cGVvZiBobWFjRm4gIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaG1hY0ZuIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIC8vIFN0ZXAgQiwgU3RlcCBDOiBzZXQgaGFzaExlbiB0byA4KmNlaWwoaGxlbi84KVxuICAgIGxldCB2ID0gdThuKGhhc2hMZW4pOyAvLyBNaW5pbWFsIG5vbi1mdWxsLXNwZWMgSE1BQy1EUkJHIGZyb20gTklTVCA4MDAtOTAgZm9yIFJGQzY5Nzkgc2lncy5cbiAgICBsZXQgayA9IHU4bihoYXNoTGVuKTsgLy8gU3RlcHMgQiBhbmQgQyBvZiBSRkM2OTc5IDMuMjogc2V0IGhhc2hMZW4sIGluIG91ciBjYXNlIGFsd2F5cyBzYW1lXG4gICAgbGV0IGkgPSAwOyAvLyBJdGVyYXRpb25zIGNvdW50ZXIsIHdpbGwgdGhyb3cgd2hlbiBvdmVyIDEwMDBcbiAgICBjb25zdCByZXNldCA9ICgpID0+IHtcbiAgICAgICAgdi5maWxsKDEpO1xuICAgICAgICBrLmZpbGwoMCk7XG4gICAgICAgIGkgPSAwO1xuICAgIH07XG4gICAgY29uc3QgaCA9ICguLi5iKSA9PiBobWFjRm4oaywgdiwgLi4uYik7IC8vIGhtYWMoaykodiwgLi4udmFsdWVzKVxuICAgIGNvbnN0IHJlc2VlZCA9IChzZWVkID0gdThuKCkpID0+IHtcbiAgICAgICAgLy8gSE1BQy1EUkJHIHJlc2VlZCgpIGZ1bmN0aW9uLiBTdGVwcyBELUdcbiAgICAgICAgayA9IGgodThmcihbMHgwMF0pLCBzZWVkKTsgLy8gayA9IGhtYWMoayB8fCB2IHx8IDB4MDAgfHwgc2VlZClcbiAgICAgICAgdiA9IGgoKTsgLy8gdiA9IGhtYWMoayB8fCB2KVxuICAgICAgICBpZiAoc2VlZC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGsgPSBoKHU4ZnIoWzB4MDFdKSwgc2VlZCk7IC8vIGsgPSBobWFjKGsgfHwgdiB8fCAweDAxIHx8IHNlZWQpXG4gICAgICAgIHYgPSBoKCk7IC8vIHYgPSBobWFjKGsgfHwgdilcbiAgICB9O1xuICAgIGNvbnN0IGdlbiA9ICgpID0+IHtcbiAgICAgICAgLy8gSE1BQy1EUkJHIGdlbmVyYXRlKCkgZnVuY3Rpb25cbiAgICAgICAgaWYgKGkrKyA+PSAxMDAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkcmJnOiB0cmllZCAxMDAwIHZhbHVlcycpO1xuICAgICAgICBsZXQgbGVuID0gMDtcbiAgICAgICAgY29uc3Qgb3V0ID0gW107XG4gICAgICAgIHdoaWxlIChsZW4gPCBxQnl0ZUxlbikge1xuICAgICAgICAgICAgdiA9IGgoKTtcbiAgICAgICAgICAgIGNvbnN0IHNsID0gdi5zbGljZSgpO1xuICAgICAgICAgICAgb3V0LnB1c2goc2wpO1xuICAgICAgICAgICAgbGVuICs9IHYubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25jYXRCeXRlcyguLi5vdXQpO1xuICAgIH07XG4gICAgY29uc3QgZ2VuVW50aWwgPSAoc2VlZCwgcHJlZCkgPT4ge1xuICAgICAgICByZXNldCgpO1xuICAgICAgICByZXNlZWQoc2VlZCk7IC8vIFN0ZXBzIEQtR1xuICAgICAgICBsZXQgcmVzID0gdW5kZWZpbmVkOyAvLyBTdGVwIEg6IGdyaW5kIHVudGlsIGsgaXMgaW4gWzEuLm4tMV1cbiAgICAgICAgd2hpbGUgKCEocmVzID0gcHJlZChnZW4oKSkpKVxuICAgICAgICAgICAgcmVzZWVkKCk7XG4gICAgICAgIHJlc2V0KCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICByZXR1cm4gZ2VuVW50aWw7XG59XG4vLyBWYWxpZGF0aW5nIGN1cnZlcyBhbmQgZmllbGRzXG5jb25zdCB2YWxpZGF0b3JGbnMgPSB7XG4gICAgYmlnaW50OiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnYmlnaW50JyxcbiAgICBmdW5jdGlvbjogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyxcbiAgICBib29sZWFuOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnYm9vbGVhbicsXG4gICAgc3RyaW5nOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyxcbiAgICBzdHJpbmdPclVpbnQ4QXJyYXk6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnIHx8IGlzQnl0ZXModmFsKSxcbiAgICBpc1NhZmVJbnRlZ2VyOiAodmFsKSA9PiBOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWwpLFxuICAgIGFycmF5OiAodmFsKSA9PiBBcnJheS5pc0FycmF5KHZhbCksXG4gICAgZmllbGQ6ICh2YWwsIG9iamVjdCkgPT4gb2JqZWN0LkZwLmlzVmFsaWQodmFsKSxcbiAgICBoYXNoOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nICYmIE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbC5vdXRwdXRMZW4pLFxufTtcbi8vIHR5cGUgUmVjb3JkPEsgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXIgfCBzeW1ib2wsIFQ+ID0geyBbUCBpbiBLXTogVDsgfVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlT2JqZWN0KG9iamVjdCwgdmFsaWRhdG9ycywgb3B0VmFsaWRhdG9ycyA9IHt9KSB7XG4gICAgY29uc3QgY2hlY2tGaWVsZCA9IChmaWVsZE5hbWUsIHR5cGUsIGlzT3B0aW9uYWwpID0+IHtcbiAgICAgICAgY29uc3QgY2hlY2tWYWwgPSB2YWxpZGF0b3JGbnNbdHlwZV07XG4gICAgICAgIGlmICh0eXBlb2YgY2hlY2tWYWwgIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdmFsaWRhdG9yIFwiJHt0eXBlfVwiLCBleHBlY3RlZCBmdW5jdGlvbmApO1xuICAgICAgICBjb25zdCB2YWwgPSBvYmplY3RbZmllbGROYW1lXTtcbiAgICAgICAgaWYgKGlzT3B0aW9uYWwgJiYgdmFsID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICghY2hlY2tWYWwodmFsLCBvYmplY3QpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcGFyYW0gJHtTdHJpbmcoZmllbGROYW1lKX09JHt2YWx9ICgke3R5cGVvZiB2YWx9KSwgZXhwZWN0ZWQgJHt0eXBlfWApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IFtmaWVsZE5hbWUsIHR5cGVdIG9mIE9iamVjdC5lbnRyaWVzKHZhbGlkYXRvcnMpKVxuICAgICAgICBjaGVja0ZpZWxkKGZpZWxkTmFtZSwgdHlwZSwgZmFsc2UpO1xuICAgIGZvciAoY29uc3QgW2ZpZWxkTmFtZSwgdHlwZV0gb2YgT2JqZWN0LmVudHJpZXMob3B0VmFsaWRhdG9ycykpXG4gICAgICAgIGNoZWNrRmllbGQoZmllbGROYW1lLCB0eXBlLCB0cnVlKTtcbiAgICByZXR1cm4gb2JqZWN0O1xufVxuLy8gdmFsaWRhdGUgdHlwZSB0ZXN0c1xuLy8gY29uc3QgbzogeyBhOiBudW1iZXI7IGI6IG51bWJlcjsgYzogbnVtYmVyIH0gPSB7IGE6IDEsIGI6IDUsIGM6IDYgfTtcbi8vIGNvbnN0IHowID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAnaXNTYWZlSW50ZWdlcicgfSwgeyBjOiAnYmlnaW50JyB9KTsgLy8gT2shXG4vLyAvLyBTaG91bGQgZmFpbCB0eXBlLWNoZWNrXG4vLyBjb25zdCB6MSA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ3RtcCcgfSwgeyBjOiAnenonIH0pO1xuLy8gY29uc3QgejIgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICdpc1NhZmVJbnRlZ2VyJyB9LCB7IGM6ICd6eicgfSk7XG4vLyBjb25zdCB6MyA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgdGVzdDogJ2Jvb2xlYW4nLCB6OiAnYnVnJyB9KTtcbi8vIGNvbnN0IHo0ID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAnYm9vbGVhbicsIHo6ICdidWcnIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/api-key-stamper/node_modules/@noble/curves/esm/abstract/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/api-key-stamper/node_modules/@noble/curves/esm/abstract/weierstrass.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@turnkey/api-key-stamper/node_modules/@noble/curves/esm/abstract/weierstrass.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DER: () => (/* binding */ DER),\n/* harmony export */   SWUFpSqrtRatio: () => (/* binding */ SWUFpSqrtRatio),\n/* harmony export */   mapToCurveSimpleSWU: () => (/* binding */ mapToCurveSimpleSWU),\n/* harmony export */   weierstrass: () => (/* binding */ weierstrass),\n/* harmony export */   weierstrassPoints: () => (/* binding */ weierstrassPoints)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/@turnkey/api-key-stamper/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@turnkey/api-key-stamper/node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _curve_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curve.js */ \"(ssr)/./node_modules/@turnkey/api-key-stamper/node_modules/@noble/curves/esm/abstract/curve.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Short Weierstrass curve. The formula is: y² = x³ + ax + b\n\n\n\n\nfunction validatePointOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject(opts, {\n        a: 'field',\n        b: 'field',\n    }, {\n        allowedPrivateKeyLengths: 'array',\n        wrapPrivateKey: 'boolean',\n        isTorsionFree: 'function',\n        clearCofactor: 'function',\n        allowInfinityPoint: 'boolean',\n        fromBytes: 'function',\n        toBytes: 'function',\n    });\n    const { endo, Fp, a } = opts;\n    if (endo) {\n        if (!Fp.eql(a, Fp.ZERO)) {\n            throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');\n        }\n        if (typeof endo !== 'object' ||\n            typeof endo.beta !== 'bigint' ||\n            typeof endo.splitScalar !== 'function') {\n            throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');\n        }\n    }\n    return Object.freeze({ ...opts });\n}\n// ASN.1 DER encoding utilities\nconst { bytesToNumberBE: b2n, hexToBytes: h2b } = _utils_js__WEBPACK_IMPORTED_MODULE_1__;\nconst DER = {\n    // asn.1 DER encoding utils\n    Err: class DERErr extends Error {\n        constructor(m = '') {\n            super(m);\n        }\n    },\n    _parseInt(data) {\n        const { Err: E } = DER;\n        if (data.length < 2 || data[0] !== 0x02)\n            throw new E('Invalid signature integer tag');\n        const len = data[1];\n        const res = data.subarray(2, len + 2);\n        if (!len || res.length !== len)\n            throw new E('Invalid signature integer: wrong length');\n        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n        // since we always use positive integers here. It must always be empty:\n        // - add zero byte if exists\n        // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n        if (res[0] & 0b10000000)\n            throw new E('Invalid signature integer: negative');\n        if (res[0] === 0x00 && !(res[1] & 0b10000000))\n            throw new E('Invalid signature integer: unnecessary leading zero');\n        return { d: b2n(res), l: data.subarray(len + 2) }; // d is data, l is left\n    },\n    toSig(hex) {\n        // parse DER signature\n        const { Err: E } = DER;\n        const data = typeof hex === 'string' ? h2b(hex) : hex;\n        _utils_js__WEBPACK_IMPORTED_MODULE_1__.abytes(data);\n        let l = data.length;\n        if (l < 2 || data[0] != 0x30)\n            throw new E('Invalid signature tag');\n        if (data[1] !== l - 2)\n            throw new E('Invalid signature: incorrect length');\n        const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));\n        const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);\n        if (rBytesLeft.length)\n            throw new E('Invalid signature: left bytes after parsing');\n        return { r, s };\n    },\n    hexFromSig(sig) {\n        // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'\n        const slice = (s) => (Number.parseInt(s[0], 16) & 0b1000 ? '00' + s : s);\n        const h = (num) => {\n            const hex = num.toString(16);\n            return hex.length & 1 ? `0${hex}` : hex;\n        };\n        const s = slice(h(sig.s));\n        const r = slice(h(sig.r));\n        const shl = s.length / 2;\n        const rhl = r.length / 2;\n        const sl = h(shl);\n        const rl = h(rhl);\n        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;\n    },\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nfunction weierstrassPoints(opts) {\n    const CURVE = validatePointOpts(opts);\n    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n    const toBytes = CURVE.toBytes ||\n        ((_c, point, _isCompressed) => {\n            const a = point.toAffine();\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n        });\n    const fromBytes = CURVE.fromBytes ||\n        ((bytes) => {\n            // const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n            return { x, y };\n        });\n    /**\n     * y² = x³ + ax + b: Short weierstrass curve formula\n     * @returns y²\n     */\n    function weierstrassEquation(x) {\n        const { a, b } = CURVE;\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x2 * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n    }\n    // Validate whether the passed curve params are valid.\n    // We check if curve equation works for generator point.\n    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\n    // ProjectivePoint class has not been initialized yet.\n    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))\n        throw new Error('bad generator point: equation left != right');\n    // Valid group elements reside in range 1..n-1\n    function isWithinCurveOrder(num) {\n        return typeof num === 'bigint' && _0n < num && num < CURVE.n;\n    }\n    function assertGE(num) {\n        if (!isWithinCurveOrder(num))\n            throw new Error('Expected valid bigint: 0 < bigint < curve.n');\n    }\n    // Validates if priv key is valid and converts it to bigint.\n    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n    function normPrivateKeyToScalar(key) {\n        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;\n        if (lengths && typeof key !== 'bigint') {\n            if (_utils_js__WEBPACK_IMPORTED_MODULE_1__.isBytes(key))\n                key = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(key);\n            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n            if (typeof key !== 'string' || !lengths.includes(key.length))\n                throw new Error('Invalid key');\n            key = key.padStart(nByteLength * 2, '0');\n        }\n        let num;\n        try {\n            num =\n                typeof key === 'bigint'\n                    ? key\n                    : _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('private key', key, nByteLength));\n        }\n        catch (error) {\n            throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);\n        }\n        if (wrapPrivateKey)\n            num = _modular_js__WEBPACK_IMPORTED_MODULE_2__.mod(num, n); // disabled by default, enabled for BLS\n        assertGE(num); // num in range [1..N-1]\n        return num;\n    }\n    const pointPrecomputes = new Map();\n    function assertPrjPoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('ProjectivePoint expected');\n    }\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z) ∋ (x=x/z, y=y/z)\n     * Default Point works in 2d / affine coordinates: (x, y)\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */\n    class Point {\n        constructor(px, py, pz) {\n            this.px = px;\n            this.py = py;\n            this.pz = pz;\n            if (px == null || !Fp.isValid(px))\n                throw new Error('x required');\n            if (py == null || !Fp.isValid(py))\n                throw new Error('y required');\n            if (pz == null || !Fp.isValid(pz))\n                throw new Error('z required');\n        }\n        // Does not validate if the point is on-curve.\n        // Use fromHex instead, or call assertValidity() later.\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('invalid affine point');\n            if (p instanceof Point)\n                throw new Error('projective point not allowed');\n            const is0 = (i) => Fp.eql(i, Fp.ZERO);\n            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n            if (is0(x) && is0(y))\n                return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         * Takes a bunch of Projective Points but executes only one\n         * inversion on all of them. Inversion is very slow operation,\n         * so this improves performance massively.\n         * Optimization: converts a list of projective points to a list of identical points with Z=1.\n         */\n        static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p) => p.pz));\n            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        /**\n         * Converts hash string or Uint8Array to Point.\n         * @param hex short/long ECDSA hex\n         */\n        static fromHex(hex) {\n            const P = Point.fromAffine(fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('pointHex', hex)));\n            P.assertValidity();\n            return P;\n        }\n        // Multiplies generator point by privateKey.\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            this._WINDOW_SIZE = windowSize;\n            pointPrecomputes.delete(this);\n        }\n        // A point on curve is valid if it conforms to equation.\n        assertValidity() {\n            if (this.is0()) {\n                // (0, 1, 0) aka ZERO is invalid in most contexts.\n                // In BLS, ZERO can be serialized, so we allow it.\n                // (0, 0, 0) is wrong representation of ZERO and is always invalid.\n                if (CURVE.allowInfinityPoint && !Fp.is0(this.py))\n                    return;\n                throw new Error('bad point: ZERO');\n            }\n            // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n            const { x, y } = this.toAffine();\n            // Check if x, y are valid field elements\n            if (!Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('bad point: x or y not FE');\n            const left = Fp.sqr(y); // y²\n            const right = weierstrassEquation(x); // x³ + ax + b\n            if (!Fp.eql(left, right))\n                throw new Error('bad point: equation left != right');\n            if (!this.isTorsionFree())\n                throw new Error('bad point: not in prime-order subgroup');\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (Fp.isOdd)\n                return !Fp.isOdd(y);\n            throw new Error(\"Field doesn't support isOdd\");\n        }\n        /**\n         * Compare one point to another.\n         */\n        equals(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /**\n         * Flips point to one corresponding to (x, -y) in Affine coordinates.\n         */\n        negate() {\n            return new Point(this.px, Fp.neg(this.py), this.pz);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {\n                const toInv = Fp.invertBatch(comp.map((p) => p.pz));\n                return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n            });\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed private key e.g. sig verification, which works over *public* keys.\n         */\n        multiplyUnsafe(n) {\n            const I = Point.ZERO;\n            if (n === _0n)\n                return I;\n            assertGE(n); // Will throw on 0\n            if (n === _1n)\n                return this;\n            const { endo } = CURVE;\n            if (!endo)\n                return wnaf.unsafeLadder(this, n);\n            // Apply endomorphism\n            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n            let k1p = I;\n            let k2p = I;\n            let d = this;\n            while (k1 > _0n || k2 > _0n) {\n                if (k1 & _1n)\n                    k1p = k1p.add(d);\n                if (k2 & _1n)\n                    k2p = k2p.add(d);\n                d = d.double();\n                k1 >>= _1n;\n                k2 >>= _1n;\n            }\n            if (k1neg)\n                k1p = k1p.negate();\n            if (k2neg)\n                k2p = k2p.negate();\n            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n            return k1p.add(k2p);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */\n        multiply(scalar) {\n            assertGE(scalar);\n            let n = scalar;\n            let point, fake; // Fake point is used to const-time mult\n            const { endo } = CURVE;\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n                let { p: k1p, f: f1p } = this.wNAF(k1);\n                let { p: k2p, f: f2p } = this.wNAF(k2);\n                k1p = wnaf.constTimeNegate(k1neg, k1p);\n                k2p = wnaf.constTimeNegate(k2neg, k2p);\n                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n                point = k1p.add(k2p);\n                fake = f1p.add(f2p);\n            }\n            else {\n                const { p, f } = this.wNAF(n);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return Point.normalizeZ([point, fake])[0];\n        }\n        /**\n         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n         * Not using Strauss-Shamir trick: precomputation tables are faster.\n         * The trick could be useful if both P and Q are not G (not in our case).\n         * @returns non-zero affine point\n         */\n        multiplyAndAddUnsafe(Q, a, b) {\n            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n            const mul = (P, a // Select faster multiply() method\n            ) => (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));\n            const sum = mul(this, a).add(mul(Q, b));\n            return sum.is0() ? undefined : sum;\n        }\n        // Converts Projective point to affine (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        // (x, y, z) ∋ (x=x/z, y=y/z)\n        toAffine(iz) {\n            const { px: x, py: y, pz: z } = this;\n            const is0 = this.is0();\n            // If invZ was 0, we return zero point. However we still want to execute\n            // all operations, so we replace invZ with a random number, 1.\n            if (iz == null)\n                iz = is0 ? Fp.ONE : Fp.inv(z);\n            const ax = Fp.mul(x, iz);\n            const ay = Fp.mul(y, iz);\n            const zz = Fp.mul(z, iz);\n            if (is0)\n                return { x: Fp.ZERO, y: Fp.ZERO };\n            if (!Fp.eql(zz, Fp.ONE))\n                throw new Error('invZ was invalid');\n            return { x: ax, y: ay };\n        }\n        isTorsionFree() {\n            const { h: cofactor, isTorsionFree } = CURVE;\n            if (cofactor === _1n)\n                return true; // No subgroups, always torsion-free\n            if (isTorsionFree)\n                return isTorsionFree(Point, this);\n            throw new Error('isTorsionFree() has not been declared for the elliptic curve');\n        }\n        clearCofactor() {\n            const { h: cofactor, clearCofactor } = CURVE;\n            if (cofactor === _1n)\n                return this; // Fast-path\n            if (clearCofactor)\n                return clearCofactor(Point, this);\n            return this.multiplyUnsafe(CURVE.h);\n        }\n        toRawBytes(isCompressed = true) {\n            this.assertValidity();\n            return toBytes(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(this.toRawBytes(isCompressed));\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n    const _bits = CURVE.nBitLength;\n    const wnaf = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n    // Validate if generator point is on curve\n    return {\n        CURVE,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar,\n        weierstrassEquation,\n        isWithinCurveOrder,\n    };\n}\nfunction validateOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject(opts, {\n        hash: 'hash',\n        hmac: 'function',\n        randomBytes: 'function',\n    }, {\n        bits2int: 'function',\n        bits2int_modN: 'function',\n        lowS: 'boolean',\n    });\n    return Object.freeze({ lowS: true, ...opts });\n}\nfunction weierstrass(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER } = CURVE;\n    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n    function isValidFieldElement(num) {\n        return _0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE\n    }\n    function modN(a) {\n        return _modular_js__WEBPACK_IMPORTED_MODULE_2__.mod(a, CURVE_ORDER);\n    }\n    function invN(a) {\n        return _modular_js__WEBPACK_IMPORTED_MODULE_2__.invert(a, CURVE_ORDER);\n    }\n    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder, } = weierstrassPoints({\n        ...CURVE,\n        toBytes(_c, point, isCompressed) {\n            const a = point.toAffine();\n            const x = Fp.toBytes(a.x);\n            const cat = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes;\n            if (isCompressed) {\n                return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);\n            }\n            else {\n                return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));\n            }\n        },\n        fromBytes(bytes) {\n            const len = bytes.length;\n            const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // this.assertValidity() is done inside of fromHex\n            if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n                const x = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(tail);\n                if (!isValidFieldElement(x))\n                    throw new Error('Point is not on curve');\n                const y2 = weierstrassEquation(x); // y² = x³ + ax + b\n                let y;\n                try {\n                    y = Fp.sqrt(y2); // y = y² ^ (p+1)/4\n                }\n                catch (sqrtError) {\n                    const suffix = sqrtError instanceof Error ? ': ' + sqrtError.message : '';\n                    throw new Error('Point is not on curve' + suffix);\n                }\n                const isYOdd = (y & _1n) === _1n;\n                // ECDSA\n                const isHeadOdd = (head & 1) === 1;\n                if (isHeadOdd !== isYOdd)\n                    y = Fp.neg(y);\n                return { x, y };\n            }\n            else if (len === uncompressedLen && head === 0x04) {\n                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n                return { x, y };\n            }\n            else {\n                throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);\n            }\n        },\n    });\n    const numToNByteStr = (num) => _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(_utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE(num, CURVE.nByteLength));\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function normalizeS(s) {\n        return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n    }\n    // slice bytes num\n    const slcNum = (b, from, to) => _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(b.slice(from, to));\n    /**\n     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n     */\n    class Signature {\n        constructor(r, s, recovery) {\n            this.r = r;\n            this.s = s;\n            this.recovery = recovery;\n            this.assertValidity();\n        }\n        // pair (bytes of r, bytes of s)\n        static fromCompact(hex) {\n            const l = CURVE.nByteLength;\n            hex = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('compactSignature', hex, l * 2);\n            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n        }\n        // DER encoded ECDSA signature\n        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n        static fromDER(hex) {\n            const { r, s } = DER.toSig((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('DER', hex));\n            return new Signature(r, s);\n        }\n        assertValidity() {\n            // can use assertGE here\n            if (!isWithinCurveOrder(this.r))\n                throw new Error('r must be 0 < r < CURVE.n');\n            if (!isWithinCurveOrder(this.s))\n                throw new Error('s must be 0 < s < CURVE.n');\n        }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(msgHash) {\n            const { r, s, recovery: rec } = this;\n            const h = bits2int_modN((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('msgHash', msgHash)); // Truncate hash\n            if (rec == null || ![0, 1, 2, 3].includes(rec))\n                throw new Error('recovery id invalid');\n            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n            if (radj >= Fp.ORDER)\n                throw new Error('recovery id 2 or 3 invalid');\n            const prefix = (rec & 1) === 0 ? '02' : '03';\n            const R = Point.fromHex(prefix + numToNByteStr(radj));\n            const ir = invN(radj); // r^-1\n            const u1 = modN(-h * ir); // -hr^-1\n            const u2 = modN(s * ir); // sr^-1\n            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n            if (!Q)\n                throw new Error('point at infinify'); // unsafe is fine: no priv data leaked\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n        }\n        // DER-encoded\n        toDERRawBytes() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.hexToBytes(this.toDERHex());\n        }\n        toDERHex() {\n            return DER.hexFromSig({ r: this.r, s: this.s });\n        }\n        // padded bytes of r, then padded bytes of s\n        toCompactRawBytes() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.hexToBytes(this.toCompactHex());\n        }\n        toCompactHex() {\n            return numToNByteStr(this.r) + numToNByteStr(this.s);\n        }\n    }\n    const utils = {\n        isValidPrivateKey(privateKey) {\n            try {\n                normPrivateKeyToScalar(privateKey);\n                return true;\n            }\n            catch (error) {\n                return false;\n            }\n        },\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\n        /**\n         * Produces cryptographically secure private key from random of size\n         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n         */\n        randomPrivateKey: () => {\n            const length = _modular_js__WEBPACK_IMPORTED_MODULE_2__.getMinHashLength(CURVE.n);\n            return _modular_js__WEBPACK_IMPORTED_MODULE_2__.mapHashToField(CURVE.randomBytes(length), CURVE.n);\n        },\n        /**\n         * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n         * Allows to massively speed-up `point.multiply(scalar)`.\n         * @returns cached point\n         * @example\n         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n         * fast.multiply(privKey); // much faster ECDH now\n         */\n        precompute(windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n            return point;\n        },\n    };\n    /**\n     * Computes public key for a private key. Checks for validity of the private key.\n     * @param privateKey private key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */\n    function getPublicKey(privateKey, isCompressed = true) {\n        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */\n    function isProbPub(item) {\n        const arr = _utils_js__WEBPACK_IMPORTED_MODULE_1__.isBytes(item);\n        const str = typeof item === 'string';\n        const len = (arr || str) && item.length;\n        if (arr)\n            return len === compressedLen || len === uncompressedLen;\n        if (str)\n            return len === 2 * compressedLen || len === 2 * uncompressedLen;\n        if (item instanceof Point)\n            return true;\n        return false;\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from private key and public key.\n     * Checks: 1) private key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param privateA private key\n     * @param publicB different public key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */\n    function getSharedSecret(privateA, publicB, isCompressed = true) {\n        if (isProbPub(privateA))\n            throw new Error('first arg must be private key');\n        if (!isProbPub(publicB))\n            throw new Error('second arg must be public key');\n        const b = Point.fromHex(publicB); // check for being on-curve\n        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = CURVE.bits2int ||\n        function (bytes) {\n            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n            // for some cases, since bytes.length * 8 is not actual bitLength.\n            const num = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(bytes); // check for == u8 done here\n            const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n            return delta > 0 ? num >> BigInt(delta) : num;\n        };\n    const bits2int_modN = CURVE.bits2int_modN ||\n        function (bytes) {\n            return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n        };\n    // NOTE: pads output with zero as per spec\n    const ORDER_MASK = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bitMask(CURVE.nBitLength);\n    /**\n     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n     */\n    function int2octets(num) {\n        if (typeof num !== 'bigint')\n            throw new Error('bigint expected');\n        if (!(_0n <= num && num < ORDER_MASK))\n            throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);\n        // works with order, can have different size than numToField!\n        return _utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE(num, CURVE.nByteLength);\n    }\n    // Steps A, D of RFC6979 3.2\n    // Creates RFC6979 seed; converts msg/privKey to numbers.\n    // Used only in sign, not in verify.\n    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.\n    // Also it can be bigger for P224 + SHA256\n    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n        if (['recovered', 'canonical'].some((k) => k in opts))\n            throw new Error('sign() legacy options not supported');\n        const { hash, randomBytes } = CURVE;\n        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n        if (lowS == null)\n            lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('msgHash', msgHash);\n        if (prehash)\n            msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('prehashed msgHash', hash(msgHash));\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(msgHash);\n        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n        const seedArgs = [int2octets(d), int2octets(h1int)];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (ent != null && ent !== false) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n            seedArgs.push((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('extraEntropy', e)); // check for being bytes\n        }\n        const seed = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n            if (!isWithinCurveOrder(k))\n                return; // Important: all mod() calls here must be done over N\n            const ik = invN(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n            const r = modN(q.x); // r = q.x mod n\n            if (r === _0n)\n                return;\n            // Can use scalar blinding b^-1(bm + bdr) where b ∈ [1,q−1] according to\n            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n            const s = modN(ik * modN(m + r * d)); // Not using blinding here\n            if (s === _0n)\n                return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = normalizeS(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return { seed, k2sig };\n    }\n    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };\n    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };\n    /**\n     * Signs message hash with a private key.\n     * ```\n     * sign(m, d, k) where\n     *   (x, y) = G × k\n     *   r = x mod n\n     *   s = (m + dr)/k mod n\n     * ```\n     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n     * @param privKey private key\n     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n     * @returns signature with recovery param\n     */\n    function sign(msgHash, privKey, opts = defaultSigOpts) {\n        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n        const C = CURVE;\n        const drbg = _utils_js__WEBPACK_IMPORTED_MODULE_1__.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);\n        return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    }\n    // Enable precomputes. Slows down first publicKey computation by 20ms.\n    Point.BASE._setWindowSize(8);\n    // utils.precompute(8, ProjectivePoint.BASE)\n    /**\n     * Verifies a signature against message hash and public key.\n     * Rejects lowS signatures by default: to override,\n     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   U1 = hs^-1 mod n\n     *   U2 = rs^-1 mod n\n     *   R = U1⋅G - U2⋅P\n     *   mod(R.x, n) == r\n     * ```\n     */\n    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n        const sg = signature;\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('msgHash', msgHash);\n        publicKey = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('publicKey', publicKey);\n        if ('strict' in opts)\n            throw new Error('options.strict was renamed to lowS');\n        const { lowS, prehash } = opts;\n        let _sig = undefined;\n        let P;\n        try {\n            if (typeof sg === 'string' || _utils_js__WEBPACK_IMPORTED_MODULE_1__.isBytes(sg)) {\n                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n                // Since DER can also be 2*nByteLength bytes, we check for it first.\n                try {\n                    _sig = Signature.fromDER(sg);\n                }\n                catch (derError) {\n                    if (!(derError instanceof DER.Err))\n                        throw derError;\n                    _sig = Signature.fromCompact(sg);\n                }\n            }\n            else if (typeof sg === 'object' && typeof sg.r === 'bigint' && typeof sg.s === 'bigint') {\n                const { r, s } = sg;\n                _sig = new Signature(r, s);\n            }\n            else {\n                throw new Error('PARSE');\n            }\n            P = Point.fromHex(publicKey);\n        }\n        catch (error) {\n            if (error.message === 'PARSE')\n                throw new Error(`signature must be Signature instance, Uint8Array or hex string`);\n            return false;\n        }\n        if (lowS && _sig.hasHighS())\n            return false;\n        if (prehash)\n            msgHash = CURVE.hash(msgHash);\n        const { r, s } = _sig;\n        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n        const is = invN(s); // s^-1\n        const u1 = modN(h * is); // u1 = hs^-1 mod n\n        const u2 = modN(r * is); // u2 = rs^-1 mod n\n        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1⋅G + u2⋅P\n        if (!R)\n            return false;\n        const v = modN(R.x);\n        return v === r;\n    }\n    return {\n        CURVE,\n        getPublicKey,\n        getSharedSecret,\n        sign,\n        verify,\n        ProjectivePoint: Point,\n        Signature,\n        utils,\n    };\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nfunction SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for (let o = q - _1n; o % _2n === _0n; o /= _2n)\n        l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v) => {\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for (let i = c1; i > _1n; i--) {\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return { isValid: isQR, value: tv3 };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v) => {\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */\nfunction mapToCurveSimpleSWU(Fp, opts) {\n    _modular_js__WEBPACK_IMPORTED_MODULE_2__.validateField(Fp);\n    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))\n        throw new Error('mapToCurveSimpleSWU: invalid opts');\n    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n    if (!Fp.isOdd)\n        throw new Error('Fp.isOdd is not implemented!');\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u) => {\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        x = Fp.div(x, tv4); // 25.   x = x / tv4\n        return { x, y };\n    };\n}\n//# sourceMappingURL=weierstrass.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvYXBpLWtleS1zdGFtcGVyL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC93ZWllcnN0cmFzcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDb0M7QUFDSDtBQUNRO0FBQ1E7QUFDakQ7QUFDQSxpQkFBaUIsd0RBQWE7QUFDOUIsSUFBSSxxREFBaUI7QUFDckI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0EsUUFBUSx3Q0FBd0MsRUFBRSxzQ0FBRTtBQUM3QztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDBDQUEwQztBQUMzRCxLQUFLO0FBQ0w7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0EsUUFBUSw2Q0FBUztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQyxnQkFBZ0Isc0JBQXNCO0FBQ3RDO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsSUFBSTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUIsSUFBSSxHQUFHLEVBQUUsRUFBRSxJQUFJLEdBQUcsRUFBRSxFQUFFO0FBQzNELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxZQUFZLEtBQUssU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0RBQWM7QUFDakMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsOEJBQThCO0FBQzlCLGtDQUFrQztBQUNsQyxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9FQUFvRTtBQUNwRjtBQUNBLGdCQUFnQiw4Q0FBVTtBQUMxQixzQkFBc0IsaURBQWE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0RBQWtCLENBQUMsc0RBQVc7QUFDcEQ7QUFDQTtBQUNBLG1EQUFtRCxhQUFhLDRCQUE0QixXQUFXO0FBQ3ZHO0FBQ0E7QUFDQSxrQkFBa0IsNENBQU8sVUFBVTtBQUNuQyx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsc0RBQVc7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLElBQUk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QyxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QywwREFBMEQ7QUFDMUQscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDLG9CQUFvQix5QkFBeUI7QUFDN0MsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHVCQUF1QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QixvQkFBb0IsT0FBTztBQUMzQjtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0Msc0JBQXNCLGlCQUFpQjtBQUN2QyxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0Esb0JBQW9CLDZCQUE2QjtBQUNqRDtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDZCQUE2QjtBQUNqRDtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaURBQWE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwrQ0FBSTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix3REFBYTtBQUM5QixJQUFJLHFEQUFpQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDJCQUEyQixxQkFBcUI7QUFDaEQ7QUFDTztBQUNQO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakMsd0NBQXdDO0FBQ3hDLDhDQUE4QztBQUM5QztBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0EsZUFBZSw0Q0FBTztBQUN0QjtBQUNBO0FBQ0EsZUFBZSwrQ0FBVTtBQUN6QjtBQUNBLFlBQVksMkZBQTJGO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtEQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsc0RBQWtCO0FBQzVDO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsbURBQW1ELEtBQUssd0JBQXdCLGVBQWUsc0JBQXNCLGlCQUFpQjtBQUN0STtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0wsbUNBQW1DLGlEQUFhLENBQUMsc0RBQWtCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msc0RBQWtCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNEQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTyxZQUFZLHNEQUFXO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQyxvQ0FBb0Msc0RBQVcsdUJBQXVCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLHNDQUFzQztBQUN0QyxxQ0FBcUM7QUFDckMsa0VBQWtFO0FBQ2xFO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpREFBYTtBQUNoQztBQUNBO0FBQ0Esb0NBQW9DLHNCQUFzQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaURBQWE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIseURBQW9CO0FBQy9DLG1CQUFtQix1REFBa0I7QUFDckMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDhDQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0RBQWtCLFNBQVM7QUFDbkQsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQSx1QkFBdUIsOENBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsaUJBQWlCO0FBQ3BFO0FBQ0EsZUFBZSxzREFBa0I7QUFDakM7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDLGNBQWMsbUNBQW1DLFFBQVE7QUFDekQ7QUFDQSx5QkFBeUI7QUFDekIsa0JBQWtCLHNEQUFXO0FBQzdCO0FBQ0Esc0JBQXNCLHNEQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFLDBCQUEwQixzREFBVyxzQkFBc0I7QUFDM0Q7QUFDQSxxQkFBcUIsa0RBQWMsZUFBZTtBQUNsRCx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0Esd0JBQXdCO0FBQ3hCLGdDQUFnQztBQUNoQyx5REFBeUQ7QUFDekQsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLCtCQUErQjtBQUMvQjtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjLG1DQUFtQztBQUNqRTtBQUNBLHFCQUFxQixxREFBaUI7QUFDdEMsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzREFBVztBQUM3QixvQkFBb0Isc0RBQVc7QUFDL0I7QUFDQTtBQUNBLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDhDQUFVO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsMENBQTBDO0FBQzFDLDRCQUE0QjtBQUM1QixpQ0FBaUM7QUFDakMsaUNBQWlDO0FBQ2pDLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUJBQWlCO0FBQzNDO0FBQ0Esa0JBQWtCO0FBQ2xCLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsaUNBQWlDO0FBQ2pDLGlDQUFpQztBQUNqQyw2QkFBNkI7QUFDN0IsOEJBQThCO0FBQzlCLDRDQUE0QztBQUM1QztBQUNBLHNCQUFzQjtBQUN0QixpQ0FBaUM7QUFDakMsK0JBQStCO0FBQy9CLDhCQUE4QjtBQUM5QixrQ0FBa0M7QUFDbEMsK0JBQStCO0FBQy9CLGdDQUFnQztBQUNoQyw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLG9DQUFvQztBQUNwQywrQkFBK0I7QUFDL0Isd0NBQXdDO0FBQ3hDLCtCQUErQjtBQUMvQixnQ0FBZ0M7QUFDaEMsdUNBQXVDO0FBQ3ZDLHVDQUF1QztBQUN2QztBQUNBLHlCQUF5QixTQUFTO0FBQ2xDLCtCQUErQjtBQUMvQixzQ0FBc0M7QUFDdEMseUNBQXlDO0FBQ3pDLDZDQUE2QztBQUM3QyxvQ0FBb0M7QUFDcEMsb0NBQW9DO0FBQ3BDLHFDQUFxQztBQUNyQyx5Q0FBeUM7QUFDekMsMENBQTBDO0FBQzFDO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQyx1Q0FBdUM7QUFDdkM7QUFDQSxpQ0FBaUM7QUFDakMsc0NBQXNDO0FBQ3RDLG9DQUFvQztBQUNwQyxzQ0FBc0M7QUFDdEMsa0NBQWtDO0FBQ2xDLHVDQUF1QztBQUN2QywrQ0FBK0Msa0JBQWtCO0FBQ2pFLHlDQUF5QztBQUN6QywyQ0FBMkM7QUFDM0MscUJBQXFCLDJCQUEyQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsSUFBSSxzREFBaUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsbUNBQW1DO0FBQ25DLDJCQUEyQjtBQUMzQixnQ0FBZ0M7QUFDaEMsbUNBQW1DO0FBQ25DLG1DQUFtQztBQUNuQyxtRUFBbUU7QUFDbkUsbUNBQW1DO0FBQ25DLDJCQUEyQjtBQUMzQiwyQkFBMkI7QUFDM0IsbUNBQW1DO0FBQ25DLGdDQUFnQztBQUNoQyxnQ0FBZ0M7QUFDaEMsZ0NBQWdDO0FBQ2hDLG1DQUFtQztBQUNuQyxnQ0FBZ0M7QUFDaEMsOEJBQThCO0FBQzlCLGdCQUFnQixpQkFBaUIsdUJBQXVCO0FBQ3hELDRCQUE0QjtBQUM1Qiw4QkFBOEI7QUFDOUIsc0NBQXNDO0FBQ3RDLHdDQUF3QztBQUN4QyxnREFBZ0Q7QUFDaEQsdUNBQXVDO0FBQ3ZDLDRCQUE0QjtBQUM1QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbnVyc2VibG9jLy4vbm9kZV9tb2R1bGVzL0B0dXJua2V5L2FwaS1rZXktc3RhbXBlci9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanM/MzQzNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBTaG9ydCBXZWllcnN0cmFzcyBjdXJ2ZS4gVGhlIGZvcm11bGEgaXM6IHnCsiA9IHjCsyArIGF4ICsgYlxuaW1wb3J0ICogYXMgbW9kIGZyb20gJy4vbW9kdWxhci5qcyc7XG5pbXBvcnQgKiBhcyB1dCBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7IGVuc3VyZUJ5dGVzIH0gZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgeyB3TkFGLCB2YWxpZGF0ZUJhc2ljIH0gZnJvbSAnLi9jdXJ2ZS5qcyc7XG5mdW5jdGlvbiB2YWxpZGF0ZVBvaW50T3B0cyhjdXJ2ZSkge1xuICAgIGNvbnN0IG9wdHMgPSB2YWxpZGF0ZUJhc2ljKGN1cnZlKTtcbiAgICB1dC52YWxpZGF0ZU9iamVjdChvcHRzLCB7XG4gICAgICAgIGE6ICdmaWVsZCcsXG4gICAgICAgIGI6ICdmaWVsZCcsXG4gICAgfSwge1xuICAgICAgICBhbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHM6ICdhcnJheScsXG4gICAgICAgIHdyYXBQcml2YXRlS2V5OiAnYm9vbGVhbicsXG4gICAgICAgIGlzVG9yc2lvbkZyZWU6ICdmdW5jdGlvbicsXG4gICAgICAgIGNsZWFyQ29mYWN0b3I6ICdmdW5jdGlvbicsXG4gICAgICAgIGFsbG93SW5maW5pdHlQb2ludDogJ2Jvb2xlYW4nLFxuICAgICAgICBmcm9tQnl0ZXM6ICdmdW5jdGlvbicsXG4gICAgICAgIHRvQnl0ZXM6ICdmdW5jdGlvbicsXG4gICAgfSk7XG4gICAgY29uc3QgeyBlbmRvLCBGcCwgYSB9ID0gb3B0cztcbiAgICBpZiAoZW5kbykge1xuICAgICAgICBpZiAoIUZwLmVxbChhLCBGcC5aRVJPKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbmRvbW9ycGhpc20gY2FuIG9ubHkgYmUgZGVmaW5lZCBmb3IgS29ibGl0eiBjdXJ2ZXMgdGhhdCBoYXZlIGE9MCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZW5kbyAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgICAgIHR5cGVvZiBlbmRvLmJldGEgIT09ICdiaWdpbnQnIHx8XG4gICAgICAgICAgICB0eXBlb2YgZW5kby5zcGxpdFNjYWxhciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBlbmRvbW9ycGhpc20gd2l0aCBiZXRhOiBiaWdpbnQgYW5kIHNwbGl0U2NhbGFyOiBmdW5jdGlvbicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHsgLi4ub3B0cyB9KTtcbn1cbi8vIEFTTi4xIERFUiBlbmNvZGluZyB1dGlsaXRpZXNcbmNvbnN0IHsgYnl0ZXNUb051bWJlckJFOiBiMm4sIGhleFRvQnl0ZXM6IGgyYiB9ID0gdXQ7XG5leHBvcnQgY29uc3QgREVSID0ge1xuICAgIC8vIGFzbi4xIERFUiBlbmNvZGluZyB1dGlsc1xuICAgIEVycjogY2xhc3MgREVSRXJyIGV4dGVuZHMgRXJyb3Ige1xuICAgICAgICBjb25zdHJ1Y3RvcihtID0gJycpIHtcbiAgICAgICAgICAgIHN1cGVyKG0pO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBfcGFyc2VJbnQoZGF0YSkge1xuICAgICAgICBjb25zdCB7IEVycjogRSB9ID0gREVSO1xuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPCAyIHx8IGRhdGFbMF0gIT09IDB4MDIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmUgaW50ZWdlciB0YWcnKTtcbiAgICAgICAgY29uc3QgbGVuID0gZGF0YVsxXTtcbiAgICAgICAgY29uc3QgcmVzID0gZGF0YS5zdWJhcnJheSgyLCBsZW4gKyAyKTtcbiAgICAgICAgaWYgKCFsZW4gfHwgcmVzLmxlbmd0aCAhPT0gbGVuKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlIGludGVnZXI6IHdyb25nIGxlbmd0aCcpO1xuICAgICAgICAvLyBodHRwczovL2NyeXB0by5zdGFja2V4Y2hhbmdlLmNvbS9hLzU3NzM0IExlZnRtb3N0IGJpdCBvZiBmaXJzdCBieXRlIGlzICduZWdhdGl2ZScgZmxhZyxcbiAgICAgICAgLy8gc2luY2Ugd2UgYWx3YXlzIHVzZSBwb3NpdGl2ZSBpbnRlZ2VycyBoZXJlLiBJdCBtdXN0IGFsd2F5cyBiZSBlbXB0eTpcbiAgICAgICAgLy8gLSBhZGQgemVybyBieXRlIGlmIGV4aXN0c1xuICAgICAgICAvLyAtIGlmIG5leHQgYnl0ZSBkb2Vzbid0IGhhdmUgYSBmbGFnLCBsZWFkaW5nIHplcm8gaXMgbm90IGFsbG93ZWQgKG1pbmltYWwgZW5jb2RpbmcpXG4gICAgICAgIGlmIChyZXNbMF0gJiAwYjEwMDAwMDAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlIGludGVnZXI6IG5lZ2F0aXZlJyk7XG4gICAgICAgIGlmIChyZXNbMF0gPT09IDB4MDAgJiYgIShyZXNbMV0gJiAwYjEwMDAwMDAwKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiB1bm5lY2Vzc2FyeSBsZWFkaW5nIHplcm8nKTtcbiAgICAgICAgcmV0dXJuIHsgZDogYjJuKHJlcyksIGw6IGRhdGEuc3ViYXJyYXkobGVuICsgMikgfTsgLy8gZCBpcyBkYXRhLCBsIGlzIGxlZnRcbiAgICB9LFxuICAgIHRvU2lnKGhleCkge1xuICAgICAgICAvLyBwYXJzZSBERVIgc2lnbmF0dXJlXG4gICAgICAgIGNvbnN0IHsgRXJyOiBFIH0gPSBERVI7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0eXBlb2YgaGV4ID09PSAnc3RyaW5nJyA/IGgyYihoZXgpIDogaGV4O1xuICAgICAgICB1dC5hYnl0ZXMoZGF0YSk7XG4gICAgICAgIGxldCBsID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGlmIChsIDwgMiB8fCBkYXRhWzBdICE9IDB4MzApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmUgdGFnJyk7XG4gICAgICAgIGlmIChkYXRhWzFdICE9PSBsIC0gMilcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZTogaW5jb3JyZWN0IGxlbmd0aCcpO1xuICAgICAgICBjb25zdCB7IGQ6IHIsIGw6IHNCeXRlcyB9ID0gREVSLl9wYXJzZUludChkYXRhLnN1YmFycmF5KDIpKTtcbiAgICAgICAgY29uc3QgeyBkOiBzLCBsOiByQnl0ZXNMZWZ0IH0gPSBERVIuX3BhcnNlSW50KHNCeXRlcyk7XG4gICAgICAgIGlmIChyQnl0ZXNMZWZ0Lmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZTogbGVmdCBieXRlcyBhZnRlciBwYXJzaW5nJyk7XG4gICAgICAgIHJldHVybiB7IHIsIHMgfTtcbiAgICB9LFxuICAgIGhleEZyb21TaWcoc2lnKSB7XG4gICAgICAgIC8vIEFkZCBsZWFkaW5nIHplcm8gaWYgZmlyc3QgYnl0ZSBoYXMgbmVnYXRpdmUgYml0IGVuYWJsZWQuIE1vcmUgZGV0YWlscyBpbiAnX3BhcnNlSW50J1xuICAgICAgICBjb25zdCBzbGljZSA9IChzKSA9PiAoTnVtYmVyLnBhcnNlSW50KHNbMF0sIDE2KSAmIDBiMTAwMCA/ICcwMCcgKyBzIDogcyk7XG4gICAgICAgIGNvbnN0IGggPSAobnVtKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBoZXggPSBudW0udG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgcmV0dXJuIGhleC5sZW5ndGggJiAxID8gYDAke2hleH1gIDogaGV4O1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzID0gc2xpY2UoaChzaWcucykpO1xuICAgICAgICBjb25zdCByID0gc2xpY2UoaChzaWcucikpO1xuICAgICAgICBjb25zdCBzaGwgPSBzLmxlbmd0aCAvIDI7XG4gICAgICAgIGNvbnN0IHJobCA9IHIubGVuZ3RoIC8gMjtcbiAgICAgICAgY29uc3Qgc2wgPSBoKHNobCk7XG4gICAgICAgIGNvbnN0IHJsID0gaChyaGwpO1xuICAgICAgICByZXR1cm4gYDMwJHtoKHJobCArIHNobCArIDQpfTAyJHtybH0ke3J9MDIke3NsfSR7c31gO1xuICAgIH0sXG59O1xuLy8gQmUgZnJpZW5kbHkgdG8gYmFkIEVDTUFTY3JpcHQgcGFyc2VycyBieSBub3QgdXNpbmcgYmlnaW50IGxpdGVyYWxzXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKSwgXzFuID0gQmlnSW50KDEpLCBfMm4gPSBCaWdJbnQoMiksIF8zbiA9IEJpZ0ludCgzKSwgXzRuID0gQmlnSW50KDQpO1xuZXhwb3J0IGZ1bmN0aW9uIHdlaWVyc3RyYXNzUG9pbnRzKG9wdHMpIHtcbiAgICBjb25zdCBDVVJWRSA9IHZhbGlkYXRlUG9pbnRPcHRzKG9wdHMpO1xuICAgIGNvbnN0IHsgRnAgfSA9IENVUlZFOyAvLyBBbGwgY3VydmVzIGhhcyBzYW1lIGZpZWxkIC8gZ3JvdXAgbGVuZ3RoIGFzIGZvciBub3csIGJ1dCB0aGV5IGNhbiBkaWZmZXJcbiAgICBjb25zdCB0b0J5dGVzID0gQ1VSVkUudG9CeXRlcyB8fFxuICAgICAgICAoKF9jLCBwb2ludCwgX2lzQ29tcHJlc3NlZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYSA9IHBvaW50LnRvQWZmaW5lKCk7XG4gICAgICAgICAgICByZXR1cm4gdXQuY29uY2F0Qnl0ZXMoVWludDhBcnJheS5mcm9tKFsweDA0XSksIEZwLnRvQnl0ZXMoYS54KSwgRnAudG9CeXRlcyhhLnkpKTtcbiAgICAgICAgfSk7XG4gICAgY29uc3QgZnJvbUJ5dGVzID0gQ1VSVkUuZnJvbUJ5dGVzIHx8XG4gICAgICAgICgoYnl0ZXMpID0+IHtcbiAgICAgICAgICAgIC8vIGNvbnN0IGhlYWQgPSBieXRlc1swXTtcbiAgICAgICAgICAgIGNvbnN0IHRhaWwgPSBieXRlcy5zdWJhcnJheSgxKTtcbiAgICAgICAgICAgIC8vIGlmIChoZWFkICE9PSAweDA0KSB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgbm9uLWNvbXByZXNzZWQgZW5jb2RpbmcgaXMgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICBjb25zdCB4ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoMCwgRnAuQllURVMpKTtcbiAgICAgICAgICAgIGNvbnN0IHkgPSBGcC5mcm9tQnl0ZXModGFpbC5zdWJhcnJheShGcC5CWVRFUywgMiAqIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgIH0pO1xuICAgIC8qKlxuICAgICAqIHnCsiA9IHjCsyArIGF4ICsgYjogU2hvcnQgd2VpZXJzdHJhc3MgY3VydmUgZm9ybXVsYVxuICAgICAqIEByZXR1cm5zIHnCslxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdlaWVyc3RyYXNzRXF1YXRpb24oeCkge1xuICAgICAgICBjb25zdCB7IGEsIGIgfSA9IENVUlZFO1xuICAgICAgICBjb25zdCB4MiA9IEZwLnNxcih4KTsgLy8geCAqIHhcbiAgICAgICAgY29uc3QgeDMgPSBGcC5tdWwoeDIsIHgpOyAvLyB4MiAqIHhcbiAgICAgICAgcmV0dXJuIEZwLmFkZChGcC5hZGQoeDMsIEZwLm11bCh4LCBhKSksIGIpOyAvLyB4MyArIGEgKiB4ICsgYlxuICAgIH1cbiAgICAvLyBWYWxpZGF0ZSB3aGV0aGVyIHRoZSBwYXNzZWQgY3VydmUgcGFyYW1zIGFyZSB2YWxpZC5cbiAgICAvLyBXZSBjaGVjayBpZiBjdXJ2ZSBlcXVhdGlvbiB3b3JrcyBmb3IgZ2VuZXJhdG9yIHBvaW50LlxuICAgIC8vIGBhc3NlcnRWYWxpZGl0eSgpYCB3b24ndCB3b3JrOiBgaXNUb3JzaW9uRnJlZSgpYCBpcyBub3QgYXZhaWxhYmxlIGF0IHRoaXMgcG9pbnQgaW4gYmxzMTItMzgxLlxuICAgIC8vIFByb2plY3RpdmVQb2ludCBjbGFzcyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0LlxuICAgIGlmICghRnAuZXFsKEZwLnNxcihDVVJWRS5HeSksIHdlaWVyc3RyYXNzRXF1YXRpb24oQ1VSVkUuR3gpKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgZ2VuZXJhdG9yIHBvaW50OiBlcXVhdGlvbiBsZWZ0ICE9IHJpZ2h0Jyk7XG4gICAgLy8gVmFsaWQgZ3JvdXAgZWxlbWVudHMgcmVzaWRlIGluIHJhbmdlIDEuLm4tMVxuICAgIGZ1bmN0aW9uIGlzV2l0aGluQ3VydmVPcmRlcihudW0pIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBudW0gPT09ICdiaWdpbnQnICYmIF8wbiA8IG51bSAmJiBudW0gPCBDVVJWRS5uO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhc3NlcnRHRShudW0pIHtcbiAgICAgICAgaWYgKCFpc1dpdGhpbkN1cnZlT3JkZXIobnVtKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdmFsaWQgYmlnaW50OiAwIDwgYmlnaW50IDwgY3VydmUubicpO1xuICAgIH1cbiAgICAvLyBWYWxpZGF0ZXMgaWYgcHJpdiBrZXkgaXMgdmFsaWQgYW5kIGNvbnZlcnRzIGl0IHRvIGJpZ2ludC5cbiAgICAvLyBTdXBwb3J0cyBvcHRpb25zIGFsbG93ZWRQcml2YXRlS2V5TGVuZ3RocyBhbmQgd3JhcFByaXZhdGVLZXkuXG4gICAgZnVuY3Rpb24gbm9ybVByaXZhdGVLZXlUb1NjYWxhcihrZXkpIHtcbiAgICAgICAgY29uc3QgeyBhbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHM6IGxlbmd0aHMsIG5CeXRlTGVuZ3RoLCB3cmFwUHJpdmF0ZUtleSwgbiB9ID0gQ1VSVkU7XG4gICAgICAgIGlmIChsZW5ndGhzICYmIHR5cGVvZiBrZXkgIT09ICdiaWdpbnQnKSB7XG4gICAgICAgICAgICBpZiAodXQuaXNCeXRlcyhrZXkpKVxuICAgICAgICAgICAgICAgIGtleSA9IHV0LmJ5dGVzVG9IZXgoa2V5KTtcbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSB0byBoZXggc3RyaW5nLCBwYWQuIEUuZy4gUDUyMSB3b3VsZCBub3JtIDEzMC0xMzIgY2hhciBoZXggdG8gMTMyLWNoYXIgYnl0ZXNcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJyB8fCAhbGVuZ3Rocy5pbmNsdWRlcyhrZXkubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQga2V5Jyk7XG4gICAgICAgICAgICBrZXkgPSBrZXkucGFkU3RhcnQobkJ5dGVMZW5ndGggKiAyLCAnMCcpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBudW07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBudW0gPVxuICAgICAgICAgICAgICAgIHR5cGVvZiBrZXkgPT09ICdiaWdpbnQnXG4gICAgICAgICAgICAgICAgICAgID8ga2V5XG4gICAgICAgICAgICAgICAgICAgIDogdXQuYnl0ZXNUb051bWJlckJFKGVuc3VyZUJ5dGVzKCdwcml2YXRlIGtleScsIGtleSwgbkJ5dGVMZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcHJpdmF0ZSBrZXkgbXVzdCBiZSAke25CeXRlTGVuZ3RofSBieXRlcywgaGV4IG9yIGJpZ2ludCwgbm90ICR7dHlwZW9mIGtleX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod3JhcFByaXZhdGVLZXkpXG4gICAgICAgICAgICBudW0gPSBtb2QubW9kKG51bSwgbik7IC8vIGRpc2FibGVkIGJ5IGRlZmF1bHQsIGVuYWJsZWQgZm9yIEJMU1xuICAgICAgICBhc3NlcnRHRShudW0pOyAvLyBudW0gaW4gcmFuZ2UgWzEuLk4tMV1cbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICB9XG4gICAgY29uc3QgcG9pbnRQcmVjb21wdXRlcyA9IG5ldyBNYXAoKTtcbiAgICBmdW5jdGlvbiBhc3NlcnRQcmpQb2ludChvdGhlcikge1xuICAgICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFBvaW50KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvamVjdGl2ZVBvaW50IGV4cGVjdGVkJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2plY3RpdmUgUG9pbnQgd29ya3MgaW4gM2QgLyBwcm9qZWN0aXZlIChob21vZ2VuZW91cykgY29vcmRpbmF0ZXM6ICh4LCB5LCB6KSDiiIsgKHg9eC96LCB5PXkveilcbiAgICAgKiBEZWZhdWx0IFBvaW50IHdvcmtzIGluIDJkIC8gYWZmaW5lIGNvb3JkaW5hdGVzOiAoeCwgeSlcbiAgICAgKiBXZSdyZSBkb2luZyBjYWxjdWxhdGlvbnMgaW4gcHJvamVjdGl2ZSwgYmVjYXVzZSBpdHMgb3BlcmF0aW9ucyBkb24ndCByZXF1aXJlIGNvc3RseSBpbnZlcnNpb24uXG4gICAgICovXG4gICAgY2xhc3MgUG9pbnQge1xuICAgICAgICBjb25zdHJ1Y3RvcihweCwgcHksIHB6KSB7XG4gICAgICAgICAgICB0aGlzLnB4ID0gcHg7XG4gICAgICAgICAgICB0aGlzLnB5ID0gcHk7XG4gICAgICAgICAgICB0aGlzLnB6ID0gcHo7XG4gICAgICAgICAgICBpZiAocHggPT0gbnVsbCB8fCAhRnAuaXNWYWxpZChweCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd4IHJlcXVpcmVkJyk7XG4gICAgICAgICAgICBpZiAocHkgPT0gbnVsbCB8fCAhRnAuaXNWYWxpZChweSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd5IHJlcXVpcmVkJyk7XG4gICAgICAgICAgICBpZiAocHogPT0gbnVsbCB8fCAhRnAuaXNWYWxpZChweikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd6IHJlcXVpcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG9lcyBub3QgdmFsaWRhdGUgaWYgdGhlIHBvaW50IGlzIG9uLWN1cnZlLlxuICAgICAgICAvLyBVc2UgZnJvbUhleCBpbnN0ZWFkLCBvciBjYWxsIGFzc2VydFZhbGlkaXR5KCkgbGF0ZXIuXG4gICAgICAgIHN0YXRpYyBmcm9tQWZmaW5lKHApIHtcbiAgICAgICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gcCB8fCB7fTtcbiAgICAgICAgICAgIGlmICghcCB8fCAhRnAuaXNWYWxpZCh4KSB8fCAhRnAuaXNWYWxpZCh5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYWZmaW5lIHBvaW50Jyk7XG4gICAgICAgICAgICBpZiAocCBpbnN0YW5jZW9mIFBvaW50KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncHJvamVjdGl2ZSBwb2ludCBub3QgYWxsb3dlZCcpO1xuICAgICAgICAgICAgY29uc3QgaXMwID0gKGkpID0+IEZwLmVxbChpLCBGcC5aRVJPKTtcbiAgICAgICAgICAgIC8vIGZyb21BZmZpbmUoeDowLCB5OjApIHdvdWxkIHByb2R1Y2UgKHg6MCwgeTowLCB6OjEpLCBidXQgd2UgbmVlZCAoeDowLCB5OjEsIHo6MClcbiAgICAgICAgICAgIGlmIChpczAoeCkgJiYgaXMwKHkpKVxuICAgICAgICAgICAgICAgIHJldHVybiBQb2ludC5aRVJPO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh4LCB5LCBGcC5PTkUpO1xuICAgICAgICB9XG4gICAgICAgIGdldCB4KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9BZmZpbmUoKS54O1xuICAgICAgICB9XG4gICAgICAgIGdldCB5KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9BZmZpbmUoKS55O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUYWtlcyBhIGJ1bmNoIG9mIFByb2plY3RpdmUgUG9pbnRzIGJ1dCBleGVjdXRlcyBvbmx5IG9uZVxuICAgICAgICAgKiBpbnZlcnNpb24gb24gYWxsIG9mIHRoZW0uIEludmVyc2lvbiBpcyB2ZXJ5IHNsb3cgb3BlcmF0aW9uLFxuICAgICAgICAgKiBzbyB0aGlzIGltcHJvdmVzIHBlcmZvcm1hbmNlIG1hc3NpdmVseS5cbiAgICAgICAgICogT3B0aW1pemF0aW9uOiBjb252ZXJ0cyBhIGxpc3Qgb2YgcHJvamVjdGl2ZSBwb2ludHMgdG8gYSBsaXN0IG9mIGlkZW50aWNhbCBwb2ludHMgd2l0aCBaPTEuXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgbm9ybWFsaXplWihwb2ludHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvSW52ID0gRnAuaW52ZXJ0QmF0Y2gocG9pbnRzLm1hcCgocCkgPT4gcC5weikpO1xuICAgICAgICAgICAgcmV0dXJuIHBvaW50cy5tYXAoKHAsIGkpID0+IHAudG9BZmZpbmUodG9JbnZbaV0pKS5tYXAoUG9pbnQuZnJvbUFmZmluZSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIGhhc2ggc3RyaW5nIG9yIFVpbnQ4QXJyYXkgdG8gUG9pbnQuXG4gICAgICAgICAqIEBwYXJhbSBoZXggc2hvcnQvbG9uZyBFQ0RTQSBoZXhcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBmcm9tSGV4KGhleCkge1xuICAgICAgICAgICAgY29uc3QgUCA9IFBvaW50LmZyb21BZmZpbmUoZnJvbUJ5dGVzKGVuc3VyZUJ5dGVzKCdwb2ludEhleCcsIGhleCkpKTtcbiAgICAgICAgICAgIFAuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiBQO1xuICAgICAgICB9XG4gICAgICAgIC8vIE11bHRpcGxpZXMgZ2VuZXJhdG9yIHBvaW50IGJ5IHByaXZhdGVLZXkuXG4gICAgICAgIHN0YXRpYyBmcm9tUHJpdmF0ZUtleShwcml2YXRlS2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gUG9pbnQuQkFTRS5tdWx0aXBseShub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVLZXkpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBcIlByaXZhdGUgbWV0aG9kXCIsIGRvbid0IHVzZSBpdCBkaXJlY3RseVxuICAgICAgICBfc2V0V2luZG93U2l6ZSh3aW5kb3dTaXplKSB7XG4gICAgICAgICAgICB0aGlzLl9XSU5ET1dfU0laRSA9IHdpbmRvd1NpemU7XG4gICAgICAgICAgICBwb2ludFByZWNvbXB1dGVzLmRlbGV0ZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBIHBvaW50IG9uIGN1cnZlIGlzIHZhbGlkIGlmIGl0IGNvbmZvcm1zIHRvIGVxdWF0aW9uLlxuICAgICAgICBhc3NlcnRWYWxpZGl0eSgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzMCgpKSB7XG4gICAgICAgICAgICAgICAgLy8gKDAsIDEsIDApIGFrYSBaRVJPIGlzIGludmFsaWQgaW4gbW9zdCBjb250ZXh0cy5cbiAgICAgICAgICAgICAgICAvLyBJbiBCTFMsIFpFUk8gY2FuIGJlIHNlcmlhbGl6ZWQsIHNvIHdlIGFsbG93IGl0LlxuICAgICAgICAgICAgICAgIC8vICgwLCAwLCAwKSBpcyB3cm9uZyByZXByZXNlbnRhdGlvbiBvZiBaRVJPIGFuZCBpcyBhbHdheXMgaW52YWxpZC5cbiAgICAgICAgICAgICAgICBpZiAoQ1VSVkUuYWxsb3dJbmZpbml0eVBvaW50ICYmICFGcC5pczAodGhpcy5weSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogWkVSTycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU29tZSAzcmQtcGFydHkgdGVzdCB2ZWN0b3JzIHJlcXVpcmUgZGlmZmVyZW50IHdvcmRpbmcgYmV0d2VlbiBoZXJlICYgYGZyb21Db21wcmVzc2VkSGV4YFxuICAgICAgICAgICAgY29uc3QgeyB4LCB5IH0gPSB0aGlzLnRvQWZmaW5lKCk7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB4LCB5IGFyZSB2YWxpZCBmaWVsZCBlbGVtZW50c1xuICAgICAgICAgICAgaWYgKCFGcC5pc1ZhbGlkKHgpIHx8ICFGcC5pc1ZhbGlkKHkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiB4IG9yIHkgbm90IEZFJyk7XG4gICAgICAgICAgICBjb25zdCBsZWZ0ID0gRnAuc3FyKHkpOyAvLyB5wrJcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gd2VpZXJzdHJhc3NFcXVhdGlvbih4KTsgLy8geMKzICsgYXggKyBiXG4gICAgICAgICAgICBpZiAoIUZwLmVxbChsZWZ0LCByaWdodCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IGVxdWF0aW9uIGxlZnQgIT0gcmlnaHQnKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc1RvcnNpb25GcmVlKCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IG5vdCBpbiBwcmltZS1vcmRlciBzdWJncm91cCcpO1xuICAgICAgICB9XG4gICAgICAgIGhhc0V2ZW5ZKCkge1xuICAgICAgICAgICAgY29uc3QgeyB5IH0gPSB0aGlzLnRvQWZmaW5lKCk7XG4gICAgICAgICAgICBpZiAoRnAuaXNPZGQpXG4gICAgICAgICAgICAgICAgcmV0dXJuICFGcC5pc09kZCh5KTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZpZWxkIGRvZXNuJ3Qgc3VwcG9ydCBpc09kZFwiKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ29tcGFyZSBvbmUgcG9pbnQgdG8gYW5vdGhlci5cbiAgICAgICAgICovXG4gICAgICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICAgICAgYXNzZXJ0UHJqUG9pbnQob3RoZXIpO1xuICAgICAgICAgICAgY29uc3QgeyBweDogWDEsIHB5OiBZMSwgcHo6IFoxIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgeyBweDogWDIsIHB5OiBZMiwgcHo6IFoyIH0gPSBvdGhlcjtcbiAgICAgICAgICAgIGNvbnN0IFUxID0gRnAuZXFsKEZwLm11bChYMSwgWjIpLCBGcC5tdWwoWDIsIFoxKSk7XG4gICAgICAgICAgICBjb25zdCBVMiA9IEZwLmVxbChGcC5tdWwoWTEsIFoyKSwgRnAubXVsKFkyLCBaMSkpO1xuICAgICAgICAgICAgcmV0dXJuIFUxICYmIFUyO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGbGlwcyBwb2ludCB0byBvbmUgY29ycmVzcG9uZGluZyB0byAoeCwgLXkpIGluIEFmZmluZSBjb29yZGluYXRlcy5cbiAgICAgICAgICovXG4gICAgICAgIG5lZ2F0ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy5weCwgRnAubmVnKHRoaXMucHkpLCB0aGlzLnB6KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW5lcy1Db3N0ZWxsby1CYXRpbmEgZXhjZXB0aW9uLWZyZWUgZG91YmxpbmcgZm9ybXVsYS5cbiAgICAgICAgLy8gVGhlcmUgaXMgMzAlIGZhc3RlciBKYWNvYmlhbiBmb3JtdWxhLCBidXQgaXQgaXMgbm90IGNvbXBsZXRlLlxuICAgICAgICAvLyBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDE1LzEwNjAsIGFsZ29yaXRobSAzXG4gICAgICAgIC8vIENvc3Q6IDhNICsgM1MgKyAzKmEgKyAyKmIzICsgMTVhZGQuXG4gICAgICAgIGRvdWJsZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgYSwgYiB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBjb25zdCBiMyA9IEZwLm11bChiLCBfM24pO1xuICAgICAgICAgICAgY29uc3QgeyBweDogWDEsIHB5OiBZMSwgcHo6IFoxIH0gPSB0aGlzO1xuICAgICAgICAgICAgbGV0IFgzID0gRnAuWkVSTywgWTMgPSBGcC5aRVJPLCBaMyA9IEZwLlpFUk87IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgbGV0IHQwID0gRnAubXVsKFgxLCBYMSk7IC8vIHN0ZXAgMVxuICAgICAgICAgICAgbGV0IHQxID0gRnAubXVsKFkxLCBZMSk7XG4gICAgICAgICAgICBsZXQgdDIgPSBGcC5tdWwoWjEsIFoxKTtcbiAgICAgICAgICAgIGxldCB0MyA9IEZwLm11bChYMSwgWTEpO1xuICAgICAgICAgICAgdDMgPSBGcC5hZGQodDMsIHQzKTsgLy8gc3RlcCA1XG4gICAgICAgICAgICBaMyA9IEZwLm11bChYMSwgWjEpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWjMsIFozKTtcbiAgICAgICAgICAgIFgzID0gRnAubXVsKGEsIFozKTtcbiAgICAgICAgICAgIFkzID0gRnAubXVsKGIzLCB0Mik7XG4gICAgICAgICAgICBZMyA9IEZwLmFkZChYMywgWTMpOyAvLyBzdGVwIDEwXG4gICAgICAgICAgICBYMyA9IEZwLnN1Yih0MSwgWTMpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQodDEsIFkzKTtcbiAgICAgICAgICAgIFkzID0gRnAubXVsKFgzLCBZMyk7XG4gICAgICAgICAgICBYMyA9IEZwLm11bCh0MywgWDMpO1xuICAgICAgICAgICAgWjMgPSBGcC5tdWwoYjMsIFozKTsgLy8gc3RlcCAxNVxuICAgICAgICAgICAgdDIgPSBGcC5tdWwoYSwgdDIpO1xuICAgICAgICAgICAgdDMgPSBGcC5zdWIodDAsIHQyKTtcbiAgICAgICAgICAgIHQzID0gRnAubXVsKGEsIHQzKTtcbiAgICAgICAgICAgIHQzID0gRnAuYWRkKHQzLCBaMyk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZCh0MCwgdDApOyAvLyBzdGVwIDIwXG4gICAgICAgICAgICB0MCA9IEZwLmFkZChaMywgdDApO1xuICAgICAgICAgICAgdDAgPSBGcC5hZGQodDAsIHQyKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQwLCB0Myk7XG4gICAgICAgICAgICBZMyA9IEZwLmFkZChZMywgdDApO1xuICAgICAgICAgICAgdDIgPSBGcC5tdWwoWTEsIFoxKTsgLy8gc3RlcCAyNVxuICAgICAgICAgICAgdDIgPSBGcC5hZGQodDIsIHQyKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQyLCB0Myk7XG4gICAgICAgICAgICBYMyA9IEZwLnN1YihYMywgdDApO1xuICAgICAgICAgICAgWjMgPSBGcC5tdWwodDIsIHQxKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCBaMyk7IC8vIHN0ZXAgMzBcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCBaMyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KFgzLCBZMywgWjMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbmVzLUNvc3RlbGxvLUJhdGluYSBleGNlcHRpb24tZnJlZSBhZGRpdGlvbiBmb3JtdWxhLlxuICAgICAgICAvLyBUaGVyZSBpcyAzMCUgZmFzdGVyIEphY29iaWFuIGZvcm11bGEsIGJ1dCBpdCBpcyBub3QgY29tcGxldGUuXG4gICAgICAgIC8vIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTUvMTA2MCwgYWxnb3JpdGhtIDFcbiAgICAgICAgLy8gQ29zdDogMTJNICsgMFMgKyAzKmEgKyAzKmIzICsgMjNhZGQuXG4gICAgICAgIGFkZChvdGhlcikge1xuICAgICAgICAgICAgYXNzZXJ0UHJqUG9pbnQob3RoZXIpO1xuICAgICAgICAgICAgY29uc3QgeyBweDogWDEsIHB5OiBZMSwgcHo6IFoxIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgeyBweDogWDIsIHB5OiBZMiwgcHo6IFoyIH0gPSBvdGhlcjtcbiAgICAgICAgICAgIGxldCBYMyA9IEZwLlpFUk8sIFkzID0gRnAuWkVSTywgWjMgPSBGcC5aRVJPOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IGEgPSBDVVJWRS5hO1xuICAgICAgICAgICAgY29uc3QgYjMgPSBGcC5tdWwoQ1VSVkUuYiwgXzNuKTtcbiAgICAgICAgICAgIGxldCB0MCA9IEZwLm11bChYMSwgWDIpOyAvLyBzdGVwIDFcbiAgICAgICAgICAgIGxldCB0MSA9IEZwLm11bChZMSwgWTIpO1xuICAgICAgICAgICAgbGV0IHQyID0gRnAubXVsKFoxLCBaMik7XG4gICAgICAgICAgICBsZXQgdDMgPSBGcC5hZGQoWDEsIFkxKTtcbiAgICAgICAgICAgIGxldCB0NCA9IEZwLmFkZChYMiwgWTIpOyAvLyBzdGVwIDVcbiAgICAgICAgICAgIHQzID0gRnAubXVsKHQzLCB0NCk7XG4gICAgICAgICAgICB0NCA9IEZwLmFkZCh0MCwgdDEpO1xuICAgICAgICAgICAgdDMgPSBGcC5zdWIodDMsIHQ0KTtcbiAgICAgICAgICAgIHQ0ID0gRnAuYWRkKFgxLCBaMSk7XG4gICAgICAgICAgICBsZXQgdDUgPSBGcC5hZGQoWDIsIFoyKTsgLy8gc3RlcCAxMFxuICAgICAgICAgICAgdDQgPSBGcC5tdWwodDQsIHQ1KTtcbiAgICAgICAgICAgIHQ1ID0gRnAuYWRkKHQwLCB0Mik7XG4gICAgICAgICAgICB0NCA9IEZwLnN1Yih0NCwgdDUpO1xuICAgICAgICAgICAgdDUgPSBGcC5hZGQoWTEsIFoxKTtcbiAgICAgICAgICAgIFgzID0gRnAuYWRkKFkyLCBaMik7IC8vIHN0ZXAgMTVcbiAgICAgICAgICAgIHQ1ID0gRnAubXVsKHQ1LCBYMyk7XG4gICAgICAgICAgICBYMyA9IEZwLmFkZCh0MSwgdDIpO1xuICAgICAgICAgICAgdDUgPSBGcC5zdWIodDUsIFgzKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKGEsIHQ0KTtcbiAgICAgICAgICAgIFgzID0gRnAubXVsKGIzLCB0Mik7IC8vIHN0ZXAgMjBcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFgzLCBaMyk7XG4gICAgICAgICAgICBYMyA9IEZwLnN1Yih0MSwgWjMpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQodDEsIFozKTtcbiAgICAgICAgICAgIFkzID0gRnAubXVsKFgzLCBaMyk7XG4gICAgICAgICAgICB0MSA9IEZwLmFkZCh0MCwgdDApOyAvLyBzdGVwIDI1XG4gICAgICAgICAgICB0MSA9IEZwLmFkZCh0MSwgdDApO1xuICAgICAgICAgICAgdDIgPSBGcC5tdWwoYSwgdDIpO1xuICAgICAgICAgICAgdDQgPSBGcC5tdWwoYjMsIHQ0KTtcbiAgICAgICAgICAgIHQxID0gRnAuYWRkKHQxLCB0Mik7XG4gICAgICAgICAgICB0MiA9IEZwLnN1Yih0MCwgdDIpOyAvLyBzdGVwIDMwXG4gICAgICAgICAgICB0MiA9IEZwLm11bChhLCB0Mik7XG4gICAgICAgICAgICB0NCA9IEZwLmFkZCh0NCwgdDIpO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDEsIHQ0KTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKFkzLCB0MCk7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0NSwgdDQpOyAvLyBzdGVwIDM1XG4gICAgICAgICAgICBYMyA9IEZwLm11bCh0MywgWDMpO1xuICAgICAgICAgICAgWDMgPSBGcC5zdWIoWDMsIHQwKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQzLCB0MSk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bCh0NSwgWjMpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWjMsIHQwKTsgLy8gc3RlcCA0MFxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChYMywgWTMsIFozKTtcbiAgICAgICAgfVxuICAgICAgICBzdWJ0cmFjdChvdGhlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKG90aGVyLm5lZ2F0ZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBpczAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lcXVhbHMoUG9pbnQuWkVSTyk7XG4gICAgICAgIH1cbiAgICAgICAgd05BRihuKSB7XG4gICAgICAgICAgICByZXR1cm4gd25hZi53TkFGQ2FjaGVkKHRoaXMsIHBvaW50UHJlY29tcHV0ZXMsIG4sIChjb21wKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9JbnYgPSBGcC5pbnZlcnRCYXRjaChjb21wLm1hcCgocCkgPT4gcC5weikpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21wLm1hcCgocCwgaSkgPT4gcC50b0FmZmluZSh0b0ludltpXSkpLm1hcChQb2ludC5mcm9tQWZmaW5lKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOb24tY29uc3RhbnQtdGltZSBtdWx0aXBsaWNhdGlvbi4gVXNlcyBkb3VibGUtYW5kLWFkZCBhbGdvcml0aG0uXG4gICAgICAgICAqIEl0J3MgZmFzdGVyLCBidXQgc2hvdWxkIG9ubHkgYmUgdXNlZCB3aGVuIHlvdSBkb24ndCBjYXJlIGFib3V0XG4gICAgICAgICAqIGFuIGV4cG9zZWQgcHJpdmF0ZSBrZXkgZS5nLiBzaWcgdmVyaWZpY2F0aW9uLCB3aGljaCB3b3JrcyBvdmVyICpwdWJsaWMqIGtleXMuXG4gICAgICAgICAqL1xuICAgICAgICBtdWx0aXBseVVuc2FmZShuKSB7XG4gICAgICAgICAgICBjb25zdCBJID0gUG9pbnQuWkVSTztcbiAgICAgICAgICAgIGlmIChuID09PSBfMG4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIEk7XG4gICAgICAgICAgICBhc3NlcnRHRShuKTsgLy8gV2lsbCB0aHJvdyBvbiAwXG4gICAgICAgICAgICBpZiAobiA9PT0gXzFuKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgY29uc3QgeyBlbmRvIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGlmICghZW5kbylcbiAgICAgICAgICAgICAgICByZXR1cm4gd25hZi51bnNhZmVMYWRkZXIodGhpcywgbik7XG4gICAgICAgICAgICAvLyBBcHBseSBlbmRvbW9ycGhpc21cbiAgICAgICAgICAgIGxldCB7IGsxbmVnLCBrMSwgazJuZWcsIGsyIH0gPSBlbmRvLnNwbGl0U2NhbGFyKG4pO1xuICAgICAgICAgICAgbGV0IGsxcCA9IEk7XG4gICAgICAgICAgICBsZXQgazJwID0gSTtcbiAgICAgICAgICAgIGxldCBkID0gdGhpcztcbiAgICAgICAgICAgIHdoaWxlIChrMSA+IF8wbiB8fCBrMiA+IF8wbikge1xuICAgICAgICAgICAgICAgIGlmIChrMSAmIF8xbilcbiAgICAgICAgICAgICAgICAgICAgazFwID0gazFwLmFkZChkKTtcbiAgICAgICAgICAgICAgICBpZiAoazIgJiBfMW4pXG4gICAgICAgICAgICAgICAgICAgIGsycCA9IGsycC5hZGQoZCk7XG4gICAgICAgICAgICAgICAgZCA9IGQuZG91YmxlKCk7XG4gICAgICAgICAgICAgICAgazEgPj49IF8xbjtcbiAgICAgICAgICAgICAgICBrMiA+Pj0gXzFuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGsxbmVnKVxuICAgICAgICAgICAgICAgIGsxcCA9IGsxcC5uZWdhdGUoKTtcbiAgICAgICAgICAgIGlmIChrMm5lZylcbiAgICAgICAgICAgICAgICBrMnAgPSBrMnAubmVnYXRlKCk7XG4gICAgICAgICAgICBrMnAgPSBuZXcgUG9pbnQoRnAubXVsKGsycC5weCwgZW5kby5iZXRhKSwgazJwLnB5LCBrMnAucHopO1xuICAgICAgICAgICAgcmV0dXJuIGsxcC5hZGQoazJwKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RhbnQgdGltZSBtdWx0aXBsaWNhdGlvbi5cbiAgICAgICAgICogVXNlcyB3TkFGIG1ldGhvZC4gV2luZG93ZWQgbWV0aG9kIG1heSBiZSAxMCUgZmFzdGVyLFxuICAgICAgICAgKiBidXQgdGFrZXMgMnggbG9uZ2VyIHRvIGdlbmVyYXRlIGFuZCBjb25zdW1lcyAyeCBtZW1vcnkuXG4gICAgICAgICAqIFVzZXMgcHJlY29tcHV0ZXMgd2hlbiBhdmFpbGFibGUuXG4gICAgICAgICAqIFVzZXMgZW5kb21vcnBoaXNtIGZvciBLb2JsaXR6IGN1cnZlcy5cbiAgICAgICAgICogQHBhcmFtIHNjYWxhciBieSB3aGljaCB0aGUgcG9pbnQgd291bGQgYmUgbXVsdGlwbGllZFxuICAgICAgICAgKiBAcmV0dXJucyBOZXcgcG9pbnRcbiAgICAgICAgICovXG4gICAgICAgIG11bHRpcGx5KHNjYWxhcikge1xuICAgICAgICAgICAgYXNzZXJ0R0Uoc2NhbGFyKTtcbiAgICAgICAgICAgIGxldCBuID0gc2NhbGFyO1xuICAgICAgICAgICAgbGV0IHBvaW50LCBmYWtlOyAvLyBGYWtlIHBvaW50IGlzIHVzZWQgdG8gY29uc3QtdGltZSBtdWx0XG4gICAgICAgICAgICBjb25zdCB7IGVuZG8gfSA9IENVUlZFO1xuICAgICAgICAgICAgaWYgKGVuZG8pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGsxbmVnLCBrMSwgazJuZWcsIGsyIH0gPSBlbmRvLnNwbGl0U2NhbGFyKG4pO1xuICAgICAgICAgICAgICAgIGxldCB7IHA6IGsxcCwgZjogZjFwIH0gPSB0aGlzLndOQUYoazEpO1xuICAgICAgICAgICAgICAgIGxldCB7IHA6IGsycCwgZjogZjJwIH0gPSB0aGlzLndOQUYoazIpO1xuICAgICAgICAgICAgICAgIGsxcCA9IHduYWYuY29uc3RUaW1lTmVnYXRlKGsxbmVnLCBrMXApO1xuICAgICAgICAgICAgICAgIGsycCA9IHduYWYuY29uc3RUaW1lTmVnYXRlKGsybmVnLCBrMnApO1xuICAgICAgICAgICAgICAgIGsycCA9IG5ldyBQb2ludChGcC5tdWwoazJwLnB4LCBlbmRvLmJldGEpLCBrMnAucHksIGsycC5weik7XG4gICAgICAgICAgICAgICAgcG9pbnQgPSBrMXAuYWRkKGsycCk7XG4gICAgICAgICAgICAgICAgZmFrZSA9IGYxcC5hZGQoZjJwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcCwgZiB9ID0gdGhpcy53TkFGKG4pO1xuICAgICAgICAgICAgICAgIHBvaW50ID0gcDtcbiAgICAgICAgICAgICAgICBmYWtlID0gZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSBgemAgZm9yIGJvdGggcG9pbnRzLCBidXQgcmV0dXJuIG9ubHkgcmVhbCBvbmVcbiAgICAgICAgICAgIHJldHVybiBQb2ludC5ub3JtYWxpemVaKFtwb2ludCwgZmFrZV0pWzBdO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFZmZpY2llbnRseSBjYWxjdWxhdGUgYGFQICsgYlFgLiBVbnNhZmUsIGNhbiBleHBvc2UgcHJpdmF0ZSBrZXksIGlmIHVzZWQgaW5jb3JyZWN0bHkuXG4gICAgICAgICAqIE5vdCB1c2luZyBTdHJhdXNzLVNoYW1pciB0cmljazogcHJlY29tcHV0YXRpb24gdGFibGVzIGFyZSBmYXN0ZXIuXG4gICAgICAgICAqIFRoZSB0cmljayBjb3VsZCBiZSB1c2VmdWwgaWYgYm90aCBQIGFuZCBRIGFyZSBub3QgRyAobm90IGluIG91ciBjYXNlKS5cbiAgICAgICAgICogQHJldHVybnMgbm9uLXplcm8gYWZmaW5lIHBvaW50XG4gICAgICAgICAqL1xuICAgICAgICBtdWx0aXBseUFuZEFkZFVuc2FmZShRLCBhLCBiKSB7XG4gICAgICAgICAgICBjb25zdCBHID0gUG9pbnQuQkFTRTsgLy8gTm8gU3RyYXVzcy1TaGFtaXIgdHJpY2s6IHdlIGhhdmUgMTAlIGZhc3RlciBHIHByZWNvbXB1dGVzXG4gICAgICAgICAgICBjb25zdCBtdWwgPSAoUCwgYSAvLyBTZWxlY3QgZmFzdGVyIG11bHRpcGx5KCkgbWV0aG9kXG4gICAgICAgICAgICApID0+IChhID09PSBfMG4gfHwgYSA9PT0gXzFuIHx8ICFQLmVxdWFscyhHKSA/IFAubXVsdGlwbHlVbnNhZmUoYSkgOiBQLm11bHRpcGx5KGEpKTtcbiAgICAgICAgICAgIGNvbnN0IHN1bSA9IG11bCh0aGlzLCBhKS5hZGQobXVsKFEsIGIpKTtcbiAgICAgICAgICAgIHJldHVybiBzdW0uaXMwKCkgPyB1bmRlZmluZWQgOiBzdW07XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29udmVydHMgUHJvamVjdGl2ZSBwb2ludCB0byBhZmZpbmUgKHgsIHkpIGNvb3JkaW5hdGVzLlxuICAgICAgICAvLyBDYW4gYWNjZXB0IHByZWNvbXB1dGVkIFpeLTEgLSBmb3IgZXhhbXBsZSwgZnJvbSBpbnZlcnRCYXRjaC5cbiAgICAgICAgLy8gKHgsIHksIHopIOKIiyAoeD14L3osIHk9eS96KVxuICAgICAgICB0b0FmZmluZShpeikge1xuICAgICAgICAgICAgY29uc3QgeyBweDogeCwgcHk6IHksIHB6OiB6IH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgaXMwID0gdGhpcy5pczAoKTtcbiAgICAgICAgICAgIC8vIElmIGludlogd2FzIDAsIHdlIHJldHVybiB6ZXJvIHBvaW50LiBIb3dldmVyIHdlIHN0aWxsIHdhbnQgdG8gZXhlY3V0ZVxuICAgICAgICAgICAgLy8gYWxsIG9wZXJhdGlvbnMsIHNvIHdlIHJlcGxhY2UgaW52WiB3aXRoIGEgcmFuZG9tIG51bWJlciwgMS5cbiAgICAgICAgICAgIGlmIChpeiA9PSBudWxsKVxuICAgICAgICAgICAgICAgIGl6ID0gaXMwID8gRnAuT05FIDogRnAuaW52KHopO1xuICAgICAgICAgICAgY29uc3QgYXggPSBGcC5tdWwoeCwgaXopO1xuICAgICAgICAgICAgY29uc3QgYXkgPSBGcC5tdWwoeSwgaXopO1xuICAgICAgICAgICAgY29uc3QgenogPSBGcC5tdWwoeiwgaXopO1xuICAgICAgICAgICAgaWYgKGlzMClcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4OiBGcC5aRVJPLCB5OiBGcC5aRVJPIH07XG4gICAgICAgICAgICBpZiAoIUZwLmVxbCh6eiwgRnAuT05FKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludlogd2FzIGludmFsaWQnKTtcbiAgICAgICAgICAgIHJldHVybiB7IHg6IGF4LCB5OiBheSB9O1xuICAgICAgICB9XG4gICAgICAgIGlzVG9yc2lvbkZyZWUoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGg6IGNvZmFjdG9yLCBpc1RvcnNpb25GcmVlIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGlmIChjb2ZhY3RvciA9PT0gXzFuKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBObyBzdWJncm91cHMsIGFsd2F5cyB0b3JzaW9uLWZyZWVcbiAgICAgICAgICAgIGlmIChpc1RvcnNpb25GcmVlKVxuICAgICAgICAgICAgICAgIHJldHVybiBpc1RvcnNpb25GcmVlKFBvaW50LCB0aGlzKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaXNUb3JzaW9uRnJlZSgpIGhhcyBub3QgYmVlbiBkZWNsYXJlZCBmb3IgdGhlIGVsbGlwdGljIGN1cnZlJyk7XG4gICAgICAgIH1cbiAgICAgICAgY2xlYXJDb2ZhY3RvcigpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaDogY29mYWN0b3IsIGNsZWFyQ29mYWN0b3IgfSA9IENVUlZFO1xuICAgICAgICAgICAgaWYgKGNvZmFjdG9yID09PSBfMW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7IC8vIEZhc3QtcGF0aFxuICAgICAgICAgICAgaWYgKGNsZWFyQ29mYWN0b3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsZWFyQ29mYWN0b3IoUG9pbnQsIHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHlVbnNhZmUoQ1VSVkUuaCk7XG4gICAgICAgIH1cbiAgICAgICAgdG9SYXdCeXRlcyhpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gdG9CeXRlcyhQb2ludCwgdGhpcywgaXNDb21wcmVzc2VkKTtcbiAgICAgICAgfVxuICAgICAgICB0b0hleChpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdXQuYnl0ZXNUb0hleCh0aGlzLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgUG9pbnQuQkFTRSA9IG5ldyBQb2ludChDVVJWRS5HeCwgQ1VSVkUuR3ksIEZwLk9ORSk7XG4gICAgUG9pbnQuWkVSTyA9IG5ldyBQb2ludChGcC5aRVJPLCBGcC5PTkUsIEZwLlpFUk8pO1xuICAgIGNvbnN0IF9iaXRzID0gQ1VSVkUubkJpdExlbmd0aDtcbiAgICBjb25zdCB3bmFmID0gd05BRihQb2ludCwgQ1VSVkUuZW5kbyA/IE1hdGguY2VpbChfYml0cyAvIDIpIDogX2JpdHMpO1xuICAgIC8vIFZhbGlkYXRlIGlmIGdlbmVyYXRvciBwb2ludCBpcyBvbiBjdXJ2ZVxuICAgIHJldHVybiB7XG4gICAgICAgIENVUlZFLFxuICAgICAgICBQcm9qZWN0aXZlUG9pbnQ6IFBvaW50LFxuICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyLFxuICAgICAgICB3ZWllcnN0cmFzc0VxdWF0aW9uLFxuICAgICAgICBpc1dpdGhpbkN1cnZlT3JkZXIsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlT3B0cyhjdXJ2ZSkge1xuICAgIGNvbnN0IG9wdHMgPSB2YWxpZGF0ZUJhc2ljKGN1cnZlKTtcbiAgICB1dC52YWxpZGF0ZU9iamVjdChvcHRzLCB7XG4gICAgICAgIGhhc2g6ICdoYXNoJyxcbiAgICAgICAgaG1hYzogJ2Z1bmN0aW9uJyxcbiAgICAgICAgcmFuZG9tQnl0ZXM6ICdmdW5jdGlvbicsXG4gICAgfSwge1xuICAgICAgICBiaXRzMmludDogJ2Z1bmN0aW9uJyxcbiAgICAgICAgYml0czJpbnRfbW9kTjogJ2Z1bmN0aW9uJyxcbiAgICAgICAgbG93UzogJ2Jvb2xlYW4nLFxuICAgIH0pO1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHsgbG93UzogdHJ1ZSwgLi4ub3B0cyB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB3ZWllcnN0cmFzcyhjdXJ2ZURlZikge1xuICAgIGNvbnN0IENVUlZFID0gdmFsaWRhdGVPcHRzKGN1cnZlRGVmKTtcbiAgICBjb25zdCB7IEZwLCBuOiBDVVJWRV9PUkRFUiB9ID0gQ1VSVkU7XG4gICAgY29uc3QgY29tcHJlc3NlZExlbiA9IEZwLkJZVEVTICsgMTsgLy8gZS5nLiAzMyBmb3IgMzJcbiAgICBjb25zdCB1bmNvbXByZXNzZWRMZW4gPSAyICogRnAuQllURVMgKyAxOyAvLyBlLmcuIDY1IGZvciAzMlxuICAgIGZ1bmN0aW9uIGlzVmFsaWRGaWVsZEVsZW1lbnQobnVtKSB7XG4gICAgICAgIHJldHVybiBfMG4gPCBudW0gJiYgbnVtIDwgRnAuT1JERVI7IC8vIDAgaXMgYmFubmVkIHNpbmNlIGl0J3Mgbm90IGludmVydGlibGUgRkVcbiAgICB9XG4gICAgZnVuY3Rpb24gbW9kTihhKSB7XG4gICAgICAgIHJldHVybiBtb2QubW9kKGEsIENVUlZFX09SREVSKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW52TihhKSB7XG4gICAgICAgIHJldHVybiBtb2QuaW52ZXJ0KGEsIENVUlZFX09SREVSKTtcbiAgICB9XG4gICAgY29uc3QgeyBQcm9qZWN0aXZlUG9pbnQ6IFBvaW50LCBub3JtUHJpdmF0ZUtleVRvU2NhbGFyLCB3ZWllcnN0cmFzc0VxdWF0aW9uLCBpc1dpdGhpbkN1cnZlT3JkZXIsIH0gPSB3ZWllcnN0cmFzc1BvaW50cyh7XG4gICAgICAgIC4uLkNVUlZFLFxuICAgICAgICB0b0J5dGVzKF9jLCBwb2ludCwgaXNDb21wcmVzc2VkKSB7XG4gICAgICAgICAgICBjb25zdCBhID0gcG9pbnQudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIGNvbnN0IHggPSBGcC50b0J5dGVzKGEueCk7XG4gICAgICAgICAgICBjb25zdCBjYXQgPSB1dC5jb25jYXRCeXRlcztcbiAgICAgICAgICAgIGlmIChpc0NvbXByZXNzZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2F0KFVpbnQ4QXJyYXkuZnJvbShbcG9pbnQuaGFzRXZlblkoKSA/IDB4MDIgOiAweDAzXSksIHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhdChVaW50OEFycmF5LmZyb20oWzB4MDRdKSwgeCwgRnAudG9CeXRlcyhhLnkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZnJvbUJ5dGVzKGJ5dGVzKSB7XG4gICAgICAgICAgICBjb25zdCBsZW4gPSBieXRlcy5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBoZWFkID0gYnl0ZXNbMF07XG4gICAgICAgICAgICBjb25zdCB0YWlsID0gYnl0ZXMuc3ViYXJyYXkoMSk7XG4gICAgICAgICAgICAvLyB0aGlzLmFzc2VydFZhbGlkaXR5KCkgaXMgZG9uZSBpbnNpZGUgb2YgZnJvbUhleFxuICAgICAgICAgICAgaWYgKGxlbiA9PT0gY29tcHJlc3NlZExlbiAmJiAoaGVhZCA9PT0gMHgwMiB8fCBoZWFkID09PSAweDAzKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSB1dC5ieXRlc1RvTnVtYmVyQkUodGFpbCk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkRmllbGRFbGVtZW50KHgpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvaW50IGlzIG5vdCBvbiBjdXJ2ZScpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkyID0gd2VpZXJzdHJhc3NFcXVhdGlvbih4KTsgLy8gecKyID0geMKzICsgYXggKyBiXG4gICAgICAgICAgICAgICAgbGV0IHk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgeSA9IEZwLnNxcnQoeTIpOyAvLyB5ID0gecKyIF4gKHArMSkvNFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoc3FydEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1ZmZpeCA9IHNxcnRFcnJvciBpbnN0YW5jZW9mIEVycm9yID8gJzogJyArIHNxcnRFcnJvci5tZXNzYWdlIDogJyc7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUG9pbnQgaXMgbm90IG9uIGN1cnZlJyArIHN1ZmZpeCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGlzWU9kZCA9ICh5ICYgXzFuKSA9PT0gXzFuO1xuICAgICAgICAgICAgICAgIC8vIEVDRFNBXG4gICAgICAgICAgICAgICAgY29uc3QgaXNIZWFkT2RkID0gKGhlYWQgJiAxKSA9PT0gMTtcbiAgICAgICAgICAgICAgICBpZiAoaXNIZWFkT2RkICE9PSBpc1lPZGQpXG4gICAgICAgICAgICAgICAgICAgIHkgPSBGcC5uZWcoeSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobGVuID09PSB1bmNvbXByZXNzZWRMZW4gJiYgaGVhZCA9PT0gMHgwNCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSBGcC5mcm9tQnl0ZXModGFpbC5zdWJhcnJheSgwLCBGcC5CWVRFUykpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBGcC5mcm9tQnl0ZXModGFpbC5zdWJhcnJheShGcC5CWVRFUywgMiAqIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQb2ludCBvZiBsZW5ndGggJHtsZW59IHdhcyBpbnZhbGlkLiBFeHBlY3RlZCAke2NvbXByZXNzZWRMZW59IGNvbXByZXNzZWQgYnl0ZXMgb3IgJHt1bmNvbXByZXNzZWRMZW59IHVuY29tcHJlc3NlZCBieXRlc2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH0pO1xuICAgIGNvbnN0IG51bVRvTkJ5dGVTdHIgPSAobnVtKSA9PiB1dC5ieXRlc1RvSGV4KHV0Lm51bWJlclRvQnl0ZXNCRShudW0sIENVUlZFLm5CeXRlTGVuZ3RoKSk7XG4gICAgZnVuY3Rpb24gaXNCaWdnZXJUaGFuSGFsZk9yZGVyKG51bWJlcikge1xuICAgICAgICBjb25zdCBIQUxGID0gQ1VSVkVfT1JERVIgPj4gXzFuO1xuICAgICAgICByZXR1cm4gbnVtYmVyID4gSEFMRjtcbiAgICB9XG4gICAgZnVuY3Rpb24gbm9ybWFsaXplUyhzKSB7XG4gICAgICAgIHJldHVybiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIocykgPyBtb2ROKC1zKSA6IHM7XG4gICAgfVxuICAgIC8vIHNsaWNlIGJ5dGVzIG51bVxuICAgIGNvbnN0IHNsY051bSA9IChiLCBmcm9tLCB0bykgPT4gdXQuYnl0ZXNUb051bWJlckJFKGIuc2xpY2UoZnJvbSwgdG8pKTtcbiAgICAvKipcbiAgICAgKiBFQ0RTQSBzaWduYXR1cmUgd2l0aCBpdHMgKHIsIHMpIHByb3BlcnRpZXMuIFN1cHBvcnRzIERFUiAmIGNvbXBhY3QgcmVwcmVzZW50YXRpb25zLlxuICAgICAqL1xuICAgIGNsYXNzIFNpZ25hdHVyZSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHIsIHMsIHJlY292ZXJ5KSB7XG4gICAgICAgICAgICB0aGlzLnIgPSByO1xuICAgICAgICAgICAgdGhpcy5zID0gcztcbiAgICAgICAgICAgIHRoaXMucmVjb3ZlcnkgPSByZWNvdmVyeTtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwYWlyIChieXRlcyBvZiByLCBieXRlcyBvZiBzKVxuICAgICAgICBzdGF0aWMgZnJvbUNvbXBhY3QoaGV4KSB7XG4gICAgICAgICAgICBjb25zdCBsID0gQ1VSVkUubkJ5dGVMZW5ndGg7XG4gICAgICAgICAgICBoZXggPSBlbnN1cmVCeXRlcygnY29tcGFjdFNpZ25hdHVyZScsIGhleCwgbCAqIDIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUoc2xjTnVtKGhleCwgMCwgbCksIHNsY051bShoZXgsIGwsIDIgKiBsKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gREVSIGVuY29kZWQgRUNEU0Egc2lnbmF0dXJlXG4gICAgICAgIC8vIGh0dHBzOi8vYml0Y29pbi5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvNTc2NDQvd2hhdC1hcmUtdGhlLXBhcnRzLW9mLWEtYml0Y29pbi10cmFuc2FjdGlvbi1pbnB1dC1zY3JpcHRcbiAgICAgICAgc3RhdGljIGZyb21ERVIoaGV4KSB7XG4gICAgICAgICAgICBjb25zdCB7IHIsIHMgfSA9IERFUi50b1NpZyhlbnN1cmVCeXRlcygnREVSJywgaGV4KSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShyLCBzKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRWYWxpZGl0eSgpIHtcbiAgICAgICAgICAgIC8vIGNhbiB1c2UgYXNzZXJ0R0UgaGVyZVxuICAgICAgICAgICAgaWYgKCFpc1dpdGhpbkN1cnZlT3JkZXIodGhpcy5yKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3IgbXVzdCBiZSAwIDwgciA8IENVUlZFLm4nKTtcbiAgICAgICAgICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKHRoaXMucykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzIG11c3QgYmUgMCA8IHMgPCBDVVJWRS5uJyk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkUmVjb3ZlcnlCaXQocmVjb3ZlcnkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHRoaXMuciwgdGhpcy5zLCByZWNvdmVyeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVjb3ZlclB1YmxpY0tleShtc2dIYXNoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHIsIHMsIHJlY292ZXJ5OiByZWMgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBoID0gYml0czJpbnRfbW9kTihlbnN1cmVCeXRlcygnbXNnSGFzaCcsIG1zZ0hhc2gpKTsgLy8gVHJ1bmNhdGUgaGFzaFxuICAgICAgICAgICAgaWYgKHJlYyA9PSBudWxsIHx8ICFbMCwgMSwgMiwgM10uaW5jbHVkZXMocmVjKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlY292ZXJ5IGlkIGludmFsaWQnKTtcbiAgICAgICAgICAgIGNvbnN0IHJhZGogPSByZWMgPT09IDIgfHwgcmVjID09PSAzID8gciArIENVUlZFLm4gOiByO1xuICAgICAgICAgICAgaWYgKHJhZGogPj0gRnAuT1JERVIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWNvdmVyeSBpZCAyIG9yIDMgaW52YWxpZCcpO1xuICAgICAgICAgICAgY29uc3QgcHJlZml4ID0gKHJlYyAmIDEpID09PSAwID8gJzAyJyA6ICcwMyc7XG4gICAgICAgICAgICBjb25zdCBSID0gUG9pbnQuZnJvbUhleChwcmVmaXggKyBudW1Ub05CeXRlU3RyKHJhZGopKTtcbiAgICAgICAgICAgIGNvbnN0IGlyID0gaW52TihyYWRqKTsgLy8gcl4tMVxuICAgICAgICAgICAgY29uc3QgdTEgPSBtb2ROKC1oICogaXIpOyAvLyAtaHJeLTFcbiAgICAgICAgICAgIGNvbnN0IHUyID0gbW9kTihzICogaXIpOyAvLyBzcl4tMVxuICAgICAgICAgICAgY29uc3QgUSA9IFBvaW50LkJBU0UubXVsdGlwbHlBbmRBZGRVbnNhZmUoUiwgdTEsIHUyKTsgLy8gKHNyXi0xKVItKGhyXi0xKUcgPSAtKGhyXi0xKUcgKyAoc3JeLTEpXG4gICAgICAgICAgICBpZiAoIVEpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwb2ludCBhdCBpbmZpbmlmeScpOyAvLyB1bnNhZmUgaXMgZmluZTogbm8gcHJpdiBkYXRhIGxlYWtlZFxuICAgICAgICAgICAgUS5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2lnbmF0dXJlcyBzaG91bGQgYmUgbG93LXMsIHRvIHByZXZlbnQgbWFsbGVhYmlsaXR5LlxuICAgICAgICBoYXNIaWdoUygpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIodGhpcy5zKTtcbiAgICAgICAgfVxuICAgICAgICBub3JtYWxpemVTKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFzSGlnaFMoKSA/IG5ldyBTaWduYXR1cmUodGhpcy5yLCBtb2ROKC10aGlzLnMpLCB0aGlzLnJlY292ZXJ5KSA6IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gREVSLWVuY29kZWRcbiAgICAgICAgdG9ERVJSYXdCeXRlcygpIHtcbiAgICAgICAgICAgIHJldHVybiB1dC5oZXhUb0J5dGVzKHRoaXMudG9ERVJIZXgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9ERVJIZXgoKSB7XG4gICAgICAgICAgICByZXR1cm4gREVSLmhleEZyb21TaWcoeyByOiB0aGlzLnIsIHM6IHRoaXMucyB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwYWRkZWQgYnl0ZXMgb2YgciwgdGhlbiBwYWRkZWQgYnl0ZXMgb2Ygc1xuICAgICAgICB0b0NvbXBhY3RSYXdCeXRlcygpIHtcbiAgICAgICAgICAgIHJldHVybiB1dC5oZXhUb0J5dGVzKHRoaXMudG9Db21wYWN0SGV4KCkpO1xuICAgICAgICB9XG4gICAgICAgIHRvQ29tcGFjdEhleCgpIHtcbiAgICAgICAgICAgIHJldHVybiBudW1Ub05CeXRlU3RyKHRoaXMucikgKyBudW1Ub05CeXRlU3RyKHRoaXMucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdXRpbHMgPSB7XG4gICAgICAgIGlzVmFsaWRQcml2YXRlS2V5KHByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlS2V5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbm9ybVByaXZhdGVLZXlUb1NjYWxhcjogbm9ybVByaXZhdGVLZXlUb1NjYWxhcixcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb2R1Y2VzIGNyeXB0b2dyYXBoaWNhbGx5IHNlY3VyZSBwcml2YXRlIGtleSBmcm9tIHJhbmRvbSBvZiBzaXplXG4gICAgICAgICAqIChncm91cExlbiArIGNlaWwoZ3JvdXBMZW4gLyAyKSkgd2l0aCBtb2R1bG8gYmlhcyBiZWluZyBuZWdsaWdpYmxlLlxuICAgICAgICAgKi9cbiAgICAgICAgcmFuZG9tUHJpdmF0ZUtleTogKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gbW9kLmdldE1pbkhhc2hMZW5ndGgoQ1VSVkUubik7XG4gICAgICAgICAgICByZXR1cm4gbW9kLm1hcEhhc2hUb0ZpZWxkKENVUlZFLnJhbmRvbUJ5dGVzKGxlbmd0aCksIENVUlZFLm4pO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBwcmVjb21wdXRlIHRhYmxlIGZvciBhbiBhcmJpdHJhcnkgRUMgcG9pbnQuIE1ha2VzIHBvaW50IFwiY2FjaGVkXCIuXG4gICAgICAgICAqIEFsbG93cyB0byBtYXNzaXZlbHkgc3BlZWQtdXAgYHBvaW50Lm11bHRpcGx5KHNjYWxhcilgLlxuICAgICAgICAgKiBAcmV0dXJucyBjYWNoZWQgcG9pbnRcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogY29uc3QgZmFzdCA9IHV0aWxzLnByZWNvbXB1dGUoOCwgUHJvamVjdGl2ZVBvaW50LmZyb21IZXgoc29tZW9uZXNQdWJLZXkpKTtcbiAgICAgICAgICogZmFzdC5tdWx0aXBseShwcml2S2V5KTsgLy8gbXVjaCBmYXN0ZXIgRUNESCBub3dcbiAgICAgICAgICovXG4gICAgICAgIHByZWNvbXB1dGUod2luZG93U2l6ZSA9IDgsIHBvaW50ID0gUG9pbnQuQkFTRSkge1xuICAgICAgICAgICAgcG9pbnQuX3NldFdpbmRvd1NpemUod2luZG93U2l6ZSk7XG4gICAgICAgICAgICBwb2ludC5tdWx0aXBseShCaWdJbnQoMykpOyAvLyAzIGlzIGFyYml0cmFyeSwganVzdCBuZWVkIGFueSBudW1iZXIgaGVyZVxuICAgICAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgICAgICB9LFxuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgcHVibGljIGtleSBmb3IgYSBwcml2YXRlIGtleS4gQ2hlY2tzIGZvciB2YWxpZGl0eSBvZiB0aGUgcHJpdmF0ZSBrZXkuXG4gICAgICogQHBhcmFtIHByaXZhdGVLZXkgcHJpdmF0ZSBrZXlcbiAgICAgKiBAcGFyYW0gaXNDb21wcmVzc2VkIHdoZXRoZXIgdG8gcmV0dXJuIGNvbXBhY3QgKGRlZmF1bHQpLCBvciBmdWxsIGtleVxuICAgICAqIEByZXR1cm5zIFB1YmxpYyBrZXksIGZ1bGwgd2hlbiBpc0NvbXByZXNzZWQ9ZmFsc2U7IHNob3J0IHdoZW4gaXNDb21wcmVzc2VkPXRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRQdWJsaWNLZXkocHJpdmF0ZUtleSwgaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gUG9pbnQuZnJvbVByaXZhdGVLZXkocHJpdmF0ZUtleSkudG9SYXdCeXRlcyhpc0NvbXByZXNzZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBRdWljayBhbmQgZGlydHkgY2hlY2sgZm9yIGl0ZW0gYmVpbmcgcHVibGljIGtleS4gRG9lcyBub3QgdmFsaWRhdGUgaGV4LCBvciBiZWluZyBvbi1jdXJ2ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1Byb2JQdWIoaXRlbSkge1xuICAgICAgICBjb25zdCBhcnIgPSB1dC5pc0J5dGVzKGl0ZW0pO1xuICAgICAgICBjb25zdCBzdHIgPSB0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZyc7XG4gICAgICAgIGNvbnN0IGxlbiA9IChhcnIgfHwgc3RyKSAmJiBpdGVtLmxlbmd0aDtcbiAgICAgICAgaWYgKGFycilcbiAgICAgICAgICAgIHJldHVybiBsZW4gPT09IGNvbXByZXNzZWRMZW4gfHwgbGVuID09PSB1bmNvbXByZXNzZWRMZW47XG4gICAgICAgIGlmIChzdHIpXG4gICAgICAgICAgICByZXR1cm4gbGVuID09PSAyICogY29tcHJlc3NlZExlbiB8fCBsZW4gPT09IDIgKiB1bmNvbXByZXNzZWRMZW47XG4gICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgUG9pbnQpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFQ0RIIChFbGxpcHRpYyBDdXJ2ZSBEaWZmaWUgSGVsbG1hbikuXG4gICAgICogQ29tcHV0ZXMgc2hhcmVkIHB1YmxpYyBrZXkgZnJvbSBwcml2YXRlIGtleSBhbmQgcHVibGljIGtleS5cbiAgICAgKiBDaGVja3M6IDEpIHByaXZhdGUga2V5IHZhbGlkaXR5IDIpIHNoYXJlZCBrZXkgaXMgb24tY3VydmUuXG4gICAgICogRG9lcyBOT1QgaGFzaCB0aGUgcmVzdWx0LlxuICAgICAqIEBwYXJhbSBwcml2YXRlQSBwcml2YXRlIGtleVxuICAgICAqIEBwYXJhbSBwdWJsaWNCIGRpZmZlcmVudCBwdWJsaWMga2V5XG4gICAgICogQHBhcmFtIGlzQ29tcHJlc3NlZCB3aGV0aGVyIHRvIHJldHVybiBjb21wYWN0IChkZWZhdWx0KSwgb3IgZnVsbCBrZXlcbiAgICAgKiBAcmV0dXJucyBzaGFyZWQgcHVibGljIGtleVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFNoYXJlZFNlY3JldChwcml2YXRlQSwgcHVibGljQiwgaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICBpZiAoaXNQcm9iUHViKHByaXZhdGVBKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZmlyc3QgYXJnIG11c3QgYmUgcHJpdmF0ZSBrZXknKTtcbiAgICAgICAgaWYgKCFpc1Byb2JQdWIocHVibGljQikpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NlY29uZCBhcmcgbXVzdCBiZSBwdWJsaWMga2V5Jyk7XG4gICAgICAgIGNvbnN0IGIgPSBQb2ludC5mcm9tSGV4KHB1YmxpY0IpOyAvLyBjaGVjayBmb3IgYmVpbmcgb24tY3VydmVcbiAgICAgICAgcmV0dXJuIGIubXVsdGlwbHkobm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlQSkpLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKTtcbiAgICB9XG4gICAgLy8gUkZDNjk3OTogZW5zdXJlIEVDRFNBIG1zZyBpcyBYIGJ5dGVzIGFuZCA8IE4uIFJGQyBzdWdnZXN0cyBvcHRpb25hbCB0cnVuY2F0aW5nIHZpYSBiaXRzMm9jdGV0cy5cbiAgICAvLyBGSVBTIDE4Ni00IDQuNiBzdWdnZXN0cyB0aGUgbGVmdG1vc3QgbWluKG5CaXRMZW4sIG91dExlbikgYml0cywgd2hpY2ggbWF0Y2hlcyBiaXRzMmludC5cbiAgICAvLyBiaXRzMmludCBjYW4gcHJvZHVjZSByZXM+Tiwgd2UgY2FuIGRvIG1vZChyZXMsIE4pIHNpbmNlIHRoZSBiaXRMZW4gaXMgdGhlIHNhbWUuXG4gICAgLy8gaW50Mm9jdGV0cyBjYW4ndCBiZSB1c2VkOyBwYWRzIHNtYWxsIG1zZ3Mgd2l0aCAwOiB1bmFjY2VwdGF0YmxlIGZvciB0cnVuYyBhcyBwZXIgUkZDIHZlY3RvcnNcbiAgICBjb25zdCBiaXRzMmludCA9IENVUlZFLmJpdHMyaW50IHx8XG4gICAgICAgIGZ1bmN0aW9uIChieXRlcykge1xuICAgICAgICAgICAgLy8gRm9yIGN1cnZlcyB3aXRoIG5CaXRMZW5ndGggJSA4ICE9PSAwOiBiaXRzMm9jdGV0cyhiaXRzMm9jdGV0cyhtKSkgIT09IGJpdHMyb2N0ZXRzKG0pXG4gICAgICAgICAgICAvLyBmb3Igc29tZSBjYXNlcywgc2luY2UgYnl0ZXMubGVuZ3RoICogOCBpcyBub3QgYWN0dWFsIGJpdExlbmd0aC5cbiAgICAgICAgICAgIGNvbnN0IG51bSA9IHV0LmJ5dGVzVG9OdW1iZXJCRShieXRlcyk7IC8vIGNoZWNrIGZvciA9PSB1OCBkb25lIGhlcmVcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gYnl0ZXMubGVuZ3RoICogOCAtIENVUlZFLm5CaXRMZW5ndGg7IC8vIHRydW5jYXRlIHRvIG5CaXRMZW5ndGggbGVmdG1vc3QgYml0c1xuICAgICAgICAgICAgcmV0dXJuIGRlbHRhID4gMCA/IG51bSA+PiBCaWdJbnQoZGVsdGEpIDogbnVtO1xuICAgICAgICB9O1xuICAgIGNvbnN0IGJpdHMyaW50X21vZE4gPSBDVVJWRS5iaXRzMmludF9tb2ROIHx8XG4gICAgICAgIGZ1bmN0aW9uIChieXRlcykge1xuICAgICAgICAgICAgcmV0dXJuIG1vZE4oYml0czJpbnQoYnl0ZXMpKTsgLy8gY2FuJ3QgdXNlIGJ5dGVzVG9OdW1iZXJCRSBoZXJlXG4gICAgICAgIH07XG4gICAgLy8gTk9URTogcGFkcyBvdXRwdXQgd2l0aCB6ZXJvIGFzIHBlciBzcGVjXG4gICAgY29uc3QgT1JERVJfTUFTSyA9IHV0LmJpdE1hc2soQ1VSVkUubkJpdExlbmd0aCk7XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdG8gYnl0ZXMuIENoZWNrcyBpZiBudW0gaW4gYFswLi5PUkRFUl9NQVNLLTFdYCBlLmcuOiBgWzAuLjJeMjU2LTFdYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnQyb2N0ZXRzKG51bSkge1xuICAgICAgICBpZiAodHlwZW9mIG51bSAhPT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JpZ2ludCBleHBlY3RlZCcpO1xuICAgICAgICBpZiAoIShfMG4gPD0gbnVtICYmIG51bSA8IE9SREVSX01BU0spKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBiaWdpbnQgZXhwZWN0ZWQgPCAyXiR7Q1VSVkUubkJpdExlbmd0aH1gKTtcbiAgICAgICAgLy8gd29ya3Mgd2l0aCBvcmRlciwgY2FuIGhhdmUgZGlmZmVyZW50IHNpemUgdGhhbiBudW1Ub0ZpZWxkIVxuICAgICAgICByZXR1cm4gdXQubnVtYmVyVG9CeXRlc0JFKG51bSwgQ1VSVkUubkJ5dGVMZW5ndGgpO1xuICAgIH1cbiAgICAvLyBTdGVwcyBBLCBEIG9mIFJGQzY5NzkgMy4yXG4gICAgLy8gQ3JlYXRlcyBSRkM2OTc5IHNlZWQ7IGNvbnZlcnRzIG1zZy9wcml2S2V5IHRvIG51bWJlcnMuXG4gICAgLy8gVXNlZCBvbmx5IGluIHNpZ24sIG5vdCBpbiB2ZXJpZnkuXG4gICAgLy8gTk9URTogd2UgY2Fubm90IGFzc3VtZSBoZXJlIHRoYXQgbXNnSGFzaCBoYXMgc2FtZSBhbW91bnQgb2YgYnl0ZXMgYXMgY3VydmUgb3JkZXIsIHRoaXMgd2lsbCBiZSB3cm9uZyBhdCBsZWFzdCBmb3IgUDUyMS5cbiAgICAvLyBBbHNvIGl0IGNhbiBiZSBiaWdnZXIgZm9yIFAyMjQgKyBTSEEyNTZcbiAgICBmdW5jdGlvbiBwcmVwU2lnKG1zZ0hhc2gsIHByaXZhdGVLZXksIG9wdHMgPSBkZWZhdWx0U2lnT3B0cykge1xuICAgICAgICBpZiAoWydyZWNvdmVyZWQnLCAnY2Fub25pY2FsJ10uc29tZSgoaykgPT4gayBpbiBvcHRzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbigpIGxlZ2FjeSBvcHRpb25zIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgY29uc3QgeyBoYXNoLCByYW5kb21CeXRlcyB9ID0gQ1VSVkU7XG4gICAgICAgIGxldCB7IGxvd1MsIHByZWhhc2gsIGV4dHJhRW50cm9weTogZW50IH0gPSBvcHRzOyAvLyBnZW5lcmF0ZXMgbG93LXMgc2lncyBieSBkZWZhdWx0XG4gICAgICAgIGlmIChsb3dTID09IG51bGwpXG4gICAgICAgICAgICBsb3dTID0gdHJ1ZTsgLy8gUkZDNjk3OSAzLjI6IHdlIHNraXAgc3RlcCBBLCBiZWNhdXNlIHdlIGFscmVhZHkgcHJvdmlkZSBoYXNoXG4gICAgICAgIG1zZ0hhc2ggPSBlbnN1cmVCeXRlcygnbXNnSGFzaCcsIG1zZ0hhc2gpO1xuICAgICAgICBpZiAocHJlaGFzaClcbiAgICAgICAgICAgIG1zZ0hhc2ggPSBlbnN1cmVCeXRlcygncHJlaGFzaGVkIG1zZ0hhc2gnLCBoYXNoKG1zZ0hhc2gpKTtcbiAgICAgICAgLy8gV2UgY2FuJ3QgbGF0ZXIgY2FsbCBiaXRzMm9jdGV0cywgc2luY2UgbmVzdGVkIGJpdHMyaW50IGlzIGJyb2tlbiBmb3IgY3VydmVzXG4gICAgICAgIC8vIHdpdGggbkJpdExlbmd0aCAlIDggIT09IDAuIEJlY2F1c2Ugb2YgdGhhdCwgd2UgdW53cmFwIGl0IGhlcmUgYXMgaW50Mm9jdGV0cyBjYWxsLlxuICAgICAgICAvLyBjb25zdCBiaXRzMm9jdGV0cyA9IChiaXRzKSA9PiBpbnQyb2N0ZXRzKGJpdHMyaW50X21vZE4oYml0cykpXG4gICAgICAgIGNvbnN0IGgxaW50ID0gYml0czJpbnRfbW9kTihtc2dIYXNoKTtcbiAgICAgICAgY29uc3QgZCA9IG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUtleSk7IC8vIHZhbGlkYXRlIHByaXZhdGUga2V5LCBjb252ZXJ0IHRvIGJpZ2ludFxuICAgICAgICBjb25zdCBzZWVkQXJncyA9IFtpbnQyb2N0ZXRzKGQpLCBpbnQyb2N0ZXRzKGgxaW50KV07XG4gICAgICAgIC8vIGV4dHJhRW50cm9weS4gUkZDNjk3OSAzLjY6IGFkZGl0aW9uYWwgaycgKG9wdGlvbmFsKS5cbiAgICAgICAgaWYgKGVudCAhPSBudWxsICYmIGVudCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIC8vIEsgPSBITUFDX0soViB8fCAweDAwIHx8IGludDJvY3RldHMoeCkgfHwgYml0czJvY3RldHMoaDEpIHx8IGsnKVxuICAgICAgICAgICAgY29uc3QgZSA9IGVudCA9PT0gdHJ1ZSA/IHJhbmRvbUJ5dGVzKEZwLkJZVEVTKSA6IGVudDsgLy8gZ2VuZXJhdGUgcmFuZG9tIGJ5dGVzIE9SIHBhc3MgYXMtaXNcbiAgICAgICAgICAgIHNlZWRBcmdzLnB1c2goZW5zdXJlQnl0ZXMoJ2V4dHJhRW50cm9weScsIGUpKTsgLy8gY2hlY2sgZm9yIGJlaW5nIGJ5dGVzXG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VlZCA9IHV0LmNvbmNhdEJ5dGVzKC4uLnNlZWRBcmdzKTsgLy8gU3RlcCBEIG9mIFJGQzY5NzkgMy4yXG4gICAgICAgIGNvbnN0IG0gPSBoMWludDsgLy8gTk9URTogbm8gbmVlZCB0byBjYWxsIGJpdHMyaW50IHNlY29uZCB0aW1lIGhlcmUsIGl0IGlzIGluc2lkZSB0cnVuY2F0ZUhhc2ghXG4gICAgICAgIC8vIENvbnZlcnRzIHNpZ25hdHVyZSBwYXJhbXMgaW50byBwb2ludCB3IHIvcywgY2hlY2tzIHJlc3VsdCBmb3IgdmFsaWRpdHkuXG4gICAgICAgIGZ1bmN0aW9uIGsyc2lnKGtCeXRlcykge1xuICAgICAgICAgICAgLy8gUkZDIDY5NzkgU2VjdGlvbiAzLjIsIHN0ZXAgMzogayA9IGJpdHMyaW50KFQpXG4gICAgICAgICAgICBjb25zdCBrID0gYml0czJpbnQoa0J5dGVzKTsgLy8gQ2Fubm90IHVzZSBmaWVsZHMgbWV0aG9kcywgc2luY2UgaXQgaXMgZ3JvdXAgZWxlbWVudFxuICAgICAgICAgICAgaWYgKCFpc1dpdGhpbkN1cnZlT3JkZXIoaykpXG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBJbXBvcnRhbnQ6IGFsbCBtb2QoKSBjYWxscyBoZXJlIG11c3QgYmUgZG9uZSBvdmVyIE5cbiAgICAgICAgICAgIGNvbnN0IGlrID0gaW52TihrKTsgLy8ga14tMSBtb2QgblxuICAgICAgICAgICAgY29uc3QgcSA9IFBvaW50LkJBU0UubXVsdGlwbHkoaykudG9BZmZpbmUoKTsgLy8gcSA9IEdrXG4gICAgICAgICAgICBjb25zdCByID0gbW9kTihxLngpOyAvLyByID0gcS54IG1vZCBuXG4gICAgICAgICAgICBpZiAociA9PT0gXzBuKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8vIENhbiB1c2Ugc2NhbGFyIGJsaW5kaW5nIGJeLTEoYm0gKyBiZHIpIHdoZXJlIGIg4oiIIFsxLHHiiJIxXSBhY2NvcmRpbmcgdG9cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vdGNoZXMuaWFjci5vcmcvaW5kZXgucGhwL1RDSEVTL2FydGljbGUvdmlldy83MzM3LzY1MDkuIFdlJ3ZlIGRlY2lkZWQgYWdhaW5zdCBpdDpcbiAgICAgICAgICAgIC8vIGEpIGRlcGVuZGVuY3kgb24gQ1NQUk5HIGIpIDE1JSBzbG93ZG93biBjKSBkb2Vzbid0IHJlYWxseSBoZWxwIHNpbmNlIGJpZ2ludHMgYXJlIG5vdCBDVFxuICAgICAgICAgICAgY29uc3QgcyA9IG1vZE4oaWsgKiBtb2ROKG0gKyByICogZCkpOyAvLyBOb3QgdXNpbmcgYmxpbmRpbmcgaGVyZVxuICAgICAgICAgICAgaWYgKHMgPT09IF8wbilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgcmVjb3ZlcnkgPSAocS54ID09PSByID8gMCA6IDIpIHwgTnVtYmVyKHEueSAmIF8xbik7IC8vIHJlY292ZXJ5IGJpdCAoMiBvciAzLCB3aGVuIHEueCA+IG4pXG4gICAgICAgICAgICBsZXQgbm9ybVMgPSBzO1xuICAgICAgICAgICAgaWYgKGxvd1MgJiYgaXNCaWdnZXJUaGFuSGFsZk9yZGVyKHMpKSB7XG4gICAgICAgICAgICAgICAgbm9ybVMgPSBub3JtYWxpemVTKHMpOyAvLyBpZiBsb3dTIHdhcyBwYXNzZWQsIGVuc3VyZSBzIGlzIGFsd2F5c1xuICAgICAgICAgICAgICAgIHJlY292ZXJ5IF49IDE7IC8vIC8vIGluIHRoZSBib3R0b20gaGFsZiBvZiBOXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShyLCBub3JtUywgcmVjb3ZlcnkpOyAvLyB1c2Ugbm9ybVMsIG5vdCBzXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc2VlZCwgazJzaWcgfTtcbiAgICB9XG4gICAgY29uc3QgZGVmYXVsdFNpZ09wdHMgPSB7IGxvd1M6IENVUlZFLmxvd1MsIHByZWhhc2g6IGZhbHNlIH07XG4gICAgY29uc3QgZGVmYXVsdFZlck9wdHMgPSB7IGxvd1M6IENVUlZFLmxvd1MsIHByZWhhc2g6IGZhbHNlIH07XG4gICAgLyoqXG4gICAgICogU2lnbnMgbWVzc2FnZSBoYXNoIHdpdGggYSBwcml2YXRlIGtleS5cbiAgICAgKiBgYGBcbiAgICAgKiBzaWduKG0sIGQsIGspIHdoZXJlXG4gICAgICogICAoeCwgeSkgPSBHIMOXIGtcbiAgICAgKiAgIHIgPSB4IG1vZCBuXG4gICAgICogICBzID0gKG0gKyBkcikvayBtb2QgblxuICAgICAqIGBgYFxuICAgICAqIEBwYXJhbSBtc2dIYXNoIE5PVCBtZXNzYWdlLiBtc2cgbmVlZHMgdG8gYmUgaGFzaGVkIHRvIGBtc2dIYXNoYCwgb3IgdXNlIGBwcmVoYXNoYC5cbiAgICAgKiBAcGFyYW0gcHJpdktleSBwcml2YXRlIGtleVxuICAgICAqIEBwYXJhbSBvcHRzIGxvd1MgZm9yIG5vbi1tYWxsZWFibGUgc2lncy4gZXh0cmFFbnRyb3B5IGZvciBtaXhpbmcgcmFuZG9tbmVzcyBpbnRvIGsuIHByZWhhc2ggd2lsbCBoYXNoIGZpcnN0IGFyZy5cbiAgICAgKiBAcmV0dXJucyBzaWduYXR1cmUgd2l0aCByZWNvdmVyeSBwYXJhbVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNpZ24obXNnSGFzaCwgcHJpdktleSwgb3B0cyA9IGRlZmF1bHRTaWdPcHRzKSB7XG4gICAgICAgIGNvbnN0IHsgc2VlZCwgazJzaWcgfSA9IHByZXBTaWcobXNnSGFzaCwgcHJpdktleSwgb3B0cyk7IC8vIFN0ZXBzIEEsIEQgb2YgUkZDNjk3OSAzLjIuXG4gICAgICAgIGNvbnN0IEMgPSBDVVJWRTtcbiAgICAgICAgY29uc3QgZHJiZyA9IHV0LmNyZWF0ZUhtYWNEcmJnKEMuaGFzaC5vdXRwdXRMZW4sIEMubkJ5dGVMZW5ndGgsIEMuaG1hYyk7XG4gICAgICAgIHJldHVybiBkcmJnKHNlZWQsIGsyc2lnKTsgLy8gU3RlcHMgQiwgQywgRCwgRSwgRiwgR1xuICAgIH1cbiAgICAvLyBFbmFibGUgcHJlY29tcHV0ZXMuIFNsb3dzIGRvd24gZmlyc3QgcHVibGljS2V5IGNvbXB1dGF0aW9uIGJ5IDIwbXMuXG4gICAgUG9pbnQuQkFTRS5fc2V0V2luZG93U2l6ZSg4KTtcbiAgICAvLyB1dGlscy5wcmVjb21wdXRlKDgsIFByb2plY3RpdmVQb2ludC5CQVNFKVxuICAgIC8qKlxuICAgICAqIFZlcmlmaWVzIGEgc2lnbmF0dXJlIGFnYWluc3QgbWVzc2FnZSBoYXNoIGFuZCBwdWJsaWMga2V5LlxuICAgICAqIFJlamVjdHMgbG93UyBzaWduYXR1cmVzIGJ5IGRlZmF1bHQ6IHRvIG92ZXJyaWRlLFxuICAgICAqIHNwZWNpZnkgb3B0aW9uIGB7bG93UzogZmFsc2V9YC4gSW1wbGVtZW50cyBzZWN0aW9uIDQuMS40IGZyb20gaHR0cHM6Ly93d3cuc2VjZy5vcmcvc2VjMS12Mi5wZGY6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiB2ZXJpZnkociwgcywgaCwgUCkgd2hlcmVcbiAgICAgKiAgIFUxID0gaHNeLTEgbW9kIG5cbiAgICAgKiAgIFUyID0gcnNeLTEgbW9kIG5cbiAgICAgKiAgIFIgPSBVMeKLhUcgLSBVMuKLhVBcbiAgICAgKiAgIG1vZChSLngsIG4pID09IHJcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2ZXJpZnkoc2lnbmF0dXJlLCBtc2dIYXNoLCBwdWJsaWNLZXksIG9wdHMgPSBkZWZhdWx0VmVyT3B0cykge1xuICAgICAgICBjb25zdCBzZyA9IHNpZ25hdHVyZTtcbiAgICAgICAgbXNnSGFzaCA9IGVuc3VyZUJ5dGVzKCdtc2dIYXNoJywgbXNnSGFzaCk7XG4gICAgICAgIHB1YmxpY0tleSA9IGVuc3VyZUJ5dGVzKCdwdWJsaWNLZXknLCBwdWJsaWNLZXkpO1xuICAgICAgICBpZiAoJ3N0cmljdCcgaW4gb3B0cylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9ucy5zdHJpY3Qgd2FzIHJlbmFtZWQgdG8gbG93UycpO1xuICAgICAgICBjb25zdCB7IGxvd1MsIHByZWhhc2ggfSA9IG9wdHM7XG4gICAgICAgIGxldCBfc2lnID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgUDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2cgPT09ICdzdHJpbmcnIHx8IHV0LmlzQnl0ZXMoc2cpKSB7XG4gICAgICAgICAgICAgICAgLy8gU2lnbmF0dXJlIGNhbiBiZSByZXByZXNlbnRlZCBpbiAyIHdheXM6IGNvbXBhY3QgKDIqbkJ5dGVMZW5ndGgpICYgREVSICh2YXJpYWJsZS1sZW5ndGgpLlxuICAgICAgICAgICAgICAgIC8vIFNpbmNlIERFUiBjYW4gYWxzbyBiZSAyKm5CeXRlTGVuZ3RoIGJ5dGVzLCB3ZSBjaGVjayBmb3IgaXQgZmlyc3QuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgX3NpZyA9IFNpZ25hdHVyZS5mcm9tREVSKHNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGRlckVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGRlckVycm9yIGluc3RhbmNlb2YgREVSLkVycikpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBkZXJFcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgX3NpZyA9IFNpZ25hdHVyZS5mcm9tQ29tcGFjdChzZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHNnID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygc2cuciA9PT0gJ2JpZ2ludCcgJiYgdHlwZW9mIHNnLnMgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyByLCBzIH0gPSBzZztcbiAgICAgICAgICAgICAgICBfc2lnID0gbmV3IFNpZ25hdHVyZShyLCBzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUEFSU0UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFAgPSBQb2ludC5mcm9tSGV4KHB1YmxpY0tleSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IubWVzc2FnZSA9PT0gJ1BBUlNFJylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHNpZ25hdHVyZSBtdXN0IGJlIFNpZ25hdHVyZSBpbnN0YW5jZSwgVWludDhBcnJheSBvciBoZXggc3RyaW5nYCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvd1MgJiYgX3NpZy5oYXNIaWdoUygpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAocHJlaGFzaClcbiAgICAgICAgICAgIG1zZ0hhc2ggPSBDVVJWRS5oYXNoKG1zZ0hhc2gpO1xuICAgICAgICBjb25zdCB7IHIsIHMgfSA9IF9zaWc7XG4gICAgICAgIGNvbnN0IGggPSBiaXRzMmludF9tb2ROKG1zZ0hhc2gpOyAvLyBDYW5ub3QgdXNlIGZpZWxkcyBtZXRob2RzLCBzaW5jZSBpdCBpcyBncm91cCBlbGVtZW50XG4gICAgICAgIGNvbnN0IGlzID0gaW52TihzKTsgLy8gc14tMVxuICAgICAgICBjb25zdCB1MSA9IG1vZE4oaCAqIGlzKTsgLy8gdTEgPSBoc14tMSBtb2QgblxuICAgICAgICBjb25zdCB1MiA9IG1vZE4ociAqIGlzKTsgLy8gdTIgPSByc14tMSBtb2QgblxuICAgICAgICBjb25zdCBSID0gUG9pbnQuQkFTRS5tdWx0aXBseUFuZEFkZFVuc2FmZShQLCB1MSwgdTIpPy50b0FmZmluZSgpOyAvLyBSID0gdTHii4VHICsgdTLii4VQXG4gICAgICAgIGlmICghUilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgdiA9IG1vZE4oUi54KTtcbiAgICAgICAgcmV0dXJuIHYgPT09IHI7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIENVUlZFLFxuICAgICAgICBnZXRQdWJsaWNLZXksXG4gICAgICAgIGdldFNoYXJlZFNlY3JldCxcbiAgICAgICAgc2lnbixcbiAgICAgICAgdmVyaWZ5LFxuICAgICAgICBQcm9qZWN0aXZlUG9pbnQ6IFBvaW50LFxuICAgICAgICBTaWduYXR1cmUsXG4gICAgICAgIHV0aWxzLFxuICAgIH07XG59XG4vKipcbiAqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBTaGFsbHVlIGFuZCB2YW4gZGUgV29lc3Rpam5lIG1ldGhvZCBmb3IgYW55IHdlaWVyc3RyYXNzIGN1cnZlLlxuICogVE9ETzogY2hlY2sgaWYgdGhlcmUgaXMgYSB3YXkgdG8gbWVyZ2UgdGhpcyB3aXRoIHV2UmF0aW8gaW4gRWR3YXJkczsgbW92ZSB0byBtb2R1bGFyLlxuICogYiA9IFRydWUgYW5kIHkgPSBzcXJ0KHUgLyB2KSBpZiAodSAvIHYpIGlzIHNxdWFyZSBpbiBGLCBhbmRcbiAqIGIgPSBGYWxzZSBhbmQgeSA9IHNxcnQoWiAqICh1IC8gdikpIG90aGVyd2lzZS5cbiAqIEBwYXJhbSBGcFxuICogQHBhcmFtIFpcbiAqIEByZXR1cm5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBTV1VGcFNxcnRSYXRpbyhGcCwgWikge1xuICAgIC8vIEdlbmVyaWMgaW1wbGVtZW50YXRpb25cbiAgICBjb25zdCBxID0gRnAuT1JERVI7XG4gICAgbGV0IGwgPSBfMG47XG4gICAgZm9yIChsZXQgbyA9IHEgLSBfMW47IG8gJSBfMm4gPT09IF8wbjsgbyAvPSBfMm4pXG4gICAgICAgIGwgKz0gXzFuO1xuICAgIGNvbnN0IGMxID0gbDsgLy8gMS4gYzEsIHRoZSBsYXJnZXN0IGludGVnZXIgc3VjaCB0aGF0IDJeYzEgZGl2aWRlcyBxIC0gMS5cbiAgICAvLyBXZSBuZWVkIDJuICoqIGMxIGFuZCAybiAqKiAoYzEtMSkuIFdlIGNhbid0IHVzZSAqKjsgYnV0IHdlIGNhbiB1c2UgPDwuXG4gICAgLy8gMm4gKiogYzEgPT0gMm4gPDwgKGMxLTEpXG4gICAgY29uc3QgXzJuX3Bvd19jMV8xID0gXzJuIDw8IChjMSAtIF8xbiAtIF8xbik7XG4gICAgY29uc3QgXzJuX3Bvd19jMSA9IF8ybl9wb3dfYzFfMSAqIF8ybjtcbiAgICBjb25zdCBjMiA9IChxIC0gXzFuKSAvIF8ybl9wb3dfYzE7IC8vIDIuIGMyID0gKHEgLSAxKSAvICgyXmMxKSAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcbiAgICBjb25zdCBjMyA9IChjMiAtIF8xbikgLyBfMm47IC8vIDMuIGMzID0gKGMyIC0gMSkgLyAyICAgICAgICAgICAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcbiAgICBjb25zdCBjNCA9IF8ybl9wb3dfYzEgLSBfMW47IC8vIDQuIGM0ID0gMl5jMSAtIDEgICAgICAgICAgICAgICAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcbiAgICBjb25zdCBjNSA9IF8ybl9wb3dfYzFfMTsgLy8gNS4gYzUgPSAyXihjMSAtIDEpICAgICAgICAgICAgICAgICAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcbiAgICBjb25zdCBjNiA9IEZwLnBvdyhaLCBjMik7IC8vIDYuIGM2ID0gWl5jMlxuICAgIGNvbnN0IGM3ID0gRnAucG93KFosIChjMiArIF8xbikgLyBfMm4pOyAvLyA3LiBjNyA9IFpeKChjMiArIDEpIC8gMilcbiAgICBsZXQgc3FydFJhdGlvID0gKHUsIHYpID0+IHtcbiAgICAgICAgbGV0IHR2MSA9IGM2OyAvLyAxLiB0djEgPSBjNlxuICAgICAgICBsZXQgdHYyID0gRnAucG93KHYsIGM0KTsgLy8gMi4gdHYyID0gdl5jNFxuICAgICAgICBsZXQgdHYzID0gRnAuc3FyKHR2Mik7IC8vIDMuIHR2MyA9IHR2Ml4yXG4gICAgICAgIHR2MyA9IEZwLm11bCh0djMsIHYpOyAvLyA0LiB0djMgPSB0djMgKiB2XG4gICAgICAgIGxldCB0djUgPSBGcC5tdWwodSwgdHYzKTsgLy8gNS4gdHY1ID0gdSAqIHR2M1xuICAgICAgICB0djUgPSBGcC5wb3codHY1LCBjMyk7IC8vIDYuIHR2NSA9IHR2NV5jM1xuICAgICAgICB0djUgPSBGcC5tdWwodHY1LCB0djIpOyAvLyA3LiB0djUgPSB0djUgKiB0djJcbiAgICAgICAgdHYyID0gRnAubXVsKHR2NSwgdik7IC8vIDguIHR2MiA9IHR2NSAqIHZcbiAgICAgICAgdHYzID0gRnAubXVsKHR2NSwgdSk7IC8vIDkuIHR2MyA9IHR2NSAqIHVcbiAgICAgICAgbGV0IHR2NCA9IEZwLm11bCh0djMsIHR2Mik7IC8vIDEwLiB0djQgPSB0djMgKiB0djJcbiAgICAgICAgdHY1ID0gRnAucG93KHR2NCwgYzUpOyAvLyAxMS4gdHY1ID0gdHY0XmM1XG4gICAgICAgIGxldCBpc1FSID0gRnAuZXFsKHR2NSwgRnAuT05FKTsgLy8gMTIuIGlzUVIgPSB0djUgPT0gMVxuICAgICAgICB0djIgPSBGcC5tdWwodHYzLCBjNyk7IC8vIDEzLiB0djIgPSB0djMgKiBjN1xuICAgICAgICB0djUgPSBGcC5tdWwodHY0LCB0djEpOyAvLyAxNC4gdHY1ID0gdHY0ICogdHYxXG4gICAgICAgIHR2MyA9IEZwLmNtb3YodHYyLCB0djMsIGlzUVIpOyAvLyAxNS4gdHYzID0gQ01PVih0djIsIHR2MywgaXNRUilcbiAgICAgICAgdHY0ID0gRnAuY21vdih0djUsIHR2NCwgaXNRUik7IC8vIDE2LiB0djQgPSBDTU9WKHR2NSwgdHY0LCBpc1FSKVxuICAgICAgICAvLyAxNy4gZm9yIGkgaW4gKGMxLCBjMSAtIDEsIC4uLiwgMik6XG4gICAgICAgIGZvciAobGV0IGkgPSBjMTsgaSA+IF8xbjsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgdHY1ID0gaSAtIF8ybjsgLy8gMTguICAgIHR2NSA9IGkgLSAyXG4gICAgICAgICAgICB0djUgPSBfMm4gPDwgKHR2NSAtIF8xbik7IC8vIDE5LiAgICB0djUgPSAyXnR2NVxuICAgICAgICAgICAgbGV0IHR2djUgPSBGcC5wb3codHY0LCB0djUpOyAvLyAyMC4gICAgdHY1ID0gdHY0XnR2NVxuICAgICAgICAgICAgY29uc3QgZTEgPSBGcC5lcWwodHZ2NSwgRnAuT05FKTsgLy8gMjEuICAgIGUxID0gdHY1ID09IDFcbiAgICAgICAgICAgIHR2MiA9IEZwLm11bCh0djMsIHR2MSk7IC8vIDIyLiAgICB0djIgPSB0djMgKiB0djFcbiAgICAgICAgICAgIHR2MSA9IEZwLm11bCh0djEsIHR2MSk7IC8vIDIzLiAgICB0djEgPSB0djEgKiB0djFcbiAgICAgICAgICAgIHR2djUgPSBGcC5tdWwodHY0LCB0djEpOyAvLyAyNC4gICAgdHY1ID0gdHY0ICogdHYxXG4gICAgICAgICAgICB0djMgPSBGcC5jbW92KHR2MiwgdHYzLCBlMSk7IC8vIDI1LiAgICB0djMgPSBDTU9WKHR2MiwgdHYzLCBlMSlcbiAgICAgICAgICAgIHR2NCA9IEZwLmNtb3YodHZ2NSwgdHY0LCBlMSk7IC8vIDI2LiAgICB0djQgPSBDTU9WKHR2NSwgdHY0LCBlMSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBpc1ZhbGlkOiBpc1FSLCB2YWx1ZTogdHYzIH07XG4gICAgfTtcbiAgICBpZiAoRnAuT1JERVIgJSBfNG4gPT09IF8zbikge1xuICAgICAgICAvLyBzcXJ0X3JhdGlvXzNtb2Q0KHUsIHYpXG4gICAgICAgIGNvbnN0IGMxID0gKEZwLk9SREVSIC0gXzNuKSAvIF80bjsgLy8gMS4gYzEgPSAocSAtIDMpIC8gNCAgICAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcbiAgICAgICAgY29uc3QgYzIgPSBGcC5zcXJ0KEZwLm5lZyhaKSk7IC8vIDIuIGMyID0gc3FydCgtWilcbiAgICAgICAgc3FydFJhdGlvID0gKHUsIHYpID0+IHtcbiAgICAgICAgICAgIGxldCB0djEgPSBGcC5zcXIodik7IC8vIDEuIHR2MSA9IHZeMlxuICAgICAgICAgICAgY29uc3QgdHYyID0gRnAubXVsKHUsIHYpOyAvLyAyLiB0djIgPSB1ICogdlxuICAgICAgICAgICAgdHYxID0gRnAubXVsKHR2MSwgdHYyKTsgLy8gMy4gdHYxID0gdHYxICogdHYyXG4gICAgICAgICAgICBsZXQgeTEgPSBGcC5wb3codHYxLCBjMSk7IC8vIDQuIHkxID0gdHYxXmMxXG4gICAgICAgICAgICB5MSA9IEZwLm11bCh5MSwgdHYyKTsgLy8gNS4geTEgPSB5MSAqIHR2MlxuICAgICAgICAgICAgY29uc3QgeTIgPSBGcC5tdWwoeTEsIGMyKTsgLy8gNi4geTIgPSB5MSAqIGMyXG4gICAgICAgICAgICBjb25zdCB0djMgPSBGcC5tdWwoRnAuc3FyKHkxKSwgdik7IC8vIDcuIHR2MyA9IHkxXjI7IDguIHR2MyA9IHR2MyAqIHZcbiAgICAgICAgICAgIGNvbnN0IGlzUVIgPSBGcC5lcWwodHYzLCB1KTsgLy8gOS4gaXNRUiA9IHR2MyA9PSB1XG4gICAgICAgICAgICBsZXQgeSA9IEZwLmNtb3YoeTIsIHkxLCBpc1FSKTsgLy8gMTAuIHkgPSBDTU9WKHkyLCB5MSwgaXNRUilcbiAgICAgICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGlzUVIsIHZhbHVlOiB5IH07IC8vIDExLiByZXR1cm4gKGlzUVIsIHkpIGlzUVIgPyB5IDogeSpjMlxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBObyBjdXJ2ZXMgdXNlcyB0aGF0XG4gICAgLy8gaWYgKEZwLk9SREVSICUgXzhuID09PSBfNW4pIC8vIHNxcnRfcmF0aW9fNW1vZDhcbiAgICByZXR1cm4gc3FydFJhdGlvO1xufVxuLyoqXG4gKiBTaW1wbGlmaWVkIFNoYWxsdWUtdmFuIGRlIFdvZXN0aWpuZS1VbGFzIE1ldGhvZFxuICogaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi02LjYuMlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFwVG9DdXJ2ZVNpbXBsZVNXVShGcCwgb3B0cykge1xuICAgIG1vZC52YWxpZGF0ZUZpZWxkKEZwKTtcbiAgICBpZiAoIUZwLmlzVmFsaWQob3B0cy5BKSB8fCAhRnAuaXNWYWxpZChvcHRzLkIpIHx8ICFGcC5pc1ZhbGlkKG9wdHMuWikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWFwVG9DdXJ2ZVNpbXBsZVNXVTogaW52YWxpZCBvcHRzJyk7XG4gICAgY29uc3Qgc3FydFJhdGlvID0gU1dVRnBTcXJ0UmF0aW8oRnAsIG9wdHMuWik7XG4gICAgaWYgKCFGcC5pc09kZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGcC5pc09kZCBpcyBub3QgaW1wbGVtZW50ZWQhJyk7XG4gICAgLy8gSW5wdXQ6IHUsIGFuIGVsZW1lbnQgb2YgRi5cbiAgICAvLyBPdXRwdXQ6ICh4LCB5KSwgYSBwb2ludCBvbiBFLlxuICAgIHJldHVybiAodSkgPT4ge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgbGV0IHR2MSwgdHYyLCB0djMsIHR2NCwgdHY1LCB0djYsIHgsIHk7XG4gICAgICAgIHR2MSA9IEZwLnNxcih1KTsgLy8gMS4gIHR2MSA9IHVeMlxuICAgICAgICB0djEgPSBGcC5tdWwodHYxLCBvcHRzLlopOyAvLyAyLiAgdHYxID0gWiAqIHR2MVxuICAgICAgICB0djIgPSBGcC5zcXIodHYxKTsgLy8gMy4gIHR2MiA9IHR2MV4yXG4gICAgICAgIHR2MiA9IEZwLmFkZCh0djIsIHR2MSk7IC8vIDQuICB0djIgPSB0djIgKyB0djFcbiAgICAgICAgdHYzID0gRnAuYWRkKHR2MiwgRnAuT05FKTsgLy8gNS4gIHR2MyA9IHR2MiArIDFcbiAgICAgICAgdHYzID0gRnAubXVsKHR2Mywgb3B0cy5CKTsgLy8gNi4gIHR2MyA9IEIgKiB0djNcbiAgICAgICAgdHY0ID0gRnAuY21vdihvcHRzLlosIEZwLm5lZyh0djIpLCAhRnAuZXFsKHR2MiwgRnAuWkVSTykpOyAvLyA3LiAgdHY0ID0gQ01PVihaLCAtdHYyLCB0djIgIT0gMClcbiAgICAgICAgdHY0ID0gRnAubXVsKHR2NCwgb3B0cy5BKTsgLy8gOC4gIHR2NCA9IEEgKiB0djRcbiAgICAgICAgdHYyID0gRnAuc3FyKHR2Myk7IC8vIDkuICB0djIgPSB0djNeMlxuICAgICAgICB0djYgPSBGcC5zcXIodHY0KTsgLy8gMTAuIHR2NiA9IHR2NF4yXG4gICAgICAgIHR2NSA9IEZwLm11bCh0djYsIG9wdHMuQSk7IC8vIDExLiB0djUgPSBBICogdHY2XG4gICAgICAgIHR2MiA9IEZwLmFkZCh0djIsIHR2NSk7IC8vIDEyLiB0djIgPSB0djIgKyB0djVcbiAgICAgICAgdHYyID0gRnAubXVsKHR2MiwgdHYzKTsgLy8gMTMuIHR2MiA9IHR2MiAqIHR2M1xuICAgICAgICB0djYgPSBGcC5tdWwodHY2LCB0djQpOyAvLyAxNC4gdHY2ID0gdHY2ICogdHY0XG4gICAgICAgIHR2NSA9IEZwLm11bCh0djYsIG9wdHMuQik7IC8vIDE1LiB0djUgPSBCICogdHY2XG4gICAgICAgIHR2MiA9IEZwLmFkZCh0djIsIHR2NSk7IC8vIDE2LiB0djIgPSB0djIgKyB0djVcbiAgICAgICAgeCA9IEZwLm11bCh0djEsIHR2Myk7IC8vIDE3LiAgIHggPSB0djEgKiB0djNcbiAgICAgICAgY29uc3QgeyBpc1ZhbGlkLCB2YWx1ZSB9ID0gc3FydFJhdGlvKHR2MiwgdHY2KTsgLy8gMTguIChpc19neDFfc3F1YXJlLCB5MSkgPSBzcXJ0X3JhdGlvKHR2MiwgdHY2KVxuICAgICAgICB5ID0gRnAubXVsKHR2MSwgdSk7IC8vIDE5LiAgIHkgPSB0djEgKiB1ICAtPiBaICogdV4zICogeTFcbiAgICAgICAgeSA9IEZwLm11bCh5LCB2YWx1ZSk7IC8vIDIwLiAgIHkgPSB5ICogeTFcbiAgICAgICAgeCA9IEZwLmNtb3YoeCwgdHYzLCBpc1ZhbGlkKTsgLy8gMjEuICAgeCA9IENNT1YoeCwgdHYzLCBpc19neDFfc3F1YXJlKVxuICAgICAgICB5ID0gRnAuY21vdih5LCB2YWx1ZSwgaXNWYWxpZCk7IC8vIDIyLiAgIHkgPSBDTU9WKHksIHkxLCBpc19neDFfc3F1YXJlKVxuICAgICAgICBjb25zdCBlMSA9IEZwLmlzT2RkKHUpID09PSBGcC5pc09kZCh5KTsgLy8gMjMuICBlMSA9IHNnbjAodSkgPT0gc2duMCh5KVxuICAgICAgICB5ID0gRnAuY21vdihGcC5uZWcoeSksIHksIGUxKTsgLy8gMjQuICAgeSA9IENNT1YoLXksIHksIGUxKVxuICAgICAgICB4ID0gRnAuZGl2KHgsIHR2NCk7IC8vIDI1LiAgIHggPSB4IC8gdHY0XG4gICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2VpZXJzdHJhc3MuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/api-key-stamper/node_modules/@noble/curves/esm/abstract/weierstrass.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/api-key-stamper/node_modules/@noble/curves/esm/p256.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@turnkey/api-key-stamper/node_modules/@noble/curves/esm/p256.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encodeToCurve: () => (/* binding */ encodeToCurve),\n/* harmony export */   hashToCurve: () => (/* binding */ hashToCurve),\n/* harmony export */   p256: () => (/* binding */ p256),\n/* harmony export */   secp256r1: () => (/* binding */ secp256r1)\n/* harmony export */ });\n/* harmony import */ var _shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_shortw_utils.js */ \"(ssr)/./node_modules/@turnkey/api-key-stamper/node_modules/@noble/curves/esm/_shortw_utils.js\");\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/@turnkey/api-key-stamper/node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract/modular.js */ \"(ssr)/./node_modules/@turnkey/api-key-stamper/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(ssr)/./node_modules/@turnkey/api-key-stamper/node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/* harmony import */ var _abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./abstract/hash-to-curve.js */ \"(ssr)/./node_modules/@turnkey/api-key-stamper/node_modules/@noble/curves/esm/abstract/hash-to-curve.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\n\n\n\n// NIST secp256r1 aka p256\n// https://www.secg.org/sec2-v2.pdf, https://neuromancer.sk/std/nist/P-256\nconst Fp = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field)(BigInt('0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff'));\nconst CURVE_A = Fp.create(BigInt('-3'));\nconst CURVE_B = BigInt('0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b');\n// prettier-ignore\nconst p256 = (0,_shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__.createCurve)({\n    a: CURVE_A, // Equation params: a, b\n    b: CURVE_B,\n    Fp, // Field: 2n**224n * (2n**32n-1n) + 2n**192n + 2n**96n-1n\n    // Curve order, total count of valid points in the field\n    n: BigInt('0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551'),\n    // Base (generator) point (x, y)\n    Gx: BigInt('0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296'),\n    Gy: BigInt('0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5'),\n    h: BigInt(1),\n    lowS: false,\n}, _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256);\nconst secp256r1 = p256;\nconst mapSWU = /* @__PURE__ */ (() => (0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_3__.mapToCurveSimpleSWU)(Fp, {\n    A: CURVE_A,\n    B: CURVE_B,\n    Z: Fp.create(BigInt('-10')),\n}))();\nconst htf = /* @__PURE__ */ (() => (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_4__.createHasher)(secp256r1.ProjectivePoint, (scalars) => mapSWU(scalars[0]), {\n    DST: 'P256_XMD:SHA-256_SSWU_RO_',\n    encodeDST: 'P256_XMD:SHA-256_SSWU_NU_',\n    p: Fp.ORDER,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256,\n}))();\nconst hashToCurve = /* @__PURE__ */ (() => htf.hashToCurve)();\nconst encodeToCurve = /* @__PURE__ */ (() => htf.encodeToCurve)();\n//# sourceMappingURL=p256.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvYXBpLWtleS1zdGFtcGVyL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9wMjU2LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBO0FBQ2lEO0FBQ0g7QUFDQTtBQUNrQjtBQUNMO0FBQzNEO0FBQ0E7QUFDQSxXQUFXLDJEQUFLO0FBQ2hCO0FBQ0E7QUFDQTtBQUNPLGFBQWEsNkRBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUUsd0RBQU07QUFDRjtBQUNQLHNDQUFzQyw2RUFBbUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG1DQUFtQyx3RUFBWTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHdEQUFNO0FBQ2hCLENBQUM7QUFDTTtBQUNBO0FBQ1AiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9udXJzZWJsb2MvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvYXBpLWtleS1zdGFtcGVyL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9wMjU2LmpzP2M4ZWUiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0IHsgY3JlYXRlQ3VydmUgfSBmcm9tICcuL19zaG9ydHdfdXRpbHMuanMnO1xuaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9zaGEyNTYnO1xuaW1wb3J0IHsgRmllbGQgfSBmcm9tICcuL2Fic3RyYWN0L21vZHVsYXIuanMnO1xuaW1wb3J0IHsgbWFwVG9DdXJ2ZVNpbXBsZVNXVSB9IGZyb20gJy4vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanMnO1xuaW1wb3J0IHsgY3JlYXRlSGFzaGVyIH0gZnJvbSAnLi9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzJztcbi8vIE5JU1Qgc2VjcDI1NnIxIGFrYSBwMjU2XG4vLyBodHRwczovL3d3dy5zZWNnLm9yZy9zZWMyLXYyLnBkZiwgaHR0cHM6Ly9uZXVyb21hbmNlci5zay9zdGQvbmlzdC9QLTI1NlxuY29uc3QgRnAgPSBGaWVsZChCaWdJbnQoJzB4ZmZmZmZmZmYwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZicpKTtcbmNvbnN0IENVUlZFX0EgPSBGcC5jcmVhdGUoQmlnSW50KCctMycpKTtcbmNvbnN0IENVUlZFX0IgPSBCaWdJbnQoJzB4NWFjNjM1ZDhhYTNhOTNlN2IzZWJiZDU1NzY5ODg2YmM2NTFkMDZiMGNjNTNiMGY2M2JjZTNjM2UyN2QyNjA0YicpO1xuLy8gcHJldHRpZXItaWdub3JlXG5leHBvcnQgY29uc3QgcDI1NiA9IGNyZWF0ZUN1cnZlKHtcbiAgICBhOiBDVVJWRV9BLCAvLyBFcXVhdGlvbiBwYXJhbXM6IGEsIGJcbiAgICBiOiBDVVJWRV9CLFxuICAgIEZwLCAvLyBGaWVsZDogMm4qKjIyNG4gKiAoMm4qKjMybi0xbikgKyAybioqMTkybiArIDJuKio5Nm4tMW5cbiAgICAvLyBDdXJ2ZSBvcmRlciwgdG90YWwgY291bnQgb2YgdmFsaWQgcG9pbnRzIGluIHRoZSBmaWVsZFxuICAgIG46IEJpZ0ludCgnMHhmZmZmZmZmZjAwMDAwMDAwZmZmZmZmZmZmZmZmZmZmZmJjZTZmYWFkYTcxNzllODRmM2I5Y2FjMmZjNjMyNTUxJyksXG4gICAgLy8gQmFzZSAoZ2VuZXJhdG9yKSBwb2ludCAoeCwgeSlcbiAgICBHeDogQmlnSW50KCcweDZiMTdkMWYyZTEyYzQyNDdmOGJjZTZlNTYzYTQ0MGYyNzcwMzdkODEyZGViMzNhMGY0YTEzOTQ1ZDg5OGMyOTYnKSxcbiAgICBHeTogQmlnSW50KCcweDRmZTM0MmUyZmUxYTdmOWI4ZWU3ZWI0YTdjMGY5ZTE2MmJjZTMzNTc2YjMxNWVjZWNiYjY0MDY4MzdiZjUxZjUnKSxcbiAgICBoOiBCaWdJbnQoMSksXG4gICAgbG93UzogZmFsc2UsXG59LCBzaGEyNTYpO1xuZXhwb3J0IGNvbnN0IHNlY3AyNTZyMSA9IHAyNTY7XG5jb25zdCBtYXBTV1UgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IG1hcFRvQ3VydmVTaW1wbGVTV1UoRnAsIHtcbiAgICBBOiBDVVJWRV9BLFxuICAgIEI6IENVUlZFX0IsXG4gICAgWjogRnAuY3JlYXRlKEJpZ0ludCgnLTEwJykpLFxufSkpKCk7XG5jb25zdCBodGYgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGNyZWF0ZUhhc2hlcihzZWNwMjU2cjEuUHJvamVjdGl2ZVBvaW50LCAoc2NhbGFycykgPT4gbWFwU1dVKHNjYWxhcnNbMF0pLCB7XG4gICAgRFNUOiAnUDI1Nl9YTUQ6U0hBLTI1Nl9TU1dVX1JPXycsXG4gICAgZW5jb2RlRFNUOiAnUDI1Nl9YTUQ6U0hBLTI1Nl9TU1dVX05VXycsXG4gICAgcDogRnAuT1JERVIsXG4gICAgbTogMSxcbiAgICBrOiAxMjgsXG4gICAgZXhwYW5kOiAneG1kJyxcbiAgICBoYXNoOiBzaGEyNTYsXG59KSkoKTtcbmV4cG9ydCBjb25zdCBoYXNoVG9DdXJ2ZSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gaHRmLmhhc2hUb0N1cnZlKSgpO1xuZXhwb3J0IGNvbnN0IGVuY29kZVRvQ3VydmUgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGh0Zi5lbmNvZGVUb0N1cnZlKSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cDI1Ni5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/api-key-stamper/node_modules/@noble/curves/esm/p256.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/api-key-stamper/node_modules/@noble/hashes/esm/_assert.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@turnkey/api-key-stamper/node_modules/@noble/hashes/esm/_assert.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bool: () => (/* binding */ bool),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   exists: () => (/* binding */ exists),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   isBytes: () => (/* binding */ isBytes),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   output: () => (/* binding */ output)\n/* harmony export */ });\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`positive integer expected, not ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`boolean expected, not ${b}`);\n}\n// copied from utils\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\nfunction bytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(h.outputLen);\n    number(h.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\n\nconst assert = { number, bool, bytes, hash, exists, output };\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (assert);\n//# sourceMappingURL=_assert.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvYXBpLWtleS1zdGFtcGVyL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fYXNzZXJ0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBLDBEQUEwRCxFQUFFO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxFQUFFO0FBQ25EO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELFFBQVEsa0JBQWtCLFNBQVM7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRixJQUFJO0FBQ3JGO0FBQ0E7QUFDcUQ7QUFDckQsaUJBQWlCO0FBQ2pCLGlFQUFlLE1BQU0sRUFBQztBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL251cnNlYmxvYy8uL25vZGVfbW9kdWxlcy9AdHVybmtleS9hcGkta2V5LXN0YW1wZXIvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19hc3NlcnQuanM/MDI1MCJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBudW1iZXIobikge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobikgfHwgbiA8IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgcG9zaXRpdmUgaW50ZWdlciBleHBlY3RlZCwgbm90ICR7bn1gKTtcbn1cbmZ1bmN0aW9uIGJvb2woYikge1xuICAgIGlmICh0eXBlb2YgYiAhPT0gJ2Jvb2xlYW4nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJvb2xlYW4gZXhwZWN0ZWQsIG5vdCAke2J9YCk7XG59XG4vLyBjb3BpZWQgZnJvbSB1dGlsc1xuZXhwb3J0IGZ1bmN0aW9uIGlzQnl0ZXMoYSkge1xuICAgIHJldHVybiAoYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHxcbiAgICAgICAgKGEgIT0gbnVsbCAmJiB0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgYS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpKTtcbn1cbmZ1bmN0aW9uIGJ5dGVzKGIsIC4uLmxlbmd0aHMpIHtcbiAgICBpZiAoIWlzQnl0ZXMoYikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgIGlmIChsZW5ndGhzLmxlbmd0aCA+IDAgJiYgIWxlbmd0aHMuaW5jbHVkZXMoYi5sZW5ndGgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVpbnQ4QXJyYXkgZXhwZWN0ZWQgb2YgbGVuZ3RoICR7bGVuZ3Roc30sIG5vdCBvZiBsZW5ndGg9JHtiLmxlbmd0aH1gKTtcbn1cbmZ1bmN0aW9uIGhhc2goaCkge1xuICAgIGlmICh0eXBlb2YgaCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaC5jcmVhdGUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBzaG91bGQgYmUgd3JhcHBlZCBieSB1dGlscy53cmFwQ29uc3RydWN0b3InKTtcbiAgICBudW1iZXIoaC5vdXRwdXRMZW4pO1xuICAgIG51bWJlcihoLmJsb2NrTGVuKTtcbn1cbmZ1bmN0aW9uIGV4aXN0cyhpbnN0YW5jZSwgY2hlY2tGaW5pc2hlZCA9IHRydWUpIHtcbiAgICBpZiAoaW5zdGFuY2UuZGVzdHJveWVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkJyk7XG4gICAgaWYgKGNoZWNrRmluaXNoZWQgJiYgaW5zdGFuY2UuZmluaXNoZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCNkaWdlc3QoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZCcpO1xufVxuZnVuY3Rpb24gb3V0cHV0KG91dCwgaW5zdGFuY2UpIHtcbiAgICBieXRlcyhvdXQpO1xuICAgIGNvbnN0IG1pbiA9IGluc3RhbmNlLm91dHB1dExlbjtcbiAgICBpZiAob3V0Lmxlbmd0aCA8IG1pbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGRpZ2VzdEludG8oKSBleHBlY3RzIG91dHB1dCBidWZmZXIgb2YgbGVuZ3RoIGF0IGxlYXN0ICR7bWlufWApO1xuICAgIH1cbn1cbmV4cG9ydCB7IG51bWJlciwgYm9vbCwgYnl0ZXMsIGhhc2gsIGV4aXN0cywgb3V0cHV0IH07XG5jb25zdCBhc3NlcnQgPSB7IG51bWJlciwgYm9vbCwgYnl0ZXMsIGhhc2gsIGV4aXN0cywgb3V0cHV0IH07XG5leHBvcnQgZGVmYXVsdCBhc3NlcnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fYXNzZXJ0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/api-key-stamper/node_modules/@noble/hashes/esm/_assert.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/api-key-stamper/node_modules/@noble/hashes/esm/_md.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@turnkey/api-key-stamper/node_modules/@noble/hashes/esm/_md.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Chi: () => (/* binding */ Chi),\n/* harmony export */   HashMD: () => (/* binding */ HashMD),\n/* harmony export */   Maj: () => (/* binding */ Maj)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./node_modules/@turnkey/api-key-stamper/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@turnkey/api-key-stamper/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Choice: a ? b : c\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nclass HashMD extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(this.buffer);\n    }\n    update(data) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        const { view, buffer, blockLen } = this;\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.output)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n//# sourceMappingURL=_md.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvYXBpLWtleS1zdGFtcGVyL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fbWQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBOEM7QUFDUztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTyxxQkFBcUIsMkNBQUk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxREFBVTtBQUM5QjtBQUNBO0FBQ0EsUUFBUSxrREFBTTtBQUNkLGdCQUFnQix5QkFBeUI7QUFDekMsZUFBZSxrREFBTztBQUN0QjtBQUNBLDBCQUEwQixVQUFVO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxxREFBVTtBQUMzQyx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBTTtBQUNkLFFBQVEsa0RBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQkFBK0I7QUFDL0MsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGNBQWM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFEQUFVO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscURBQXFEO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbnVyc2VibG9jLy4vbm9kZV9tb2R1bGVzL0B0dXJua2V5L2FwaS1rZXktc3RhbXBlci9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX21kLmpzPzMxM2IiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZXhpc3RzLCBvdXRwdXQgfSBmcm9tICcuL19hc3NlcnQuanMnO1xuaW1wb3J0IHsgSGFzaCwgY3JlYXRlVmlldywgdG9CeXRlcyB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gUG9seWZpbGwgZm9yIFNhZmFyaSAxNFxuZnVuY3Rpb24gc2V0QmlnVWludDY0KHZpZXcsIGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKSB7XG4gICAgaWYgKHR5cGVvZiB2aWV3LnNldEJpZ1VpbnQ2NCA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgcmV0dXJuIHZpZXcuc2V0QmlnVWludDY0KGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKTtcbiAgICBjb25zdCBfMzJuID0gQmlnSW50KDMyKTtcbiAgICBjb25zdCBfdTMyX21heCA9IEJpZ0ludCgweGZmZmZmZmZmKTtcbiAgICBjb25zdCB3aCA9IE51bWJlcigodmFsdWUgPj4gXzMybikgJiBfdTMyX21heCk7XG4gICAgY29uc3Qgd2wgPSBOdW1iZXIodmFsdWUgJiBfdTMyX21heCk7XG4gICAgY29uc3QgaCA9IGlzTEUgPyA0IDogMDtcbiAgICBjb25zdCBsID0gaXNMRSA/IDAgOiA0O1xuICAgIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBoLCB3aCwgaXNMRSk7XG4gICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGwsIHdsLCBpc0xFKTtcbn1cbi8vIENob2ljZTogYSA/IGIgOiBjXG5leHBvcnQgY29uc3QgQ2hpID0gKGEsIGIsIGMpID0+IChhICYgYikgXiAofmEgJiBjKTtcbi8vIE1ham9yaXR5IGZ1bmN0aW9uLCB0cnVlIGlmIGFueSB0d28gaW5wdXN0IGlzIHRydWVcbmV4cG9ydCBjb25zdCBNYWogPSAoYSwgYiwgYykgPT4gKGEgJiBiKSBeIChhICYgYykgXiAoYiAmIGMpO1xuLyoqXG4gKiBNZXJrbGUtRGFtZ2FyZCBoYXNoIGNvbnN0cnVjdGlvbiBiYXNlIGNsYXNzLlxuICogQ291bGQgYmUgdXNlZCB0byBjcmVhdGUgTUQ1LCBSSVBFTUQsIFNIQTEsIFNIQTIuXG4gKi9cbmV4cG9ydCBjbGFzcyBIYXNoTUQgZXh0ZW5kcyBIYXNoIHtcbiAgICBjb25zdHJ1Y3RvcihibG9ja0xlbiwgb3V0cHV0TGVuLCBwYWRPZmZzZXQsIGlzTEUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdGhpcy5wYWRPZmZzZXQgPSBwYWRPZmZzZXQ7XG4gICAgICAgIHRoaXMuaXNMRSA9IGlzTEU7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tMZW4pO1xuICAgICAgICB0aGlzLnZpZXcgPSBjcmVhdGVWaWV3KHRoaXMuYnVmZmVyKTtcbiAgICB9XG4gICAgdXBkYXRlKGRhdGEpIHtcbiAgICAgICAgZXhpc3RzKHRoaXMpO1xuICAgICAgICBjb25zdCB7IHZpZXcsIGJ1ZmZlciwgYmxvY2tMZW4gfSA9IHRoaXM7XG4gICAgICAgIGRhdGEgPSB0b0J5dGVzKGRhdGEpO1xuICAgICAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3MsIGxlbiAtIHBvcyk7XG4gICAgICAgICAgICAvLyBGYXN0IHBhdGg6IHdlIGhhdmUgYXQgbGVhc3Qgb25lIGJsb2NrIGluIGlucHV0LCBjYXN0IGl0IHRvIHZpZXcgYW5kIHByb2Nlc3NcbiAgICAgICAgICAgIGlmICh0YWtlID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFWaWV3ID0gY3JlYXRlVmlldyhkYXRhKTtcbiAgICAgICAgICAgICAgICBmb3IgKDsgYmxvY2tMZW4gPD0gbGVuIC0gcG9zOyBwb3MgKz0gYmxvY2tMZW4pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2VzcyhkYXRhVmlldywgcG9zKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlci5zZXQoZGF0YS5zdWJhcnJheShwb3MsIHBvcyArIHRha2UpLCB0aGlzLnBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSB0YWtlO1xuICAgICAgICAgICAgcG9zICs9IHRha2U7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxlbmd0aCArPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgdGhpcy5yb3VuZENsZWFuKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBleGlzdHModGhpcyk7XG4gICAgICAgIG91dHB1dChvdXQsIHRoaXMpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgLy8gUGFkZGluZ1xuICAgICAgICAvLyBXZSBjYW4gYXZvaWQgYWxsb2NhdGlvbiBvZiBidWZmZXIgZm9yIHBhZGRpbmcgY29tcGxldGVseSBpZiBpdFxuICAgICAgICAvLyB3YXMgcHJldmlvdXNseSBub3QgYWxsb2NhdGVkIGhlcmUuIEJ1dCBpdCB3b24ndCBjaGFuZ2UgcGVyZm9ybWFuY2UuXG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCB2aWV3LCBibG9ja0xlbiwgaXNMRSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgcG9zIH0gPSB0aGlzO1xuICAgICAgICAvLyBhcHBlbmQgdGhlIGJpdCAnMScgdG8gdGhlIG1lc3NhZ2VcbiAgICAgICAgYnVmZmVyW3BvcysrXSA9IDBiMTAwMDAwMDA7XG4gICAgICAgIHRoaXMuYnVmZmVyLnN1YmFycmF5KHBvcykuZmlsbCgwKTtcbiAgICAgICAgLy8gd2UgaGF2ZSBsZXNzIHRoYW4gcGFkT2Zmc2V0IGxlZnQgaW4gYnVmZmVyLCBzbyB3ZSBjYW5ub3QgcHV0IGxlbmd0aCBpblxuICAgICAgICAvLyBjdXJyZW50IGJsb2NrLCBuZWVkIHByb2Nlc3MgaXQgYW5kIHBhZCBhZ2FpblxuICAgICAgICBpZiAodGhpcy5wYWRPZmZzZXQgPiBibG9ja0xlbiAtIHBvcykge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICAgICAgcG9zID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBQYWQgdW50aWwgZnVsbCBibG9jayBieXRlIHdpdGggemVyb3NcbiAgICAgICAgZm9yIChsZXQgaSA9IHBvczsgaSA8IGJsb2NrTGVuOyBpKyspXG4gICAgICAgICAgICBidWZmZXJbaV0gPSAwO1xuICAgICAgICAvLyBOb3RlOiBzaGE1MTIgcmVxdWlyZXMgbGVuZ3RoIHRvIGJlIDEyOGJpdCBpbnRlZ2VyLCBidXQgbGVuZ3RoIGluIEpTIHdpbGwgb3ZlcmZsb3cgYmVmb3JlIHRoYXRcbiAgICAgICAgLy8gWW91IG5lZWQgdG8gd3JpdGUgYXJvdW5kIDIgZXhhYnl0ZXMgKHU2NF9tYXggLyA4IC8gKDEwMjQqKjYpKSBmb3IgdGhpcyB0byBoYXBwZW4uXG4gICAgICAgIC8vIFNvIHdlIGp1c3Qgd3JpdGUgbG93ZXN0IDY0IGJpdHMgb2YgdGhhdCB2YWx1ZS5cbiAgICAgICAgc2V0QmlnVWludDY0KHZpZXcsIGJsb2NrTGVuIC0gOCwgQmlnSW50KHRoaXMubGVuZ3RoICogOCksIGlzTEUpO1xuICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgIGNvbnN0IG92aWV3ID0gY3JlYXRlVmlldyhvdXQpO1xuICAgICAgICBjb25zdCBsZW4gPSB0aGlzLm91dHB1dExlbjtcbiAgICAgICAgLy8gTk9URTogd2UgZG8gZGl2aXNpb24gYnkgNCBsYXRlciwgd2hpY2ggc2hvdWxkIGJlIGZ1c2VkIGluIHNpbmdsZSBvcCB3aXRoIG1vZHVsbyBieSBKSVRcbiAgICAgICAgaWYgKGxlbiAlIDQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ19zaGEyOiBvdXRwdXRMZW4gc2hvdWxkIGJlIGFsaWduZWQgdG8gMzJiaXQnKTtcbiAgICAgICAgY29uc3Qgb3V0TGVuID0gbGVuIC8gNDtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldCgpO1xuICAgICAgICBpZiAob3V0TGVuID4gc3RhdGUubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfc2hhMjogb3V0cHV0TGVuIGJpZ2dlciB0aGFuIHN0YXRlJyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0TGVuOyBpKyspXG4gICAgICAgICAgICBvdmlldy5zZXRVaW50MzIoNCAqIGksIHN0YXRlW2ldLCBpc0xFKTtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgb3V0cHV0TGVuIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLmRpZ2VzdEludG8oYnVmZmVyKTtcbiAgICAgICAgY29uc3QgcmVzID0gYnVmZmVyLnNsaWNlKDAsIG91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIHRvIHx8ICh0byA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkpO1xuICAgICAgICB0by5zZXQoLi4udGhpcy5nZXQoKSk7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIGJ1ZmZlciwgbGVuZ3RoLCBmaW5pc2hlZCwgZGVzdHJveWVkLCBwb3MgfSA9IHRoaXM7XG4gICAgICAgIHRvLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdG8ucG9zID0gcG9zO1xuICAgICAgICB0by5maW5pc2hlZCA9IGZpbmlzaGVkO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSBkZXN0cm95ZWQ7XG4gICAgICAgIGlmIChsZW5ndGggJSBibG9ja0xlbilcbiAgICAgICAgICAgIHRvLmJ1ZmZlci5zZXQoYnVmZmVyKTtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9tZC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/api-key-stamper/node_modules/@noble/hashes/esm/_md.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/api-key-stamper/node_modules/@noble/hashes/esm/cryptoNode.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@turnkey/api-key-stamper/node_modules/@noble/hashes/esm/cryptoNode.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   crypto: () => (/* binding */ crypto)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// See utils.ts for details.\n// The file will throw on node.js 14 and earlier.\n// @ts-ignore\n\nconst crypto = /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) && typeof /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) === 'object' && \"webcrypto\" in /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) ? node_crypto__WEBPACK_IMPORTED_MODULE_0__.webcrypto : undefined;\n//# sourceMappingURL=cryptoNode.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvYXBpLWtleS1zdGFtcGVyL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9jcnlwdG9Ob2RlLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ2tDO0FBQzNCLGVBQWUsMk1BQUUsV0FBVywyTUFBRSxpQkFBaUIsME5BQWlCLEdBQUcsa0RBQVk7QUFDdEYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9udXJzZWJsb2MvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvYXBpLWtleS1zdGFtcGVyL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9jcnlwdG9Ob2RlLmpzP2Y1NTciXSwic291cmNlc0NvbnRlbnQiOlsiLy8gV2UgdXNlIFdlYkNyeXB0byBha2EgZ2xvYmFsVGhpcy5jcnlwdG8sIHdoaWNoIGV4aXN0cyBpbiBicm93c2VycyBhbmQgbm9kZS5qcyAxNisuXG4vLyBTZWUgdXRpbHMudHMgZm9yIGRldGFpbHMuXG4vLyBUaGUgZmlsZSB3aWxsIHRocm93IG9uIG5vZGUuanMgMTQgYW5kIGVhcmxpZXIuXG4vLyBAdHMtaWdub3JlXG5pbXBvcnQgKiBhcyBuYyBmcm9tICdub2RlOmNyeXB0byc7XG5leHBvcnQgY29uc3QgY3J5cHRvID0gbmMgJiYgdHlwZW9mIG5jID09PSAnb2JqZWN0JyAmJiAnd2ViY3J5cHRvJyBpbiBuYyA/IG5jLndlYmNyeXB0byA6IHVuZGVmaW5lZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyeXB0b05vZGUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/api-key-stamper/node_modules/@noble/hashes/esm/cryptoNode.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/api-key-stamper/node_modules/@noble/hashes/esm/hmac.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@turnkey/api-key-stamper/node_modules/@noble/hashes/esm/hmac.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HMAC: () => (/* binding */ HMAC),\n/* harmony export */   hmac: () => (/* binding */ hmac)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./node_modules/@turnkey/api-key-stamper/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@turnkey/api-key-stamper/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// HMAC (RFC 2104)\nclass HMAC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.hash)(hash);\n        const key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.bytes)(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */\nconst hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key) => new HMAC(hash, key);\n//# sourceMappingURL=hmac.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvYXBpLWtleS1zdGFtcGVyL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9obWFjLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBZ0c7QUFDckQ7QUFDM0M7QUFDTyxtQkFBbUIsMkNBQUk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdEQUFVO0FBQ2xCLG9CQUFvQixrREFBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFZO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBWTtBQUNwQixRQUFRLGlEQUFXO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFLGdCQUFnQix5REFBeUQ7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbnVyc2VibG9jLy4vbm9kZV9tb2R1bGVzL0B0dXJua2V5L2FwaS1rZXktc3RhbXBlci9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vaG1hYy5qcz9kYzU5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGhhc2ggYXMgYXNzZXJ0SGFzaCwgYnl0ZXMgYXMgYXNzZXJ0Qnl0ZXMsIGV4aXN0cyBhcyBhc3NlcnRFeGlzdHMgfSBmcm9tICcuL19hc3NlcnQuanMnO1xuaW1wb3J0IHsgSGFzaCwgdG9CeXRlcyB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gSE1BQyAoUkZDIDIxMDQpXG5leHBvcnQgY2xhc3MgSE1BQyBleHRlbmRzIEhhc2gge1xuICAgIGNvbnN0cnVjdG9yKGhhc2gsIF9rZXkpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICBhc3NlcnRIYXNoKGhhc2gpO1xuICAgICAgICBjb25zdCBrZXkgPSB0b0J5dGVzKF9rZXkpO1xuICAgICAgICB0aGlzLmlIYXNoID0gaGFzaC5jcmVhdGUoKTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmlIYXNoLnVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgaW5zdGFuY2Ugb2YgY2xhc3Mgd2hpY2ggZXh0ZW5kcyB1dGlscy5IYXNoJyk7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSB0aGlzLmlIYXNoLmJsb2NrTGVuO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IHRoaXMuaUhhc2gub3V0cHV0TGVuO1xuICAgICAgICBjb25zdCBibG9ja0xlbiA9IHRoaXMuYmxvY2tMZW47XG4gICAgICAgIGNvbnN0IHBhZCA9IG5ldyBVaW50OEFycmF5KGJsb2NrTGVuKTtcbiAgICAgICAgLy8gYmxvY2tMZW4gY2FuIGJlIGJpZ2dlciB0aGFuIG91dHB1dExlblxuICAgICAgICBwYWQuc2V0KGtleS5sZW5ndGggPiBibG9ja0xlbiA/IGhhc2guY3JlYXRlKCkudXBkYXRlKGtleSkuZGlnZXN0KCkgOiBrZXkpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHBhZFtpXSBePSAweDM2O1xuICAgICAgICB0aGlzLmlIYXNoLnVwZGF0ZShwYWQpO1xuICAgICAgICAvLyBCeSBkb2luZyB1cGRhdGUgKHByb2Nlc3Npbmcgb2YgZmlyc3QgYmxvY2spIG9mIG91dGVyIGhhc2ggaGVyZSB3ZSBjYW4gcmUtdXNlIGl0IGJldHdlZW4gbXVsdGlwbGUgY2FsbHMgdmlhIGNsb25lXG4gICAgICAgIHRoaXMub0hhc2ggPSBoYXNoLmNyZWF0ZSgpO1xuICAgICAgICAvLyBVbmRvIGludGVybmFsIFhPUiAmJiBhcHBseSBvdXRlciBYT1JcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBwYWRbaV0gXj0gMHgzNiBeIDB4NWM7XG4gICAgICAgIHRoaXMub0hhc2gudXBkYXRlKHBhZCk7XG4gICAgICAgIHBhZC5maWxsKDApO1xuICAgIH1cbiAgICB1cGRhdGUoYnVmKSB7XG4gICAgICAgIGFzc2VydEV4aXN0cyh0aGlzKTtcbiAgICAgICAgdGhpcy5pSGFzaC51cGRhdGUoYnVmKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgIGFzc2VydEV4aXN0cyh0aGlzKTtcbiAgICAgICAgYXNzZXJ0Qnl0ZXMob3V0LCB0aGlzLm91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmlIYXNoLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgdGhpcy5vSGFzaC51cGRhdGUob3V0KTtcbiAgICAgICAgdGhpcy5vSGFzaC5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgIH1cbiAgICBkaWdlc3QoKSB7XG4gICAgICAgIGNvbnN0IG91dCA9IG5ldyBVaW50OEFycmF5KHRoaXMub0hhc2gub3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIF9jbG9uZUludG8odG8pIHtcbiAgICAgICAgLy8gQ3JlYXRlIG5ldyBpbnN0YW5jZSB3aXRob3V0IGNhbGxpbmcgY29uc3RydWN0b3Igc2luY2Uga2V5IGFscmVhZHkgaW4gc3RhdGUgYW5kIHdlIGRvbid0IGtub3cgaXQuXG4gICAgICAgIHRvIHx8ICh0byA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLCB7fSkpO1xuICAgICAgICBjb25zdCB7IG9IYXNoLCBpSGFzaCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgYmxvY2tMZW4sIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICAgICAgdG8gPSB0bztcbiAgICAgICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gZGVzdHJveWVkO1xuICAgICAgICB0by5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgICB0by5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRvLm9IYXNoID0gb0hhc2guX2Nsb25lSW50byh0by5vSGFzaCk7XG4gICAgICAgIHRvLmlIYXNoID0gaUhhc2guX2Nsb25lSW50byh0by5pSGFzaCk7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLm9IYXNoLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5pSGFzaC5kZXN0cm95KCk7XG4gICAgfVxufVxuLyoqXG4gKiBITUFDOiBSRkMyMTA0IG1lc3NhZ2UgYXV0aGVudGljYXRpb24gY29kZS5cbiAqIEBwYXJhbSBoYXNoIC0gZnVuY3Rpb24gdGhhdCB3b3VsZCBiZSB1c2VkIGUuZy4gc2hhMjU2XG4gKiBAcGFyYW0ga2V5IC0gbWVzc2FnZSBrZXlcbiAqIEBwYXJhbSBtZXNzYWdlIC0gbWVzc2FnZSBkYXRhXG4gKi9cbmV4cG9ydCBjb25zdCBobWFjID0gKGhhc2gsIGtleSwgbWVzc2FnZSkgPT4gbmV3IEhNQUMoaGFzaCwga2V5KS51cGRhdGUobWVzc2FnZSkuZGlnZXN0KCk7XG5obWFjLmNyZWF0ZSA9IChoYXNoLCBrZXkpID0+IG5ldyBITUFDKGhhc2gsIGtleSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1obWFjLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/api-key-stamper/node_modules/@noble/hashes/esm/hmac.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/api-key-stamper/node_modules/@noble/hashes/esm/sha256.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@turnkey/api-key-stamper/node_modules/@noble/hashes/esm/sha256.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sha224: () => (/* binding */ sha224),\n/* harmony export */   sha256: () => (/* binding */ sha256)\n/* harmony export */ });\n/* harmony import */ var _md_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_md.js */ \"(ssr)/./node_modules/@turnkey/api-key-stamper/node_modules/@noble/hashes/esm/_md.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@turnkey/api-key-stamper/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state:\n// first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19\n// prettier-ignore\nconst SHA256_IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends _md_js__WEBPACK_IMPORTED_MODULE_0__.HashMD {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = SHA256_IV[0] | 0;\n        this.B = SHA256_IV[1] | 0;\n        this.C = SHA256_IV[2] | 0;\n        this.D = SHA256_IV[3] | 0;\n        this.E = SHA256_IV[4] | 0;\n        this.F = SHA256_IV[5] | 0;\n        this.G = SHA256_IV[6] | 0;\n        this.H = SHA256_IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 7) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 18) ^ (W15 >>> 3);\n            const s1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 17) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 6) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 11) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 25);\n            const T1 = (H + sigma1 + (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 2) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 13) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 22);\n            const T2 = (sigma0 + (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Maj)(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nconst sha256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA256());\nconst sha224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA224());\n//# sourceMappingURL=sha256.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvYXBpLWtleS1zdGFtcGVyL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGEyNTYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUE0QztBQUNPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwwQ0FBTTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlCQUF5QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQSx1QkFBdUIsK0NBQUksV0FBVywrQ0FBSTtBQUMxQyx1QkFBdUIsK0NBQUksV0FBVywrQ0FBSTtBQUMxQztBQUNBO0FBQ0E7QUFDQSxjQUFjLHlCQUF5QjtBQUN2Qyx3QkFBd0IsUUFBUTtBQUNoQywyQkFBMkIsK0NBQUksU0FBUywrQ0FBSSxVQUFVLCtDQUFJO0FBQzFELHFDQUFxQywyQ0FBRztBQUN4QywyQkFBMkIsK0NBQUksU0FBUywrQ0FBSSxVQUFVLCtDQUFJO0FBQzFELGlDQUFpQywyQ0FBRztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sK0JBQStCLDBEQUFlO0FBQzlDLCtCQUErQiwwREFBZTtBQUNyRCIsInNvdXJjZXMiOlsid2VicGFjazovL251cnNlYmxvYy8uL25vZGVfbW9kdWxlcy9AdHVybmtleS9hcGkta2V5LXN0YW1wZXIvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTI1Ni5qcz9kODIwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEhhc2hNRCwgQ2hpLCBNYWogfSBmcm9tICcuL19tZC5qcyc7XG5pbXBvcnQgeyByb3RyLCB3cmFwQ29uc3RydWN0b3IgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIFNIQTItMjU2IG5lZWQgdG8gdHJ5IDJeMTI4IGhhc2hlcyB0byBleGVjdXRlIGJpcnRoZGF5IGF0dGFjay5cbi8vIEJUQyBuZXR3b3JrIGlzIGRvaW5nIDJeNjcgaGFzaGVzL3NlYyBhcyBwZXIgZWFybHkgMjAyMy5cbi8vIFJvdW5kIGNvbnN0YW50czpcbi8vIGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIGN1YmUgcm9vdHMgb2YgdGhlIGZpcnN0IDY0IHByaW1lcyAyLi4zMTEpXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IFNIQTI1Nl9LID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheShbXG4gICAgMHg0MjhhMmY5OCwgMHg3MTM3NDQ5MSwgMHhiNWMwZmJjZiwgMHhlOWI1ZGJhNSwgMHgzOTU2YzI1YiwgMHg1OWYxMTFmMSwgMHg5MjNmODJhNCwgMHhhYjFjNWVkNSxcbiAgICAweGQ4MDdhYTk4LCAweDEyODM1YjAxLCAweDI0MzE4NWJlLCAweDU1MGM3ZGMzLCAweDcyYmU1ZDc0LCAweDgwZGViMWZlLCAweDliZGMwNmE3LCAweGMxOWJmMTc0LFxuICAgIDB4ZTQ5YjY5YzEsIDB4ZWZiZTQ3ODYsIDB4MGZjMTlkYzYsIDB4MjQwY2ExY2MsIDB4MmRlOTJjNmYsIDB4NGE3NDg0YWEsIDB4NWNiMGE5ZGMsIDB4NzZmOTg4ZGEsXG4gICAgMHg5ODNlNTE1MiwgMHhhODMxYzY2ZCwgMHhiMDAzMjdjOCwgMHhiZjU5N2ZjNywgMHhjNmUwMGJmMywgMHhkNWE3OTE0NywgMHgwNmNhNjM1MSwgMHgxNDI5Mjk2NyxcbiAgICAweDI3YjcwYTg1LCAweDJlMWIyMTM4LCAweDRkMmM2ZGZjLCAweDUzMzgwZDEzLCAweDY1MGE3MzU0LCAweDc2NmEwYWJiLCAweDgxYzJjOTJlLCAweDkyNzIyYzg1LFxuICAgIDB4YTJiZmU4YTEsIDB4YTgxYTY2NGIsIDB4YzI0YjhiNzAsIDB4Yzc2YzUxYTMsIDB4ZDE5MmU4MTksIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsXG4gICAgMHgxOWE0YzExNiwgMHgxZTM3NmMwOCwgMHgyNzQ4Nzc0YywgMHgzNGIwYmNiNSwgMHgzOTFjMGNiMywgMHg0ZWQ4YWE0YSwgMHg1YjljY2E0ZiwgMHg2ODJlNmZmMyxcbiAgICAweDc0OGY4MmVlLCAweDc4YTU2MzZmLCAweDg0Yzg3ODE0LCAweDhjYzcwMjA4LCAweDkwYmVmZmZhLCAweGE0NTA2Y2ViLCAweGJlZjlhM2Y3LCAweGM2NzE3OGYyXG5dKTtcbi8vIEluaXRpYWwgc3RhdGU6XG4vLyBmaXJzdCAzMiBiaXRzIG9mIHRoZSBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBzcXVhcmUgcm9vdHMgb2YgdGhlIGZpcnN0IDggcHJpbWVzIDIuLjE5XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IFNIQTI1Nl9JViA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoW1xuICAgIDB4NmEwOWU2NjcsIDB4YmI2N2FlODUsIDB4M2M2ZWYzNzIsIDB4YTU0ZmY1M2EsIDB4NTEwZTUyN2YsIDB4OWIwNTY4OGMsIDB4MWY4M2Q5YWIsIDB4NWJlMGNkMTlcbl0pO1xuLy8gVGVtcG9yYXJ5IGJ1ZmZlciwgbm90IHVzZWQgdG8gc3RvcmUgYW55dGhpbmcgYmV0d2VlbiBydW5zXG4vLyBOYW1lZCB0aGlzIHdheSBiZWNhdXNlIGl0IG1hdGNoZXMgc3BlY2lmaWNhdGlvbi5cbmNvbnN0IFNIQTI1Nl9XID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheSg2NCk7XG5jbGFzcyBTSEEyNTYgZXh0ZW5kcyBIYXNoTUQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcig2NCwgMzIsIDgsIGZhbHNlKTtcbiAgICAgICAgLy8gV2UgY2Fubm90IHVzZSBhcnJheSBoZXJlIHNpbmNlIGFycmF5IGFsbG93cyBpbmRleGluZyBieSB2YXJpYWJsZVxuICAgICAgICAvLyB3aGljaCBtZWFucyBvcHRpbWl6ZXIvY29tcGlsZXIgY2Fubm90IHVzZSByZWdpc3RlcnMuXG4gICAgICAgIHRoaXMuQSA9IFNIQTI1Nl9JVlswXSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IFNIQTI1Nl9JVlsxXSB8IDA7XG4gICAgICAgIHRoaXMuQyA9IFNIQTI1Nl9JVlsyXSB8IDA7XG4gICAgICAgIHRoaXMuRCA9IFNIQTI1Nl9JVlszXSB8IDA7XG4gICAgICAgIHRoaXMuRSA9IFNIQTI1Nl9JVls0XSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IFNIQTI1Nl9JVls1XSB8IDA7XG4gICAgICAgIHRoaXMuRyA9IFNIQTI1Nl9JVls2XSB8IDA7XG4gICAgICAgIHRoaXMuSCA9IFNIQTI1Nl9JVls3XSB8IDA7XG4gICAgfVxuICAgIGdldCgpIHtcbiAgICAgICAgY29uc3QgeyBBLCBCLCBDLCBELCBFLCBGLCBHLCBIIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW0EsIEIsIEMsIEQsIEUsIEYsIEcsIEhdO1xuICAgIH1cbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBzZXQoQSwgQiwgQywgRCwgRSwgRiwgRywgSCkge1xuICAgICAgICB0aGlzLkEgPSBBIHwgMDtcbiAgICAgICAgdGhpcy5CID0gQiB8IDA7XG4gICAgICAgIHRoaXMuQyA9IEMgfCAwO1xuICAgICAgICB0aGlzLkQgPSBEIHwgMDtcbiAgICAgICAgdGhpcy5FID0gRSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IEYgfCAwO1xuICAgICAgICB0aGlzLkcgPSBHIHwgMDtcbiAgICAgICAgdGhpcy5IID0gSCB8IDA7XG4gICAgfVxuICAgIHByb2Nlc3Modmlldywgb2Zmc2V0KSB7XG4gICAgICAgIC8vIEV4dGVuZCB0aGUgZmlyc3QgMTYgd29yZHMgaW50byB0aGUgcmVtYWluaW5nIDQ4IHdvcmRzIHdbMTYuLjYzXSBvZiB0aGUgbWVzc2FnZSBzY2hlZHVsZSBhcnJheVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyssIG9mZnNldCArPSA0KVxuICAgICAgICAgICAgU0hBMjU2X1dbaV0gPSB2aWV3LmdldFVpbnQzMihvZmZzZXQsIGZhbHNlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE2OyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgVzE1ID0gU0hBMjU2X1dbaSAtIDE1XTtcbiAgICAgICAgICAgIGNvbnN0IFcyID0gU0hBMjU2X1dbaSAtIDJdO1xuICAgICAgICAgICAgY29uc3QgczAgPSByb3RyKFcxNSwgNykgXiByb3RyKFcxNSwgMTgpIF4gKFcxNSA+Pj4gMyk7XG4gICAgICAgICAgICBjb25zdCBzMSA9IHJvdHIoVzIsIDE3KSBeIHJvdHIoVzIsIDE5KSBeIChXMiA+Pj4gMTApO1xuICAgICAgICAgICAgU0hBMjU2X1dbaV0gPSAoczEgKyBTSEEyNTZfV1tpIC0gN10gKyBzMCArIFNIQTI1Nl9XW2kgLSAxNl0pIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wcmVzc2lvbiBmdW5jdGlvbiBtYWluIGxvb3AsIDY0IHJvdW5kc1xuICAgICAgICBsZXQgeyBBLCBCLCBDLCBELCBFLCBGLCBHLCBIIH0gPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY0OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMSA9IHJvdHIoRSwgNikgXiByb3RyKEUsIDExKSBeIHJvdHIoRSwgMjUpO1xuICAgICAgICAgICAgY29uc3QgVDEgPSAoSCArIHNpZ21hMSArIENoaShFLCBGLCBHKSArIFNIQTI1Nl9LW2ldICsgU0hBMjU2X1dbaV0pIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMCA9IHJvdHIoQSwgMikgXiByb3RyKEEsIDEzKSBeIHJvdHIoQSwgMjIpO1xuICAgICAgICAgICAgY29uc3QgVDIgPSAoc2lnbWEwICsgTWFqKEEsIEIsIEMpKSB8IDA7XG4gICAgICAgICAgICBIID0gRztcbiAgICAgICAgICAgIEcgPSBGO1xuICAgICAgICAgICAgRiA9IEU7XG4gICAgICAgICAgICBFID0gKEQgKyBUMSkgfCAwO1xuICAgICAgICAgICAgRCA9IEM7XG4gICAgICAgICAgICBDID0gQjtcbiAgICAgICAgICAgIEIgPSBBO1xuICAgICAgICAgICAgQSA9IChUMSArIFQyKSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBjb21wcmVzc2VkIGNodW5rIHRvIHRoZSBjdXJyZW50IGhhc2ggdmFsdWVcbiAgICAgICAgQSA9IChBICsgdGhpcy5BKSB8IDA7XG4gICAgICAgIEIgPSAoQiArIHRoaXMuQikgfCAwO1xuICAgICAgICBDID0gKEMgKyB0aGlzLkMpIHwgMDtcbiAgICAgICAgRCA9IChEICsgdGhpcy5EKSB8IDA7XG4gICAgICAgIEUgPSAoRSArIHRoaXMuRSkgfCAwO1xuICAgICAgICBGID0gKEYgKyB0aGlzLkYpIHwgMDtcbiAgICAgICAgRyA9IChHICsgdGhpcy5HKSB8IDA7XG4gICAgICAgIEggPSAoSCArIHRoaXMuSCkgfCAwO1xuICAgICAgICB0aGlzLnNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKTtcbiAgICB9XG4gICAgcm91bmRDbGVhbigpIHtcbiAgICAgICAgU0hBMjU2X1cuZmlsbCgwKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgICAgIHRoaXMuYnVmZmVyLmZpbGwoMCk7XG4gICAgfVxufVxuLy8gQ29uc3RhbnRzIGZyb20gaHR0cHM6Ly9udmxwdWJzLm5pc3QuZ292L25pc3RwdWJzL0ZJUFMvTklTVC5GSVBTLjE4MC00LnBkZlxuY2xhc3MgU0hBMjI0IGV4dGVuZHMgU0hBMjU2IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5BID0gMHhjMTA1OWVkOCB8IDA7XG4gICAgICAgIHRoaXMuQiA9IDB4MzY3Y2Q1MDcgfCAwO1xuICAgICAgICB0aGlzLkMgPSAweDMwNzBkZDE3IHwgMDtcbiAgICAgICAgdGhpcy5EID0gMHhmNzBlNTkzOSB8IDA7XG4gICAgICAgIHRoaXMuRSA9IDB4ZmZjMDBiMzEgfCAwO1xuICAgICAgICB0aGlzLkYgPSAweDY4NTgxNTExIHwgMDtcbiAgICAgICAgdGhpcy5HID0gMHg2NGY5OGZhNyB8IDA7XG4gICAgICAgIHRoaXMuSCA9IDB4YmVmYTRmYTQgfCAwO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IDI4O1xuICAgIH1cbn1cbi8qKlxuICogU0hBMi0yNTYgaGFzaCBmdW5jdGlvblxuICogQHBhcmFtIG1lc3NhZ2UgLSBkYXRhIHRoYXQgd291bGQgYmUgaGFzaGVkXG4gKi9cbmV4cG9ydCBjb25zdCBzaGEyNTYgPSAvKiBAX19QVVJFX18gKi8gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBTSEEyNTYoKSk7XG5leHBvcnQgY29uc3Qgc2hhMjI0ID0gLyogQF9fUFVSRV9fICovIHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgU0hBMjI0KCkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhMjU2LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/api-key-stamper/node_modules/@noble/hashes/esm/sha256.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/api-key-stamper/node_modules/@noble/hashes/esm/utils.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@turnkey/api-key-stamper/node_modules/@noble/hashes/esm/utils.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hash: () => (/* binding */ Hash),\n/* harmony export */   asyncLoop: () => (/* binding */ asyncLoop),\n/* harmony export */   byteSwap: () => (/* binding */ byteSwap),\n/* harmony export */   byteSwap32: () => (/* binding */ byteSwap32),\n/* harmony export */   byteSwapIfBE: () => (/* binding */ byteSwapIfBE),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   checkOpts: () => (/* binding */ checkOpts),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createView: () => (/* binding */ createView),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   isBytes: () => (/* binding */ isBytes),\n/* harmony export */   isLE: () => (/* binding */ isLE),\n/* harmony export */   nextTick: () => (/* binding */ nextTick),\n/* harmony export */   randomBytes: () => (/* binding */ randomBytes),\n/* harmony export */   rotl: () => (/* binding */ rotl),\n/* harmony export */   rotr: () => (/* binding */ rotr),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   u32: () => (/* binding */ u32),\n/* harmony export */   u8: () => (/* binding */ u8),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   wrapConstructor: () => (/* binding */ wrapConstructor),\n/* harmony export */   wrapConstructorWithOpts: () => (/* binding */ wrapConstructorWithOpts),\n/* harmony export */   wrapXOFConstructorWithOpts: () => (/* binding */ wrapXOFConstructorWithOpts)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/crypto */ \"(ssr)/./node_modules/@turnkey/api-key-stamper/node_modules/@noble/hashes/esm/cryptoNode.js\");\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./node_modules/@turnkey/api-key-stamper/node_modules/@noble/hashes/esm/_assert.js\");\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\n\n\n// export { isBytes } from './_assert.js';\n// We can't reuse isBytes from _assert, because somehow this causes huge perf issues\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\n// Cast array to different type\nconst u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nconst u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nconst createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\n// The rotate left (circular left shift) operation for uint32\nconst rotl = (word, shift) => (word << shift) | ((word >>> (32 - shift)) >>> 0);\nconst isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\n// The byte swap operation for uint32\nconst byteSwap = (word) => ((word << 24) & 0xff000000) |\n    ((word << 8) & 0xff0000) |\n    ((word >>> 8) & 0xff00) |\n    ((word >>> 24) & 0xff);\n// Conditionally byte swap if on a big-endian platform\nconst byteSwapIfBE = isLE ? (n) => n : (n) => byteSwap(n);\n// In place byte swap for Uint32Array\nfunction byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = byteSwap(arr[i]);\n    }\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(bytes);\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9)\n        return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F)\n        return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f)\n        return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(data);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nconst toStr = {}.toString;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nfunction wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nfunction randomBytes(bytesLength = 32) {\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto.getRandomValues === 'function') {\n        return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvYXBpLWtleS1zdGFtcGVyL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDOEM7QUFDQztBQUMvQyxZQUFZLFVBQVU7QUFDdEI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDTztBQUNBO0FBQ1A7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNPO0FBQ1Asb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxhQUFhO0FBQ3hEO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsSUFBSSxpREFBTTtBQUNWO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixTQUFTO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsNERBQTRELFdBQVc7QUFDdkUsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLElBQUksaURBQU07QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQSxRQUFRLGlEQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLG1CQUFtQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNUO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFFBQVEsd0RBQU0sV0FBVyx3REFBTTtBQUMvQixlQUFlLHdEQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbnVyc2VibG9jLy4vbm9kZV9tb2R1bGVzL0B0dXJua2V5L2FwaS1rZXktc3RhbXBlci9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vdXRpbHMuanM/Mjk0NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtaGFzaGVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBXZSB1c2UgV2ViQ3J5cHRvIGFrYSBnbG9iYWxUaGlzLmNyeXB0bywgd2hpY2ggZXhpc3RzIGluIGJyb3dzZXJzIGFuZCBub2RlLmpzIDE2Ky5cbi8vIG5vZGUuanMgdmVyc2lvbnMgZWFybGllciB0aGFuIHYxOSBkb24ndCBkZWNsYXJlIGl0IGluIGdsb2JhbCBzY29wZS5cbi8vIEZvciBub2RlLmpzLCBwYWNrYWdlLmpzb24jZXhwb3J0cyBmaWVsZCBtYXBwaW5nIHJld3JpdGVzIGltcG9ydFxuLy8gZnJvbSBgY3J5cHRvYCB0byBgY3J5cHRvTm9kZWAsIHdoaWNoIGltcG9ydHMgbmF0aXZlIG1vZHVsZS5cbi8vIE1ha2VzIHRoZSB1dGlscyB1bi1pbXBvcnRhYmxlIGluIGJyb3dzZXJzIHdpdGhvdXQgYSBidW5kbGVyLlxuLy8gT25jZSBub2RlLmpzIDE4IGlzIGRlcHJlY2F0ZWQgKDIwMjUtMDQtMzApLCB3ZSBjYW4ganVzdCBkcm9wIHRoZSBpbXBvcnQuXG5pbXBvcnQgeyBjcnlwdG8gfSBmcm9tICdAbm9ibGUvaGFzaGVzL2NyeXB0byc7XG5pbXBvcnQgeyBieXRlcyBhcyBhYnl0ZXMgfSBmcm9tICcuL19hc3NlcnQuanMnO1xuLy8gZXhwb3J0IHsgaXNCeXRlcyB9IGZyb20gJy4vX2Fzc2VydC5qcyc7XG4vLyBXZSBjYW4ndCByZXVzZSBpc0J5dGVzIGZyb20gX2Fzc2VydCwgYmVjYXVzZSBzb21laG93IHRoaXMgY2F1c2VzIGh1Z2UgcGVyZiBpc3N1ZXNcbmV4cG9ydCBmdW5jdGlvbiBpc0J5dGVzKGEpIHtcbiAgICByZXR1cm4gKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8XG4gICAgICAgIChhICE9IG51bGwgJiYgdHlwZW9mIGEgPT09ICdvYmplY3QnICYmIGEuY29uc3RydWN0b3IubmFtZSA9PT0gJ1VpbnQ4QXJyYXknKSk7XG59XG4vLyBDYXN0IGFycmF5IHRvIGRpZmZlcmVudCB0eXBlXG5leHBvcnQgY29uc3QgdTggPSAoYXJyKSA9PiBuZXcgVWludDhBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xuZXhwb3J0IGNvbnN0IHUzMiA9IChhcnIpID0+IG5ldyBVaW50MzJBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgTWF0aC5mbG9vcihhcnIuYnl0ZUxlbmd0aCAvIDQpKTtcbi8vIENhc3QgYXJyYXkgdG8gdmlld1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVZpZXcgPSAoYXJyKSA9PiBuZXcgRGF0YVZpZXcoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbi8vIFRoZSByb3RhdGUgcmlnaHQgKGNpcmN1bGFyIHJpZ2h0IHNoaWZ0KSBvcGVyYXRpb24gZm9yIHVpbnQzMlxuZXhwb3J0IGNvbnN0IHJvdHIgPSAod29yZCwgc2hpZnQpID0+ICh3b3JkIDw8ICgzMiAtIHNoaWZ0KSkgfCAod29yZCA+Pj4gc2hpZnQpO1xuLy8gVGhlIHJvdGF0ZSBsZWZ0IChjaXJjdWxhciBsZWZ0IHNoaWZ0KSBvcGVyYXRpb24gZm9yIHVpbnQzMlxuZXhwb3J0IGNvbnN0IHJvdGwgPSAod29yZCwgc2hpZnQpID0+ICh3b3JkIDw8IHNoaWZ0KSB8ICgod29yZCA+Pj4gKDMyIC0gc2hpZnQpKSA+Pj4gMCk7XG5leHBvcnQgY29uc3QgaXNMRSA9IG5ldyBVaW50OEFycmF5KG5ldyBVaW50MzJBcnJheShbMHgxMTIyMzM0NF0pLmJ1ZmZlcilbMF0gPT09IDB4NDQ7XG4vLyBUaGUgYnl0ZSBzd2FwIG9wZXJhdGlvbiBmb3IgdWludDMyXG5leHBvcnQgY29uc3QgYnl0ZVN3YXAgPSAod29yZCkgPT4gKCh3b3JkIDw8IDI0KSAmIDB4ZmYwMDAwMDApIHxcbiAgICAoKHdvcmQgPDwgOCkgJiAweGZmMDAwMCkgfFxuICAgICgod29yZCA+Pj4gOCkgJiAweGZmMDApIHxcbiAgICAoKHdvcmQgPj4+IDI0KSAmIDB4ZmYpO1xuLy8gQ29uZGl0aW9uYWxseSBieXRlIHN3YXAgaWYgb24gYSBiaWctZW5kaWFuIHBsYXRmb3JtXG5leHBvcnQgY29uc3QgYnl0ZVN3YXBJZkJFID0gaXNMRSA/IChuKSA9PiBuIDogKG4pID0+IGJ5dGVTd2FwKG4pO1xuLy8gSW4gcGxhY2UgYnl0ZSBzd2FwIGZvciBVaW50MzJBcnJheVxuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVTd2FwMzIoYXJyKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyW2ldID0gYnl0ZVN3YXAoYXJyW2ldKTtcbiAgICB9XG59XG4vLyBBcnJheSB3aGVyZSBpbmRleCAweGYwICgyNDApIGlzIG1hcHBlZCB0byBzdHJpbmcgJ2YwJ1xuY29uc3QgaGV4ZXMgPSAvKiBAX19QVVJFX18gKi8gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sIChfLCBpKSA9PiBpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbi8qKlxuICogQGV4YW1wbGUgYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKSkgLy8gJ2NhZmUwMTIzJ1xuICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuICAgIGFieXRlcyhieXRlcyk7XG4gICAgLy8gcHJlLWNhY2hpbmcgaW1wcm92ZXMgdGhlIHNwZWVkIDZ4XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IGhleGVzW2J5dGVzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbi8vIFdlIHVzZSBvcHRpbWl6ZWQgdGVjaG5pcXVlIHRvIGNvbnZlcnQgaGV4IHN0cmluZyB0byBieXRlIGFycmF5XG5jb25zdCBhc2NpaXMgPSB7IF8wOiA0OCwgXzk6IDU3LCBfQTogNjUsIF9GOiA3MCwgX2E6IDk3LCBfZjogMTAyIH07XG5mdW5jdGlvbiBhc2NpaVRvQmFzZTE2KGNoYXIpIHtcbiAgICBpZiAoY2hhciA+PSBhc2NpaXMuXzAgJiYgY2hhciA8PSBhc2NpaXMuXzkpXG4gICAgICAgIHJldHVybiBjaGFyIC0gYXNjaWlzLl8wO1xuICAgIGlmIChjaGFyID49IGFzY2lpcy5fQSAmJiBjaGFyIDw9IGFzY2lpcy5fRilcbiAgICAgICAgcmV0dXJuIGNoYXIgLSAoYXNjaWlzLl9BIC0gMTApO1xuICAgIGlmIChjaGFyID49IGFzY2lpcy5fYSAmJiBjaGFyIDw9IGFzY2lpcy5fZilcbiAgICAgICAgcmV0dXJuIGNoYXIgLSAoYXNjaWlzLl9hIC0gMTApO1xuICAgIHJldHVybjtcbn1cbi8qKlxuICogQGV4YW1wbGUgaGV4VG9CeXRlcygnY2FmZTAxMjMnKSAvLyBVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGV4VG9CeXRlcyhoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICBjb25zdCBobCA9IGhleC5sZW5ndGg7XG4gICAgY29uc3QgYWwgPSBobCAvIDI7XG4gICAgaWYgKGhsICUgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkZWQgaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IHVucGFkZGVkIGhleCBvZiBsZW5ndGggJyArIGhsKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFsKTtcbiAgICBmb3IgKGxldCBhaSA9IDAsIGhpID0gMDsgYWkgPCBhbDsgYWkrKywgaGkgKz0gMikge1xuICAgICAgICBjb25zdCBuMSA9IGFzY2lpVG9CYXNlMTYoaGV4LmNoYXJDb2RlQXQoaGkpKTtcbiAgICAgICAgY29uc3QgbjIgPSBhc2NpaVRvQmFzZTE2KGhleC5jaGFyQ29kZUF0KGhpICsgMSkpO1xuICAgICAgICBpZiAobjEgPT09IHVuZGVmaW5lZCB8fCBuMiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFyID0gaGV4W2hpXSArIGhleFtoaSArIDFdO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3Qgbm9uLWhleCBjaGFyYWN0ZXIgXCInICsgY2hhciArICdcIiBhdCBpbmRleCAnICsgaGkpO1xuICAgICAgICB9XG4gICAgICAgIGFycmF5W2FpXSA9IG4xICogMTYgKyBuMjtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuLy8gVGhlcmUgaXMgbm8gc2V0SW1tZWRpYXRlIGluIGJyb3dzZXIgYW5kIHNldFRpbWVvdXQgaXMgc2xvdy5cbi8vIGNhbGwgb2YgYXN5bmMgZm4gd2lsbCByZXR1cm4gUHJvbWlzZSwgd2hpY2ggd2lsbCBiZSBmdWxsZmlsZWQgb25seSBvblxuLy8gbmV4dCBzY2hlZHVsZXIgcXVldWUgcHJvY2Vzc2luZyBzdGVwIGFuZCB0aGlzIGlzIGV4YWN0bHkgd2hhdCB3ZSBuZWVkLlxuZXhwb3J0IGNvbnN0IG5leHRUaWNrID0gYXN5bmMgKCkgPT4geyB9O1xuLy8gUmV0dXJucyBjb250cm9sIHRvIHRocmVhZCBlYWNoICd0aWNrJyBtcyB0byBhdm9pZCBibG9ja2luZ1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFzeW5jTG9vcChpdGVycywgdGljaywgY2IpIHtcbiAgICBsZXQgdHMgPSBEYXRlLm5vdygpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcnM7IGkrKykge1xuICAgICAgICBjYihpKTtcbiAgICAgICAgLy8gRGF0ZS5ub3coKSBpcyBub3QgbW9ub3RvbmljLCBzbyBpbiBjYXNlIGlmIGNsb2NrIGdvZXMgYmFja3dhcmRzIHdlIHJldHVybiByZXR1cm4gY29udHJvbCB0b29cbiAgICAgICAgY29uc3QgZGlmZiA9IERhdGUubm93KCkgLSB0cztcbiAgICAgICAgaWYgKGRpZmYgPj0gMCAmJiBkaWZmIDwgdGljaylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBhd2FpdCBuZXh0VGljaygpO1xuICAgICAgICB0cyArPSBkaWZmO1xuICAgIH1cbn1cbi8qKlxuICogQGV4YW1wbGUgdXRmOFRvQnl0ZXMoJ2FiYycpIC8vIG5ldyBVaW50OEFycmF5KFs5NywgOTgsIDk5XSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1dGY4VG9CeXRlcyBleHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiBzdHJ9YCk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpKTsgLy8gaHR0cHM6Ly9idWd6aWwubGEvMTY4MTgwOVxufVxuLyoqXG4gKiBOb3JtYWxpemVzIChub24taGV4KSBzdHJpbmcgb3IgVWludDhBcnJheSB0byBVaW50OEFycmF5LlxuICogV2FybmluZzogd2hlbiBVaW50OEFycmF5IGlzIHBhc3NlZCwgaXQgd291bGQgTk9UIGdldCBjb3BpZWQuXG4gKiBLZWVwIGluIG1pbmQgZm9yIGZ1dHVyZSBtdXRhYmxlIG9wZXJhdGlvbnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0J5dGVzKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKVxuICAgICAgICBkYXRhID0gdXRmOFRvQnl0ZXMoZGF0YSk7XG4gICAgYWJ5dGVzKGRhdGEpO1xuICAgIHJldHVybiBkYXRhO1xufVxuLyoqXG4gKiBDb3BpZXMgc2V2ZXJhbCBVaW50OEFycmF5cyBpbnRvIG9uZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5cykge1xuICAgIGxldCBzdW0gPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBhcnJheXNbaV07XG4gICAgICAgIGFieXRlcyhhKTtcbiAgICAgICAgc3VtICs9IGEubGVuZ3RoO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheShzdW0pO1xuICAgIGZvciAobGV0IGkgPSAwLCBwYWQgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBhcnJheXNbaV07XG4gICAgICAgIHJlcy5zZXQoYSwgcGFkKTtcbiAgICAgICAgcGFkICs9IGEubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLy8gRm9yIHJ1bnRpbWUgY2hlY2sgaWYgY2xhc3MgaW1wbGVtZW50cyBpbnRlcmZhY2VcbmV4cG9ydCBjbGFzcyBIYXNoIHtcbiAgICAvLyBTYWZlIHZlcnNpb24gdGhhdCBjbG9uZXMgaW50ZXJuYWwgc3RhdGVcbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb25lSW50bygpO1xuICAgIH1cbn1cbmNvbnN0IHRvU3RyID0ge30udG9TdHJpbmc7XG5leHBvcnQgZnVuY3Rpb24gY2hlY2tPcHRzKGRlZmF1bHRzLCBvcHRzKSB7XG4gICAgaWYgKG9wdHMgIT09IHVuZGVmaW5lZCAmJiB0b1N0ci5jYWxsKG9wdHMpICE9PSAnW29iamVjdCBPYmplY3RdJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcHRpb25zIHNob3VsZCBiZSBvYmplY3Qgb3IgdW5kZWZpbmVkJyk7XG4gICAgY29uc3QgbWVyZ2VkID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0cywgb3B0cyk7XG4gICAgcmV0dXJuIG1lcmdlZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiB3cmFwQ29uc3RydWN0b3IoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2cpID0+IGhhc2hDb25zKCkudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoKTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9ICgpID0+IGhhc2hDb25zKCk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBDb25zdHJ1Y3RvcldpdGhPcHRzKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnLCBvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucyh7fSk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAob3B0cykgPT4gaGFzaENvbnMob3B0cyk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnLCBvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucyh7fSk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAob3B0cykgPT4gaGFzaENvbnMob3B0cyk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuLyoqXG4gKiBTZWN1cmUgUFJORy4gVXNlcyBgY3J5cHRvLmdldFJhbmRvbVZhbHVlc2AsIHdoaWNoIGRlZmVycyB0byBPUy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbUJ5dGVzKGJ5dGVzTGVuZ3RoID0gMzIpIHtcbiAgICBpZiAoY3J5cHRvICYmIHR5cGVvZiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KGJ5dGVzTGVuZ3RoKSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignY3J5cHRvLmdldFJhbmRvbVZhbHVlcyBtdXN0IGJlIGRlZmluZWQnKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/api-key-stamper/node_modules/@noble/hashes/esm/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/encoding/dist/index.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@turnkey/encoding/dist/index.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   base64StringToBase64UrlEncodedString: () => (/* binding */ base64StringToBase64UrlEncodedString),\n/* harmony export */   stringToBase64urlString: () => (/* binding */ stringToBase64urlString),\n/* harmony export */   uint8ArrayToHexString: () => (/* binding */ uint8ArrayToHexString)\n/* harmony export */ });\n/**\n * Code modified from https://github.com/github/webauthn-json/blob/e932b3585fa70b0bd5b5a4012ba7dbad7b0a0d0f/src/webauthn-json/base64url.ts#L23\n */\nfunction stringToBase64urlString(input) {\n    // string to base64 -- we do not rely on the browser's btoa since it's not present in React Native environments\n    const base64String = btoa(input);\n    return base64StringToBase64UrlEncodedString(base64String);\n}\nfunction base64StringToBase64UrlEncodedString(input) {\n    return input.replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=/g, \"\");\n}\nfunction uint8ArrayToHexString(input) {\n    return input.reduce((result, x) => result + x.toString(16).padStart(2, \"0\"), \"\");\n}\n// Polyfill btoa with a pure JS implementation. This is adapted from the following:\n// https://github.com/jsdom/abab/blob/80874ae1fe1cde2e587bb6e51b6d7c9b42ca1d34/lib/btoa.js\nfunction btoa(s) {\n    if (arguments.length === 0) {\n        throw new TypeError(\"1 argument required, but only 0 present.\");\n    }\n    let i;\n    // String conversion as required by Web IDL.\n    s = `${s}`;\n    // \"The btoa() method must throw an \"InvalidCharacterError\" DOMException if\n    // data contains any character whose code point is greater than U+00FF.\"\n    for (i = 0; i < s.length; i++) {\n        if (s.charCodeAt(i) > 255) {\n            throw new Error(`InvalidCharacterError: found code point greater than 255:${s.charCodeAt(i)} at position ${i}`);\n        }\n    }\n    let out = \"\";\n    for (i = 0; i < s.length; i += 3) {\n        const groupsOfSix = [\n            undefined,\n            undefined,\n            undefined,\n            undefined,\n        ];\n        groupsOfSix[0] = s.charCodeAt(i) >> 2;\n        groupsOfSix[1] = (s.charCodeAt(i) & 0x03) << 4;\n        if (s.length > i + 1) {\n            groupsOfSix[1] |= s.charCodeAt(i + 1) >> 4;\n            groupsOfSix[2] = (s.charCodeAt(i + 1) & 0x0f) << 2;\n        }\n        if (s.length > i + 2) {\n            groupsOfSix[2] |= s.charCodeAt(i + 2) >> 6;\n            groupsOfSix[3] = s.charCodeAt(i + 2) & 0x3f;\n        }\n        for (let j = 0; j < groupsOfSix.length; j++) {\n            if (typeof groupsOfSix[j] === \"undefined\") {\n                out += \"=\";\n            }\n            else {\n                out += btoaLookup(groupsOfSix[j]);\n            }\n        }\n    }\n    return out;\n}\nfunction btoaLookup(index) {\n    /**\n     * Lookup table for btoa(), which converts a six-bit number into the\n     * corresponding ASCII character.\n     */\n    const keystr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n    if (index >= 0 && index < 64) {\n        return keystr[index];\n    }\n    // Throw INVALID_CHARACTER_ERR exception here -- won't be hit in the tests.\n    return undefined;\n}\n\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvZW5jb2RpbmcvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYjtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQSx3RkFBd0YsaUJBQWlCLGNBQWMsRUFBRTtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWdHO0FBQ2hHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbnVyc2VibG9jLy4vbm9kZV9tb2R1bGVzL0B0dXJua2V5L2VuY29kaW5nL2Rpc3QvaW5kZXgubWpzPzlhNTAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb2RlIG1vZGlmaWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2dpdGh1Yi93ZWJhdXRobi1qc29uL2Jsb2IvZTkzMmIzNTg1ZmE3MGIwYmQ1YjVhNDAxMmJhN2RiYWQ3YjBhMGQwZi9zcmMvd2ViYXV0aG4tanNvbi9iYXNlNjR1cmwudHMjTDIzXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1RvQmFzZTY0dXJsU3RyaW5nKGlucHV0KSB7XG4gICAgLy8gc3RyaW5nIHRvIGJhc2U2NCAtLSB3ZSBkbyBub3QgcmVseSBvbiB0aGUgYnJvd3NlcidzIGJ0b2Egc2luY2UgaXQncyBub3QgcHJlc2VudCBpbiBSZWFjdCBOYXRpdmUgZW52aXJvbm1lbnRzXG4gICAgY29uc3QgYmFzZTY0U3RyaW5nID0gYnRvYShpbnB1dCk7XG4gICAgcmV0dXJuIGJhc2U2NFN0cmluZ1RvQmFzZTY0VXJsRW5jb2RlZFN0cmluZyhiYXNlNjRTdHJpbmcpO1xufVxuZnVuY3Rpb24gYmFzZTY0U3RyaW5nVG9CYXNlNjRVcmxFbmNvZGVkU3RyaW5nKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL1xcKy9nLCBcIi1cIikucmVwbGFjZSgvXFwvL2csIFwiX1wiKS5yZXBsYWNlKC89L2csIFwiXCIpO1xufVxuZnVuY3Rpb24gdWludDhBcnJheVRvSGV4U3RyaW5nKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0LnJlZHVjZSgocmVzdWx0LCB4KSA9PiByZXN1bHQgKyB4LnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIiksIFwiXCIpO1xufVxuLy8gUG9seWZpbGwgYnRvYSB3aXRoIGEgcHVyZSBKUyBpbXBsZW1lbnRhdGlvbi4gVGhpcyBpcyBhZGFwdGVkIGZyb20gdGhlIGZvbGxvd2luZzpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qc2RvbS9hYmFiL2Jsb2IvODA4NzRhZTFmZTFjZGUyZTU4N2JiNmU1MWI2ZDdjOWI0MmNhMWQzNC9saWIvYnRvYS5qc1xuZnVuY3Rpb24gYnRvYShzKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIjEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5IDAgcHJlc2VudC5cIik7XG4gICAgfVxuICAgIGxldCBpO1xuICAgIC8vIFN0cmluZyBjb252ZXJzaW9uIGFzIHJlcXVpcmVkIGJ5IFdlYiBJREwuXG4gICAgcyA9IGAke3N9YDtcbiAgICAvLyBcIlRoZSBidG9hKCkgbWV0aG9kIG11c3QgdGhyb3cgYW4gXCJJbnZhbGlkQ2hhcmFjdGVyRXJyb3JcIiBET01FeGNlcHRpb24gaWZcbiAgICAvLyBkYXRhIGNvbnRhaW5zIGFueSBjaGFyYWN0ZXIgd2hvc2UgY29kZSBwb2ludCBpcyBncmVhdGVyIHRoYW4gVSswMEZGLlwiXG4gICAgZm9yIChpID0gMDsgaSA8IHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHMuY2hhckNvZGVBdChpKSA+IDI1NSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkQ2hhcmFjdGVyRXJyb3I6IGZvdW5kIGNvZGUgcG9pbnQgZ3JlYXRlciB0aGFuIDI1NToke3MuY2hhckNvZGVBdChpKX0gYXQgcG9zaXRpb24gJHtpfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBvdXQgPSBcIlwiO1xuICAgIGZvciAoaSA9IDA7IGkgPCBzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgIGNvbnN0IGdyb3Vwc09mU2l4ID0gW1xuICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICBdO1xuICAgICAgICBncm91cHNPZlNpeFswXSA9IHMuY2hhckNvZGVBdChpKSA+PiAyO1xuICAgICAgICBncm91cHNPZlNpeFsxXSA9IChzLmNoYXJDb2RlQXQoaSkgJiAweDAzKSA8PCA0O1xuICAgICAgICBpZiAocy5sZW5ndGggPiBpICsgMSkge1xuICAgICAgICAgICAgZ3JvdXBzT2ZTaXhbMV0gfD0gcy5jaGFyQ29kZUF0KGkgKyAxKSA+PiA0O1xuICAgICAgICAgICAgZ3JvdXBzT2ZTaXhbMl0gPSAocy5jaGFyQ29kZUF0KGkgKyAxKSAmIDB4MGYpIDw8IDI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMubGVuZ3RoID4gaSArIDIpIHtcbiAgICAgICAgICAgIGdyb3Vwc09mU2l4WzJdIHw9IHMuY2hhckNvZGVBdChpICsgMikgPj4gNjtcbiAgICAgICAgICAgIGdyb3Vwc09mU2l4WzNdID0gcy5jaGFyQ29kZUF0KGkgKyAyKSAmIDB4M2Y7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBncm91cHNPZlNpeC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBncm91cHNPZlNpeFtqXSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIG91dCArPSBcIj1cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dCArPSBidG9hTG9va3VwKGdyb3Vwc09mU2l4W2pdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufVxuZnVuY3Rpb24gYnRvYUxvb2t1cChpbmRleCkge1xuICAgIC8qKlxuICAgICAqIExvb2t1cCB0YWJsZSBmb3IgYnRvYSgpLCB3aGljaCBjb252ZXJ0cyBhIHNpeC1iaXQgbnVtYmVyIGludG8gdGhlXG4gICAgICogY29ycmVzcG9uZGluZyBBU0NJSSBjaGFyYWN0ZXIuXG4gICAgICovXG4gICAgY29uc3Qga2V5c3RyID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCI7XG4gICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCA2NCkge1xuICAgICAgICByZXR1cm4ga2V5c3RyW2luZGV4XTtcbiAgICB9XG4gICAgLy8gVGhyb3cgSU5WQUxJRF9DSEFSQUNURVJfRVJSIGV4Y2VwdGlvbiBoZXJlIC0tIHdvbid0IGJlIGhpdCBpbiB0aGUgdGVzdHMuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IHsgYmFzZTY0U3RyaW5nVG9CYXNlNjRVcmxFbmNvZGVkU3RyaW5nLCBzdHJpbmdUb0Jhc2U2NHVybFN0cmluZywgdWludDhBcnJheVRvSGV4U3RyaW5nIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/encoding/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/http/dist/__generated__/services/coordinator/public/v1/public_api.client.mjs":
/*!************************************************************************************************************!*\
  !*** ./node_modules/@turnkey/http/dist/__generated__/services/coordinator/public/v1/public_api.client.mjs ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TurnkeyClient: () => (/* binding */ TurnkeyClient)\n/* harmony export */ });\n/* harmony import */ var _base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../base.mjs */ \"(ssr)/./node_modules/@turnkey/http/dist/base.mjs\");\n/* harmony import */ var _version_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../../version.mjs */ \"(ssr)/./node_modules/@turnkey/http/dist/version.mjs\");\n/* harmony import */ var _universal_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../../universal.mjs */ \"(ssr)/./node_modules/@turnkey/http/dist/universal.mjs\");\n\n\n\n\n/* @generated by `@turnkey/fetchers`. DO NOT EDIT BY HAND */\nclass TurnkeyClient {\n    constructor(config, stamper) {\n        /**\n         * Get details about an Activity\n         *\n         * Sign the provided `TGetActivityBody` with the client's `stamp` function, and submit the request (POST /public/v1/query/get_activity).\n         *\n         * See also {@link stampGetActivity}.\n         */\n        this.getActivity = async (input) => {\n            return this.request(\"/public/v1/query/get_activity\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TGetActivityBody` by using the client's `stamp` function.\n         *\n         * See also {@link GetActivity}.\n         */\n        this.stampGetActivity = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/query/get_activity\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Get details about an API key\n         *\n         * Sign the provided `TGetApiKeyBody` with the client's `stamp` function, and submit the request (POST /public/v1/query/get_api_key).\n         *\n         * See also {@link stampGetApiKey}.\n         */\n        this.getApiKey = async (input) => {\n            return this.request(\"/public/v1/query/get_api_key\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TGetApiKeyBody` by using the client's `stamp` function.\n         *\n         * See also {@link GetApiKey}.\n         */\n        this.stampGetApiKey = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/query/get_api_key\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Get details about API keys for a user\n         *\n         * Sign the provided `TGetApiKeysBody` with the client's `stamp` function, and submit the request (POST /public/v1/query/get_api_keys).\n         *\n         * See also {@link stampGetApiKeys}.\n         */\n        this.getApiKeys = async (input) => {\n            return this.request(\"/public/v1/query/get_api_keys\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TGetApiKeysBody` by using the client's `stamp` function.\n         *\n         * See also {@link GetApiKeys}.\n         */\n        this.stampGetApiKeys = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/query/get_api_keys\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Get details about an authenticator\n         *\n         * Sign the provided `TGetAuthenticatorBody` with the client's `stamp` function, and submit the request (POST /public/v1/query/get_authenticator).\n         *\n         * See also {@link stampGetAuthenticator}.\n         */\n        this.getAuthenticator = async (input) => {\n            return this.request(\"/public/v1/query/get_authenticator\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TGetAuthenticatorBody` by using the client's `stamp` function.\n         *\n         * See also {@link GetAuthenticator}.\n         */\n        this.stampGetAuthenticator = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/query/get_authenticator\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Get details about authenticators for a user\n         *\n         * Sign the provided `TGetAuthenticatorsBody` with the client's `stamp` function, and submit the request (POST /public/v1/query/get_authenticators).\n         *\n         * See also {@link stampGetAuthenticators}.\n         */\n        this.getAuthenticators = async (input) => {\n            return this.request(\"/public/v1/query/get_authenticators\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TGetAuthenticatorsBody` by using the client's `stamp` function.\n         *\n         * See also {@link GetAuthenticators}.\n         */\n        this.stampGetAuthenticators = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/query/get_authenticators\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Get details about an Organization\n         *\n         * Sign the provided `TGetOrganizationBody` with the client's `stamp` function, and submit the request (POST /public/v1/query/get_organization).\n         *\n         * See also {@link stampGetOrganization}.\n         */\n        this.getOrganization = async (input) => {\n            return this.request(\"/public/v1/query/get_organization\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TGetOrganizationBody` by using the client's `stamp` function.\n         *\n         * See also {@link GetOrganization}.\n         */\n        this.stampGetOrganization = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/query/get_organization\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Get details about a Policy\n         *\n         * Sign the provided `TGetPolicyBody` with the client's `stamp` function, and submit the request (POST /public/v1/query/get_policy).\n         *\n         * See also {@link stampGetPolicy}.\n         */\n        this.getPolicy = async (input) => {\n            return this.request(\"/public/v1/query/get_policy\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TGetPolicyBody` by using the client's `stamp` function.\n         *\n         * See also {@link GetPolicy}.\n         */\n        this.stampGetPolicy = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/query/get_policy\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Get details about a Private Key\n         *\n         * Sign the provided `TGetPrivateKeyBody` with the client's `stamp` function, and submit the request (POST /public/v1/query/get_private_key).\n         *\n         * See also {@link stampGetPrivateKey}.\n         */\n        this.getPrivateKey = async (input) => {\n            return this.request(\"/public/v1/query/get_private_key\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TGetPrivateKeyBody` by using the client's `stamp` function.\n         *\n         * See also {@link GetPrivateKey}.\n         */\n        this.stampGetPrivateKey = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/query/get_private_key\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Get details about a User\n         *\n         * Sign the provided `TGetUserBody` with the client's `stamp` function, and submit the request (POST /public/v1/query/get_user).\n         *\n         * See also {@link stampGetUser}.\n         */\n        this.getUser = async (input) => {\n            return this.request(\"/public/v1/query/get_user\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TGetUserBody` by using the client's `stamp` function.\n         *\n         * See also {@link GetUser}.\n         */\n        this.stampGetUser = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/query/get_user\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Get details about a Wallet\n         *\n         * Sign the provided `TGetWalletBody` with the client's `stamp` function, and submit the request (POST /public/v1/query/get_wallet).\n         *\n         * See also {@link stampGetWallet}.\n         */\n        this.getWallet = async (input) => {\n            return this.request(\"/public/v1/query/get_wallet\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TGetWalletBody` by using the client's `stamp` function.\n         *\n         * See also {@link GetWallet}.\n         */\n        this.stampGetWallet = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/query/get_wallet\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * List all Activities within an Organization\n         *\n         * Sign the provided `TGetActivitiesBody` with the client's `stamp` function, and submit the request (POST /public/v1/query/list_activities).\n         *\n         * See also {@link stampGetActivities}.\n         */\n        this.getActivities = async (input) => {\n            return this.request(\"/public/v1/query/list_activities\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TGetActivitiesBody` by using the client's `stamp` function.\n         *\n         * See also {@link GetActivities}.\n         */\n        this.stampGetActivities = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/query/list_activities\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * List all Policies within an Organization\n         *\n         * Sign the provided `TGetPoliciesBody` with the client's `stamp` function, and submit the request (POST /public/v1/query/list_policies).\n         *\n         * See also {@link stampGetPolicies}.\n         */\n        this.getPolicies = async (input) => {\n            return this.request(\"/public/v1/query/list_policies\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TGetPoliciesBody` by using the client's `stamp` function.\n         *\n         * See also {@link GetPolicies}.\n         */\n        this.stampGetPolicies = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/query/list_policies\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * List all Private Key Tags within an Organization\n         *\n         * Sign the provided `TListPrivateKeyTagsBody` with the client's `stamp` function, and submit the request (POST /public/v1/query/list_private_key_tags).\n         *\n         * See also {@link stampListPrivateKeyTags}.\n         */\n        this.listPrivateKeyTags = async (input) => {\n            return this.request(\"/public/v1/query/list_private_key_tags\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TListPrivateKeyTagsBody` by using the client's `stamp` function.\n         *\n         * See also {@link ListPrivateKeyTags}.\n         */\n        this.stampListPrivateKeyTags = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/query/list_private_key_tags\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * List all Private Keys within an Organization\n         *\n         * Sign the provided `TGetPrivateKeysBody` with the client's `stamp` function, and submit the request (POST /public/v1/query/list_private_keys).\n         *\n         * See also {@link stampGetPrivateKeys}.\n         */\n        this.getPrivateKeys = async (input) => {\n            return this.request(\"/public/v1/query/list_private_keys\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TGetPrivateKeysBody` by using the client's `stamp` function.\n         *\n         * See also {@link GetPrivateKeys}.\n         */\n        this.stampGetPrivateKeys = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/query/list_private_keys\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Get all suborg IDs associated given a parent org ID and an optional filter.\n         *\n         * Sign the provided `TGetSubOrgIdsBody` with the client's `stamp` function, and submit the request (POST /public/v1/query/list_suborgs).\n         *\n         * See also {@link stampGetSubOrgIds}.\n         */\n        this.getSubOrgIds = async (input) => {\n            return this.request(\"/public/v1/query/list_suborgs\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TGetSubOrgIdsBody` by using the client's `stamp` function.\n         *\n         * See also {@link GetSubOrgIds}.\n         */\n        this.stampGetSubOrgIds = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/query/list_suborgs\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * List all User Tags within an Organization\n         *\n         * Sign the provided `TListUserTagsBody` with the client's `stamp` function, and submit the request (POST /public/v1/query/list_user_tags).\n         *\n         * See also {@link stampListUserTags}.\n         */\n        this.listUserTags = async (input) => {\n            return this.request(\"/public/v1/query/list_user_tags\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TListUserTagsBody` by using the client's `stamp` function.\n         *\n         * See also {@link ListUserTags}.\n         */\n        this.stampListUserTags = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/query/list_user_tags\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * List all Users within an Organization\n         *\n         * Sign the provided `TGetUsersBody` with the client's `stamp` function, and submit the request (POST /public/v1/query/list_users).\n         *\n         * See also {@link stampGetUsers}.\n         */\n        this.getUsers = async (input) => {\n            return this.request(\"/public/v1/query/list_users\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TGetUsersBody` by using the client's `stamp` function.\n         *\n         * See also {@link GetUsers}.\n         */\n        this.stampGetUsers = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/query/list_users\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * List all Accounts wirhin a Wallet\n         *\n         * Sign the provided `TGetWalletAccountsBody` with the client's `stamp` function, and submit the request (POST /public/v1/query/list_wallet_accounts).\n         *\n         * See also {@link stampGetWalletAccounts}.\n         */\n        this.getWalletAccounts = async (input) => {\n            return this.request(\"/public/v1/query/list_wallet_accounts\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TGetWalletAccountsBody` by using the client's `stamp` function.\n         *\n         * See also {@link GetWalletAccounts}.\n         */\n        this.stampGetWalletAccounts = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/query/list_wallet_accounts\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * List all Wallets within an Organization\n         *\n         * Sign the provided `TGetWalletsBody` with the client's `stamp` function, and submit the request (POST /public/v1/query/list_wallets).\n         *\n         * See also {@link stampGetWallets}.\n         */\n        this.getWallets = async (input) => {\n            return this.request(\"/public/v1/query/list_wallets\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TGetWalletsBody` by using the client's `stamp` function.\n         *\n         * See also {@link GetWallets}.\n         */\n        this.stampGetWallets = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/query/list_wallets\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Get basic information about your current API or WebAuthN user and their organization. Affords Sub-Organization look ups via Parent Organization for WebAuthN or API key users.\n         *\n         * Sign the provided `TGetWhoamiBody` with the client's `stamp` function, and submit the request (POST /public/v1/query/whoami).\n         *\n         * See also {@link stampGetWhoami}.\n         */\n        this.getWhoami = async (input) => {\n            return this.request(\"/public/v1/query/whoami\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TGetWhoamiBody` by using the client's `stamp` function.\n         *\n         * See also {@link GetWhoami}.\n         */\n        this.stampGetWhoami = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/query/whoami\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Approve an Activity\n         *\n         * Sign the provided `TApproveActivityBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/approve_activity).\n         *\n         * See also {@link stampApproveActivity}.\n         */\n        this.approveActivity = async (input) => {\n            return this.request(\"/public/v1/submit/approve_activity\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TApproveActivityBody` by using the client's `stamp` function.\n         *\n         * See also {@link ApproveActivity}.\n         */\n        this.stampApproveActivity = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/approve_activity\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Add api keys to an existing User\n         *\n         * Sign the provided `TCreateApiKeysBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/create_api_keys).\n         *\n         * See also {@link stampCreateApiKeys}.\n         */\n        this.createApiKeys = async (input) => {\n            return this.request(\"/public/v1/submit/create_api_keys\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TCreateApiKeysBody` by using the client's `stamp` function.\n         *\n         * See also {@link CreateApiKeys}.\n         */\n        this.stampCreateApiKeys = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/create_api_keys\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Create API-only Users in an existing Organization\n         *\n         * Sign the provided `TCreateApiOnlyUsersBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/create_api_only_users).\n         *\n         * See also {@link stampCreateApiOnlyUsers}.\n         */\n        this.createApiOnlyUsers = async (input) => {\n            return this.request(\"/public/v1/submit/create_api_only_users\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TCreateApiOnlyUsersBody` by using the client's `stamp` function.\n         *\n         * See also {@link CreateApiOnlyUsers}.\n         */\n        this.stampCreateApiOnlyUsers = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/create_api_only_users\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Create Authenticators to authenticate requests to Turnkey\n         *\n         * Sign the provided `TCreateAuthenticatorsBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/create_authenticators).\n         *\n         * See also {@link stampCreateAuthenticators}.\n         */\n        this.createAuthenticators = async (input) => {\n            return this.request(\"/public/v1/submit/create_authenticators\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TCreateAuthenticatorsBody` by using the client's `stamp` function.\n         *\n         * See also {@link CreateAuthenticators}.\n         */\n        this.stampCreateAuthenticators = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/create_authenticators\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Create Invitations to join an existing Organization\n         *\n         * Sign the provided `TCreateInvitationsBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/create_invitations).\n         *\n         * See also {@link stampCreateInvitations}.\n         */\n        this.createInvitations = async (input) => {\n            return this.request(\"/public/v1/submit/create_invitations\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TCreateInvitationsBody` by using the client's `stamp` function.\n         *\n         * See also {@link CreateInvitations}.\n         */\n        this.stampCreateInvitations = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/create_invitations\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Create new Policies\n         *\n         * Sign the provided `TCreatePoliciesBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/create_policies).\n         *\n         * See also {@link stampCreatePolicies}.\n         */\n        this.createPolicies = async (input) => {\n            return this.request(\"/public/v1/submit/create_policies\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TCreatePoliciesBody` by using the client's `stamp` function.\n         *\n         * See also {@link CreatePolicies}.\n         */\n        this.stampCreatePolicies = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/create_policies\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Create a new Policy\n         *\n         * Sign the provided `TCreatePolicyBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/create_policy).\n         *\n         * See also {@link stampCreatePolicy}.\n         */\n        this.createPolicy = async (input) => {\n            return this.request(\"/public/v1/submit/create_policy\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TCreatePolicyBody` by using the client's `stamp` function.\n         *\n         * See also {@link CreatePolicy}.\n         */\n        this.stampCreatePolicy = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/create_policy\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Create a private key tag and add it to private keys.\n         *\n         * Sign the provided `TCreatePrivateKeyTagBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/create_private_key_tag).\n         *\n         * See also {@link stampCreatePrivateKeyTag}.\n         */\n        this.createPrivateKeyTag = async (input) => {\n            return this.request(\"/public/v1/submit/create_private_key_tag\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TCreatePrivateKeyTagBody` by using the client's `stamp` function.\n         *\n         * See also {@link CreatePrivateKeyTag}.\n         */\n        this.stampCreatePrivateKeyTag = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/create_private_key_tag\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Create new Private Keys\n         *\n         * Sign the provided `TCreatePrivateKeysBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/create_private_keys).\n         *\n         * See also {@link stampCreatePrivateKeys}.\n         */\n        this.createPrivateKeys = async (input) => {\n            return this.request(\"/public/v1/submit/create_private_keys\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TCreatePrivateKeysBody` by using the client's `stamp` function.\n         *\n         * See also {@link CreatePrivateKeys}.\n         */\n        this.stampCreatePrivateKeys = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/create_private_keys\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Create a new Sub-Organization\n         *\n         * Sign the provided `TCreateSubOrganizationBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/create_sub_organization).\n         *\n         * See also {@link stampCreateSubOrganization}.\n         */\n        this.createSubOrganization = async (input) => {\n            return this.request(\"/public/v1/submit/create_sub_organization\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TCreateSubOrganizationBody` by using the client's `stamp` function.\n         *\n         * See also {@link CreateSubOrganization}.\n         */\n        this.stampCreateSubOrganization = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/create_sub_organization\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Create a user tag and add it to users.\n         *\n         * Sign the provided `TCreateUserTagBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/create_user_tag).\n         *\n         * See also {@link stampCreateUserTag}.\n         */\n        this.createUserTag = async (input) => {\n            return this.request(\"/public/v1/submit/create_user_tag\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TCreateUserTagBody` by using the client's `stamp` function.\n         *\n         * See also {@link CreateUserTag}.\n         */\n        this.stampCreateUserTag = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/create_user_tag\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Create Users in an existing Organization\n         *\n         * Sign the provided `TCreateUsersBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/create_users).\n         *\n         * See also {@link stampCreateUsers}.\n         */\n        this.createUsers = async (input) => {\n            return this.request(\"/public/v1/submit/create_users\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TCreateUsersBody` by using the client's `stamp` function.\n         *\n         * See also {@link CreateUsers}.\n         */\n        this.stampCreateUsers = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/create_users\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Create a Wallet and derive addresses\n         *\n         * Sign the provided `TCreateWalletBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/create_wallet).\n         *\n         * See also {@link stampCreateWallet}.\n         */\n        this.createWallet = async (input) => {\n            return this.request(\"/public/v1/submit/create_wallet\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TCreateWalletBody` by using the client's `stamp` function.\n         *\n         * See also {@link CreateWallet}.\n         */\n        this.stampCreateWallet = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/create_wallet\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Derive additional addresses using an existing wallet\n         *\n         * Sign the provided `TCreateWalletAccountsBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/create_wallet_accounts).\n         *\n         * See also {@link stampCreateWalletAccounts}.\n         */\n        this.createWalletAccounts = async (input) => {\n            return this.request(\"/public/v1/submit/create_wallet_accounts\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TCreateWalletAccountsBody` by using the client's `stamp` function.\n         *\n         * See also {@link CreateWalletAccounts}.\n         */\n        this.stampCreateWalletAccounts = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/create_wallet_accounts\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Remove api keys from a User\n         *\n         * Sign the provided `TDeleteApiKeysBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/delete_api_keys).\n         *\n         * See also {@link stampDeleteApiKeys}.\n         */\n        this.deleteApiKeys = async (input) => {\n            return this.request(\"/public/v1/submit/delete_api_keys\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TDeleteApiKeysBody` by using the client's `stamp` function.\n         *\n         * See also {@link DeleteApiKeys}.\n         */\n        this.stampDeleteApiKeys = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/delete_api_keys\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Remove authenticators from a User\n         *\n         * Sign the provided `TDeleteAuthenticatorsBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/delete_authenticators).\n         *\n         * See also {@link stampDeleteAuthenticators}.\n         */\n        this.deleteAuthenticators = async (input) => {\n            return this.request(\"/public/v1/submit/delete_authenticators\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TDeleteAuthenticatorsBody` by using the client's `stamp` function.\n         *\n         * See also {@link DeleteAuthenticators}.\n         */\n        this.stampDeleteAuthenticators = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/delete_authenticators\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Delete an existing Invitation\n         *\n         * Sign the provided `TDeleteInvitationBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/delete_invitation).\n         *\n         * See also {@link stampDeleteInvitation}.\n         */\n        this.deleteInvitation = async (input) => {\n            return this.request(\"/public/v1/submit/delete_invitation\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TDeleteInvitationBody` by using the client's `stamp` function.\n         *\n         * See also {@link DeleteInvitation}.\n         */\n        this.stampDeleteInvitation = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/delete_invitation\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Delete an existing Policy\n         *\n         * Sign the provided `TDeletePolicyBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/delete_policy).\n         *\n         * See also {@link stampDeletePolicy}.\n         */\n        this.deletePolicy = async (input) => {\n            return this.request(\"/public/v1/submit/delete_policy\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TDeletePolicyBody` by using the client's `stamp` function.\n         *\n         * See also {@link DeletePolicy}.\n         */\n        this.stampDeletePolicy = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/delete_policy\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Delete Private Key Tags within an Organization\n         *\n         * Sign the provided `TDeletePrivateKeyTagsBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/delete_private_key_tags).\n         *\n         * See also {@link stampDeletePrivateKeyTags}.\n         */\n        this.deletePrivateKeyTags = async (input) => {\n            return this.request(\"/public/v1/submit/delete_private_key_tags\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TDeletePrivateKeyTagsBody` by using the client's `stamp` function.\n         *\n         * See also {@link DeletePrivateKeyTags}.\n         */\n        this.stampDeletePrivateKeyTags = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/delete_private_key_tags\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Delete User Tags within an Organization\n         *\n         * Sign the provided `TDeleteUserTagsBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/delete_user_tags).\n         *\n         * See also {@link stampDeleteUserTags}.\n         */\n        this.deleteUserTags = async (input) => {\n            return this.request(\"/public/v1/submit/delete_user_tags\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TDeleteUserTagsBody` by using the client's `stamp` function.\n         *\n         * See also {@link DeleteUserTags}.\n         */\n        this.stampDeleteUserTags = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/delete_user_tags\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Delete Users within an Organization\n         *\n         * Sign the provided `TDeleteUsersBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/delete_users).\n         *\n         * See also {@link stampDeleteUsers}.\n         */\n        this.deleteUsers = async (input) => {\n            return this.request(\"/public/v1/submit/delete_users\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TDeleteUsersBody` by using the client's `stamp` function.\n         *\n         * See also {@link DeleteUsers}.\n         */\n        this.stampDeleteUsers = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/delete_users\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Authenticate a user via Email\n         *\n         * Sign the provided `TEmailAuthBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/email_auth).\n         *\n         * See also {@link stampEmailAuth}.\n         */\n        this.emailAuth = async (input) => {\n            return this.request(\"/public/v1/submit/email_auth\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TEmailAuthBody` by using the client's `stamp` function.\n         *\n         * See also {@link EmailAuth}.\n         */\n        this.stampEmailAuth = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/email_auth\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Exports a Private Key\n         *\n         * Sign the provided `TExportPrivateKeyBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/export_private_key).\n         *\n         * See also {@link stampExportPrivateKey}.\n         */\n        this.exportPrivateKey = async (input) => {\n            return this.request(\"/public/v1/submit/export_private_key\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TExportPrivateKeyBody` by using the client's `stamp` function.\n         *\n         * See also {@link ExportPrivateKey}.\n         */\n        this.stampExportPrivateKey = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/export_private_key\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Exports a Wallet\n         *\n         * Sign the provided `TExportWalletBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/export_wallet).\n         *\n         * See also {@link stampExportWallet}.\n         */\n        this.exportWallet = async (input) => {\n            return this.request(\"/public/v1/submit/export_wallet\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TExportWalletBody` by using the client's `stamp` function.\n         *\n         * See also {@link ExportWallet}.\n         */\n        this.stampExportWallet = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/export_wallet\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Exports a Wallet Account\n         *\n         * Sign the provided `TExportWalletAccountBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/export_wallet_account).\n         *\n         * See also {@link stampExportWalletAccount}.\n         */\n        this.exportWalletAccount = async (input) => {\n            return this.request(\"/public/v1/submit/export_wallet_account\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TExportWalletAccountBody` by using the client's `stamp` function.\n         *\n         * See also {@link ExportWalletAccount}.\n         */\n        this.stampExportWalletAccount = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/export_wallet_account\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Imports a private key\n         *\n         * Sign the provided `TImportPrivateKeyBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/import_private_key).\n         *\n         * See also {@link stampImportPrivateKey}.\n         */\n        this.importPrivateKey = async (input) => {\n            return this.request(\"/public/v1/submit/import_private_key\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TImportPrivateKeyBody` by using the client's `stamp` function.\n         *\n         * See also {@link ImportPrivateKey}.\n         */\n        this.stampImportPrivateKey = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/import_private_key\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Imports a wallet\n         *\n         * Sign the provided `TImportWalletBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/import_wallet).\n         *\n         * See also {@link stampImportWallet}.\n         */\n        this.importWallet = async (input) => {\n            return this.request(\"/public/v1/submit/import_wallet\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TImportWalletBody` by using the client's `stamp` function.\n         *\n         * See also {@link ImportWallet}.\n         */\n        this.stampImportWallet = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/import_wallet\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Initializes a new private key import\n         *\n         * Sign the provided `TInitImportPrivateKeyBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/init_import_private_key).\n         *\n         * See also {@link stampInitImportPrivateKey}.\n         */\n        this.initImportPrivateKey = async (input) => {\n            return this.request(\"/public/v1/submit/init_import_private_key\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TInitImportPrivateKeyBody` by using the client's `stamp` function.\n         *\n         * See also {@link InitImportPrivateKey}.\n         */\n        this.stampInitImportPrivateKey = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/init_import_private_key\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Initializes a new wallet import\n         *\n         * Sign the provided `TInitImportWalletBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/init_import_wallet).\n         *\n         * See also {@link stampInitImportWallet}.\n         */\n        this.initImportWallet = async (input) => {\n            return this.request(\"/public/v1/submit/init_import_wallet\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TInitImportWalletBody` by using the client's `stamp` function.\n         *\n         * See also {@link InitImportWallet}.\n         */\n        this.stampInitImportWallet = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/init_import_wallet\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Initializes a new email recovery\n         *\n         * Sign the provided `TInitUserEmailRecoveryBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/init_user_email_recovery).\n         *\n         * See also {@link stampInitUserEmailRecovery}.\n         */\n        this.initUserEmailRecovery = async (input) => {\n            return this.request(\"/public/v1/submit/init_user_email_recovery\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TInitUserEmailRecoveryBody` by using the client's `stamp` function.\n         *\n         * See also {@link InitUserEmailRecovery}.\n         */\n        this.stampInitUserEmailRecovery = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/init_user_email_recovery\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Completes the process of recovering a user by adding an authenticator\n         *\n         * Sign the provided `TRecoverUserBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/recover_user).\n         *\n         * See also {@link stampRecoverUser}.\n         */\n        this.recoverUser = async (input) => {\n            return this.request(\"/public/v1/submit/recover_user\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TRecoverUserBody` by using the client's `stamp` function.\n         *\n         * See also {@link RecoverUser}.\n         */\n        this.stampRecoverUser = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/recover_user\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Reject an Activity\n         *\n         * Sign the provided `TRejectActivityBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/reject_activity).\n         *\n         * See also {@link stampRejectActivity}.\n         */\n        this.rejectActivity = async (input) => {\n            return this.request(\"/public/v1/submit/reject_activity\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TRejectActivityBody` by using the client's `stamp` function.\n         *\n         * See also {@link RejectActivity}.\n         */\n        this.stampRejectActivity = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/reject_activity\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Removes an organization feature\n         *\n         * Sign the provided `TRemoveOrganizationFeatureBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/remove_organization_feature).\n         *\n         * See also {@link stampRemoveOrganizationFeature}.\n         */\n        this.removeOrganizationFeature = async (input) => {\n            return this.request(\"/public/v1/submit/remove_organization_feature\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TRemoveOrganizationFeatureBody` by using the client's `stamp` function.\n         *\n         * See also {@link RemoveOrganizationFeature}.\n         */\n        this.stampRemoveOrganizationFeature = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/remove_organization_feature\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Sets an organization feature\n         *\n         * Sign the provided `TSetOrganizationFeatureBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/set_organization_feature).\n         *\n         * See also {@link stampSetOrganizationFeature}.\n         */\n        this.setOrganizationFeature = async (input) => {\n            return this.request(\"/public/v1/submit/set_organization_feature\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TSetOrganizationFeatureBody` by using the client's `stamp` function.\n         *\n         * See also {@link SetOrganizationFeature}.\n         */\n        this.stampSetOrganizationFeature = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/set_organization_feature\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Sign a raw payload\n         *\n         * Sign the provided `TSignRawPayloadBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/sign_raw_payload).\n         *\n         * See also {@link stampSignRawPayload}.\n         */\n        this.signRawPayload = async (input) => {\n            return this.request(\"/public/v1/submit/sign_raw_payload\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TSignRawPayloadBody` by using the client's `stamp` function.\n         *\n         * See also {@link SignRawPayload}.\n         */\n        this.stampSignRawPayload = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/sign_raw_payload\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Sign multiple raw payloads with the same signing parameters\n         *\n         * Sign the provided `TSignRawPayloadsBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/sign_raw_payloads).\n         *\n         * See also {@link stampSignRawPayloads}.\n         */\n        this.signRawPayloads = async (input) => {\n            return this.request(\"/public/v1/submit/sign_raw_payloads\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TSignRawPayloadsBody` by using the client's `stamp` function.\n         *\n         * See also {@link SignRawPayloads}.\n         */\n        this.stampSignRawPayloads = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/sign_raw_payloads\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Sign a transaction\n         *\n         * Sign the provided `TSignTransactionBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/sign_transaction).\n         *\n         * See also {@link stampSignTransaction}.\n         */\n        this.signTransaction = async (input) => {\n            return this.request(\"/public/v1/submit/sign_transaction\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TSignTransactionBody` by using the client's `stamp` function.\n         *\n         * See also {@link SignTransaction}.\n         */\n        this.stampSignTransaction = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/sign_transaction\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Update an existing Policy\n         *\n         * Sign the provided `TUpdatePolicyBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/update_policy).\n         *\n         * See also {@link stampUpdatePolicy}.\n         */\n        this.updatePolicy = async (input) => {\n            return this.request(\"/public/v1/submit/update_policy\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TUpdatePolicyBody` by using the client's `stamp` function.\n         *\n         * See also {@link UpdatePolicy}.\n         */\n        this.stampUpdatePolicy = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/update_policy\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Update human-readable name or associated private keys. Note that this activity is atomic: all of the updates will succeed at once, or all of them will fail.\n         *\n         * Sign the provided `TUpdatePrivateKeyTagBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/update_private_key_tag).\n         *\n         * See also {@link stampUpdatePrivateKeyTag}.\n         */\n        this.updatePrivateKeyTag = async (input) => {\n            return this.request(\"/public/v1/submit/update_private_key_tag\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TUpdatePrivateKeyTagBody` by using the client's `stamp` function.\n         *\n         * See also {@link UpdatePrivateKeyTag}.\n         */\n        this.stampUpdatePrivateKeyTag = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/update_private_key_tag\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Set the threshold and members of the root quorum. This must be approved by the current root quorum.\n         *\n         * Sign the provided `TUpdateRootQuorumBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/update_root_quorum).\n         *\n         * See also {@link stampUpdateRootQuorum}.\n         */\n        this.updateRootQuorum = async (input) => {\n            return this.request(\"/public/v1/submit/update_root_quorum\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TUpdateRootQuorumBody` by using the client's `stamp` function.\n         *\n         * See also {@link UpdateRootQuorum}.\n         */\n        this.stampUpdateRootQuorum = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/update_root_quorum\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Update a User in an existing Organization\n         *\n         * Sign the provided `TUpdateUserBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/update_user).\n         *\n         * See also {@link stampUpdateUser}.\n         */\n        this.updateUser = async (input) => {\n            return this.request(\"/public/v1/submit/update_user\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TUpdateUserBody` by using the client's `stamp` function.\n         *\n         * See also {@link UpdateUser}.\n         */\n        this.stampUpdateUser = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/update_user\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Update human-readable name or associated users. Note that this activity is atomic: all of the updates will succeed at once, or all of them will fail.\n         *\n         * Sign the provided `TUpdateUserTagBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/update_user_tag).\n         *\n         * See also {@link stampUpdateUserTag}.\n         */\n        this.updateUserTag = async (input) => {\n            return this.request(\"/public/v1/submit/update_user_tag\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TUpdateUserTagBody` by using the client's `stamp` function.\n         *\n         * See also {@link UpdateUserTag}.\n         */\n        this.stampUpdateUserTag = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/update_user_tag\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        if (!config.baseUrl) {\n            throw new Error(`Missing base URL. Please verify env vars.`);\n        }\n        this.config = config;\n        this.stamper = stamper;\n    }\n    async request(url, body) {\n        const fullUrl = this.config.baseUrl + url;\n        const stringifiedBody = JSON.stringify(body);\n        const stamp = await this.stamper.stamp(stringifiedBody);\n        const response = await (0,_universal_mjs__WEBPACK_IMPORTED_MODULE_2__.fetch)(fullUrl, {\n            method: \"POST\",\n            headers: {\n                [stamp.stampHeaderName]: stamp.stampHeaderValue,\n                \"X-Client-Version\": _version_mjs__WEBPACK_IMPORTED_MODULE_1__.VERSION,\n            },\n            body: stringifiedBody,\n            redirect: \"follow\",\n        });\n        if (!response.ok) {\n            let res;\n            try {\n                res = await response.json();\n            }\n            catch (_) {\n                throw new Error(`${response.status} ${response.statusText}`);\n            }\n            throw new _base_mjs__WEBPACK_IMPORTED_MODULE_0__.TurnkeyRequestError(res);\n        }\n        const data = await response.json();\n        return data;\n    }\n}\n\n\n//# sourceMappingURL=public_api.client.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvaHR0cC9kaXN0L19fZ2VuZXJhdGVkX18vc2VydmljZXMvY29vcmRpbmF0b3IvcHVibGljL3YxL3B1YmxpY19hcGkuY2xpZW50Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQThEO0FBQ1Q7QUFDQTs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsa0JBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHFCQUFxQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0JBQXNCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlCQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw0QkFBNEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDZCQUE2QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix3QkFBd0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMkJBQTJCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNCQUFzQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixxQkFBcUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHlCQUF5QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixvQkFBb0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbUJBQW1CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGNBQWM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIscUJBQXFCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix5QkFBeUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsb0JBQW9CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsOEJBQThCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHlCQUF5QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwwQkFBMEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIscUJBQXFCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHdCQUF3QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixtQkFBbUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsd0JBQXdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1CQUFtQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixvQkFBb0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZUFBZTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw2QkFBNkI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsd0JBQXdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNCQUFzQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIscUJBQXFCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwyQkFBMkI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0JBQXNCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHlCQUF5QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixvQkFBb0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsOEJBQThCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHlCQUF5QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixnQ0FBZ0M7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMkJBQTJCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDZCQUE2QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix3QkFBd0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMEJBQTBCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHFCQUFxQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix3QkFBd0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbUJBQW1CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLCtCQUErQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwwQkFBMEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNkJBQTZCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHdCQUF3QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQ0FBaUM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNEJBQTRCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHlCQUF5QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixvQkFBb0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix3QkFBd0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbUJBQW1CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGdDQUFnQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwyQkFBMkI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIseUJBQXlCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG9CQUFvQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixnQ0FBZ0M7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMkJBQTJCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDRCQUE0QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsd0JBQXdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1CQUFtQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixnQ0FBZ0M7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMkJBQTJCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDBCQUEwQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixxQkFBcUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixxQkFBcUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDRCQUE0QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsd0JBQXdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1CQUFtQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwrQkFBK0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMEJBQTBCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDRCQUE0QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsd0JBQXdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1CQUFtQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixnQ0FBZ0M7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMkJBQTJCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDRCQUE0QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaUNBQWlDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDRCQUE0QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsa0JBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDBCQUEwQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixxQkFBcUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIscUNBQXFDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGdDQUFnQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrQ0FBa0M7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNkJBQTZCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDBCQUEwQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixxQkFBcUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMkJBQTJCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNCQUFzQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwyQkFBMkI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0JBQXNCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHdCQUF3QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixtQkFBbUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsK0JBQStCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDBCQUEwQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw0QkFBNEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNCQUFzQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIseUJBQXlCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG9CQUFvQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IscURBQUs7QUFDcEM7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGlEQUFPO0FBQzNDLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxpQkFBaUIsRUFBRSxvQkFBb0I7QUFDMUU7QUFDQSxzQkFBc0IsMERBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXlCO0FBQ3pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbnVyc2VibG9jLy4vbm9kZV9tb2R1bGVzL0B0dXJua2V5L2h0dHAvZGlzdC9fX2dlbmVyYXRlZF9fL3NlcnZpY2VzL2Nvb3JkaW5hdG9yL3B1YmxpYy92MS9wdWJsaWNfYXBpLmNsaWVudC5tanM/YTUwYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUdXJua2V5UmVxdWVzdEVycm9yIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vYmFzZS5tanMnO1xuaW1wb3J0IHsgVkVSU0lPTiB9IGZyb20gJy4uLy4uLy4uLy4uLy4uL3ZlcnNpb24ubWpzJztcbmltcG9ydCB7IGZldGNoIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vdW5pdmVyc2FsLm1qcyc7XG5cbi8qIEBnZW5lcmF0ZWQgYnkgYEB0dXJua2V5L2ZldGNoZXJzYC4gRE8gTk9UIEVESVQgQlkgSEFORCAqL1xuY2xhc3MgVHVybmtleUNsaWVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnLCBzdGFtcGVyKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgZGV0YWlscyBhYm91dCBhbiBBY3Rpdml0eVxuICAgICAgICAgKlxuICAgICAgICAgKiBTaWduIHRoZSBwcm92aWRlZCBgVEdldEFjdGl2aXR5Qm9keWAgd2l0aCB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbiwgYW5kIHN1Ym1pdCB0aGUgcmVxdWVzdCAoUE9TVCAvcHVibGljL3YxL3F1ZXJ5L2dldF9hY3Rpdml0eSkuXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBhbHNvIHtAbGluayBzdGFtcEdldEFjdGl2aXR5fS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0QWN0aXZpdHkgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoXCIvcHVibGljL3YxL3F1ZXJ5L2dldF9hY3Rpdml0eVwiLCBpbnB1dCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9kdWNlIGEgYFNpZ25lZFJlcXVlc3RgIGZyb20gYFRHZXRBY3Rpdml0eUJvZHlgIGJ5IHVzaW5nIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgR2V0QWN0aXZpdHl9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFtcEdldEFjdGl2aXR5ID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmdWxsVXJsID0gdGhpcy5jb25maWcuYmFzZVVybCArIFwiL3B1YmxpYy92MS9xdWVyeS9nZXRfYWN0aXZpdHlcIjtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeShpbnB1dCk7XG4gICAgICAgICAgICBjb25zdCBzdGFtcCA9IGF3YWl0IHRoaXMuc3RhbXBlci5zdGFtcChib2R5KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgICAgICBzdGFtcDogc3RhbXAsXG4gICAgICAgICAgICAgICAgdXJsOiBmdWxsVXJsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBkZXRhaWxzIGFib3V0IGFuIEFQSSBrZXlcbiAgICAgICAgICpcbiAgICAgICAgICogU2lnbiB0aGUgcHJvdmlkZWQgYFRHZXRBcGlLZXlCb2R5YCB3aXRoIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLCBhbmQgc3VibWl0IHRoZSByZXF1ZXN0IChQT1NUIC9wdWJsaWMvdjEvcXVlcnkvZ2V0X2FwaV9rZXkpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgc3RhbXBHZXRBcGlLZXl9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZXRBcGlLZXkgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoXCIvcHVibGljL3YxL3F1ZXJ5L2dldF9hcGlfa2V5XCIsIGlucHV0KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb2R1Y2UgYSBgU2lnbmVkUmVxdWVzdGAgZnJvbSBgVEdldEFwaUtleUJvZHlgIGJ5IHVzaW5nIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgR2V0QXBpS2V5fS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhbXBHZXRBcGlLZXkgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZ1bGxVcmwgPSB0aGlzLmNvbmZpZy5iYXNlVXJsICsgXCIvcHVibGljL3YxL3F1ZXJ5L2dldF9hcGlfa2V5XCI7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkoaW5wdXQpO1xuICAgICAgICAgICAgY29uc3Qgc3RhbXAgPSBhd2FpdCB0aGlzLnN0YW1wZXIuc3RhbXAoYm9keSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICAgICAgc3RhbXA6IHN0YW1wLFxuICAgICAgICAgICAgICAgIHVybDogZnVsbFVybCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgZGV0YWlscyBhYm91dCBBUEkga2V5cyBmb3IgYSB1c2VyXG4gICAgICAgICAqXG4gICAgICAgICAqIFNpZ24gdGhlIHByb3ZpZGVkIGBUR2V0QXBpS2V5c0JvZHlgIHdpdGggdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24sIGFuZCBzdWJtaXQgdGhlIHJlcXVlc3QgKFBPU1QgL3B1YmxpYy92MS9xdWVyeS9nZXRfYXBpX2tleXMpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgc3RhbXBHZXRBcGlLZXlzfS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0QXBpS2V5cyA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChcIi9wdWJsaWMvdjEvcXVlcnkvZ2V0X2FwaV9rZXlzXCIsIGlucHV0KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb2R1Y2UgYSBgU2lnbmVkUmVxdWVzdGAgZnJvbSBgVEdldEFwaUtleXNCb2R5YCBieSB1c2luZyB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIEdldEFwaUtleXN9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFtcEdldEFwaUtleXMgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZ1bGxVcmwgPSB0aGlzLmNvbmZpZy5iYXNlVXJsICsgXCIvcHVibGljL3YxL3F1ZXJ5L2dldF9hcGlfa2V5c1wiO1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KGlucHV0KTtcbiAgICAgICAgICAgIGNvbnN0IHN0YW1wID0gYXdhaXQgdGhpcy5zdGFtcGVyLnN0YW1wKGJvZHkpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgICAgIHN0YW1wOiBzdGFtcCxcbiAgICAgICAgICAgICAgICB1cmw6IGZ1bGxVcmwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGRldGFpbHMgYWJvdXQgYW4gYXV0aGVudGljYXRvclxuICAgICAgICAgKlxuICAgICAgICAgKiBTaWduIHRoZSBwcm92aWRlZCBgVEdldEF1dGhlbnRpY2F0b3JCb2R5YCB3aXRoIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLCBhbmQgc3VibWl0IHRoZSByZXF1ZXN0IChQT1NUIC9wdWJsaWMvdjEvcXVlcnkvZ2V0X2F1dGhlbnRpY2F0b3IpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgc3RhbXBHZXRBdXRoZW50aWNhdG9yfS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0QXV0aGVudGljYXRvciA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChcIi9wdWJsaWMvdjEvcXVlcnkvZ2V0X2F1dGhlbnRpY2F0b3JcIiwgaW5wdXQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZHVjZSBhIGBTaWduZWRSZXF1ZXN0YCBmcm9tIGBUR2V0QXV0aGVudGljYXRvckJvZHlgIGJ5IHVzaW5nIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgR2V0QXV0aGVudGljYXRvcn0uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YW1wR2V0QXV0aGVudGljYXRvciA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnVsbFVybCA9IHRoaXMuY29uZmlnLmJhc2VVcmwgKyBcIi9wdWJsaWMvdjEvcXVlcnkvZ2V0X2F1dGhlbnRpY2F0b3JcIjtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeShpbnB1dCk7XG4gICAgICAgICAgICBjb25zdCBzdGFtcCA9IGF3YWl0IHRoaXMuc3RhbXBlci5zdGFtcChib2R5KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgICAgICBzdGFtcDogc3RhbXAsXG4gICAgICAgICAgICAgICAgdXJsOiBmdWxsVXJsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBkZXRhaWxzIGFib3V0IGF1dGhlbnRpY2F0b3JzIGZvciBhIHVzZXJcbiAgICAgICAgICpcbiAgICAgICAgICogU2lnbiB0aGUgcHJvdmlkZWQgYFRHZXRBdXRoZW50aWNhdG9yc0JvZHlgIHdpdGggdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24sIGFuZCBzdWJtaXQgdGhlIHJlcXVlc3QgKFBPU1QgL3B1YmxpYy92MS9xdWVyeS9nZXRfYXV0aGVudGljYXRvcnMpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgc3RhbXBHZXRBdXRoZW50aWNhdG9yc30uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldEF1dGhlbnRpY2F0b3JzID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KFwiL3B1YmxpYy92MS9xdWVyeS9nZXRfYXV0aGVudGljYXRvcnNcIiwgaW5wdXQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZHVjZSBhIGBTaWduZWRSZXF1ZXN0YCBmcm9tIGBUR2V0QXV0aGVudGljYXRvcnNCb2R5YCBieSB1c2luZyB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIEdldEF1dGhlbnRpY2F0b3JzfS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhbXBHZXRBdXRoZW50aWNhdG9ycyA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnVsbFVybCA9IHRoaXMuY29uZmlnLmJhc2VVcmwgKyBcIi9wdWJsaWMvdjEvcXVlcnkvZ2V0X2F1dGhlbnRpY2F0b3JzXCI7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkoaW5wdXQpO1xuICAgICAgICAgICAgY29uc3Qgc3RhbXAgPSBhd2FpdCB0aGlzLnN0YW1wZXIuc3RhbXAoYm9keSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICAgICAgc3RhbXA6IHN0YW1wLFxuICAgICAgICAgICAgICAgIHVybDogZnVsbFVybCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgZGV0YWlscyBhYm91dCBhbiBPcmdhbml6YXRpb25cbiAgICAgICAgICpcbiAgICAgICAgICogU2lnbiB0aGUgcHJvdmlkZWQgYFRHZXRPcmdhbml6YXRpb25Cb2R5YCB3aXRoIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLCBhbmQgc3VibWl0IHRoZSByZXF1ZXN0IChQT1NUIC9wdWJsaWMvdjEvcXVlcnkvZ2V0X29yZ2FuaXphdGlvbikuXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBhbHNvIHtAbGluayBzdGFtcEdldE9yZ2FuaXphdGlvbn0uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldE9yZ2FuaXphdGlvbiA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChcIi9wdWJsaWMvdjEvcXVlcnkvZ2V0X29yZ2FuaXphdGlvblwiLCBpbnB1dCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9kdWNlIGEgYFNpZ25lZFJlcXVlc3RgIGZyb20gYFRHZXRPcmdhbml6YXRpb25Cb2R5YCBieSB1c2luZyB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIEdldE9yZ2FuaXphdGlvbn0uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YW1wR2V0T3JnYW5pemF0aW9uID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmdWxsVXJsID0gdGhpcy5jb25maWcuYmFzZVVybCArIFwiL3B1YmxpYy92MS9xdWVyeS9nZXRfb3JnYW5pemF0aW9uXCI7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkoaW5wdXQpO1xuICAgICAgICAgICAgY29uc3Qgc3RhbXAgPSBhd2FpdCB0aGlzLnN0YW1wZXIuc3RhbXAoYm9keSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICAgICAgc3RhbXA6IHN0YW1wLFxuICAgICAgICAgICAgICAgIHVybDogZnVsbFVybCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgZGV0YWlscyBhYm91dCBhIFBvbGljeVxuICAgICAgICAgKlxuICAgICAgICAgKiBTaWduIHRoZSBwcm92aWRlZCBgVEdldFBvbGljeUJvZHlgIHdpdGggdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24sIGFuZCBzdWJtaXQgdGhlIHJlcXVlc3QgKFBPU1QgL3B1YmxpYy92MS9xdWVyeS9nZXRfcG9saWN5KS5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIHN0YW1wR2V0UG9saWN5fS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0UG9saWN5ID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KFwiL3B1YmxpYy92MS9xdWVyeS9nZXRfcG9saWN5XCIsIGlucHV0KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb2R1Y2UgYSBgU2lnbmVkUmVxdWVzdGAgZnJvbSBgVEdldFBvbGljeUJvZHlgIGJ5IHVzaW5nIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgR2V0UG9saWN5fS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhbXBHZXRQb2xpY3kgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZ1bGxVcmwgPSB0aGlzLmNvbmZpZy5iYXNlVXJsICsgXCIvcHVibGljL3YxL3F1ZXJ5L2dldF9wb2xpY3lcIjtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeShpbnB1dCk7XG4gICAgICAgICAgICBjb25zdCBzdGFtcCA9IGF3YWl0IHRoaXMuc3RhbXBlci5zdGFtcChib2R5KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgICAgICBzdGFtcDogc3RhbXAsXG4gICAgICAgICAgICAgICAgdXJsOiBmdWxsVXJsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBkZXRhaWxzIGFib3V0IGEgUHJpdmF0ZSBLZXlcbiAgICAgICAgICpcbiAgICAgICAgICogU2lnbiB0aGUgcHJvdmlkZWQgYFRHZXRQcml2YXRlS2V5Qm9keWAgd2l0aCB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbiwgYW5kIHN1Ym1pdCB0aGUgcmVxdWVzdCAoUE9TVCAvcHVibGljL3YxL3F1ZXJ5L2dldF9wcml2YXRlX2tleSkuXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBhbHNvIHtAbGluayBzdGFtcEdldFByaXZhdGVLZXl9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZXRQcml2YXRlS2V5ID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KFwiL3B1YmxpYy92MS9xdWVyeS9nZXRfcHJpdmF0ZV9rZXlcIiwgaW5wdXQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZHVjZSBhIGBTaWduZWRSZXF1ZXN0YCBmcm9tIGBUR2V0UHJpdmF0ZUtleUJvZHlgIGJ5IHVzaW5nIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgR2V0UHJpdmF0ZUtleX0uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YW1wR2V0UHJpdmF0ZUtleSA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnVsbFVybCA9IHRoaXMuY29uZmlnLmJhc2VVcmwgKyBcIi9wdWJsaWMvdjEvcXVlcnkvZ2V0X3ByaXZhdGVfa2V5XCI7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkoaW5wdXQpO1xuICAgICAgICAgICAgY29uc3Qgc3RhbXAgPSBhd2FpdCB0aGlzLnN0YW1wZXIuc3RhbXAoYm9keSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICAgICAgc3RhbXA6IHN0YW1wLFxuICAgICAgICAgICAgICAgIHVybDogZnVsbFVybCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgZGV0YWlscyBhYm91dCBhIFVzZXJcbiAgICAgICAgICpcbiAgICAgICAgICogU2lnbiB0aGUgcHJvdmlkZWQgYFRHZXRVc2VyQm9keWAgd2l0aCB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbiwgYW5kIHN1Ym1pdCB0aGUgcmVxdWVzdCAoUE9TVCAvcHVibGljL3YxL3F1ZXJ5L2dldF91c2VyKS5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIHN0YW1wR2V0VXNlcn0uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldFVzZXIgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoXCIvcHVibGljL3YxL3F1ZXJ5L2dldF91c2VyXCIsIGlucHV0KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb2R1Y2UgYSBgU2lnbmVkUmVxdWVzdGAgZnJvbSBgVEdldFVzZXJCb2R5YCBieSB1c2luZyB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIEdldFVzZXJ9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFtcEdldFVzZXIgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZ1bGxVcmwgPSB0aGlzLmNvbmZpZy5iYXNlVXJsICsgXCIvcHVibGljL3YxL3F1ZXJ5L2dldF91c2VyXCI7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkoaW5wdXQpO1xuICAgICAgICAgICAgY29uc3Qgc3RhbXAgPSBhd2FpdCB0aGlzLnN0YW1wZXIuc3RhbXAoYm9keSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICAgICAgc3RhbXA6IHN0YW1wLFxuICAgICAgICAgICAgICAgIHVybDogZnVsbFVybCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgZGV0YWlscyBhYm91dCBhIFdhbGxldFxuICAgICAgICAgKlxuICAgICAgICAgKiBTaWduIHRoZSBwcm92aWRlZCBgVEdldFdhbGxldEJvZHlgIHdpdGggdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24sIGFuZCBzdWJtaXQgdGhlIHJlcXVlc3QgKFBPU1QgL3B1YmxpYy92MS9xdWVyeS9nZXRfd2FsbGV0KS5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIHN0YW1wR2V0V2FsbGV0fS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0V2FsbGV0ID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KFwiL3B1YmxpYy92MS9xdWVyeS9nZXRfd2FsbGV0XCIsIGlucHV0KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb2R1Y2UgYSBgU2lnbmVkUmVxdWVzdGAgZnJvbSBgVEdldFdhbGxldEJvZHlgIGJ5IHVzaW5nIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgR2V0V2FsbGV0fS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhbXBHZXRXYWxsZXQgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZ1bGxVcmwgPSB0aGlzLmNvbmZpZy5iYXNlVXJsICsgXCIvcHVibGljL3YxL3F1ZXJ5L2dldF93YWxsZXRcIjtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeShpbnB1dCk7XG4gICAgICAgICAgICBjb25zdCBzdGFtcCA9IGF3YWl0IHRoaXMuc3RhbXBlci5zdGFtcChib2R5KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgICAgICBzdGFtcDogc3RhbXAsXG4gICAgICAgICAgICAgICAgdXJsOiBmdWxsVXJsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3QgYWxsIEFjdGl2aXRpZXMgd2l0aGluIGFuIE9yZ2FuaXphdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBTaWduIHRoZSBwcm92aWRlZCBgVEdldEFjdGl2aXRpZXNCb2R5YCB3aXRoIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLCBhbmQgc3VibWl0IHRoZSByZXF1ZXN0IChQT1NUIC9wdWJsaWMvdjEvcXVlcnkvbGlzdF9hY3Rpdml0aWVzKS5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIHN0YW1wR2V0QWN0aXZpdGllc30uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldEFjdGl2aXRpZXMgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoXCIvcHVibGljL3YxL3F1ZXJ5L2xpc3RfYWN0aXZpdGllc1wiLCBpbnB1dCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9kdWNlIGEgYFNpZ25lZFJlcXVlc3RgIGZyb20gYFRHZXRBY3Rpdml0aWVzQm9keWAgYnkgdXNpbmcgdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBhbHNvIHtAbGluayBHZXRBY3Rpdml0aWVzfS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhbXBHZXRBY3Rpdml0aWVzID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmdWxsVXJsID0gdGhpcy5jb25maWcuYmFzZVVybCArIFwiL3B1YmxpYy92MS9xdWVyeS9saXN0X2FjdGl2aXRpZXNcIjtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeShpbnB1dCk7XG4gICAgICAgICAgICBjb25zdCBzdGFtcCA9IGF3YWl0IHRoaXMuc3RhbXBlci5zdGFtcChib2R5KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgICAgICBzdGFtcDogc3RhbXAsXG4gICAgICAgICAgICAgICAgdXJsOiBmdWxsVXJsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3QgYWxsIFBvbGljaWVzIHdpdGhpbiBhbiBPcmdhbml6YXRpb25cbiAgICAgICAgICpcbiAgICAgICAgICogU2lnbiB0aGUgcHJvdmlkZWQgYFRHZXRQb2xpY2llc0JvZHlgIHdpdGggdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24sIGFuZCBzdWJtaXQgdGhlIHJlcXVlc3QgKFBPU1QgL3B1YmxpYy92MS9xdWVyeS9saXN0X3BvbGljaWVzKS5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIHN0YW1wR2V0UG9saWNpZXN9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZXRQb2xpY2llcyA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChcIi9wdWJsaWMvdjEvcXVlcnkvbGlzdF9wb2xpY2llc1wiLCBpbnB1dCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9kdWNlIGEgYFNpZ25lZFJlcXVlc3RgIGZyb20gYFRHZXRQb2xpY2llc0JvZHlgIGJ5IHVzaW5nIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgR2V0UG9saWNpZXN9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFtcEdldFBvbGljaWVzID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmdWxsVXJsID0gdGhpcy5jb25maWcuYmFzZVVybCArIFwiL3B1YmxpYy92MS9xdWVyeS9saXN0X3BvbGljaWVzXCI7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkoaW5wdXQpO1xuICAgICAgICAgICAgY29uc3Qgc3RhbXAgPSBhd2FpdCB0aGlzLnN0YW1wZXIuc3RhbXAoYm9keSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICAgICAgc3RhbXA6IHN0YW1wLFxuICAgICAgICAgICAgICAgIHVybDogZnVsbFVybCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IGFsbCBQcml2YXRlIEtleSBUYWdzIHdpdGhpbiBhbiBPcmdhbml6YXRpb25cbiAgICAgICAgICpcbiAgICAgICAgICogU2lnbiB0aGUgcHJvdmlkZWQgYFRMaXN0UHJpdmF0ZUtleVRhZ3NCb2R5YCB3aXRoIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLCBhbmQgc3VibWl0IHRoZSByZXF1ZXN0IChQT1NUIC9wdWJsaWMvdjEvcXVlcnkvbGlzdF9wcml2YXRlX2tleV90YWdzKS5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIHN0YW1wTGlzdFByaXZhdGVLZXlUYWdzfS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGlzdFByaXZhdGVLZXlUYWdzID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KFwiL3B1YmxpYy92MS9xdWVyeS9saXN0X3ByaXZhdGVfa2V5X3RhZ3NcIiwgaW5wdXQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZHVjZSBhIGBTaWduZWRSZXF1ZXN0YCBmcm9tIGBUTGlzdFByaXZhdGVLZXlUYWdzQm9keWAgYnkgdXNpbmcgdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBhbHNvIHtAbGluayBMaXN0UHJpdmF0ZUtleVRhZ3N9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFtcExpc3RQcml2YXRlS2V5VGFncyA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnVsbFVybCA9IHRoaXMuY29uZmlnLmJhc2VVcmwgKyBcIi9wdWJsaWMvdjEvcXVlcnkvbGlzdF9wcml2YXRlX2tleV90YWdzXCI7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkoaW5wdXQpO1xuICAgICAgICAgICAgY29uc3Qgc3RhbXAgPSBhd2FpdCB0aGlzLnN0YW1wZXIuc3RhbXAoYm9keSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICAgICAgc3RhbXA6IHN0YW1wLFxuICAgICAgICAgICAgICAgIHVybDogZnVsbFVybCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IGFsbCBQcml2YXRlIEtleXMgd2l0aGluIGFuIE9yZ2FuaXphdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBTaWduIHRoZSBwcm92aWRlZCBgVEdldFByaXZhdGVLZXlzQm9keWAgd2l0aCB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbiwgYW5kIHN1Ym1pdCB0aGUgcmVxdWVzdCAoUE9TVCAvcHVibGljL3YxL3F1ZXJ5L2xpc3RfcHJpdmF0ZV9rZXlzKS5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIHN0YW1wR2V0UHJpdmF0ZUtleXN9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZXRQcml2YXRlS2V5cyA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChcIi9wdWJsaWMvdjEvcXVlcnkvbGlzdF9wcml2YXRlX2tleXNcIiwgaW5wdXQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZHVjZSBhIGBTaWduZWRSZXF1ZXN0YCBmcm9tIGBUR2V0UHJpdmF0ZUtleXNCb2R5YCBieSB1c2luZyB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIEdldFByaXZhdGVLZXlzfS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhbXBHZXRQcml2YXRlS2V5cyA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnVsbFVybCA9IHRoaXMuY29uZmlnLmJhc2VVcmwgKyBcIi9wdWJsaWMvdjEvcXVlcnkvbGlzdF9wcml2YXRlX2tleXNcIjtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeShpbnB1dCk7XG4gICAgICAgICAgICBjb25zdCBzdGFtcCA9IGF3YWl0IHRoaXMuc3RhbXBlci5zdGFtcChib2R5KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgICAgICBzdGFtcDogc3RhbXAsXG4gICAgICAgICAgICAgICAgdXJsOiBmdWxsVXJsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhbGwgc3Vib3JnIElEcyBhc3NvY2lhdGVkIGdpdmVuIGEgcGFyZW50IG9yZyBJRCBhbmQgYW4gb3B0aW9uYWwgZmlsdGVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTaWduIHRoZSBwcm92aWRlZCBgVEdldFN1Yk9yZ0lkc0JvZHlgIHdpdGggdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24sIGFuZCBzdWJtaXQgdGhlIHJlcXVlc3QgKFBPU1QgL3B1YmxpYy92MS9xdWVyeS9saXN0X3N1Ym9yZ3MpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgc3RhbXBHZXRTdWJPcmdJZHN9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZXRTdWJPcmdJZHMgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoXCIvcHVibGljL3YxL3F1ZXJ5L2xpc3Rfc3Vib3Jnc1wiLCBpbnB1dCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9kdWNlIGEgYFNpZ25lZFJlcXVlc3RgIGZyb20gYFRHZXRTdWJPcmdJZHNCb2R5YCBieSB1c2luZyB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIEdldFN1Yk9yZ0lkc30uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YW1wR2V0U3ViT3JnSWRzID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmdWxsVXJsID0gdGhpcy5jb25maWcuYmFzZVVybCArIFwiL3B1YmxpYy92MS9xdWVyeS9saXN0X3N1Ym9yZ3NcIjtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeShpbnB1dCk7XG4gICAgICAgICAgICBjb25zdCBzdGFtcCA9IGF3YWl0IHRoaXMuc3RhbXBlci5zdGFtcChib2R5KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgICAgICBzdGFtcDogc3RhbXAsXG4gICAgICAgICAgICAgICAgdXJsOiBmdWxsVXJsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3QgYWxsIFVzZXIgVGFncyB3aXRoaW4gYW4gT3JnYW5pemF0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIFNpZ24gdGhlIHByb3ZpZGVkIGBUTGlzdFVzZXJUYWdzQm9keWAgd2l0aCB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbiwgYW5kIHN1Ym1pdCB0aGUgcmVxdWVzdCAoUE9TVCAvcHVibGljL3YxL3F1ZXJ5L2xpc3RfdXNlcl90YWdzKS5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIHN0YW1wTGlzdFVzZXJUYWdzfS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGlzdFVzZXJUYWdzID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KFwiL3B1YmxpYy92MS9xdWVyeS9saXN0X3VzZXJfdGFnc1wiLCBpbnB1dCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9kdWNlIGEgYFNpZ25lZFJlcXVlc3RgIGZyb20gYFRMaXN0VXNlclRhZ3NCb2R5YCBieSB1c2luZyB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIExpc3RVc2VyVGFnc30uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YW1wTGlzdFVzZXJUYWdzID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmdWxsVXJsID0gdGhpcy5jb25maWcuYmFzZVVybCArIFwiL3B1YmxpYy92MS9xdWVyeS9saXN0X3VzZXJfdGFnc1wiO1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KGlucHV0KTtcbiAgICAgICAgICAgIGNvbnN0IHN0YW1wID0gYXdhaXQgdGhpcy5zdGFtcGVyLnN0YW1wKGJvZHkpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgICAgIHN0YW1wOiBzdGFtcCxcbiAgICAgICAgICAgICAgICB1cmw6IGZ1bGxVcmwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCBhbGwgVXNlcnMgd2l0aGluIGFuIE9yZ2FuaXphdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBTaWduIHRoZSBwcm92aWRlZCBgVEdldFVzZXJzQm9keWAgd2l0aCB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbiwgYW5kIHN1Ym1pdCB0aGUgcmVxdWVzdCAoUE9TVCAvcHVibGljL3YxL3F1ZXJ5L2xpc3RfdXNlcnMpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgc3RhbXBHZXRVc2Vyc30uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldFVzZXJzID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KFwiL3B1YmxpYy92MS9xdWVyeS9saXN0X3VzZXJzXCIsIGlucHV0KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb2R1Y2UgYSBgU2lnbmVkUmVxdWVzdGAgZnJvbSBgVEdldFVzZXJzQm9keWAgYnkgdXNpbmcgdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBhbHNvIHtAbGluayBHZXRVc2Vyc30uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YW1wR2V0VXNlcnMgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZ1bGxVcmwgPSB0aGlzLmNvbmZpZy5iYXNlVXJsICsgXCIvcHVibGljL3YxL3F1ZXJ5L2xpc3RfdXNlcnNcIjtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeShpbnB1dCk7XG4gICAgICAgICAgICBjb25zdCBzdGFtcCA9IGF3YWl0IHRoaXMuc3RhbXBlci5zdGFtcChib2R5KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgICAgICBzdGFtcDogc3RhbXAsXG4gICAgICAgICAgICAgICAgdXJsOiBmdWxsVXJsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3QgYWxsIEFjY291bnRzIHdpcmhpbiBhIFdhbGxldFxuICAgICAgICAgKlxuICAgICAgICAgKiBTaWduIHRoZSBwcm92aWRlZCBgVEdldFdhbGxldEFjY291bnRzQm9keWAgd2l0aCB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbiwgYW5kIHN1Ym1pdCB0aGUgcmVxdWVzdCAoUE9TVCAvcHVibGljL3YxL3F1ZXJ5L2xpc3Rfd2FsbGV0X2FjY291bnRzKS5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIHN0YW1wR2V0V2FsbGV0QWNjb3VudHN9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZXRXYWxsZXRBY2NvdW50cyA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChcIi9wdWJsaWMvdjEvcXVlcnkvbGlzdF93YWxsZXRfYWNjb3VudHNcIiwgaW5wdXQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZHVjZSBhIGBTaWduZWRSZXF1ZXN0YCBmcm9tIGBUR2V0V2FsbGV0QWNjb3VudHNCb2R5YCBieSB1c2luZyB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIEdldFdhbGxldEFjY291bnRzfS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhbXBHZXRXYWxsZXRBY2NvdW50cyA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnVsbFVybCA9IHRoaXMuY29uZmlnLmJhc2VVcmwgKyBcIi9wdWJsaWMvdjEvcXVlcnkvbGlzdF93YWxsZXRfYWNjb3VudHNcIjtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeShpbnB1dCk7XG4gICAgICAgICAgICBjb25zdCBzdGFtcCA9IGF3YWl0IHRoaXMuc3RhbXBlci5zdGFtcChib2R5KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgICAgICBzdGFtcDogc3RhbXAsXG4gICAgICAgICAgICAgICAgdXJsOiBmdWxsVXJsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3QgYWxsIFdhbGxldHMgd2l0aGluIGFuIE9yZ2FuaXphdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBTaWduIHRoZSBwcm92aWRlZCBgVEdldFdhbGxldHNCb2R5YCB3aXRoIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLCBhbmQgc3VibWl0IHRoZSByZXF1ZXN0IChQT1NUIC9wdWJsaWMvdjEvcXVlcnkvbGlzdF93YWxsZXRzKS5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIHN0YW1wR2V0V2FsbGV0c30uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldFdhbGxldHMgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoXCIvcHVibGljL3YxL3F1ZXJ5L2xpc3Rfd2FsbGV0c1wiLCBpbnB1dCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9kdWNlIGEgYFNpZ25lZFJlcXVlc3RgIGZyb20gYFRHZXRXYWxsZXRzQm9keWAgYnkgdXNpbmcgdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBhbHNvIHtAbGluayBHZXRXYWxsZXRzfS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhbXBHZXRXYWxsZXRzID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmdWxsVXJsID0gdGhpcy5jb25maWcuYmFzZVVybCArIFwiL3B1YmxpYy92MS9xdWVyeS9saXN0X3dhbGxldHNcIjtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeShpbnB1dCk7XG4gICAgICAgICAgICBjb25zdCBzdGFtcCA9IGF3YWl0IHRoaXMuc3RhbXBlci5zdGFtcChib2R5KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgICAgICBzdGFtcDogc3RhbXAsXG4gICAgICAgICAgICAgICAgdXJsOiBmdWxsVXJsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBiYXNpYyBpbmZvcm1hdGlvbiBhYm91dCB5b3VyIGN1cnJlbnQgQVBJIG9yIFdlYkF1dGhOIHVzZXIgYW5kIHRoZWlyIG9yZ2FuaXphdGlvbi4gQWZmb3JkcyBTdWItT3JnYW5pemF0aW9uIGxvb2sgdXBzIHZpYSBQYXJlbnQgT3JnYW5pemF0aW9uIGZvciBXZWJBdXRoTiBvciBBUEkga2V5IHVzZXJzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTaWduIHRoZSBwcm92aWRlZCBgVEdldFdob2FtaUJvZHlgIHdpdGggdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24sIGFuZCBzdWJtaXQgdGhlIHJlcXVlc3QgKFBPU1QgL3B1YmxpYy92MS9xdWVyeS93aG9hbWkpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgc3RhbXBHZXRXaG9hbWl9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZXRXaG9hbWkgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoXCIvcHVibGljL3YxL3F1ZXJ5L3dob2FtaVwiLCBpbnB1dCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9kdWNlIGEgYFNpZ25lZFJlcXVlc3RgIGZyb20gYFRHZXRXaG9hbWlCb2R5YCBieSB1c2luZyB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIEdldFdob2FtaX0uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YW1wR2V0V2hvYW1pID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmdWxsVXJsID0gdGhpcy5jb25maWcuYmFzZVVybCArIFwiL3B1YmxpYy92MS9xdWVyeS93aG9hbWlcIjtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeShpbnB1dCk7XG4gICAgICAgICAgICBjb25zdCBzdGFtcCA9IGF3YWl0IHRoaXMuc3RhbXBlci5zdGFtcChib2R5KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgICAgICBzdGFtcDogc3RhbXAsXG4gICAgICAgICAgICAgICAgdXJsOiBmdWxsVXJsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFwcHJvdmUgYW4gQWN0aXZpdHlcbiAgICAgICAgICpcbiAgICAgICAgICogU2lnbiB0aGUgcHJvdmlkZWQgYFRBcHByb3ZlQWN0aXZpdHlCb2R5YCB3aXRoIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLCBhbmQgc3VibWl0IHRoZSByZXF1ZXN0IChQT1NUIC9wdWJsaWMvdjEvc3VibWl0L2FwcHJvdmVfYWN0aXZpdHkpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgc3RhbXBBcHByb3ZlQWN0aXZpdHl9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hcHByb3ZlQWN0aXZpdHkgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoXCIvcHVibGljL3YxL3N1Ym1pdC9hcHByb3ZlX2FjdGl2aXR5XCIsIGlucHV0KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb2R1Y2UgYSBgU2lnbmVkUmVxdWVzdGAgZnJvbSBgVEFwcHJvdmVBY3Rpdml0eUJvZHlgIGJ5IHVzaW5nIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgQXBwcm92ZUFjdGl2aXR5fS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhbXBBcHByb3ZlQWN0aXZpdHkgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZ1bGxVcmwgPSB0aGlzLmNvbmZpZy5iYXNlVXJsICsgXCIvcHVibGljL3YxL3N1Ym1pdC9hcHByb3ZlX2FjdGl2aXR5XCI7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkoaW5wdXQpO1xuICAgICAgICAgICAgY29uc3Qgc3RhbXAgPSBhd2FpdCB0aGlzLnN0YW1wZXIuc3RhbXAoYm9keSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICAgICAgc3RhbXA6IHN0YW1wLFxuICAgICAgICAgICAgICAgIHVybDogZnVsbFVybCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgYXBpIGtleXMgdG8gYW4gZXhpc3RpbmcgVXNlclxuICAgICAgICAgKlxuICAgICAgICAgKiBTaWduIHRoZSBwcm92aWRlZCBgVENyZWF0ZUFwaUtleXNCb2R5YCB3aXRoIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLCBhbmQgc3VibWl0IHRoZSByZXF1ZXN0IChQT1NUIC9wdWJsaWMvdjEvc3VibWl0L2NyZWF0ZV9hcGlfa2V5cykuXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBhbHNvIHtAbGluayBzdGFtcENyZWF0ZUFwaUtleXN9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jcmVhdGVBcGlLZXlzID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KFwiL3B1YmxpYy92MS9zdWJtaXQvY3JlYXRlX2FwaV9rZXlzXCIsIGlucHV0KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb2R1Y2UgYSBgU2lnbmVkUmVxdWVzdGAgZnJvbSBgVENyZWF0ZUFwaUtleXNCb2R5YCBieSB1c2luZyB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIENyZWF0ZUFwaUtleXN9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFtcENyZWF0ZUFwaUtleXMgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZ1bGxVcmwgPSB0aGlzLmNvbmZpZy5iYXNlVXJsICsgXCIvcHVibGljL3YxL3N1Ym1pdC9jcmVhdGVfYXBpX2tleXNcIjtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeShpbnB1dCk7XG4gICAgICAgICAgICBjb25zdCBzdGFtcCA9IGF3YWl0IHRoaXMuc3RhbXBlci5zdGFtcChib2R5KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgICAgICBzdGFtcDogc3RhbXAsXG4gICAgICAgICAgICAgICAgdXJsOiBmdWxsVXJsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBBUEktb25seSBVc2VycyBpbiBhbiBleGlzdGluZyBPcmdhbml6YXRpb25cbiAgICAgICAgICpcbiAgICAgICAgICogU2lnbiB0aGUgcHJvdmlkZWQgYFRDcmVhdGVBcGlPbmx5VXNlcnNCb2R5YCB3aXRoIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLCBhbmQgc3VibWl0IHRoZSByZXF1ZXN0IChQT1NUIC9wdWJsaWMvdjEvc3VibWl0L2NyZWF0ZV9hcGlfb25seV91c2VycykuXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBhbHNvIHtAbGluayBzdGFtcENyZWF0ZUFwaU9ubHlVc2Vyc30uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNyZWF0ZUFwaU9ubHlVc2VycyA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChcIi9wdWJsaWMvdjEvc3VibWl0L2NyZWF0ZV9hcGlfb25seV91c2Vyc1wiLCBpbnB1dCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9kdWNlIGEgYFNpZ25lZFJlcXVlc3RgIGZyb20gYFRDcmVhdGVBcGlPbmx5VXNlcnNCb2R5YCBieSB1c2luZyB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIENyZWF0ZUFwaU9ubHlVc2Vyc30uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YW1wQ3JlYXRlQXBpT25seVVzZXJzID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmdWxsVXJsID0gdGhpcy5jb25maWcuYmFzZVVybCArIFwiL3B1YmxpYy92MS9zdWJtaXQvY3JlYXRlX2FwaV9vbmx5X3VzZXJzXCI7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkoaW5wdXQpO1xuICAgICAgICAgICAgY29uc3Qgc3RhbXAgPSBhd2FpdCB0aGlzLnN0YW1wZXIuc3RhbXAoYm9keSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICAgICAgc3RhbXA6IHN0YW1wLFxuICAgICAgICAgICAgICAgIHVybDogZnVsbFVybCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgQXV0aGVudGljYXRvcnMgdG8gYXV0aGVudGljYXRlIHJlcXVlc3RzIHRvIFR1cm5rZXlcbiAgICAgICAgICpcbiAgICAgICAgICogU2lnbiB0aGUgcHJvdmlkZWQgYFRDcmVhdGVBdXRoZW50aWNhdG9yc0JvZHlgIHdpdGggdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24sIGFuZCBzdWJtaXQgdGhlIHJlcXVlc3QgKFBPU1QgL3B1YmxpYy92MS9zdWJtaXQvY3JlYXRlX2F1dGhlbnRpY2F0b3JzKS5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIHN0YW1wQ3JlYXRlQXV0aGVudGljYXRvcnN9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jcmVhdGVBdXRoZW50aWNhdG9ycyA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChcIi9wdWJsaWMvdjEvc3VibWl0L2NyZWF0ZV9hdXRoZW50aWNhdG9yc1wiLCBpbnB1dCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9kdWNlIGEgYFNpZ25lZFJlcXVlc3RgIGZyb20gYFRDcmVhdGVBdXRoZW50aWNhdG9yc0JvZHlgIGJ5IHVzaW5nIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgQ3JlYXRlQXV0aGVudGljYXRvcnN9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFtcENyZWF0ZUF1dGhlbnRpY2F0b3JzID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmdWxsVXJsID0gdGhpcy5jb25maWcuYmFzZVVybCArIFwiL3B1YmxpYy92MS9zdWJtaXQvY3JlYXRlX2F1dGhlbnRpY2F0b3JzXCI7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkoaW5wdXQpO1xuICAgICAgICAgICAgY29uc3Qgc3RhbXAgPSBhd2FpdCB0aGlzLnN0YW1wZXIuc3RhbXAoYm9keSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICAgICAgc3RhbXA6IHN0YW1wLFxuICAgICAgICAgICAgICAgIHVybDogZnVsbFVybCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgSW52aXRhdGlvbnMgdG8gam9pbiBhbiBleGlzdGluZyBPcmdhbml6YXRpb25cbiAgICAgICAgICpcbiAgICAgICAgICogU2lnbiB0aGUgcHJvdmlkZWQgYFRDcmVhdGVJbnZpdGF0aW9uc0JvZHlgIHdpdGggdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24sIGFuZCBzdWJtaXQgdGhlIHJlcXVlc3QgKFBPU1QgL3B1YmxpYy92MS9zdWJtaXQvY3JlYXRlX2ludml0YXRpb25zKS5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIHN0YW1wQ3JlYXRlSW52aXRhdGlvbnN9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jcmVhdGVJbnZpdGF0aW9ucyA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChcIi9wdWJsaWMvdjEvc3VibWl0L2NyZWF0ZV9pbnZpdGF0aW9uc1wiLCBpbnB1dCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9kdWNlIGEgYFNpZ25lZFJlcXVlc3RgIGZyb20gYFRDcmVhdGVJbnZpdGF0aW9uc0JvZHlgIGJ5IHVzaW5nIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgQ3JlYXRlSW52aXRhdGlvbnN9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFtcENyZWF0ZUludml0YXRpb25zID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmdWxsVXJsID0gdGhpcy5jb25maWcuYmFzZVVybCArIFwiL3B1YmxpYy92MS9zdWJtaXQvY3JlYXRlX2ludml0YXRpb25zXCI7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkoaW5wdXQpO1xuICAgICAgICAgICAgY29uc3Qgc3RhbXAgPSBhd2FpdCB0aGlzLnN0YW1wZXIuc3RhbXAoYm9keSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICAgICAgc3RhbXA6IHN0YW1wLFxuICAgICAgICAgICAgICAgIHVybDogZnVsbFVybCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgbmV3IFBvbGljaWVzXG4gICAgICAgICAqXG4gICAgICAgICAqIFNpZ24gdGhlIHByb3ZpZGVkIGBUQ3JlYXRlUG9saWNpZXNCb2R5YCB3aXRoIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLCBhbmQgc3VibWl0IHRoZSByZXF1ZXN0IChQT1NUIC9wdWJsaWMvdjEvc3VibWl0L2NyZWF0ZV9wb2xpY2llcykuXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBhbHNvIHtAbGluayBzdGFtcENyZWF0ZVBvbGljaWVzfS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY3JlYXRlUG9saWNpZXMgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoXCIvcHVibGljL3YxL3N1Ym1pdC9jcmVhdGVfcG9saWNpZXNcIiwgaW5wdXQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZHVjZSBhIGBTaWduZWRSZXF1ZXN0YCBmcm9tIGBUQ3JlYXRlUG9saWNpZXNCb2R5YCBieSB1c2luZyB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIENyZWF0ZVBvbGljaWVzfS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhbXBDcmVhdGVQb2xpY2llcyA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnVsbFVybCA9IHRoaXMuY29uZmlnLmJhc2VVcmwgKyBcIi9wdWJsaWMvdjEvc3VibWl0L2NyZWF0ZV9wb2xpY2llc1wiO1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KGlucHV0KTtcbiAgICAgICAgICAgIGNvbnN0IHN0YW1wID0gYXdhaXQgdGhpcy5zdGFtcGVyLnN0YW1wKGJvZHkpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgICAgIHN0YW1wOiBzdGFtcCxcbiAgICAgICAgICAgICAgICB1cmw6IGZ1bGxVcmwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgbmV3IFBvbGljeVxuICAgICAgICAgKlxuICAgICAgICAgKiBTaWduIHRoZSBwcm92aWRlZCBgVENyZWF0ZVBvbGljeUJvZHlgIHdpdGggdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24sIGFuZCBzdWJtaXQgdGhlIHJlcXVlc3QgKFBPU1QgL3B1YmxpYy92MS9zdWJtaXQvY3JlYXRlX3BvbGljeSkuXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBhbHNvIHtAbGluayBzdGFtcENyZWF0ZVBvbGljeX0uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNyZWF0ZVBvbGljeSA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChcIi9wdWJsaWMvdjEvc3VibWl0L2NyZWF0ZV9wb2xpY3lcIiwgaW5wdXQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZHVjZSBhIGBTaWduZWRSZXF1ZXN0YCBmcm9tIGBUQ3JlYXRlUG9saWN5Qm9keWAgYnkgdXNpbmcgdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBhbHNvIHtAbGluayBDcmVhdGVQb2xpY3l9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFtcENyZWF0ZVBvbGljeSA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnVsbFVybCA9IHRoaXMuY29uZmlnLmJhc2VVcmwgKyBcIi9wdWJsaWMvdjEvc3VibWl0L2NyZWF0ZV9wb2xpY3lcIjtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeShpbnB1dCk7XG4gICAgICAgICAgICBjb25zdCBzdGFtcCA9IGF3YWl0IHRoaXMuc3RhbXBlci5zdGFtcChib2R5KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgICAgICBzdGFtcDogc3RhbXAsXG4gICAgICAgICAgICAgICAgdXJsOiBmdWxsVXJsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIHByaXZhdGUga2V5IHRhZyBhbmQgYWRkIGl0IHRvIHByaXZhdGUga2V5cy5cbiAgICAgICAgICpcbiAgICAgICAgICogU2lnbiB0aGUgcHJvdmlkZWQgYFRDcmVhdGVQcml2YXRlS2V5VGFnQm9keWAgd2l0aCB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbiwgYW5kIHN1Ym1pdCB0aGUgcmVxdWVzdCAoUE9TVCAvcHVibGljL3YxL3N1Ym1pdC9jcmVhdGVfcHJpdmF0ZV9rZXlfdGFnKS5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIHN0YW1wQ3JlYXRlUHJpdmF0ZUtleVRhZ30uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNyZWF0ZVByaXZhdGVLZXlUYWcgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoXCIvcHVibGljL3YxL3N1Ym1pdC9jcmVhdGVfcHJpdmF0ZV9rZXlfdGFnXCIsIGlucHV0KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb2R1Y2UgYSBgU2lnbmVkUmVxdWVzdGAgZnJvbSBgVENyZWF0ZVByaXZhdGVLZXlUYWdCb2R5YCBieSB1c2luZyB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIENyZWF0ZVByaXZhdGVLZXlUYWd9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFtcENyZWF0ZVByaXZhdGVLZXlUYWcgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZ1bGxVcmwgPSB0aGlzLmNvbmZpZy5iYXNlVXJsICsgXCIvcHVibGljL3YxL3N1Ym1pdC9jcmVhdGVfcHJpdmF0ZV9rZXlfdGFnXCI7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkoaW5wdXQpO1xuICAgICAgICAgICAgY29uc3Qgc3RhbXAgPSBhd2FpdCB0aGlzLnN0YW1wZXIuc3RhbXAoYm9keSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICAgICAgc3RhbXA6IHN0YW1wLFxuICAgICAgICAgICAgICAgIHVybDogZnVsbFVybCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgbmV3IFByaXZhdGUgS2V5c1xuICAgICAgICAgKlxuICAgICAgICAgKiBTaWduIHRoZSBwcm92aWRlZCBgVENyZWF0ZVByaXZhdGVLZXlzQm9keWAgd2l0aCB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbiwgYW5kIHN1Ym1pdCB0aGUgcmVxdWVzdCAoUE9TVCAvcHVibGljL3YxL3N1Ym1pdC9jcmVhdGVfcHJpdmF0ZV9rZXlzKS5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIHN0YW1wQ3JlYXRlUHJpdmF0ZUtleXN9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jcmVhdGVQcml2YXRlS2V5cyA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChcIi9wdWJsaWMvdjEvc3VibWl0L2NyZWF0ZV9wcml2YXRlX2tleXNcIiwgaW5wdXQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZHVjZSBhIGBTaWduZWRSZXF1ZXN0YCBmcm9tIGBUQ3JlYXRlUHJpdmF0ZUtleXNCb2R5YCBieSB1c2luZyB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIENyZWF0ZVByaXZhdGVLZXlzfS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhbXBDcmVhdGVQcml2YXRlS2V5cyA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnVsbFVybCA9IHRoaXMuY29uZmlnLmJhc2VVcmwgKyBcIi9wdWJsaWMvdjEvc3VibWl0L2NyZWF0ZV9wcml2YXRlX2tleXNcIjtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeShpbnB1dCk7XG4gICAgICAgICAgICBjb25zdCBzdGFtcCA9IGF3YWl0IHRoaXMuc3RhbXBlci5zdGFtcChib2R5KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgICAgICBzdGFtcDogc3RhbXAsXG4gICAgICAgICAgICAgICAgdXJsOiBmdWxsVXJsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIG5ldyBTdWItT3JnYW5pemF0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIFNpZ24gdGhlIHByb3ZpZGVkIGBUQ3JlYXRlU3ViT3JnYW5pemF0aW9uQm9keWAgd2l0aCB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbiwgYW5kIHN1Ym1pdCB0aGUgcmVxdWVzdCAoUE9TVCAvcHVibGljL3YxL3N1Ym1pdC9jcmVhdGVfc3ViX29yZ2FuaXphdGlvbikuXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBhbHNvIHtAbGluayBzdGFtcENyZWF0ZVN1Yk9yZ2FuaXphdGlvbn0uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNyZWF0ZVN1Yk9yZ2FuaXphdGlvbiA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChcIi9wdWJsaWMvdjEvc3VibWl0L2NyZWF0ZV9zdWJfb3JnYW5pemF0aW9uXCIsIGlucHV0KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb2R1Y2UgYSBgU2lnbmVkUmVxdWVzdGAgZnJvbSBgVENyZWF0ZVN1Yk9yZ2FuaXphdGlvbkJvZHlgIGJ5IHVzaW5nIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgQ3JlYXRlU3ViT3JnYW5pemF0aW9ufS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhbXBDcmVhdGVTdWJPcmdhbml6YXRpb24gPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZ1bGxVcmwgPSB0aGlzLmNvbmZpZy5iYXNlVXJsICsgXCIvcHVibGljL3YxL3N1Ym1pdC9jcmVhdGVfc3ViX29yZ2FuaXphdGlvblwiO1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KGlucHV0KTtcbiAgICAgICAgICAgIGNvbnN0IHN0YW1wID0gYXdhaXQgdGhpcy5zdGFtcGVyLnN0YW1wKGJvZHkpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgICAgIHN0YW1wOiBzdGFtcCxcbiAgICAgICAgICAgICAgICB1cmw6IGZ1bGxVcmwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgdXNlciB0YWcgYW5kIGFkZCBpdCB0byB1c2Vycy5cbiAgICAgICAgICpcbiAgICAgICAgICogU2lnbiB0aGUgcHJvdmlkZWQgYFRDcmVhdGVVc2VyVGFnQm9keWAgd2l0aCB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbiwgYW5kIHN1Ym1pdCB0aGUgcmVxdWVzdCAoUE9TVCAvcHVibGljL3YxL3N1Ym1pdC9jcmVhdGVfdXNlcl90YWcpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgc3RhbXBDcmVhdGVVc2VyVGFnfS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY3JlYXRlVXNlclRhZyA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChcIi9wdWJsaWMvdjEvc3VibWl0L2NyZWF0ZV91c2VyX3RhZ1wiLCBpbnB1dCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9kdWNlIGEgYFNpZ25lZFJlcXVlc3RgIGZyb20gYFRDcmVhdGVVc2VyVGFnQm9keWAgYnkgdXNpbmcgdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBhbHNvIHtAbGluayBDcmVhdGVVc2VyVGFnfS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhbXBDcmVhdGVVc2VyVGFnID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmdWxsVXJsID0gdGhpcy5jb25maWcuYmFzZVVybCArIFwiL3B1YmxpYy92MS9zdWJtaXQvY3JlYXRlX3VzZXJfdGFnXCI7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkoaW5wdXQpO1xuICAgICAgICAgICAgY29uc3Qgc3RhbXAgPSBhd2FpdCB0aGlzLnN0YW1wZXIuc3RhbXAoYm9keSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICAgICAgc3RhbXA6IHN0YW1wLFxuICAgICAgICAgICAgICAgIHVybDogZnVsbFVybCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgVXNlcnMgaW4gYW4gZXhpc3RpbmcgT3JnYW5pemF0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIFNpZ24gdGhlIHByb3ZpZGVkIGBUQ3JlYXRlVXNlcnNCb2R5YCB3aXRoIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLCBhbmQgc3VibWl0IHRoZSByZXF1ZXN0IChQT1NUIC9wdWJsaWMvdjEvc3VibWl0L2NyZWF0ZV91c2VycykuXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBhbHNvIHtAbGluayBzdGFtcENyZWF0ZVVzZXJzfS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY3JlYXRlVXNlcnMgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoXCIvcHVibGljL3YxL3N1Ym1pdC9jcmVhdGVfdXNlcnNcIiwgaW5wdXQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZHVjZSBhIGBTaWduZWRSZXF1ZXN0YCBmcm9tIGBUQ3JlYXRlVXNlcnNCb2R5YCBieSB1c2luZyB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIENyZWF0ZVVzZXJzfS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhbXBDcmVhdGVVc2VycyA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnVsbFVybCA9IHRoaXMuY29uZmlnLmJhc2VVcmwgKyBcIi9wdWJsaWMvdjEvc3VibWl0L2NyZWF0ZV91c2Vyc1wiO1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KGlucHV0KTtcbiAgICAgICAgICAgIGNvbnN0IHN0YW1wID0gYXdhaXQgdGhpcy5zdGFtcGVyLnN0YW1wKGJvZHkpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgICAgIHN0YW1wOiBzdGFtcCxcbiAgICAgICAgICAgICAgICB1cmw6IGZ1bGxVcmwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgV2FsbGV0IGFuZCBkZXJpdmUgYWRkcmVzc2VzXG4gICAgICAgICAqXG4gICAgICAgICAqIFNpZ24gdGhlIHByb3ZpZGVkIGBUQ3JlYXRlV2FsbGV0Qm9keWAgd2l0aCB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbiwgYW5kIHN1Ym1pdCB0aGUgcmVxdWVzdCAoUE9TVCAvcHVibGljL3YxL3N1Ym1pdC9jcmVhdGVfd2FsbGV0KS5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIHN0YW1wQ3JlYXRlV2FsbGV0fS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY3JlYXRlV2FsbGV0ID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KFwiL3B1YmxpYy92MS9zdWJtaXQvY3JlYXRlX3dhbGxldFwiLCBpbnB1dCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9kdWNlIGEgYFNpZ25lZFJlcXVlc3RgIGZyb20gYFRDcmVhdGVXYWxsZXRCb2R5YCBieSB1c2luZyB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIENyZWF0ZVdhbGxldH0uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YW1wQ3JlYXRlV2FsbGV0ID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmdWxsVXJsID0gdGhpcy5jb25maWcuYmFzZVVybCArIFwiL3B1YmxpYy92MS9zdWJtaXQvY3JlYXRlX3dhbGxldFwiO1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KGlucHV0KTtcbiAgICAgICAgICAgIGNvbnN0IHN0YW1wID0gYXdhaXQgdGhpcy5zdGFtcGVyLnN0YW1wKGJvZHkpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgICAgIHN0YW1wOiBzdGFtcCxcbiAgICAgICAgICAgICAgICB1cmw6IGZ1bGxVcmwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVyaXZlIGFkZGl0aW9uYWwgYWRkcmVzc2VzIHVzaW5nIGFuIGV4aXN0aW5nIHdhbGxldFxuICAgICAgICAgKlxuICAgICAgICAgKiBTaWduIHRoZSBwcm92aWRlZCBgVENyZWF0ZVdhbGxldEFjY291bnRzQm9keWAgd2l0aCB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbiwgYW5kIHN1Ym1pdCB0aGUgcmVxdWVzdCAoUE9TVCAvcHVibGljL3YxL3N1Ym1pdC9jcmVhdGVfd2FsbGV0X2FjY291bnRzKS5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIHN0YW1wQ3JlYXRlV2FsbGV0QWNjb3VudHN9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jcmVhdGVXYWxsZXRBY2NvdW50cyA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChcIi9wdWJsaWMvdjEvc3VibWl0L2NyZWF0ZV93YWxsZXRfYWNjb3VudHNcIiwgaW5wdXQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZHVjZSBhIGBTaWduZWRSZXF1ZXN0YCBmcm9tIGBUQ3JlYXRlV2FsbGV0QWNjb3VudHNCb2R5YCBieSB1c2luZyB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIENyZWF0ZVdhbGxldEFjY291bnRzfS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhbXBDcmVhdGVXYWxsZXRBY2NvdW50cyA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnVsbFVybCA9IHRoaXMuY29uZmlnLmJhc2VVcmwgKyBcIi9wdWJsaWMvdjEvc3VibWl0L2NyZWF0ZV93YWxsZXRfYWNjb3VudHNcIjtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeShpbnB1dCk7XG4gICAgICAgICAgICBjb25zdCBzdGFtcCA9IGF3YWl0IHRoaXMuc3RhbXBlci5zdGFtcChib2R5KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgICAgICBzdGFtcDogc3RhbXAsXG4gICAgICAgICAgICAgICAgdXJsOiBmdWxsVXJsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZSBhcGkga2V5cyBmcm9tIGEgVXNlclxuICAgICAgICAgKlxuICAgICAgICAgKiBTaWduIHRoZSBwcm92aWRlZCBgVERlbGV0ZUFwaUtleXNCb2R5YCB3aXRoIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLCBhbmQgc3VibWl0IHRoZSByZXF1ZXN0IChQT1NUIC9wdWJsaWMvdjEvc3VibWl0L2RlbGV0ZV9hcGlfa2V5cykuXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBhbHNvIHtAbGluayBzdGFtcERlbGV0ZUFwaUtleXN9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kZWxldGVBcGlLZXlzID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KFwiL3B1YmxpYy92MS9zdWJtaXQvZGVsZXRlX2FwaV9rZXlzXCIsIGlucHV0KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb2R1Y2UgYSBgU2lnbmVkUmVxdWVzdGAgZnJvbSBgVERlbGV0ZUFwaUtleXNCb2R5YCBieSB1c2luZyB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIERlbGV0ZUFwaUtleXN9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFtcERlbGV0ZUFwaUtleXMgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZ1bGxVcmwgPSB0aGlzLmNvbmZpZy5iYXNlVXJsICsgXCIvcHVibGljL3YxL3N1Ym1pdC9kZWxldGVfYXBpX2tleXNcIjtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeShpbnB1dCk7XG4gICAgICAgICAgICBjb25zdCBzdGFtcCA9IGF3YWl0IHRoaXMuc3RhbXBlci5zdGFtcChib2R5KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgICAgICBzdGFtcDogc3RhbXAsXG4gICAgICAgICAgICAgICAgdXJsOiBmdWxsVXJsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZSBhdXRoZW50aWNhdG9ycyBmcm9tIGEgVXNlclxuICAgICAgICAgKlxuICAgICAgICAgKiBTaWduIHRoZSBwcm92aWRlZCBgVERlbGV0ZUF1dGhlbnRpY2F0b3JzQm9keWAgd2l0aCB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbiwgYW5kIHN1Ym1pdCB0aGUgcmVxdWVzdCAoUE9TVCAvcHVibGljL3YxL3N1Ym1pdC9kZWxldGVfYXV0aGVudGljYXRvcnMpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgc3RhbXBEZWxldGVBdXRoZW50aWNhdG9yc30uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRlbGV0ZUF1dGhlbnRpY2F0b3JzID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KFwiL3B1YmxpYy92MS9zdWJtaXQvZGVsZXRlX2F1dGhlbnRpY2F0b3JzXCIsIGlucHV0KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb2R1Y2UgYSBgU2lnbmVkUmVxdWVzdGAgZnJvbSBgVERlbGV0ZUF1dGhlbnRpY2F0b3JzQm9keWAgYnkgdXNpbmcgdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBhbHNvIHtAbGluayBEZWxldGVBdXRoZW50aWNhdG9yc30uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YW1wRGVsZXRlQXV0aGVudGljYXRvcnMgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZ1bGxVcmwgPSB0aGlzLmNvbmZpZy5iYXNlVXJsICsgXCIvcHVibGljL3YxL3N1Ym1pdC9kZWxldGVfYXV0aGVudGljYXRvcnNcIjtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeShpbnB1dCk7XG4gICAgICAgICAgICBjb25zdCBzdGFtcCA9IGF3YWl0IHRoaXMuc3RhbXBlci5zdGFtcChib2R5KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgICAgICBzdGFtcDogc3RhbXAsXG4gICAgICAgICAgICAgICAgdXJsOiBmdWxsVXJsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlbGV0ZSBhbiBleGlzdGluZyBJbnZpdGF0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIFNpZ24gdGhlIHByb3ZpZGVkIGBURGVsZXRlSW52aXRhdGlvbkJvZHlgIHdpdGggdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24sIGFuZCBzdWJtaXQgdGhlIHJlcXVlc3QgKFBPU1QgL3B1YmxpYy92MS9zdWJtaXQvZGVsZXRlX2ludml0YXRpb24pLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgc3RhbXBEZWxldGVJbnZpdGF0aW9ufS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGVsZXRlSW52aXRhdGlvbiA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChcIi9wdWJsaWMvdjEvc3VibWl0L2RlbGV0ZV9pbnZpdGF0aW9uXCIsIGlucHV0KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb2R1Y2UgYSBgU2lnbmVkUmVxdWVzdGAgZnJvbSBgVERlbGV0ZUludml0YXRpb25Cb2R5YCBieSB1c2luZyB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIERlbGV0ZUludml0YXRpb259LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFtcERlbGV0ZUludml0YXRpb24gPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZ1bGxVcmwgPSB0aGlzLmNvbmZpZy5iYXNlVXJsICsgXCIvcHVibGljL3YxL3N1Ym1pdC9kZWxldGVfaW52aXRhdGlvblwiO1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KGlucHV0KTtcbiAgICAgICAgICAgIGNvbnN0IHN0YW1wID0gYXdhaXQgdGhpcy5zdGFtcGVyLnN0YW1wKGJvZHkpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgICAgIHN0YW1wOiBzdGFtcCxcbiAgICAgICAgICAgICAgICB1cmw6IGZ1bGxVcmwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVsZXRlIGFuIGV4aXN0aW5nIFBvbGljeVxuICAgICAgICAgKlxuICAgICAgICAgKiBTaWduIHRoZSBwcm92aWRlZCBgVERlbGV0ZVBvbGljeUJvZHlgIHdpdGggdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24sIGFuZCBzdWJtaXQgdGhlIHJlcXVlc3QgKFBPU1QgL3B1YmxpYy92MS9zdWJtaXQvZGVsZXRlX3BvbGljeSkuXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBhbHNvIHtAbGluayBzdGFtcERlbGV0ZVBvbGljeX0uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRlbGV0ZVBvbGljeSA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChcIi9wdWJsaWMvdjEvc3VibWl0L2RlbGV0ZV9wb2xpY3lcIiwgaW5wdXQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZHVjZSBhIGBTaWduZWRSZXF1ZXN0YCBmcm9tIGBURGVsZXRlUG9saWN5Qm9keWAgYnkgdXNpbmcgdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBhbHNvIHtAbGluayBEZWxldGVQb2xpY3l9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFtcERlbGV0ZVBvbGljeSA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnVsbFVybCA9IHRoaXMuY29uZmlnLmJhc2VVcmwgKyBcIi9wdWJsaWMvdjEvc3VibWl0L2RlbGV0ZV9wb2xpY3lcIjtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeShpbnB1dCk7XG4gICAgICAgICAgICBjb25zdCBzdGFtcCA9IGF3YWl0IHRoaXMuc3RhbXBlci5zdGFtcChib2R5KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgICAgICBzdGFtcDogc3RhbXAsXG4gICAgICAgICAgICAgICAgdXJsOiBmdWxsVXJsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlbGV0ZSBQcml2YXRlIEtleSBUYWdzIHdpdGhpbiBhbiBPcmdhbml6YXRpb25cbiAgICAgICAgICpcbiAgICAgICAgICogU2lnbiB0aGUgcHJvdmlkZWQgYFREZWxldGVQcml2YXRlS2V5VGFnc0JvZHlgIHdpdGggdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24sIGFuZCBzdWJtaXQgdGhlIHJlcXVlc3QgKFBPU1QgL3B1YmxpYy92MS9zdWJtaXQvZGVsZXRlX3ByaXZhdGVfa2V5X3RhZ3MpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgc3RhbXBEZWxldGVQcml2YXRlS2V5VGFnc30uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRlbGV0ZVByaXZhdGVLZXlUYWdzID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KFwiL3B1YmxpYy92MS9zdWJtaXQvZGVsZXRlX3ByaXZhdGVfa2V5X3RhZ3NcIiwgaW5wdXQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZHVjZSBhIGBTaWduZWRSZXF1ZXN0YCBmcm9tIGBURGVsZXRlUHJpdmF0ZUtleVRhZ3NCb2R5YCBieSB1c2luZyB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIERlbGV0ZVByaXZhdGVLZXlUYWdzfS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhbXBEZWxldGVQcml2YXRlS2V5VGFncyA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnVsbFVybCA9IHRoaXMuY29uZmlnLmJhc2VVcmwgKyBcIi9wdWJsaWMvdjEvc3VibWl0L2RlbGV0ZV9wcml2YXRlX2tleV90YWdzXCI7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkoaW5wdXQpO1xuICAgICAgICAgICAgY29uc3Qgc3RhbXAgPSBhd2FpdCB0aGlzLnN0YW1wZXIuc3RhbXAoYm9keSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICAgICAgc3RhbXA6IHN0YW1wLFxuICAgICAgICAgICAgICAgIHVybDogZnVsbFVybCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWxldGUgVXNlciBUYWdzIHdpdGhpbiBhbiBPcmdhbml6YXRpb25cbiAgICAgICAgICpcbiAgICAgICAgICogU2lnbiB0aGUgcHJvdmlkZWQgYFREZWxldGVVc2VyVGFnc0JvZHlgIHdpdGggdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24sIGFuZCBzdWJtaXQgdGhlIHJlcXVlc3QgKFBPU1QgL3B1YmxpYy92MS9zdWJtaXQvZGVsZXRlX3VzZXJfdGFncykuXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBhbHNvIHtAbGluayBzdGFtcERlbGV0ZVVzZXJUYWdzfS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGVsZXRlVXNlclRhZ3MgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoXCIvcHVibGljL3YxL3N1Ym1pdC9kZWxldGVfdXNlcl90YWdzXCIsIGlucHV0KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb2R1Y2UgYSBgU2lnbmVkUmVxdWVzdGAgZnJvbSBgVERlbGV0ZVVzZXJUYWdzQm9keWAgYnkgdXNpbmcgdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBhbHNvIHtAbGluayBEZWxldGVVc2VyVGFnc30uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YW1wRGVsZXRlVXNlclRhZ3MgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZ1bGxVcmwgPSB0aGlzLmNvbmZpZy5iYXNlVXJsICsgXCIvcHVibGljL3YxL3N1Ym1pdC9kZWxldGVfdXNlcl90YWdzXCI7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkoaW5wdXQpO1xuICAgICAgICAgICAgY29uc3Qgc3RhbXAgPSBhd2FpdCB0aGlzLnN0YW1wZXIuc3RhbXAoYm9keSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICAgICAgc3RhbXA6IHN0YW1wLFxuICAgICAgICAgICAgICAgIHVybDogZnVsbFVybCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWxldGUgVXNlcnMgd2l0aGluIGFuIE9yZ2FuaXphdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBTaWduIHRoZSBwcm92aWRlZCBgVERlbGV0ZVVzZXJzQm9keWAgd2l0aCB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbiwgYW5kIHN1Ym1pdCB0aGUgcmVxdWVzdCAoUE9TVCAvcHVibGljL3YxL3N1Ym1pdC9kZWxldGVfdXNlcnMpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgc3RhbXBEZWxldGVVc2Vyc30uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRlbGV0ZVVzZXJzID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KFwiL3B1YmxpYy92MS9zdWJtaXQvZGVsZXRlX3VzZXJzXCIsIGlucHV0KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb2R1Y2UgYSBgU2lnbmVkUmVxdWVzdGAgZnJvbSBgVERlbGV0ZVVzZXJzQm9keWAgYnkgdXNpbmcgdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBhbHNvIHtAbGluayBEZWxldGVVc2Vyc30uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YW1wRGVsZXRlVXNlcnMgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZ1bGxVcmwgPSB0aGlzLmNvbmZpZy5iYXNlVXJsICsgXCIvcHVibGljL3YxL3N1Ym1pdC9kZWxldGVfdXNlcnNcIjtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeShpbnB1dCk7XG4gICAgICAgICAgICBjb25zdCBzdGFtcCA9IGF3YWl0IHRoaXMuc3RhbXBlci5zdGFtcChib2R5KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgICAgICBzdGFtcDogc3RhbXAsXG4gICAgICAgICAgICAgICAgdXJsOiBmdWxsVXJsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEF1dGhlbnRpY2F0ZSBhIHVzZXIgdmlhIEVtYWlsXG4gICAgICAgICAqXG4gICAgICAgICAqIFNpZ24gdGhlIHByb3ZpZGVkIGBURW1haWxBdXRoQm9keWAgd2l0aCB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbiwgYW5kIHN1Ym1pdCB0aGUgcmVxdWVzdCAoUE9TVCAvcHVibGljL3YxL3N1Ym1pdC9lbWFpbF9hdXRoKS5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIHN0YW1wRW1haWxBdXRofS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZW1haWxBdXRoID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KFwiL3B1YmxpYy92MS9zdWJtaXQvZW1haWxfYXV0aFwiLCBpbnB1dCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9kdWNlIGEgYFNpZ25lZFJlcXVlc3RgIGZyb20gYFRFbWFpbEF1dGhCb2R5YCBieSB1c2luZyB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIEVtYWlsQXV0aH0uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YW1wRW1haWxBdXRoID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmdWxsVXJsID0gdGhpcy5jb25maWcuYmFzZVVybCArIFwiL3B1YmxpYy92MS9zdWJtaXQvZW1haWxfYXV0aFwiO1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KGlucHV0KTtcbiAgICAgICAgICAgIGNvbnN0IHN0YW1wID0gYXdhaXQgdGhpcy5zdGFtcGVyLnN0YW1wKGJvZHkpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgICAgIHN0YW1wOiBzdGFtcCxcbiAgICAgICAgICAgICAgICB1cmw6IGZ1bGxVcmwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRXhwb3J0cyBhIFByaXZhdGUgS2V5XG4gICAgICAgICAqXG4gICAgICAgICAqIFNpZ24gdGhlIHByb3ZpZGVkIGBURXhwb3J0UHJpdmF0ZUtleUJvZHlgIHdpdGggdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24sIGFuZCBzdWJtaXQgdGhlIHJlcXVlc3QgKFBPU1QgL3B1YmxpYy92MS9zdWJtaXQvZXhwb3J0X3ByaXZhdGVfa2V5KS5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIHN0YW1wRXhwb3J0UHJpdmF0ZUtleX0uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmV4cG9ydFByaXZhdGVLZXkgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoXCIvcHVibGljL3YxL3N1Ym1pdC9leHBvcnRfcHJpdmF0ZV9rZXlcIiwgaW5wdXQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZHVjZSBhIGBTaWduZWRSZXF1ZXN0YCBmcm9tIGBURXhwb3J0UHJpdmF0ZUtleUJvZHlgIGJ5IHVzaW5nIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgRXhwb3J0UHJpdmF0ZUtleX0uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YW1wRXhwb3J0UHJpdmF0ZUtleSA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnVsbFVybCA9IHRoaXMuY29uZmlnLmJhc2VVcmwgKyBcIi9wdWJsaWMvdjEvc3VibWl0L2V4cG9ydF9wcml2YXRlX2tleVwiO1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KGlucHV0KTtcbiAgICAgICAgICAgIGNvbnN0IHN0YW1wID0gYXdhaXQgdGhpcy5zdGFtcGVyLnN0YW1wKGJvZHkpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgICAgIHN0YW1wOiBzdGFtcCxcbiAgICAgICAgICAgICAgICB1cmw6IGZ1bGxVcmwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRXhwb3J0cyBhIFdhbGxldFxuICAgICAgICAgKlxuICAgICAgICAgKiBTaWduIHRoZSBwcm92aWRlZCBgVEV4cG9ydFdhbGxldEJvZHlgIHdpdGggdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24sIGFuZCBzdWJtaXQgdGhlIHJlcXVlc3QgKFBPU1QgL3B1YmxpYy92MS9zdWJtaXQvZXhwb3J0X3dhbGxldCkuXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBhbHNvIHtAbGluayBzdGFtcEV4cG9ydFdhbGxldH0uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmV4cG9ydFdhbGxldCA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChcIi9wdWJsaWMvdjEvc3VibWl0L2V4cG9ydF93YWxsZXRcIiwgaW5wdXQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZHVjZSBhIGBTaWduZWRSZXF1ZXN0YCBmcm9tIGBURXhwb3J0V2FsbGV0Qm9keWAgYnkgdXNpbmcgdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBhbHNvIHtAbGluayBFeHBvcnRXYWxsZXR9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFtcEV4cG9ydFdhbGxldCA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnVsbFVybCA9IHRoaXMuY29uZmlnLmJhc2VVcmwgKyBcIi9wdWJsaWMvdjEvc3VibWl0L2V4cG9ydF93YWxsZXRcIjtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeShpbnB1dCk7XG4gICAgICAgICAgICBjb25zdCBzdGFtcCA9IGF3YWl0IHRoaXMuc3RhbXBlci5zdGFtcChib2R5KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgICAgICBzdGFtcDogc3RhbXAsXG4gICAgICAgICAgICAgICAgdXJsOiBmdWxsVXJsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV4cG9ydHMgYSBXYWxsZXQgQWNjb3VudFxuICAgICAgICAgKlxuICAgICAgICAgKiBTaWduIHRoZSBwcm92aWRlZCBgVEV4cG9ydFdhbGxldEFjY291bnRCb2R5YCB3aXRoIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLCBhbmQgc3VibWl0IHRoZSByZXF1ZXN0IChQT1NUIC9wdWJsaWMvdjEvc3VibWl0L2V4cG9ydF93YWxsZXRfYWNjb3VudCkuXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBhbHNvIHtAbGluayBzdGFtcEV4cG9ydFdhbGxldEFjY291bnR9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5leHBvcnRXYWxsZXRBY2NvdW50ID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KFwiL3B1YmxpYy92MS9zdWJtaXQvZXhwb3J0X3dhbGxldF9hY2NvdW50XCIsIGlucHV0KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb2R1Y2UgYSBgU2lnbmVkUmVxdWVzdGAgZnJvbSBgVEV4cG9ydFdhbGxldEFjY291bnRCb2R5YCBieSB1c2luZyB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIEV4cG9ydFdhbGxldEFjY291bnR9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFtcEV4cG9ydFdhbGxldEFjY291bnQgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZ1bGxVcmwgPSB0aGlzLmNvbmZpZy5iYXNlVXJsICsgXCIvcHVibGljL3YxL3N1Ym1pdC9leHBvcnRfd2FsbGV0X2FjY291bnRcIjtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeShpbnB1dCk7XG4gICAgICAgICAgICBjb25zdCBzdGFtcCA9IGF3YWl0IHRoaXMuc3RhbXBlci5zdGFtcChib2R5KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgICAgICBzdGFtcDogc3RhbXAsXG4gICAgICAgICAgICAgICAgdXJsOiBmdWxsVXJsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEltcG9ydHMgYSBwcml2YXRlIGtleVxuICAgICAgICAgKlxuICAgICAgICAgKiBTaWduIHRoZSBwcm92aWRlZCBgVEltcG9ydFByaXZhdGVLZXlCb2R5YCB3aXRoIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLCBhbmQgc3VibWl0IHRoZSByZXF1ZXN0IChQT1NUIC9wdWJsaWMvdjEvc3VibWl0L2ltcG9ydF9wcml2YXRlX2tleSkuXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBhbHNvIHtAbGluayBzdGFtcEltcG9ydFByaXZhdGVLZXl9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbXBvcnRQcml2YXRlS2V5ID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KFwiL3B1YmxpYy92MS9zdWJtaXQvaW1wb3J0X3ByaXZhdGVfa2V5XCIsIGlucHV0KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb2R1Y2UgYSBgU2lnbmVkUmVxdWVzdGAgZnJvbSBgVEltcG9ydFByaXZhdGVLZXlCb2R5YCBieSB1c2luZyB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIEltcG9ydFByaXZhdGVLZXl9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFtcEltcG9ydFByaXZhdGVLZXkgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZ1bGxVcmwgPSB0aGlzLmNvbmZpZy5iYXNlVXJsICsgXCIvcHVibGljL3YxL3N1Ym1pdC9pbXBvcnRfcHJpdmF0ZV9rZXlcIjtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeShpbnB1dCk7XG4gICAgICAgICAgICBjb25zdCBzdGFtcCA9IGF3YWl0IHRoaXMuc3RhbXBlci5zdGFtcChib2R5KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgICAgICBzdGFtcDogc3RhbXAsXG4gICAgICAgICAgICAgICAgdXJsOiBmdWxsVXJsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEltcG9ydHMgYSB3YWxsZXRcbiAgICAgICAgICpcbiAgICAgICAgICogU2lnbiB0aGUgcHJvdmlkZWQgYFRJbXBvcnRXYWxsZXRCb2R5YCB3aXRoIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLCBhbmQgc3VibWl0IHRoZSByZXF1ZXN0IChQT1NUIC9wdWJsaWMvdjEvc3VibWl0L2ltcG9ydF93YWxsZXQpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgc3RhbXBJbXBvcnRXYWxsZXR9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbXBvcnRXYWxsZXQgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoXCIvcHVibGljL3YxL3N1Ym1pdC9pbXBvcnRfd2FsbGV0XCIsIGlucHV0KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb2R1Y2UgYSBgU2lnbmVkUmVxdWVzdGAgZnJvbSBgVEltcG9ydFdhbGxldEJvZHlgIGJ5IHVzaW5nIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgSW1wb3J0V2FsbGV0fS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhbXBJbXBvcnRXYWxsZXQgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZ1bGxVcmwgPSB0aGlzLmNvbmZpZy5iYXNlVXJsICsgXCIvcHVibGljL3YxL3N1Ym1pdC9pbXBvcnRfd2FsbGV0XCI7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkoaW5wdXQpO1xuICAgICAgICAgICAgY29uc3Qgc3RhbXAgPSBhd2FpdCB0aGlzLnN0YW1wZXIuc3RhbXAoYm9keSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICAgICAgc3RhbXA6IHN0YW1wLFxuICAgICAgICAgICAgICAgIHVybDogZnVsbFVybCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ldyBwcml2YXRlIGtleSBpbXBvcnRcbiAgICAgICAgICpcbiAgICAgICAgICogU2lnbiB0aGUgcHJvdmlkZWQgYFRJbml0SW1wb3J0UHJpdmF0ZUtleUJvZHlgIHdpdGggdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24sIGFuZCBzdWJtaXQgdGhlIHJlcXVlc3QgKFBPU1QgL3B1YmxpYy92MS9zdWJtaXQvaW5pdF9pbXBvcnRfcHJpdmF0ZV9rZXkpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgc3RhbXBJbml0SW1wb3J0UHJpdmF0ZUtleX0uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmluaXRJbXBvcnRQcml2YXRlS2V5ID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KFwiL3B1YmxpYy92MS9zdWJtaXQvaW5pdF9pbXBvcnRfcHJpdmF0ZV9rZXlcIiwgaW5wdXQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZHVjZSBhIGBTaWduZWRSZXF1ZXN0YCBmcm9tIGBUSW5pdEltcG9ydFByaXZhdGVLZXlCb2R5YCBieSB1c2luZyB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIEluaXRJbXBvcnRQcml2YXRlS2V5fS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhbXBJbml0SW1wb3J0UHJpdmF0ZUtleSA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnVsbFVybCA9IHRoaXMuY29uZmlnLmJhc2VVcmwgKyBcIi9wdWJsaWMvdjEvc3VibWl0L2luaXRfaW1wb3J0X3ByaXZhdGVfa2V5XCI7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkoaW5wdXQpO1xuICAgICAgICAgICAgY29uc3Qgc3RhbXAgPSBhd2FpdCB0aGlzLnN0YW1wZXIuc3RhbXAoYm9keSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICAgICAgc3RhbXA6IHN0YW1wLFxuICAgICAgICAgICAgICAgIHVybDogZnVsbFVybCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ldyB3YWxsZXQgaW1wb3J0XG4gICAgICAgICAqXG4gICAgICAgICAqIFNpZ24gdGhlIHByb3ZpZGVkIGBUSW5pdEltcG9ydFdhbGxldEJvZHlgIHdpdGggdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24sIGFuZCBzdWJtaXQgdGhlIHJlcXVlc3QgKFBPU1QgL3B1YmxpYy92MS9zdWJtaXQvaW5pdF9pbXBvcnRfd2FsbGV0KS5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIHN0YW1wSW5pdEltcG9ydFdhbGxldH0uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmluaXRJbXBvcnRXYWxsZXQgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoXCIvcHVibGljL3YxL3N1Ym1pdC9pbml0X2ltcG9ydF93YWxsZXRcIiwgaW5wdXQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZHVjZSBhIGBTaWduZWRSZXF1ZXN0YCBmcm9tIGBUSW5pdEltcG9ydFdhbGxldEJvZHlgIGJ5IHVzaW5nIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgSW5pdEltcG9ydFdhbGxldH0uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YW1wSW5pdEltcG9ydFdhbGxldCA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnVsbFVybCA9IHRoaXMuY29uZmlnLmJhc2VVcmwgKyBcIi9wdWJsaWMvdjEvc3VibWl0L2luaXRfaW1wb3J0X3dhbGxldFwiO1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KGlucHV0KTtcbiAgICAgICAgICAgIGNvbnN0IHN0YW1wID0gYXdhaXQgdGhpcy5zdGFtcGVyLnN0YW1wKGJvZHkpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgICAgIHN0YW1wOiBzdGFtcCxcbiAgICAgICAgICAgICAgICB1cmw6IGZ1bGxVcmwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXcgZW1haWwgcmVjb3ZlcnlcbiAgICAgICAgICpcbiAgICAgICAgICogU2lnbiB0aGUgcHJvdmlkZWQgYFRJbml0VXNlckVtYWlsUmVjb3ZlcnlCb2R5YCB3aXRoIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLCBhbmQgc3VibWl0IHRoZSByZXF1ZXN0IChQT1NUIC9wdWJsaWMvdjEvc3VibWl0L2luaXRfdXNlcl9lbWFpbF9yZWNvdmVyeSkuXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBhbHNvIHtAbGluayBzdGFtcEluaXRVc2VyRW1haWxSZWNvdmVyeX0uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmluaXRVc2VyRW1haWxSZWNvdmVyeSA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChcIi9wdWJsaWMvdjEvc3VibWl0L2luaXRfdXNlcl9lbWFpbF9yZWNvdmVyeVwiLCBpbnB1dCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9kdWNlIGEgYFNpZ25lZFJlcXVlc3RgIGZyb20gYFRJbml0VXNlckVtYWlsUmVjb3ZlcnlCb2R5YCBieSB1c2luZyB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIEluaXRVc2VyRW1haWxSZWNvdmVyeX0uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YW1wSW5pdFVzZXJFbWFpbFJlY292ZXJ5ID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmdWxsVXJsID0gdGhpcy5jb25maWcuYmFzZVVybCArIFwiL3B1YmxpYy92MS9zdWJtaXQvaW5pdF91c2VyX2VtYWlsX3JlY292ZXJ5XCI7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkoaW5wdXQpO1xuICAgICAgICAgICAgY29uc3Qgc3RhbXAgPSBhd2FpdCB0aGlzLnN0YW1wZXIuc3RhbXAoYm9keSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICAgICAgc3RhbXA6IHN0YW1wLFxuICAgICAgICAgICAgICAgIHVybDogZnVsbFVybCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21wbGV0ZXMgdGhlIHByb2Nlc3Mgb2YgcmVjb3ZlcmluZyBhIHVzZXIgYnkgYWRkaW5nIGFuIGF1dGhlbnRpY2F0b3JcbiAgICAgICAgICpcbiAgICAgICAgICogU2lnbiB0aGUgcHJvdmlkZWQgYFRSZWNvdmVyVXNlckJvZHlgIHdpdGggdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24sIGFuZCBzdWJtaXQgdGhlIHJlcXVlc3QgKFBPU1QgL3B1YmxpYy92MS9zdWJtaXQvcmVjb3Zlcl91c2VyKS5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIHN0YW1wUmVjb3ZlclVzZXJ9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZWNvdmVyVXNlciA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChcIi9wdWJsaWMvdjEvc3VibWl0L3JlY292ZXJfdXNlclwiLCBpbnB1dCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9kdWNlIGEgYFNpZ25lZFJlcXVlc3RgIGZyb20gYFRSZWNvdmVyVXNlckJvZHlgIGJ5IHVzaW5nIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgUmVjb3ZlclVzZXJ9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFtcFJlY292ZXJVc2VyID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmdWxsVXJsID0gdGhpcy5jb25maWcuYmFzZVVybCArIFwiL3B1YmxpYy92MS9zdWJtaXQvcmVjb3Zlcl91c2VyXCI7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkoaW5wdXQpO1xuICAgICAgICAgICAgY29uc3Qgc3RhbXAgPSBhd2FpdCB0aGlzLnN0YW1wZXIuc3RhbXAoYm9keSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICAgICAgc3RhbXA6IHN0YW1wLFxuICAgICAgICAgICAgICAgIHVybDogZnVsbFVybCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWplY3QgYW4gQWN0aXZpdHlcbiAgICAgICAgICpcbiAgICAgICAgICogU2lnbiB0aGUgcHJvdmlkZWQgYFRSZWplY3RBY3Rpdml0eUJvZHlgIHdpdGggdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24sIGFuZCBzdWJtaXQgdGhlIHJlcXVlc3QgKFBPU1QgL3B1YmxpYy92MS9zdWJtaXQvcmVqZWN0X2FjdGl2aXR5KS5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIHN0YW1wUmVqZWN0QWN0aXZpdHl9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZWplY3RBY3Rpdml0eSA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChcIi9wdWJsaWMvdjEvc3VibWl0L3JlamVjdF9hY3Rpdml0eVwiLCBpbnB1dCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9kdWNlIGEgYFNpZ25lZFJlcXVlc3RgIGZyb20gYFRSZWplY3RBY3Rpdml0eUJvZHlgIGJ5IHVzaW5nIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgUmVqZWN0QWN0aXZpdHl9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFtcFJlamVjdEFjdGl2aXR5ID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmdWxsVXJsID0gdGhpcy5jb25maWcuYmFzZVVybCArIFwiL3B1YmxpYy92MS9zdWJtaXQvcmVqZWN0X2FjdGl2aXR5XCI7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkoaW5wdXQpO1xuICAgICAgICAgICAgY29uc3Qgc3RhbXAgPSBhd2FpdCB0aGlzLnN0YW1wZXIuc3RhbXAoYm9keSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICAgICAgc3RhbXA6IHN0YW1wLFxuICAgICAgICAgICAgICAgIHVybDogZnVsbFVybCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIGFuIG9yZ2FuaXphdGlvbiBmZWF0dXJlXG4gICAgICAgICAqXG4gICAgICAgICAqIFNpZ24gdGhlIHByb3ZpZGVkIGBUUmVtb3ZlT3JnYW5pemF0aW9uRmVhdHVyZUJvZHlgIHdpdGggdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24sIGFuZCBzdWJtaXQgdGhlIHJlcXVlc3QgKFBPU1QgL3B1YmxpYy92MS9zdWJtaXQvcmVtb3ZlX29yZ2FuaXphdGlvbl9mZWF0dXJlKS5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIHN0YW1wUmVtb3ZlT3JnYW5pemF0aW9uRmVhdHVyZX0uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlbW92ZU9yZ2FuaXphdGlvbkZlYXR1cmUgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoXCIvcHVibGljL3YxL3N1Ym1pdC9yZW1vdmVfb3JnYW5pemF0aW9uX2ZlYXR1cmVcIiwgaW5wdXQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZHVjZSBhIGBTaWduZWRSZXF1ZXN0YCBmcm9tIGBUUmVtb3ZlT3JnYW5pemF0aW9uRmVhdHVyZUJvZHlgIGJ5IHVzaW5nIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgUmVtb3ZlT3JnYW5pemF0aW9uRmVhdHVyZX0uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YW1wUmVtb3ZlT3JnYW5pemF0aW9uRmVhdHVyZSA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnVsbFVybCA9IHRoaXMuY29uZmlnLmJhc2VVcmwgKyBcIi9wdWJsaWMvdjEvc3VibWl0L3JlbW92ZV9vcmdhbml6YXRpb25fZmVhdHVyZVwiO1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KGlucHV0KTtcbiAgICAgICAgICAgIGNvbnN0IHN0YW1wID0gYXdhaXQgdGhpcy5zdGFtcGVyLnN0YW1wKGJvZHkpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgICAgIHN0YW1wOiBzdGFtcCxcbiAgICAgICAgICAgICAgICB1cmw6IGZ1bGxVcmwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyBhbiBvcmdhbml6YXRpb24gZmVhdHVyZVxuICAgICAgICAgKlxuICAgICAgICAgKiBTaWduIHRoZSBwcm92aWRlZCBgVFNldE9yZ2FuaXphdGlvbkZlYXR1cmVCb2R5YCB3aXRoIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLCBhbmQgc3VibWl0IHRoZSByZXF1ZXN0IChQT1NUIC9wdWJsaWMvdjEvc3VibWl0L3NldF9vcmdhbml6YXRpb25fZmVhdHVyZSkuXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBhbHNvIHtAbGluayBzdGFtcFNldE9yZ2FuaXphdGlvbkZlYXR1cmV9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZXRPcmdhbml6YXRpb25GZWF0dXJlID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KFwiL3B1YmxpYy92MS9zdWJtaXQvc2V0X29yZ2FuaXphdGlvbl9mZWF0dXJlXCIsIGlucHV0KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb2R1Y2UgYSBgU2lnbmVkUmVxdWVzdGAgZnJvbSBgVFNldE9yZ2FuaXphdGlvbkZlYXR1cmVCb2R5YCBieSB1c2luZyB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIFNldE9yZ2FuaXphdGlvbkZlYXR1cmV9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFtcFNldE9yZ2FuaXphdGlvbkZlYXR1cmUgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZ1bGxVcmwgPSB0aGlzLmNvbmZpZy5iYXNlVXJsICsgXCIvcHVibGljL3YxL3N1Ym1pdC9zZXRfb3JnYW5pemF0aW9uX2ZlYXR1cmVcIjtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeShpbnB1dCk7XG4gICAgICAgICAgICBjb25zdCBzdGFtcCA9IGF3YWl0IHRoaXMuc3RhbXBlci5zdGFtcChib2R5KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgICAgICBzdGFtcDogc3RhbXAsXG4gICAgICAgICAgICAgICAgdXJsOiBmdWxsVXJsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNpZ24gYSByYXcgcGF5bG9hZFxuICAgICAgICAgKlxuICAgICAgICAgKiBTaWduIHRoZSBwcm92aWRlZCBgVFNpZ25SYXdQYXlsb2FkQm9keWAgd2l0aCB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbiwgYW5kIHN1Ym1pdCB0aGUgcmVxdWVzdCAoUE9TVCAvcHVibGljL3YxL3N1Ym1pdC9zaWduX3Jhd19wYXlsb2FkKS5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIHN0YW1wU2lnblJhd1BheWxvYWR9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zaWduUmF3UGF5bG9hZCA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChcIi9wdWJsaWMvdjEvc3VibWl0L3NpZ25fcmF3X3BheWxvYWRcIiwgaW5wdXQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZHVjZSBhIGBTaWduZWRSZXF1ZXN0YCBmcm9tIGBUU2lnblJhd1BheWxvYWRCb2R5YCBieSB1c2luZyB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIFNpZ25SYXdQYXlsb2FkfS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhbXBTaWduUmF3UGF5bG9hZCA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnVsbFVybCA9IHRoaXMuY29uZmlnLmJhc2VVcmwgKyBcIi9wdWJsaWMvdjEvc3VibWl0L3NpZ25fcmF3X3BheWxvYWRcIjtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeShpbnB1dCk7XG4gICAgICAgICAgICBjb25zdCBzdGFtcCA9IGF3YWl0IHRoaXMuc3RhbXBlci5zdGFtcChib2R5KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgICAgICBzdGFtcDogc3RhbXAsXG4gICAgICAgICAgICAgICAgdXJsOiBmdWxsVXJsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNpZ24gbXVsdGlwbGUgcmF3IHBheWxvYWRzIHdpdGggdGhlIHNhbWUgc2lnbmluZyBwYXJhbWV0ZXJzXG4gICAgICAgICAqXG4gICAgICAgICAqIFNpZ24gdGhlIHByb3ZpZGVkIGBUU2lnblJhd1BheWxvYWRzQm9keWAgd2l0aCB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbiwgYW5kIHN1Ym1pdCB0aGUgcmVxdWVzdCAoUE9TVCAvcHVibGljL3YxL3N1Ym1pdC9zaWduX3Jhd19wYXlsb2FkcykuXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBhbHNvIHtAbGluayBzdGFtcFNpZ25SYXdQYXlsb2Fkc30uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNpZ25SYXdQYXlsb2FkcyA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChcIi9wdWJsaWMvdjEvc3VibWl0L3NpZ25fcmF3X3BheWxvYWRzXCIsIGlucHV0KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb2R1Y2UgYSBgU2lnbmVkUmVxdWVzdGAgZnJvbSBgVFNpZ25SYXdQYXlsb2Fkc0JvZHlgIGJ5IHVzaW5nIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgU2lnblJhd1BheWxvYWRzfS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhbXBTaWduUmF3UGF5bG9hZHMgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZ1bGxVcmwgPSB0aGlzLmNvbmZpZy5iYXNlVXJsICsgXCIvcHVibGljL3YxL3N1Ym1pdC9zaWduX3Jhd19wYXlsb2Fkc1wiO1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KGlucHV0KTtcbiAgICAgICAgICAgIGNvbnN0IHN0YW1wID0gYXdhaXQgdGhpcy5zdGFtcGVyLnN0YW1wKGJvZHkpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgICAgIHN0YW1wOiBzdGFtcCxcbiAgICAgICAgICAgICAgICB1cmw6IGZ1bGxVcmwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2lnbiBhIHRyYW5zYWN0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIFNpZ24gdGhlIHByb3ZpZGVkIGBUU2lnblRyYW5zYWN0aW9uQm9keWAgd2l0aCB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbiwgYW5kIHN1Ym1pdCB0aGUgcmVxdWVzdCAoUE9TVCAvcHVibGljL3YxL3N1Ym1pdC9zaWduX3RyYW5zYWN0aW9uKS5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIHN0YW1wU2lnblRyYW5zYWN0aW9ufS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2lnblRyYW5zYWN0aW9uID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KFwiL3B1YmxpYy92MS9zdWJtaXQvc2lnbl90cmFuc2FjdGlvblwiLCBpbnB1dCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9kdWNlIGEgYFNpZ25lZFJlcXVlc3RgIGZyb20gYFRTaWduVHJhbnNhY3Rpb25Cb2R5YCBieSB1c2luZyB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIFNpZ25UcmFuc2FjdGlvbn0uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YW1wU2lnblRyYW5zYWN0aW9uID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmdWxsVXJsID0gdGhpcy5jb25maWcuYmFzZVVybCArIFwiL3B1YmxpYy92MS9zdWJtaXQvc2lnbl90cmFuc2FjdGlvblwiO1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KGlucHV0KTtcbiAgICAgICAgICAgIGNvbnN0IHN0YW1wID0gYXdhaXQgdGhpcy5zdGFtcGVyLnN0YW1wKGJvZHkpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgICAgIHN0YW1wOiBzdGFtcCxcbiAgICAgICAgICAgICAgICB1cmw6IGZ1bGxVcmwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlIGFuIGV4aXN0aW5nIFBvbGljeVxuICAgICAgICAgKlxuICAgICAgICAgKiBTaWduIHRoZSBwcm92aWRlZCBgVFVwZGF0ZVBvbGljeUJvZHlgIHdpdGggdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24sIGFuZCBzdWJtaXQgdGhlIHJlcXVlc3QgKFBPU1QgL3B1YmxpYy92MS9zdWJtaXQvdXBkYXRlX3BvbGljeSkuXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBhbHNvIHtAbGluayBzdGFtcFVwZGF0ZVBvbGljeX0uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVwZGF0ZVBvbGljeSA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChcIi9wdWJsaWMvdjEvc3VibWl0L3VwZGF0ZV9wb2xpY3lcIiwgaW5wdXQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZHVjZSBhIGBTaWduZWRSZXF1ZXN0YCBmcm9tIGBUVXBkYXRlUG9saWN5Qm9keWAgYnkgdXNpbmcgdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBhbHNvIHtAbGluayBVcGRhdGVQb2xpY3l9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFtcFVwZGF0ZVBvbGljeSA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnVsbFVybCA9IHRoaXMuY29uZmlnLmJhc2VVcmwgKyBcIi9wdWJsaWMvdjEvc3VibWl0L3VwZGF0ZV9wb2xpY3lcIjtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeShpbnB1dCk7XG4gICAgICAgICAgICBjb25zdCBzdGFtcCA9IGF3YWl0IHRoaXMuc3RhbXBlci5zdGFtcChib2R5KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgICAgICBzdGFtcDogc3RhbXAsXG4gICAgICAgICAgICAgICAgdXJsOiBmdWxsVXJsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9yIGFzc29jaWF0ZWQgcHJpdmF0ZSBrZXlzLiBOb3RlIHRoYXQgdGhpcyBhY3Rpdml0eSBpcyBhdG9taWM6IGFsbCBvZiB0aGUgdXBkYXRlcyB3aWxsIHN1Y2NlZWQgYXQgb25jZSwgb3IgYWxsIG9mIHRoZW0gd2lsbCBmYWlsLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTaWduIHRoZSBwcm92aWRlZCBgVFVwZGF0ZVByaXZhdGVLZXlUYWdCb2R5YCB3aXRoIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLCBhbmQgc3VibWl0IHRoZSByZXF1ZXN0IChQT1NUIC9wdWJsaWMvdjEvc3VibWl0L3VwZGF0ZV9wcml2YXRlX2tleV90YWcpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgc3RhbXBVcGRhdGVQcml2YXRlS2V5VGFnfS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudXBkYXRlUHJpdmF0ZUtleVRhZyA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChcIi9wdWJsaWMvdjEvc3VibWl0L3VwZGF0ZV9wcml2YXRlX2tleV90YWdcIiwgaW5wdXQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZHVjZSBhIGBTaWduZWRSZXF1ZXN0YCBmcm9tIGBUVXBkYXRlUHJpdmF0ZUtleVRhZ0JvZHlgIGJ5IHVzaW5nIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgVXBkYXRlUHJpdmF0ZUtleVRhZ30uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YW1wVXBkYXRlUHJpdmF0ZUtleVRhZyA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnVsbFVybCA9IHRoaXMuY29uZmlnLmJhc2VVcmwgKyBcIi9wdWJsaWMvdjEvc3VibWl0L3VwZGF0ZV9wcml2YXRlX2tleV90YWdcIjtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeShpbnB1dCk7XG4gICAgICAgICAgICBjb25zdCBzdGFtcCA9IGF3YWl0IHRoaXMuc3RhbXBlci5zdGFtcChib2R5KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgICAgICBzdGFtcDogc3RhbXAsXG4gICAgICAgICAgICAgICAgdXJsOiBmdWxsVXJsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgdGhyZXNob2xkIGFuZCBtZW1iZXJzIG9mIHRoZSByb290IHF1b3J1bS4gVGhpcyBtdXN0IGJlIGFwcHJvdmVkIGJ5IHRoZSBjdXJyZW50IHJvb3QgcXVvcnVtLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTaWduIHRoZSBwcm92aWRlZCBgVFVwZGF0ZVJvb3RRdW9ydW1Cb2R5YCB3aXRoIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLCBhbmQgc3VibWl0IHRoZSByZXF1ZXN0IChQT1NUIC9wdWJsaWMvdjEvc3VibWl0L3VwZGF0ZV9yb290X3F1b3J1bSkuXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBhbHNvIHtAbGluayBzdGFtcFVwZGF0ZVJvb3RRdW9ydW19LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51cGRhdGVSb290UXVvcnVtID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KFwiL3B1YmxpYy92MS9zdWJtaXQvdXBkYXRlX3Jvb3RfcXVvcnVtXCIsIGlucHV0KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb2R1Y2UgYSBgU2lnbmVkUmVxdWVzdGAgZnJvbSBgVFVwZGF0ZVJvb3RRdW9ydW1Cb2R5YCBieSB1c2luZyB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIFVwZGF0ZVJvb3RRdW9ydW19LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFtcFVwZGF0ZVJvb3RRdW9ydW0gPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZ1bGxVcmwgPSB0aGlzLmNvbmZpZy5iYXNlVXJsICsgXCIvcHVibGljL3YxL3N1Ym1pdC91cGRhdGVfcm9vdF9xdW9ydW1cIjtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeShpbnB1dCk7XG4gICAgICAgICAgICBjb25zdCBzdGFtcCA9IGF3YWl0IHRoaXMuc3RhbXBlci5zdGFtcChib2R5KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgICAgICBzdGFtcDogc3RhbXAsXG4gICAgICAgICAgICAgICAgdXJsOiBmdWxsVXJsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSBhIFVzZXIgaW4gYW4gZXhpc3RpbmcgT3JnYW5pemF0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIFNpZ24gdGhlIHByb3ZpZGVkIGBUVXBkYXRlVXNlckJvZHlgIHdpdGggdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24sIGFuZCBzdWJtaXQgdGhlIHJlcXVlc3QgKFBPU1QgL3B1YmxpYy92MS9zdWJtaXQvdXBkYXRlX3VzZXIpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgc3RhbXBVcGRhdGVVc2VyfS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudXBkYXRlVXNlciA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChcIi9wdWJsaWMvdjEvc3VibWl0L3VwZGF0ZV91c2VyXCIsIGlucHV0KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb2R1Y2UgYSBgU2lnbmVkUmVxdWVzdGAgZnJvbSBgVFVwZGF0ZVVzZXJCb2R5YCBieSB1c2luZyB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIFVwZGF0ZVVzZXJ9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFtcFVwZGF0ZVVzZXIgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZ1bGxVcmwgPSB0aGlzLmNvbmZpZy5iYXNlVXJsICsgXCIvcHVibGljL3YxL3N1Ym1pdC91cGRhdGVfdXNlclwiO1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KGlucHV0KTtcbiAgICAgICAgICAgIGNvbnN0IHN0YW1wID0gYXdhaXQgdGhpcy5zdGFtcGVyLnN0YW1wKGJvZHkpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgICAgIHN0YW1wOiBzdGFtcCxcbiAgICAgICAgICAgICAgICB1cmw6IGZ1bGxVcmwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlIGh1bWFuLXJlYWRhYmxlIG5hbWUgb3IgYXNzb2NpYXRlZCB1c2Vycy4gTm90ZSB0aGF0IHRoaXMgYWN0aXZpdHkgaXMgYXRvbWljOiBhbGwgb2YgdGhlIHVwZGF0ZXMgd2lsbCBzdWNjZWVkIGF0IG9uY2UsIG9yIGFsbCBvZiB0aGVtIHdpbGwgZmFpbC5cbiAgICAgICAgICpcbiAgICAgICAgICogU2lnbiB0aGUgcHJvdmlkZWQgYFRVcGRhdGVVc2VyVGFnQm9keWAgd2l0aCB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbiwgYW5kIHN1Ym1pdCB0aGUgcmVxdWVzdCAoUE9TVCAvcHVibGljL3YxL3N1Ym1pdC91cGRhdGVfdXNlcl90YWcpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgc3RhbXBVcGRhdGVVc2VyVGFnfS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudXBkYXRlVXNlclRhZyA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChcIi9wdWJsaWMvdjEvc3VibWl0L3VwZGF0ZV91c2VyX3RhZ1wiLCBpbnB1dCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9kdWNlIGEgYFNpZ25lZFJlcXVlc3RgIGZyb20gYFRVcGRhdGVVc2VyVGFnQm9keWAgYnkgdXNpbmcgdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBhbHNvIHtAbGluayBVcGRhdGVVc2VyVGFnfS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhbXBVcGRhdGVVc2VyVGFnID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmdWxsVXJsID0gdGhpcy5jb25maWcuYmFzZVVybCArIFwiL3B1YmxpYy92MS9zdWJtaXQvdXBkYXRlX3VzZXJfdGFnXCI7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkoaW5wdXQpO1xuICAgICAgICAgICAgY29uc3Qgc3RhbXAgPSBhd2FpdCB0aGlzLnN0YW1wZXIuc3RhbXAoYm9keSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICAgICAgc3RhbXA6IHN0YW1wLFxuICAgICAgICAgICAgICAgIHVybDogZnVsbFVybCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIGlmICghY29uZmlnLmJhc2VVcmwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTWlzc2luZyBiYXNlIFVSTC4gUGxlYXNlIHZlcmlmeSBlbnYgdmFycy5gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5zdGFtcGVyID0gc3RhbXBlcjtcbiAgICB9XG4gICAgYXN5bmMgcmVxdWVzdCh1cmwsIGJvZHkpIHtcbiAgICAgICAgY29uc3QgZnVsbFVybCA9IHRoaXMuY29uZmlnLmJhc2VVcmwgKyB1cmw7XG4gICAgICAgIGNvbnN0IHN0cmluZ2lmaWVkQm9keSA9IEpTT04uc3RyaW5naWZ5KGJvZHkpO1xuICAgICAgICBjb25zdCBzdGFtcCA9IGF3YWl0IHRoaXMuc3RhbXBlci5zdGFtcChzdHJpbmdpZmllZEJvZHkpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGZ1bGxVcmwsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgW3N0YW1wLnN0YW1wSGVhZGVyTmFtZV06IHN0YW1wLnN0YW1wSGVhZGVyVmFsdWUsXG4gICAgICAgICAgICAgICAgXCJYLUNsaWVudC1WZXJzaW9uXCI6IFZFUlNJT04sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYm9keTogc3RyaW5naWZpZWRCb2R5LFxuICAgICAgICAgICAgcmVkaXJlY3Q6IFwiZm9sbG93XCIsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICBsZXQgcmVzO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXMgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoXykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBUdXJua2V5UmVxdWVzdEVycm9yKHJlcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxufVxuXG5leHBvcnQgeyBUdXJua2V5Q2xpZW50IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wdWJsaWNfYXBpLmNsaWVudC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/http/dist/__generated__/services/coordinator/public/v1/public_api.client.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/http/dist/__generated__/services/coordinator/public/v1/public_api.fetcher.mjs":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/@turnkey/http/dist/__generated__/services/coordinator/public/v1/public_api.fetcher.mjs ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   approveActivity: () => (/* binding */ approveActivity),\n/* harmony export */   createApiKeys: () => (/* binding */ createApiKeys),\n/* harmony export */   createApiOnlyUsers: () => (/* binding */ createApiOnlyUsers),\n/* harmony export */   createAuthenticators: () => (/* binding */ createAuthenticators),\n/* harmony export */   createInvitations: () => (/* binding */ createInvitations),\n/* harmony export */   createPolicies: () => (/* binding */ createPolicies),\n/* harmony export */   createPolicy: () => (/* binding */ createPolicy),\n/* harmony export */   createPrivateKeyTag: () => (/* binding */ createPrivateKeyTag),\n/* harmony export */   createPrivateKeys: () => (/* binding */ createPrivateKeys),\n/* harmony export */   createSubOrganization: () => (/* binding */ createSubOrganization),\n/* harmony export */   createUserTag: () => (/* binding */ createUserTag),\n/* harmony export */   createUsers: () => (/* binding */ createUsers),\n/* harmony export */   createWallet: () => (/* binding */ createWallet),\n/* harmony export */   createWalletAccounts: () => (/* binding */ createWalletAccounts),\n/* harmony export */   deleteApiKeys: () => (/* binding */ deleteApiKeys),\n/* harmony export */   deleteAuthenticators: () => (/* binding */ deleteAuthenticators),\n/* harmony export */   deleteInvitation: () => (/* binding */ deleteInvitation),\n/* harmony export */   deletePolicy: () => (/* binding */ deletePolicy),\n/* harmony export */   deletePrivateKeyTags: () => (/* binding */ deletePrivateKeyTags),\n/* harmony export */   deleteUserTags: () => (/* binding */ deleteUserTags),\n/* harmony export */   deleteUsers: () => (/* binding */ deleteUsers),\n/* harmony export */   emailAuth: () => (/* binding */ emailAuth),\n/* harmony export */   exportPrivateKey: () => (/* binding */ exportPrivateKey),\n/* harmony export */   exportWallet: () => (/* binding */ exportWallet),\n/* harmony export */   exportWalletAccount: () => (/* binding */ exportWalletAccount),\n/* harmony export */   getActivities: () => (/* binding */ getActivities),\n/* harmony export */   getActivity: () => (/* binding */ getActivity),\n/* harmony export */   getApiKey: () => (/* binding */ getApiKey),\n/* harmony export */   getApiKeys: () => (/* binding */ getApiKeys),\n/* harmony export */   getAuthenticator: () => (/* binding */ getAuthenticator),\n/* harmony export */   getAuthenticators: () => (/* binding */ getAuthenticators),\n/* harmony export */   getOrganization: () => (/* binding */ getOrganization),\n/* harmony export */   getPolicies: () => (/* binding */ getPolicies),\n/* harmony export */   getPolicy: () => (/* binding */ getPolicy),\n/* harmony export */   getPrivateKey: () => (/* binding */ getPrivateKey),\n/* harmony export */   getPrivateKeys: () => (/* binding */ getPrivateKeys),\n/* harmony export */   getSubOrgIds: () => (/* binding */ getSubOrgIds),\n/* harmony export */   getUser: () => (/* binding */ getUser),\n/* harmony export */   getUsers: () => (/* binding */ getUsers),\n/* harmony export */   getWallet: () => (/* binding */ getWallet),\n/* harmony export */   getWalletAccounts: () => (/* binding */ getWalletAccounts),\n/* harmony export */   getWallets: () => (/* binding */ getWallets),\n/* harmony export */   getWhoami: () => (/* binding */ getWhoami),\n/* harmony export */   importPrivateKey: () => (/* binding */ importPrivateKey),\n/* harmony export */   importWallet: () => (/* binding */ importWallet),\n/* harmony export */   initImportPrivateKey: () => (/* binding */ initImportPrivateKey),\n/* harmony export */   initImportWallet: () => (/* binding */ initImportWallet),\n/* harmony export */   initUserEmailRecovery: () => (/* binding */ initUserEmailRecovery),\n/* harmony export */   listPrivateKeyTags: () => (/* binding */ listPrivateKeyTags),\n/* harmony export */   listUserTags: () => (/* binding */ listUserTags),\n/* harmony export */   nOOPCodegenAnchor: () => (/* binding */ nOOPCodegenAnchor),\n/* harmony export */   recoverUser: () => (/* binding */ recoverUser),\n/* harmony export */   rejectActivity: () => (/* binding */ rejectActivity),\n/* harmony export */   removeOrganizationFeature: () => (/* binding */ removeOrganizationFeature),\n/* harmony export */   setOrganizationFeature: () => (/* binding */ setOrganizationFeature),\n/* harmony export */   signApproveActivity: () => (/* binding */ signApproveActivity),\n/* harmony export */   signCreateApiKeys: () => (/* binding */ signCreateApiKeys),\n/* harmony export */   signCreateApiOnlyUsers: () => (/* binding */ signCreateApiOnlyUsers),\n/* harmony export */   signCreateAuthenticators: () => (/* binding */ signCreateAuthenticators),\n/* harmony export */   signCreateInvitations: () => (/* binding */ signCreateInvitations),\n/* harmony export */   signCreatePolicies: () => (/* binding */ signCreatePolicies),\n/* harmony export */   signCreatePolicy: () => (/* binding */ signCreatePolicy),\n/* harmony export */   signCreatePrivateKeyTag: () => (/* binding */ signCreatePrivateKeyTag),\n/* harmony export */   signCreatePrivateKeys: () => (/* binding */ signCreatePrivateKeys),\n/* harmony export */   signCreateSubOrganization: () => (/* binding */ signCreateSubOrganization),\n/* harmony export */   signCreateUserTag: () => (/* binding */ signCreateUserTag),\n/* harmony export */   signCreateUsers: () => (/* binding */ signCreateUsers),\n/* harmony export */   signCreateWallet: () => (/* binding */ signCreateWallet),\n/* harmony export */   signCreateWalletAccounts: () => (/* binding */ signCreateWalletAccounts),\n/* harmony export */   signDeleteApiKeys: () => (/* binding */ signDeleteApiKeys),\n/* harmony export */   signDeleteAuthenticators: () => (/* binding */ signDeleteAuthenticators),\n/* harmony export */   signDeleteInvitation: () => (/* binding */ signDeleteInvitation),\n/* harmony export */   signDeletePolicy: () => (/* binding */ signDeletePolicy),\n/* harmony export */   signDeletePrivateKeyTags: () => (/* binding */ signDeletePrivateKeyTags),\n/* harmony export */   signDeleteUserTags: () => (/* binding */ signDeleteUserTags),\n/* harmony export */   signDeleteUsers: () => (/* binding */ signDeleteUsers),\n/* harmony export */   signEmailAuth: () => (/* binding */ signEmailAuth),\n/* harmony export */   signExportPrivateKey: () => (/* binding */ signExportPrivateKey),\n/* harmony export */   signExportWallet: () => (/* binding */ signExportWallet),\n/* harmony export */   signExportWalletAccount: () => (/* binding */ signExportWalletAccount),\n/* harmony export */   signGetActivities: () => (/* binding */ signGetActivities),\n/* harmony export */   signGetActivity: () => (/* binding */ signGetActivity),\n/* harmony export */   signGetApiKey: () => (/* binding */ signGetApiKey),\n/* harmony export */   signGetApiKeys: () => (/* binding */ signGetApiKeys),\n/* harmony export */   signGetAuthenticator: () => (/* binding */ signGetAuthenticator),\n/* harmony export */   signGetAuthenticators: () => (/* binding */ signGetAuthenticators),\n/* harmony export */   signGetOrganization: () => (/* binding */ signGetOrganization),\n/* harmony export */   signGetPolicies: () => (/* binding */ signGetPolicies),\n/* harmony export */   signGetPolicy: () => (/* binding */ signGetPolicy),\n/* harmony export */   signGetPrivateKey: () => (/* binding */ signGetPrivateKey),\n/* harmony export */   signGetPrivateKeys: () => (/* binding */ signGetPrivateKeys),\n/* harmony export */   signGetSubOrgIds: () => (/* binding */ signGetSubOrgIds),\n/* harmony export */   signGetUser: () => (/* binding */ signGetUser),\n/* harmony export */   signGetUsers: () => (/* binding */ signGetUsers),\n/* harmony export */   signGetWallet: () => (/* binding */ signGetWallet),\n/* harmony export */   signGetWalletAccounts: () => (/* binding */ signGetWalletAccounts),\n/* harmony export */   signGetWallets: () => (/* binding */ signGetWallets),\n/* harmony export */   signGetWhoami: () => (/* binding */ signGetWhoami),\n/* harmony export */   signImportPrivateKey: () => (/* binding */ signImportPrivateKey),\n/* harmony export */   signImportWallet: () => (/* binding */ signImportWallet),\n/* harmony export */   signInitImportPrivateKey: () => (/* binding */ signInitImportPrivateKey),\n/* harmony export */   signInitImportWallet: () => (/* binding */ signInitImportWallet),\n/* harmony export */   signInitUserEmailRecovery: () => (/* binding */ signInitUserEmailRecovery),\n/* harmony export */   signListPrivateKeyTags: () => (/* binding */ signListPrivateKeyTags),\n/* harmony export */   signListUserTags: () => (/* binding */ signListUserTags),\n/* harmony export */   signNOOPCodegenAnchor: () => (/* binding */ signNOOPCodegenAnchor),\n/* harmony export */   signRawPayload: () => (/* binding */ signRawPayload),\n/* harmony export */   signRawPayloads: () => (/* binding */ signRawPayloads),\n/* harmony export */   signRecoverUser: () => (/* binding */ signRecoverUser),\n/* harmony export */   signRejectActivity: () => (/* binding */ signRejectActivity),\n/* harmony export */   signRemoveOrganizationFeature: () => (/* binding */ signRemoveOrganizationFeature),\n/* harmony export */   signSetOrganizationFeature: () => (/* binding */ signSetOrganizationFeature),\n/* harmony export */   signSignRawPayload: () => (/* binding */ signSignRawPayload),\n/* harmony export */   signSignRawPayloads: () => (/* binding */ signSignRawPayloads),\n/* harmony export */   signSignTransaction: () => (/* binding */ signSignTransaction),\n/* harmony export */   signTransaction: () => (/* binding */ signTransaction),\n/* harmony export */   signUpdatePolicy: () => (/* binding */ signUpdatePolicy),\n/* harmony export */   signUpdatePrivateKeyTag: () => (/* binding */ signUpdatePrivateKeyTag),\n/* harmony export */   signUpdateRootQuorum: () => (/* binding */ signUpdateRootQuorum),\n/* harmony export */   signUpdateUser: () => (/* binding */ signUpdateUser),\n/* harmony export */   signUpdateUserTag: () => (/* binding */ signUpdateUserTag),\n/* harmony export */   updatePolicy: () => (/* binding */ updatePolicy),\n/* harmony export */   updatePrivateKeyTag: () => (/* binding */ updatePrivateKeyTag),\n/* harmony export */   updateRootQuorum: () => (/* binding */ updateRootQuorum),\n/* harmony export */   updateUser: () => (/* binding */ updateUser),\n/* harmony export */   updateUserTag: () => (/* binding */ updateUserTag)\n/* harmony export */ });\n/* harmony import */ var _base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../base.mjs */ \"(ssr)/./node_modules/@turnkey/http/dist/base.mjs\");\n\n\n/* @generated by `@turnkey/fetchers`. DO NOT EDIT BY HAND */\n/**\n * Get Activity\n *\n * Get details about an Activity\n *\n * `POST /public/v1/query/get_activity`\n */\nconst getActivity = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/query/get_activity\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `GetActivity` request, ready to be POSTed to Turnkey.\n *\n * See {@link GetActivity}\n */\nconst signGetActivity = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/query/get_activity\",\n    body: input.body,\n    options,\n});\n/**\n * Get API key\n *\n * Get details about an API key\n *\n * `POST /public/v1/query/get_api_key`\n */\nconst getApiKey = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/query/get_api_key\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `GetApiKey` request, ready to be POSTed to Turnkey.\n *\n * See {@link GetApiKey}\n */\nconst signGetApiKey = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/query/get_api_key\",\n    body: input.body,\n    options,\n});\n/**\n * Get API key\n *\n * Get details about API keys for a user\n *\n * `POST /public/v1/query/get_api_keys`\n */\nconst getApiKeys = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/query/get_api_keys\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `GetApiKeys` request, ready to be POSTed to Turnkey.\n *\n * See {@link GetApiKeys}\n */\nconst signGetApiKeys = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/query/get_api_keys\",\n    body: input.body,\n    options,\n});\n/**\n * Get Authenticator\n *\n * Get details about an authenticator\n *\n * `POST /public/v1/query/get_authenticator`\n */\nconst getAuthenticator = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/query/get_authenticator\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `GetAuthenticator` request, ready to be POSTed to Turnkey.\n *\n * See {@link GetAuthenticator}\n */\nconst signGetAuthenticator = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/query/get_authenticator\",\n    body: input.body,\n    options,\n});\n/**\n * Get Authenticators\n *\n * Get details about authenticators for a user\n *\n * `POST /public/v1/query/get_authenticators`\n */\nconst getAuthenticators = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/query/get_authenticators\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `GetAuthenticators` request, ready to be POSTed to Turnkey.\n *\n * See {@link GetAuthenticators}\n */\nconst signGetAuthenticators = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/query/get_authenticators\",\n    body: input.body,\n    options,\n});\n/**\n * Get Organization\n *\n * Get details about an Organization\n *\n * `POST /public/v1/query/get_organization`\n */\nconst getOrganization = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/query/get_organization\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `GetOrganization` request, ready to be POSTed to Turnkey.\n *\n * See {@link GetOrganization}\n */\nconst signGetOrganization = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/query/get_organization\",\n    body: input.body,\n    options,\n});\n/**\n * Get Policy\n *\n * Get details about a Policy\n *\n * `POST /public/v1/query/get_policy`\n */\nconst getPolicy = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/query/get_policy\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `GetPolicy` request, ready to be POSTed to Turnkey.\n *\n * See {@link GetPolicy}\n */\nconst signGetPolicy = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/query/get_policy\",\n    body: input.body,\n    options,\n});\n/**\n * Get Private Key\n *\n * Get details about a Private Key\n *\n * `POST /public/v1/query/get_private_key`\n */\nconst getPrivateKey = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/query/get_private_key\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `GetPrivateKey` request, ready to be POSTed to Turnkey.\n *\n * See {@link GetPrivateKey}\n */\nconst signGetPrivateKey = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/query/get_private_key\",\n    body: input.body,\n    options,\n});\n/**\n * Get User\n *\n * Get details about a User\n *\n * `POST /public/v1/query/get_user`\n */\nconst getUser = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/query/get_user\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `GetUser` request, ready to be POSTed to Turnkey.\n *\n * See {@link GetUser}\n */\nconst signGetUser = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/query/get_user\",\n    body: input.body,\n    options,\n});\n/**\n * Get Wallet\n *\n * Get details about a Wallet\n *\n * `POST /public/v1/query/get_wallet`\n */\nconst getWallet = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/query/get_wallet\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `GetWallet` request, ready to be POSTed to Turnkey.\n *\n * See {@link GetWallet}\n */\nconst signGetWallet = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/query/get_wallet\",\n    body: input.body,\n    options,\n});\n/**\n * List Activities\n *\n * List all Activities within an Organization\n *\n * `POST /public/v1/query/list_activities`\n */\nconst getActivities = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/query/list_activities\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `GetActivities` request, ready to be POSTed to Turnkey.\n *\n * See {@link GetActivities}\n */\nconst signGetActivities = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/query/list_activities\",\n    body: input.body,\n    options,\n});\n/**\n * List Policies\n *\n * List all Policies within an Organization\n *\n * `POST /public/v1/query/list_policies`\n */\nconst getPolicies = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/query/list_policies\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `GetPolicies` request, ready to be POSTed to Turnkey.\n *\n * See {@link GetPolicies}\n */\nconst signGetPolicies = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/query/list_policies\",\n    body: input.body,\n    options,\n});\n/**\n * List Private Key Tags\n *\n * List all Private Key Tags within an Organization\n *\n * `POST /public/v1/query/list_private_key_tags`\n */\nconst listPrivateKeyTags = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/query/list_private_key_tags\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `ListPrivateKeyTags` request, ready to be POSTed to Turnkey.\n *\n * See {@link ListPrivateKeyTags}\n */\nconst signListPrivateKeyTags = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/query/list_private_key_tags\",\n    body: input.body,\n    options,\n});\n/**\n * List Private Keys\n *\n * List all Private Keys within an Organization\n *\n * `POST /public/v1/query/list_private_keys`\n */\nconst getPrivateKeys = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/query/list_private_keys\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `GetPrivateKeys` request, ready to be POSTed to Turnkey.\n *\n * See {@link GetPrivateKeys}\n */\nconst signGetPrivateKeys = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/query/list_private_keys\",\n    body: input.body,\n    options,\n});\n/**\n * Get Suborgs\n *\n * Get all suborg IDs associated given a parent org ID and an optional filter.\n *\n * `POST /public/v1/query/list_suborgs`\n */\nconst getSubOrgIds = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/query/list_suborgs\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `GetSubOrgIds` request, ready to be POSTed to Turnkey.\n *\n * See {@link GetSubOrgIds}\n */\nconst signGetSubOrgIds = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/query/list_suborgs\",\n    body: input.body,\n    options,\n});\n/**\n * List User Tags\n *\n * List all User Tags within an Organization\n *\n * `POST /public/v1/query/list_user_tags`\n */\nconst listUserTags = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/query/list_user_tags\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `ListUserTags` request, ready to be POSTed to Turnkey.\n *\n * See {@link ListUserTags}\n */\nconst signListUserTags = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/query/list_user_tags\",\n    body: input.body,\n    options,\n});\n/**\n * List Users\n *\n * List all Users within an Organization\n *\n * `POST /public/v1/query/list_users`\n */\nconst getUsers = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/query/list_users\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `GetUsers` request, ready to be POSTed to Turnkey.\n *\n * See {@link GetUsers}\n */\nconst signGetUsers = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/query/list_users\",\n    body: input.body,\n    options,\n});\n/**\n * List Wallets Accounts\n *\n * List all Accounts wirhin a Wallet\n *\n * `POST /public/v1/query/list_wallet_accounts`\n */\nconst getWalletAccounts = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/query/list_wallet_accounts\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `GetWalletAccounts` request, ready to be POSTed to Turnkey.\n *\n * See {@link GetWalletAccounts}\n */\nconst signGetWalletAccounts = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/query/list_wallet_accounts\",\n    body: input.body,\n    options,\n});\n/**\n * List Wallets\n *\n * List all Wallets within an Organization\n *\n * `POST /public/v1/query/list_wallets`\n */\nconst getWallets = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/query/list_wallets\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `GetWallets` request, ready to be POSTed to Turnkey.\n *\n * See {@link GetWallets}\n */\nconst signGetWallets = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/query/list_wallets\",\n    body: input.body,\n    options,\n});\n/**\n * Who am I?\n *\n * Get basic information about your current API or WebAuthN user and their organization. Affords Sub-Organization look ups via Parent Organization for WebAuthN or API key users.\n *\n * `POST /public/v1/query/whoami`\n */\nconst getWhoami = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/query/whoami\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `GetWhoami` request, ready to be POSTed to Turnkey.\n *\n * See {@link GetWhoami}\n */\nconst signGetWhoami = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/query/whoami\",\n    body: input.body,\n    options,\n});\n/**\n * Approve Activity\n *\n * Approve an Activity\n *\n * `POST /public/v1/submit/approve_activity`\n */\nconst approveActivity = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/approve_activity\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `ApproveActivity` request, ready to be POSTed to Turnkey.\n *\n * See {@link ApproveActivity}\n */\nconst signApproveActivity = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/approve_activity\",\n    body: input.body,\n    options,\n});\n/**\n * Create API Keys\n *\n * Add api keys to an existing User\n *\n * `POST /public/v1/submit/create_api_keys`\n */\nconst createApiKeys = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/create_api_keys\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `CreateApiKeys` request, ready to be POSTed to Turnkey.\n *\n * See {@link CreateApiKeys}\n */\nconst signCreateApiKeys = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/create_api_keys\",\n    body: input.body,\n    options,\n});\n/**\n * Create API-only Users\n *\n * Create API-only Users in an existing Organization\n *\n * `POST /public/v1/submit/create_api_only_users`\n */\nconst createApiOnlyUsers = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/create_api_only_users\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `CreateApiOnlyUsers` request, ready to be POSTed to Turnkey.\n *\n * See {@link CreateApiOnlyUsers}\n */\nconst signCreateApiOnlyUsers = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/create_api_only_users\",\n    body: input.body,\n    options,\n});\n/**\n * Create Authenticators\n *\n * Create Authenticators to authenticate requests to Turnkey\n *\n * `POST /public/v1/submit/create_authenticators`\n */\nconst createAuthenticators = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/create_authenticators\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `CreateAuthenticators` request, ready to be POSTed to Turnkey.\n *\n * See {@link CreateAuthenticators}\n */\nconst signCreateAuthenticators = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/create_authenticators\",\n    body: input.body,\n    options,\n});\n/**\n * Create Invitations\n *\n * Create Invitations to join an existing Organization\n *\n * `POST /public/v1/submit/create_invitations`\n */\nconst createInvitations = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/create_invitations\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `CreateInvitations` request, ready to be POSTed to Turnkey.\n *\n * See {@link CreateInvitations}\n */\nconst signCreateInvitations = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/create_invitations\",\n    body: input.body,\n    options,\n});\n/**\n * Create Policies\n *\n * Create new Policies\n *\n * `POST /public/v1/submit/create_policies`\n */\nconst createPolicies = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/create_policies\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `CreatePolicies` request, ready to be POSTed to Turnkey.\n *\n * See {@link CreatePolicies}\n */\nconst signCreatePolicies = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/create_policies\",\n    body: input.body,\n    options,\n});\n/**\n * Create Policy\n *\n * Create a new Policy\n *\n * `POST /public/v1/submit/create_policy`\n */\nconst createPolicy = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/create_policy\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `CreatePolicy` request, ready to be POSTed to Turnkey.\n *\n * See {@link CreatePolicy}\n */\nconst signCreatePolicy = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/create_policy\",\n    body: input.body,\n    options,\n});\n/**\n * Create Private Key Tag\n *\n * Create a private key tag and add it to private keys.\n *\n * `POST /public/v1/submit/create_private_key_tag`\n */\nconst createPrivateKeyTag = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/create_private_key_tag\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `CreatePrivateKeyTag` request, ready to be POSTed to Turnkey.\n *\n * See {@link CreatePrivateKeyTag}\n */\nconst signCreatePrivateKeyTag = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/create_private_key_tag\",\n    body: input.body,\n    options,\n});\n/**\n * Create Private Keys\n *\n * Create new Private Keys\n *\n * `POST /public/v1/submit/create_private_keys`\n */\nconst createPrivateKeys = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/create_private_keys\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `CreatePrivateKeys` request, ready to be POSTed to Turnkey.\n *\n * See {@link CreatePrivateKeys}\n */\nconst signCreatePrivateKeys = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/create_private_keys\",\n    body: input.body,\n    options,\n});\n/**\n * Create Sub-Organization\n *\n * Create a new Sub-Organization\n *\n * `POST /public/v1/submit/create_sub_organization`\n */\nconst createSubOrganization = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/create_sub_organization\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `CreateSubOrganization` request, ready to be POSTed to Turnkey.\n *\n * See {@link CreateSubOrganization}\n */\nconst signCreateSubOrganization = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/create_sub_organization\",\n    body: input.body,\n    options,\n});\n/**\n * Create User Tag\n *\n * Create a user tag and add it to users.\n *\n * `POST /public/v1/submit/create_user_tag`\n */\nconst createUserTag = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/create_user_tag\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `CreateUserTag` request, ready to be POSTed to Turnkey.\n *\n * See {@link CreateUserTag}\n */\nconst signCreateUserTag = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/create_user_tag\",\n    body: input.body,\n    options,\n});\n/**\n * Create Users\n *\n * Create Users in an existing Organization\n *\n * `POST /public/v1/submit/create_users`\n */\nconst createUsers = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/create_users\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `CreateUsers` request, ready to be POSTed to Turnkey.\n *\n * See {@link CreateUsers}\n */\nconst signCreateUsers = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/create_users\",\n    body: input.body,\n    options,\n});\n/**\n * Create Wallet\n *\n * Create a Wallet and derive addresses\n *\n * `POST /public/v1/submit/create_wallet`\n */\nconst createWallet = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/create_wallet\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `CreateWallet` request, ready to be POSTed to Turnkey.\n *\n * See {@link CreateWallet}\n */\nconst signCreateWallet = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/create_wallet\",\n    body: input.body,\n    options,\n});\n/**\n * Create Wallet Accounts\n *\n * Derive additional addresses using an existing wallet\n *\n * `POST /public/v1/submit/create_wallet_accounts`\n */\nconst createWalletAccounts = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/create_wallet_accounts\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `CreateWalletAccounts` request, ready to be POSTed to Turnkey.\n *\n * See {@link CreateWalletAccounts}\n */\nconst signCreateWalletAccounts = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/create_wallet_accounts\",\n    body: input.body,\n    options,\n});\n/**\n * Delete API Keys\n *\n * Remove api keys from a User\n *\n * `POST /public/v1/submit/delete_api_keys`\n */\nconst deleteApiKeys = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/delete_api_keys\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `DeleteApiKeys` request, ready to be POSTed to Turnkey.\n *\n * See {@link DeleteApiKeys}\n */\nconst signDeleteApiKeys = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/delete_api_keys\",\n    body: input.body,\n    options,\n});\n/**\n * Delete Authenticators\n *\n * Remove authenticators from a User\n *\n * `POST /public/v1/submit/delete_authenticators`\n */\nconst deleteAuthenticators = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/delete_authenticators\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `DeleteAuthenticators` request, ready to be POSTed to Turnkey.\n *\n * See {@link DeleteAuthenticators}\n */\nconst signDeleteAuthenticators = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/delete_authenticators\",\n    body: input.body,\n    options,\n});\n/**\n * Delete Invitation\n *\n * Delete an existing Invitation\n *\n * `POST /public/v1/submit/delete_invitation`\n */\nconst deleteInvitation = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/delete_invitation\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `DeleteInvitation` request, ready to be POSTed to Turnkey.\n *\n * See {@link DeleteInvitation}\n */\nconst signDeleteInvitation = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/delete_invitation\",\n    body: input.body,\n    options,\n});\n/**\n * Delete Policy\n *\n * Delete an existing Policy\n *\n * `POST /public/v1/submit/delete_policy`\n */\nconst deletePolicy = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/delete_policy\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `DeletePolicy` request, ready to be POSTed to Turnkey.\n *\n * See {@link DeletePolicy}\n */\nconst signDeletePolicy = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/delete_policy\",\n    body: input.body,\n    options,\n});\n/**\n * Delete Private Key Tags\n *\n * Delete Private Key Tags within an Organization\n *\n * `POST /public/v1/submit/delete_private_key_tags`\n */\nconst deletePrivateKeyTags = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/delete_private_key_tags\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `DeletePrivateKeyTags` request, ready to be POSTed to Turnkey.\n *\n * See {@link DeletePrivateKeyTags}\n */\nconst signDeletePrivateKeyTags = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/delete_private_key_tags\",\n    body: input.body,\n    options,\n});\n/**\n * Delete User Tags\n *\n * Delete User Tags within an Organization\n *\n * `POST /public/v1/submit/delete_user_tags`\n */\nconst deleteUserTags = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/delete_user_tags\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `DeleteUserTags` request, ready to be POSTed to Turnkey.\n *\n * See {@link DeleteUserTags}\n */\nconst signDeleteUserTags = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/delete_user_tags\",\n    body: input.body,\n    options,\n});\n/**\n * Delete Users\n *\n * Delete Users within an Organization\n *\n * `POST /public/v1/submit/delete_users`\n */\nconst deleteUsers = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/delete_users\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `DeleteUsers` request, ready to be POSTed to Turnkey.\n *\n * See {@link DeleteUsers}\n */\nconst signDeleteUsers = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/delete_users\",\n    body: input.body,\n    options,\n});\n/**\n * Perform Email Auth\n *\n * Authenticate a user via Email\n *\n * `POST /public/v1/submit/email_auth`\n */\nconst emailAuth = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/email_auth\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `EmailAuth` request, ready to be POSTed to Turnkey.\n *\n * See {@link EmailAuth}\n */\nconst signEmailAuth = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/email_auth\",\n    body: input.body,\n    options,\n});\n/**\n * Export Private Key\n *\n * Exports a Private Key\n *\n * `POST /public/v1/submit/export_private_key`\n */\nconst exportPrivateKey = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/export_private_key\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `ExportPrivateKey` request, ready to be POSTed to Turnkey.\n *\n * See {@link ExportPrivateKey}\n */\nconst signExportPrivateKey = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/export_private_key\",\n    body: input.body,\n    options,\n});\n/**\n * Export Wallet\n *\n * Exports a Wallet\n *\n * `POST /public/v1/submit/export_wallet`\n */\nconst exportWallet = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/export_wallet\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `ExportWallet` request, ready to be POSTed to Turnkey.\n *\n * See {@link ExportWallet}\n */\nconst signExportWallet = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/export_wallet\",\n    body: input.body,\n    options,\n});\n/**\n * Export Wallet Account\n *\n * Exports a Wallet Account\n *\n * `POST /public/v1/submit/export_wallet_account`\n */\nconst exportWalletAccount = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/export_wallet_account\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `ExportWalletAccount` request, ready to be POSTed to Turnkey.\n *\n * See {@link ExportWalletAccount}\n */\nconst signExportWalletAccount = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/export_wallet_account\",\n    body: input.body,\n    options,\n});\n/**\n * Import Private Key\n *\n * Imports a private key\n *\n * `POST /public/v1/submit/import_private_key`\n */\nconst importPrivateKey = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/import_private_key\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `ImportPrivateKey` request, ready to be POSTed to Turnkey.\n *\n * See {@link ImportPrivateKey}\n */\nconst signImportPrivateKey = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/import_private_key\",\n    body: input.body,\n    options,\n});\n/**\n * Import Wallet\n *\n * Imports a wallet\n *\n * `POST /public/v1/submit/import_wallet`\n */\nconst importWallet = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/import_wallet\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `ImportWallet` request, ready to be POSTed to Turnkey.\n *\n * See {@link ImportWallet}\n */\nconst signImportWallet = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/import_wallet\",\n    body: input.body,\n    options,\n});\n/**\n * Init Import Private Key\n *\n * Initializes a new private key import\n *\n * `POST /public/v1/submit/init_import_private_key`\n */\nconst initImportPrivateKey = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/init_import_private_key\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `InitImportPrivateKey` request, ready to be POSTed to Turnkey.\n *\n * See {@link InitImportPrivateKey}\n */\nconst signInitImportPrivateKey = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/init_import_private_key\",\n    body: input.body,\n    options,\n});\n/**\n * Init Import Wallet\n *\n * Initializes a new wallet import\n *\n * `POST /public/v1/submit/init_import_wallet`\n */\nconst initImportWallet = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/init_import_wallet\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `InitImportWallet` request, ready to be POSTed to Turnkey.\n *\n * See {@link InitImportWallet}\n */\nconst signInitImportWallet = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/init_import_wallet\",\n    body: input.body,\n    options,\n});\n/**\n * Init Email Recovery\n *\n * Initializes a new email recovery\n *\n * `POST /public/v1/submit/init_user_email_recovery`\n */\nconst initUserEmailRecovery = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/init_user_email_recovery\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `InitUserEmailRecovery` request, ready to be POSTed to Turnkey.\n *\n * See {@link InitUserEmailRecovery}\n */\nconst signInitUserEmailRecovery = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/init_user_email_recovery\",\n    body: input.body,\n    options,\n});\n/**\n * Recover a user\n *\n * Completes the process of recovering a user by adding an authenticator\n *\n * `POST /public/v1/submit/recover_user`\n */\nconst recoverUser = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/recover_user\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `RecoverUser` request, ready to be POSTed to Turnkey.\n *\n * See {@link RecoverUser}\n */\nconst signRecoverUser = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/recover_user\",\n    body: input.body,\n    options,\n});\n/**\n * Reject Activity\n *\n * Reject an Activity\n *\n * `POST /public/v1/submit/reject_activity`\n */\nconst rejectActivity = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/reject_activity\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `RejectActivity` request, ready to be POSTed to Turnkey.\n *\n * See {@link RejectActivity}\n */\nconst signRejectActivity = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/reject_activity\",\n    body: input.body,\n    options,\n});\n/**\n * Remove Organization Feature\n *\n * Removes an organization feature\n *\n * `POST /public/v1/submit/remove_organization_feature`\n */\nconst removeOrganizationFeature = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/remove_organization_feature\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `RemoveOrganizationFeature` request, ready to be POSTed to Turnkey.\n *\n * See {@link RemoveOrganizationFeature}\n */\nconst signRemoveOrganizationFeature = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/remove_organization_feature\",\n    body: input.body,\n    options,\n});\n/**\n * Set Organization Feature\n *\n * Sets an organization feature\n *\n * `POST /public/v1/submit/set_organization_feature`\n */\nconst setOrganizationFeature = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/set_organization_feature\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `SetOrganizationFeature` request, ready to be POSTed to Turnkey.\n *\n * See {@link SetOrganizationFeature}\n */\nconst signSetOrganizationFeature = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/set_organization_feature\",\n    body: input.body,\n    options,\n});\n/**\n * Sign Raw Payload\n *\n * Sign a raw payload\n *\n * `POST /public/v1/submit/sign_raw_payload`\n */\nconst signRawPayload = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/sign_raw_payload\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `SignRawPayload` request, ready to be POSTed to Turnkey.\n *\n * See {@link SignRawPayload}\n */\nconst signSignRawPayload = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/sign_raw_payload\",\n    body: input.body,\n    options,\n});\n/**\n * Sign Raw Payloads\n *\n * Sign multiple raw payloads with the same signing parameters\n *\n * `POST /public/v1/submit/sign_raw_payloads`\n */\nconst signRawPayloads = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/sign_raw_payloads\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `SignRawPayloads` request, ready to be POSTed to Turnkey.\n *\n * See {@link SignRawPayloads}\n */\nconst signSignRawPayloads = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/sign_raw_payloads\",\n    body: input.body,\n    options,\n});\n/**\n * Sign Transaction\n *\n * Sign a transaction\n *\n * `POST /public/v1/submit/sign_transaction`\n */\nconst signTransaction = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/sign_transaction\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `SignTransaction` request, ready to be POSTed to Turnkey.\n *\n * See {@link SignTransaction}\n */\nconst signSignTransaction = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/sign_transaction\",\n    body: input.body,\n    options,\n});\n/**\n * Update Policy\n *\n * Update an existing Policy\n *\n * `POST /public/v1/submit/update_policy`\n */\nconst updatePolicy = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/update_policy\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `UpdatePolicy` request, ready to be POSTed to Turnkey.\n *\n * See {@link UpdatePolicy}\n */\nconst signUpdatePolicy = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/update_policy\",\n    body: input.body,\n    options,\n});\n/**\n * Update Private Key Tag\n *\n * Update human-readable name or associated private keys. Note that this activity is atomic: all of the updates will succeed at once, or all of them will fail.\n *\n * `POST /public/v1/submit/update_private_key_tag`\n */\nconst updatePrivateKeyTag = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/update_private_key_tag\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `UpdatePrivateKeyTag` request, ready to be POSTed to Turnkey.\n *\n * See {@link UpdatePrivateKeyTag}\n */\nconst signUpdatePrivateKeyTag = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/update_private_key_tag\",\n    body: input.body,\n    options,\n});\n/**\n * Update Root Quorum\n *\n * Set the threshold and members of the root quorum. This must be approved by the current root quorum.\n *\n * `POST /public/v1/submit/update_root_quorum`\n */\nconst updateRootQuorum = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/update_root_quorum\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `UpdateRootQuorum` request, ready to be POSTed to Turnkey.\n *\n * See {@link UpdateRootQuorum}\n */\nconst signUpdateRootQuorum = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/update_root_quorum\",\n    body: input.body,\n    options,\n});\n/**\n * Update User\n *\n * Update a User in an existing Organization\n *\n * `POST /public/v1/submit/update_user`\n */\nconst updateUser = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/update_user\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `UpdateUser` request, ready to be POSTed to Turnkey.\n *\n * See {@link UpdateUser}\n */\nconst signUpdateUser = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/update_user\",\n    body: input.body,\n    options,\n});\n/**\n * Update User Tag\n *\n * Update human-readable name or associated users. Note that this activity is atomic: all of the updates will succeed at once, or all of them will fail.\n *\n * `POST /public/v1/submit/update_user_tag`\n */\nconst updateUserTag = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/update_user_tag\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `UpdateUserTag` request, ready to be POSTed to Turnkey.\n *\n * See {@link UpdateUserTag}\n */\nconst signUpdateUserTag = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/update_user_tag\",\n    body: input.body,\n    options,\n});\n/**\n * `POST /tkhq/api/v1/noop-codegen-anchor`\n */\nconst nOOPCodegenAnchor = () => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/tkhq/api/v1/noop-codegen-anchor\",\n    method: \"POST\",\n});\n/**\n * Request a WebAuthn assertion and return a signed `NOOPCodegenAnchor` request, ready to be POSTed to Turnkey.\n *\n * See {@link NOOPCodegenAnchor}\n */\nconst signNOOPCodegenAnchor = () => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/tkhq/api/v1/noop-codegen-anchor\",\n});\n\n\n//# sourceMappingURL=public_api.fetcher.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvaHR0cC9kaXN0L19fZ2VuZXJhdGVkX18vc2VydmljZXMvY29vcmRpbmF0b3IvcHVibGljL3YxL3B1YmxpY19hcGkuZmV0Y2hlci5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFpRTs7QUFFakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixrREFBTztBQUN0QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsNENBQTRDLHdEQUFhO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixrREFBTztBQUNwQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsMENBQTBDLHdEQUFhO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrREFBTztBQUNyQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsMkNBQTJDLHdEQUFhO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxrREFBTztBQUMzQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsaURBQWlELHdEQUFhO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxrREFBTztBQUM1QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esa0RBQWtELHdEQUFhO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxrREFBTztBQUMxQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsZ0RBQWdELHdEQUFhO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixrREFBTztBQUNwQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsMENBQTBDLHdEQUFhO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrREFBTztBQUN4QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsOENBQThDLHdEQUFhO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrREFBTztBQUNsQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esd0NBQXdDLHdEQUFhO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixrREFBTztBQUNwQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsMENBQTBDLHdEQUFhO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrREFBTztBQUN4QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsOENBQThDLHdEQUFhO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixrREFBTztBQUN0QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsNENBQTRDLHdEQUFhO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxrREFBTztBQUM3QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsbURBQW1ELHdEQUFhO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxrREFBTztBQUN6QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsK0NBQStDLHdEQUFhO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxrREFBTztBQUN2QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsNkNBQTZDLHdEQUFhO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxrREFBTztBQUN2QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsNkNBQTZDLHdEQUFhO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrREFBTztBQUNuQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EseUNBQXlDLHdEQUFhO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxrREFBTztBQUM1QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esa0RBQWtELHdEQUFhO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrREFBTztBQUNyQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsMkNBQTJDLHdEQUFhO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixrREFBTztBQUNwQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsMENBQTBDLHdEQUFhO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxrREFBTztBQUMxQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsZ0RBQWdELHdEQUFhO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrREFBTztBQUN4QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsOENBQThDLHdEQUFhO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxrREFBTztBQUM3QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsbURBQW1ELHdEQUFhO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxrREFBTztBQUMvQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EscURBQXFELHdEQUFhO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxrREFBTztBQUM1QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esa0RBQWtELHdEQUFhO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxrREFBTztBQUN6QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsK0NBQStDLHdEQUFhO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxrREFBTztBQUN2QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsNkNBQTZDLHdEQUFhO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxrREFBTztBQUM5QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esb0RBQW9ELHdEQUFhO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxrREFBTztBQUM1QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esa0RBQWtELHdEQUFhO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxrREFBTztBQUNoRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esc0RBQXNELHdEQUFhO0FBQ25FO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrREFBTztBQUN4QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsOENBQThDLHdEQUFhO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixrREFBTztBQUN0QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsNENBQTRDLHdEQUFhO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxrREFBTztBQUN2QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsNkNBQTZDLHdEQUFhO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxrREFBTztBQUMvQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EscURBQXFELHdEQUFhO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrREFBTztBQUN4QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsOENBQThDLHdEQUFhO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxrREFBTztBQUMvQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EscURBQXFELHdEQUFhO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxrREFBTztBQUMzQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsaURBQWlELHdEQUFhO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxrREFBTztBQUN2QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsNkNBQTZDLHdEQUFhO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxrREFBTztBQUMvQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EscURBQXFELHdEQUFhO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxrREFBTztBQUN6QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsK0NBQStDLHdEQUFhO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixrREFBTztBQUN0QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsNENBQTRDLHdEQUFhO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixrREFBTztBQUNwQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsMENBQTBDLHdEQUFhO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxrREFBTztBQUMzQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsaURBQWlELHdEQUFhO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxrREFBTztBQUN2QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsNkNBQTZDLHdEQUFhO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxrREFBTztBQUM5QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esb0RBQW9ELHdEQUFhO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxrREFBTztBQUMzQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsaURBQWlELHdEQUFhO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxrREFBTztBQUN2QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsNkNBQTZDLHdEQUFhO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxrREFBTztBQUMvQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EscURBQXFELHdEQUFhO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxrREFBTztBQUMzQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsaURBQWlELHdEQUFhO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxrREFBTztBQUNoRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esc0RBQXNELHdEQUFhO0FBQ25FO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixrREFBTztBQUN0QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsNENBQTRDLHdEQUFhO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxrREFBTztBQUN6QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsK0NBQStDLHdEQUFhO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxrREFBTztBQUNwRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsMERBQTBELHdEQUFhO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxrREFBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsdURBQXVELHdEQUFhO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxrREFBTztBQUN6QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsK0NBQStDLHdEQUFhO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxrREFBTztBQUMxQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsZ0RBQWdELHdEQUFhO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxrREFBTztBQUMxQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsZ0RBQWdELHdEQUFhO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxrREFBTztBQUN2QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsNkNBQTZDLHdEQUFhO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxrREFBTztBQUM5QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esb0RBQW9ELHdEQUFhO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxrREFBTztBQUMzQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsaURBQWlELHdEQUFhO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrREFBTztBQUNyQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsMkNBQTJDLHdEQUFhO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrREFBTztBQUN4QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsOENBQThDLHdEQUFhO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msa0RBQU87QUFDdkM7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxvQ0FBb0Msd0RBQWE7QUFDakQ7QUFDQSxDQUFDOztBQUVpeUU7QUFDbHlFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbnVyc2VibG9jLy4vbm9kZV9tb2R1bGVzL0B0dXJua2V5L2h0dHAvZGlzdC9fX2dlbmVyYXRlZF9fL3NlcnZpY2VzL2Nvb3JkaW5hdG9yL3B1YmxpYy92MS9wdWJsaWNfYXBpLmZldGNoZXIubWpzP2MxNDQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmVxdWVzdCwgc2lnbmVkUmVxdWVzdCB9IGZyb20gJy4uLy4uLy4uLy4uLy4uL2Jhc2UubWpzJztcblxuLyogQGdlbmVyYXRlZCBieSBgQHR1cm5rZXkvZmV0Y2hlcnNgLiBETyBOT1QgRURJVCBCWSBIQU5EICovXG4vKipcbiAqIEdldCBBY3Rpdml0eVxuICpcbiAqIEdldCBkZXRhaWxzIGFib3V0IGFuIEFjdGl2aXR5XG4gKlxuICogYFBPU1QgL3B1YmxpYy92MS9xdWVyeS9nZXRfYWN0aXZpdHlgXG4gKi9cbmNvbnN0IGdldEFjdGl2aXR5ID0gKGlucHV0KSA9PiByZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9xdWVyeS9nZXRfYWN0aXZpdHlcIixcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG59KTtcbi8qKlxuICogUmVxdWVzdCBhIFdlYkF1dGhuIGFzc2VydGlvbiBhbmQgcmV0dXJuIGEgc2lnbmVkIGBHZXRBY3Rpdml0eWAgcmVxdWVzdCwgcmVhZHkgdG8gYmUgUE9TVGVkIHRvIFR1cm5rZXkuXG4gKlxuICogU2VlIHtAbGluayBHZXRBY3Rpdml0eX1cbiAqL1xuY29uc3Qgc2lnbkdldEFjdGl2aXR5ID0gKGlucHV0LCBvcHRpb25zKSA9PiBzaWduZWRSZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9xdWVyeS9nZXRfYWN0aXZpdHlcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxuICAgIG9wdGlvbnMsXG59KTtcbi8qKlxuICogR2V0IEFQSSBrZXlcbiAqXG4gKiBHZXQgZGV0YWlscyBhYm91dCBhbiBBUEkga2V5XG4gKlxuICogYFBPU1QgL3B1YmxpYy92MS9xdWVyeS9nZXRfYXBpX2tleWBcbiAqL1xuY29uc3QgZ2V0QXBpS2V5ID0gKGlucHV0KSA9PiByZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9xdWVyeS9nZXRfYXBpX2tleVwiLFxuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbn0pO1xuLyoqXG4gKiBSZXF1ZXN0IGEgV2ViQXV0aG4gYXNzZXJ0aW9uIGFuZCByZXR1cm4gYSBzaWduZWQgYEdldEFwaUtleWAgcmVxdWVzdCwgcmVhZHkgdG8gYmUgUE9TVGVkIHRvIFR1cm5rZXkuXG4gKlxuICogU2VlIHtAbGluayBHZXRBcGlLZXl9XG4gKi9cbmNvbnN0IHNpZ25HZXRBcGlLZXkgPSAoaW5wdXQsIG9wdGlvbnMpID0+IHNpZ25lZFJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3F1ZXJ5L2dldF9hcGlfa2V5XCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbiAgICBvcHRpb25zLFxufSk7XG4vKipcbiAqIEdldCBBUEkga2V5XG4gKlxuICogR2V0IGRldGFpbHMgYWJvdXQgQVBJIGtleXMgZm9yIGEgdXNlclxuICpcbiAqIGBQT1NUIC9wdWJsaWMvdjEvcXVlcnkvZ2V0X2FwaV9rZXlzYFxuICovXG5jb25zdCBnZXRBcGlLZXlzID0gKGlucHV0KSA9PiByZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9xdWVyeS9nZXRfYXBpX2tleXNcIixcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG59KTtcbi8qKlxuICogUmVxdWVzdCBhIFdlYkF1dGhuIGFzc2VydGlvbiBhbmQgcmV0dXJuIGEgc2lnbmVkIGBHZXRBcGlLZXlzYCByZXF1ZXN0LCByZWFkeSB0byBiZSBQT1NUZWQgdG8gVHVybmtleS5cbiAqXG4gKiBTZWUge0BsaW5rIEdldEFwaUtleXN9XG4gKi9cbmNvbnN0IHNpZ25HZXRBcGlLZXlzID0gKGlucHV0LCBvcHRpb25zKSA9PiBzaWduZWRSZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9xdWVyeS9nZXRfYXBpX2tleXNcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxuICAgIG9wdGlvbnMsXG59KTtcbi8qKlxuICogR2V0IEF1dGhlbnRpY2F0b3JcbiAqXG4gKiBHZXQgZGV0YWlscyBhYm91dCBhbiBhdXRoZW50aWNhdG9yXG4gKlxuICogYFBPU1QgL3B1YmxpYy92MS9xdWVyeS9nZXRfYXV0aGVudGljYXRvcmBcbiAqL1xuY29uc3QgZ2V0QXV0aGVudGljYXRvciA9IChpbnB1dCkgPT4gcmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvcXVlcnkvZ2V0X2F1dGhlbnRpY2F0b3JcIixcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG59KTtcbi8qKlxuICogUmVxdWVzdCBhIFdlYkF1dGhuIGFzc2VydGlvbiBhbmQgcmV0dXJuIGEgc2lnbmVkIGBHZXRBdXRoZW50aWNhdG9yYCByZXF1ZXN0LCByZWFkeSB0byBiZSBQT1NUZWQgdG8gVHVybmtleS5cbiAqXG4gKiBTZWUge0BsaW5rIEdldEF1dGhlbnRpY2F0b3J9XG4gKi9cbmNvbnN0IHNpZ25HZXRBdXRoZW50aWNhdG9yID0gKGlucHV0LCBvcHRpb25zKSA9PiBzaWduZWRSZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9xdWVyeS9nZXRfYXV0aGVudGljYXRvclwiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG4gICAgb3B0aW9ucyxcbn0pO1xuLyoqXG4gKiBHZXQgQXV0aGVudGljYXRvcnNcbiAqXG4gKiBHZXQgZGV0YWlscyBhYm91dCBhdXRoZW50aWNhdG9ycyBmb3IgYSB1c2VyXG4gKlxuICogYFBPU1QgL3B1YmxpYy92MS9xdWVyeS9nZXRfYXV0aGVudGljYXRvcnNgXG4gKi9cbmNvbnN0IGdldEF1dGhlbnRpY2F0b3JzID0gKGlucHV0KSA9PiByZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9xdWVyeS9nZXRfYXV0aGVudGljYXRvcnNcIixcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG59KTtcbi8qKlxuICogUmVxdWVzdCBhIFdlYkF1dGhuIGFzc2VydGlvbiBhbmQgcmV0dXJuIGEgc2lnbmVkIGBHZXRBdXRoZW50aWNhdG9yc2AgcmVxdWVzdCwgcmVhZHkgdG8gYmUgUE9TVGVkIHRvIFR1cm5rZXkuXG4gKlxuICogU2VlIHtAbGluayBHZXRBdXRoZW50aWNhdG9yc31cbiAqL1xuY29uc3Qgc2lnbkdldEF1dGhlbnRpY2F0b3JzID0gKGlucHV0LCBvcHRpb25zKSA9PiBzaWduZWRSZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9xdWVyeS9nZXRfYXV0aGVudGljYXRvcnNcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxuICAgIG9wdGlvbnMsXG59KTtcbi8qKlxuICogR2V0IE9yZ2FuaXphdGlvblxuICpcbiAqIEdldCBkZXRhaWxzIGFib3V0IGFuIE9yZ2FuaXphdGlvblxuICpcbiAqIGBQT1NUIC9wdWJsaWMvdjEvcXVlcnkvZ2V0X29yZ2FuaXphdGlvbmBcbiAqL1xuY29uc3QgZ2V0T3JnYW5pemF0aW9uID0gKGlucHV0KSA9PiByZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9xdWVyeS9nZXRfb3JnYW5pemF0aW9uXCIsXG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxufSk7XG4vKipcbiAqIFJlcXVlc3QgYSBXZWJBdXRobiBhc3NlcnRpb24gYW5kIHJldHVybiBhIHNpZ25lZCBgR2V0T3JnYW5pemF0aW9uYCByZXF1ZXN0LCByZWFkeSB0byBiZSBQT1NUZWQgdG8gVHVybmtleS5cbiAqXG4gKiBTZWUge0BsaW5rIEdldE9yZ2FuaXphdGlvbn1cbiAqL1xuY29uc3Qgc2lnbkdldE9yZ2FuaXphdGlvbiA9IChpbnB1dCwgb3B0aW9ucykgPT4gc2lnbmVkUmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvcXVlcnkvZ2V0X29yZ2FuaXphdGlvblwiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG4gICAgb3B0aW9ucyxcbn0pO1xuLyoqXG4gKiBHZXQgUG9saWN5XG4gKlxuICogR2V0IGRldGFpbHMgYWJvdXQgYSBQb2xpY3lcbiAqXG4gKiBgUE9TVCAvcHVibGljL3YxL3F1ZXJ5L2dldF9wb2xpY3lgXG4gKi9cbmNvbnN0IGdldFBvbGljeSA9IChpbnB1dCkgPT4gcmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvcXVlcnkvZ2V0X3BvbGljeVwiLFxuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbn0pO1xuLyoqXG4gKiBSZXF1ZXN0IGEgV2ViQXV0aG4gYXNzZXJ0aW9uIGFuZCByZXR1cm4gYSBzaWduZWQgYEdldFBvbGljeWAgcmVxdWVzdCwgcmVhZHkgdG8gYmUgUE9TVGVkIHRvIFR1cm5rZXkuXG4gKlxuICogU2VlIHtAbGluayBHZXRQb2xpY3l9XG4gKi9cbmNvbnN0IHNpZ25HZXRQb2xpY3kgPSAoaW5wdXQsIG9wdGlvbnMpID0+IHNpZ25lZFJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3F1ZXJ5L2dldF9wb2xpY3lcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxuICAgIG9wdGlvbnMsXG59KTtcbi8qKlxuICogR2V0IFByaXZhdGUgS2V5XG4gKlxuICogR2V0IGRldGFpbHMgYWJvdXQgYSBQcml2YXRlIEtleVxuICpcbiAqIGBQT1NUIC9wdWJsaWMvdjEvcXVlcnkvZ2V0X3ByaXZhdGVfa2V5YFxuICovXG5jb25zdCBnZXRQcml2YXRlS2V5ID0gKGlucHV0KSA9PiByZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9xdWVyeS9nZXRfcHJpdmF0ZV9rZXlcIixcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG59KTtcbi8qKlxuICogUmVxdWVzdCBhIFdlYkF1dGhuIGFzc2VydGlvbiBhbmQgcmV0dXJuIGEgc2lnbmVkIGBHZXRQcml2YXRlS2V5YCByZXF1ZXN0LCByZWFkeSB0byBiZSBQT1NUZWQgdG8gVHVybmtleS5cbiAqXG4gKiBTZWUge0BsaW5rIEdldFByaXZhdGVLZXl9XG4gKi9cbmNvbnN0IHNpZ25HZXRQcml2YXRlS2V5ID0gKGlucHV0LCBvcHRpb25zKSA9PiBzaWduZWRSZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9xdWVyeS9nZXRfcHJpdmF0ZV9rZXlcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxuICAgIG9wdGlvbnMsXG59KTtcbi8qKlxuICogR2V0IFVzZXJcbiAqXG4gKiBHZXQgZGV0YWlscyBhYm91dCBhIFVzZXJcbiAqXG4gKiBgUE9TVCAvcHVibGljL3YxL3F1ZXJ5L2dldF91c2VyYFxuICovXG5jb25zdCBnZXRVc2VyID0gKGlucHV0KSA9PiByZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9xdWVyeS9nZXRfdXNlclwiLFxuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbn0pO1xuLyoqXG4gKiBSZXF1ZXN0IGEgV2ViQXV0aG4gYXNzZXJ0aW9uIGFuZCByZXR1cm4gYSBzaWduZWQgYEdldFVzZXJgIHJlcXVlc3QsIHJlYWR5IHRvIGJlIFBPU1RlZCB0byBUdXJua2V5LlxuICpcbiAqIFNlZSB7QGxpbmsgR2V0VXNlcn1cbiAqL1xuY29uc3Qgc2lnbkdldFVzZXIgPSAoaW5wdXQsIG9wdGlvbnMpID0+IHNpZ25lZFJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3F1ZXJ5L2dldF91c2VyXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbiAgICBvcHRpb25zLFxufSk7XG4vKipcbiAqIEdldCBXYWxsZXRcbiAqXG4gKiBHZXQgZGV0YWlscyBhYm91dCBhIFdhbGxldFxuICpcbiAqIGBQT1NUIC9wdWJsaWMvdjEvcXVlcnkvZ2V0X3dhbGxldGBcbiAqL1xuY29uc3QgZ2V0V2FsbGV0ID0gKGlucHV0KSA9PiByZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9xdWVyeS9nZXRfd2FsbGV0XCIsXG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxufSk7XG4vKipcbiAqIFJlcXVlc3QgYSBXZWJBdXRobiBhc3NlcnRpb24gYW5kIHJldHVybiBhIHNpZ25lZCBgR2V0V2FsbGV0YCByZXF1ZXN0LCByZWFkeSB0byBiZSBQT1NUZWQgdG8gVHVybmtleS5cbiAqXG4gKiBTZWUge0BsaW5rIEdldFdhbGxldH1cbiAqL1xuY29uc3Qgc2lnbkdldFdhbGxldCA9IChpbnB1dCwgb3B0aW9ucykgPT4gc2lnbmVkUmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvcXVlcnkvZ2V0X3dhbGxldFwiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG4gICAgb3B0aW9ucyxcbn0pO1xuLyoqXG4gKiBMaXN0IEFjdGl2aXRpZXNcbiAqXG4gKiBMaXN0IGFsbCBBY3Rpdml0aWVzIHdpdGhpbiBhbiBPcmdhbml6YXRpb25cbiAqXG4gKiBgUE9TVCAvcHVibGljL3YxL3F1ZXJ5L2xpc3RfYWN0aXZpdGllc2BcbiAqL1xuY29uc3QgZ2V0QWN0aXZpdGllcyA9IChpbnB1dCkgPT4gcmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvcXVlcnkvbGlzdF9hY3Rpdml0aWVzXCIsXG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxufSk7XG4vKipcbiAqIFJlcXVlc3QgYSBXZWJBdXRobiBhc3NlcnRpb24gYW5kIHJldHVybiBhIHNpZ25lZCBgR2V0QWN0aXZpdGllc2AgcmVxdWVzdCwgcmVhZHkgdG8gYmUgUE9TVGVkIHRvIFR1cm5rZXkuXG4gKlxuICogU2VlIHtAbGluayBHZXRBY3Rpdml0aWVzfVxuICovXG5jb25zdCBzaWduR2V0QWN0aXZpdGllcyA9IChpbnB1dCwgb3B0aW9ucykgPT4gc2lnbmVkUmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvcXVlcnkvbGlzdF9hY3Rpdml0aWVzXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbiAgICBvcHRpb25zLFxufSk7XG4vKipcbiAqIExpc3QgUG9saWNpZXNcbiAqXG4gKiBMaXN0IGFsbCBQb2xpY2llcyB3aXRoaW4gYW4gT3JnYW5pemF0aW9uXG4gKlxuICogYFBPU1QgL3B1YmxpYy92MS9xdWVyeS9saXN0X3BvbGljaWVzYFxuICovXG5jb25zdCBnZXRQb2xpY2llcyA9IChpbnB1dCkgPT4gcmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvcXVlcnkvbGlzdF9wb2xpY2llc1wiLFxuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbn0pO1xuLyoqXG4gKiBSZXF1ZXN0IGEgV2ViQXV0aG4gYXNzZXJ0aW9uIGFuZCByZXR1cm4gYSBzaWduZWQgYEdldFBvbGljaWVzYCByZXF1ZXN0LCByZWFkeSB0byBiZSBQT1NUZWQgdG8gVHVybmtleS5cbiAqXG4gKiBTZWUge0BsaW5rIEdldFBvbGljaWVzfVxuICovXG5jb25zdCBzaWduR2V0UG9saWNpZXMgPSAoaW5wdXQsIG9wdGlvbnMpID0+IHNpZ25lZFJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3F1ZXJ5L2xpc3RfcG9saWNpZXNcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxuICAgIG9wdGlvbnMsXG59KTtcbi8qKlxuICogTGlzdCBQcml2YXRlIEtleSBUYWdzXG4gKlxuICogTGlzdCBhbGwgUHJpdmF0ZSBLZXkgVGFncyB3aXRoaW4gYW4gT3JnYW5pemF0aW9uXG4gKlxuICogYFBPU1QgL3B1YmxpYy92MS9xdWVyeS9saXN0X3ByaXZhdGVfa2V5X3RhZ3NgXG4gKi9cbmNvbnN0IGxpc3RQcml2YXRlS2V5VGFncyA9IChpbnB1dCkgPT4gcmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvcXVlcnkvbGlzdF9wcml2YXRlX2tleV90YWdzXCIsXG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxufSk7XG4vKipcbiAqIFJlcXVlc3QgYSBXZWJBdXRobiBhc3NlcnRpb24gYW5kIHJldHVybiBhIHNpZ25lZCBgTGlzdFByaXZhdGVLZXlUYWdzYCByZXF1ZXN0LCByZWFkeSB0byBiZSBQT1NUZWQgdG8gVHVybmtleS5cbiAqXG4gKiBTZWUge0BsaW5rIExpc3RQcml2YXRlS2V5VGFnc31cbiAqL1xuY29uc3Qgc2lnbkxpc3RQcml2YXRlS2V5VGFncyA9IChpbnB1dCwgb3B0aW9ucykgPT4gc2lnbmVkUmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvcXVlcnkvbGlzdF9wcml2YXRlX2tleV90YWdzXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbiAgICBvcHRpb25zLFxufSk7XG4vKipcbiAqIExpc3QgUHJpdmF0ZSBLZXlzXG4gKlxuICogTGlzdCBhbGwgUHJpdmF0ZSBLZXlzIHdpdGhpbiBhbiBPcmdhbml6YXRpb25cbiAqXG4gKiBgUE9TVCAvcHVibGljL3YxL3F1ZXJ5L2xpc3RfcHJpdmF0ZV9rZXlzYFxuICovXG5jb25zdCBnZXRQcml2YXRlS2V5cyA9IChpbnB1dCkgPT4gcmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvcXVlcnkvbGlzdF9wcml2YXRlX2tleXNcIixcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG59KTtcbi8qKlxuICogUmVxdWVzdCBhIFdlYkF1dGhuIGFzc2VydGlvbiBhbmQgcmV0dXJuIGEgc2lnbmVkIGBHZXRQcml2YXRlS2V5c2AgcmVxdWVzdCwgcmVhZHkgdG8gYmUgUE9TVGVkIHRvIFR1cm5rZXkuXG4gKlxuICogU2VlIHtAbGluayBHZXRQcml2YXRlS2V5c31cbiAqL1xuY29uc3Qgc2lnbkdldFByaXZhdGVLZXlzID0gKGlucHV0LCBvcHRpb25zKSA9PiBzaWduZWRSZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9xdWVyeS9saXN0X3ByaXZhdGVfa2V5c1wiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG4gICAgb3B0aW9ucyxcbn0pO1xuLyoqXG4gKiBHZXQgU3Vib3Jnc1xuICpcbiAqIEdldCBhbGwgc3Vib3JnIElEcyBhc3NvY2lhdGVkIGdpdmVuIGEgcGFyZW50IG9yZyBJRCBhbmQgYW4gb3B0aW9uYWwgZmlsdGVyLlxuICpcbiAqIGBQT1NUIC9wdWJsaWMvdjEvcXVlcnkvbGlzdF9zdWJvcmdzYFxuICovXG5jb25zdCBnZXRTdWJPcmdJZHMgPSAoaW5wdXQpID0+IHJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3F1ZXJ5L2xpc3Rfc3Vib3Jnc1wiLFxuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbn0pO1xuLyoqXG4gKiBSZXF1ZXN0IGEgV2ViQXV0aG4gYXNzZXJ0aW9uIGFuZCByZXR1cm4gYSBzaWduZWQgYEdldFN1Yk9yZ0lkc2AgcmVxdWVzdCwgcmVhZHkgdG8gYmUgUE9TVGVkIHRvIFR1cm5rZXkuXG4gKlxuICogU2VlIHtAbGluayBHZXRTdWJPcmdJZHN9XG4gKi9cbmNvbnN0IHNpZ25HZXRTdWJPcmdJZHMgPSAoaW5wdXQsIG9wdGlvbnMpID0+IHNpZ25lZFJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3F1ZXJ5L2xpc3Rfc3Vib3Jnc1wiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG4gICAgb3B0aW9ucyxcbn0pO1xuLyoqXG4gKiBMaXN0IFVzZXIgVGFnc1xuICpcbiAqIExpc3QgYWxsIFVzZXIgVGFncyB3aXRoaW4gYW4gT3JnYW5pemF0aW9uXG4gKlxuICogYFBPU1QgL3B1YmxpYy92MS9xdWVyeS9saXN0X3VzZXJfdGFnc2BcbiAqL1xuY29uc3QgbGlzdFVzZXJUYWdzID0gKGlucHV0KSA9PiByZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9xdWVyeS9saXN0X3VzZXJfdGFnc1wiLFxuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbn0pO1xuLyoqXG4gKiBSZXF1ZXN0IGEgV2ViQXV0aG4gYXNzZXJ0aW9uIGFuZCByZXR1cm4gYSBzaWduZWQgYExpc3RVc2VyVGFnc2AgcmVxdWVzdCwgcmVhZHkgdG8gYmUgUE9TVGVkIHRvIFR1cm5rZXkuXG4gKlxuICogU2VlIHtAbGluayBMaXN0VXNlclRhZ3N9XG4gKi9cbmNvbnN0IHNpZ25MaXN0VXNlclRhZ3MgPSAoaW5wdXQsIG9wdGlvbnMpID0+IHNpZ25lZFJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3F1ZXJ5L2xpc3RfdXNlcl90YWdzXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbiAgICBvcHRpb25zLFxufSk7XG4vKipcbiAqIExpc3QgVXNlcnNcbiAqXG4gKiBMaXN0IGFsbCBVc2VycyB3aXRoaW4gYW4gT3JnYW5pemF0aW9uXG4gKlxuICogYFBPU1QgL3B1YmxpYy92MS9xdWVyeS9saXN0X3VzZXJzYFxuICovXG5jb25zdCBnZXRVc2VycyA9IChpbnB1dCkgPT4gcmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvcXVlcnkvbGlzdF91c2Vyc1wiLFxuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbn0pO1xuLyoqXG4gKiBSZXF1ZXN0IGEgV2ViQXV0aG4gYXNzZXJ0aW9uIGFuZCByZXR1cm4gYSBzaWduZWQgYEdldFVzZXJzYCByZXF1ZXN0LCByZWFkeSB0byBiZSBQT1NUZWQgdG8gVHVybmtleS5cbiAqXG4gKiBTZWUge0BsaW5rIEdldFVzZXJzfVxuICovXG5jb25zdCBzaWduR2V0VXNlcnMgPSAoaW5wdXQsIG9wdGlvbnMpID0+IHNpZ25lZFJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3F1ZXJ5L2xpc3RfdXNlcnNcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxuICAgIG9wdGlvbnMsXG59KTtcbi8qKlxuICogTGlzdCBXYWxsZXRzIEFjY291bnRzXG4gKlxuICogTGlzdCBhbGwgQWNjb3VudHMgd2lyaGluIGEgV2FsbGV0XG4gKlxuICogYFBPU1QgL3B1YmxpYy92MS9xdWVyeS9saXN0X3dhbGxldF9hY2NvdW50c2BcbiAqL1xuY29uc3QgZ2V0V2FsbGV0QWNjb3VudHMgPSAoaW5wdXQpID0+IHJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3F1ZXJ5L2xpc3Rfd2FsbGV0X2FjY291bnRzXCIsXG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxufSk7XG4vKipcbiAqIFJlcXVlc3QgYSBXZWJBdXRobiBhc3NlcnRpb24gYW5kIHJldHVybiBhIHNpZ25lZCBgR2V0V2FsbGV0QWNjb3VudHNgIHJlcXVlc3QsIHJlYWR5IHRvIGJlIFBPU1RlZCB0byBUdXJua2V5LlxuICpcbiAqIFNlZSB7QGxpbmsgR2V0V2FsbGV0QWNjb3VudHN9XG4gKi9cbmNvbnN0IHNpZ25HZXRXYWxsZXRBY2NvdW50cyA9IChpbnB1dCwgb3B0aW9ucykgPT4gc2lnbmVkUmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvcXVlcnkvbGlzdF93YWxsZXRfYWNjb3VudHNcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxuICAgIG9wdGlvbnMsXG59KTtcbi8qKlxuICogTGlzdCBXYWxsZXRzXG4gKlxuICogTGlzdCBhbGwgV2FsbGV0cyB3aXRoaW4gYW4gT3JnYW5pemF0aW9uXG4gKlxuICogYFBPU1QgL3B1YmxpYy92MS9xdWVyeS9saXN0X3dhbGxldHNgXG4gKi9cbmNvbnN0IGdldFdhbGxldHMgPSAoaW5wdXQpID0+IHJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3F1ZXJ5L2xpc3Rfd2FsbGV0c1wiLFxuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbn0pO1xuLyoqXG4gKiBSZXF1ZXN0IGEgV2ViQXV0aG4gYXNzZXJ0aW9uIGFuZCByZXR1cm4gYSBzaWduZWQgYEdldFdhbGxldHNgIHJlcXVlc3QsIHJlYWR5IHRvIGJlIFBPU1RlZCB0byBUdXJua2V5LlxuICpcbiAqIFNlZSB7QGxpbmsgR2V0V2FsbGV0c31cbiAqL1xuY29uc3Qgc2lnbkdldFdhbGxldHMgPSAoaW5wdXQsIG9wdGlvbnMpID0+IHNpZ25lZFJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3F1ZXJ5L2xpc3Rfd2FsbGV0c1wiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG4gICAgb3B0aW9ucyxcbn0pO1xuLyoqXG4gKiBXaG8gYW0gST9cbiAqXG4gKiBHZXQgYmFzaWMgaW5mb3JtYXRpb24gYWJvdXQgeW91ciBjdXJyZW50IEFQSSBvciBXZWJBdXRoTiB1c2VyIGFuZCB0aGVpciBvcmdhbml6YXRpb24uIEFmZm9yZHMgU3ViLU9yZ2FuaXphdGlvbiBsb29rIHVwcyB2aWEgUGFyZW50IE9yZ2FuaXphdGlvbiBmb3IgV2ViQXV0aE4gb3IgQVBJIGtleSB1c2Vycy5cbiAqXG4gKiBgUE9TVCAvcHVibGljL3YxL3F1ZXJ5L3dob2FtaWBcbiAqL1xuY29uc3QgZ2V0V2hvYW1pID0gKGlucHV0KSA9PiByZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9xdWVyeS93aG9hbWlcIixcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG59KTtcbi8qKlxuICogUmVxdWVzdCBhIFdlYkF1dGhuIGFzc2VydGlvbiBhbmQgcmV0dXJuIGEgc2lnbmVkIGBHZXRXaG9hbWlgIHJlcXVlc3QsIHJlYWR5IHRvIGJlIFBPU1RlZCB0byBUdXJua2V5LlxuICpcbiAqIFNlZSB7QGxpbmsgR2V0V2hvYW1pfVxuICovXG5jb25zdCBzaWduR2V0V2hvYW1pID0gKGlucHV0LCBvcHRpb25zKSA9PiBzaWduZWRSZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9xdWVyeS93aG9hbWlcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxuICAgIG9wdGlvbnMsXG59KTtcbi8qKlxuICogQXBwcm92ZSBBY3Rpdml0eVxuICpcbiAqIEFwcHJvdmUgYW4gQWN0aXZpdHlcbiAqXG4gKiBgUE9TVCAvcHVibGljL3YxL3N1Ym1pdC9hcHByb3ZlX2FjdGl2aXR5YFxuICovXG5jb25zdCBhcHByb3ZlQWN0aXZpdHkgPSAoaW5wdXQpID0+IHJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3N1Ym1pdC9hcHByb3ZlX2FjdGl2aXR5XCIsXG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxufSk7XG4vKipcbiAqIFJlcXVlc3QgYSBXZWJBdXRobiBhc3NlcnRpb24gYW5kIHJldHVybiBhIHNpZ25lZCBgQXBwcm92ZUFjdGl2aXR5YCByZXF1ZXN0LCByZWFkeSB0byBiZSBQT1NUZWQgdG8gVHVybmtleS5cbiAqXG4gKiBTZWUge0BsaW5rIEFwcHJvdmVBY3Rpdml0eX1cbiAqL1xuY29uc3Qgc2lnbkFwcHJvdmVBY3Rpdml0eSA9IChpbnB1dCwgb3B0aW9ucykgPT4gc2lnbmVkUmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvc3VibWl0L2FwcHJvdmVfYWN0aXZpdHlcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxuICAgIG9wdGlvbnMsXG59KTtcbi8qKlxuICogQ3JlYXRlIEFQSSBLZXlzXG4gKlxuICogQWRkIGFwaSBrZXlzIHRvIGFuIGV4aXN0aW5nIFVzZXJcbiAqXG4gKiBgUE9TVCAvcHVibGljL3YxL3N1Ym1pdC9jcmVhdGVfYXBpX2tleXNgXG4gKi9cbmNvbnN0IGNyZWF0ZUFwaUtleXMgPSAoaW5wdXQpID0+IHJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3N1Ym1pdC9jcmVhdGVfYXBpX2tleXNcIixcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG59KTtcbi8qKlxuICogUmVxdWVzdCBhIFdlYkF1dGhuIGFzc2VydGlvbiBhbmQgcmV0dXJuIGEgc2lnbmVkIGBDcmVhdGVBcGlLZXlzYCByZXF1ZXN0LCByZWFkeSB0byBiZSBQT1NUZWQgdG8gVHVybmtleS5cbiAqXG4gKiBTZWUge0BsaW5rIENyZWF0ZUFwaUtleXN9XG4gKi9cbmNvbnN0IHNpZ25DcmVhdGVBcGlLZXlzID0gKGlucHV0LCBvcHRpb25zKSA9PiBzaWduZWRSZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9zdWJtaXQvY3JlYXRlX2FwaV9rZXlzXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbiAgICBvcHRpb25zLFxufSk7XG4vKipcbiAqIENyZWF0ZSBBUEktb25seSBVc2Vyc1xuICpcbiAqIENyZWF0ZSBBUEktb25seSBVc2VycyBpbiBhbiBleGlzdGluZyBPcmdhbml6YXRpb25cbiAqXG4gKiBgUE9TVCAvcHVibGljL3YxL3N1Ym1pdC9jcmVhdGVfYXBpX29ubHlfdXNlcnNgXG4gKi9cbmNvbnN0IGNyZWF0ZUFwaU9ubHlVc2VycyA9IChpbnB1dCkgPT4gcmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvc3VibWl0L2NyZWF0ZV9hcGlfb25seV91c2Vyc1wiLFxuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbn0pO1xuLyoqXG4gKiBSZXF1ZXN0IGEgV2ViQXV0aG4gYXNzZXJ0aW9uIGFuZCByZXR1cm4gYSBzaWduZWQgYENyZWF0ZUFwaU9ubHlVc2Vyc2AgcmVxdWVzdCwgcmVhZHkgdG8gYmUgUE9TVGVkIHRvIFR1cm5rZXkuXG4gKlxuICogU2VlIHtAbGluayBDcmVhdGVBcGlPbmx5VXNlcnN9XG4gKi9cbmNvbnN0IHNpZ25DcmVhdGVBcGlPbmx5VXNlcnMgPSAoaW5wdXQsIG9wdGlvbnMpID0+IHNpZ25lZFJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3N1Ym1pdC9jcmVhdGVfYXBpX29ubHlfdXNlcnNcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxuICAgIG9wdGlvbnMsXG59KTtcbi8qKlxuICogQ3JlYXRlIEF1dGhlbnRpY2F0b3JzXG4gKlxuICogQ3JlYXRlIEF1dGhlbnRpY2F0b3JzIHRvIGF1dGhlbnRpY2F0ZSByZXF1ZXN0cyB0byBUdXJua2V5XG4gKlxuICogYFBPU1QgL3B1YmxpYy92MS9zdWJtaXQvY3JlYXRlX2F1dGhlbnRpY2F0b3JzYFxuICovXG5jb25zdCBjcmVhdGVBdXRoZW50aWNhdG9ycyA9IChpbnB1dCkgPT4gcmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvc3VibWl0L2NyZWF0ZV9hdXRoZW50aWNhdG9yc1wiLFxuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbn0pO1xuLyoqXG4gKiBSZXF1ZXN0IGEgV2ViQXV0aG4gYXNzZXJ0aW9uIGFuZCByZXR1cm4gYSBzaWduZWQgYENyZWF0ZUF1dGhlbnRpY2F0b3JzYCByZXF1ZXN0LCByZWFkeSB0byBiZSBQT1NUZWQgdG8gVHVybmtleS5cbiAqXG4gKiBTZWUge0BsaW5rIENyZWF0ZUF1dGhlbnRpY2F0b3JzfVxuICovXG5jb25zdCBzaWduQ3JlYXRlQXV0aGVudGljYXRvcnMgPSAoaW5wdXQsIG9wdGlvbnMpID0+IHNpZ25lZFJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3N1Ym1pdC9jcmVhdGVfYXV0aGVudGljYXRvcnNcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxuICAgIG9wdGlvbnMsXG59KTtcbi8qKlxuICogQ3JlYXRlIEludml0YXRpb25zXG4gKlxuICogQ3JlYXRlIEludml0YXRpb25zIHRvIGpvaW4gYW4gZXhpc3RpbmcgT3JnYW5pemF0aW9uXG4gKlxuICogYFBPU1QgL3B1YmxpYy92MS9zdWJtaXQvY3JlYXRlX2ludml0YXRpb25zYFxuICovXG5jb25zdCBjcmVhdGVJbnZpdGF0aW9ucyA9IChpbnB1dCkgPT4gcmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvc3VibWl0L2NyZWF0ZV9pbnZpdGF0aW9uc1wiLFxuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbn0pO1xuLyoqXG4gKiBSZXF1ZXN0IGEgV2ViQXV0aG4gYXNzZXJ0aW9uIGFuZCByZXR1cm4gYSBzaWduZWQgYENyZWF0ZUludml0YXRpb25zYCByZXF1ZXN0LCByZWFkeSB0byBiZSBQT1NUZWQgdG8gVHVybmtleS5cbiAqXG4gKiBTZWUge0BsaW5rIENyZWF0ZUludml0YXRpb25zfVxuICovXG5jb25zdCBzaWduQ3JlYXRlSW52aXRhdGlvbnMgPSAoaW5wdXQsIG9wdGlvbnMpID0+IHNpZ25lZFJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3N1Ym1pdC9jcmVhdGVfaW52aXRhdGlvbnNcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxuICAgIG9wdGlvbnMsXG59KTtcbi8qKlxuICogQ3JlYXRlIFBvbGljaWVzXG4gKlxuICogQ3JlYXRlIG5ldyBQb2xpY2llc1xuICpcbiAqIGBQT1NUIC9wdWJsaWMvdjEvc3VibWl0L2NyZWF0ZV9wb2xpY2llc2BcbiAqL1xuY29uc3QgY3JlYXRlUG9saWNpZXMgPSAoaW5wdXQpID0+IHJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3N1Ym1pdC9jcmVhdGVfcG9saWNpZXNcIixcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG59KTtcbi8qKlxuICogUmVxdWVzdCBhIFdlYkF1dGhuIGFzc2VydGlvbiBhbmQgcmV0dXJuIGEgc2lnbmVkIGBDcmVhdGVQb2xpY2llc2AgcmVxdWVzdCwgcmVhZHkgdG8gYmUgUE9TVGVkIHRvIFR1cm5rZXkuXG4gKlxuICogU2VlIHtAbGluayBDcmVhdGVQb2xpY2llc31cbiAqL1xuY29uc3Qgc2lnbkNyZWF0ZVBvbGljaWVzID0gKGlucHV0LCBvcHRpb25zKSA9PiBzaWduZWRSZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9zdWJtaXQvY3JlYXRlX3BvbGljaWVzXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbiAgICBvcHRpb25zLFxufSk7XG4vKipcbiAqIENyZWF0ZSBQb2xpY3lcbiAqXG4gKiBDcmVhdGUgYSBuZXcgUG9saWN5XG4gKlxuICogYFBPU1QgL3B1YmxpYy92MS9zdWJtaXQvY3JlYXRlX3BvbGljeWBcbiAqL1xuY29uc3QgY3JlYXRlUG9saWN5ID0gKGlucHV0KSA9PiByZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9zdWJtaXQvY3JlYXRlX3BvbGljeVwiLFxuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbn0pO1xuLyoqXG4gKiBSZXF1ZXN0IGEgV2ViQXV0aG4gYXNzZXJ0aW9uIGFuZCByZXR1cm4gYSBzaWduZWQgYENyZWF0ZVBvbGljeWAgcmVxdWVzdCwgcmVhZHkgdG8gYmUgUE9TVGVkIHRvIFR1cm5rZXkuXG4gKlxuICogU2VlIHtAbGluayBDcmVhdGVQb2xpY3l9XG4gKi9cbmNvbnN0IHNpZ25DcmVhdGVQb2xpY3kgPSAoaW5wdXQsIG9wdGlvbnMpID0+IHNpZ25lZFJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3N1Ym1pdC9jcmVhdGVfcG9saWN5XCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbiAgICBvcHRpb25zLFxufSk7XG4vKipcbiAqIENyZWF0ZSBQcml2YXRlIEtleSBUYWdcbiAqXG4gKiBDcmVhdGUgYSBwcml2YXRlIGtleSB0YWcgYW5kIGFkZCBpdCB0byBwcml2YXRlIGtleXMuXG4gKlxuICogYFBPU1QgL3B1YmxpYy92MS9zdWJtaXQvY3JlYXRlX3ByaXZhdGVfa2V5X3RhZ2BcbiAqL1xuY29uc3QgY3JlYXRlUHJpdmF0ZUtleVRhZyA9IChpbnB1dCkgPT4gcmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvc3VibWl0L2NyZWF0ZV9wcml2YXRlX2tleV90YWdcIixcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG59KTtcbi8qKlxuICogUmVxdWVzdCBhIFdlYkF1dGhuIGFzc2VydGlvbiBhbmQgcmV0dXJuIGEgc2lnbmVkIGBDcmVhdGVQcml2YXRlS2V5VGFnYCByZXF1ZXN0LCByZWFkeSB0byBiZSBQT1NUZWQgdG8gVHVybmtleS5cbiAqXG4gKiBTZWUge0BsaW5rIENyZWF0ZVByaXZhdGVLZXlUYWd9XG4gKi9cbmNvbnN0IHNpZ25DcmVhdGVQcml2YXRlS2V5VGFnID0gKGlucHV0LCBvcHRpb25zKSA9PiBzaWduZWRSZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9zdWJtaXQvY3JlYXRlX3ByaXZhdGVfa2V5X3RhZ1wiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG4gICAgb3B0aW9ucyxcbn0pO1xuLyoqXG4gKiBDcmVhdGUgUHJpdmF0ZSBLZXlzXG4gKlxuICogQ3JlYXRlIG5ldyBQcml2YXRlIEtleXNcbiAqXG4gKiBgUE9TVCAvcHVibGljL3YxL3N1Ym1pdC9jcmVhdGVfcHJpdmF0ZV9rZXlzYFxuICovXG5jb25zdCBjcmVhdGVQcml2YXRlS2V5cyA9IChpbnB1dCkgPT4gcmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvc3VibWl0L2NyZWF0ZV9wcml2YXRlX2tleXNcIixcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG59KTtcbi8qKlxuICogUmVxdWVzdCBhIFdlYkF1dGhuIGFzc2VydGlvbiBhbmQgcmV0dXJuIGEgc2lnbmVkIGBDcmVhdGVQcml2YXRlS2V5c2AgcmVxdWVzdCwgcmVhZHkgdG8gYmUgUE9TVGVkIHRvIFR1cm5rZXkuXG4gKlxuICogU2VlIHtAbGluayBDcmVhdGVQcml2YXRlS2V5c31cbiAqL1xuY29uc3Qgc2lnbkNyZWF0ZVByaXZhdGVLZXlzID0gKGlucHV0LCBvcHRpb25zKSA9PiBzaWduZWRSZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9zdWJtaXQvY3JlYXRlX3ByaXZhdGVfa2V5c1wiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG4gICAgb3B0aW9ucyxcbn0pO1xuLyoqXG4gKiBDcmVhdGUgU3ViLU9yZ2FuaXphdGlvblxuICpcbiAqIENyZWF0ZSBhIG5ldyBTdWItT3JnYW5pemF0aW9uXG4gKlxuICogYFBPU1QgL3B1YmxpYy92MS9zdWJtaXQvY3JlYXRlX3N1Yl9vcmdhbml6YXRpb25gXG4gKi9cbmNvbnN0IGNyZWF0ZVN1Yk9yZ2FuaXphdGlvbiA9IChpbnB1dCkgPT4gcmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvc3VibWl0L2NyZWF0ZV9zdWJfb3JnYW5pemF0aW9uXCIsXG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxufSk7XG4vKipcbiAqIFJlcXVlc3QgYSBXZWJBdXRobiBhc3NlcnRpb24gYW5kIHJldHVybiBhIHNpZ25lZCBgQ3JlYXRlU3ViT3JnYW5pemF0aW9uYCByZXF1ZXN0LCByZWFkeSB0byBiZSBQT1NUZWQgdG8gVHVybmtleS5cbiAqXG4gKiBTZWUge0BsaW5rIENyZWF0ZVN1Yk9yZ2FuaXphdGlvbn1cbiAqL1xuY29uc3Qgc2lnbkNyZWF0ZVN1Yk9yZ2FuaXphdGlvbiA9IChpbnB1dCwgb3B0aW9ucykgPT4gc2lnbmVkUmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvc3VibWl0L2NyZWF0ZV9zdWJfb3JnYW5pemF0aW9uXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbiAgICBvcHRpb25zLFxufSk7XG4vKipcbiAqIENyZWF0ZSBVc2VyIFRhZ1xuICpcbiAqIENyZWF0ZSBhIHVzZXIgdGFnIGFuZCBhZGQgaXQgdG8gdXNlcnMuXG4gKlxuICogYFBPU1QgL3B1YmxpYy92MS9zdWJtaXQvY3JlYXRlX3VzZXJfdGFnYFxuICovXG5jb25zdCBjcmVhdGVVc2VyVGFnID0gKGlucHV0KSA9PiByZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9zdWJtaXQvY3JlYXRlX3VzZXJfdGFnXCIsXG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxufSk7XG4vKipcbiAqIFJlcXVlc3QgYSBXZWJBdXRobiBhc3NlcnRpb24gYW5kIHJldHVybiBhIHNpZ25lZCBgQ3JlYXRlVXNlclRhZ2AgcmVxdWVzdCwgcmVhZHkgdG8gYmUgUE9TVGVkIHRvIFR1cm5rZXkuXG4gKlxuICogU2VlIHtAbGluayBDcmVhdGVVc2VyVGFnfVxuICovXG5jb25zdCBzaWduQ3JlYXRlVXNlclRhZyA9IChpbnB1dCwgb3B0aW9ucykgPT4gc2lnbmVkUmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvc3VibWl0L2NyZWF0ZV91c2VyX3RhZ1wiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG4gICAgb3B0aW9ucyxcbn0pO1xuLyoqXG4gKiBDcmVhdGUgVXNlcnNcbiAqXG4gKiBDcmVhdGUgVXNlcnMgaW4gYW4gZXhpc3RpbmcgT3JnYW5pemF0aW9uXG4gKlxuICogYFBPU1QgL3B1YmxpYy92MS9zdWJtaXQvY3JlYXRlX3VzZXJzYFxuICovXG5jb25zdCBjcmVhdGVVc2VycyA9IChpbnB1dCkgPT4gcmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvc3VibWl0L2NyZWF0ZV91c2Vyc1wiLFxuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbn0pO1xuLyoqXG4gKiBSZXF1ZXN0IGEgV2ViQXV0aG4gYXNzZXJ0aW9uIGFuZCByZXR1cm4gYSBzaWduZWQgYENyZWF0ZVVzZXJzYCByZXF1ZXN0LCByZWFkeSB0byBiZSBQT1NUZWQgdG8gVHVybmtleS5cbiAqXG4gKiBTZWUge0BsaW5rIENyZWF0ZVVzZXJzfVxuICovXG5jb25zdCBzaWduQ3JlYXRlVXNlcnMgPSAoaW5wdXQsIG9wdGlvbnMpID0+IHNpZ25lZFJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3N1Ym1pdC9jcmVhdGVfdXNlcnNcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxuICAgIG9wdGlvbnMsXG59KTtcbi8qKlxuICogQ3JlYXRlIFdhbGxldFxuICpcbiAqIENyZWF0ZSBhIFdhbGxldCBhbmQgZGVyaXZlIGFkZHJlc3Nlc1xuICpcbiAqIGBQT1NUIC9wdWJsaWMvdjEvc3VibWl0L2NyZWF0ZV93YWxsZXRgXG4gKi9cbmNvbnN0IGNyZWF0ZVdhbGxldCA9IChpbnB1dCkgPT4gcmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvc3VibWl0L2NyZWF0ZV93YWxsZXRcIixcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG59KTtcbi8qKlxuICogUmVxdWVzdCBhIFdlYkF1dGhuIGFzc2VydGlvbiBhbmQgcmV0dXJuIGEgc2lnbmVkIGBDcmVhdGVXYWxsZXRgIHJlcXVlc3QsIHJlYWR5IHRvIGJlIFBPU1RlZCB0byBUdXJua2V5LlxuICpcbiAqIFNlZSB7QGxpbmsgQ3JlYXRlV2FsbGV0fVxuICovXG5jb25zdCBzaWduQ3JlYXRlV2FsbGV0ID0gKGlucHV0LCBvcHRpb25zKSA9PiBzaWduZWRSZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9zdWJtaXQvY3JlYXRlX3dhbGxldFwiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG4gICAgb3B0aW9ucyxcbn0pO1xuLyoqXG4gKiBDcmVhdGUgV2FsbGV0IEFjY291bnRzXG4gKlxuICogRGVyaXZlIGFkZGl0aW9uYWwgYWRkcmVzc2VzIHVzaW5nIGFuIGV4aXN0aW5nIHdhbGxldFxuICpcbiAqIGBQT1NUIC9wdWJsaWMvdjEvc3VibWl0L2NyZWF0ZV93YWxsZXRfYWNjb3VudHNgXG4gKi9cbmNvbnN0IGNyZWF0ZVdhbGxldEFjY291bnRzID0gKGlucHV0KSA9PiByZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9zdWJtaXQvY3JlYXRlX3dhbGxldF9hY2NvdW50c1wiLFxuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbn0pO1xuLyoqXG4gKiBSZXF1ZXN0IGEgV2ViQXV0aG4gYXNzZXJ0aW9uIGFuZCByZXR1cm4gYSBzaWduZWQgYENyZWF0ZVdhbGxldEFjY291bnRzYCByZXF1ZXN0LCByZWFkeSB0byBiZSBQT1NUZWQgdG8gVHVybmtleS5cbiAqXG4gKiBTZWUge0BsaW5rIENyZWF0ZVdhbGxldEFjY291bnRzfVxuICovXG5jb25zdCBzaWduQ3JlYXRlV2FsbGV0QWNjb3VudHMgPSAoaW5wdXQsIG9wdGlvbnMpID0+IHNpZ25lZFJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3N1Ym1pdC9jcmVhdGVfd2FsbGV0X2FjY291bnRzXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbiAgICBvcHRpb25zLFxufSk7XG4vKipcbiAqIERlbGV0ZSBBUEkgS2V5c1xuICpcbiAqIFJlbW92ZSBhcGkga2V5cyBmcm9tIGEgVXNlclxuICpcbiAqIGBQT1NUIC9wdWJsaWMvdjEvc3VibWl0L2RlbGV0ZV9hcGlfa2V5c2BcbiAqL1xuY29uc3QgZGVsZXRlQXBpS2V5cyA9IChpbnB1dCkgPT4gcmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvc3VibWl0L2RlbGV0ZV9hcGlfa2V5c1wiLFxuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbn0pO1xuLyoqXG4gKiBSZXF1ZXN0IGEgV2ViQXV0aG4gYXNzZXJ0aW9uIGFuZCByZXR1cm4gYSBzaWduZWQgYERlbGV0ZUFwaUtleXNgIHJlcXVlc3QsIHJlYWR5IHRvIGJlIFBPU1RlZCB0byBUdXJua2V5LlxuICpcbiAqIFNlZSB7QGxpbmsgRGVsZXRlQXBpS2V5c31cbiAqL1xuY29uc3Qgc2lnbkRlbGV0ZUFwaUtleXMgPSAoaW5wdXQsIG9wdGlvbnMpID0+IHNpZ25lZFJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3N1Ym1pdC9kZWxldGVfYXBpX2tleXNcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxuICAgIG9wdGlvbnMsXG59KTtcbi8qKlxuICogRGVsZXRlIEF1dGhlbnRpY2F0b3JzXG4gKlxuICogUmVtb3ZlIGF1dGhlbnRpY2F0b3JzIGZyb20gYSBVc2VyXG4gKlxuICogYFBPU1QgL3B1YmxpYy92MS9zdWJtaXQvZGVsZXRlX2F1dGhlbnRpY2F0b3JzYFxuICovXG5jb25zdCBkZWxldGVBdXRoZW50aWNhdG9ycyA9IChpbnB1dCkgPT4gcmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvc3VibWl0L2RlbGV0ZV9hdXRoZW50aWNhdG9yc1wiLFxuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbn0pO1xuLyoqXG4gKiBSZXF1ZXN0IGEgV2ViQXV0aG4gYXNzZXJ0aW9uIGFuZCByZXR1cm4gYSBzaWduZWQgYERlbGV0ZUF1dGhlbnRpY2F0b3JzYCByZXF1ZXN0LCByZWFkeSB0byBiZSBQT1NUZWQgdG8gVHVybmtleS5cbiAqXG4gKiBTZWUge0BsaW5rIERlbGV0ZUF1dGhlbnRpY2F0b3JzfVxuICovXG5jb25zdCBzaWduRGVsZXRlQXV0aGVudGljYXRvcnMgPSAoaW5wdXQsIG9wdGlvbnMpID0+IHNpZ25lZFJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3N1Ym1pdC9kZWxldGVfYXV0aGVudGljYXRvcnNcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxuICAgIG9wdGlvbnMsXG59KTtcbi8qKlxuICogRGVsZXRlIEludml0YXRpb25cbiAqXG4gKiBEZWxldGUgYW4gZXhpc3RpbmcgSW52aXRhdGlvblxuICpcbiAqIGBQT1NUIC9wdWJsaWMvdjEvc3VibWl0L2RlbGV0ZV9pbnZpdGF0aW9uYFxuICovXG5jb25zdCBkZWxldGVJbnZpdGF0aW9uID0gKGlucHV0KSA9PiByZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9zdWJtaXQvZGVsZXRlX2ludml0YXRpb25cIixcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG59KTtcbi8qKlxuICogUmVxdWVzdCBhIFdlYkF1dGhuIGFzc2VydGlvbiBhbmQgcmV0dXJuIGEgc2lnbmVkIGBEZWxldGVJbnZpdGF0aW9uYCByZXF1ZXN0LCByZWFkeSB0byBiZSBQT1NUZWQgdG8gVHVybmtleS5cbiAqXG4gKiBTZWUge0BsaW5rIERlbGV0ZUludml0YXRpb259XG4gKi9cbmNvbnN0IHNpZ25EZWxldGVJbnZpdGF0aW9uID0gKGlucHV0LCBvcHRpb25zKSA9PiBzaWduZWRSZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9zdWJtaXQvZGVsZXRlX2ludml0YXRpb25cIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxuICAgIG9wdGlvbnMsXG59KTtcbi8qKlxuICogRGVsZXRlIFBvbGljeVxuICpcbiAqIERlbGV0ZSBhbiBleGlzdGluZyBQb2xpY3lcbiAqXG4gKiBgUE9TVCAvcHVibGljL3YxL3N1Ym1pdC9kZWxldGVfcG9saWN5YFxuICovXG5jb25zdCBkZWxldGVQb2xpY3kgPSAoaW5wdXQpID0+IHJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3N1Ym1pdC9kZWxldGVfcG9saWN5XCIsXG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxufSk7XG4vKipcbiAqIFJlcXVlc3QgYSBXZWJBdXRobiBhc3NlcnRpb24gYW5kIHJldHVybiBhIHNpZ25lZCBgRGVsZXRlUG9saWN5YCByZXF1ZXN0LCByZWFkeSB0byBiZSBQT1NUZWQgdG8gVHVybmtleS5cbiAqXG4gKiBTZWUge0BsaW5rIERlbGV0ZVBvbGljeX1cbiAqL1xuY29uc3Qgc2lnbkRlbGV0ZVBvbGljeSA9IChpbnB1dCwgb3B0aW9ucykgPT4gc2lnbmVkUmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvc3VibWl0L2RlbGV0ZV9wb2xpY3lcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxuICAgIG9wdGlvbnMsXG59KTtcbi8qKlxuICogRGVsZXRlIFByaXZhdGUgS2V5IFRhZ3NcbiAqXG4gKiBEZWxldGUgUHJpdmF0ZSBLZXkgVGFncyB3aXRoaW4gYW4gT3JnYW5pemF0aW9uXG4gKlxuICogYFBPU1QgL3B1YmxpYy92MS9zdWJtaXQvZGVsZXRlX3ByaXZhdGVfa2V5X3RhZ3NgXG4gKi9cbmNvbnN0IGRlbGV0ZVByaXZhdGVLZXlUYWdzID0gKGlucHV0KSA9PiByZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9zdWJtaXQvZGVsZXRlX3ByaXZhdGVfa2V5X3RhZ3NcIixcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG59KTtcbi8qKlxuICogUmVxdWVzdCBhIFdlYkF1dGhuIGFzc2VydGlvbiBhbmQgcmV0dXJuIGEgc2lnbmVkIGBEZWxldGVQcml2YXRlS2V5VGFnc2AgcmVxdWVzdCwgcmVhZHkgdG8gYmUgUE9TVGVkIHRvIFR1cm5rZXkuXG4gKlxuICogU2VlIHtAbGluayBEZWxldGVQcml2YXRlS2V5VGFnc31cbiAqL1xuY29uc3Qgc2lnbkRlbGV0ZVByaXZhdGVLZXlUYWdzID0gKGlucHV0LCBvcHRpb25zKSA9PiBzaWduZWRSZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9zdWJtaXQvZGVsZXRlX3ByaXZhdGVfa2V5X3RhZ3NcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxuICAgIG9wdGlvbnMsXG59KTtcbi8qKlxuICogRGVsZXRlIFVzZXIgVGFnc1xuICpcbiAqIERlbGV0ZSBVc2VyIFRhZ3Mgd2l0aGluIGFuIE9yZ2FuaXphdGlvblxuICpcbiAqIGBQT1NUIC9wdWJsaWMvdjEvc3VibWl0L2RlbGV0ZV91c2VyX3RhZ3NgXG4gKi9cbmNvbnN0IGRlbGV0ZVVzZXJUYWdzID0gKGlucHV0KSA9PiByZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9zdWJtaXQvZGVsZXRlX3VzZXJfdGFnc1wiLFxuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbn0pO1xuLyoqXG4gKiBSZXF1ZXN0IGEgV2ViQXV0aG4gYXNzZXJ0aW9uIGFuZCByZXR1cm4gYSBzaWduZWQgYERlbGV0ZVVzZXJUYWdzYCByZXF1ZXN0LCByZWFkeSB0byBiZSBQT1NUZWQgdG8gVHVybmtleS5cbiAqXG4gKiBTZWUge0BsaW5rIERlbGV0ZVVzZXJUYWdzfVxuICovXG5jb25zdCBzaWduRGVsZXRlVXNlclRhZ3MgPSAoaW5wdXQsIG9wdGlvbnMpID0+IHNpZ25lZFJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3N1Ym1pdC9kZWxldGVfdXNlcl90YWdzXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbiAgICBvcHRpb25zLFxufSk7XG4vKipcbiAqIERlbGV0ZSBVc2Vyc1xuICpcbiAqIERlbGV0ZSBVc2VycyB3aXRoaW4gYW4gT3JnYW5pemF0aW9uXG4gKlxuICogYFBPU1QgL3B1YmxpYy92MS9zdWJtaXQvZGVsZXRlX3VzZXJzYFxuICovXG5jb25zdCBkZWxldGVVc2VycyA9IChpbnB1dCkgPT4gcmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvc3VibWl0L2RlbGV0ZV91c2Vyc1wiLFxuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbn0pO1xuLyoqXG4gKiBSZXF1ZXN0IGEgV2ViQXV0aG4gYXNzZXJ0aW9uIGFuZCByZXR1cm4gYSBzaWduZWQgYERlbGV0ZVVzZXJzYCByZXF1ZXN0LCByZWFkeSB0byBiZSBQT1NUZWQgdG8gVHVybmtleS5cbiAqXG4gKiBTZWUge0BsaW5rIERlbGV0ZVVzZXJzfVxuICovXG5jb25zdCBzaWduRGVsZXRlVXNlcnMgPSAoaW5wdXQsIG9wdGlvbnMpID0+IHNpZ25lZFJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3N1Ym1pdC9kZWxldGVfdXNlcnNcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxuICAgIG9wdGlvbnMsXG59KTtcbi8qKlxuICogUGVyZm9ybSBFbWFpbCBBdXRoXG4gKlxuICogQXV0aGVudGljYXRlIGEgdXNlciB2aWEgRW1haWxcbiAqXG4gKiBgUE9TVCAvcHVibGljL3YxL3N1Ym1pdC9lbWFpbF9hdXRoYFxuICovXG5jb25zdCBlbWFpbEF1dGggPSAoaW5wdXQpID0+IHJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3N1Ym1pdC9lbWFpbF9hdXRoXCIsXG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxufSk7XG4vKipcbiAqIFJlcXVlc3QgYSBXZWJBdXRobiBhc3NlcnRpb24gYW5kIHJldHVybiBhIHNpZ25lZCBgRW1haWxBdXRoYCByZXF1ZXN0LCByZWFkeSB0byBiZSBQT1NUZWQgdG8gVHVybmtleS5cbiAqXG4gKiBTZWUge0BsaW5rIEVtYWlsQXV0aH1cbiAqL1xuY29uc3Qgc2lnbkVtYWlsQXV0aCA9IChpbnB1dCwgb3B0aW9ucykgPT4gc2lnbmVkUmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvc3VibWl0L2VtYWlsX2F1dGhcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxuICAgIG9wdGlvbnMsXG59KTtcbi8qKlxuICogRXhwb3J0IFByaXZhdGUgS2V5XG4gKlxuICogRXhwb3J0cyBhIFByaXZhdGUgS2V5XG4gKlxuICogYFBPU1QgL3B1YmxpYy92MS9zdWJtaXQvZXhwb3J0X3ByaXZhdGVfa2V5YFxuICovXG5jb25zdCBleHBvcnRQcml2YXRlS2V5ID0gKGlucHV0KSA9PiByZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9zdWJtaXQvZXhwb3J0X3ByaXZhdGVfa2V5XCIsXG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxufSk7XG4vKipcbiAqIFJlcXVlc3QgYSBXZWJBdXRobiBhc3NlcnRpb24gYW5kIHJldHVybiBhIHNpZ25lZCBgRXhwb3J0UHJpdmF0ZUtleWAgcmVxdWVzdCwgcmVhZHkgdG8gYmUgUE9TVGVkIHRvIFR1cm5rZXkuXG4gKlxuICogU2VlIHtAbGluayBFeHBvcnRQcml2YXRlS2V5fVxuICovXG5jb25zdCBzaWduRXhwb3J0UHJpdmF0ZUtleSA9IChpbnB1dCwgb3B0aW9ucykgPT4gc2lnbmVkUmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvc3VibWl0L2V4cG9ydF9wcml2YXRlX2tleVwiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG4gICAgb3B0aW9ucyxcbn0pO1xuLyoqXG4gKiBFeHBvcnQgV2FsbGV0XG4gKlxuICogRXhwb3J0cyBhIFdhbGxldFxuICpcbiAqIGBQT1NUIC9wdWJsaWMvdjEvc3VibWl0L2V4cG9ydF93YWxsZXRgXG4gKi9cbmNvbnN0IGV4cG9ydFdhbGxldCA9IChpbnB1dCkgPT4gcmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvc3VibWl0L2V4cG9ydF93YWxsZXRcIixcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG59KTtcbi8qKlxuICogUmVxdWVzdCBhIFdlYkF1dGhuIGFzc2VydGlvbiBhbmQgcmV0dXJuIGEgc2lnbmVkIGBFeHBvcnRXYWxsZXRgIHJlcXVlc3QsIHJlYWR5IHRvIGJlIFBPU1RlZCB0byBUdXJua2V5LlxuICpcbiAqIFNlZSB7QGxpbmsgRXhwb3J0V2FsbGV0fVxuICovXG5jb25zdCBzaWduRXhwb3J0V2FsbGV0ID0gKGlucHV0LCBvcHRpb25zKSA9PiBzaWduZWRSZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9zdWJtaXQvZXhwb3J0X3dhbGxldFwiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG4gICAgb3B0aW9ucyxcbn0pO1xuLyoqXG4gKiBFeHBvcnQgV2FsbGV0IEFjY291bnRcbiAqXG4gKiBFeHBvcnRzIGEgV2FsbGV0IEFjY291bnRcbiAqXG4gKiBgUE9TVCAvcHVibGljL3YxL3N1Ym1pdC9leHBvcnRfd2FsbGV0X2FjY291bnRgXG4gKi9cbmNvbnN0IGV4cG9ydFdhbGxldEFjY291bnQgPSAoaW5wdXQpID0+IHJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3N1Ym1pdC9leHBvcnRfd2FsbGV0X2FjY291bnRcIixcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG59KTtcbi8qKlxuICogUmVxdWVzdCBhIFdlYkF1dGhuIGFzc2VydGlvbiBhbmQgcmV0dXJuIGEgc2lnbmVkIGBFeHBvcnRXYWxsZXRBY2NvdW50YCByZXF1ZXN0LCByZWFkeSB0byBiZSBQT1NUZWQgdG8gVHVybmtleS5cbiAqXG4gKiBTZWUge0BsaW5rIEV4cG9ydFdhbGxldEFjY291bnR9XG4gKi9cbmNvbnN0IHNpZ25FeHBvcnRXYWxsZXRBY2NvdW50ID0gKGlucHV0LCBvcHRpb25zKSA9PiBzaWduZWRSZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9zdWJtaXQvZXhwb3J0X3dhbGxldF9hY2NvdW50XCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbiAgICBvcHRpb25zLFxufSk7XG4vKipcbiAqIEltcG9ydCBQcml2YXRlIEtleVxuICpcbiAqIEltcG9ydHMgYSBwcml2YXRlIGtleVxuICpcbiAqIGBQT1NUIC9wdWJsaWMvdjEvc3VibWl0L2ltcG9ydF9wcml2YXRlX2tleWBcbiAqL1xuY29uc3QgaW1wb3J0UHJpdmF0ZUtleSA9IChpbnB1dCkgPT4gcmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvc3VibWl0L2ltcG9ydF9wcml2YXRlX2tleVwiLFxuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbn0pO1xuLyoqXG4gKiBSZXF1ZXN0IGEgV2ViQXV0aG4gYXNzZXJ0aW9uIGFuZCByZXR1cm4gYSBzaWduZWQgYEltcG9ydFByaXZhdGVLZXlgIHJlcXVlc3QsIHJlYWR5IHRvIGJlIFBPU1RlZCB0byBUdXJua2V5LlxuICpcbiAqIFNlZSB7QGxpbmsgSW1wb3J0UHJpdmF0ZUtleX1cbiAqL1xuY29uc3Qgc2lnbkltcG9ydFByaXZhdGVLZXkgPSAoaW5wdXQsIG9wdGlvbnMpID0+IHNpZ25lZFJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3N1Ym1pdC9pbXBvcnRfcHJpdmF0ZV9rZXlcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxuICAgIG9wdGlvbnMsXG59KTtcbi8qKlxuICogSW1wb3J0IFdhbGxldFxuICpcbiAqIEltcG9ydHMgYSB3YWxsZXRcbiAqXG4gKiBgUE9TVCAvcHVibGljL3YxL3N1Ym1pdC9pbXBvcnRfd2FsbGV0YFxuICovXG5jb25zdCBpbXBvcnRXYWxsZXQgPSAoaW5wdXQpID0+IHJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3N1Ym1pdC9pbXBvcnRfd2FsbGV0XCIsXG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxufSk7XG4vKipcbiAqIFJlcXVlc3QgYSBXZWJBdXRobiBhc3NlcnRpb24gYW5kIHJldHVybiBhIHNpZ25lZCBgSW1wb3J0V2FsbGV0YCByZXF1ZXN0LCByZWFkeSB0byBiZSBQT1NUZWQgdG8gVHVybmtleS5cbiAqXG4gKiBTZWUge0BsaW5rIEltcG9ydFdhbGxldH1cbiAqL1xuY29uc3Qgc2lnbkltcG9ydFdhbGxldCA9IChpbnB1dCwgb3B0aW9ucykgPT4gc2lnbmVkUmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvc3VibWl0L2ltcG9ydF93YWxsZXRcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxuICAgIG9wdGlvbnMsXG59KTtcbi8qKlxuICogSW5pdCBJbXBvcnQgUHJpdmF0ZSBLZXlcbiAqXG4gKiBJbml0aWFsaXplcyBhIG5ldyBwcml2YXRlIGtleSBpbXBvcnRcbiAqXG4gKiBgUE9TVCAvcHVibGljL3YxL3N1Ym1pdC9pbml0X2ltcG9ydF9wcml2YXRlX2tleWBcbiAqL1xuY29uc3QgaW5pdEltcG9ydFByaXZhdGVLZXkgPSAoaW5wdXQpID0+IHJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3N1Ym1pdC9pbml0X2ltcG9ydF9wcml2YXRlX2tleVwiLFxuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbn0pO1xuLyoqXG4gKiBSZXF1ZXN0IGEgV2ViQXV0aG4gYXNzZXJ0aW9uIGFuZCByZXR1cm4gYSBzaWduZWQgYEluaXRJbXBvcnRQcml2YXRlS2V5YCByZXF1ZXN0LCByZWFkeSB0byBiZSBQT1NUZWQgdG8gVHVybmtleS5cbiAqXG4gKiBTZWUge0BsaW5rIEluaXRJbXBvcnRQcml2YXRlS2V5fVxuICovXG5jb25zdCBzaWduSW5pdEltcG9ydFByaXZhdGVLZXkgPSAoaW5wdXQsIG9wdGlvbnMpID0+IHNpZ25lZFJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3N1Ym1pdC9pbml0X2ltcG9ydF9wcml2YXRlX2tleVwiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG4gICAgb3B0aW9ucyxcbn0pO1xuLyoqXG4gKiBJbml0IEltcG9ydCBXYWxsZXRcbiAqXG4gKiBJbml0aWFsaXplcyBhIG5ldyB3YWxsZXQgaW1wb3J0XG4gKlxuICogYFBPU1QgL3B1YmxpYy92MS9zdWJtaXQvaW5pdF9pbXBvcnRfd2FsbGV0YFxuICovXG5jb25zdCBpbml0SW1wb3J0V2FsbGV0ID0gKGlucHV0KSA9PiByZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9zdWJtaXQvaW5pdF9pbXBvcnRfd2FsbGV0XCIsXG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxufSk7XG4vKipcbiAqIFJlcXVlc3QgYSBXZWJBdXRobiBhc3NlcnRpb24gYW5kIHJldHVybiBhIHNpZ25lZCBgSW5pdEltcG9ydFdhbGxldGAgcmVxdWVzdCwgcmVhZHkgdG8gYmUgUE9TVGVkIHRvIFR1cm5rZXkuXG4gKlxuICogU2VlIHtAbGluayBJbml0SW1wb3J0V2FsbGV0fVxuICovXG5jb25zdCBzaWduSW5pdEltcG9ydFdhbGxldCA9IChpbnB1dCwgb3B0aW9ucykgPT4gc2lnbmVkUmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvc3VibWl0L2luaXRfaW1wb3J0X3dhbGxldFwiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG4gICAgb3B0aW9ucyxcbn0pO1xuLyoqXG4gKiBJbml0IEVtYWlsIFJlY292ZXJ5XG4gKlxuICogSW5pdGlhbGl6ZXMgYSBuZXcgZW1haWwgcmVjb3ZlcnlcbiAqXG4gKiBgUE9TVCAvcHVibGljL3YxL3N1Ym1pdC9pbml0X3VzZXJfZW1haWxfcmVjb3ZlcnlgXG4gKi9cbmNvbnN0IGluaXRVc2VyRW1haWxSZWNvdmVyeSA9IChpbnB1dCkgPT4gcmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvc3VibWl0L2luaXRfdXNlcl9lbWFpbF9yZWNvdmVyeVwiLFxuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbn0pO1xuLyoqXG4gKiBSZXF1ZXN0IGEgV2ViQXV0aG4gYXNzZXJ0aW9uIGFuZCByZXR1cm4gYSBzaWduZWQgYEluaXRVc2VyRW1haWxSZWNvdmVyeWAgcmVxdWVzdCwgcmVhZHkgdG8gYmUgUE9TVGVkIHRvIFR1cm5rZXkuXG4gKlxuICogU2VlIHtAbGluayBJbml0VXNlckVtYWlsUmVjb3Zlcnl9XG4gKi9cbmNvbnN0IHNpZ25Jbml0VXNlckVtYWlsUmVjb3ZlcnkgPSAoaW5wdXQsIG9wdGlvbnMpID0+IHNpZ25lZFJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3N1Ym1pdC9pbml0X3VzZXJfZW1haWxfcmVjb3ZlcnlcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxuICAgIG9wdGlvbnMsXG59KTtcbi8qKlxuICogUmVjb3ZlciBhIHVzZXJcbiAqXG4gKiBDb21wbGV0ZXMgdGhlIHByb2Nlc3Mgb2YgcmVjb3ZlcmluZyBhIHVzZXIgYnkgYWRkaW5nIGFuIGF1dGhlbnRpY2F0b3JcbiAqXG4gKiBgUE9TVCAvcHVibGljL3YxL3N1Ym1pdC9yZWNvdmVyX3VzZXJgXG4gKi9cbmNvbnN0IHJlY292ZXJVc2VyID0gKGlucHV0KSA9PiByZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9zdWJtaXQvcmVjb3Zlcl91c2VyXCIsXG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxufSk7XG4vKipcbiAqIFJlcXVlc3QgYSBXZWJBdXRobiBhc3NlcnRpb24gYW5kIHJldHVybiBhIHNpZ25lZCBgUmVjb3ZlclVzZXJgIHJlcXVlc3QsIHJlYWR5IHRvIGJlIFBPU1RlZCB0byBUdXJua2V5LlxuICpcbiAqIFNlZSB7QGxpbmsgUmVjb3ZlclVzZXJ9XG4gKi9cbmNvbnN0IHNpZ25SZWNvdmVyVXNlciA9IChpbnB1dCwgb3B0aW9ucykgPT4gc2lnbmVkUmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvc3VibWl0L3JlY292ZXJfdXNlclwiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG4gICAgb3B0aW9ucyxcbn0pO1xuLyoqXG4gKiBSZWplY3QgQWN0aXZpdHlcbiAqXG4gKiBSZWplY3QgYW4gQWN0aXZpdHlcbiAqXG4gKiBgUE9TVCAvcHVibGljL3YxL3N1Ym1pdC9yZWplY3RfYWN0aXZpdHlgXG4gKi9cbmNvbnN0IHJlamVjdEFjdGl2aXR5ID0gKGlucHV0KSA9PiByZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9zdWJtaXQvcmVqZWN0X2FjdGl2aXR5XCIsXG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxufSk7XG4vKipcbiAqIFJlcXVlc3QgYSBXZWJBdXRobiBhc3NlcnRpb24gYW5kIHJldHVybiBhIHNpZ25lZCBgUmVqZWN0QWN0aXZpdHlgIHJlcXVlc3QsIHJlYWR5IHRvIGJlIFBPU1RlZCB0byBUdXJua2V5LlxuICpcbiAqIFNlZSB7QGxpbmsgUmVqZWN0QWN0aXZpdHl9XG4gKi9cbmNvbnN0IHNpZ25SZWplY3RBY3Rpdml0eSA9IChpbnB1dCwgb3B0aW9ucykgPT4gc2lnbmVkUmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvc3VibWl0L3JlamVjdF9hY3Rpdml0eVwiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG4gICAgb3B0aW9ucyxcbn0pO1xuLyoqXG4gKiBSZW1vdmUgT3JnYW5pemF0aW9uIEZlYXR1cmVcbiAqXG4gKiBSZW1vdmVzIGFuIG9yZ2FuaXphdGlvbiBmZWF0dXJlXG4gKlxuICogYFBPU1QgL3B1YmxpYy92MS9zdWJtaXQvcmVtb3ZlX29yZ2FuaXphdGlvbl9mZWF0dXJlYFxuICovXG5jb25zdCByZW1vdmVPcmdhbml6YXRpb25GZWF0dXJlID0gKGlucHV0KSA9PiByZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9zdWJtaXQvcmVtb3ZlX29yZ2FuaXphdGlvbl9mZWF0dXJlXCIsXG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxufSk7XG4vKipcbiAqIFJlcXVlc3QgYSBXZWJBdXRobiBhc3NlcnRpb24gYW5kIHJldHVybiBhIHNpZ25lZCBgUmVtb3ZlT3JnYW5pemF0aW9uRmVhdHVyZWAgcmVxdWVzdCwgcmVhZHkgdG8gYmUgUE9TVGVkIHRvIFR1cm5rZXkuXG4gKlxuICogU2VlIHtAbGluayBSZW1vdmVPcmdhbml6YXRpb25GZWF0dXJlfVxuICovXG5jb25zdCBzaWduUmVtb3ZlT3JnYW5pemF0aW9uRmVhdHVyZSA9IChpbnB1dCwgb3B0aW9ucykgPT4gc2lnbmVkUmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvc3VibWl0L3JlbW92ZV9vcmdhbml6YXRpb25fZmVhdHVyZVwiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG4gICAgb3B0aW9ucyxcbn0pO1xuLyoqXG4gKiBTZXQgT3JnYW5pemF0aW9uIEZlYXR1cmVcbiAqXG4gKiBTZXRzIGFuIG9yZ2FuaXphdGlvbiBmZWF0dXJlXG4gKlxuICogYFBPU1QgL3B1YmxpYy92MS9zdWJtaXQvc2V0X29yZ2FuaXphdGlvbl9mZWF0dXJlYFxuICovXG5jb25zdCBzZXRPcmdhbml6YXRpb25GZWF0dXJlID0gKGlucHV0KSA9PiByZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9zdWJtaXQvc2V0X29yZ2FuaXphdGlvbl9mZWF0dXJlXCIsXG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxufSk7XG4vKipcbiAqIFJlcXVlc3QgYSBXZWJBdXRobiBhc3NlcnRpb24gYW5kIHJldHVybiBhIHNpZ25lZCBgU2V0T3JnYW5pemF0aW9uRmVhdHVyZWAgcmVxdWVzdCwgcmVhZHkgdG8gYmUgUE9TVGVkIHRvIFR1cm5rZXkuXG4gKlxuICogU2VlIHtAbGluayBTZXRPcmdhbml6YXRpb25GZWF0dXJlfVxuICovXG5jb25zdCBzaWduU2V0T3JnYW5pemF0aW9uRmVhdHVyZSA9IChpbnB1dCwgb3B0aW9ucykgPT4gc2lnbmVkUmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvc3VibWl0L3NldF9vcmdhbml6YXRpb25fZmVhdHVyZVwiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG4gICAgb3B0aW9ucyxcbn0pO1xuLyoqXG4gKiBTaWduIFJhdyBQYXlsb2FkXG4gKlxuICogU2lnbiBhIHJhdyBwYXlsb2FkXG4gKlxuICogYFBPU1QgL3B1YmxpYy92MS9zdWJtaXQvc2lnbl9yYXdfcGF5bG9hZGBcbiAqL1xuY29uc3Qgc2lnblJhd1BheWxvYWQgPSAoaW5wdXQpID0+IHJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3N1Ym1pdC9zaWduX3Jhd19wYXlsb2FkXCIsXG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxufSk7XG4vKipcbiAqIFJlcXVlc3QgYSBXZWJBdXRobiBhc3NlcnRpb24gYW5kIHJldHVybiBhIHNpZ25lZCBgU2lnblJhd1BheWxvYWRgIHJlcXVlc3QsIHJlYWR5IHRvIGJlIFBPU1RlZCB0byBUdXJua2V5LlxuICpcbiAqIFNlZSB7QGxpbmsgU2lnblJhd1BheWxvYWR9XG4gKi9cbmNvbnN0IHNpZ25TaWduUmF3UGF5bG9hZCA9IChpbnB1dCwgb3B0aW9ucykgPT4gc2lnbmVkUmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvc3VibWl0L3NpZ25fcmF3X3BheWxvYWRcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxuICAgIG9wdGlvbnMsXG59KTtcbi8qKlxuICogU2lnbiBSYXcgUGF5bG9hZHNcbiAqXG4gKiBTaWduIG11bHRpcGxlIHJhdyBwYXlsb2FkcyB3aXRoIHRoZSBzYW1lIHNpZ25pbmcgcGFyYW1ldGVyc1xuICpcbiAqIGBQT1NUIC9wdWJsaWMvdjEvc3VibWl0L3NpZ25fcmF3X3BheWxvYWRzYFxuICovXG5jb25zdCBzaWduUmF3UGF5bG9hZHMgPSAoaW5wdXQpID0+IHJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3N1Ym1pdC9zaWduX3Jhd19wYXlsb2Fkc1wiLFxuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbn0pO1xuLyoqXG4gKiBSZXF1ZXN0IGEgV2ViQXV0aG4gYXNzZXJ0aW9uIGFuZCByZXR1cm4gYSBzaWduZWQgYFNpZ25SYXdQYXlsb2Fkc2AgcmVxdWVzdCwgcmVhZHkgdG8gYmUgUE9TVGVkIHRvIFR1cm5rZXkuXG4gKlxuICogU2VlIHtAbGluayBTaWduUmF3UGF5bG9hZHN9XG4gKi9cbmNvbnN0IHNpZ25TaWduUmF3UGF5bG9hZHMgPSAoaW5wdXQsIG9wdGlvbnMpID0+IHNpZ25lZFJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3N1Ym1pdC9zaWduX3Jhd19wYXlsb2Fkc1wiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG4gICAgb3B0aW9ucyxcbn0pO1xuLyoqXG4gKiBTaWduIFRyYW5zYWN0aW9uXG4gKlxuICogU2lnbiBhIHRyYW5zYWN0aW9uXG4gKlxuICogYFBPU1QgL3B1YmxpYy92MS9zdWJtaXQvc2lnbl90cmFuc2FjdGlvbmBcbiAqL1xuY29uc3Qgc2lnblRyYW5zYWN0aW9uID0gKGlucHV0KSA9PiByZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9zdWJtaXQvc2lnbl90cmFuc2FjdGlvblwiLFxuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbn0pO1xuLyoqXG4gKiBSZXF1ZXN0IGEgV2ViQXV0aG4gYXNzZXJ0aW9uIGFuZCByZXR1cm4gYSBzaWduZWQgYFNpZ25UcmFuc2FjdGlvbmAgcmVxdWVzdCwgcmVhZHkgdG8gYmUgUE9TVGVkIHRvIFR1cm5rZXkuXG4gKlxuICogU2VlIHtAbGluayBTaWduVHJhbnNhY3Rpb259XG4gKi9cbmNvbnN0IHNpZ25TaWduVHJhbnNhY3Rpb24gPSAoaW5wdXQsIG9wdGlvbnMpID0+IHNpZ25lZFJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3N1Ym1pdC9zaWduX3RyYW5zYWN0aW9uXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbiAgICBvcHRpb25zLFxufSk7XG4vKipcbiAqIFVwZGF0ZSBQb2xpY3lcbiAqXG4gKiBVcGRhdGUgYW4gZXhpc3RpbmcgUG9saWN5XG4gKlxuICogYFBPU1QgL3B1YmxpYy92MS9zdWJtaXQvdXBkYXRlX3BvbGljeWBcbiAqL1xuY29uc3QgdXBkYXRlUG9saWN5ID0gKGlucHV0KSA9PiByZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9zdWJtaXQvdXBkYXRlX3BvbGljeVwiLFxuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbn0pO1xuLyoqXG4gKiBSZXF1ZXN0IGEgV2ViQXV0aG4gYXNzZXJ0aW9uIGFuZCByZXR1cm4gYSBzaWduZWQgYFVwZGF0ZVBvbGljeWAgcmVxdWVzdCwgcmVhZHkgdG8gYmUgUE9TVGVkIHRvIFR1cm5rZXkuXG4gKlxuICogU2VlIHtAbGluayBVcGRhdGVQb2xpY3l9XG4gKi9cbmNvbnN0IHNpZ25VcGRhdGVQb2xpY3kgPSAoaW5wdXQsIG9wdGlvbnMpID0+IHNpZ25lZFJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3N1Ym1pdC91cGRhdGVfcG9saWN5XCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbiAgICBvcHRpb25zLFxufSk7XG4vKipcbiAqIFVwZGF0ZSBQcml2YXRlIEtleSBUYWdcbiAqXG4gKiBVcGRhdGUgaHVtYW4tcmVhZGFibGUgbmFtZSBvciBhc3NvY2lhdGVkIHByaXZhdGUga2V5cy4gTm90ZSB0aGF0IHRoaXMgYWN0aXZpdHkgaXMgYXRvbWljOiBhbGwgb2YgdGhlIHVwZGF0ZXMgd2lsbCBzdWNjZWVkIGF0IG9uY2UsIG9yIGFsbCBvZiB0aGVtIHdpbGwgZmFpbC5cbiAqXG4gKiBgUE9TVCAvcHVibGljL3YxL3N1Ym1pdC91cGRhdGVfcHJpdmF0ZV9rZXlfdGFnYFxuICovXG5jb25zdCB1cGRhdGVQcml2YXRlS2V5VGFnID0gKGlucHV0KSA9PiByZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9zdWJtaXQvdXBkYXRlX3ByaXZhdGVfa2V5X3RhZ1wiLFxuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbn0pO1xuLyoqXG4gKiBSZXF1ZXN0IGEgV2ViQXV0aG4gYXNzZXJ0aW9uIGFuZCByZXR1cm4gYSBzaWduZWQgYFVwZGF0ZVByaXZhdGVLZXlUYWdgIHJlcXVlc3QsIHJlYWR5IHRvIGJlIFBPU1RlZCB0byBUdXJua2V5LlxuICpcbiAqIFNlZSB7QGxpbmsgVXBkYXRlUHJpdmF0ZUtleVRhZ31cbiAqL1xuY29uc3Qgc2lnblVwZGF0ZVByaXZhdGVLZXlUYWcgPSAoaW5wdXQsIG9wdGlvbnMpID0+IHNpZ25lZFJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3N1Ym1pdC91cGRhdGVfcHJpdmF0ZV9rZXlfdGFnXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbiAgICBvcHRpb25zLFxufSk7XG4vKipcbiAqIFVwZGF0ZSBSb290IFF1b3J1bVxuICpcbiAqIFNldCB0aGUgdGhyZXNob2xkIGFuZCBtZW1iZXJzIG9mIHRoZSByb290IHF1b3J1bS4gVGhpcyBtdXN0IGJlIGFwcHJvdmVkIGJ5IHRoZSBjdXJyZW50IHJvb3QgcXVvcnVtLlxuICpcbiAqIGBQT1NUIC9wdWJsaWMvdjEvc3VibWl0L3VwZGF0ZV9yb290X3F1b3J1bWBcbiAqL1xuY29uc3QgdXBkYXRlUm9vdFF1b3J1bSA9IChpbnB1dCkgPT4gcmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvc3VibWl0L3VwZGF0ZV9yb290X3F1b3J1bVwiLFxuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbn0pO1xuLyoqXG4gKiBSZXF1ZXN0IGEgV2ViQXV0aG4gYXNzZXJ0aW9uIGFuZCByZXR1cm4gYSBzaWduZWQgYFVwZGF0ZVJvb3RRdW9ydW1gIHJlcXVlc3QsIHJlYWR5IHRvIGJlIFBPU1RlZCB0byBUdXJua2V5LlxuICpcbiAqIFNlZSB7QGxpbmsgVXBkYXRlUm9vdFF1b3J1bX1cbiAqL1xuY29uc3Qgc2lnblVwZGF0ZVJvb3RRdW9ydW0gPSAoaW5wdXQsIG9wdGlvbnMpID0+IHNpZ25lZFJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3N1Ym1pdC91cGRhdGVfcm9vdF9xdW9ydW1cIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxuICAgIG9wdGlvbnMsXG59KTtcbi8qKlxuICogVXBkYXRlIFVzZXJcbiAqXG4gKiBVcGRhdGUgYSBVc2VyIGluIGFuIGV4aXN0aW5nIE9yZ2FuaXphdGlvblxuICpcbiAqIGBQT1NUIC9wdWJsaWMvdjEvc3VibWl0L3VwZGF0ZV91c2VyYFxuICovXG5jb25zdCB1cGRhdGVVc2VyID0gKGlucHV0KSA9PiByZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9zdWJtaXQvdXBkYXRlX3VzZXJcIixcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG59KTtcbi8qKlxuICogUmVxdWVzdCBhIFdlYkF1dGhuIGFzc2VydGlvbiBhbmQgcmV0dXJuIGEgc2lnbmVkIGBVcGRhdGVVc2VyYCByZXF1ZXN0LCByZWFkeSB0byBiZSBQT1NUZWQgdG8gVHVybmtleS5cbiAqXG4gKiBTZWUge0BsaW5rIFVwZGF0ZVVzZXJ9XG4gKi9cbmNvbnN0IHNpZ25VcGRhdGVVc2VyID0gKGlucHV0LCBvcHRpb25zKSA9PiBzaWduZWRSZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9zdWJtaXQvdXBkYXRlX3VzZXJcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxuICAgIG9wdGlvbnMsXG59KTtcbi8qKlxuICogVXBkYXRlIFVzZXIgVGFnXG4gKlxuICogVXBkYXRlIGh1bWFuLXJlYWRhYmxlIG5hbWUgb3IgYXNzb2NpYXRlZCB1c2Vycy4gTm90ZSB0aGF0IHRoaXMgYWN0aXZpdHkgaXMgYXRvbWljOiBhbGwgb2YgdGhlIHVwZGF0ZXMgd2lsbCBzdWNjZWVkIGF0IG9uY2UsIG9yIGFsbCBvZiB0aGVtIHdpbGwgZmFpbC5cbiAqXG4gKiBgUE9TVCAvcHVibGljL3YxL3N1Ym1pdC91cGRhdGVfdXNlcl90YWdgXG4gKi9cbmNvbnN0IHVwZGF0ZVVzZXJUYWcgPSAoaW5wdXQpID0+IHJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3N1Ym1pdC91cGRhdGVfdXNlcl90YWdcIixcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG59KTtcbi8qKlxuICogUmVxdWVzdCBhIFdlYkF1dGhuIGFzc2VydGlvbiBhbmQgcmV0dXJuIGEgc2lnbmVkIGBVcGRhdGVVc2VyVGFnYCByZXF1ZXN0LCByZWFkeSB0byBiZSBQT1NUZWQgdG8gVHVybmtleS5cbiAqXG4gKiBTZWUge0BsaW5rIFVwZGF0ZVVzZXJUYWd9XG4gKi9cbmNvbnN0IHNpZ25VcGRhdGVVc2VyVGFnID0gKGlucHV0LCBvcHRpb25zKSA9PiBzaWduZWRSZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9zdWJtaXQvdXBkYXRlX3VzZXJfdGFnXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbiAgICBvcHRpb25zLFxufSk7XG4vKipcbiAqIGBQT1NUIC90a2hxL2FwaS92MS9ub29wLWNvZGVnZW4tYW5jaG9yYFxuICovXG5jb25zdCBuT09QQ29kZWdlbkFuY2hvciA9ICgpID0+IHJlcXVlc3Qoe1xuICAgIHVyaTogXCIvdGtocS9hcGkvdjEvbm9vcC1jb2RlZ2VuLWFuY2hvclwiLFxuICAgIG1ldGhvZDogXCJQT1NUXCIsXG59KTtcbi8qKlxuICogUmVxdWVzdCBhIFdlYkF1dGhuIGFzc2VydGlvbiBhbmQgcmV0dXJuIGEgc2lnbmVkIGBOT09QQ29kZWdlbkFuY2hvcmAgcmVxdWVzdCwgcmVhZHkgdG8gYmUgUE9TVGVkIHRvIFR1cm5rZXkuXG4gKlxuICogU2VlIHtAbGluayBOT09QQ29kZWdlbkFuY2hvcn1cbiAqL1xuY29uc3Qgc2lnbk5PT1BDb2RlZ2VuQW5jaG9yID0gKCkgPT4gc2lnbmVkUmVxdWVzdCh7XG4gICAgdXJpOiBcIi90a2hxL2FwaS92MS9ub29wLWNvZGVnZW4tYW5jaG9yXCIsXG59KTtcblxuZXhwb3J0IHsgYXBwcm92ZUFjdGl2aXR5LCBjcmVhdGVBcGlLZXlzLCBjcmVhdGVBcGlPbmx5VXNlcnMsIGNyZWF0ZUF1dGhlbnRpY2F0b3JzLCBjcmVhdGVJbnZpdGF0aW9ucywgY3JlYXRlUG9saWNpZXMsIGNyZWF0ZVBvbGljeSwgY3JlYXRlUHJpdmF0ZUtleVRhZywgY3JlYXRlUHJpdmF0ZUtleXMsIGNyZWF0ZVN1Yk9yZ2FuaXphdGlvbiwgY3JlYXRlVXNlclRhZywgY3JlYXRlVXNlcnMsIGNyZWF0ZVdhbGxldCwgY3JlYXRlV2FsbGV0QWNjb3VudHMsIGRlbGV0ZUFwaUtleXMsIGRlbGV0ZUF1dGhlbnRpY2F0b3JzLCBkZWxldGVJbnZpdGF0aW9uLCBkZWxldGVQb2xpY3ksIGRlbGV0ZVByaXZhdGVLZXlUYWdzLCBkZWxldGVVc2VyVGFncywgZGVsZXRlVXNlcnMsIGVtYWlsQXV0aCwgZXhwb3J0UHJpdmF0ZUtleSwgZXhwb3J0V2FsbGV0LCBleHBvcnRXYWxsZXRBY2NvdW50LCBnZXRBY3Rpdml0aWVzLCBnZXRBY3Rpdml0eSwgZ2V0QXBpS2V5LCBnZXRBcGlLZXlzLCBnZXRBdXRoZW50aWNhdG9yLCBnZXRBdXRoZW50aWNhdG9ycywgZ2V0T3JnYW5pemF0aW9uLCBnZXRQb2xpY2llcywgZ2V0UG9saWN5LCBnZXRQcml2YXRlS2V5LCBnZXRQcml2YXRlS2V5cywgZ2V0U3ViT3JnSWRzLCBnZXRVc2VyLCBnZXRVc2VycywgZ2V0V2FsbGV0LCBnZXRXYWxsZXRBY2NvdW50cywgZ2V0V2FsbGV0cywgZ2V0V2hvYW1pLCBpbXBvcnRQcml2YXRlS2V5LCBpbXBvcnRXYWxsZXQsIGluaXRJbXBvcnRQcml2YXRlS2V5LCBpbml0SW1wb3J0V2FsbGV0LCBpbml0VXNlckVtYWlsUmVjb3ZlcnksIGxpc3RQcml2YXRlS2V5VGFncywgbGlzdFVzZXJUYWdzLCBuT09QQ29kZWdlbkFuY2hvciwgcmVjb3ZlclVzZXIsIHJlamVjdEFjdGl2aXR5LCByZW1vdmVPcmdhbml6YXRpb25GZWF0dXJlLCBzZXRPcmdhbml6YXRpb25GZWF0dXJlLCBzaWduQXBwcm92ZUFjdGl2aXR5LCBzaWduQ3JlYXRlQXBpS2V5cywgc2lnbkNyZWF0ZUFwaU9ubHlVc2Vycywgc2lnbkNyZWF0ZUF1dGhlbnRpY2F0b3JzLCBzaWduQ3JlYXRlSW52aXRhdGlvbnMsIHNpZ25DcmVhdGVQb2xpY2llcywgc2lnbkNyZWF0ZVBvbGljeSwgc2lnbkNyZWF0ZVByaXZhdGVLZXlUYWcsIHNpZ25DcmVhdGVQcml2YXRlS2V5cywgc2lnbkNyZWF0ZVN1Yk9yZ2FuaXphdGlvbiwgc2lnbkNyZWF0ZVVzZXJUYWcsIHNpZ25DcmVhdGVVc2Vycywgc2lnbkNyZWF0ZVdhbGxldCwgc2lnbkNyZWF0ZVdhbGxldEFjY291bnRzLCBzaWduRGVsZXRlQXBpS2V5cywgc2lnbkRlbGV0ZUF1dGhlbnRpY2F0b3JzLCBzaWduRGVsZXRlSW52aXRhdGlvbiwgc2lnbkRlbGV0ZVBvbGljeSwgc2lnbkRlbGV0ZVByaXZhdGVLZXlUYWdzLCBzaWduRGVsZXRlVXNlclRhZ3MsIHNpZ25EZWxldGVVc2Vycywgc2lnbkVtYWlsQXV0aCwgc2lnbkV4cG9ydFByaXZhdGVLZXksIHNpZ25FeHBvcnRXYWxsZXQsIHNpZ25FeHBvcnRXYWxsZXRBY2NvdW50LCBzaWduR2V0QWN0aXZpdGllcywgc2lnbkdldEFjdGl2aXR5LCBzaWduR2V0QXBpS2V5LCBzaWduR2V0QXBpS2V5cywgc2lnbkdldEF1dGhlbnRpY2F0b3IsIHNpZ25HZXRBdXRoZW50aWNhdG9ycywgc2lnbkdldE9yZ2FuaXphdGlvbiwgc2lnbkdldFBvbGljaWVzLCBzaWduR2V0UG9saWN5LCBzaWduR2V0UHJpdmF0ZUtleSwgc2lnbkdldFByaXZhdGVLZXlzLCBzaWduR2V0U3ViT3JnSWRzLCBzaWduR2V0VXNlciwgc2lnbkdldFVzZXJzLCBzaWduR2V0V2FsbGV0LCBzaWduR2V0V2FsbGV0QWNjb3VudHMsIHNpZ25HZXRXYWxsZXRzLCBzaWduR2V0V2hvYW1pLCBzaWduSW1wb3J0UHJpdmF0ZUtleSwgc2lnbkltcG9ydFdhbGxldCwgc2lnbkluaXRJbXBvcnRQcml2YXRlS2V5LCBzaWduSW5pdEltcG9ydFdhbGxldCwgc2lnbkluaXRVc2VyRW1haWxSZWNvdmVyeSwgc2lnbkxpc3RQcml2YXRlS2V5VGFncywgc2lnbkxpc3RVc2VyVGFncywgc2lnbk5PT1BDb2RlZ2VuQW5jaG9yLCBzaWduUmF3UGF5bG9hZCwgc2lnblJhd1BheWxvYWRzLCBzaWduUmVjb3ZlclVzZXIsIHNpZ25SZWplY3RBY3Rpdml0eSwgc2lnblJlbW92ZU9yZ2FuaXphdGlvbkZlYXR1cmUsIHNpZ25TZXRPcmdhbml6YXRpb25GZWF0dXJlLCBzaWduU2lnblJhd1BheWxvYWQsIHNpZ25TaWduUmF3UGF5bG9hZHMsIHNpZ25TaWduVHJhbnNhY3Rpb24sIHNpZ25UcmFuc2FjdGlvbiwgc2lnblVwZGF0ZVBvbGljeSwgc2lnblVwZGF0ZVByaXZhdGVLZXlUYWcsIHNpZ25VcGRhdGVSb290UXVvcnVtLCBzaWduVXBkYXRlVXNlciwgc2lnblVwZGF0ZVVzZXJUYWcsIHVwZGF0ZVBvbGljeSwgdXBkYXRlUHJpdmF0ZUtleVRhZywgdXBkYXRlUm9vdFF1b3J1bSwgdXBkYXRlVXNlciwgdXBkYXRlVXNlclRhZyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHVibGljX2FwaS5mZXRjaGVyLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/http/dist/__generated__/services/coordinator/public/v1/public_api.fetcher.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/http/dist/async.mjs":
/*!***************************************************!*\
  !*** ./node_modules/@turnkey/http/dist/async.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createActivityPoller: () => (/* binding */ createActivityPoller),\n/* harmony export */   withAsyncPolling: () => (/* binding */ withAsyncPolling)\n/* harmony export */ });\n/* harmony import */ var _generated_services_coordinator_public_v1_public_api_fetcher_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./__generated__/services/coordinator/public/v1/public_api.fetcher.mjs */ \"(ssr)/./node_modules/@turnkey/http/dist/__generated__/services/coordinator/public/v1/public_api.fetcher.mjs\");\n/* harmony import */ var _shared_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shared.mjs */ \"(ssr)/./node_modules/@turnkey/http/dist/shared.mjs\");\n\n\n\nconst DEFAULT_REFRESH_INTERVAL_MS = 500;\n/**\n * Wraps a request to create a fetcher with built-in async polling support.\n *\n * @deprecated this function only works with {@link TurnkeyApi}.\n * Use {@link TurnkeyClient} and {@link createActivityPoller} instead.\n */\nfunction withAsyncPolling(params) {\n    const { request, refreshIntervalMs = DEFAULT_REFRESH_INTERVAL_MS } = params;\n    return async (input) => {\n        const initialResponse = await request(input);\n        let activity = initialResponse.activity;\n        while (true) {\n            switch (activity.status) {\n                case \"ACTIVITY_STATUS_COMPLETED\": {\n                    return activity;\n                }\n                case \"ACTIVITY_STATUS_CREATED\": {\n                    // Async pending state -- keep polling\n                    break;\n                }\n                case \"ACTIVITY_STATUS_PENDING\": {\n                    // Async pending state -- keep polling\n                    break;\n                }\n                case \"ACTIVITY_STATUS_CONSENSUS_NEEDED\": {\n                    // If the activity requires consensus, we shouldn't be polling forever.\n                    // You can read the `TurnkeyActivityError` thrown to get the `activityId`,\n                    // store it somewhere, then re-fetch the activity via `.postGetActivity(...)`\n                    // when the required approvals/rejections are in place.\n                    throw new _shared_mjs__WEBPACK_IMPORTED_MODULE_1__.TurnkeyActivityError({\n                        message: `Consensus needed for activity ${activity.id}`,\n                        activityId: activity.id,\n                        activityStatus: activity.status,\n                        activityType: activity.type,\n                    });\n                }\n                case \"ACTIVITY_STATUS_FAILED\": {\n                    // Activity failed\n                    throw new _shared_mjs__WEBPACK_IMPORTED_MODULE_1__.TurnkeyActivityError({\n                        message: `Activity ${activity.id} failed`,\n                        activityId: activity.id,\n                        activityStatus: activity.status,\n                        activityType: activity.type,\n                    });\n                }\n                case \"ACTIVITY_STATUS_REJECTED\": {\n                    // Activity was rejected\n                    throw new _shared_mjs__WEBPACK_IMPORTED_MODULE_1__.TurnkeyActivityError({\n                        message: `Activity ${activity.id} was rejected`,\n                        activityId: activity.id,\n                        activityStatus: activity.status,\n                        activityType: activity.type,\n                    });\n                }\n                default: {\n                    // Make sure the switch block is exhaustive\n                    assertNever(activity.status);\n                }\n            }\n            await sleep(refreshIntervalMs);\n            const pollingResponse = await (0,_generated_services_coordinator_public_v1_public_api_fetcher_mjs__WEBPACK_IMPORTED_MODULE_0__.getActivity)({\n                body: {\n                    activityId: activity.id,\n                    organizationId: activity.organizationId,\n                },\n            });\n            activity = pollingResponse.activity;\n        }\n    };\n}\n/**\n * Wraps a client request function (e.g. `client.createPrivateKeys`) in a poller.\n * The default refresh interval is 500ms.\n *\n * The returned poller will poll until the activity becomes `COMPLETED`.\n * If the activity becomes `FAILED` or `REJECTED` or is flagged as `NEEDS_CONSENSUS`, an error is thrown.\n *\n * @example\n * const activityPoller = createActivityPoller(client, client.createPrivateKeys);\n * const activity = await activityPoller(input);\n * console.log(activity.result); // activity is completed\n */\nfunction createActivityPoller(params) {\n    const { client, requestFn, refreshIntervalMs = DEFAULT_REFRESH_INTERVAL_MS, } = params;\n    return async (input) => {\n        const initialResponse = await requestFn(input);\n        let activity = initialResponse.activity;\n        while (true) {\n            switch (activity.status) {\n                case \"ACTIVITY_STATUS_COMPLETED\": {\n                    return activity;\n                }\n                case \"ACTIVITY_STATUS_CREATED\": {\n                    // Async pending state -- keep polling\n                    break;\n                }\n                case \"ACTIVITY_STATUS_PENDING\": {\n                    // Async pending state -- keep polling\n                    break;\n                }\n                case \"ACTIVITY_STATUS_CONSENSUS_NEEDED\": {\n                    // If the activity requires consensus, we shouldn't be polling forever.\n                    // You can read the `TurnkeyActivityError` thrown to get the `activityId`,\n                    // store it somewhere, then re-fetch the activity via `.postGetActivity(...)`\n                    // when the required approvals/rejections are in place.\n                    throw new _shared_mjs__WEBPACK_IMPORTED_MODULE_1__.TurnkeyActivityError({\n                        message: `Consensus needed for activity ${activity.id}`,\n                        activityId: activity.id,\n                        activityStatus: activity.status,\n                        activityType: activity.type,\n                    });\n                }\n                case \"ACTIVITY_STATUS_FAILED\": {\n                    // Activity failed\n                    throw new _shared_mjs__WEBPACK_IMPORTED_MODULE_1__.TurnkeyActivityError({\n                        message: `Activity ${activity.id} failed`,\n                        activityId: activity.id,\n                        activityStatus: activity.status,\n                        activityType: activity.type,\n                    });\n                }\n                case \"ACTIVITY_STATUS_REJECTED\": {\n                    // Activity was rejected\n                    throw new _shared_mjs__WEBPACK_IMPORTED_MODULE_1__.TurnkeyActivityError({\n                        message: `Activity ${activity.id} was rejected`,\n                        activityId: activity.id,\n                        activityStatus: activity.status,\n                        activityType: activity.type,\n                    });\n                }\n                default: {\n                    // Make sure the switch block is exhaustive\n                    assertNever(activity.status);\n                }\n            }\n            await sleep(refreshIntervalMs);\n            const pollingResponse = await client.getActivity({\n                activityId: activity.id,\n                organizationId: activity.organizationId,\n            });\n            activity = pollingResponse.activity;\n        }\n    };\n}\nfunction sleep(ms) {\n    return new Promise((resolve) => {\n        setTimeout(() => {\n            resolve();\n        }, ms);\n    });\n}\nfunction assertNever(input, message) {\n    throw new Error(message != null ? message : `Unexpected case: ${JSON.stringify(input)}`);\n}\n\n\n//# sourceMappingURL=async.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvaHR0cC9kaXN0L2FzeW5jLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQW9HO0FBQ2hEOztBQUVwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxpQkFBaUI7QUFDL0QsUUFBUSxxQkFBcUIsS0FBSyw0QkFBNEI7QUFDOUQ7QUFDQTtBQUNBLFlBQVksMkRBQTJEO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw2REFBb0I7QUFDbEQsa0VBQWtFLFlBQVk7QUFDOUU7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw2REFBb0I7QUFDbEQsNkNBQTZDLGFBQWE7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw2REFBb0I7QUFDbEQsNkNBQTZDLGFBQWE7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDZHQUFXO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsWUFBWSxzRUFBc0U7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDZEQUFvQjtBQUNsRCxrRUFBa0UsWUFBWTtBQUM5RTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDZEQUFvQjtBQUNsRCw2Q0FBNkMsYUFBYTtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDZEQUFvQjtBQUNsRCw2Q0FBNkMsYUFBYTtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBLG9FQUFvRSxzQkFBc0I7QUFDMUY7O0FBRWtEO0FBQ2xEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbnVyc2VibG9jLy4vbm9kZV9tb2R1bGVzL0B0dXJua2V5L2h0dHAvZGlzdC9hc3luYy5tanM/MDhhMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRBY3Rpdml0eSB9IGZyb20gJy4vX19nZW5lcmF0ZWRfXy9zZXJ2aWNlcy9jb29yZGluYXRvci9wdWJsaWMvdjEvcHVibGljX2FwaS5mZXRjaGVyLm1qcyc7XG5pbXBvcnQgeyBUdXJua2V5QWN0aXZpdHlFcnJvciB9IGZyb20gJy4vc2hhcmVkLm1qcyc7XG5cbmNvbnN0IERFRkFVTFRfUkVGUkVTSF9JTlRFUlZBTF9NUyA9IDUwMDtcbi8qKlxuICogV3JhcHMgYSByZXF1ZXN0IHRvIGNyZWF0ZSBhIGZldGNoZXIgd2l0aCBidWlsdC1pbiBhc3luYyBwb2xsaW5nIHN1cHBvcnQuXG4gKlxuICogQGRlcHJlY2F0ZWQgdGhpcyBmdW5jdGlvbiBvbmx5IHdvcmtzIHdpdGgge0BsaW5rIFR1cm5rZXlBcGl9LlxuICogVXNlIHtAbGluayBUdXJua2V5Q2xpZW50fSBhbmQge0BsaW5rIGNyZWF0ZUFjdGl2aXR5UG9sbGVyfSBpbnN0ZWFkLlxuICovXG5mdW5jdGlvbiB3aXRoQXN5bmNQb2xsaW5nKHBhcmFtcykge1xuICAgIGNvbnN0IHsgcmVxdWVzdCwgcmVmcmVzaEludGVydmFsTXMgPSBERUZBVUxUX1JFRlJFU0hfSU5URVJWQUxfTVMgfSA9IHBhcmFtcztcbiAgICByZXR1cm4gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgIGNvbnN0IGluaXRpYWxSZXNwb25zZSA9IGF3YWl0IHJlcXVlc3QoaW5wdXQpO1xuICAgICAgICBsZXQgYWN0aXZpdHkgPSBpbml0aWFsUmVzcG9uc2UuYWN0aXZpdHk7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGFjdGl2aXR5LnN0YXR1cykge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJBQ1RJVklUWV9TVEFUVVNfQ09NUExFVEVEXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjdGl2aXR5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwiQUNUSVZJVFlfU1RBVFVTX0NSRUFURURcIjoge1xuICAgICAgICAgICAgICAgICAgICAvLyBBc3luYyBwZW5kaW5nIHN0YXRlIC0tIGtlZXAgcG9sbGluZ1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcIkFDVElWSVRZX1NUQVRVU19QRU5ESU5HXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXN5bmMgcGVuZGluZyBzdGF0ZSAtLSBrZWVwIHBvbGxpbmdcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJBQ1RJVklUWV9TVEFUVVNfQ09OU0VOU1VTX05FRURFRFwiOiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBhY3Rpdml0eSByZXF1aXJlcyBjb25zZW5zdXMsIHdlIHNob3VsZG4ndCBiZSBwb2xsaW5nIGZvcmV2ZXIuXG4gICAgICAgICAgICAgICAgICAgIC8vIFlvdSBjYW4gcmVhZCB0aGUgYFR1cm5rZXlBY3Rpdml0eUVycm9yYCB0aHJvd24gdG8gZ2V0IHRoZSBgYWN0aXZpdHlJZGAsXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0b3JlIGl0IHNvbWV3aGVyZSwgdGhlbiByZS1mZXRjaCB0aGUgYWN0aXZpdHkgdmlhIGAucG9zdEdldEFjdGl2aXR5KC4uLilgXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gdGhlIHJlcXVpcmVkIGFwcHJvdmFscy9yZWplY3Rpb25zIGFyZSBpbiBwbGFjZS5cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR1cm5rZXlBY3Rpdml0eUVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBDb25zZW5zdXMgbmVlZGVkIGZvciBhY3Rpdml0eSAke2FjdGl2aXR5LmlkfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpdml0eUlkOiBhY3Rpdml0eS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2aXR5U3RhdHVzOiBhY3Rpdml0eS5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpdml0eVR5cGU6IGFjdGl2aXR5LnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwiQUNUSVZJVFlfU1RBVFVTX0ZBSUxFRFwiOiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFjdGl2aXR5IGZhaWxlZFxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHVybmtleUFjdGl2aXR5RXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYEFjdGl2aXR5ICR7YWN0aXZpdHkuaWR9IGZhaWxlZGAsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpdml0eUlkOiBhY3Rpdml0eS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2aXR5U3RhdHVzOiBhY3Rpdml0eS5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpdml0eVR5cGU6IGFjdGl2aXR5LnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwiQUNUSVZJVFlfU1RBVFVTX1JFSkVDVEVEXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWN0aXZpdHkgd2FzIHJlamVjdGVkXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUdXJua2V5QWN0aXZpdHlFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgQWN0aXZpdHkgJHthY3Rpdml0eS5pZH0gd2FzIHJlamVjdGVkYCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2aXR5SWQ6IGFjdGl2aXR5LmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZpdHlTdGF0dXM6IGFjdGl2aXR5LnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2aXR5VHlwZTogYWN0aXZpdHkudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBzd2l0Y2ggYmxvY2sgaXMgZXhoYXVzdGl2ZVxuICAgICAgICAgICAgICAgICAgICBhc3NlcnROZXZlcihhY3Rpdml0eS5zdGF0dXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IHNsZWVwKHJlZnJlc2hJbnRlcnZhbE1zKTtcbiAgICAgICAgICAgIGNvbnN0IHBvbGxpbmdSZXNwb25zZSA9IGF3YWl0IGdldEFjdGl2aXR5KHtcbiAgICAgICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2aXR5SWQ6IGFjdGl2aXR5LmlkLFxuICAgICAgICAgICAgICAgICAgICBvcmdhbml6YXRpb25JZDogYWN0aXZpdHkub3JnYW5pemF0aW9uSWQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYWN0aXZpdHkgPSBwb2xsaW5nUmVzcG9uc2UuYWN0aXZpdHk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuLyoqXG4gKiBXcmFwcyBhIGNsaWVudCByZXF1ZXN0IGZ1bmN0aW9uIChlLmcuIGBjbGllbnQuY3JlYXRlUHJpdmF0ZUtleXNgKSBpbiBhIHBvbGxlci5cbiAqIFRoZSBkZWZhdWx0IHJlZnJlc2ggaW50ZXJ2YWwgaXMgNTAwbXMuXG4gKlxuICogVGhlIHJldHVybmVkIHBvbGxlciB3aWxsIHBvbGwgdW50aWwgdGhlIGFjdGl2aXR5IGJlY29tZXMgYENPTVBMRVRFRGAuXG4gKiBJZiB0aGUgYWN0aXZpdHkgYmVjb21lcyBgRkFJTEVEYCBvciBgUkVKRUNURURgIG9yIGlzIGZsYWdnZWQgYXMgYE5FRURTX0NPTlNFTlNVU2AsIGFuIGVycm9yIGlzIHRocm93bi5cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgYWN0aXZpdHlQb2xsZXIgPSBjcmVhdGVBY3Rpdml0eVBvbGxlcihjbGllbnQsIGNsaWVudC5jcmVhdGVQcml2YXRlS2V5cyk7XG4gKiBjb25zdCBhY3Rpdml0eSA9IGF3YWl0IGFjdGl2aXR5UG9sbGVyKGlucHV0KTtcbiAqIGNvbnNvbGUubG9nKGFjdGl2aXR5LnJlc3VsdCk7IC8vIGFjdGl2aXR5IGlzIGNvbXBsZXRlZFxuICovXG5mdW5jdGlvbiBjcmVhdGVBY3Rpdml0eVBvbGxlcihwYXJhbXMpIHtcbiAgICBjb25zdCB7IGNsaWVudCwgcmVxdWVzdEZuLCByZWZyZXNoSW50ZXJ2YWxNcyA9IERFRkFVTFRfUkVGUkVTSF9JTlRFUlZBTF9NUywgfSA9IHBhcmFtcztcbiAgICByZXR1cm4gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgIGNvbnN0IGluaXRpYWxSZXNwb25zZSA9IGF3YWl0IHJlcXVlc3RGbihpbnB1dCk7XG4gICAgICAgIGxldCBhY3Rpdml0eSA9IGluaXRpYWxSZXNwb25zZS5hY3Rpdml0eTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoYWN0aXZpdHkuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIkFDVElWSVRZX1NUQVRVU19DT01QTEVURURcIjoge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWN0aXZpdHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJBQ1RJVklUWV9TVEFUVVNfQ1JFQVRFRFwiOiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFzeW5jIHBlbmRpbmcgc3RhdGUgLS0ga2VlcCBwb2xsaW5nXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwiQUNUSVZJVFlfU1RBVFVTX1BFTkRJTkdcIjoge1xuICAgICAgICAgICAgICAgICAgICAvLyBBc3luYyBwZW5kaW5nIHN0YXRlIC0tIGtlZXAgcG9sbGluZ1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcIkFDVElWSVRZX1NUQVRVU19DT05TRU5TVVNfTkVFREVEXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGFjdGl2aXR5IHJlcXVpcmVzIGNvbnNlbnN1cywgd2Ugc2hvdWxkbid0IGJlIHBvbGxpbmcgZm9yZXZlci5cbiAgICAgICAgICAgICAgICAgICAgLy8gWW91IGNhbiByZWFkIHRoZSBgVHVybmtleUFjdGl2aXR5RXJyb3JgIHRocm93biB0byBnZXQgdGhlIGBhY3Rpdml0eUlkYCxcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RvcmUgaXQgc29tZXdoZXJlLCB0aGVuIHJlLWZldGNoIHRoZSBhY3Rpdml0eSB2aWEgYC5wb3N0R2V0QWN0aXZpdHkoLi4uKWBcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiB0aGUgcmVxdWlyZWQgYXBwcm92YWxzL3JlamVjdGlvbnMgYXJlIGluIHBsYWNlLlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHVybmtleUFjdGl2aXR5RXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYENvbnNlbnN1cyBuZWVkZWQgZm9yIGFjdGl2aXR5ICR7YWN0aXZpdHkuaWR9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2aXR5SWQ6IGFjdGl2aXR5LmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZpdHlTdGF0dXM6IGFjdGl2aXR5LnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2aXR5VHlwZTogYWN0aXZpdHkudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJBQ1RJVklUWV9TVEFUVVNfRkFJTEVEXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWN0aXZpdHkgZmFpbGVkXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUdXJua2V5QWN0aXZpdHlFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgQWN0aXZpdHkgJHthY3Rpdml0eS5pZH0gZmFpbGVkYCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2aXR5SWQ6IGFjdGl2aXR5LmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZpdHlTdGF0dXM6IGFjdGl2aXR5LnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2aXR5VHlwZTogYWN0aXZpdHkudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJBQ1RJVklUWV9TVEFUVVNfUkVKRUNURURcIjoge1xuICAgICAgICAgICAgICAgICAgICAvLyBBY3Rpdml0eSB3YXMgcmVqZWN0ZWRcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR1cm5rZXlBY3Rpdml0eUVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBBY3Rpdml0eSAke2FjdGl2aXR5LmlkfSB3YXMgcmVqZWN0ZWRgLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZpdHlJZDogYWN0aXZpdHkuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpdml0eVN0YXR1czogYWN0aXZpdHkuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZpdHlUeXBlOiBhY3Rpdml0eS50eXBlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHN3aXRjaCBibG9jayBpcyBleGhhdXN0aXZlXG4gICAgICAgICAgICAgICAgICAgIGFzc2VydE5ldmVyKGFjdGl2aXR5LnN0YXR1cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgc2xlZXAocmVmcmVzaEludGVydmFsTXMpO1xuICAgICAgICAgICAgY29uc3QgcG9sbGluZ1Jlc3BvbnNlID0gYXdhaXQgY2xpZW50LmdldEFjdGl2aXR5KHtcbiAgICAgICAgICAgICAgICBhY3Rpdml0eUlkOiBhY3Rpdml0eS5pZCxcbiAgICAgICAgICAgICAgICBvcmdhbml6YXRpb25JZDogYWN0aXZpdHkub3JnYW5pemF0aW9uSWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGFjdGl2aXR5ID0gcG9sbGluZ1Jlc3BvbnNlLmFjdGl2aXR5O1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHNsZWVwKG1zKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9LCBtcyk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBhc3NlcnROZXZlcihpbnB1dCwgbWVzc2FnZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlICE9IG51bGwgPyBtZXNzYWdlIDogYFVuZXhwZWN0ZWQgY2FzZTogJHtKU09OLnN0cmluZ2lmeShpbnB1dCl9YCk7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZUFjdGl2aXR5UG9sbGVyLCB3aXRoQXN5bmNQb2xsaW5nIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3luYy5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/http/dist/async.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/http/dist/base.mjs":
/*!**************************************************!*\
  !*** ./node_modules/@turnkey/http/dist/base.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TurnkeyRequestError: () => (/* binding */ TurnkeyRequestError),\n/* harmony export */   fetch: () => (/* reexport safe */ _universal_mjs__WEBPACK_IMPORTED_MODULE_1__.fetch),\n/* harmony export */   request: () => (/* binding */ request),\n/* harmony export */   sealAndStampRequestBody: () => (/* binding */ sealAndStampRequestBody),\n/* harmony export */   signedRequest: () => (/* binding */ signedRequest)\n/* harmony export */ });\n/* harmony import */ var _turnkey_api_key_stamper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @turnkey/api-key-stamper */ \"(ssr)/./node_modules/@turnkey/api-key-stamper/dist/index.mjs\");\n/* harmony import */ var _universal_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./universal.mjs */ \"(ssr)/./node_modules/@turnkey/http/dist/universal.mjs\");\n/* harmony import */ var _config_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./config.mjs */ \"(ssr)/./node_modules/@turnkey/http/dist/config.mjs\");\n/* harmony import */ var _turnkey_encoding__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @turnkey/encoding */ \"(ssr)/./node_modules/@turnkey/encoding/dist/index.mjs\");\n/* harmony import */ var _webauthn_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./webauthn.mjs */ \"(ssr)/./node_modules/@turnkey/http/dist/webauthn.mjs\");\n\n\n\n\n\n\nconst sharedHeaders = {};\nconst sharedRequestOptions = {\n    redirect: \"follow\",\n};\n/**\n * @deprecated\n */\nasync function signedRequest(input) {\n    const { uri: inputUri, query: inputQuery = {}, substitution: inputSubstitution = {}, body: inputBody = {}, } = input;\n    const url = constructUrl({\n        uri: inputUri,\n        query: inputQuery,\n        substitution: inputSubstitution,\n    });\n    const body = JSON.stringify(inputBody);\n    const stamp = await (0,_webauthn_mjs__WEBPACK_IMPORTED_MODULE_4__.getWebAuthnAssertion)(body, input.options);\n    return {\n        url: url.toString(),\n        body,\n        stamp,\n    };\n}\nasync function request(input) {\n    const { uri: inputUri, method, headers: inputHeaders = {}, query: inputQuery = {}, substitution: inputSubstitution = {}, body: inputBody = {}, } = input;\n    const url = constructUrl({\n        uri: inputUri,\n        query: inputQuery,\n        substitution: inputSubstitution,\n    });\n    const { sealedBody, xStamp } = await sealAndStampRequestBody({\n        body: inputBody,\n    });\n    const response = await (0,_universal_mjs__WEBPACK_IMPORTED_MODULE_1__.fetch)(url.toString(), {\n        ...sharedRequestOptions,\n        method,\n        headers: {\n            ...sharedHeaders,\n            ...inputHeaders,\n            \"X-Stamp\": xStamp,\n        },\n        body: sealedBody,\n    });\n    if (!response.ok) {\n        // Can't use native `cause` here because it's not well supported on Node v16\n        // https://node.green/#ES2022-features-Error-cause-property\n        let res;\n        try {\n            res = await response.json();\n        }\n        catch (_) {\n            throw new Error(`${response.status} ${response.statusText}`);\n        }\n        throw new TurnkeyRequestError(res);\n    }\n    const data = await response.json();\n    return data;\n}\nfunction constructUrl(input) {\n    const { uri, query, substitution } = input;\n    const baseUrl = getBaseUrl();\n    const url = new URL(substitutePath(uri, substitution), baseUrl);\n    for (const key in query) {\n        const value = query[key];\n        if (Array.isArray(value)) {\n            for (const item of value) {\n                url.searchParams.append(key, item);\n            }\n        }\n        else {\n            url.searchParams.append(key, value ?? \"\");\n        }\n    }\n    return url;\n}\nfunction getBaseUrl() {\n    try {\n        const { baseUrl } = (0,_config_mjs__WEBPACK_IMPORTED_MODULE_2__.getConfig)();\n        return baseUrl;\n    }\n    catch (e) {\n        const { baseUrl } = (0,_config_mjs__WEBPACK_IMPORTED_MODULE_2__.getBrowserConfig)();\n        return baseUrl;\n    }\n}\nfunction substitutePath(uri, substitutionMap) {\n    let result = uri;\n    const keyList = Object.keys(substitutionMap);\n    for (const key of keyList) {\n        const output = result.replaceAll(`{${key}}`, substitutionMap[key]);\n        invariant(output !== result, `Substitution error: cannot find \"${key}\" in URI \"${uri}\". \\`substitutionMap\\`: ${JSON.stringify(substitutionMap)}`);\n        result = output;\n    }\n    invariant(!/\\{.*\\}/.test(result), `Substitution error: found unsubstituted components in \"${result}\"`);\n    return result;\n}\nfunction invariant(condition, message) {\n    if (!condition) {\n        throw new Error(message);\n    }\n}\nfunction stableStringify(input) {\n    return JSON.stringify(input);\n}\n/**\n * Seals and stamps the request body with your Turnkey API credentials.\n *\n * You can either:\n * - Before calling `sealAndStampRequestBody(...)`, initialize with your Turnkey API credentials via `init(...)`\n * - Or, provide `apiPublicKey` and `apiPrivateKey` here as arguments\n */\nasync function sealAndStampRequestBody(input) {\n    const { body } = input;\n    let { apiPublicKey, apiPrivateKey } = input;\n    if (!apiPublicKey) {\n        const config = (0,_config_mjs__WEBPACK_IMPORTED_MODULE_2__.getConfig)();\n        apiPublicKey = config.apiPublicKey;\n    }\n    if (!apiPrivateKey) {\n        const config = (0,_config_mjs__WEBPACK_IMPORTED_MODULE_2__.getConfig)();\n        apiPrivateKey = config.apiPrivateKey;\n    }\n    const sealedBody = stableStringify(body);\n    const signature = await (0,_turnkey_api_key_stamper__WEBPACK_IMPORTED_MODULE_0__.signWithApiKey)({\n        content: sealedBody,\n        privateKey: apiPrivateKey,\n        publicKey: apiPublicKey,\n    });\n    const sealedStamp = stableStringify({\n        publicKey: apiPublicKey,\n        scheme: \"SIGNATURE_SCHEME_TK_API_P256\",\n        signature: signature,\n    });\n    const xStamp = (0,_turnkey_encoding__WEBPACK_IMPORTED_MODULE_3__.stringToBase64urlString)(sealedStamp);\n    return {\n        sealedBody,\n        xStamp,\n    };\n}\nclass TurnkeyRequestError extends Error {\n    constructor(input) {\n        let turnkeyErrorMessage = `Turnkey error ${input.code}: ${input.message}`;\n        if (input.details != null) {\n            turnkeyErrorMessage += ` (Details: ${JSON.stringify(input.details)})`;\n        }\n        super(turnkeyErrorMessage);\n        this.name = \"TurnkeyRequestError\";\n        this.details = input.details ?? null;\n        this.code = input.code;\n    }\n}\n\n\n//# sourceMappingURL=base.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvaHR0cC9kaXN0L2Jhc2UubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBMEQ7QUFDbEI7QUFDbUI7QUFDQztBQUNOOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQ0FBcUMsc0NBQXNDLHNCQUFzQixJQUFJO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0JBQXdCLG1FQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaURBQWlELHdCQUF3QixzQ0FBc0Msc0JBQXNCLElBQUk7QUFDcko7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsWUFBWSxxQkFBcUI7QUFDakM7QUFDQSxLQUFLO0FBQ0wsMkJBQTJCLHFEQUFLO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGlCQUFpQixFQUFFLG9CQUFvQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMkJBQTJCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVSxFQUFFLHNEQUFTO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVLEVBQUUsNkRBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLEVBQUUsS0FBSztBQUNsRCx5RUFBeUUsSUFBSSxZQUFZLElBQUksMEJBQTBCLGdDQUFnQztBQUN2SjtBQUNBO0FBQ0Esa0JBQWtCLElBQUksMEVBQTBFLE9BQU87QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFVBQVUsOEJBQThCO0FBQ3hDO0FBQ0EsdUJBQXVCLHNEQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzREFBUztBQUNoQztBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsd0VBQWM7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLG1CQUFtQiwwRUFBdUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsV0FBVyxJQUFJLGNBQWM7QUFDaEY7QUFDQSxpREFBaUQsOEJBQThCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV1RjtBQUN2RiIsInNvdXJjZXMiOlsid2VicGFjazovL251cnNlYmxvYy8uL25vZGVfbW9kdWxlcy9AdHVybmtleS9odHRwL2Rpc3QvYmFzZS5tanM/MWZhNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzaWduV2l0aEFwaUtleSB9IGZyb20gJ0B0dXJua2V5L2FwaS1rZXktc3RhbXBlcic7XG5pbXBvcnQgeyBmZXRjaCB9IGZyb20gJy4vdW5pdmVyc2FsLm1qcyc7XG5pbXBvcnQgeyBnZXRDb25maWcsIGdldEJyb3dzZXJDb25maWcgfSBmcm9tICcuL2NvbmZpZy5tanMnO1xuaW1wb3J0IHsgc3RyaW5nVG9CYXNlNjR1cmxTdHJpbmcgfSBmcm9tICdAdHVybmtleS9lbmNvZGluZyc7XG5pbXBvcnQgeyBnZXRXZWJBdXRobkFzc2VydGlvbiB9IGZyb20gJy4vd2ViYXV0aG4ubWpzJztcblxuY29uc3Qgc2hhcmVkSGVhZGVycyA9IHt9O1xuY29uc3Qgc2hhcmVkUmVxdWVzdE9wdGlvbnMgPSB7XG4gICAgcmVkaXJlY3Q6IFwiZm9sbG93XCIsXG59O1xuLyoqXG4gKiBAZGVwcmVjYXRlZFxuICovXG5hc3luYyBmdW5jdGlvbiBzaWduZWRSZXF1ZXN0KGlucHV0KSB7XG4gICAgY29uc3QgeyB1cmk6IGlucHV0VXJpLCBxdWVyeTogaW5wdXRRdWVyeSA9IHt9LCBzdWJzdGl0dXRpb246IGlucHV0U3Vic3RpdHV0aW9uID0ge30sIGJvZHk6IGlucHV0Qm9keSA9IHt9LCB9ID0gaW5wdXQ7XG4gICAgY29uc3QgdXJsID0gY29uc3RydWN0VXJsKHtcbiAgICAgICAgdXJpOiBpbnB1dFVyaSxcbiAgICAgICAgcXVlcnk6IGlucHV0UXVlcnksXG4gICAgICAgIHN1YnN0aXR1dGlvbjogaW5wdXRTdWJzdGl0dXRpb24sXG4gICAgfSk7XG4gICAgY29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KGlucHV0Qm9keSk7XG4gICAgY29uc3Qgc3RhbXAgPSBhd2FpdCBnZXRXZWJBdXRobkFzc2VydGlvbihib2R5LCBpbnB1dC5vcHRpb25zKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB1cmw6IHVybC50b1N0cmluZygpLFxuICAgICAgICBib2R5LFxuICAgICAgICBzdGFtcCxcbiAgICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gcmVxdWVzdChpbnB1dCkge1xuICAgIGNvbnN0IHsgdXJpOiBpbnB1dFVyaSwgbWV0aG9kLCBoZWFkZXJzOiBpbnB1dEhlYWRlcnMgPSB7fSwgcXVlcnk6IGlucHV0UXVlcnkgPSB7fSwgc3Vic3RpdHV0aW9uOiBpbnB1dFN1YnN0aXR1dGlvbiA9IHt9LCBib2R5OiBpbnB1dEJvZHkgPSB7fSwgfSA9IGlucHV0O1xuICAgIGNvbnN0IHVybCA9IGNvbnN0cnVjdFVybCh7XG4gICAgICAgIHVyaTogaW5wdXRVcmksXG4gICAgICAgIHF1ZXJ5OiBpbnB1dFF1ZXJ5LFxuICAgICAgICBzdWJzdGl0dXRpb246IGlucHV0U3Vic3RpdHV0aW9uLFxuICAgIH0pO1xuICAgIGNvbnN0IHsgc2VhbGVkQm9keSwgeFN0YW1wIH0gPSBhd2FpdCBzZWFsQW5kU3RhbXBSZXF1ZXN0Qm9keSh7XG4gICAgICAgIGJvZHk6IGlucHV0Qm9keSxcbiAgICB9KTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybC50b1N0cmluZygpLCB7XG4gICAgICAgIC4uLnNoYXJlZFJlcXVlc3RPcHRpb25zLFxuICAgICAgICBtZXRob2QsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIC4uLnNoYXJlZEhlYWRlcnMsXG4gICAgICAgICAgICAuLi5pbnB1dEhlYWRlcnMsXG4gICAgICAgICAgICBcIlgtU3RhbXBcIjogeFN0YW1wLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBzZWFsZWRCb2R5LFxuICAgIH0pO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgLy8gQ2FuJ3QgdXNlIG5hdGl2ZSBgY2F1c2VgIGhlcmUgYmVjYXVzZSBpdCdzIG5vdCB3ZWxsIHN1cHBvcnRlZCBvbiBOb2RlIHYxNlxuICAgICAgICAvLyBodHRwczovL25vZGUuZ3JlZW4vI0VTMjAyMi1mZWF0dXJlcy1FcnJvci1jYXVzZS1wcm9wZXJ0eVxuICAgICAgICBsZXQgcmVzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IFR1cm5rZXlSZXF1ZXN0RXJyb3IocmVzKTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICByZXR1cm4gZGF0YTtcbn1cbmZ1bmN0aW9uIGNvbnN0cnVjdFVybChpbnB1dCkge1xuICAgIGNvbnN0IHsgdXJpLCBxdWVyeSwgc3Vic3RpdHV0aW9uIH0gPSBpbnB1dDtcbiAgICBjb25zdCBiYXNlVXJsID0gZ2V0QmFzZVVybCgpO1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoc3Vic3RpdHV0ZVBhdGgodXJpLCBzdWJzdGl0dXRpb24pLCBiYXNlVXJsKTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBxdWVyeSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHF1ZXJ5W2tleV07XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCBpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgdmFsdWUgPz8gXCJcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVybDtcbn1cbmZ1bmN0aW9uIGdldEJhc2VVcmwoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyBiYXNlVXJsIH0gPSBnZXRDb25maWcoKTtcbiAgICAgICAgcmV0dXJuIGJhc2VVcmw7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnN0IHsgYmFzZVVybCB9ID0gZ2V0QnJvd3NlckNvbmZpZygpO1xuICAgICAgICByZXR1cm4gYmFzZVVybDtcbiAgICB9XG59XG5mdW5jdGlvbiBzdWJzdGl0dXRlUGF0aCh1cmksIHN1YnN0aXR1dGlvbk1hcCkge1xuICAgIGxldCByZXN1bHQgPSB1cmk7XG4gICAgY29uc3Qga2V5TGlzdCA9IE9iamVjdC5rZXlzKHN1YnN0aXR1dGlvbk1hcCk7XG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5TGlzdCkge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSByZXN1bHQucmVwbGFjZUFsbChgeyR7a2V5fX1gLCBzdWJzdGl0dXRpb25NYXBba2V5XSk7XG4gICAgICAgIGludmFyaWFudChvdXRwdXQgIT09IHJlc3VsdCwgYFN1YnN0aXR1dGlvbiBlcnJvcjogY2Fubm90IGZpbmQgXCIke2tleX1cIiBpbiBVUkkgXCIke3VyaX1cIi4gXFxgc3Vic3RpdHV0aW9uTWFwXFxgOiAke0pTT04uc3RyaW5naWZ5KHN1YnN0aXR1dGlvbk1hcCl9YCk7XG4gICAgICAgIHJlc3VsdCA9IG91dHB1dDtcbiAgICB9XG4gICAgaW52YXJpYW50KCEvXFx7LipcXH0vLnRlc3QocmVzdWx0KSwgYFN1YnN0aXR1dGlvbiBlcnJvcjogZm91bmQgdW5zdWJzdGl0dXRlZCBjb21wb25lbnRzIGluIFwiJHtyZXN1bHR9XCJgKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzdGFibGVTdHJpbmdpZnkoaW5wdXQpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoaW5wdXQpO1xufVxuLyoqXG4gKiBTZWFscyBhbmQgc3RhbXBzIHRoZSByZXF1ZXN0IGJvZHkgd2l0aCB5b3VyIFR1cm5rZXkgQVBJIGNyZWRlbnRpYWxzLlxuICpcbiAqIFlvdSBjYW4gZWl0aGVyOlxuICogLSBCZWZvcmUgY2FsbGluZyBgc2VhbEFuZFN0YW1wUmVxdWVzdEJvZHkoLi4uKWAsIGluaXRpYWxpemUgd2l0aCB5b3VyIFR1cm5rZXkgQVBJIGNyZWRlbnRpYWxzIHZpYSBgaW5pdCguLi4pYFxuICogLSBPciwgcHJvdmlkZSBgYXBpUHVibGljS2V5YCBhbmQgYGFwaVByaXZhdGVLZXlgIGhlcmUgYXMgYXJndW1lbnRzXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNlYWxBbmRTdGFtcFJlcXVlc3RCb2R5KGlucHV0KSB7XG4gICAgY29uc3QgeyBib2R5IH0gPSBpbnB1dDtcbiAgICBsZXQgeyBhcGlQdWJsaWNLZXksIGFwaVByaXZhdGVLZXkgfSA9IGlucHV0O1xuICAgIGlmICghYXBpUHVibGljS2V5KSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IGdldENvbmZpZygpO1xuICAgICAgICBhcGlQdWJsaWNLZXkgPSBjb25maWcuYXBpUHVibGljS2V5O1xuICAgIH1cbiAgICBpZiAoIWFwaVByaXZhdGVLZXkpIHtcbiAgICAgICAgY29uc3QgY29uZmlnID0gZ2V0Q29uZmlnKCk7XG4gICAgICAgIGFwaVByaXZhdGVLZXkgPSBjb25maWcuYXBpUHJpdmF0ZUtleTtcbiAgICB9XG4gICAgY29uc3Qgc2VhbGVkQm9keSA9IHN0YWJsZVN0cmluZ2lmeShib2R5KTtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBzaWduV2l0aEFwaUtleSh7XG4gICAgICAgIGNvbnRlbnQ6IHNlYWxlZEJvZHksXG4gICAgICAgIHByaXZhdGVLZXk6IGFwaVByaXZhdGVLZXksXG4gICAgICAgIHB1YmxpY0tleTogYXBpUHVibGljS2V5LFxuICAgIH0pO1xuICAgIGNvbnN0IHNlYWxlZFN0YW1wID0gc3RhYmxlU3RyaW5naWZ5KHtcbiAgICAgICAgcHVibGljS2V5OiBhcGlQdWJsaWNLZXksXG4gICAgICAgIHNjaGVtZTogXCJTSUdOQVRVUkVfU0NIRU1FX1RLX0FQSV9QMjU2XCIsXG4gICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlLFxuICAgIH0pO1xuICAgIGNvbnN0IHhTdGFtcCA9IHN0cmluZ1RvQmFzZTY0dXJsU3RyaW5nKHNlYWxlZFN0YW1wKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzZWFsZWRCb2R5LFxuICAgICAgICB4U3RhbXAsXG4gICAgfTtcbn1cbmNsYXNzIFR1cm5rZXlSZXF1ZXN0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoaW5wdXQpIHtcbiAgICAgICAgbGV0IHR1cm5rZXlFcnJvck1lc3NhZ2UgPSBgVHVybmtleSBlcnJvciAke2lucHV0LmNvZGV9OiAke2lucHV0Lm1lc3NhZ2V9YDtcbiAgICAgICAgaWYgKGlucHV0LmRldGFpbHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgdHVybmtleUVycm9yTWVzc2FnZSArPSBgIChEZXRhaWxzOiAke0pTT04uc3RyaW5naWZ5KGlucHV0LmRldGFpbHMpfSlgO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKHR1cm5rZXlFcnJvck1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIlR1cm5rZXlSZXF1ZXN0RXJyb3JcIjtcbiAgICAgICAgdGhpcy5kZXRhaWxzID0gaW5wdXQuZGV0YWlscyA/PyBudWxsO1xuICAgICAgICB0aGlzLmNvZGUgPSBpbnB1dC5jb2RlO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgVHVybmtleVJlcXVlc3RFcnJvciwgZmV0Y2gsIHJlcXVlc3QsIHNlYWxBbmRTdGFtcFJlcXVlc3RCb2R5LCBzaWduZWRSZXF1ZXN0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/http/dist/base.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/http/dist/config.mjs":
/*!****************************************************!*\
  !*** ./node_modules/@turnkey/http/dist/config.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   browserInit: () => (/* binding */ browserInit),\n/* harmony export */   getBrowserConfig: () => (/* binding */ getBrowserConfig),\n/* harmony export */   getConfig: () => (/* binding */ getConfig),\n/* harmony export */   init: () => (/* binding */ init)\n/* harmony export */ });\nconst config = {\n    apiPublicKey: null,\n    apiPrivateKey: null,\n    baseUrl: null,\n};\nconst browserConfig = {\n    baseUrl: null,\n};\n/**\n * @deprecated use {@link TurnkeyClient} instead, which doesn't rely on global initialization logic.\n */\nfunction browserInit(value) {\n    browserConfig.baseUrl = assertNonEmptyString(value.baseUrl, \"baseUrl\");\n}\n/**\n * @deprecated use {@link TurnkeyClient} instead, which doesn't rely on global initialization logic.\n */\nfunction init(value) {\n    config.apiPublicKey = assertNonEmptyString(value.apiPublicKey, \"apiPublicKey\");\n    config.apiPrivateKey = assertNonEmptyString(value.apiPrivateKey, \"apiPrivateKey\");\n    config.baseUrl = assertNonEmptyString(value.baseUrl, \"baseUrl\");\n}\nfunction getConfig() {\n    return {\n        apiPublicKey: assertNonEmptyString(config.apiPublicKey, \"apiPublicKey\"),\n        apiPrivateKey: assertNonEmptyString(config.apiPrivateKey, \"apiPrivateKey\"),\n        baseUrl: assertNonEmptyString(config.baseUrl, \"baseUrl\"),\n    };\n}\nfunction getBrowserConfig() {\n    return {\n        baseUrl: assertNonEmptyString(browserConfig.baseUrl, \"baseUrl\"),\n    };\n}\nfunction assertNonEmptyString(input, name) {\n    if (typeof input !== \"string\" || !input) {\n        throw new Error(`\"${name}\" must be a non-empty string`);\n    }\n    return input;\n}\n\n\n//# sourceMappingURL=config.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvaHR0cC9kaXN0L2NvbmZpZy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixLQUFLO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFMEQ7QUFDMUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9udXJzZWJsb2MvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvaHR0cC9kaXN0L2NvbmZpZy5tanM/ZGFhMiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBjb25maWcgPSB7XG4gICAgYXBpUHVibGljS2V5OiBudWxsLFxuICAgIGFwaVByaXZhdGVLZXk6IG51bGwsXG4gICAgYmFzZVVybDogbnVsbCxcbn07XG5jb25zdCBicm93c2VyQ29uZmlnID0ge1xuICAgIGJhc2VVcmw6IG51bGwsXG59O1xuLyoqXG4gKiBAZGVwcmVjYXRlZCB1c2Uge0BsaW5rIFR1cm5rZXlDbGllbnR9IGluc3RlYWQsIHdoaWNoIGRvZXNuJ3QgcmVseSBvbiBnbG9iYWwgaW5pdGlhbGl6YXRpb24gbG9naWMuXG4gKi9cbmZ1bmN0aW9uIGJyb3dzZXJJbml0KHZhbHVlKSB7XG4gICAgYnJvd3NlckNvbmZpZy5iYXNlVXJsID0gYXNzZXJ0Tm9uRW1wdHlTdHJpbmcodmFsdWUuYmFzZVVybCwgXCJiYXNlVXJsXCIpO1xufVxuLyoqXG4gKiBAZGVwcmVjYXRlZCB1c2Uge0BsaW5rIFR1cm5rZXlDbGllbnR9IGluc3RlYWQsIHdoaWNoIGRvZXNuJ3QgcmVseSBvbiBnbG9iYWwgaW5pdGlhbGl6YXRpb24gbG9naWMuXG4gKi9cbmZ1bmN0aW9uIGluaXQodmFsdWUpIHtcbiAgICBjb25maWcuYXBpUHVibGljS2V5ID0gYXNzZXJ0Tm9uRW1wdHlTdHJpbmcodmFsdWUuYXBpUHVibGljS2V5LCBcImFwaVB1YmxpY0tleVwiKTtcbiAgICBjb25maWcuYXBpUHJpdmF0ZUtleSA9IGFzc2VydE5vbkVtcHR5U3RyaW5nKHZhbHVlLmFwaVByaXZhdGVLZXksIFwiYXBpUHJpdmF0ZUtleVwiKTtcbiAgICBjb25maWcuYmFzZVVybCA9IGFzc2VydE5vbkVtcHR5U3RyaW5nKHZhbHVlLmJhc2VVcmwsIFwiYmFzZVVybFwiKTtcbn1cbmZ1bmN0aW9uIGdldENvbmZpZygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBhcGlQdWJsaWNLZXk6IGFzc2VydE5vbkVtcHR5U3RyaW5nKGNvbmZpZy5hcGlQdWJsaWNLZXksIFwiYXBpUHVibGljS2V5XCIpLFxuICAgICAgICBhcGlQcml2YXRlS2V5OiBhc3NlcnROb25FbXB0eVN0cmluZyhjb25maWcuYXBpUHJpdmF0ZUtleSwgXCJhcGlQcml2YXRlS2V5XCIpLFxuICAgICAgICBiYXNlVXJsOiBhc3NlcnROb25FbXB0eVN0cmluZyhjb25maWcuYmFzZVVybCwgXCJiYXNlVXJsXCIpLFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRCcm93c2VyQ29uZmlnKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGJhc2VVcmw6IGFzc2VydE5vbkVtcHR5U3RyaW5nKGJyb3dzZXJDb25maWcuYmFzZVVybCwgXCJiYXNlVXJsXCIpLFxuICAgIH07XG59XG5mdW5jdGlvbiBhc3NlcnROb25FbXB0eVN0cmluZyhpbnB1dCwgbmFtZSkge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgIT09IFwic3RyaW5nXCIgfHwgIWlucHV0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke25hbWV9XCIgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmdgKTtcbiAgICB9XG4gICAgcmV0dXJuIGlucHV0O1xufVxuXG5leHBvcnQgeyBicm93c2VySW5pdCwgZ2V0QnJvd3NlckNvbmZpZywgZ2V0Q29uZmlnLCBpbml0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25maWcubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/http/dist/config.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/http/dist/index.mjs":
/*!***************************************************!*\
  !*** ./node_modules/@turnkey/http/dist/index.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PublicApiService: () => (/* binding */ PublicApiService),\n/* harmony export */   TurnkeyActivityError: () => (/* reexport safe */ _shared_mjs__WEBPACK_IMPORTED_MODULE_4__.TurnkeyActivityError),\n/* harmony export */   TurnkeyApi: () => (/* reexport module object */ _generated_services_coordinator_public_v1_public_api_fetcher_mjs__WEBPACK_IMPORTED_MODULE_0__),\n/* harmony export */   TurnkeyClient: () => (/* reexport safe */ _generated_services_coordinator_public_v1_public_api_client_mjs__WEBPACK_IMPORTED_MODULE_1__.TurnkeyClient),\n/* harmony export */   TurnkeyRequestError: () => (/* reexport safe */ _base_mjs__WEBPACK_IMPORTED_MODULE_3__.TurnkeyRequestError),\n/* harmony export */   VERSION: () => (/* reexport safe */ _version_mjs__WEBPACK_IMPORTED_MODULE_7__.VERSION),\n/* harmony export */   browserInit: () => (/* reexport safe */ _config_mjs__WEBPACK_IMPORTED_MODULE_2__.browserInit),\n/* harmony export */   createActivityPoller: () => (/* reexport safe */ _async_mjs__WEBPACK_IMPORTED_MODULE_6__.createActivityPoller),\n/* harmony export */   getWebAuthnAttestation: () => (/* reexport safe */ _webauthn_mjs__WEBPACK_IMPORTED_MODULE_5__.getWebAuthnAttestation),\n/* harmony export */   init: () => (/* reexport safe */ _config_mjs__WEBPACK_IMPORTED_MODULE_2__.init),\n/* harmony export */   sealAndStampRequestBody: () => (/* reexport safe */ _base_mjs__WEBPACK_IMPORTED_MODULE_3__.sealAndStampRequestBody),\n/* harmony export */   withAsyncPolling: () => (/* reexport safe */ _async_mjs__WEBPACK_IMPORTED_MODULE_6__.withAsyncPolling)\n/* harmony export */ });\n/* harmony import */ var _generated_services_coordinator_public_v1_public_api_fetcher_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./__generated__/services/coordinator/public/v1/public_api.fetcher.mjs */ \"(ssr)/./node_modules/@turnkey/http/dist/__generated__/services/coordinator/public/v1/public_api.fetcher.mjs\");\n/* harmony import */ var _generated_services_coordinator_public_v1_public_api_client_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./__generated__/services/coordinator/public/v1/public_api.client.mjs */ \"(ssr)/./node_modules/@turnkey/http/dist/__generated__/services/coordinator/public/v1/public_api.client.mjs\");\n/* harmony import */ var _config_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./config.mjs */ \"(ssr)/./node_modules/@turnkey/http/dist/config.mjs\");\n/* harmony import */ var _base_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./base.mjs */ \"(ssr)/./node_modules/@turnkey/http/dist/base.mjs\");\n/* harmony import */ var _shared_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./shared.mjs */ \"(ssr)/./node_modules/@turnkey/http/dist/shared.mjs\");\n/* harmony import */ var _webauthn_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./webauthn.mjs */ \"(ssr)/./node_modules/@turnkey/http/dist/webauthn.mjs\");\n/* harmony import */ var _async_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./async.mjs */ \"(ssr)/./node_modules/@turnkey/http/dist/async.mjs\");\n/* harmony import */ var _version_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./version.mjs */ \"(ssr)/./node_modules/@turnkey/http/dist/version.mjs\");\n\n\n\n\n\n\n\n\n\n/**\n * @deprecated use `TurnkeyApi` instead\n */\nconst PublicApiService = _generated_services_coordinator_public_v1_public_api_fetcher_mjs__WEBPACK_IMPORTED_MODULE_0__;\n\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvaHR0cC9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE0RztBQUNQO0FBQ3BEO0FBQ3lCO0FBQ3RCO0FBQ0k7QUFDYTtBQUM3Qjs7QUFFeEM7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDZGQUFrQjs7QUFFbUI7QUFDOUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9udXJzZWJsb2MvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvaHR0cC9kaXN0L2luZGV4Lm1qcz81NmU3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHB1YmxpY19hcGlfZmV0Y2hlciBmcm9tICcuL19fZ2VuZXJhdGVkX18vc2VydmljZXMvY29vcmRpbmF0b3IvcHVibGljL3YxL3B1YmxpY19hcGkuZmV0Y2hlci5tanMnO1xuZXhwb3J0IHsgVHVybmtleUNsaWVudCB9IGZyb20gJy4vX19nZW5lcmF0ZWRfXy9zZXJ2aWNlcy9jb29yZGluYXRvci9wdWJsaWMvdjEvcHVibGljX2FwaS5jbGllbnQubWpzJztcbmV4cG9ydCB7IGJyb3dzZXJJbml0LCBpbml0IH0gZnJvbSAnLi9jb25maWcubWpzJztcbmV4cG9ydCB7IFR1cm5rZXlSZXF1ZXN0RXJyb3IsIHNlYWxBbmRTdGFtcFJlcXVlc3RCb2R5IH0gZnJvbSAnLi9iYXNlLm1qcyc7XG5leHBvcnQgeyBUdXJua2V5QWN0aXZpdHlFcnJvciB9IGZyb20gJy4vc2hhcmVkLm1qcyc7XG5leHBvcnQgeyBnZXRXZWJBdXRobkF0dGVzdGF0aW9uIH0gZnJvbSAnLi93ZWJhdXRobi5tanMnO1xuZXhwb3J0IHsgY3JlYXRlQWN0aXZpdHlQb2xsZXIsIHdpdGhBc3luY1BvbGxpbmcgfSBmcm9tICcuL2FzeW5jLm1qcyc7XG5leHBvcnQgeyBWRVJTSU9OIH0gZnJvbSAnLi92ZXJzaW9uLm1qcyc7XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgdXNlIGBUdXJua2V5QXBpYCBpbnN0ZWFkXG4gKi9cbmNvbnN0IFB1YmxpY0FwaVNlcnZpY2UgPSBwdWJsaWNfYXBpX2ZldGNoZXI7XG5cbmV4cG9ydCB7IFB1YmxpY0FwaVNlcnZpY2UsIHB1YmxpY19hcGlfZmV0Y2hlciBhcyBUdXJua2V5QXBpIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/http/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/http/dist/shared.mjs":
/*!****************************************************!*\
  !*** ./node_modules/@turnkey/http/dist/shared.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TurnkeyActivityError: () => (/* binding */ TurnkeyActivityError)\n/* harmony export */ });\nclass TurnkeyActivityError extends Error {\n    constructor(input) {\n        const { message, cause, activityId, activityStatus, activityType } = input;\n        super(message);\n        this.name = \"TurnkeyActivityError\";\n        this.activityId = activityId ?? null;\n        this.activityStatus = activityStatus ?? null;\n        this.activityType = activityType ?? null;\n        this.cause = cause ?? null;\n    }\n}\n\n\n//# sourceMappingURL=shared.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvaHR0cC9kaXN0L3NoYXJlZC5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQSxnQkFBZ0IsMkRBQTJEO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWdDO0FBQ2hDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbnVyc2VibG9jLy4vbm9kZV9tb2R1bGVzL0B0dXJua2V5L2h0dHAvZGlzdC9zaGFyZWQubWpzPzg5MWQiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgVHVybmtleUFjdGl2aXR5RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlLCBjYXVzZSwgYWN0aXZpdHlJZCwgYWN0aXZpdHlTdGF0dXMsIGFjdGl2aXR5VHlwZSB9ID0gaW5wdXQ7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIlR1cm5rZXlBY3Rpdml0eUVycm9yXCI7XG4gICAgICAgIHRoaXMuYWN0aXZpdHlJZCA9IGFjdGl2aXR5SWQgPz8gbnVsbDtcbiAgICAgICAgdGhpcy5hY3Rpdml0eVN0YXR1cyA9IGFjdGl2aXR5U3RhdHVzID8/IG51bGw7XG4gICAgICAgIHRoaXMuYWN0aXZpdHlUeXBlID0gYWN0aXZpdHlUeXBlID8/IG51bGw7XG4gICAgICAgIHRoaXMuY2F1c2UgPSBjYXVzZSA/PyBudWxsO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgVHVybmtleUFjdGl2aXR5RXJyb3IgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYXJlZC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/http/dist/shared.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/http/dist/universal.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@turnkey/http/dist/universal.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fetch: () => (/* binding */ fetch)\n/* harmony export */ });\n/* harmony import */ var cross_fetch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cross-fetch */ \"(ssr)/./node_modules/cross-fetch/dist/node-ponyfill.js\");\n\n\n/// <reference lib=\"dom\" />\n// This is useful for mocking fetch in tests.\nconst fetch = cross_fetch__WEBPACK_IMPORTED_MODULE_0__.fetch;\n\n\n//# sourceMappingURL=universal.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvaHR0cC9kaXN0L3VuaXZlcnNhbC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBK0M7O0FBRS9DO0FBQ0E7QUFDQSxjQUFjLDhDQUFPOztBQUVKO0FBQ2pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbnVyc2VibG9jLy4vbm9kZV9tb2R1bGVzL0B0dXJua2V5L2h0dHAvZGlzdC91bml2ZXJzYWwubWpzPzgxYmYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZmV0Y2ggYXMgZmV0Y2gkMSB9IGZyb20gJ2Nyb3NzLWZldGNoJztcblxuLy8vIDxyZWZlcmVuY2UgbGliPVwiZG9tXCIgLz5cbi8vIFRoaXMgaXMgdXNlZnVsIGZvciBtb2NraW5nIGZldGNoIGluIHRlc3RzLlxuY29uc3QgZmV0Y2ggPSBmZXRjaCQxO1xuXG5leHBvcnQgeyBmZXRjaCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dW5pdmVyc2FsLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/http/dist/universal.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/http/dist/version.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/@turnkey/http/dist/version.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   VERSION: () => (/* binding */ VERSION)\n/* harmony export */ });\nconst VERSION = \"@turnkey/http@2.10.0\";\n\n\n//# sourceMappingURL=version.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvaHR0cC9kaXN0L3ZlcnNpb24ubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7QUFFbUI7QUFDbkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9udXJzZWJsb2MvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvaHR0cC9kaXN0L3ZlcnNpb24ubWpzP2E3NTgiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgVkVSU0lPTiA9IFwiQHR1cm5rZXkvaHR0cEAyLjEwLjBcIjtcblxuZXhwb3J0IHsgVkVSU0lPTiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVyc2lvbi5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/http/dist/version.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/http/dist/webauthn-json/api.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@turnkey/http/dist/webauthn-json/api.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createResponseToJSON: () => (/* binding */ createResponseToJSON),\n/* harmony export */   getResponseToJSON: () => (/* binding */ getResponseToJSON)\n/* harmony export */ });\n/* harmony import */ var _base64url_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base64url.mjs */ \"(ssr)/./node_modules/@turnkey/http/dist/webauthn-json/base64url.mjs\");\n/* harmony import */ var _convert_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./convert.mjs */ \"(ssr)/./node_modules/@turnkey/http/dist/webauthn-json/convert.mjs\");\n/* harmony import */ var _schema_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./schema.mjs */ \"(ssr)/./node_modules/@turnkey/http/dist/webauthn-json/schema.mjs\");\n\n\n\n\nfunction createResponseToJSON(credential) {\n    return (0,_convert_mjs__WEBPACK_IMPORTED_MODULE_1__.convert)(_base64url_mjs__WEBPACK_IMPORTED_MODULE_0__.bufferToBase64url, _schema_mjs__WEBPACK_IMPORTED_MODULE_2__.publicKeyCredentialWithAttestation, credential);\n}\nfunction getResponseToJSON(credential) {\n    return (0,_convert_mjs__WEBPACK_IMPORTED_MODULE_1__.convert)(_base64url_mjs__WEBPACK_IMPORTED_MODULE_0__.bufferToBase64url, _schema_mjs__WEBPACK_IMPORTED_MODULE_2__.publicKeyCredentialWithAssertion, credential);\n}\n\n\n//# sourceMappingURL=api.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvaHR0cC9kaXN0L3dlYmF1dGhuLWpzb24vYXBpLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFvRDtBQUNaO0FBQzREOztBQUVwRztBQUNBLFdBQVcscURBQU8sQ0FBQyw2REFBaUIsRUFBRSwyRUFBa0M7QUFDeEU7QUFDQTtBQUNBLFdBQVcscURBQU8sQ0FBQyw2REFBaUIsRUFBRSx5RUFBZ0M7QUFDdEU7O0FBRW1EO0FBQ25EIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbnVyc2VibG9jLy4vbm9kZV9tb2R1bGVzL0B0dXJua2V5L2h0dHAvZGlzdC93ZWJhdXRobi1qc29uL2FwaS5tanM/MTI1MSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBidWZmZXJUb0Jhc2U2NHVybCB9IGZyb20gJy4vYmFzZTY0dXJsLm1qcyc7XG5pbXBvcnQgeyBjb252ZXJ0IH0gZnJvbSAnLi9jb252ZXJ0Lm1qcyc7XG5pbXBvcnQgeyBwdWJsaWNLZXlDcmVkZW50aWFsV2l0aEF0dGVzdGF0aW9uLCBwdWJsaWNLZXlDcmVkZW50aWFsV2l0aEFzc2VydGlvbiB9IGZyb20gJy4vc2NoZW1hLm1qcyc7XG5cbmZ1bmN0aW9uIGNyZWF0ZVJlc3BvbnNlVG9KU09OKGNyZWRlbnRpYWwpIHtcbiAgICByZXR1cm4gY29udmVydChidWZmZXJUb0Jhc2U2NHVybCwgcHVibGljS2V5Q3JlZGVudGlhbFdpdGhBdHRlc3RhdGlvbiwgY3JlZGVudGlhbCk7XG59XG5mdW5jdGlvbiBnZXRSZXNwb25zZVRvSlNPTihjcmVkZW50aWFsKSB7XG4gICAgcmV0dXJuIGNvbnZlcnQoYnVmZmVyVG9CYXNlNjR1cmwsIHB1YmxpY0tleUNyZWRlbnRpYWxXaXRoQXNzZXJ0aW9uLCBjcmVkZW50aWFsKTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlUmVzcG9uc2VUb0pTT04sIGdldFJlc3BvbnNlVG9KU09OIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcGkubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/http/dist/webauthn-json/api.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/http/dist/webauthn-json/base64url.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@turnkey/http/dist/webauthn-json/base64url.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bufferToBase64url: () => (/* binding */ bufferToBase64url)\n/* harmony export */ });\nfunction bufferToBase64url(buffer) {\n    // Buffer to binary string\n    const byteView = new Uint8Array(buffer);\n    let str = \"\";\n    for (const charCode of byteView) {\n        str += String.fromCharCode(charCode);\n    }\n    // Binary string to base64\n    const base64String = btoa(str);\n    // Base64 to base64url\n    // We assume that the base64url string is well-formed.\n    const base64urlString = base64String\n        .replace(/\\+/g, \"-\")\n        .replace(/\\//g, \"_\")\n        .replace(/=/g, \"\");\n    return base64urlString;\n}\n\n\n//# sourceMappingURL=base64url.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvaHR0cC9kaXN0L3dlYmF1dGhuLWpzb24vYmFzZTY0dXJsLm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNkI7QUFDN0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9udXJzZWJsb2MvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvaHR0cC9kaXN0L3dlYmF1dGhuLWpzb24vYmFzZTY0dXJsLm1qcz8wNjdjIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGJ1ZmZlclRvQmFzZTY0dXJsKGJ1ZmZlcikge1xuICAgIC8vIEJ1ZmZlciB0byBiaW5hcnkgc3RyaW5nXG4gICAgY29uc3QgYnl0ZVZpZXcgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgIGxldCBzdHIgPSBcIlwiO1xuICAgIGZvciAoY29uc3QgY2hhckNvZGUgb2YgYnl0ZVZpZXcpIHtcbiAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xuICAgIH1cbiAgICAvLyBCaW5hcnkgc3RyaW5nIHRvIGJhc2U2NFxuICAgIGNvbnN0IGJhc2U2NFN0cmluZyA9IGJ0b2Eoc3RyKTtcbiAgICAvLyBCYXNlNjQgdG8gYmFzZTY0dXJsXG4gICAgLy8gV2UgYXNzdW1lIHRoYXQgdGhlIGJhc2U2NHVybCBzdHJpbmcgaXMgd2VsbC1mb3JtZWQuXG4gICAgY29uc3QgYmFzZTY0dXJsU3RyaW5nID0gYmFzZTY0U3RyaW5nXG4gICAgICAgIC5yZXBsYWNlKC9cXCsvZywgXCItXCIpXG4gICAgICAgIC5yZXBsYWNlKC9cXC8vZywgXCJfXCIpXG4gICAgICAgIC5yZXBsYWNlKC89L2csIFwiXCIpO1xuICAgIHJldHVybiBiYXNlNjR1cmxTdHJpbmc7XG59XG5cbmV4cG9ydCB7IGJ1ZmZlclRvQmFzZTY0dXJsIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlNjR1cmwubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/http/dist/webauthn-json/base64url.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/http/dist/webauthn-json/convert.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@turnkey/http/dist/webauthn-json/convert.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   convert: () => (/* binding */ convert),\n/* harmony export */   convertValue: () => (/* binding */ convertValue),\n/* harmony export */   copyValue: () => (/* binding */ copyValue),\n/* harmony export */   derived: () => (/* binding */ derived),\n/* harmony export */   optional: () => (/* binding */ optional),\n/* harmony export */   required: () => (/* binding */ required)\n/* harmony export */ });\n// We export these values in order so that they can be used to deduplicate\n// schema definitions in minified JS code.\n// TODO: Parcel isn't deduplicating these values.\nconst copyValue = \"copy\";\nconst convertValue = \"convert\";\nfunction convert(conversionFn, schema, input) {\n    if (schema === copyValue) {\n        return input;\n    }\n    if (schema === convertValue) {\n        return conversionFn(input);\n    }\n    if (schema instanceof Array) {\n        return input.map((v) => convert(conversionFn, schema[0], v));\n    }\n    if (schema instanceof Object) {\n        const output = {};\n        for (const [key, schemaField] of Object.entries(schema)) {\n            if (schemaField.derive) {\n                const v = schemaField.derive(input);\n                if (v !== undefined) {\n                    input[key] = v;\n                }\n            }\n            if (!(key in input)) {\n                if (schemaField.required) {\n                    throw new Error(`Missing key: ${key}`);\n                }\n                continue;\n            }\n            // Fields can be null (rather than missing or `undefined`), e.g. the\n            // `userHandle` field of the `AuthenticatorAssertionResponse`:\n            // https://www.w3.org/TR/webauthn/#iface-authenticatorassertionresponse\n            if (input[key] == null) {\n                output[key] = null;\n                continue;\n            }\n            output[key] = convert(conversionFn, schemaField.schema, input[key]);\n        }\n        return output;\n    }\n}\nfunction derived(schema, derive) {\n    return {\n        required: true,\n        schema,\n        derive,\n    };\n}\nfunction required(schema) {\n    return {\n        required: true,\n        schema,\n    };\n}\nfunction optional(schema) {\n    return {\n        required: false,\n        schema,\n    };\n}\n\n\n//# sourceMappingURL=convert.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvaHR0cC9kaXN0L3dlYmF1dGhuLWpzb24vY29udmVydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxJQUFJO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV5RTtBQUN6RSIsInNvdXJjZXMiOlsid2VicGFjazovL251cnNlYmxvYy8uL25vZGVfbW9kdWxlcy9AdHVybmtleS9odHRwL2Rpc3Qvd2ViYXV0aG4tanNvbi9jb252ZXJ0Lm1qcz84OWI2Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFdlIGV4cG9ydCB0aGVzZSB2YWx1ZXMgaW4gb3JkZXIgc28gdGhhdCB0aGV5IGNhbiBiZSB1c2VkIHRvIGRlZHVwbGljYXRlXG4vLyBzY2hlbWEgZGVmaW5pdGlvbnMgaW4gbWluaWZpZWQgSlMgY29kZS5cbi8vIFRPRE86IFBhcmNlbCBpc24ndCBkZWR1cGxpY2F0aW5nIHRoZXNlIHZhbHVlcy5cbmNvbnN0IGNvcHlWYWx1ZSA9IFwiY29weVwiO1xuY29uc3QgY29udmVydFZhbHVlID0gXCJjb252ZXJ0XCI7XG5mdW5jdGlvbiBjb252ZXJ0KGNvbnZlcnNpb25Gbiwgc2NoZW1hLCBpbnB1dCkge1xuICAgIGlmIChzY2hlbWEgPT09IGNvcHlWYWx1ZSkge1xuICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuICAgIGlmIChzY2hlbWEgPT09IGNvbnZlcnRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gY29udmVyc2lvbkZuKGlucHV0KTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIHJldHVybiBpbnB1dC5tYXAoKHYpID0+IGNvbnZlcnQoY29udmVyc2lvbkZuLCBzY2hlbWFbMF0sIHYpKTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCBzY2hlbWFGaWVsZF0gb2YgT2JqZWN0LmVudHJpZXMoc2NoZW1hKSkge1xuICAgICAgICAgICAgaWYgKHNjaGVtYUZpZWxkLmRlcml2ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHYgPSBzY2hlbWFGaWVsZC5kZXJpdmUoaW5wdXQpO1xuICAgICAgICAgICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRba2V5XSA9IHY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEoa2V5IGluIGlucHV0KSkge1xuICAgICAgICAgICAgICAgIGlmIChzY2hlbWFGaWVsZC5yZXF1aXJlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1pc3Npbmcga2V5OiAke2tleX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGaWVsZHMgY2FuIGJlIG51bGwgKHJhdGhlciB0aGFuIG1pc3Npbmcgb3IgYHVuZGVmaW5lZGApLCBlLmcuIHRoZVxuICAgICAgICAgICAgLy8gYHVzZXJIYW5kbGVgIGZpZWxkIG9mIHRoZSBgQXV0aGVudGljYXRvckFzc2VydGlvblJlc3BvbnNlYDpcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJhdXRobi8jaWZhY2UtYXV0aGVudGljYXRvcmFzc2VydGlvbnJlc3BvbnNlXG4gICAgICAgICAgICBpZiAoaW5wdXRba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W2tleV0gPSBudWxsO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0cHV0W2tleV0gPSBjb252ZXJ0KGNvbnZlcnNpb25Gbiwgc2NoZW1hRmllbGQuc2NoZW1hLCBpbnB1dFtrZXldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRlcml2ZWQoc2NoZW1hLCBkZXJpdmUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgICAgc2NoZW1hLFxuICAgICAgICBkZXJpdmUsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJlcXVpcmVkKHNjaGVtYSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgICBzY2hlbWEsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIG9wdGlvbmFsKHNjaGVtYSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHJlcXVpcmVkOiBmYWxzZSxcbiAgICAgICAgc2NoZW1hLFxuICAgIH07XG59XG5cbmV4cG9ydCB7IGNvbnZlcnQsIGNvbnZlcnRWYWx1ZSwgY29weVZhbHVlLCBkZXJpdmVkLCBvcHRpb25hbCwgcmVxdWlyZWQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnZlcnQubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/http/dist/webauthn-json/convert.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/http/dist/webauthn-json/index.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@turnkey/http/dist/webauthn-json/index.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   create: () => (/* binding */ create),\n/* harmony export */   get: () => (/* binding */ get)\n/* harmony export */ });\n/* harmony import */ var _api_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./api.mjs */ \"(ssr)/./node_modules/@turnkey/http/dist/webauthn-json/api.mjs\");\n\n\nasync function create(options) {\n    const response = (await navigator.credentials.create(options));\n    response.toJSON = () => (0,_api_mjs__WEBPACK_IMPORTED_MODULE_0__.createResponseToJSON)(response);\n    return response;\n}\nasync function get(options) {\n    const response = (await navigator.credentials.get(options));\n    response.toJSON = () => (0,_api_mjs__WEBPACK_IMPORTED_MODULE_0__.getResponseToJSON)(response);\n    return response;\n}\n\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvaHR0cC9kaXN0L3dlYmF1dGhuLWpzb24vaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFvRTs7QUFFcEU7QUFDQTtBQUNBLDRCQUE0Qiw4REFBb0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMkRBQWlCO0FBQzdDO0FBQ0E7O0FBRXVCO0FBQ3ZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbnVyc2VibG9jLy4vbm9kZV9tb2R1bGVzL0B0dXJua2V5L2h0dHAvZGlzdC93ZWJhdXRobi1qc29uL2luZGV4Lm1qcz9jNDVmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZVJlc3BvbnNlVG9KU09OLCBnZXRSZXNwb25zZVRvSlNPTiB9IGZyb20gJy4vYXBpLm1qcyc7XG5cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZShvcHRpb25zKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSAoYXdhaXQgbmF2aWdhdG9yLmNyZWRlbnRpYWxzLmNyZWF0ZShvcHRpb25zKSk7XG4gICAgcmVzcG9uc2UudG9KU09OID0gKCkgPT4gY3JlYXRlUmVzcG9uc2VUb0pTT04ocmVzcG9uc2UpO1xuICAgIHJldHVybiByZXNwb25zZTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldChvcHRpb25zKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSAoYXdhaXQgbmF2aWdhdG9yLmNyZWRlbnRpYWxzLmdldChvcHRpb25zKSk7XG4gICAgcmVzcG9uc2UudG9KU09OID0gKCkgPT4gZ2V0UmVzcG9uc2VUb0pTT04ocmVzcG9uc2UpO1xuICAgIHJldHVybiByZXNwb25zZTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlLCBnZXQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/http/dist/webauthn-json/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/http/dist/webauthn-json/schema.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@turnkey/http/dist/webauthn-json/schema.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   publicKeyCredentialWithAssertion: () => (/* binding */ publicKeyCredentialWithAssertion),\n/* harmony export */   publicKeyCredentialWithAttestation: () => (/* binding */ publicKeyCredentialWithAttestation)\n/* harmony export */ });\n/* harmony import */ var _convert_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./convert.mjs */ \"(ssr)/./node_modules/@turnkey/http/dist/webauthn-json/convert.mjs\");\n\n\nconst simplifiedClientExtensionResultsSchema = {\n    appid: (0,_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.optional)(_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.copyValue),\n    appidExclude: (0,_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.optional)(_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.copyValue),\n    credProps: (0,_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.optional)(_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.copyValue),\n};\n// `navigator.create()` response\nconst publicKeyCredentialWithAttestation = {\n    type: (0,_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.required)(_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.copyValue),\n    id: (0,_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.required)(_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.copyValue),\n    rawId: (0,_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.required)(_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.convertValue),\n    authenticatorAttachment: (0,_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.optional)(_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.copyValue),\n    response: (0,_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.required)({\n        clientDataJSON: (0,_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.required)(_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.convertValue),\n        attestationObject: (0,_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.required)(_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.convertValue),\n        transports: (0,_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.derived)(_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.copyValue, (response) => response.getTransports?.() || []),\n    }),\n    clientExtensionResults: (0,_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.derived)(simplifiedClientExtensionResultsSchema, (pkc) => pkc.getClientExtensionResults()),\n};\n// `navigator.get()` response\nconst publicKeyCredentialWithAssertion = {\n    type: (0,_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.required)(_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.copyValue),\n    id: (0,_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.required)(_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.copyValue),\n    rawId: (0,_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.required)(_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.convertValue),\n    authenticatorAttachment: (0,_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.optional)(_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.copyValue),\n    response: (0,_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.required)({\n        clientDataJSON: (0,_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.required)(_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.convertValue),\n        authenticatorData: (0,_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.required)(_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.convertValue),\n        signature: (0,_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.required)(_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.convertValue),\n        userHandle: (0,_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.required)(_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.convertValue),\n    }),\n    clientExtensionResults: (0,_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.derived)(simplifiedClientExtensionResultsSchema, (pkc) => pkc.getClientExtensionResults()),\n};\n\n\n//# sourceMappingURL=schema.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvaHR0cC9kaXN0L3dlYmF1dGhuLWpzb24vc2NoZW1hLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBcUY7O0FBRXJGO0FBQ0EsV0FBVyxzREFBUSxDQUFDLG1EQUFTO0FBQzdCLGtCQUFrQixzREFBUSxDQUFDLG1EQUFTO0FBQ3BDLGVBQWUsc0RBQVEsQ0FBQyxtREFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQSxVQUFVLHNEQUFRLENBQUMsbURBQVM7QUFDNUIsUUFBUSxzREFBUSxDQUFDLG1EQUFTO0FBQzFCLFdBQVcsc0RBQVEsQ0FBQyxzREFBWTtBQUNoQyw2QkFBNkIsc0RBQVEsQ0FBQyxtREFBUztBQUMvQyxjQUFjLHNEQUFRO0FBQ3RCLHdCQUF3QixzREFBUSxDQUFDLHNEQUFZO0FBQzdDLDJCQUEyQixzREFBUSxDQUFDLHNEQUFZO0FBQ2hELG9CQUFvQixxREFBTyxDQUFDLG1EQUFTO0FBQ3JDLEtBQUs7QUFDTCw0QkFBNEIscURBQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0EsVUFBVSxzREFBUSxDQUFDLG1EQUFTO0FBQzVCLFFBQVEsc0RBQVEsQ0FBQyxtREFBUztBQUMxQixXQUFXLHNEQUFRLENBQUMsc0RBQVk7QUFDaEMsNkJBQTZCLHNEQUFRLENBQUMsbURBQVM7QUFDL0MsY0FBYyxzREFBUTtBQUN0Qix3QkFBd0Isc0RBQVEsQ0FBQyxzREFBWTtBQUM3QywyQkFBMkIsc0RBQVEsQ0FBQyxzREFBWTtBQUNoRCxtQkFBbUIsc0RBQVEsQ0FBQyxzREFBWTtBQUN4QyxvQkFBb0Isc0RBQVEsQ0FBQyxzREFBWTtBQUN6QyxLQUFLO0FBQ0wsNEJBQTRCLHFEQUFPO0FBQ25DOztBQUVnRjtBQUNoRiIsInNvdXJjZXMiOlsid2VicGFjazovL251cnNlYmxvYy8uL25vZGVfbW9kdWxlcy9AdHVybmtleS9odHRwL2Rpc3Qvd2ViYXV0aG4tanNvbi9zY2hlbWEubWpzPzRhZjYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmVxdWlyZWQsIG9wdGlvbmFsLCBkZXJpdmVkLCBjb3B5VmFsdWUsIGNvbnZlcnRWYWx1ZSB9IGZyb20gJy4vY29udmVydC5tanMnO1xuXG5jb25zdCBzaW1wbGlmaWVkQ2xpZW50RXh0ZW5zaW9uUmVzdWx0c1NjaGVtYSA9IHtcbiAgICBhcHBpZDogb3B0aW9uYWwoY29weVZhbHVlKSxcbiAgICBhcHBpZEV4Y2x1ZGU6IG9wdGlvbmFsKGNvcHlWYWx1ZSksXG4gICAgY3JlZFByb3BzOiBvcHRpb25hbChjb3B5VmFsdWUpLFxufTtcbi8vIGBuYXZpZ2F0b3IuY3JlYXRlKClgIHJlc3BvbnNlXG5jb25zdCBwdWJsaWNLZXlDcmVkZW50aWFsV2l0aEF0dGVzdGF0aW9uID0ge1xuICAgIHR5cGU6IHJlcXVpcmVkKGNvcHlWYWx1ZSksXG4gICAgaWQ6IHJlcXVpcmVkKGNvcHlWYWx1ZSksXG4gICAgcmF3SWQ6IHJlcXVpcmVkKGNvbnZlcnRWYWx1ZSksXG4gICAgYXV0aGVudGljYXRvckF0dGFjaG1lbnQ6IG9wdGlvbmFsKGNvcHlWYWx1ZSksXG4gICAgcmVzcG9uc2U6IHJlcXVpcmVkKHtcbiAgICAgICAgY2xpZW50RGF0YUpTT046IHJlcXVpcmVkKGNvbnZlcnRWYWx1ZSksXG4gICAgICAgIGF0dGVzdGF0aW9uT2JqZWN0OiByZXF1aXJlZChjb252ZXJ0VmFsdWUpLFxuICAgICAgICB0cmFuc3BvcnRzOiBkZXJpdmVkKGNvcHlWYWx1ZSwgKHJlc3BvbnNlKSA9PiByZXNwb25zZS5nZXRUcmFuc3BvcnRzPy4oKSB8fCBbXSksXG4gICAgfSksXG4gICAgY2xpZW50RXh0ZW5zaW9uUmVzdWx0czogZGVyaXZlZChzaW1wbGlmaWVkQ2xpZW50RXh0ZW5zaW9uUmVzdWx0c1NjaGVtYSwgKHBrYykgPT4gcGtjLmdldENsaWVudEV4dGVuc2lvblJlc3VsdHMoKSksXG59O1xuLy8gYG5hdmlnYXRvci5nZXQoKWAgcmVzcG9uc2VcbmNvbnN0IHB1YmxpY0tleUNyZWRlbnRpYWxXaXRoQXNzZXJ0aW9uID0ge1xuICAgIHR5cGU6IHJlcXVpcmVkKGNvcHlWYWx1ZSksXG4gICAgaWQ6IHJlcXVpcmVkKGNvcHlWYWx1ZSksXG4gICAgcmF3SWQ6IHJlcXVpcmVkKGNvbnZlcnRWYWx1ZSksXG4gICAgYXV0aGVudGljYXRvckF0dGFjaG1lbnQ6IG9wdGlvbmFsKGNvcHlWYWx1ZSksXG4gICAgcmVzcG9uc2U6IHJlcXVpcmVkKHtcbiAgICAgICAgY2xpZW50RGF0YUpTT046IHJlcXVpcmVkKGNvbnZlcnRWYWx1ZSksXG4gICAgICAgIGF1dGhlbnRpY2F0b3JEYXRhOiByZXF1aXJlZChjb252ZXJ0VmFsdWUpLFxuICAgICAgICBzaWduYXR1cmU6IHJlcXVpcmVkKGNvbnZlcnRWYWx1ZSksXG4gICAgICAgIHVzZXJIYW5kbGU6IHJlcXVpcmVkKGNvbnZlcnRWYWx1ZSksXG4gICAgfSksXG4gICAgY2xpZW50RXh0ZW5zaW9uUmVzdWx0czogZGVyaXZlZChzaW1wbGlmaWVkQ2xpZW50RXh0ZW5zaW9uUmVzdWx0c1NjaGVtYSwgKHBrYykgPT4gcGtjLmdldENsaWVudEV4dGVuc2lvblJlc3VsdHMoKSksXG59O1xuXG5leHBvcnQgeyBwdWJsaWNLZXlDcmVkZW50aWFsV2l0aEFzc2VydGlvbiwgcHVibGljS2V5Q3JlZGVudGlhbFdpdGhBdHRlc3RhdGlvbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2NoZW1hLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/http/dist/webauthn-json/schema.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/http/dist/webauthn.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@turnkey/http/dist/webauthn.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getWebAuthnAssertion: () => (/* binding */ getWebAuthnAssertion),\n/* harmony export */   getWebAuthnAttestation: () => (/* binding */ getWebAuthnAttestation),\n/* harmony export */   protocolTransportEnumToInternalEnum: () => (/* binding */ protocolTransportEnumToInternalEnum)\n/* harmony export */ });\n/* harmony import */ var _webauthn_json_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webauthn-json/index.mjs */ \"(ssr)/./node_modules/@turnkey/http/dist/webauthn-json/index.mjs\");\n\n\nconst defaultTimeout = 5 * 60 * 1000; // five minutes\nconst defaultUserVerification = \"preferred\";\nconst defaultSigningOptions = {\n    publicKey: {\n        timeout: defaultTimeout,\n        userVerification: defaultUserVerification,\n    },\n};\nasync function getCredentialRequestOptions(payload, tkSigningOptions = defaultSigningOptions) {\n    const challenge = await getChallengeFromPayload(payload);\n    const signingOptions = {\n        ...tkSigningOptions,\n        publicKey: {\n            ...defaultSigningOptions.publicKey,\n            ...tkSigningOptions.publicKey,\n            challenge,\n        },\n    };\n    return signingOptions;\n}\nasync function getChallengeFromPayload(payload) {\n    const messageBuffer = new TextEncoder().encode(payload);\n    const hashBuffer = await crypto.subtle.digest(\"SHA-256\", messageBuffer);\n    const hexString = Buffer.from(hashBuffer).toString(\"hex\");\n    const hexBuffer = Buffer.from(hexString, \"utf8\");\n    return new Uint8Array(hexBuffer);\n}\n/* Pulled from https://www.w3.org/TR/webauthn-2/#enum-transport */\nfunction protocolTransportEnumToInternalEnum(protocolEnum) {\n    switch (protocolEnum) {\n        case \"internal\": {\n            return \"AUTHENTICATOR_TRANSPORT_INTERNAL\";\n        }\n        case \"usb\": {\n            return \"AUTHENTICATOR_TRANSPORT_USB\";\n        }\n        case \"nfc\": {\n            return \"AUTHENTICATOR_TRANSPORT_NFC\";\n        }\n        case \"ble\": {\n            return \"AUTHENTICATOR_TRANSPORT_BLE\";\n        }\n        case \"hybrid\": {\n            return \"AUTHENTICATOR_TRANSPORT_HYBRID\";\n        }\n        default: {\n            throw new Error(\"unsupported transport format\");\n        }\n    }\n}\nfunction toInternalAttestation(attestation) {\n    return {\n        credentialId: attestation.rawId,\n        attestationObject: attestation.response.attestationObject,\n        clientDataJson: attestation.response.clientDataJSON,\n        transports: attestation.response.transports.map(protocolTransportEnumToInternalEnum),\n    };\n}\nasync function getWebAuthnAssertion(payload, options) {\n    const webAuthnSupported = hasWebAuthnSupport();\n    if (!webAuthnSupported) {\n        throw new Error(\"webauthn is not supported by this browser\");\n    }\n    const signingOptions = await getCredentialRequestOptions(payload, options);\n    const clientGetResult = await (0,_webauthn_json_index_mjs__WEBPACK_IMPORTED_MODULE_0__.get)(signingOptions);\n    const assertion = clientGetResult.toJSON();\n    const stamp = {\n        authenticatorData: assertion.response.authenticatorData,\n        clientDataJson: assertion.response.clientDataJSON,\n        credentialId: assertion.id,\n        signature: assertion.response.signature,\n    };\n    return JSON.stringify(stamp);\n}\nasync function getWebAuthnAttestation(options) {\n    const webAuthnSupported = hasWebAuthnSupport();\n    if (!webAuthnSupported) {\n        throw new Error(\"webauthn is not supported by this browser\");\n    }\n    const res = await (0,_webauthn_json_index_mjs__WEBPACK_IMPORTED_MODULE_0__.create)(options);\n    return toInternalAttestation(res.toJSON());\n}\n// `hasWebAuthnSupport` checks for barebones webauthn support.\n// For additional details and granular settings, see:\n// https://web.dev/articles/passkey-form-autofill#feature-detection, https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredential\nfunction hasWebAuthnSupport() {\n    return !!window.PublicKeyCredential;\n}\n\n\n//# sourceMappingURL=webauthn.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvaHR0cC9kaXN0L3dlYmF1dGhuLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXdEOztBQUV4RCxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyw2REFBRztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdFQUFNO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTZGO0FBQzdGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbnVyc2VibG9jLy4vbm9kZV9tb2R1bGVzL0B0dXJua2V5L2h0dHAvZGlzdC93ZWJhdXRobi5tanM/NmMyOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGUsIGdldCB9IGZyb20gJy4vd2ViYXV0aG4tanNvbi9pbmRleC5tanMnO1xuXG5jb25zdCBkZWZhdWx0VGltZW91dCA9IDUgKiA2MCAqIDEwMDA7IC8vIGZpdmUgbWludXRlc1xuY29uc3QgZGVmYXVsdFVzZXJWZXJpZmljYXRpb24gPSBcInByZWZlcnJlZFwiO1xuY29uc3QgZGVmYXVsdFNpZ25pbmdPcHRpb25zID0ge1xuICAgIHB1YmxpY0tleToge1xuICAgICAgICB0aW1lb3V0OiBkZWZhdWx0VGltZW91dCxcbiAgICAgICAgdXNlclZlcmlmaWNhdGlvbjogZGVmYXVsdFVzZXJWZXJpZmljYXRpb24sXG4gICAgfSxcbn07XG5hc3luYyBmdW5jdGlvbiBnZXRDcmVkZW50aWFsUmVxdWVzdE9wdGlvbnMocGF5bG9hZCwgdGtTaWduaW5nT3B0aW9ucyA9IGRlZmF1bHRTaWduaW5nT3B0aW9ucykge1xuICAgIGNvbnN0IGNoYWxsZW5nZSA9IGF3YWl0IGdldENoYWxsZW5nZUZyb21QYXlsb2FkKHBheWxvYWQpO1xuICAgIGNvbnN0IHNpZ25pbmdPcHRpb25zID0ge1xuICAgICAgICAuLi50a1NpZ25pbmdPcHRpb25zLFxuICAgICAgICBwdWJsaWNLZXk6IHtcbiAgICAgICAgICAgIC4uLmRlZmF1bHRTaWduaW5nT3B0aW9ucy5wdWJsaWNLZXksXG4gICAgICAgICAgICAuLi50a1NpZ25pbmdPcHRpb25zLnB1YmxpY0tleSxcbiAgICAgICAgICAgIGNoYWxsZW5nZSxcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIHJldHVybiBzaWduaW5nT3B0aW9ucztcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldENoYWxsZW5nZUZyb21QYXlsb2FkKHBheWxvYWQpIHtcbiAgICBjb25zdCBtZXNzYWdlQnVmZmVyID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHBheWxvYWQpO1xuICAgIGNvbnN0IGhhc2hCdWZmZXIgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmRpZ2VzdChcIlNIQS0yNTZcIiwgbWVzc2FnZUJ1ZmZlcik7XG4gICAgY29uc3QgaGV4U3RyaW5nID0gQnVmZmVyLmZyb20oaGFzaEJ1ZmZlcikudG9TdHJpbmcoXCJoZXhcIik7XG4gICAgY29uc3QgaGV4QnVmZmVyID0gQnVmZmVyLmZyb20oaGV4U3RyaW5nLCBcInV0ZjhcIik7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGhleEJ1ZmZlcik7XG59XG4vKiBQdWxsZWQgZnJvbSBodHRwczovL3d3dy53My5vcmcvVFIvd2ViYXV0aG4tMi8jZW51bS10cmFuc3BvcnQgKi9cbmZ1bmN0aW9uIHByb3RvY29sVHJhbnNwb3J0RW51bVRvSW50ZXJuYWxFbnVtKHByb3RvY29sRW51bSkge1xuICAgIHN3aXRjaCAocHJvdG9jb2xFbnVtKSB7XG4gICAgICAgIGNhc2UgXCJpbnRlcm5hbFwiOiB7XG4gICAgICAgICAgICByZXR1cm4gXCJBVVRIRU5USUNBVE9SX1RSQU5TUE9SVF9JTlRFUk5BTFwiO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJ1c2JcIjoge1xuICAgICAgICAgICAgcmV0dXJuIFwiQVVUSEVOVElDQVRPUl9UUkFOU1BPUlRfVVNCXCI7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIm5mY1wiOiB7XG4gICAgICAgICAgICByZXR1cm4gXCJBVVRIRU5USUNBVE9SX1RSQU5TUE9SVF9ORkNcIjtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiYmxlXCI6IHtcbiAgICAgICAgICAgIHJldHVybiBcIkFVVEhFTlRJQ0FUT1JfVFJBTlNQT1JUX0JMRVwiO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJoeWJyaWRcIjoge1xuICAgICAgICAgICAgcmV0dXJuIFwiQVVUSEVOVElDQVRPUl9UUkFOU1BPUlRfSFlCUklEXCI7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgdHJhbnNwb3J0IGZvcm1hdFwiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHRvSW50ZXJuYWxBdHRlc3RhdGlvbihhdHRlc3RhdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNyZWRlbnRpYWxJZDogYXR0ZXN0YXRpb24ucmF3SWQsXG4gICAgICAgIGF0dGVzdGF0aW9uT2JqZWN0OiBhdHRlc3RhdGlvbi5yZXNwb25zZS5hdHRlc3RhdGlvbk9iamVjdCxcbiAgICAgICAgY2xpZW50RGF0YUpzb246IGF0dGVzdGF0aW9uLnJlc3BvbnNlLmNsaWVudERhdGFKU09OLFxuICAgICAgICB0cmFuc3BvcnRzOiBhdHRlc3RhdGlvbi5yZXNwb25zZS50cmFuc3BvcnRzLm1hcChwcm90b2NvbFRyYW5zcG9ydEVudW1Ub0ludGVybmFsRW51bSksXG4gICAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldFdlYkF1dGhuQXNzZXJ0aW9uKHBheWxvYWQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB3ZWJBdXRoblN1cHBvcnRlZCA9IGhhc1dlYkF1dGhuU3VwcG9ydCgpO1xuICAgIGlmICghd2ViQXV0aG5TdXBwb3J0ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwid2ViYXV0aG4gaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIGJyb3dzZXJcIik7XG4gICAgfVxuICAgIGNvbnN0IHNpZ25pbmdPcHRpb25zID0gYXdhaXQgZ2V0Q3JlZGVudGlhbFJlcXVlc3RPcHRpb25zKHBheWxvYWQsIG9wdGlvbnMpO1xuICAgIGNvbnN0IGNsaWVudEdldFJlc3VsdCA9IGF3YWl0IGdldChzaWduaW5nT3B0aW9ucyk7XG4gICAgY29uc3QgYXNzZXJ0aW9uID0gY2xpZW50R2V0UmVzdWx0LnRvSlNPTigpO1xuICAgIGNvbnN0IHN0YW1wID0ge1xuICAgICAgICBhdXRoZW50aWNhdG9yRGF0YTogYXNzZXJ0aW9uLnJlc3BvbnNlLmF1dGhlbnRpY2F0b3JEYXRhLFxuICAgICAgICBjbGllbnREYXRhSnNvbjogYXNzZXJ0aW9uLnJlc3BvbnNlLmNsaWVudERhdGFKU09OLFxuICAgICAgICBjcmVkZW50aWFsSWQ6IGFzc2VydGlvbi5pZCxcbiAgICAgICAgc2lnbmF0dXJlOiBhc3NlcnRpb24ucmVzcG9uc2Uuc2lnbmF0dXJlLFxuICAgIH07XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHN0YW1wKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldFdlYkF1dGhuQXR0ZXN0YXRpb24ob3B0aW9ucykge1xuICAgIGNvbnN0IHdlYkF1dGhuU3VwcG9ydGVkID0gaGFzV2ViQXV0aG5TdXBwb3J0KCk7XG4gICAgaWYgKCF3ZWJBdXRoblN1cHBvcnRlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ3ZWJhdXRobiBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgYnJvd3NlclwiKTtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gYXdhaXQgY3JlYXRlKG9wdGlvbnMpO1xuICAgIHJldHVybiB0b0ludGVybmFsQXR0ZXN0YXRpb24ocmVzLnRvSlNPTigpKTtcbn1cbi8vIGBoYXNXZWJBdXRoblN1cHBvcnRgIGNoZWNrcyBmb3IgYmFyZWJvbmVzIHdlYmF1dGhuIHN1cHBvcnQuXG4vLyBGb3IgYWRkaXRpb25hbCBkZXRhaWxzIGFuZCBncmFudWxhciBzZXR0aW5ncywgc2VlOlxuLy8gaHR0cHM6Ly93ZWIuZGV2L2FydGljbGVzL3Bhc3NrZXktZm9ybS1hdXRvZmlsbCNmZWF0dXJlLWRldGVjdGlvbiwgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1B1YmxpY0tleUNyZWRlbnRpYWxcbmZ1bmN0aW9uIGhhc1dlYkF1dGhuU3VwcG9ydCgpIHtcbiAgICByZXR1cm4gISF3aW5kb3cuUHVibGljS2V5Q3JlZGVudGlhbDtcbn1cblxuZXhwb3J0IHsgZ2V0V2ViQXV0aG5Bc3NlcnRpb24sIGdldFdlYkF1dGhuQXR0ZXN0YXRpb24sIHByb3RvY29sVHJhbnNwb3J0RW51bVRvSW50ZXJuYWxFbnVtIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD13ZWJhdXRobi5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/http/dist/webauthn.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/iframe-stamper/dist/index.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@turnkey/iframe-stamper/dist/index.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IframeEventType: () => (/* binding */ IframeEventType),\n/* harmony export */   IframeStamper: () => (/* binding */ IframeStamper),\n/* harmony export */   KeyFormat: () => (/* binding */ KeyFormat)\n/* harmony export */ });\n/// <reference lib=\"dom\" />\n// Header name for an API key stamp\nconst stampHeaderName = \"X-Stamp\";\n// Set of constants for event types expected to be sent and received between a parent page and its iframe.\nvar IframeEventType;\n(function (IframeEventType) {\n    // Event sent by the iframe to its parent to indicate readiness.\n    // Value: the iframe public key\n    IframeEventType[\"PublicKeyReady\"] = \"PUBLIC_KEY_READY\";\n    // Event sent by the parent to inject a credential bundle (for recovery or auth) into the iframe.\n    // Value: the bundle to inject\n    IframeEventType[\"InjectCredentialBundle\"] = \"INJECT_CREDENTIAL_BUNDLE\";\n    // Event sent by the parent to inject a private key export bundle into the iframe.\n    // Value: the bundle to inject\n    // Key Format (optional): the key format to encode the private key in after it's exported and decrypted: HEXADECIMAL or SOLANA. Defaults to HEXADECIMAL.\n    // Public Key (optional): the public key of the exported private key. Required when the key format is SOLANA.\n    IframeEventType[\"InjectKeyExportBundle\"] = \"INJECT_KEY_EXPORT_BUNDLE\";\n    // Event sent by the parent to inject a wallet export bundle into the iframe.\n    // Value: the bundle to inject\n    IframeEventType[\"InjectWalletExportBundle\"] = \"INJECT_WALLET_EXPORT_BUNDLE\";\n    // Event sent by the parent to inject an import bundle into the iframe.\n    // Value: the bundle to inject\n    IframeEventType[\"InjectImportBundle\"] = \"INJECT_IMPORT_BUNDLE\";\n    // Event sent by the parent to extract an encrypted wallet bundle from the iframe.\n    // Value: none\n    IframeEventType[\"ExtractWalletEncryptedBundle\"] = \"EXTRACT_WALLET_ENCRYPTED_BUNDLE\";\n    // Event sent by the parent to extract an encrypted private key bundle from the iframe.\n    // Value: none\n    // Key Format (optional): the key format to decode the private key in before it's encrypted for import: HEXADECIMAL or SOLANA. Defaults to HEXADECIMAL.\n    IframeEventType[\"ExtractKeyEncryptedBundle\"] = \"EXTRACT_KEY_ENCRYPTED_BUNDLE\";\n    // Event sent by the iframe to its parent when `InjectBundle` is successful\n    // Value: true (boolean)\n    IframeEventType[\"BundleInjected\"] = \"BUNDLE_INJECTED\";\n    // Event sent by the iframe to its parent when `ExtractEncryptedBundle` is successful\n    // Value: the bundle encrypted in the iframe\n    IframeEventType[\"EncryptedBundleExtracted\"] = \"ENCRYPTED_BUNDLE_EXTRACTED\";\n    // Event sent by the parent page to request a signature\n    // Value: payload to sign\n    IframeEventType[\"StampRequest\"] = \"STAMP_REQUEST\";\n    // Event sent by the iframe to communicate the result of a stamp operation.\n    // Value: signed payload\n    IframeEventType[\"Stamp\"] = \"STAMP\";\n    // Event sent by the iframe to communicate an error\n    // Value: serialized error\n    IframeEventType[\"Error\"] = \"ERROR\";\n})(IframeEventType || (IframeEventType = {}));\n// Set of constants for private key formats. These formats map to the encoding type used on a private key before encrypting and importing it\n// or after exporting it and decrypting it.\nvar KeyFormat;\n(function (KeyFormat) {\n    // 64 hexadecimal digits. Key format used by MetaMask, MyEtherWallet, Phantom, Ledger, and Trezor for Ethereum and Tron keys\n    KeyFormat[\"Hexadecimal\"] = \"HEXADECIMAL\";\n    // Key format used by Phantom and Solflare for Solana keys\n    KeyFormat[\"Solana\"] = \"SOLANA\";\n})(KeyFormat || (KeyFormat = {}));\n/**\n * Stamper to use with `@turnkey/http`'s `TurnkeyClient`\n * Creating a stamper inserts an iframe in the current page.\n */\nclass IframeStamper {\n    /**\n     * Creates a new iframe stamper. This function _does not_ insert the iframe in the DOM.\n     * Call `.init()` to insert the iframe element in the DOM.\n     */\n    constructor(config) {\n        if (typeof window === \"undefined\") {\n            throw new Error(\"Cannot initialize iframe in non-browser environment\");\n        }\n        if (!config.iframeContainer) {\n            throw new Error(\"Iframe container cannot be found\");\n        }\n        this.container = config.iframeContainer;\n        if (this.container.querySelector(`#${config.iframeElementId}`)) {\n            throw new Error(`Iframe element with ID ${config.iframeElementId} already exists`);\n        }\n        let iframe = window.document.createElement(\"iframe\");\n        iframe.id = config.iframeElementId;\n        iframe.src = config.iframeUrl;\n        this.iframe = iframe;\n        const iframeUrl = new URL(config.iframeUrl);\n        this.iframeOrigin = iframeUrl.origin;\n        // This is populated once the iframe is ready. Call `.init()` to kick off DOM insertion!\n        this.iframePublicKey = null;\n    }\n    /**\n     * Inserts the iframe on the page and returns a promise resolving to the iframe's public key\n     */\n    async init() {\n        this.container.appendChild(this.iframe);\n        return new Promise((resolve, _reject) => {\n            window.addEventListener(\"message\", (event) => {\n                if (event.origin !== this.iframeOrigin) {\n                    // There might be other things going on in the window, for example: react dev tools, other extensions, etc.\n                    // Instead of erroring out\n                    return;\n                }\n                if (event.data?.type === IframeEventType.PublicKeyReady) {\n                    this.iframePublicKey = event.data[\"value\"];\n                    resolve(event.data[\"value\"]);\n                }\n            }, false);\n        });\n    }\n    /**\n     * Removes the iframe from the DOM\n     */\n    clear() {\n        this.iframe.remove();\n    }\n    /**\n     * Returns the public key, or `null` if the underlying iframe isn't properly initialized.\n     */\n    publicKey() {\n        return this.iframePublicKey;\n    }\n    /**\n     * Function to inject a new credential into the iframe\n     * The bundle should be encrypted to the iframe's initial public key\n     * Encryption should be performed with HPKE (RFC 9180).\n     * This is used during recovery and auth flows.\n     */\n    async injectCredentialBundle(bundle) {\n        return new Promise((resolve, reject) => {\n            this.iframe.contentWindow?.postMessage({\n                type: IframeEventType.InjectCredentialBundle,\n                value: bundle,\n            }, \"*\");\n            window.addEventListener(\"message\", (event) => {\n                if (event.origin !== this.iframeOrigin) {\n                    // There might be other things going on in the window, for example: react dev tools, other extensions, etc.\n                    // Instead of erroring out we simply return. Not our event!\n                    return;\n                }\n                if (event.data?.type === IframeEventType.BundleInjected) {\n                    resolve(event.data[\"value\"]);\n                }\n                if (event.data?.type === IframeEventType.Error) {\n                    reject(event.data[\"value\"]);\n                }\n            }, false);\n        });\n    }\n    /**\n     * Function to inject an export bundle into the iframe\n     * The bundle should be encrypted to the iframe's initial public key\n     * Encryption should be performed with HPKE (RFC 9180).\n     * The key format to encode the private key in after it's exported and decrypted: HEXADECIMAL or SOLANA. Defaults to HEXADECIMAL.\n     * This is used during the private key export flow.\n     */\n    async injectKeyExportBundle(bundle, keyFormat) {\n        this.iframe.contentWindow?.postMessage({\n            type: IframeEventType.InjectKeyExportBundle,\n            value: bundle,\n            keyFormat: keyFormat,\n        }, \"*\");\n        return new Promise((resolve, reject) => {\n            window.addEventListener(\"message\", (event) => {\n                if (event.origin !== this.iframeOrigin) {\n                    // There might be other things going on in the window, for example: react dev tools, other extensions, etc.\n                    // Instead of erroring out we simply return. Not our event!\n                    return;\n                }\n                if (event.data?.type === IframeEventType.BundleInjected) {\n                    resolve(event.data[\"value\"]);\n                }\n                if (event.data?.type === IframeEventType.Error) {\n                    reject(event.data[\"value\"]);\n                }\n            }, false);\n        });\n    }\n    /**\n     * Function to inject an export bundle into the iframe\n     * The bundle should be encrypted to the iframe's initial public key\n     * Encryption should be performed with HPKE (RFC 9180).\n     * This is used during the wallet export flow.\n     */\n    async injectWalletExportBundle(bundle) {\n        this.iframe.contentWindow?.postMessage({\n            type: IframeEventType.InjectWalletExportBundle,\n            value: bundle,\n        }, \"*\");\n        return new Promise((resolve, reject) => {\n            window.addEventListener(\"message\", (event) => {\n                if (event.origin !== this.iframeOrigin) {\n                    // There might be other things going on in the window, for example: react dev tools, other extensions, etc.\n                    // Instead of erroring out we simply return. Not our event!\n                    return;\n                }\n                if (event.data?.type === IframeEventType.BundleInjected) {\n                    resolve(event.data[\"value\"]);\n                }\n                if (event.data?.type === IframeEventType.Error) {\n                    reject(event.data[\"value\"]);\n                }\n            }, false);\n        });\n    }\n    /**\n     * Function to inject an import bundle into the iframe\n     * This is used to initiate either the wallet import flow or the private key import flow.\n     */\n    async injectImportBundle(bundle) {\n        this.iframe.contentWindow?.postMessage({\n            type: IframeEventType.InjectImportBundle,\n            value: bundle,\n        }, \"*\");\n        return new Promise((resolve, reject) => {\n            window.addEventListener(\"message\", (event) => {\n                if (event.origin !== this.iframeOrigin) {\n                    // There might be other things going on in the window, for example: react dev tools, other extensions, etc.\n                    // Instead of erroring out we simply return. Not our event!\n                    return;\n                }\n                if (event.data?.type === IframeEventType.BundleInjected) {\n                    resolve(event.data[\"value\"]);\n                }\n                if (event.data?.type === IframeEventType.Error) {\n                    reject(event.data[\"value\"]);\n                }\n            }, false);\n        });\n    }\n    /**\n     * Function to extract an encrypted bundle from the iframe\n     * The bundle should be encrypted to Turnkey's Signer enclave's initial public key\n     * Encryption should be performed with HPKE (RFC 9180).\n     * This is used during the wallet import flow.\n     */\n    async extractWalletEncryptedBundle() {\n        this.iframe.contentWindow?.postMessage({\n            type: IframeEventType.ExtractWalletEncryptedBundle,\n        }, \"*\");\n        return new Promise((resolve, reject) => {\n            window.addEventListener(\"message\", (event) => {\n                if (event.origin !== this.iframeOrigin) {\n                    // There might be other things going on in the window, for example: react dev tools, other extensions, etc.\n                    // Instead of erroring out we simply return. Not our event!\n                    return;\n                }\n                if (event.data?.type === IframeEventType.EncryptedBundleExtracted) {\n                    resolve(event.data[\"value\"]);\n                }\n                if (event.data?.type === IframeEventType.Error) {\n                    reject(event.data[\"value\"]);\n                }\n            }, false);\n        });\n    }\n    /**\n     * Function to extract an encrypted bundle from the iframe\n     * The bundle should be encrypted to Turnkey's Signer enclave's initial public key\n     * Encryption should be performed with HPKE (RFC 9180).\n     * The key format to encode the private key in before it's encrypted and imported: HEXADECIMAL or SOLANA. Defaults to HEXADECIMAL.\n     * This is used during the private key import flow.\n     */\n    async extractKeyEncryptedBundle(keyFormat) {\n        this.iframe.contentWindow?.postMessage({\n            type: IframeEventType.ExtractKeyEncryptedBundle,\n            keyFormat: keyFormat,\n        }, \"*\");\n        return new Promise((resolve, reject) => {\n            window.addEventListener(\"message\", (event) => {\n                if (event.origin !== this.iframeOrigin) {\n                    // There might be other things going on in the window, for example: react dev tools, other extensions, etc.\n                    // Instead of erroring out we simply return. Not our event!\n                    return;\n                }\n                if (event.data?.type === IframeEventType.EncryptedBundleExtracted) {\n                    resolve(event.data[\"value\"]);\n                }\n                if (event.data?.type === IframeEventType.Error) {\n                    reject(event.data[\"value\"]);\n                }\n            }, false);\n        });\n    }\n    /**\n     * Function to sign a payload with the underlying iframe\n     */\n    async stamp(payload) {\n        if (this.iframePublicKey === null) {\n            throw new Error(\"null iframe public key. Have you called/awaited .init()?\");\n        }\n        const iframeOrigin = this.iframeOrigin;\n        this.iframe.contentWindow?.postMessage({\n            type: IframeEventType.StampRequest,\n            value: payload,\n        }, \"*\");\n        return new Promise(function (resolve, reject) {\n            window.addEventListener(\"message\", (event) => {\n                if (event.origin !== iframeOrigin) {\n                    // There might be other things going on in the window, for example: react dev tools, other extensions, etc.\n                    // Instead of erroring out we simply return. Not our event!\n                    return;\n                }\n                if (event.data?.type === IframeEventType.Stamp) {\n                    resolve({\n                        stampHeaderName: stampHeaderName,\n                        stampHeaderValue: event.data[\"value\"],\n                    });\n                }\n                if (event.data?.type === IframeEventType.Error) {\n                    reject(event.data[\"value\"]);\n                }\n            }, false);\n        });\n    }\n}\n\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvaWZyYW1lLXN0YW1wZXIvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQ0FBMEM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOEJBQThCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsdUJBQXVCO0FBQ3BFLHNEQUFzRCx3QkFBd0I7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7O0FBRXFEO0FBQ3JEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbnVyc2VibG9jLy4vbm9kZV9tb2R1bGVzL0B0dXJua2V5L2lmcmFtZS1zdGFtcGVyL2Rpc3QvaW5kZXgubWpzPzkzMGQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8vIDxyZWZlcmVuY2UgbGliPVwiZG9tXCIgLz5cbi8vIEhlYWRlciBuYW1lIGZvciBhbiBBUEkga2V5IHN0YW1wXG5jb25zdCBzdGFtcEhlYWRlck5hbWUgPSBcIlgtU3RhbXBcIjtcbi8vIFNldCBvZiBjb25zdGFudHMgZm9yIGV2ZW50IHR5cGVzIGV4cGVjdGVkIHRvIGJlIHNlbnQgYW5kIHJlY2VpdmVkIGJldHdlZW4gYSBwYXJlbnQgcGFnZSBhbmQgaXRzIGlmcmFtZS5cbnZhciBJZnJhbWVFdmVudFR5cGU7XG4oZnVuY3Rpb24gKElmcmFtZUV2ZW50VHlwZSkge1xuICAgIC8vIEV2ZW50IHNlbnQgYnkgdGhlIGlmcmFtZSB0byBpdHMgcGFyZW50IHRvIGluZGljYXRlIHJlYWRpbmVzcy5cbiAgICAvLyBWYWx1ZTogdGhlIGlmcmFtZSBwdWJsaWMga2V5XG4gICAgSWZyYW1lRXZlbnRUeXBlW1wiUHVibGljS2V5UmVhZHlcIl0gPSBcIlBVQkxJQ19LRVlfUkVBRFlcIjtcbiAgICAvLyBFdmVudCBzZW50IGJ5IHRoZSBwYXJlbnQgdG8gaW5qZWN0IGEgY3JlZGVudGlhbCBidW5kbGUgKGZvciByZWNvdmVyeSBvciBhdXRoKSBpbnRvIHRoZSBpZnJhbWUuXG4gICAgLy8gVmFsdWU6IHRoZSBidW5kbGUgdG8gaW5qZWN0XG4gICAgSWZyYW1lRXZlbnRUeXBlW1wiSW5qZWN0Q3JlZGVudGlhbEJ1bmRsZVwiXSA9IFwiSU5KRUNUX0NSRURFTlRJQUxfQlVORExFXCI7XG4gICAgLy8gRXZlbnQgc2VudCBieSB0aGUgcGFyZW50IHRvIGluamVjdCBhIHByaXZhdGUga2V5IGV4cG9ydCBidW5kbGUgaW50byB0aGUgaWZyYW1lLlxuICAgIC8vIFZhbHVlOiB0aGUgYnVuZGxlIHRvIGluamVjdFxuICAgIC8vIEtleSBGb3JtYXQgKG9wdGlvbmFsKTogdGhlIGtleSBmb3JtYXQgdG8gZW5jb2RlIHRoZSBwcml2YXRlIGtleSBpbiBhZnRlciBpdCdzIGV4cG9ydGVkIGFuZCBkZWNyeXB0ZWQ6IEhFWEFERUNJTUFMIG9yIFNPTEFOQS4gRGVmYXVsdHMgdG8gSEVYQURFQ0lNQUwuXG4gICAgLy8gUHVibGljIEtleSAob3B0aW9uYWwpOiB0aGUgcHVibGljIGtleSBvZiB0aGUgZXhwb3J0ZWQgcHJpdmF0ZSBrZXkuIFJlcXVpcmVkIHdoZW4gdGhlIGtleSBmb3JtYXQgaXMgU09MQU5BLlxuICAgIElmcmFtZUV2ZW50VHlwZVtcIkluamVjdEtleUV4cG9ydEJ1bmRsZVwiXSA9IFwiSU5KRUNUX0tFWV9FWFBPUlRfQlVORExFXCI7XG4gICAgLy8gRXZlbnQgc2VudCBieSB0aGUgcGFyZW50IHRvIGluamVjdCBhIHdhbGxldCBleHBvcnQgYnVuZGxlIGludG8gdGhlIGlmcmFtZS5cbiAgICAvLyBWYWx1ZTogdGhlIGJ1bmRsZSB0byBpbmplY3RcbiAgICBJZnJhbWVFdmVudFR5cGVbXCJJbmplY3RXYWxsZXRFeHBvcnRCdW5kbGVcIl0gPSBcIklOSkVDVF9XQUxMRVRfRVhQT1JUX0JVTkRMRVwiO1xuICAgIC8vIEV2ZW50IHNlbnQgYnkgdGhlIHBhcmVudCB0byBpbmplY3QgYW4gaW1wb3J0IGJ1bmRsZSBpbnRvIHRoZSBpZnJhbWUuXG4gICAgLy8gVmFsdWU6IHRoZSBidW5kbGUgdG8gaW5qZWN0XG4gICAgSWZyYW1lRXZlbnRUeXBlW1wiSW5qZWN0SW1wb3J0QnVuZGxlXCJdID0gXCJJTkpFQ1RfSU1QT1JUX0JVTkRMRVwiO1xuICAgIC8vIEV2ZW50IHNlbnQgYnkgdGhlIHBhcmVudCB0byBleHRyYWN0IGFuIGVuY3J5cHRlZCB3YWxsZXQgYnVuZGxlIGZyb20gdGhlIGlmcmFtZS5cbiAgICAvLyBWYWx1ZTogbm9uZVxuICAgIElmcmFtZUV2ZW50VHlwZVtcIkV4dHJhY3RXYWxsZXRFbmNyeXB0ZWRCdW5kbGVcIl0gPSBcIkVYVFJBQ1RfV0FMTEVUX0VOQ1JZUFRFRF9CVU5ETEVcIjtcbiAgICAvLyBFdmVudCBzZW50IGJ5IHRoZSBwYXJlbnQgdG8gZXh0cmFjdCBhbiBlbmNyeXB0ZWQgcHJpdmF0ZSBrZXkgYnVuZGxlIGZyb20gdGhlIGlmcmFtZS5cbiAgICAvLyBWYWx1ZTogbm9uZVxuICAgIC8vIEtleSBGb3JtYXQgKG9wdGlvbmFsKTogdGhlIGtleSBmb3JtYXQgdG8gZGVjb2RlIHRoZSBwcml2YXRlIGtleSBpbiBiZWZvcmUgaXQncyBlbmNyeXB0ZWQgZm9yIGltcG9ydDogSEVYQURFQ0lNQUwgb3IgU09MQU5BLiBEZWZhdWx0cyB0byBIRVhBREVDSU1BTC5cbiAgICBJZnJhbWVFdmVudFR5cGVbXCJFeHRyYWN0S2V5RW5jcnlwdGVkQnVuZGxlXCJdID0gXCJFWFRSQUNUX0tFWV9FTkNSWVBURURfQlVORExFXCI7XG4gICAgLy8gRXZlbnQgc2VudCBieSB0aGUgaWZyYW1lIHRvIGl0cyBwYXJlbnQgd2hlbiBgSW5qZWN0QnVuZGxlYCBpcyBzdWNjZXNzZnVsXG4gICAgLy8gVmFsdWU6IHRydWUgKGJvb2xlYW4pXG4gICAgSWZyYW1lRXZlbnRUeXBlW1wiQnVuZGxlSW5qZWN0ZWRcIl0gPSBcIkJVTkRMRV9JTkpFQ1RFRFwiO1xuICAgIC8vIEV2ZW50IHNlbnQgYnkgdGhlIGlmcmFtZSB0byBpdHMgcGFyZW50IHdoZW4gYEV4dHJhY3RFbmNyeXB0ZWRCdW5kbGVgIGlzIHN1Y2Nlc3NmdWxcbiAgICAvLyBWYWx1ZTogdGhlIGJ1bmRsZSBlbmNyeXB0ZWQgaW4gdGhlIGlmcmFtZVxuICAgIElmcmFtZUV2ZW50VHlwZVtcIkVuY3J5cHRlZEJ1bmRsZUV4dHJhY3RlZFwiXSA9IFwiRU5DUllQVEVEX0JVTkRMRV9FWFRSQUNURURcIjtcbiAgICAvLyBFdmVudCBzZW50IGJ5IHRoZSBwYXJlbnQgcGFnZSB0byByZXF1ZXN0IGEgc2lnbmF0dXJlXG4gICAgLy8gVmFsdWU6IHBheWxvYWQgdG8gc2lnblxuICAgIElmcmFtZUV2ZW50VHlwZVtcIlN0YW1wUmVxdWVzdFwiXSA9IFwiU1RBTVBfUkVRVUVTVFwiO1xuICAgIC8vIEV2ZW50IHNlbnQgYnkgdGhlIGlmcmFtZSB0byBjb21tdW5pY2F0ZSB0aGUgcmVzdWx0IG9mIGEgc3RhbXAgb3BlcmF0aW9uLlxuICAgIC8vIFZhbHVlOiBzaWduZWQgcGF5bG9hZFxuICAgIElmcmFtZUV2ZW50VHlwZVtcIlN0YW1wXCJdID0gXCJTVEFNUFwiO1xuICAgIC8vIEV2ZW50IHNlbnQgYnkgdGhlIGlmcmFtZSB0byBjb21tdW5pY2F0ZSBhbiBlcnJvclxuICAgIC8vIFZhbHVlOiBzZXJpYWxpemVkIGVycm9yXG4gICAgSWZyYW1lRXZlbnRUeXBlW1wiRXJyb3JcIl0gPSBcIkVSUk9SXCI7XG59KShJZnJhbWVFdmVudFR5cGUgfHwgKElmcmFtZUV2ZW50VHlwZSA9IHt9KSk7XG4vLyBTZXQgb2YgY29uc3RhbnRzIGZvciBwcml2YXRlIGtleSBmb3JtYXRzLiBUaGVzZSBmb3JtYXRzIG1hcCB0byB0aGUgZW5jb2RpbmcgdHlwZSB1c2VkIG9uIGEgcHJpdmF0ZSBrZXkgYmVmb3JlIGVuY3J5cHRpbmcgYW5kIGltcG9ydGluZyBpdFxuLy8gb3IgYWZ0ZXIgZXhwb3J0aW5nIGl0IGFuZCBkZWNyeXB0aW5nIGl0LlxudmFyIEtleUZvcm1hdDtcbihmdW5jdGlvbiAoS2V5Rm9ybWF0KSB7XG4gICAgLy8gNjQgaGV4YWRlY2ltYWwgZGlnaXRzLiBLZXkgZm9ybWF0IHVzZWQgYnkgTWV0YU1hc2ssIE15RXRoZXJXYWxsZXQsIFBoYW50b20sIExlZGdlciwgYW5kIFRyZXpvciBmb3IgRXRoZXJldW0gYW5kIFRyb24ga2V5c1xuICAgIEtleUZvcm1hdFtcIkhleGFkZWNpbWFsXCJdID0gXCJIRVhBREVDSU1BTFwiO1xuICAgIC8vIEtleSBmb3JtYXQgdXNlZCBieSBQaGFudG9tIGFuZCBTb2xmbGFyZSBmb3IgU29sYW5hIGtleXNcbiAgICBLZXlGb3JtYXRbXCJTb2xhbmFcIl0gPSBcIlNPTEFOQVwiO1xufSkoS2V5Rm9ybWF0IHx8IChLZXlGb3JtYXQgPSB7fSkpO1xuLyoqXG4gKiBTdGFtcGVyIHRvIHVzZSB3aXRoIGBAdHVybmtleS9odHRwYCdzIGBUdXJua2V5Q2xpZW50YFxuICogQ3JlYXRpbmcgYSBzdGFtcGVyIGluc2VydHMgYW4gaWZyYW1lIGluIHRoZSBjdXJyZW50IHBhZ2UuXG4gKi9cbmNsYXNzIElmcmFtZVN0YW1wZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaWZyYW1lIHN0YW1wZXIuIFRoaXMgZnVuY3Rpb24gX2RvZXMgbm90XyBpbnNlcnQgdGhlIGlmcmFtZSBpbiB0aGUgRE9NLlxuICAgICAqIENhbGwgYC5pbml0KClgIHRvIGluc2VydCB0aGUgaWZyYW1lIGVsZW1lbnQgaW4gdGhlIERPTS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBpbml0aWFsaXplIGlmcmFtZSBpbiBub24tYnJvd3NlciBlbnZpcm9ubWVudFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbmZpZy5pZnJhbWVDb250YWluZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklmcmFtZSBjb250YWluZXIgY2Fubm90IGJlIGZvdW5kXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29uZmlnLmlmcmFtZUNvbnRhaW5lcjtcbiAgICAgICAgaWYgKHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoYCMke2NvbmZpZy5pZnJhbWVFbGVtZW50SWR9YCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSWZyYW1lIGVsZW1lbnQgd2l0aCBJRCAke2NvbmZpZy5pZnJhbWVFbGVtZW50SWR9IGFscmVhZHkgZXhpc3RzYCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGlmcmFtZSA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpO1xuICAgICAgICBpZnJhbWUuaWQgPSBjb25maWcuaWZyYW1lRWxlbWVudElkO1xuICAgICAgICBpZnJhbWUuc3JjID0gY29uZmlnLmlmcmFtZVVybDtcbiAgICAgICAgdGhpcy5pZnJhbWUgPSBpZnJhbWU7XG4gICAgICAgIGNvbnN0IGlmcmFtZVVybCA9IG5ldyBVUkwoY29uZmlnLmlmcmFtZVVybCk7XG4gICAgICAgIHRoaXMuaWZyYW1lT3JpZ2luID0gaWZyYW1lVXJsLm9yaWdpbjtcbiAgICAgICAgLy8gVGhpcyBpcyBwb3B1bGF0ZWQgb25jZSB0aGUgaWZyYW1lIGlzIHJlYWR5LiBDYWxsIGAuaW5pdCgpYCB0byBraWNrIG9mZiBET00gaW5zZXJ0aW9uIVxuICAgICAgICB0aGlzLmlmcmFtZVB1YmxpY0tleSA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydHMgdGhlIGlmcmFtZSBvbiB0aGUgcGFnZSBhbmQgcmV0dXJucyBhIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBpZnJhbWUncyBwdWJsaWMga2V5XG4gICAgICovXG4gICAgYXN5bmMgaW5pdCgpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5pZnJhbWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIF9yZWplY3QpID0+IHtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQub3JpZ2luICE9PSB0aGlzLmlmcmFtZU9yaWdpbikge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGVyZSBtaWdodCBiZSBvdGhlciB0aGluZ3MgZ29pbmcgb24gaW4gdGhlIHdpbmRvdywgZm9yIGV4YW1wbGU6IHJlYWN0IGRldiB0b29scywgb3RoZXIgZXh0ZW5zaW9ucywgZXRjLlxuICAgICAgICAgICAgICAgICAgICAvLyBJbnN0ZWFkIG9mIGVycm9yaW5nIG91dFxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChldmVudC5kYXRhPy50eXBlID09PSBJZnJhbWVFdmVudFR5cGUuUHVibGljS2V5UmVhZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pZnJhbWVQdWJsaWNLZXkgPSBldmVudC5kYXRhW1widmFsdWVcIl07XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZXZlbnQuZGF0YVtcInZhbHVlXCJdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBpZnJhbWUgZnJvbSB0aGUgRE9NXG4gICAgICovXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMuaWZyYW1lLnJlbW92ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwdWJsaWMga2V5LCBvciBgbnVsbGAgaWYgdGhlIHVuZGVybHlpbmcgaWZyYW1lIGlzbid0IHByb3Blcmx5IGluaXRpYWxpemVkLlxuICAgICAqL1xuICAgIHB1YmxpY0tleSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWZyYW1lUHVibGljS2V5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0byBpbmplY3QgYSBuZXcgY3JlZGVudGlhbCBpbnRvIHRoZSBpZnJhbWVcbiAgICAgKiBUaGUgYnVuZGxlIHNob3VsZCBiZSBlbmNyeXB0ZWQgdG8gdGhlIGlmcmFtZSdzIGluaXRpYWwgcHVibGljIGtleVxuICAgICAqIEVuY3J5cHRpb24gc2hvdWxkIGJlIHBlcmZvcm1lZCB3aXRoIEhQS0UgKFJGQyA5MTgwKS5cbiAgICAgKiBUaGlzIGlzIHVzZWQgZHVyaW5nIHJlY292ZXJ5IGFuZCBhdXRoIGZsb3dzLlxuICAgICAqL1xuICAgIGFzeW5jIGluamVjdENyZWRlbnRpYWxCdW5kbGUoYnVuZGxlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmlmcmFtZS5jb250ZW50V2luZG93Py5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogSWZyYW1lRXZlbnRUeXBlLkluamVjdENyZWRlbnRpYWxCdW5kbGUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGJ1bmRsZSxcbiAgICAgICAgICAgIH0sIFwiKlwiKTtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQub3JpZ2luICE9PSB0aGlzLmlmcmFtZU9yaWdpbikge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGVyZSBtaWdodCBiZSBvdGhlciB0aGluZ3MgZ29pbmcgb24gaW4gdGhlIHdpbmRvdywgZm9yIGV4YW1wbGU6IHJlYWN0IGRldiB0b29scywgb3RoZXIgZXh0ZW5zaW9ucywgZXRjLlxuICAgICAgICAgICAgICAgICAgICAvLyBJbnN0ZWFkIG9mIGVycm9yaW5nIG91dCB3ZSBzaW1wbHkgcmV0dXJuLiBOb3Qgb3VyIGV2ZW50IVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChldmVudC5kYXRhPy50eXBlID09PSBJZnJhbWVFdmVudFR5cGUuQnVuZGxlSW5qZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShldmVudC5kYXRhW1widmFsdWVcIl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuZGF0YT8udHlwZSA9PT0gSWZyYW1lRXZlbnRUeXBlLkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChldmVudC5kYXRhW1widmFsdWVcIl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRvIGluamVjdCBhbiBleHBvcnQgYnVuZGxlIGludG8gdGhlIGlmcmFtZVxuICAgICAqIFRoZSBidW5kbGUgc2hvdWxkIGJlIGVuY3J5cHRlZCB0byB0aGUgaWZyYW1lJ3MgaW5pdGlhbCBwdWJsaWMga2V5XG4gICAgICogRW5jcnlwdGlvbiBzaG91bGQgYmUgcGVyZm9ybWVkIHdpdGggSFBLRSAoUkZDIDkxODApLlxuICAgICAqIFRoZSBrZXkgZm9ybWF0IHRvIGVuY29kZSB0aGUgcHJpdmF0ZSBrZXkgaW4gYWZ0ZXIgaXQncyBleHBvcnRlZCBhbmQgZGVjcnlwdGVkOiBIRVhBREVDSU1BTCBvciBTT0xBTkEuIERlZmF1bHRzIHRvIEhFWEFERUNJTUFMLlxuICAgICAqIFRoaXMgaXMgdXNlZCBkdXJpbmcgdGhlIHByaXZhdGUga2V5IGV4cG9ydCBmbG93LlxuICAgICAqL1xuICAgIGFzeW5jIGluamVjdEtleUV4cG9ydEJ1bmRsZShidW5kbGUsIGtleUZvcm1hdCkge1xuICAgICAgICB0aGlzLmlmcmFtZS5jb250ZW50V2luZG93Py5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICB0eXBlOiBJZnJhbWVFdmVudFR5cGUuSW5qZWN0S2V5RXhwb3J0QnVuZGxlLFxuICAgICAgICAgICAgdmFsdWU6IGJ1bmRsZSxcbiAgICAgICAgICAgIGtleUZvcm1hdDoga2V5Rm9ybWF0LFxuICAgICAgICB9LCBcIipcIik7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50Lm9yaWdpbiAhPT0gdGhpcy5pZnJhbWVPcmlnaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgbWlnaHQgYmUgb3RoZXIgdGhpbmdzIGdvaW5nIG9uIGluIHRoZSB3aW5kb3csIGZvciBleGFtcGxlOiByZWFjdCBkZXYgdG9vbHMsIG90aGVyIGV4dGVuc2lvbnMsIGV0Yy5cbiAgICAgICAgICAgICAgICAgICAgLy8gSW5zdGVhZCBvZiBlcnJvcmluZyBvdXQgd2Ugc2ltcGx5IHJldHVybi4gTm90IG91ciBldmVudCFcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuZGF0YT8udHlwZSA9PT0gSWZyYW1lRXZlbnRUeXBlLkJ1bmRsZUluamVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZXZlbnQuZGF0YVtcInZhbHVlXCJdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmRhdGE/LnR5cGUgPT09IElmcmFtZUV2ZW50VHlwZS5FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXZlbnQuZGF0YVtcInZhbHVlXCJdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0byBpbmplY3QgYW4gZXhwb3J0IGJ1bmRsZSBpbnRvIHRoZSBpZnJhbWVcbiAgICAgKiBUaGUgYnVuZGxlIHNob3VsZCBiZSBlbmNyeXB0ZWQgdG8gdGhlIGlmcmFtZSdzIGluaXRpYWwgcHVibGljIGtleVxuICAgICAqIEVuY3J5cHRpb24gc2hvdWxkIGJlIHBlcmZvcm1lZCB3aXRoIEhQS0UgKFJGQyA5MTgwKS5cbiAgICAgKiBUaGlzIGlzIHVzZWQgZHVyaW5nIHRoZSB3YWxsZXQgZXhwb3J0IGZsb3cuXG4gICAgICovXG4gICAgYXN5bmMgaW5qZWN0V2FsbGV0RXhwb3J0QnVuZGxlKGJ1bmRsZSkge1xuICAgICAgICB0aGlzLmlmcmFtZS5jb250ZW50V2luZG93Py5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICB0eXBlOiBJZnJhbWVFdmVudFR5cGUuSW5qZWN0V2FsbGV0RXhwb3J0QnVuZGxlLFxuICAgICAgICAgICAgdmFsdWU6IGJ1bmRsZSxcbiAgICAgICAgfSwgXCIqXCIpO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5vcmlnaW4gIT09IHRoaXMuaWZyYW1lT3JpZ2luKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIG1pZ2h0IGJlIG90aGVyIHRoaW5ncyBnb2luZyBvbiBpbiB0aGUgd2luZG93LCBmb3IgZXhhbXBsZTogcmVhY3QgZGV2IHRvb2xzLCBvdGhlciBleHRlbnNpb25zLCBldGMuXG4gICAgICAgICAgICAgICAgICAgIC8vIEluc3RlYWQgb2YgZXJyb3Jpbmcgb3V0IHdlIHNpbXBseSByZXR1cm4uIE5vdCBvdXIgZXZlbnQhXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmRhdGE/LnR5cGUgPT09IElmcmFtZUV2ZW50VHlwZS5CdW5kbGVJbmplY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGV2ZW50LmRhdGFbXCJ2YWx1ZVwiXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChldmVudC5kYXRhPy50eXBlID09PSBJZnJhbWVFdmVudFR5cGUuRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGV2ZW50LmRhdGFbXCJ2YWx1ZVwiXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdG8gaW5qZWN0IGFuIGltcG9ydCBidW5kbGUgaW50byB0aGUgaWZyYW1lXG4gICAgICogVGhpcyBpcyB1c2VkIHRvIGluaXRpYXRlIGVpdGhlciB0aGUgd2FsbGV0IGltcG9ydCBmbG93IG9yIHRoZSBwcml2YXRlIGtleSBpbXBvcnQgZmxvdy5cbiAgICAgKi9cbiAgICBhc3luYyBpbmplY3RJbXBvcnRCdW5kbGUoYnVuZGxlKSB7XG4gICAgICAgIHRoaXMuaWZyYW1lLmNvbnRlbnRXaW5kb3c/LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHR5cGU6IElmcmFtZUV2ZW50VHlwZS5JbmplY3RJbXBvcnRCdW5kbGUsXG4gICAgICAgICAgICB2YWx1ZTogYnVuZGxlLFxuICAgICAgICB9LCBcIipcIik7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50Lm9yaWdpbiAhPT0gdGhpcy5pZnJhbWVPcmlnaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgbWlnaHQgYmUgb3RoZXIgdGhpbmdzIGdvaW5nIG9uIGluIHRoZSB3aW5kb3csIGZvciBleGFtcGxlOiByZWFjdCBkZXYgdG9vbHMsIG90aGVyIGV4dGVuc2lvbnMsIGV0Yy5cbiAgICAgICAgICAgICAgICAgICAgLy8gSW5zdGVhZCBvZiBlcnJvcmluZyBvdXQgd2Ugc2ltcGx5IHJldHVybi4gTm90IG91ciBldmVudCFcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuZGF0YT8udHlwZSA9PT0gSWZyYW1lRXZlbnRUeXBlLkJ1bmRsZUluamVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZXZlbnQuZGF0YVtcInZhbHVlXCJdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmRhdGE/LnR5cGUgPT09IElmcmFtZUV2ZW50VHlwZS5FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXZlbnQuZGF0YVtcInZhbHVlXCJdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0byBleHRyYWN0IGFuIGVuY3J5cHRlZCBidW5kbGUgZnJvbSB0aGUgaWZyYW1lXG4gICAgICogVGhlIGJ1bmRsZSBzaG91bGQgYmUgZW5jcnlwdGVkIHRvIFR1cm5rZXkncyBTaWduZXIgZW5jbGF2ZSdzIGluaXRpYWwgcHVibGljIGtleVxuICAgICAqIEVuY3J5cHRpb24gc2hvdWxkIGJlIHBlcmZvcm1lZCB3aXRoIEhQS0UgKFJGQyA5MTgwKS5cbiAgICAgKiBUaGlzIGlzIHVzZWQgZHVyaW5nIHRoZSB3YWxsZXQgaW1wb3J0IGZsb3cuXG4gICAgICovXG4gICAgYXN5bmMgZXh0cmFjdFdhbGxldEVuY3J5cHRlZEJ1bmRsZSgpIHtcbiAgICAgICAgdGhpcy5pZnJhbWUuY29udGVudFdpbmRvdz8ucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgdHlwZTogSWZyYW1lRXZlbnRUeXBlLkV4dHJhY3RXYWxsZXRFbmNyeXB0ZWRCdW5kbGUsXG4gICAgICAgIH0sIFwiKlwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQub3JpZ2luICE9PSB0aGlzLmlmcmFtZU9yaWdpbikge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGVyZSBtaWdodCBiZSBvdGhlciB0aGluZ3MgZ29pbmcgb24gaW4gdGhlIHdpbmRvdywgZm9yIGV4YW1wbGU6IHJlYWN0IGRldiB0b29scywgb3RoZXIgZXh0ZW5zaW9ucywgZXRjLlxuICAgICAgICAgICAgICAgICAgICAvLyBJbnN0ZWFkIG9mIGVycm9yaW5nIG91dCB3ZSBzaW1wbHkgcmV0dXJuLiBOb3Qgb3VyIGV2ZW50IVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChldmVudC5kYXRhPy50eXBlID09PSBJZnJhbWVFdmVudFR5cGUuRW5jcnlwdGVkQnVuZGxlRXh0cmFjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZXZlbnQuZGF0YVtcInZhbHVlXCJdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmRhdGE/LnR5cGUgPT09IElmcmFtZUV2ZW50VHlwZS5FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXZlbnQuZGF0YVtcInZhbHVlXCJdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0byBleHRyYWN0IGFuIGVuY3J5cHRlZCBidW5kbGUgZnJvbSB0aGUgaWZyYW1lXG4gICAgICogVGhlIGJ1bmRsZSBzaG91bGQgYmUgZW5jcnlwdGVkIHRvIFR1cm5rZXkncyBTaWduZXIgZW5jbGF2ZSdzIGluaXRpYWwgcHVibGljIGtleVxuICAgICAqIEVuY3J5cHRpb24gc2hvdWxkIGJlIHBlcmZvcm1lZCB3aXRoIEhQS0UgKFJGQyA5MTgwKS5cbiAgICAgKiBUaGUga2V5IGZvcm1hdCB0byBlbmNvZGUgdGhlIHByaXZhdGUga2V5IGluIGJlZm9yZSBpdCdzIGVuY3J5cHRlZCBhbmQgaW1wb3J0ZWQ6IEhFWEFERUNJTUFMIG9yIFNPTEFOQS4gRGVmYXVsdHMgdG8gSEVYQURFQ0lNQUwuXG4gICAgICogVGhpcyBpcyB1c2VkIGR1cmluZyB0aGUgcHJpdmF0ZSBrZXkgaW1wb3J0IGZsb3cuXG4gICAgICovXG4gICAgYXN5bmMgZXh0cmFjdEtleUVuY3J5cHRlZEJ1bmRsZShrZXlGb3JtYXQpIHtcbiAgICAgICAgdGhpcy5pZnJhbWUuY29udGVudFdpbmRvdz8ucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgdHlwZTogSWZyYW1lRXZlbnRUeXBlLkV4dHJhY3RLZXlFbmNyeXB0ZWRCdW5kbGUsXG4gICAgICAgICAgICBrZXlGb3JtYXQ6IGtleUZvcm1hdCxcbiAgICAgICAgfSwgXCIqXCIpO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5vcmlnaW4gIT09IHRoaXMuaWZyYW1lT3JpZ2luKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIG1pZ2h0IGJlIG90aGVyIHRoaW5ncyBnb2luZyBvbiBpbiB0aGUgd2luZG93LCBmb3IgZXhhbXBsZTogcmVhY3QgZGV2IHRvb2xzLCBvdGhlciBleHRlbnNpb25zLCBldGMuXG4gICAgICAgICAgICAgICAgICAgIC8vIEluc3RlYWQgb2YgZXJyb3Jpbmcgb3V0IHdlIHNpbXBseSByZXR1cm4uIE5vdCBvdXIgZXZlbnQhXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmRhdGE/LnR5cGUgPT09IElmcmFtZUV2ZW50VHlwZS5FbmNyeXB0ZWRCdW5kbGVFeHRyYWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShldmVudC5kYXRhW1widmFsdWVcIl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuZGF0YT8udHlwZSA9PT0gSWZyYW1lRXZlbnRUeXBlLkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChldmVudC5kYXRhW1widmFsdWVcIl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRvIHNpZ24gYSBwYXlsb2FkIHdpdGggdGhlIHVuZGVybHlpbmcgaWZyYW1lXG4gICAgICovXG4gICAgYXN5bmMgc3RhbXAocGF5bG9hZCkge1xuICAgICAgICBpZiAodGhpcy5pZnJhbWVQdWJsaWNLZXkgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm51bGwgaWZyYW1lIHB1YmxpYyBrZXkuIEhhdmUgeW91IGNhbGxlZC9hd2FpdGVkIC5pbml0KCk/XCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlmcmFtZU9yaWdpbiA9IHRoaXMuaWZyYW1lT3JpZ2luO1xuICAgICAgICB0aGlzLmlmcmFtZS5jb250ZW50V2luZG93Py5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICB0eXBlOiBJZnJhbWVFdmVudFR5cGUuU3RhbXBSZXF1ZXN0LFxuICAgICAgICAgICAgdmFsdWU6IHBheWxvYWQsXG4gICAgICAgIH0sIFwiKlwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQub3JpZ2luICE9PSBpZnJhbWVPcmlnaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgbWlnaHQgYmUgb3RoZXIgdGhpbmdzIGdvaW5nIG9uIGluIHRoZSB3aW5kb3csIGZvciBleGFtcGxlOiByZWFjdCBkZXYgdG9vbHMsIG90aGVyIGV4dGVuc2lvbnMsIGV0Yy5cbiAgICAgICAgICAgICAgICAgICAgLy8gSW5zdGVhZCBvZiBlcnJvcmluZyBvdXQgd2Ugc2ltcGx5IHJldHVybi4gTm90IG91ciBldmVudCFcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuZGF0YT8udHlwZSA9PT0gSWZyYW1lRXZlbnRUeXBlLlN0YW1wKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhbXBIZWFkZXJOYW1lOiBzdGFtcEhlYWRlck5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFtcEhlYWRlclZhbHVlOiBldmVudC5kYXRhW1widmFsdWVcIl0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuZGF0YT8udHlwZSA9PT0gSWZyYW1lRXZlbnRUeXBlLkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChldmVudC5kYXRhW1widmFsdWVcIl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5leHBvcnQgeyBJZnJhbWVFdmVudFR5cGUsIElmcmFtZVN0YW1wZXIsIEtleUZvcm1hdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/iframe-stamper/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/solana/dist/index.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/@turnkey/solana/dist/index.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TurnkeySigner: () => (/* binding */ TurnkeySigner)\n/* harmony export */ });\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/web3.js */ \"(ssr)/./node_modules/@turnkey/solana/node_modules/@solana/web3.js/lib/index.cjs.js\");\n/* harmony import */ var _turnkey_http__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @turnkey/http */ \"(ssr)/./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/index.mjs\");\n\n\n\nclass TurnkeySigner {\n    constructor(input) {\n        this.organizationId = input.organizationId;\n        this.client = input.client;\n    }\n    /**\n     * This function takes a Solana transaction and adds a signature with Turnkey\n     *\n     * @param tx Transaction object (native @solana/web3.js type)\n     * @param fromAddress Solana address (base58 encoded)\n     */\n    async addSignature(tx, fromAddress) {\n        const fromKey = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(fromAddress);\n        const messageToSign = tx.serializeMessage();\n        const signRawPayloadResult = await this.signRawPayload(messageToSign.toString(\"hex\"), fromAddress);\n        const signature = `${signRawPayloadResult.signRawPayloadResult?.r}${signRawPayloadResult.signRawPayloadResult?.s}`;\n        tx.addSignature(fromKey, Buffer.from(signature, \"hex\"));\n    }\n    /**\n     * This function takes a message and returns it after being signed with Turnkey\n     *\n     * @param message The message to sign (Uint8Array)\n     * @param fromAddress Solana address (base58 encoded)\n     */\n    async signMessage(message, fromAddress) {\n        const signRawPayloadResult = await this.signRawPayload(Buffer.from(message).toString(\"hex\"), fromAddress);\n        return Buffer.from(`${signRawPayloadResult.signRawPayloadResult?.r}${signRawPayloadResult.signRawPayloadResult?.s}`, \"hex\");\n    }\n    async signRawPayload(payload, signWith) {\n        const response = await this.client.signRawPayload({\n            type: \"ACTIVITY_TYPE_SIGN_RAW_PAYLOAD_V2\",\n            organizationId: this.organizationId,\n            timestampMs: String(Date.now()),\n            parameters: {\n                signWith,\n                payload,\n                encoding: \"PAYLOAD_ENCODING_HEXADECIMAL\",\n                // Note: unlike ECDSA, EdDSA's API does not support signing raw digests (see RFC 8032).\n                // Turnkey's signer requires an explicit value to be passed here to minimize ambiguity.\n                hashFunction: \"HASH_FUNCTION_NOT_APPLICABLE\",\n            },\n        });\n        const { id, status, type, result } = response.activity;\n        if (status !== \"ACTIVITY_STATUS_COMPLETED\") {\n            throw new _turnkey_http__WEBPACK_IMPORTED_MODULE_1__.TurnkeyActivityError({\n                message: `Expected COMPLETED status, got ${status}`,\n                activityId: id,\n                activityStatus: status,\n                activityType: type,\n            });\n        }\n        return result;\n    }\n}\n\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvc29sYW5hL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE0QztBQUNTOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0RBQVM7QUFDckM7QUFDQTtBQUNBLDZCQUE2Qiw2Q0FBNkMsRUFBRSw2Q0FBNkM7QUFDekg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsNkNBQTZDLEVBQUUsNkNBQTZDO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxnQkFBZ0IsMkJBQTJCO0FBQzNDO0FBQ0Esc0JBQXNCLCtEQUFvQjtBQUMxQywyREFBMkQsT0FBTztBQUNsRTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRXlCO0FBQ3pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbnVyc2VibG9jLy4vbm9kZV9tb2R1bGVzL0B0dXJua2V5L3NvbGFuYS9kaXN0L2luZGV4Lm1qcz8xMTRiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFB1YmxpY0tleSB9IGZyb20gJ0Bzb2xhbmEvd2ViMy5qcyc7XG5pbXBvcnQgeyBUdXJua2V5QWN0aXZpdHlFcnJvciB9IGZyb20gJ0B0dXJua2V5L2h0dHAnO1xuXG5jbGFzcyBUdXJua2V5U2lnbmVyIHtcbiAgICBjb25zdHJ1Y3RvcihpbnB1dCkge1xuICAgICAgICB0aGlzLm9yZ2FuaXphdGlvbklkID0gaW5wdXQub3JnYW5pemF0aW9uSWQ7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gaW5wdXQuY2xpZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHRha2VzIGEgU29sYW5hIHRyYW5zYWN0aW9uIGFuZCBhZGRzIGEgc2lnbmF0dXJlIHdpdGggVHVybmtleVxuICAgICAqXG4gICAgICogQHBhcmFtIHR4IFRyYW5zYWN0aW9uIG9iamVjdCAobmF0aXZlIEBzb2xhbmEvd2ViMy5qcyB0eXBlKVxuICAgICAqIEBwYXJhbSBmcm9tQWRkcmVzcyBTb2xhbmEgYWRkcmVzcyAoYmFzZTU4IGVuY29kZWQpXG4gICAgICovXG4gICAgYXN5bmMgYWRkU2lnbmF0dXJlKHR4LCBmcm9tQWRkcmVzcykge1xuICAgICAgICBjb25zdCBmcm9tS2V5ID0gbmV3IFB1YmxpY0tleShmcm9tQWRkcmVzcyk7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VUb1NpZ24gPSB0eC5zZXJpYWxpemVNZXNzYWdlKCk7XG4gICAgICAgIGNvbnN0IHNpZ25SYXdQYXlsb2FkUmVzdWx0ID0gYXdhaXQgdGhpcy5zaWduUmF3UGF5bG9hZChtZXNzYWdlVG9TaWduLnRvU3RyaW5nKFwiaGV4XCIpLCBmcm9tQWRkcmVzcyk7XG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGAke3NpZ25SYXdQYXlsb2FkUmVzdWx0LnNpZ25SYXdQYXlsb2FkUmVzdWx0Py5yfSR7c2lnblJhd1BheWxvYWRSZXN1bHQuc2lnblJhd1BheWxvYWRSZXN1bHQ/LnN9YDtcbiAgICAgICAgdHguYWRkU2lnbmF0dXJlKGZyb21LZXksIEJ1ZmZlci5mcm9tKHNpZ25hdHVyZSwgXCJoZXhcIikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHRha2VzIGEgbWVzc2FnZSBhbmQgcmV0dXJucyBpdCBhZnRlciBiZWluZyBzaWduZWQgd2l0aCBUdXJua2V5XG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBzaWduIChVaW50OEFycmF5KVxuICAgICAqIEBwYXJhbSBmcm9tQWRkcmVzcyBTb2xhbmEgYWRkcmVzcyAoYmFzZTU4IGVuY29kZWQpXG4gICAgICovXG4gICAgYXN5bmMgc2lnbk1lc3NhZ2UobWVzc2FnZSwgZnJvbUFkZHJlc3MpIHtcbiAgICAgICAgY29uc3Qgc2lnblJhd1BheWxvYWRSZXN1bHQgPSBhd2FpdCB0aGlzLnNpZ25SYXdQYXlsb2FkKEJ1ZmZlci5mcm9tKG1lc3NhZ2UpLnRvU3RyaW5nKFwiaGV4XCIpLCBmcm9tQWRkcmVzcyk7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShgJHtzaWduUmF3UGF5bG9hZFJlc3VsdC5zaWduUmF3UGF5bG9hZFJlc3VsdD8ucn0ke3NpZ25SYXdQYXlsb2FkUmVzdWx0LnNpZ25SYXdQYXlsb2FkUmVzdWx0Py5zfWAsIFwiaGV4XCIpO1xuICAgIH1cbiAgICBhc3luYyBzaWduUmF3UGF5bG9hZChwYXlsb2FkLCBzaWduV2l0aCkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2xpZW50LnNpZ25SYXdQYXlsb2FkKHtcbiAgICAgICAgICAgIHR5cGU6IFwiQUNUSVZJVFlfVFlQRV9TSUdOX1JBV19QQVlMT0FEX1YyXCIsXG4gICAgICAgICAgICBvcmdhbml6YXRpb25JZDogdGhpcy5vcmdhbml6YXRpb25JZCxcbiAgICAgICAgICAgIHRpbWVzdGFtcE1zOiBTdHJpbmcoRGF0ZS5ub3coKSksXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICAgICAgc2lnbldpdGgsXG4gICAgICAgICAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgICAgICAgICBlbmNvZGluZzogXCJQQVlMT0FEX0VOQ09ESU5HX0hFWEFERUNJTUFMXCIsXG4gICAgICAgICAgICAgICAgLy8gTm90ZTogdW5saWtlIEVDRFNBLCBFZERTQSdzIEFQSSBkb2VzIG5vdCBzdXBwb3J0IHNpZ25pbmcgcmF3IGRpZ2VzdHMgKHNlZSBSRkMgODAzMikuXG4gICAgICAgICAgICAgICAgLy8gVHVybmtleSdzIHNpZ25lciByZXF1aXJlcyBhbiBleHBsaWNpdCB2YWx1ZSB0byBiZSBwYXNzZWQgaGVyZSB0byBtaW5pbWl6ZSBhbWJpZ3VpdHkuXG4gICAgICAgICAgICAgICAgaGFzaEZ1bmN0aW9uOiBcIkhBU0hfRlVOQ1RJT05fTk9UX0FQUExJQ0FCTEVcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB7IGlkLCBzdGF0dXMsIHR5cGUsIHJlc3VsdCB9ID0gcmVzcG9uc2UuYWN0aXZpdHk7XG4gICAgICAgIGlmIChzdGF0dXMgIT09IFwiQUNUSVZJVFlfU1RBVFVTX0NPTVBMRVRFRFwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHVybmtleUFjdGl2aXR5RXJyb3Ioe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBFeHBlY3RlZCBDT01QTEVURUQgc3RhdHVzLCBnb3QgJHtzdGF0dXN9YCxcbiAgICAgICAgICAgICAgICBhY3Rpdml0eUlkOiBpZCxcbiAgICAgICAgICAgICAgICBhY3Rpdml0eVN0YXR1czogc3RhdHVzLFxuICAgICAgICAgICAgICAgIGFjdGl2aXR5VHlwZTogdHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuXG5leHBvcnQgeyBUdXJua2V5U2lnbmVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/solana/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/__generated__/services/coordinator/public/v1/public_api.client.mjs":
/*!*****************************************************************************************************************************************!*\
  !*** ./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/__generated__/services/coordinator/public/v1/public_api.client.mjs ***!
  \*****************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TurnkeyClient: () => (/* binding */ TurnkeyClient)\n/* harmony export */ });\n/* harmony import */ var _base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../base.mjs */ \"(ssr)/./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/base.mjs\");\n/* harmony import */ var _version_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../../version.mjs */ \"(ssr)/./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/version.mjs\");\n/* harmony import */ var _universal_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../../universal.mjs */ \"(ssr)/./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/universal.mjs\");\n\n\n\n\n/* @generated by `@turnkey/fetchers`. DO NOT EDIT BY HAND */\nclass TurnkeyClient {\n    constructor(config, stamper) {\n        /**\n         * Get details about an Activity\n         *\n         * Sign the provided `TGetActivityBody` with the client's `stamp` function, and submit the request (POST /public/v1/query/get_activity).\n         *\n         * See also {@link stampGetActivity}.\n         */\n        this.getActivity = async (input) => {\n            return this.request(\"/public/v1/query/get_activity\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TGetActivityBody` by using the client's `stamp` function.\n         *\n         * See also {@link GetActivity}.\n         */\n        this.stampGetActivity = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/query/get_activity\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Get details about an API key\n         *\n         * Sign the provided `TGetApiKeyBody` with the client's `stamp` function, and submit the request (POST /public/v1/query/get_api_key).\n         *\n         * See also {@link stampGetApiKey}.\n         */\n        this.getApiKey = async (input) => {\n            return this.request(\"/public/v1/query/get_api_key\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TGetApiKeyBody` by using the client's `stamp` function.\n         *\n         * See also {@link GetApiKey}.\n         */\n        this.stampGetApiKey = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/query/get_api_key\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Get details about API keys for a user\n         *\n         * Sign the provided `TGetApiKeysBody` with the client's `stamp` function, and submit the request (POST /public/v1/query/get_api_keys).\n         *\n         * See also {@link stampGetApiKeys}.\n         */\n        this.getApiKeys = async (input) => {\n            return this.request(\"/public/v1/query/get_api_keys\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TGetApiKeysBody` by using the client's `stamp` function.\n         *\n         * See also {@link GetApiKeys}.\n         */\n        this.stampGetApiKeys = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/query/get_api_keys\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Get details about an authenticator\n         *\n         * Sign the provided `TGetAuthenticatorBody` with the client's `stamp` function, and submit the request (POST /public/v1/query/get_authenticator).\n         *\n         * See also {@link stampGetAuthenticator}.\n         */\n        this.getAuthenticator = async (input) => {\n            return this.request(\"/public/v1/query/get_authenticator\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TGetAuthenticatorBody` by using the client's `stamp` function.\n         *\n         * See also {@link GetAuthenticator}.\n         */\n        this.stampGetAuthenticator = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/query/get_authenticator\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Get details about authenticators for a user\n         *\n         * Sign the provided `TGetAuthenticatorsBody` with the client's `stamp` function, and submit the request (POST /public/v1/query/get_authenticators).\n         *\n         * See also {@link stampGetAuthenticators}.\n         */\n        this.getAuthenticators = async (input) => {\n            return this.request(\"/public/v1/query/get_authenticators\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TGetAuthenticatorsBody` by using the client's `stamp` function.\n         *\n         * See also {@link GetAuthenticators}.\n         */\n        this.stampGetAuthenticators = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/query/get_authenticators\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Get details about an Organization\n         *\n         * Sign the provided `TGetOrganizationBody` with the client's `stamp` function, and submit the request (POST /public/v1/query/get_organization).\n         *\n         * See also {@link stampGetOrganization}.\n         */\n        this.getOrganization = async (input) => {\n            return this.request(\"/public/v1/query/get_organization\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TGetOrganizationBody` by using the client's `stamp` function.\n         *\n         * See also {@link GetOrganization}.\n         */\n        this.stampGetOrganization = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/query/get_organization\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Get details about a Policy\n         *\n         * Sign the provided `TGetPolicyBody` with the client's `stamp` function, and submit the request (POST /public/v1/query/get_policy).\n         *\n         * See also {@link stampGetPolicy}.\n         */\n        this.getPolicy = async (input) => {\n            return this.request(\"/public/v1/query/get_policy\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TGetPolicyBody` by using the client's `stamp` function.\n         *\n         * See also {@link GetPolicy}.\n         */\n        this.stampGetPolicy = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/query/get_policy\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Get details about a Private Key\n         *\n         * Sign the provided `TGetPrivateKeyBody` with the client's `stamp` function, and submit the request (POST /public/v1/query/get_private_key).\n         *\n         * See also {@link stampGetPrivateKey}.\n         */\n        this.getPrivateKey = async (input) => {\n            return this.request(\"/public/v1/query/get_private_key\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TGetPrivateKeyBody` by using the client's `stamp` function.\n         *\n         * See also {@link GetPrivateKey}.\n         */\n        this.stampGetPrivateKey = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/query/get_private_key\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Get details about a User\n         *\n         * Sign the provided `TGetUserBody` with the client's `stamp` function, and submit the request (POST /public/v1/query/get_user).\n         *\n         * See also {@link stampGetUser}.\n         */\n        this.getUser = async (input) => {\n            return this.request(\"/public/v1/query/get_user\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TGetUserBody` by using the client's `stamp` function.\n         *\n         * See also {@link GetUser}.\n         */\n        this.stampGetUser = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/query/get_user\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Get details about a Wallet\n         *\n         * Sign the provided `TGetWalletBody` with the client's `stamp` function, and submit the request (POST /public/v1/query/get_wallet).\n         *\n         * See also {@link stampGetWallet}.\n         */\n        this.getWallet = async (input) => {\n            return this.request(\"/public/v1/query/get_wallet\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TGetWalletBody` by using the client's `stamp` function.\n         *\n         * See also {@link GetWallet}.\n         */\n        this.stampGetWallet = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/query/get_wallet\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * List all Activities within an Organization\n         *\n         * Sign the provided `TGetActivitiesBody` with the client's `stamp` function, and submit the request (POST /public/v1/query/list_activities).\n         *\n         * See also {@link stampGetActivities}.\n         */\n        this.getActivities = async (input) => {\n            return this.request(\"/public/v1/query/list_activities\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TGetActivitiesBody` by using the client's `stamp` function.\n         *\n         * See also {@link GetActivities}.\n         */\n        this.stampGetActivities = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/query/list_activities\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * List all Policies within an Organization\n         *\n         * Sign the provided `TGetPoliciesBody` with the client's `stamp` function, and submit the request (POST /public/v1/query/list_policies).\n         *\n         * See also {@link stampGetPolicies}.\n         */\n        this.getPolicies = async (input) => {\n            return this.request(\"/public/v1/query/list_policies\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TGetPoliciesBody` by using the client's `stamp` function.\n         *\n         * See also {@link GetPolicies}.\n         */\n        this.stampGetPolicies = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/query/list_policies\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * List all Private Key Tags within an Organization\n         *\n         * Sign the provided `TListPrivateKeyTagsBody` with the client's `stamp` function, and submit the request (POST /public/v1/query/list_private_key_tags).\n         *\n         * See also {@link stampListPrivateKeyTags}.\n         */\n        this.listPrivateKeyTags = async (input) => {\n            return this.request(\"/public/v1/query/list_private_key_tags\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TListPrivateKeyTagsBody` by using the client's `stamp` function.\n         *\n         * See also {@link ListPrivateKeyTags}.\n         */\n        this.stampListPrivateKeyTags = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/query/list_private_key_tags\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * List all Private Keys within an Organization\n         *\n         * Sign the provided `TGetPrivateKeysBody` with the client's `stamp` function, and submit the request (POST /public/v1/query/list_private_keys).\n         *\n         * See also {@link stampGetPrivateKeys}.\n         */\n        this.getPrivateKeys = async (input) => {\n            return this.request(\"/public/v1/query/list_private_keys\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TGetPrivateKeysBody` by using the client's `stamp` function.\n         *\n         * See also {@link GetPrivateKeys}.\n         */\n        this.stampGetPrivateKeys = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/query/list_private_keys\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * List all User Tags within an Organization\n         *\n         * Sign the provided `TListUserTagsBody` with the client's `stamp` function, and submit the request (POST /public/v1/query/list_user_tags).\n         *\n         * See also {@link stampListUserTags}.\n         */\n        this.listUserTags = async (input) => {\n            return this.request(\"/public/v1/query/list_user_tags\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TListUserTagsBody` by using the client's `stamp` function.\n         *\n         * See also {@link ListUserTags}.\n         */\n        this.stampListUserTags = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/query/list_user_tags\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * List all Users within an Organization\n         *\n         * Sign the provided `TGetUsersBody` with the client's `stamp` function, and submit the request (POST /public/v1/query/list_users).\n         *\n         * See also {@link stampGetUsers}.\n         */\n        this.getUsers = async (input) => {\n            return this.request(\"/public/v1/query/list_users\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TGetUsersBody` by using the client's `stamp` function.\n         *\n         * See also {@link GetUsers}.\n         */\n        this.stampGetUsers = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/query/list_users\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * List all Accounts wirhin a Wallet\n         *\n         * Sign the provided `TGetWalletAccountsBody` with the client's `stamp` function, and submit the request (POST /public/v1/query/list_wallet_accounts).\n         *\n         * See also {@link stampGetWalletAccounts}.\n         */\n        this.getWalletAccounts = async (input) => {\n            return this.request(\"/public/v1/query/list_wallet_accounts\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TGetWalletAccountsBody` by using the client's `stamp` function.\n         *\n         * See also {@link GetWalletAccounts}.\n         */\n        this.stampGetWalletAccounts = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/query/list_wallet_accounts\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * List all Wallets within an Organization\n         *\n         * Sign the provided `TGetWalletsBody` with the client's `stamp` function, and submit the request (POST /public/v1/query/list_wallets).\n         *\n         * See also {@link stampGetWallets}.\n         */\n        this.getWallets = async (input) => {\n            return this.request(\"/public/v1/query/list_wallets\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TGetWalletsBody` by using the client's `stamp` function.\n         *\n         * See also {@link GetWallets}.\n         */\n        this.stampGetWallets = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/query/list_wallets\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Get basic information about your current API or WebAuthN user and their organization. Affords Sub-Organization look ups via Parent Organization for WebAuthN users.\n         *\n         * Sign the provided `TGetWhoamiBody` with the client's `stamp` function, and submit the request (POST /public/v1/query/whoami).\n         *\n         * See also {@link stampGetWhoami}.\n         */\n        this.getWhoami = async (input) => {\n            return this.request(\"/public/v1/query/whoami\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TGetWhoamiBody` by using the client's `stamp` function.\n         *\n         * See also {@link GetWhoami}.\n         */\n        this.stampGetWhoami = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/query/whoami\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Approve an Activity\n         *\n         * Sign the provided `TApproveActivityBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/approve_activity).\n         *\n         * See also {@link stampApproveActivity}.\n         */\n        this.approveActivity = async (input) => {\n            return this.request(\"/public/v1/submit/approve_activity\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TApproveActivityBody` by using the client's `stamp` function.\n         *\n         * See also {@link ApproveActivity}.\n         */\n        this.stampApproveActivity = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/approve_activity\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Add api keys to an existing User\n         *\n         * Sign the provided `TCreateApiKeysBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/create_api_keys).\n         *\n         * See also {@link stampCreateApiKeys}.\n         */\n        this.createApiKeys = async (input) => {\n            return this.request(\"/public/v1/submit/create_api_keys\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TCreateApiKeysBody` by using the client's `stamp` function.\n         *\n         * See also {@link CreateApiKeys}.\n         */\n        this.stampCreateApiKeys = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/create_api_keys\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Create API-only Users in an existing Organization\n         *\n         * Sign the provided `TCreateApiOnlyUsersBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/create_api_only_users).\n         *\n         * See also {@link stampCreateApiOnlyUsers}.\n         */\n        this.createApiOnlyUsers = async (input) => {\n            return this.request(\"/public/v1/submit/create_api_only_users\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TCreateApiOnlyUsersBody` by using the client's `stamp` function.\n         *\n         * See also {@link CreateApiOnlyUsers}.\n         */\n        this.stampCreateApiOnlyUsers = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/create_api_only_users\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Create Authenticators to authenticate requests to Turnkey\n         *\n         * Sign the provided `TCreateAuthenticatorsBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/create_authenticators).\n         *\n         * See also {@link stampCreateAuthenticators}.\n         */\n        this.createAuthenticators = async (input) => {\n            return this.request(\"/public/v1/submit/create_authenticators\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TCreateAuthenticatorsBody` by using the client's `stamp` function.\n         *\n         * See also {@link CreateAuthenticators}.\n         */\n        this.stampCreateAuthenticators = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/create_authenticators\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Create Invitations to join an existing Organization\n         *\n         * Sign the provided `TCreateInvitationsBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/create_invitations).\n         *\n         * See also {@link stampCreateInvitations}.\n         */\n        this.createInvitations = async (input) => {\n            return this.request(\"/public/v1/submit/create_invitations\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TCreateInvitationsBody` by using the client's `stamp` function.\n         *\n         * See also {@link CreateInvitations}.\n         */\n        this.stampCreateInvitations = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/create_invitations\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Create a new Policy\n         *\n         * Sign the provided `TCreatePolicyBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/create_policy).\n         *\n         * See also {@link stampCreatePolicy}.\n         */\n        this.createPolicy = async (input) => {\n            return this.request(\"/public/v1/submit/create_policy\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TCreatePolicyBody` by using the client's `stamp` function.\n         *\n         * See also {@link CreatePolicy}.\n         */\n        this.stampCreatePolicy = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/create_policy\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Create a private key tag and add it to private keys.\n         *\n         * Sign the provided `TCreatePrivateKeyTagBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/create_private_key_tag).\n         *\n         * See also {@link stampCreatePrivateKeyTag}.\n         */\n        this.createPrivateKeyTag = async (input) => {\n            return this.request(\"/public/v1/submit/create_private_key_tag\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TCreatePrivateKeyTagBody` by using the client's `stamp` function.\n         *\n         * See also {@link CreatePrivateKeyTag}.\n         */\n        this.stampCreatePrivateKeyTag = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/create_private_key_tag\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Create new Private Keys\n         *\n         * Sign the provided `TCreatePrivateKeysBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/create_private_keys).\n         *\n         * See also {@link stampCreatePrivateKeys}.\n         */\n        this.createPrivateKeys = async (input) => {\n            return this.request(\"/public/v1/submit/create_private_keys\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TCreatePrivateKeysBody` by using the client's `stamp` function.\n         *\n         * See also {@link CreatePrivateKeys}.\n         */\n        this.stampCreatePrivateKeys = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/create_private_keys\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Create a new Sub-Organization\n         *\n         * Sign the provided `TCreateSubOrganizationBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/create_sub_organization).\n         *\n         * See also {@link stampCreateSubOrganization}.\n         */\n        this.createSubOrganization = async (input) => {\n            return this.request(\"/public/v1/submit/create_sub_organization\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TCreateSubOrganizationBody` by using the client's `stamp` function.\n         *\n         * See also {@link CreateSubOrganization}.\n         */\n        this.stampCreateSubOrganization = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/create_sub_organization\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Create a user tag and add it to users.\n         *\n         * Sign the provided `TCreateUserTagBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/create_user_tag).\n         *\n         * See also {@link stampCreateUserTag}.\n         */\n        this.createUserTag = async (input) => {\n            return this.request(\"/public/v1/submit/create_user_tag\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TCreateUserTagBody` by using the client's `stamp` function.\n         *\n         * See also {@link CreateUserTag}.\n         */\n        this.stampCreateUserTag = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/create_user_tag\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Create Users in an existing Organization\n         *\n         * Sign the provided `TCreateUsersBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/create_users).\n         *\n         * See also {@link stampCreateUsers}.\n         */\n        this.createUsers = async (input) => {\n            return this.request(\"/public/v1/submit/create_users\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TCreateUsersBody` by using the client's `stamp` function.\n         *\n         * See also {@link CreateUsers}.\n         */\n        this.stampCreateUsers = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/create_users\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Create a Wallet and derive addresses\n         *\n         * Sign the provided `TCreateWalletBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/create_wallet).\n         *\n         * See also {@link stampCreateWallet}.\n         */\n        this.createWallet = async (input) => {\n            return this.request(\"/public/v1/submit/create_wallet\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TCreateWalletBody` by using the client's `stamp` function.\n         *\n         * See also {@link CreateWallet}.\n         */\n        this.stampCreateWallet = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/create_wallet\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Derive additional addresses using an existing wallet\n         *\n         * Sign the provided `TCreateWalletAccountsBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/create_wallet_accounts).\n         *\n         * See also {@link stampCreateWalletAccounts}.\n         */\n        this.createWalletAccounts = async (input) => {\n            return this.request(\"/public/v1/submit/create_wallet_accounts\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TCreateWalletAccountsBody` by using the client's `stamp` function.\n         *\n         * See also {@link CreateWalletAccounts}.\n         */\n        this.stampCreateWalletAccounts = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/create_wallet_accounts\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Remove api keys from a User\n         *\n         * Sign the provided `TDeleteApiKeysBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/delete_api_keys).\n         *\n         * See also {@link stampDeleteApiKeys}.\n         */\n        this.deleteApiKeys = async (input) => {\n            return this.request(\"/public/v1/submit/delete_api_keys\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TDeleteApiKeysBody` by using the client's `stamp` function.\n         *\n         * See also {@link DeleteApiKeys}.\n         */\n        this.stampDeleteApiKeys = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/delete_api_keys\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Remove authenticators from a User\n         *\n         * Sign the provided `TDeleteAuthenticatorsBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/delete_authenticators).\n         *\n         * See also {@link stampDeleteAuthenticators}.\n         */\n        this.deleteAuthenticators = async (input) => {\n            return this.request(\"/public/v1/submit/delete_authenticators\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TDeleteAuthenticatorsBody` by using the client's `stamp` function.\n         *\n         * See also {@link DeleteAuthenticators}.\n         */\n        this.stampDeleteAuthenticators = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/delete_authenticators\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Delete an existing Invitation\n         *\n         * Sign the provided `TDeleteInvitationBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/delete_invitation).\n         *\n         * See also {@link stampDeleteInvitation}.\n         */\n        this.deleteInvitation = async (input) => {\n            return this.request(\"/public/v1/submit/delete_invitation\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TDeleteInvitationBody` by using the client's `stamp` function.\n         *\n         * See also {@link DeleteInvitation}.\n         */\n        this.stampDeleteInvitation = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/delete_invitation\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Delete an existing Policy\n         *\n         * Sign the provided `TDeletePolicyBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/delete_policy).\n         *\n         * See also {@link stampDeletePolicy}.\n         */\n        this.deletePolicy = async (input) => {\n            return this.request(\"/public/v1/submit/delete_policy\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TDeletePolicyBody` by using the client's `stamp` function.\n         *\n         * See also {@link DeletePolicy}.\n         */\n        this.stampDeletePolicy = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/delete_policy\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Authenticate a user via Email\n         *\n         * Sign the provided `TEmailAuthBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/email_auth).\n         *\n         * See also {@link stampEmailAuth}.\n         */\n        this.emailAuth = async (input) => {\n            return this.request(\"/public/v1/submit/email_auth\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TEmailAuthBody` by using the client's `stamp` function.\n         *\n         * See also {@link EmailAuth}.\n         */\n        this.stampEmailAuth = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/email_auth\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Exports a Private Key\n         *\n         * Sign the provided `TExportPrivateKeyBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/export_private_key).\n         *\n         * See also {@link stampExportPrivateKey}.\n         */\n        this.exportPrivateKey = async (input) => {\n            return this.request(\"/public/v1/submit/export_private_key\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TExportPrivateKeyBody` by using the client's `stamp` function.\n         *\n         * See also {@link ExportPrivateKey}.\n         */\n        this.stampExportPrivateKey = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/export_private_key\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Exports a Wallet\n         *\n         * Sign the provided `TExportWalletBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/export_wallet).\n         *\n         * See also {@link stampExportWallet}.\n         */\n        this.exportWallet = async (input) => {\n            return this.request(\"/public/v1/submit/export_wallet\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TExportWalletBody` by using the client's `stamp` function.\n         *\n         * See also {@link ExportWallet}.\n         */\n        this.stampExportWallet = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/export_wallet\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Exports a Wallet Account\n         *\n         * Sign the provided `TExportWalletAccountBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/export_wallet_account).\n         *\n         * See also {@link stampExportWalletAccount}.\n         */\n        this.exportWalletAccount = async (input) => {\n            return this.request(\"/public/v1/submit/export_wallet_account\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TExportWalletAccountBody` by using the client's `stamp` function.\n         *\n         * See also {@link ExportWalletAccount}.\n         */\n        this.stampExportWalletAccount = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/export_wallet_account\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Initializes a new email recovery\n         *\n         * Sign the provided `TInitUserEmailRecoveryBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/init_user_email_recovery).\n         *\n         * See also {@link stampInitUserEmailRecovery}.\n         */\n        this.initUserEmailRecovery = async (input) => {\n            return this.request(\"/public/v1/submit/init_user_email_recovery\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TInitUserEmailRecoveryBody` by using the client's `stamp` function.\n         *\n         * See also {@link InitUserEmailRecovery}.\n         */\n        this.stampInitUserEmailRecovery = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/init_user_email_recovery\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Completes the process of recovering a user by adding an authenticator\n         *\n         * Sign the provided `TRecoverUserBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/recover_user).\n         *\n         * See also {@link stampRecoverUser}.\n         */\n        this.recoverUser = async (input) => {\n            return this.request(\"/public/v1/submit/recover_user\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TRecoverUserBody` by using the client's `stamp` function.\n         *\n         * See also {@link RecoverUser}.\n         */\n        this.stampRecoverUser = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/recover_user\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Reject an Activity\n         *\n         * Sign the provided `TRejectActivityBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/reject_activity).\n         *\n         * See also {@link stampRejectActivity}.\n         */\n        this.rejectActivity = async (input) => {\n            return this.request(\"/public/v1/submit/reject_activity\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TRejectActivityBody` by using the client's `stamp` function.\n         *\n         * See also {@link RejectActivity}.\n         */\n        this.stampRejectActivity = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/reject_activity\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Removes an organization feature\n         *\n         * Sign the provided `TRemoveOrganizationFeatureBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/remove_organization_feature).\n         *\n         * See also {@link stampRemoveOrganizationFeature}.\n         */\n        this.removeOrganizationFeature = async (input) => {\n            return this.request(\"/public/v1/submit/remove_organization_feature\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TRemoveOrganizationFeatureBody` by using the client's `stamp` function.\n         *\n         * See also {@link RemoveOrganizationFeature}.\n         */\n        this.stampRemoveOrganizationFeature = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/remove_organization_feature\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Sets an organization feature\n         *\n         * Sign the provided `TSetOrganizationFeatureBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/set_organization_feature).\n         *\n         * See also {@link stampSetOrganizationFeature}.\n         */\n        this.setOrganizationFeature = async (input) => {\n            return this.request(\"/public/v1/submit/set_organization_feature\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TSetOrganizationFeatureBody` by using the client's `stamp` function.\n         *\n         * See also {@link SetOrganizationFeature}.\n         */\n        this.stampSetOrganizationFeature = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/set_organization_feature\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Sign a raw payload\n         *\n         * Sign the provided `TSignRawPayloadBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/sign_raw_payload).\n         *\n         * See also {@link stampSignRawPayload}.\n         */\n        this.signRawPayload = async (input) => {\n            return this.request(\"/public/v1/submit/sign_raw_payload\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TSignRawPayloadBody` by using the client's `stamp` function.\n         *\n         * See also {@link SignRawPayload}.\n         */\n        this.stampSignRawPayload = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/sign_raw_payload\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Sign a transaction\n         *\n         * Sign the provided `TSignTransactionBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/sign_transaction).\n         *\n         * See also {@link stampSignTransaction}.\n         */\n        this.signTransaction = async (input) => {\n            return this.request(\"/public/v1/submit/sign_transaction\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TSignTransactionBody` by using the client's `stamp` function.\n         *\n         * See also {@link SignTransaction}.\n         */\n        this.stampSignTransaction = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/sign_transaction\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Update an existing Policy\n         *\n         * Sign the provided `TUpdatePolicyBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/update_policy).\n         *\n         * See also {@link stampUpdatePolicy}.\n         */\n        this.updatePolicy = async (input) => {\n            return this.request(\"/public/v1/submit/update_policy\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TUpdatePolicyBody` by using the client's `stamp` function.\n         *\n         * See also {@link UpdatePolicy}.\n         */\n        this.stampUpdatePolicy = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/update_policy\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Update human-readable name or associated private keys. Note that this activity is atomic: all of the updates will succeed at once, or all of them will fail.\n         *\n         * Sign the provided `TUpdatePrivateKeyTagBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/update_private_key_tag).\n         *\n         * See also {@link stampUpdatePrivateKeyTag}.\n         */\n        this.updatePrivateKeyTag = async (input) => {\n            return this.request(\"/public/v1/submit/update_private_key_tag\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TUpdatePrivateKeyTagBody` by using the client's `stamp` function.\n         *\n         * See also {@link UpdatePrivateKeyTag}.\n         */\n        this.stampUpdatePrivateKeyTag = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/update_private_key_tag\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Set the threshold and members of the root quorum. This must be approved by the current root quorum.\n         *\n         * Sign the provided `TUpdateRootQuorumBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/update_root_quorum).\n         *\n         * See also {@link stampUpdateRootQuorum}.\n         */\n        this.updateRootQuorum = async (input) => {\n            return this.request(\"/public/v1/submit/update_root_quorum\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TUpdateRootQuorumBody` by using the client's `stamp` function.\n         *\n         * See also {@link UpdateRootQuorum}.\n         */\n        this.stampUpdateRootQuorum = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/update_root_quorum\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Update a User in an existing Organization\n         *\n         * Sign the provided `TUpdateUserBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/update_user).\n         *\n         * See also {@link stampUpdateUser}.\n         */\n        this.updateUser = async (input) => {\n            return this.request(\"/public/v1/submit/update_user\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TUpdateUserBody` by using the client's `stamp` function.\n         *\n         * See also {@link UpdateUser}.\n         */\n        this.stampUpdateUser = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/update_user\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        /**\n         * Update human-readable name or associated users. Note that this activity is atomic: all of the updates will succeed at once, or all of them will fail.\n         *\n         * Sign the provided `TUpdateUserTagBody` with the client's `stamp` function, and submit the request (POST /public/v1/submit/update_user_tag).\n         *\n         * See also {@link stampUpdateUserTag}.\n         */\n        this.updateUserTag = async (input) => {\n            return this.request(\"/public/v1/submit/update_user_tag\", input);\n        };\n        /**\n         * Produce a `SignedRequest` from `TUpdateUserTagBody` by using the client's `stamp` function.\n         *\n         * See also {@link UpdateUserTag}.\n         */\n        this.stampUpdateUserTag = async (input) => {\n            const fullUrl = this.config.baseUrl + \"/public/v1/submit/update_user_tag\";\n            const body = JSON.stringify(input);\n            const stamp = await this.stamper.stamp(body);\n            return {\n                body: body,\n                stamp: stamp,\n                url: fullUrl,\n            };\n        };\n        if (!config.baseUrl) {\n            throw new Error(`Missing base URL. Please verify env vars.`);\n        }\n        this.config = config;\n        this.stamper = stamper;\n    }\n    async request(url, body) {\n        const fullUrl = this.config.baseUrl + url;\n        const stringifiedBody = JSON.stringify(body);\n        const stamp = await this.stamper.stamp(stringifiedBody);\n        const response = await (0,_universal_mjs__WEBPACK_IMPORTED_MODULE_2__.fetch)(fullUrl, {\n            method: \"POST\",\n            headers: {\n                [stamp.stampHeaderName]: stamp.stampHeaderValue,\n                \"X-Client-Version\": _version_mjs__WEBPACK_IMPORTED_MODULE_1__.VERSION,\n            },\n            body: stringifiedBody,\n            redirect: \"follow\",\n        });\n        if (!response.ok) {\n            let res;\n            try {\n                res = await response.json();\n            }\n            catch (_) {\n                throw new Error(`${response.status} ${response.statusText}`);\n            }\n            throw new _base_mjs__WEBPACK_IMPORTED_MODULE_0__.TurnkeyRequestError(res);\n        }\n        const data = await response.json();\n        return data;\n    }\n}\n\n\n//# sourceMappingURL=public_api.client.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvc29sYW5hL25vZGVfbW9kdWxlcy9AdHVybmtleS9odHRwL2Rpc3QvX19nZW5lcmF0ZWRfXy9zZXJ2aWNlcy9jb29yZGluYXRvci9wdWJsaWMvdjEvcHVibGljX2FwaS5jbGllbnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBOEQ7QUFDVDtBQUNBOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIscUJBQXFCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDRCQUE0QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNkJBQTZCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHdCQUF3QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwyQkFBMkI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0JBQXNCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHFCQUFxQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIseUJBQXlCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG9CQUFvQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixtQkFBbUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsY0FBYztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixxQkFBcUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHlCQUF5QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixvQkFBb0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw4QkFBOEI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIseUJBQXlCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDBCQUEwQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixxQkFBcUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsd0JBQXdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1CQUFtQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixvQkFBb0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZUFBZTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw2QkFBNkI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsd0JBQXdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNCQUFzQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIscUJBQXFCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwyQkFBMkI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0JBQXNCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHlCQUF5QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixvQkFBb0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsOEJBQThCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHlCQUF5QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixnQ0FBZ0M7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMkJBQTJCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDZCQUE2QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix3QkFBd0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsd0JBQXdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1CQUFtQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwrQkFBK0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMEJBQTBCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDZCQUE2QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix3QkFBd0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaUNBQWlDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDRCQUE0QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix5QkFBeUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsb0JBQW9CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsd0JBQXdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1CQUFtQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixnQ0FBZ0M7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMkJBQTJCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHlCQUF5QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixvQkFBb0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZ0NBQWdDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDJCQUEyQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw0QkFBNEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHdCQUF3QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixtQkFBbUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIscUJBQXFCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw0QkFBNEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHdCQUF3QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixtQkFBbUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsK0JBQStCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDBCQUEwQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQ0FBaUM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNEJBQTRCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMEJBQTBCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHFCQUFxQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixxQ0FBcUM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZ0NBQWdDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGtDQUFrQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw2QkFBNkI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMEJBQTBCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHFCQUFxQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwyQkFBMkI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0JBQXNCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHdCQUF3QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixtQkFBbUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsK0JBQStCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDBCQUEwQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw0QkFBNEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNCQUFzQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIseUJBQXlCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG9CQUFvQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IscURBQUs7QUFDcEM7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGlEQUFPO0FBQzNDLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxpQkFBaUIsRUFBRSxvQkFBb0I7QUFDMUU7QUFDQSxzQkFBc0IsMERBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXlCO0FBQ3pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbnVyc2VibG9jLy4vbm9kZV9tb2R1bGVzL0B0dXJua2V5L3NvbGFuYS9ub2RlX21vZHVsZXMvQHR1cm5rZXkvaHR0cC9kaXN0L19fZ2VuZXJhdGVkX18vc2VydmljZXMvY29vcmRpbmF0b3IvcHVibGljL3YxL3B1YmxpY19hcGkuY2xpZW50Lm1qcz9hYWY3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFR1cm5rZXlSZXF1ZXN0RXJyb3IgfSBmcm9tICcuLi8uLi8uLi8uLi8uLi9iYXNlLm1qcyc7XG5pbXBvcnQgeyBWRVJTSU9OIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vdmVyc2lvbi5tanMnO1xuaW1wb3J0IHsgZmV0Y2ggfSBmcm9tICcuLi8uLi8uLi8uLi8uLi91bml2ZXJzYWwubWpzJztcblxuLyogQGdlbmVyYXRlZCBieSBgQHR1cm5rZXkvZmV0Y2hlcnNgLiBETyBOT1QgRURJVCBCWSBIQU5EICovXG5jbGFzcyBUdXJua2V5Q2xpZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcsIHN0YW1wZXIpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBkZXRhaWxzIGFib3V0IGFuIEFjdGl2aXR5XG4gICAgICAgICAqXG4gICAgICAgICAqIFNpZ24gdGhlIHByb3ZpZGVkIGBUR2V0QWN0aXZpdHlCb2R5YCB3aXRoIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLCBhbmQgc3VibWl0IHRoZSByZXF1ZXN0IChQT1NUIC9wdWJsaWMvdjEvcXVlcnkvZ2V0X2FjdGl2aXR5KS5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIHN0YW1wR2V0QWN0aXZpdHl9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZXRBY3Rpdml0eSA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChcIi9wdWJsaWMvdjEvcXVlcnkvZ2V0X2FjdGl2aXR5XCIsIGlucHV0KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb2R1Y2UgYSBgU2lnbmVkUmVxdWVzdGAgZnJvbSBgVEdldEFjdGl2aXR5Qm9keWAgYnkgdXNpbmcgdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBhbHNvIHtAbGluayBHZXRBY3Rpdml0eX0uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YW1wR2V0QWN0aXZpdHkgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZ1bGxVcmwgPSB0aGlzLmNvbmZpZy5iYXNlVXJsICsgXCIvcHVibGljL3YxL3F1ZXJ5L2dldF9hY3Rpdml0eVwiO1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KGlucHV0KTtcbiAgICAgICAgICAgIGNvbnN0IHN0YW1wID0gYXdhaXQgdGhpcy5zdGFtcGVyLnN0YW1wKGJvZHkpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgICAgIHN0YW1wOiBzdGFtcCxcbiAgICAgICAgICAgICAgICB1cmw6IGZ1bGxVcmwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGRldGFpbHMgYWJvdXQgYW4gQVBJIGtleVxuICAgICAgICAgKlxuICAgICAgICAgKiBTaWduIHRoZSBwcm92aWRlZCBgVEdldEFwaUtleUJvZHlgIHdpdGggdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24sIGFuZCBzdWJtaXQgdGhlIHJlcXVlc3QgKFBPU1QgL3B1YmxpYy92MS9xdWVyeS9nZXRfYXBpX2tleSkuXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBhbHNvIHtAbGluayBzdGFtcEdldEFwaUtleX0uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldEFwaUtleSA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChcIi9wdWJsaWMvdjEvcXVlcnkvZ2V0X2FwaV9rZXlcIiwgaW5wdXQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZHVjZSBhIGBTaWduZWRSZXF1ZXN0YCBmcm9tIGBUR2V0QXBpS2V5Qm9keWAgYnkgdXNpbmcgdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBhbHNvIHtAbGluayBHZXRBcGlLZXl9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFtcEdldEFwaUtleSA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnVsbFVybCA9IHRoaXMuY29uZmlnLmJhc2VVcmwgKyBcIi9wdWJsaWMvdjEvcXVlcnkvZ2V0X2FwaV9rZXlcIjtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeShpbnB1dCk7XG4gICAgICAgICAgICBjb25zdCBzdGFtcCA9IGF3YWl0IHRoaXMuc3RhbXBlci5zdGFtcChib2R5KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgICAgICBzdGFtcDogc3RhbXAsXG4gICAgICAgICAgICAgICAgdXJsOiBmdWxsVXJsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBkZXRhaWxzIGFib3V0IEFQSSBrZXlzIGZvciBhIHVzZXJcbiAgICAgICAgICpcbiAgICAgICAgICogU2lnbiB0aGUgcHJvdmlkZWQgYFRHZXRBcGlLZXlzQm9keWAgd2l0aCB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbiwgYW5kIHN1Ym1pdCB0aGUgcmVxdWVzdCAoUE9TVCAvcHVibGljL3YxL3F1ZXJ5L2dldF9hcGlfa2V5cykuXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBhbHNvIHtAbGluayBzdGFtcEdldEFwaUtleXN9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZXRBcGlLZXlzID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KFwiL3B1YmxpYy92MS9xdWVyeS9nZXRfYXBpX2tleXNcIiwgaW5wdXQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZHVjZSBhIGBTaWduZWRSZXF1ZXN0YCBmcm9tIGBUR2V0QXBpS2V5c0JvZHlgIGJ5IHVzaW5nIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgR2V0QXBpS2V5c30uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YW1wR2V0QXBpS2V5cyA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnVsbFVybCA9IHRoaXMuY29uZmlnLmJhc2VVcmwgKyBcIi9wdWJsaWMvdjEvcXVlcnkvZ2V0X2FwaV9rZXlzXCI7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkoaW5wdXQpO1xuICAgICAgICAgICAgY29uc3Qgc3RhbXAgPSBhd2FpdCB0aGlzLnN0YW1wZXIuc3RhbXAoYm9keSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICAgICAgc3RhbXA6IHN0YW1wLFxuICAgICAgICAgICAgICAgIHVybDogZnVsbFVybCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgZGV0YWlscyBhYm91dCBhbiBhdXRoZW50aWNhdG9yXG4gICAgICAgICAqXG4gICAgICAgICAqIFNpZ24gdGhlIHByb3ZpZGVkIGBUR2V0QXV0aGVudGljYXRvckJvZHlgIHdpdGggdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24sIGFuZCBzdWJtaXQgdGhlIHJlcXVlc3QgKFBPU1QgL3B1YmxpYy92MS9xdWVyeS9nZXRfYXV0aGVudGljYXRvcikuXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBhbHNvIHtAbGluayBzdGFtcEdldEF1dGhlbnRpY2F0b3J9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZXRBdXRoZW50aWNhdG9yID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KFwiL3B1YmxpYy92MS9xdWVyeS9nZXRfYXV0aGVudGljYXRvclwiLCBpbnB1dCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9kdWNlIGEgYFNpZ25lZFJlcXVlc3RgIGZyb20gYFRHZXRBdXRoZW50aWNhdG9yQm9keWAgYnkgdXNpbmcgdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBhbHNvIHtAbGluayBHZXRBdXRoZW50aWNhdG9yfS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhbXBHZXRBdXRoZW50aWNhdG9yID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmdWxsVXJsID0gdGhpcy5jb25maWcuYmFzZVVybCArIFwiL3B1YmxpYy92MS9xdWVyeS9nZXRfYXV0aGVudGljYXRvclwiO1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KGlucHV0KTtcbiAgICAgICAgICAgIGNvbnN0IHN0YW1wID0gYXdhaXQgdGhpcy5zdGFtcGVyLnN0YW1wKGJvZHkpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgICAgIHN0YW1wOiBzdGFtcCxcbiAgICAgICAgICAgICAgICB1cmw6IGZ1bGxVcmwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGRldGFpbHMgYWJvdXQgYXV0aGVudGljYXRvcnMgZm9yIGEgdXNlclxuICAgICAgICAgKlxuICAgICAgICAgKiBTaWduIHRoZSBwcm92aWRlZCBgVEdldEF1dGhlbnRpY2F0b3JzQm9keWAgd2l0aCB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbiwgYW5kIHN1Ym1pdCB0aGUgcmVxdWVzdCAoUE9TVCAvcHVibGljL3YxL3F1ZXJ5L2dldF9hdXRoZW50aWNhdG9ycykuXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBhbHNvIHtAbGluayBzdGFtcEdldEF1dGhlbnRpY2F0b3JzfS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0QXV0aGVudGljYXRvcnMgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoXCIvcHVibGljL3YxL3F1ZXJ5L2dldF9hdXRoZW50aWNhdG9yc1wiLCBpbnB1dCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9kdWNlIGEgYFNpZ25lZFJlcXVlc3RgIGZyb20gYFRHZXRBdXRoZW50aWNhdG9yc0JvZHlgIGJ5IHVzaW5nIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgR2V0QXV0aGVudGljYXRvcnN9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFtcEdldEF1dGhlbnRpY2F0b3JzID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmdWxsVXJsID0gdGhpcy5jb25maWcuYmFzZVVybCArIFwiL3B1YmxpYy92MS9xdWVyeS9nZXRfYXV0aGVudGljYXRvcnNcIjtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeShpbnB1dCk7XG4gICAgICAgICAgICBjb25zdCBzdGFtcCA9IGF3YWl0IHRoaXMuc3RhbXBlci5zdGFtcChib2R5KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgICAgICBzdGFtcDogc3RhbXAsXG4gICAgICAgICAgICAgICAgdXJsOiBmdWxsVXJsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBkZXRhaWxzIGFib3V0IGFuIE9yZ2FuaXphdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBTaWduIHRoZSBwcm92aWRlZCBgVEdldE9yZ2FuaXphdGlvbkJvZHlgIHdpdGggdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24sIGFuZCBzdWJtaXQgdGhlIHJlcXVlc3QgKFBPU1QgL3B1YmxpYy92MS9xdWVyeS9nZXRfb3JnYW5pemF0aW9uKS5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIHN0YW1wR2V0T3JnYW5pemF0aW9ufS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0T3JnYW5pemF0aW9uID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KFwiL3B1YmxpYy92MS9xdWVyeS9nZXRfb3JnYW5pemF0aW9uXCIsIGlucHV0KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb2R1Y2UgYSBgU2lnbmVkUmVxdWVzdGAgZnJvbSBgVEdldE9yZ2FuaXphdGlvbkJvZHlgIGJ5IHVzaW5nIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgR2V0T3JnYW5pemF0aW9ufS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhbXBHZXRPcmdhbml6YXRpb24gPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZ1bGxVcmwgPSB0aGlzLmNvbmZpZy5iYXNlVXJsICsgXCIvcHVibGljL3YxL3F1ZXJ5L2dldF9vcmdhbml6YXRpb25cIjtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeShpbnB1dCk7XG4gICAgICAgICAgICBjb25zdCBzdGFtcCA9IGF3YWl0IHRoaXMuc3RhbXBlci5zdGFtcChib2R5KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgICAgICBzdGFtcDogc3RhbXAsXG4gICAgICAgICAgICAgICAgdXJsOiBmdWxsVXJsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBkZXRhaWxzIGFib3V0IGEgUG9saWN5XG4gICAgICAgICAqXG4gICAgICAgICAqIFNpZ24gdGhlIHByb3ZpZGVkIGBUR2V0UG9saWN5Qm9keWAgd2l0aCB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbiwgYW5kIHN1Ym1pdCB0aGUgcmVxdWVzdCAoUE9TVCAvcHVibGljL3YxL3F1ZXJ5L2dldF9wb2xpY3kpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgc3RhbXBHZXRQb2xpY3l9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZXRQb2xpY3kgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoXCIvcHVibGljL3YxL3F1ZXJ5L2dldF9wb2xpY3lcIiwgaW5wdXQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZHVjZSBhIGBTaWduZWRSZXF1ZXN0YCBmcm9tIGBUR2V0UG9saWN5Qm9keWAgYnkgdXNpbmcgdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBhbHNvIHtAbGluayBHZXRQb2xpY3l9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFtcEdldFBvbGljeSA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnVsbFVybCA9IHRoaXMuY29uZmlnLmJhc2VVcmwgKyBcIi9wdWJsaWMvdjEvcXVlcnkvZ2V0X3BvbGljeVwiO1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KGlucHV0KTtcbiAgICAgICAgICAgIGNvbnN0IHN0YW1wID0gYXdhaXQgdGhpcy5zdGFtcGVyLnN0YW1wKGJvZHkpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgICAgIHN0YW1wOiBzdGFtcCxcbiAgICAgICAgICAgICAgICB1cmw6IGZ1bGxVcmwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGRldGFpbHMgYWJvdXQgYSBQcml2YXRlIEtleVxuICAgICAgICAgKlxuICAgICAgICAgKiBTaWduIHRoZSBwcm92aWRlZCBgVEdldFByaXZhdGVLZXlCb2R5YCB3aXRoIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLCBhbmQgc3VibWl0IHRoZSByZXF1ZXN0IChQT1NUIC9wdWJsaWMvdjEvcXVlcnkvZ2V0X3ByaXZhdGVfa2V5KS5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIHN0YW1wR2V0UHJpdmF0ZUtleX0uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldFByaXZhdGVLZXkgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoXCIvcHVibGljL3YxL3F1ZXJ5L2dldF9wcml2YXRlX2tleVwiLCBpbnB1dCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9kdWNlIGEgYFNpZ25lZFJlcXVlc3RgIGZyb20gYFRHZXRQcml2YXRlS2V5Qm9keWAgYnkgdXNpbmcgdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBhbHNvIHtAbGluayBHZXRQcml2YXRlS2V5fS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhbXBHZXRQcml2YXRlS2V5ID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmdWxsVXJsID0gdGhpcy5jb25maWcuYmFzZVVybCArIFwiL3B1YmxpYy92MS9xdWVyeS9nZXRfcHJpdmF0ZV9rZXlcIjtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeShpbnB1dCk7XG4gICAgICAgICAgICBjb25zdCBzdGFtcCA9IGF3YWl0IHRoaXMuc3RhbXBlci5zdGFtcChib2R5KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgICAgICBzdGFtcDogc3RhbXAsXG4gICAgICAgICAgICAgICAgdXJsOiBmdWxsVXJsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBkZXRhaWxzIGFib3V0IGEgVXNlclxuICAgICAgICAgKlxuICAgICAgICAgKiBTaWduIHRoZSBwcm92aWRlZCBgVEdldFVzZXJCb2R5YCB3aXRoIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLCBhbmQgc3VibWl0IHRoZSByZXF1ZXN0IChQT1NUIC9wdWJsaWMvdjEvcXVlcnkvZ2V0X3VzZXIpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgc3RhbXBHZXRVc2VyfS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0VXNlciA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChcIi9wdWJsaWMvdjEvcXVlcnkvZ2V0X3VzZXJcIiwgaW5wdXQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZHVjZSBhIGBTaWduZWRSZXF1ZXN0YCBmcm9tIGBUR2V0VXNlckJvZHlgIGJ5IHVzaW5nIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgR2V0VXNlcn0uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YW1wR2V0VXNlciA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnVsbFVybCA9IHRoaXMuY29uZmlnLmJhc2VVcmwgKyBcIi9wdWJsaWMvdjEvcXVlcnkvZ2V0X3VzZXJcIjtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeShpbnB1dCk7XG4gICAgICAgICAgICBjb25zdCBzdGFtcCA9IGF3YWl0IHRoaXMuc3RhbXBlci5zdGFtcChib2R5KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgICAgICBzdGFtcDogc3RhbXAsXG4gICAgICAgICAgICAgICAgdXJsOiBmdWxsVXJsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBkZXRhaWxzIGFib3V0IGEgV2FsbGV0XG4gICAgICAgICAqXG4gICAgICAgICAqIFNpZ24gdGhlIHByb3ZpZGVkIGBUR2V0V2FsbGV0Qm9keWAgd2l0aCB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbiwgYW5kIHN1Ym1pdCB0aGUgcmVxdWVzdCAoUE9TVCAvcHVibGljL3YxL3F1ZXJ5L2dldF93YWxsZXQpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgc3RhbXBHZXRXYWxsZXR9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZXRXYWxsZXQgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoXCIvcHVibGljL3YxL3F1ZXJ5L2dldF93YWxsZXRcIiwgaW5wdXQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZHVjZSBhIGBTaWduZWRSZXF1ZXN0YCBmcm9tIGBUR2V0V2FsbGV0Qm9keWAgYnkgdXNpbmcgdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBhbHNvIHtAbGluayBHZXRXYWxsZXR9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFtcEdldFdhbGxldCA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnVsbFVybCA9IHRoaXMuY29uZmlnLmJhc2VVcmwgKyBcIi9wdWJsaWMvdjEvcXVlcnkvZ2V0X3dhbGxldFwiO1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KGlucHV0KTtcbiAgICAgICAgICAgIGNvbnN0IHN0YW1wID0gYXdhaXQgdGhpcy5zdGFtcGVyLnN0YW1wKGJvZHkpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgICAgIHN0YW1wOiBzdGFtcCxcbiAgICAgICAgICAgICAgICB1cmw6IGZ1bGxVcmwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCBhbGwgQWN0aXZpdGllcyB3aXRoaW4gYW4gT3JnYW5pemF0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIFNpZ24gdGhlIHByb3ZpZGVkIGBUR2V0QWN0aXZpdGllc0JvZHlgIHdpdGggdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24sIGFuZCBzdWJtaXQgdGhlIHJlcXVlc3QgKFBPU1QgL3B1YmxpYy92MS9xdWVyeS9saXN0X2FjdGl2aXRpZXMpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgc3RhbXBHZXRBY3Rpdml0aWVzfS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0QWN0aXZpdGllcyA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChcIi9wdWJsaWMvdjEvcXVlcnkvbGlzdF9hY3Rpdml0aWVzXCIsIGlucHV0KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb2R1Y2UgYSBgU2lnbmVkUmVxdWVzdGAgZnJvbSBgVEdldEFjdGl2aXRpZXNCb2R5YCBieSB1c2luZyB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIEdldEFjdGl2aXRpZXN9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFtcEdldEFjdGl2aXRpZXMgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZ1bGxVcmwgPSB0aGlzLmNvbmZpZy5iYXNlVXJsICsgXCIvcHVibGljL3YxL3F1ZXJ5L2xpc3RfYWN0aXZpdGllc1wiO1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KGlucHV0KTtcbiAgICAgICAgICAgIGNvbnN0IHN0YW1wID0gYXdhaXQgdGhpcy5zdGFtcGVyLnN0YW1wKGJvZHkpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgICAgIHN0YW1wOiBzdGFtcCxcbiAgICAgICAgICAgICAgICB1cmw6IGZ1bGxVcmwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCBhbGwgUG9saWNpZXMgd2l0aGluIGFuIE9yZ2FuaXphdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBTaWduIHRoZSBwcm92aWRlZCBgVEdldFBvbGljaWVzQm9keWAgd2l0aCB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbiwgYW5kIHN1Ym1pdCB0aGUgcmVxdWVzdCAoUE9TVCAvcHVibGljL3YxL3F1ZXJ5L2xpc3RfcG9saWNpZXMpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgc3RhbXBHZXRQb2xpY2llc30uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldFBvbGljaWVzID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KFwiL3B1YmxpYy92MS9xdWVyeS9saXN0X3BvbGljaWVzXCIsIGlucHV0KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb2R1Y2UgYSBgU2lnbmVkUmVxdWVzdGAgZnJvbSBgVEdldFBvbGljaWVzQm9keWAgYnkgdXNpbmcgdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBhbHNvIHtAbGluayBHZXRQb2xpY2llc30uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YW1wR2V0UG9saWNpZXMgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZ1bGxVcmwgPSB0aGlzLmNvbmZpZy5iYXNlVXJsICsgXCIvcHVibGljL3YxL3F1ZXJ5L2xpc3RfcG9saWNpZXNcIjtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeShpbnB1dCk7XG4gICAgICAgICAgICBjb25zdCBzdGFtcCA9IGF3YWl0IHRoaXMuc3RhbXBlci5zdGFtcChib2R5KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgICAgICBzdGFtcDogc3RhbXAsXG4gICAgICAgICAgICAgICAgdXJsOiBmdWxsVXJsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3QgYWxsIFByaXZhdGUgS2V5IFRhZ3Mgd2l0aGluIGFuIE9yZ2FuaXphdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBTaWduIHRoZSBwcm92aWRlZCBgVExpc3RQcml2YXRlS2V5VGFnc0JvZHlgIHdpdGggdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24sIGFuZCBzdWJtaXQgdGhlIHJlcXVlc3QgKFBPU1QgL3B1YmxpYy92MS9xdWVyeS9saXN0X3ByaXZhdGVfa2V5X3RhZ3MpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgc3RhbXBMaXN0UHJpdmF0ZUtleVRhZ3N9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5saXN0UHJpdmF0ZUtleVRhZ3MgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoXCIvcHVibGljL3YxL3F1ZXJ5L2xpc3RfcHJpdmF0ZV9rZXlfdGFnc1wiLCBpbnB1dCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9kdWNlIGEgYFNpZ25lZFJlcXVlc3RgIGZyb20gYFRMaXN0UHJpdmF0ZUtleVRhZ3NCb2R5YCBieSB1c2luZyB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIExpc3RQcml2YXRlS2V5VGFnc30uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YW1wTGlzdFByaXZhdGVLZXlUYWdzID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmdWxsVXJsID0gdGhpcy5jb25maWcuYmFzZVVybCArIFwiL3B1YmxpYy92MS9xdWVyeS9saXN0X3ByaXZhdGVfa2V5X3RhZ3NcIjtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeShpbnB1dCk7XG4gICAgICAgICAgICBjb25zdCBzdGFtcCA9IGF3YWl0IHRoaXMuc3RhbXBlci5zdGFtcChib2R5KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgICAgICBzdGFtcDogc3RhbXAsXG4gICAgICAgICAgICAgICAgdXJsOiBmdWxsVXJsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3QgYWxsIFByaXZhdGUgS2V5cyB3aXRoaW4gYW4gT3JnYW5pemF0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIFNpZ24gdGhlIHByb3ZpZGVkIGBUR2V0UHJpdmF0ZUtleXNCb2R5YCB3aXRoIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLCBhbmQgc3VibWl0IHRoZSByZXF1ZXN0IChQT1NUIC9wdWJsaWMvdjEvcXVlcnkvbGlzdF9wcml2YXRlX2tleXMpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgc3RhbXBHZXRQcml2YXRlS2V5c30uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldFByaXZhdGVLZXlzID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KFwiL3B1YmxpYy92MS9xdWVyeS9saXN0X3ByaXZhdGVfa2V5c1wiLCBpbnB1dCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9kdWNlIGEgYFNpZ25lZFJlcXVlc3RgIGZyb20gYFRHZXRQcml2YXRlS2V5c0JvZHlgIGJ5IHVzaW5nIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgR2V0UHJpdmF0ZUtleXN9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFtcEdldFByaXZhdGVLZXlzID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmdWxsVXJsID0gdGhpcy5jb25maWcuYmFzZVVybCArIFwiL3B1YmxpYy92MS9xdWVyeS9saXN0X3ByaXZhdGVfa2V5c1wiO1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KGlucHV0KTtcbiAgICAgICAgICAgIGNvbnN0IHN0YW1wID0gYXdhaXQgdGhpcy5zdGFtcGVyLnN0YW1wKGJvZHkpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgICAgIHN0YW1wOiBzdGFtcCxcbiAgICAgICAgICAgICAgICB1cmw6IGZ1bGxVcmwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCBhbGwgVXNlciBUYWdzIHdpdGhpbiBhbiBPcmdhbml6YXRpb25cbiAgICAgICAgICpcbiAgICAgICAgICogU2lnbiB0aGUgcHJvdmlkZWQgYFRMaXN0VXNlclRhZ3NCb2R5YCB3aXRoIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLCBhbmQgc3VibWl0IHRoZSByZXF1ZXN0IChQT1NUIC9wdWJsaWMvdjEvcXVlcnkvbGlzdF91c2VyX3RhZ3MpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgc3RhbXBMaXN0VXNlclRhZ3N9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5saXN0VXNlclRhZ3MgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoXCIvcHVibGljL3YxL3F1ZXJ5L2xpc3RfdXNlcl90YWdzXCIsIGlucHV0KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb2R1Y2UgYSBgU2lnbmVkUmVxdWVzdGAgZnJvbSBgVExpc3RVc2VyVGFnc0JvZHlgIGJ5IHVzaW5nIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgTGlzdFVzZXJUYWdzfS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhbXBMaXN0VXNlclRhZ3MgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZ1bGxVcmwgPSB0aGlzLmNvbmZpZy5iYXNlVXJsICsgXCIvcHVibGljL3YxL3F1ZXJ5L2xpc3RfdXNlcl90YWdzXCI7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkoaW5wdXQpO1xuICAgICAgICAgICAgY29uc3Qgc3RhbXAgPSBhd2FpdCB0aGlzLnN0YW1wZXIuc3RhbXAoYm9keSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICAgICAgc3RhbXA6IHN0YW1wLFxuICAgICAgICAgICAgICAgIHVybDogZnVsbFVybCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IGFsbCBVc2VycyB3aXRoaW4gYW4gT3JnYW5pemF0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIFNpZ24gdGhlIHByb3ZpZGVkIGBUR2V0VXNlcnNCb2R5YCB3aXRoIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLCBhbmQgc3VibWl0IHRoZSByZXF1ZXN0IChQT1NUIC9wdWJsaWMvdjEvcXVlcnkvbGlzdF91c2VycykuXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBhbHNvIHtAbGluayBzdGFtcEdldFVzZXJzfS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0VXNlcnMgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoXCIvcHVibGljL3YxL3F1ZXJ5L2xpc3RfdXNlcnNcIiwgaW5wdXQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZHVjZSBhIGBTaWduZWRSZXF1ZXN0YCBmcm9tIGBUR2V0VXNlcnNCb2R5YCBieSB1c2luZyB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIEdldFVzZXJzfS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhbXBHZXRVc2VycyA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnVsbFVybCA9IHRoaXMuY29uZmlnLmJhc2VVcmwgKyBcIi9wdWJsaWMvdjEvcXVlcnkvbGlzdF91c2Vyc1wiO1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KGlucHV0KTtcbiAgICAgICAgICAgIGNvbnN0IHN0YW1wID0gYXdhaXQgdGhpcy5zdGFtcGVyLnN0YW1wKGJvZHkpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgICAgIHN0YW1wOiBzdGFtcCxcbiAgICAgICAgICAgICAgICB1cmw6IGZ1bGxVcmwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCBhbGwgQWNjb3VudHMgd2lyaGluIGEgV2FsbGV0XG4gICAgICAgICAqXG4gICAgICAgICAqIFNpZ24gdGhlIHByb3ZpZGVkIGBUR2V0V2FsbGV0QWNjb3VudHNCb2R5YCB3aXRoIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLCBhbmQgc3VibWl0IHRoZSByZXF1ZXN0IChQT1NUIC9wdWJsaWMvdjEvcXVlcnkvbGlzdF93YWxsZXRfYWNjb3VudHMpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgc3RhbXBHZXRXYWxsZXRBY2NvdW50c30uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldFdhbGxldEFjY291bnRzID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KFwiL3B1YmxpYy92MS9xdWVyeS9saXN0X3dhbGxldF9hY2NvdW50c1wiLCBpbnB1dCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9kdWNlIGEgYFNpZ25lZFJlcXVlc3RgIGZyb20gYFRHZXRXYWxsZXRBY2NvdW50c0JvZHlgIGJ5IHVzaW5nIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgR2V0V2FsbGV0QWNjb3VudHN9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFtcEdldFdhbGxldEFjY291bnRzID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmdWxsVXJsID0gdGhpcy5jb25maWcuYmFzZVVybCArIFwiL3B1YmxpYy92MS9xdWVyeS9saXN0X3dhbGxldF9hY2NvdW50c1wiO1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KGlucHV0KTtcbiAgICAgICAgICAgIGNvbnN0IHN0YW1wID0gYXdhaXQgdGhpcy5zdGFtcGVyLnN0YW1wKGJvZHkpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgICAgIHN0YW1wOiBzdGFtcCxcbiAgICAgICAgICAgICAgICB1cmw6IGZ1bGxVcmwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCBhbGwgV2FsbGV0cyB3aXRoaW4gYW4gT3JnYW5pemF0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIFNpZ24gdGhlIHByb3ZpZGVkIGBUR2V0V2FsbGV0c0JvZHlgIHdpdGggdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24sIGFuZCBzdWJtaXQgdGhlIHJlcXVlc3QgKFBPU1QgL3B1YmxpYy92MS9xdWVyeS9saXN0X3dhbGxldHMpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgc3RhbXBHZXRXYWxsZXRzfS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0V2FsbGV0cyA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChcIi9wdWJsaWMvdjEvcXVlcnkvbGlzdF93YWxsZXRzXCIsIGlucHV0KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb2R1Y2UgYSBgU2lnbmVkUmVxdWVzdGAgZnJvbSBgVEdldFdhbGxldHNCb2R5YCBieSB1c2luZyB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIEdldFdhbGxldHN9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFtcEdldFdhbGxldHMgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZ1bGxVcmwgPSB0aGlzLmNvbmZpZy5iYXNlVXJsICsgXCIvcHVibGljL3YxL3F1ZXJ5L2xpc3Rfd2FsbGV0c1wiO1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KGlucHV0KTtcbiAgICAgICAgICAgIGNvbnN0IHN0YW1wID0gYXdhaXQgdGhpcy5zdGFtcGVyLnN0YW1wKGJvZHkpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgICAgIHN0YW1wOiBzdGFtcCxcbiAgICAgICAgICAgICAgICB1cmw6IGZ1bGxVcmwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGJhc2ljIGluZm9ybWF0aW9uIGFib3V0IHlvdXIgY3VycmVudCBBUEkgb3IgV2ViQXV0aE4gdXNlciBhbmQgdGhlaXIgb3JnYW5pemF0aW9uLiBBZmZvcmRzIFN1Yi1Pcmdhbml6YXRpb24gbG9vayB1cHMgdmlhIFBhcmVudCBPcmdhbml6YXRpb24gZm9yIFdlYkF1dGhOIHVzZXJzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTaWduIHRoZSBwcm92aWRlZCBgVEdldFdob2FtaUJvZHlgIHdpdGggdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24sIGFuZCBzdWJtaXQgdGhlIHJlcXVlc3QgKFBPU1QgL3B1YmxpYy92MS9xdWVyeS93aG9hbWkpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgc3RhbXBHZXRXaG9hbWl9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZXRXaG9hbWkgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoXCIvcHVibGljL3YxL3F1ZXJ5L3dob2FtaVwiLCBpbnB1dCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9kdWNlIGEgYFNpZ25lZFJlcXVlc3RgIGZyb20gYFRHZXRXaG9hbWlCb2R5YCBieSB1c2luZyB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIEdldFdob2FtaX0uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YW1wR2V0V2hvYW1pID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmdWxsVXJsID0gdGhpcy5jb25maWcuYmFzZVVybCArIFwiL3B1YmxpYy92MS9xdWVyeS93aG9hbWlcIjtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeShpbnB1dCk7XG4gICAgICAgICAgICBjb25zdCBzdGFtcCA9IGF3YWl0IHRoaXMuc3RhbXBlci5zdGFtcChib2R5KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgICAgICBzdGFtcDogc3RhbXAsXG4gICAgICAgICAgICAgICAgdXJsOiBmdWxsVXJsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFwcHJvdmUgYW4gQWN0aXZpdHlcbiAgICAgICAgICpcbiAgICAgICAgICogU2lnbiB0aGUgcHJvdmlkZWQgYFRBcHByb3ZlQWN0aXZpdHlCb2R5YCB3aXRoIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLCBhbmQgc3VibWl0IHRoZSByZXF1ZXN0IChQT1NUIC9wdWJsaWMvdjEvc3VibWl0L2FwcHJvdmVfYWN0aXZpdHkpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgc3RhbXBBcHByb3ZlQWN0aXZpdHl9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hcHByb3ZlQWN0aXZpdHkgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoXCIvcHVibGljL3YxL3N1Ym1pdC9hcHByb3ZlX2FjdGl2aXR5XCIsIGlucHV0KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb2R1Y2UgYSBgU2lnbmVkUmVxdWVzdGAgZnJvbSBgVEFwcHJvdmVBY3Rpdml0eUJvZHlgIGJ5IHVzaW5nIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgQXBwcm92ZUFjdGl2aXR5fS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhbXBBcHByb3ZlQWN0aXZpdHkgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZ1bGxVcmwgPSB0aGlzLmNvbmZpZy5iYXNlVXJsICsgXCIvcHVibGljL3YxL3N1Ym1pdC9hcHByb3ZlX2FjdGl2aXR5XCI7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkoaW5wdXQpO1xuICAgICAgICAgICAgY29uc3Qgc3RhbXAgPSBhd2FpdCB0aGlzLnN0YW1wZXIuc3RhbXAoYm9keSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICAgICAgc3RhbXA6IHN0YW1wLFxuICAgICAgICAgICAgICAgIHVybDogZnVsbFVybCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgYXBpIGtleXMgdG8gYW4gZXhpc3RpbmcgVXNlclxuICAgICAgICAgKlxuICAgICAgICAgKiBTaWduIHRoZSBwcm92aWRlZCBgVENyZWF0ZUFwaUtleXNCb2R5YCB3aXRoIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLCBhbmQgc3VibWl0IHRoZSByZXF1ZXN0IChQT1NUIC9wdWJsaWMvdjEvc3VibWl0L2NyZWF0ZV9hcGlfa2V5cykuXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBhbHNvIHtAbGluayBzdGFtcENyZWF0ZUFwaUtleXN9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jcmVhdGVBcGlLZXlzID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KFwiL3B1YmxpYy92MS9zdWJtaXQvY3JlYXRlX2FwaV9rZXlzXCIsIGlucHV0KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb2R1Y2UgYSBgU2lnbmVkUmVxdWVzdGAgZnJvbSBgVENyZWF0ZUFwaUtleXNCb2R5YCBieSB1c2luZyB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIENyZWF0ZUFwaUtleXN9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFtcENyZWF0ZUFwaUtleXMgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZ1bGxVcmwgPSB0aGlzLmNvbmZpZy5iYXNlVXJsICsgXCIvcHVibGljL3YxL3N1Ym1pdC9jcmVhdGVfYXBpX2tleXNcIjtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeShpbnB1dCk7XG4gICAgICAgICAgICBjb25zdCBzdGFtcCA9IGF3YWl0IHRoaXMuc3RhbXBlci5zdGFtcChib2R5KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgICAgICBzdGFtcDogc3RhbXAsXG4gICAgICAgICAgICAgICAgdXJsOiBmdWxsVXJsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBBUEktb25seSBVc2VycyBpbiBhbiBleGlzdGluZyBPcmdhbml6YXRpb25cbiAgICAgICAgICpcbiAgICAgICAgICogU2lnbiB0aGUgcHJvdmlkZWQgYFRDcmVhdGVBcGlPbmx5VXNlcnNCb2R5YCB3aXRoIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLCBhbmQgc3VibWl0IHRoZSByZXF1ZXN0IChQT1NUIC9wdWJsaWMvdjEvc3VibWl0L2NyZWF0ZV9hcGlfb25seV91c2VycykuXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBhbHNvIHtAbGluayBzdGFtcENyZWF0ZUFwaU9ubHlVc2Vyc30uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNyZWF0ZUFwaU9ubHlVc2VycyA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChcIi9wdWJsaWMvdjEvc3VibWl0L2NyZWF0ZV9hcGlfb25seV91c2Vyc1wiLCBpbnB1dCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9kdWNlIGEgYFNpZ25lZFJlcXVlc3RgIGZyb20gYFRDcmVhdGVBcGlPbmx5VXNlcnNCb2R5YCBieSB1c2luZyB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIENyZWF0ZUFwaU9ubHlVc2Vyc30uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YW1wQ3JlYXRlQXBpT25seVVzZXJzID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmdWxsVXJsID0gdGhpcy5jb25maWcuYmFzZVVybCArIFwiL3B1YmxpYy92MS9zdWJtaXQvY3JlYXRlX2FwaV9vbmx5X3VzZXJzXCI7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkoaW5wdXQpO1xuICAgICAgICAgICAgY29uc3Qgc3RhbXAgPSBhd2FpdCB0aGlzLnN0YW1wZXIuc3RhbXAoYm9keSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICAgICAgc3RhbXA6IHN0YW1wLFxuICAgICAgICAgICAgICAgIHVybDogZnVsbFVybCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgQXV0aGVudGljYXRvcnMgdG8gYXV0aGVudGljYXRlIHJlcXVlc3RzIHRvIFR1cm5rZXlcbiAgICAgICAgICpcbiAgICAgICAgICogU2lnbiB0aGUgcHJvdmlkZWQgYFRDcmVhdGVBdXRoZW50aWNhdG9yc0JvZHlgIHdpdGggdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24sIGFuZCBzdWJtaXQgdGhlIHJlcXVlc3QgKFBPU1QgL3B1YmxpYy92MS9zdWJtaXQvY3JlYXRlX2F1dGhlbnRpY2F0b3JzKS5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIHN0YW1wQ3JlYXRlQXV0aGVudGljYXRvcnN9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jcmVhdGVBdXRoZW50aWNhdG9ycyA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChcIi9wdWJsaWMvdjEvc3VibWl0L2NyZWF0ZV9hdXRoZW50aWNhdG9yc1wiLCBpbnB1dCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9kdWNlIGEgYFNpZ25lZFJlcXVlc3RgIGZyb20gYFRDcmVhdGVBdXRoZW50aWNhdG9yc0JvZHlgIGJ5IHVzaW5nIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgQ3JlYXRlQXV0aGVudGljYXRvcnN9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFtcENyZWF0ZUF1dGhlbnRpY2F0b3JzID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmdWxsVXJsID0gdGhpcy5jb25maWcuYmFzZVVybCArIFwiL3B1YmxpYy92MS9zdWJtaXQvY3JlYXRlX2F1dGhlbnRpY2F0b3JzXCI7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkoaW5wdXQpO1xuICAgICAgICAgICAgY29uc3Qgc3RhbXAgPSBhd2FpdCB0aGlzLnN0YW1wZXIuc3RhbXAoYm9keSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICAgICAgc3RhbXA6IHN0YW1wLFxuICAgICAgICAgICAgICAgIHVybDogZnVsbFVybCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgSW52aXRhdGlvbnMgdG8gam9pbiBhbiBleGlzdGluZyBPcmdhbml6YXRpb25cbiAgICAgICAgICpcbiAgICAgICAgICogU2lnbiB0aGUgcHJvdmlkZWQgYFRDcmVhdGVJbnZpdGF0aW9uc0JvZHlgIHdpdGggdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24sIGFuZCBzdWJtaXQgdGhlIHJlcXVlc3QgKFBPU1QgL3B1YmxpYy92MS9zdWJtaXQvY3JlYXRlX2ludml0YXRpb25zKS5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIHN0YW1wQ3JlYXRlSW52aXRhdGlvbnN9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jcmVhdGVJbnZpdGF0aW9ucyA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChcIi9wdWJsaWMvdjEvc3VibWl0L2NyZWF0ZV9pbnZpdGF0aW9uc1wiLCBpbnB1dCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9kdWNlIGEgYFNpZ25lZFJlcXVlc3RgIGZyb20gYFRDcmVhdGVJbnZpdGF0aW9uc0JvZHlgIGJ5IHVzaW5nIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgQ3JlYXRlSW52aXRhdGlvbnN9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFtcENyZWF0ZUludml0YXRpb25zID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmdWxsVXJsID0gdGhpcy5jb25maWcuYmFzZVVybCArIFwiL3B1YmxpYy92MS9zdWJtaXQvY3JlYXRlX2ludml0YXRpb25zXCI7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkoaW5wdXQpO1xuICAgICAgICAgICAgY29uc3Qgc3RhbXAgPSBhd2FpdCB0aGlzLnN0YW1wZXIuc3RhbXAoYm9keSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICAgICAgc3RhbXA6IHN0YW1wLFxuICAgICAgICAgICAgICAgIHVybDogZnVsbFVybCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBuZXcgUG9saWN5XG4gICAgICAgICAqXG4gICAgICAgICAqIFNpZ24gdGhlIHByb3ZpZGVkIGBUQ3JlYXRlUG9saWN5Qm9keWAgd2l0aCB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbiwgYW5kIHN1Ym1pdCB0aGUgcmVxdWVzdCAoUE9TVCAvcHVibGljL3YxL3N1Ym1pdC9jcmVhdGVfcG9saWN5KS5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIHN0YW1wQ3JlYXRlUG9saWN5fS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY3JlYXRlUG9saWN5ID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KFwiL3B1YmxpYy92MS9zdWJtaXQvY3JlYXRlX3BvbGljeVwiLCBpbnB1dCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9kdWNlIGEgYFNpZ25lZFJlcXVlc3RgIGZyb20gYFRDcmVhdGVQb2xpY3lCb2R5YCBieSB1c2luZyB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIENyZWF0ZVBvbGljeX0uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YW1wQ3JlYXRlUG9saWN5ID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmdWxsVXJsID0gdGhpcy5jb25maWcuYmFzZVVybCArIFwiL3B1YmxpYy92MS9zdWJtaXQvY3JlYXRlX3BvbGljeVwiO1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KGlucHV0KTtcbiAgICAgICAgICAgIGNvbnN0IHN0YW1wID0gYXdhaXQgdGhpcy5zdGFtcGVyLnN0YW1wKGJvZHkpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgICAgIHN0YW1wOiBzdGFtcCxcbiAgICAgICAgICAgICAgICB1cmw6IGZ1bGxVcmwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgcHJpdmF0ZSBrZXkgdGFnIGFuZCBhZGQgaXQgdG8gcHJpdmF0ZSBrZXlzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTaWduIHRoZSBwcm92aWRlZCBgVENyZWF0ZVByaXZhdGVLZXlUYWdCb2R5YCB3aXRoIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLCBhbmQgc3VibWl0IHRoZSByZXF1ZXN0IChQT1NUIC9wdWJsaWMvdjEvc3VibWl0L2NyZWF0ZV9wcml2YXRlX2tleV90YWcpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgc3RhbXBDcmVhdGVQcml2YXRlS2V5VGFnfS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY3JlYXRlUHJpdmF0ZUtleVRhZyA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChcIi9wdWJsaWMvdjEvc3VibWl0L2NyZWF0ZV9wcml2YXRlX2tleV90YWdcIiwgaW5wdXQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZHVjZSBhIGBTaWduZWRSZXF1ZXN0YCBmcm9tIGBUQ3JlYXRlUHJpdmF0ZUtleVRhZ0JvZHlgIGJ5IHVzaW5nIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgQ3JlYXRlUHJpdmF0ZUtleVRhZ30uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YW1wQ3JlYXRlUHJpdmF0ZUtleVRhZyA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnVsbFVybCA9IHRoaXMuY29uZmlnLmJhc2VVcmwgKyBcIi9wdWJsaWMvdjEvc3VibWl0L2NyZWF0ZV9wcml2YXRlX2tleV90YWdcIjtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeShpbnB1dCk7XG4gICAgICAgICAgICBjb25zdCBzdGFtcCA9IGF3YWl0IHRoaXMuc3RhbXBlci5zdGFtcChib2R5KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgICAgICBzdGFtcDogc3RhbXAsXG4gICAgICAgICAgICAgICAgdXJsOiBmdWxsVXJsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBuZXcgUHJpdmF0ZSBLZXlzXG4gICAgICAgICAqXG4gICAgICAgICAqIFNpZ24gdGhlIHByb3ZpZGVkIGBUQ3JlYXRlUHJpdmF0ZUtleXNCb2R5YCB3aXRoIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLCBhbmQgc3VibWl0IHRoZSByZXF1ZXN0IChQT1NUIC9wdWJsaWMvdjEvc3VibWl0L2NyZWF0ZV9wcml2YXRlX2tleXMpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgc3RhbXBDcmVhdGVQcml2YXRlS2V5c30uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNyZWF0ZVByaXZhdGVLZXlzID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KFwiL3B1YmxpYy92MS9zdWJtaXQvY3JlYXRlX3ByaXZhdGVfa2V5c1wiLCBpbnB1dCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9kdWNlIGEgYFNpZ25lZFJlcXVlc3RgIGZyb20gYFRDcmVhdGVQcml2YXRlS2V5c0JvZHlgIGJ5IHVzaW5nIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgQ3JlYXRlUHJpdmF0ZUtleXN9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFtcENyZWF0ZVByaXZhdGVLZXlzID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmdWxsVXJsID0gdGhpcy5jb25maWcuYmFzZVVybCArIFwiL3B1YmxpYy92MS9zdWJtaXQvY3JlYXRlX3ByaXZhdGVfa2V5c1wiO1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KGlucHV0KTtcbiAgICAgICAgICAgIGNvbnN0IHN0YW1wID0gYXdhaXQgdGhpcy5zdGFtcGVyLnN0YW1wKGJvZHkpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgICAgIHN0YW1wOiBzdGFtcCxcbiAgICAgICAgICAgICAgICB1cmw6IGZ1bGxVcmwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgbmV3IFN1Yi1Pcmdhbml6YXRpb25cbiAgICAgICAgICpcbiAgICAgICAgICogU2lnbiB0aGUgcHJvdmlkZWQgYFRDcmVhdGVTdWJPcmdhbml6YXRpb25Cb2R5YCB3aXRoIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLCBhbmQgc3VibWl0IHRoZSByZXF1ZXN0IChQT1NUIC9wdWJsaWMvdjEvc3VibWl0L2NyZWF0ZV9zdWJfb3JnYW5pemF0aW9uKS5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIHN0YW1wQ3JlYXRlU3ViT3JnYW5pemF0aW9ufS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY3JlYXRlU3ViT3JnYW5pemF0aW9uID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KFwiL3B1YmxpYy92MS9zdWJtaXQvY3JlYXRlX3N1Yl9vcmdhbml6YXRpb25cIiwgaW5wdXQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZHVjZSBhIGBTaWduZWRSZXF1ZXN0YCBmcm9tIGBUQ3JlYXRlU3ViT3JnYW5pemF0aW9uQm9keWAgYnkgdXNpbmcgdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBhbHNvIHtAbGluayBDcmVhdGVTdWJPcmdhbml6YXRpb259LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFtcENyZWF0ZVN1Yk9yZ2FuaXphdGlvbiA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnVsbFVybCA9IHRoaXMuY29uZmlnLmJhc2VVcmwgKyBcIi9wdWJsaWMvdjEvc3VibWl0L2NyZWF0ZV9zdWJfb3JnYW5pemF0aW9uXCI7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkoaW5wdXQpO1xuICAgICAgICAgICAgY29uc3Qgc3RhbXAgPSBhd2FpdCB0aGlzLnN0YW1wZXIuc3RhbXAoYm9keSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICAgICAgc3RhbXA6IHN0YW1wLFxuICAgICAgICAgICAgICAgIHVybDogZnVsbFVybCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSB1c2VyIHRhZyBhbmQgYWRkIGl0IHRvIHVzZXJzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTaWduIHRoZSBwcm92aWRlZCBgVENyZWF0ZVVzZXJUYWdCb2R5YCB3aXRoIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLCBhbmQgc3VibWl0IHRoZSByZXF1ZXN0IChQT1NUIC9wdWJsaWMvdjEvc3VibWl0L2NyZWF0ZV91c2VyX3RhZykuXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBhbHNvIHtAbGluayBzdGFtcENyZWF0ZVVzZXJUYWd9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jcmVhdGVVc2VyVGFnID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KFwiL3B1YmxpYy92MS9zdWJtaXQvY3JlYXRlX3VzZXJfdGFnXCIsIGlucHV0KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb2R1Y2UgYSBgU2lnbmVkUmVxdWVzdGAgZnJvbSBgVENyZWF0ZVVzZXJUYWdCb2R5YCBieSB1c2luZyB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIENyZWF0ZVVzZXJUYWd9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFtcENyZWF0ZVVzZXJUYWcgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZ1bGxVcmwgPSB0aGlzLmNvbmZpZy5iYXNlVXJsICsgXCIvcHVibGljL3YxL3N1Ym1pdC9jcmVhdGVfdXNlcl90YWdcIjtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeShpbnB1dCk7XG4gICAgICAgICAgICBjb25zdCBzdGFtcCA9IGF3YWl0IHRoaXMuc3RhbXBlci5zdGFtcChib2R5KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgICAgICBzdGFtcDogc3RhbXAsXG4gICAgICAgICAgICAgICAgdXJsOiBmdWxsVXJsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBVc2VycyBpbiBhbiBleGlzdGluZyBPcmdhbml6YXRpb25cbiAgICAgICAgICpcbiAgICAgICAgICogU2lnbiB0aGUgcHJvdmlkZWQgYFRDcmVhdGVVc2Vyc0JvZHlgIHdpdGggdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24sIGFuZCBzdWJtaXQgdGhlIHJlcXVlc3QgKFBPU1QgL3B1YmxpYy92MS9zdWJtaXQvY3JlYXRlX3VzZXJzKS5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIHN0YW1wQ3JlYXRlVXNlcnN9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jcmVhdGVVc2VycyA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChcIi9wdWJsaWMvdjEvc3VibWl0L2NyZWF0ZV91c2Vyc1wiLCBpbnB1dCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9kdWNlIGEgYFNpZ25lZFJlcXVlc3RgIGZyb20gYFRDcmVhdGVVc2Vyc0JvZHlgIGJ5IHVzaW5nIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgQ3JlYXRlVXNlcnN9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFtcENyZWF0ZVVzZXJzID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmdWxsVXJsID0gdGhpcy5jb25maWcuYmFzZVVybCArIFwiL3B1YmxpYy92MS9zdWJtaXQvY3JlYXRlX3VzZXJzXCI7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkoaW5wdXQpO1xuICAgICAgICAgICAgY29uc3Qgc3RhbXAgPSBhd2FpdCB0aGlzLnN0YW1wZXIuc3RhbXAoYm9keSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICAgICAgc3RhbXA6IHN0YW1wLFxuICAgICAgICAgICAgICAgIHVybDogZnVsbFVybCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBXYWxsZXQgYW5kIGRlcml2ZSBhZGRyZXNzZXNcbiAgICAgICAgICpcbiAgICAgICAgICogU2lnbiB0aGUgcHJvdmlkZWQgYFRDcmVhdGVXYWxsZXRCb2R5YCB3aXRoIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLCBhbmQgc3VibWl0IHRoZSByZXF1ZXN0IChQT1NUIC9wdWJsaWMvdjEvc3VibWl0L2NyZWF0ZV93YWxsZXQpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgc3RhbXBDcmVhdGVXYWxsZXR9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jcmVhdGVXYWxsZXQgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoXCIvcHVibGljL3YxL3N1Ym1pdC9jcmVhdGVfd2FsbGV0XCIsIGlucHV0KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb2R1Y2UgYSBgU2lnbmVkUmVxdWVzdGAgZnJvbSBgVENyZWF0ZVdhbGxldEJvZHlgIGJ5IHVzaW5nIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgQ3JlYXRlV2FsbGV0fS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhbXBDcmVhdGVXYWxsZXQgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZ1bGxVcmwgPSB0aGlzLmNvbmZpZy5iYXNlVXJsICsgXCIvcHVibGljL3YxL3N1Ym1pdC9jcmVhdGVfd2FsbGV0XCI7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkoaW5wdXQpO1xuICAgICAgICAgICAgY29uc3Qgc3RhbXAgPSBhd2FpdCB0aGlzLnN0YW1wZXIuc3RhbXAoYm9keSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICAgICAgc3RhbXA6IHN0YW1wLFxuICAgICAgICAgICAgICAgIHVybDogZnVsbFVybCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXJpdmUgYWRkaXRpb25hbCBhZGRyZXNzZXMgdXNpbmcgYW4gZXhpc3Rpbmcgd2FsbGV0XG4gICAgICAgICAqXG4gICAgICAgICAqIFNpZ24gdGhlIHByb3ZpZGVkIGBUQ3JlYXRlV2FsbGV0QWNjb3VudHNCb2R5YCB3aXRoIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLCBhbmQgc3VibWl0IHRoZSByZXF1ZXN0IChQT1NUIC9wdWJsaWMvdjEvc3VibWl0L2NyZWF0ZV93YWxsZXRfYWNjb3VudHMpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgc3RhbXBDcmVhdGVXYWxsZXRBY2NvdW50c30uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNyZWF0ZVdhbGxldEFjY291bnRzID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KFwiL3B1YmxpYy92MS9zdWJtaXQvY3JlYXRlX3dhbGxldF9hY2NvdW50c1wiLCBpbnB1dCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9kdWNlIGEgYFNpZ25lZFJlcXVlc3RgIGZyb20gYFRDcmVhdGVXYWxsZXRBY2NvdW50c0JvZHlgIGJ5IHVzaW5nIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgQ3JlYXRlV2FsbGV0QWNjb3VudHN9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFtcENyZWF0ZVdhbGxldEFjY291bnRzID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmdWxsVXJsID0gdGhpcy5jb25maWcuYmFzZVVybCArIFwiL3B1YmxpYy92MS9zdWJtaXQvY3JlYXRlX3dhbGxldF9hY2NvdW50c1wiO1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KGlucHV0KTtcbiAgICAgICAgICAgIGNvbnN0IHN0YW1wID0gYXdhaXQgdGhpcy5zdGFtcGVyLnN0YW1wKGJvZHkpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgICAgIHN0YW1wOiBzdGFtcCxcbiAgICAgICAgICAgICAgICB1cmw6IGZ1bGxVcmwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlIGFwaSBrZXlzIGZyb20gYSBVc2VyXG4gICAgICAgICAqXG4gICAgICAgICAqIFNpZ24gdGhlIHByb3ZpZGVkIGBURGVsZXRlQXBpS2V5c0JvZHlgIHdpdGggdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24sIGFuZCBzdWJtaXQgdGhlIHJlcXVlc3QgKFBPU1QgL3B1YmxpYy92MS9zdWJtaXQvZGVsZXRlX2FwaV9rZXlzKS5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIHN0YW1wRGVsZXRlQXBpS2V5c30uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRlbGV0ZUFwaUtleXMgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoXCIvcHVibGljL3YxL3N1Ym1pdC9kZWxldGVfYXBpX2tleXNcIiwgaW5wdXQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZHVjZSBhIGBTaWduZWRSZXF1ZXN0YCBmcm9tIGBURGVsZXRlQXBpS2V5c0JvZHlgIGJ5IHVzaW5nIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgRGVsZXRlQXBpS2V5c30uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YW1wRGVsZXRlQXBpS2V5cyA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnVsbFVybCA9IHRoaXMuY29uZmlnLmJhc2VVcmwgKyBcIi9wdWJsaWMvdjEvc3VibWl0L2RlbGV0ZV9hcGlfa2V5c1wiO1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KGlucHV0KTtcbiAgICAgICAgICAgIGNvbnN0IHN0YW1wID0gYXdhaXQgdGhpcy5zdGFtcGVyLnN0YW1wKGJvZHkpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgICAgIHN0YW1wOiBzdGFtcCxcbiAgICAgICAgICAgICAgICB1cmw6IGZ1bGxVcmwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlIGF1dGhlbnRpY2F0b3JzIGZyb20gYSBVc2VyXG4gICAgICAgICAqXG4gICAgICAgICAqIFNpZ24gdGhlIHByb3ZpZGVkIGBURGVsZXRlQXV0aGVudGljYXRvcnNCb2R5YCB3aXRoIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLCBhbmQgc3VibWl0IHRoZSByZXF1ZXN0IChQT1NUIC9wdWJsaWMvdjEvc3VibWl0L2RlbGV0ZV9hdXRoZW50aWNhdG9ycykuXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBhbHNvIHtAbGluayBzdGFtcERlbGV0ZUF1dGhlbnRpY2F0b3JzfS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGVsZXRlQXV0aGVudGljYXRvcnMgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoXCIvcHVibGljL3YxL3N1Ym1pdC9kZWxldGVfYXV0aGVudGljYXRvcnNcIiwgaW5wdXQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZHVjZSBhIGBTaWduZWRSZXF1ZXN0YCBmcm9tIGBURGVsZXRlQXV0aGVudGljYXRvcnNCb2R5YCBieSB1c2luZyB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIERlbGV0ZUF1dGhlbnRpY2F0b3JzfS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhbXBEZWxldGVBdXRoZW50aWNhdG9ycyA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnVsbFVybCA9IHRoaXMuY29uZmlnLmJhc2VVcmwgKyBcIi9wdWJsaWMvdjEvc3VibWl0L2RlbGV0ZV9hdXRoZW50aWNhdG9yc1wiO1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KGlucHV0KTtcbiAgICAgICAgICAgIGNvbnN0IHN0YW1wID0gYXdhaXQgdGhpcy5zdGFtcGVyLnN0YW1wKGJvZHkpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgICAgIHN0YW1wOiBzdGFtcCxcbiAgICAgICAgICAgICAgICB1cmw6IGZ1bGxVcmwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVsZXRlIGFuIGV4aXN0aW5nIEludml0YXRpb25cbiAgICAgICAgICpcbiAgICAgICAgICogU2lnbiB0aGUgcHJvdmlkZWQgYFREZWxldGVJbnZpdGF0aW9uQm9keWAgd2l0aCB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbiwgYW5kIHN1Ym1pdCB0aGUgcmVxdWVzdCAoUE9TVCAvcHVibGljL3YxL3N1Ym1pdC9kZWxldGVfaW52aXRhdGlvbikuXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBhbHNvIHtAbGluayBzdGFtcERlbGV0ZUludml0YXRpb259LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kZWxldGVJbnZpdGF0aW9uID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KFwiL3B1YmxpYy92MS9zdWJtaXQvZGVsZXRlX2ludml0YXRpb25cIiwgaW5wdXQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZHVjZSBhIGBTaWduZWRSZXF1ZXN0YCBmcm9tIGBURGVsZXRlSW52aXRhdGlvbkJvZHlgIGJ5IHVzaW5nIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgRGVsZXRlSW52aXRhdGlvbn0uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YW1wRGVsZXRlSW52aXRhdGlvbiA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnVsbFVybCA9IHRoaXMuY29uZmlnLmJhc2VVcmwgKyBcIi9wdWJsaWMvdjEvc3VibWl0L2RlbGV0ZV9pbnZpdGF0aW9uXCI7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkoaW5wdXQpO1xuICAgICAgICAgICAgY29uc3Qgc3RhbXAgPSBhd2FpdCB0aGlzLnN0YW1wZXIuc3RhbXAoYm9keSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICAgICAgc3RhbXA6IHN0YW1wLFxuICAgICAgICAgICAgICAgIHVybDogZnVsbFVybCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWxldGUgYW4gZXhpc3RpbmcgUG9saWN5XG4gICAgICAgICAqXG4gICAgICAgICAqIFNpZ24gdGhlIHByb3ZpZGVkIGBURGVsZXRlUG9saWN5Qm9keWAgd2l0aCB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbiwgYW5kIHN1Ym1pdCB0aGUgcmVxdWVzdCAoUE9TVCAvcHVibGljL3YxL3N1Ym1pdC9kZWxldGVfcG9saWN5KS5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIHN0YW1wRGVsZXRlUG9saWN5fS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGVsZXRlUG9saWN5ID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KFwiL3B1YmxpYy92MS9zdWJtaXQvZGVsZXRlX3BvbGljeVwiLCBpbnB1dCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9kdWNlIGEgYFNpZ25lZFJlcXVlc3RgIGZyb20gYFREZWxldGVQb2xpY3lCb2R5YCBieSB1c2luZyB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIERlbGV0ZVBvbGljeX0uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YW1wRGVsZXRlUG9saWN5ID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmdWxsVXJsID0gdGhpcy5jb25maWcuYmFzZVVybCArIFwiL3B1YmxpYy92MS9zdWJtaXQvZGVsZXRlX3BvbGljeVwiO1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KGlucHV0KTtcbiAgICAgICAgICAgIGNvbnN0IHN0YW1wID0gYXdhaXQgdGhpcy5zdGFtcGVyLnN0YW1wKGJvZHkpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgICAgIHN0YW1wOiBzdGFtcCxcbiAgICAgICAgICAgICAgICB1cmw6IGZ1bGxVcmwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQXV0aGVudGljYXRlIGEgdXNlciB2aWEgRW1haWxcbiAgICAgICAgICpcbiAgICAgICAgICogU2lnbiB0aGUgcHJvdmlkZWQgYFRFbWFpbEF1dGhCb2R5YCB3aXRoIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLCBhbmQgc3VibWl0IHRoZSByZXF1ZXN0IChQT1NUIC9wdWJsaWMvdjEvc3VibWl0L2VtYWlsX2F1dGgpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgc3RhbXBFbWFpbEF1dGh9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lbWFpbEF1dGggPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoXCIvcHVibGljL3YxL3N1Ym1pdC9lbWFpbF9hdXRoXCIsIGlucHV0KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb2R1Y2UgYSBgU2lnbmVkUmVxdWVzdGAgZnJvbSBgVEVtYWlsQXV0aEJvZHlgIGJ5IHVzaW5nIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgRW1haWxBdXRofS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhbXBFbWFpbEF1dGggPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZ1bGxVcmwgPSB0aGlzLmNvbmZpZy5iYXNlVXJsICsgXCIvcHVibGljL3YxL3N1Ym1pdC9lbWFpbF9hdXRoXCI7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkoaW5wdXQpO1xuICAgICAgICAgICAgY29uc3Qgc3RhbXAgPSBhd2FpdCB0aGlzLnN0YW1wZXIuc3RhbXAoYm9keSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICAgICAgc3RhbXA6IHN0YW1wLFxuICAgICAgICAgICAgICAgIHVybDogZnVsbFVybCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFeHBvcnRzIGEgUHJpdmF0ZSBLZXlcbiAgICAgICAgICpcbiAgICAgICAgICogU2lnbiB0aGUgcHJvdmlkZWQgYFRFeHBvcnRQcml2YXRlS2V5Qm9keWAgd2l0aCB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbiwgYW5kIHN1Ym1pdCB0aGUgcmVxdWVzdCAoUE9TVCAvcHVibGljL3YxL3N1Ym1pdC9leHBvcnRfcHJpdmF0ZV9rZXkpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgc3RhbXBFeHBvcnRQcml2YXRlS2V5fS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZXhwb3J0UHJpdmF0ZUtleSA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChcIi9wdWJsaWMvdjEvc3VibWl0L2V4cG9ydF9wcml2YXRlX2tleVwiLCBpbnB1dCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9kdWNlIGEgYFNpZ25lZFJlcXVlc3RgIGZyb20gYFRFeHBvcnRQcml2YXRlS2V5Qm9keWAgYnkgdXNpbmcgdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBhbHNvIHtAbGluayBFeHBvcnRQcml2YXRlS2V5fS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhbXBFeHBvcnRQcml2YXRlS2V5ID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmdWxsVXJsID0gdGhpcy5jb25maWcuYmFzZVVybCArIFwiL3B1YmxpYy92MS9zdWJtaXQvZXhwb3J0X3ByaXZhdGVfa2V5XCI7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkoaW5wdXQpO1xuICAgICAgICAgICAgY29uc3Qgc3RhbXAgPSBhd2FpdCB0aGlzLnN0YW1wZXIuc3RhbXAoYm9keSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICAgICAgc3RhbXA6IHN0YW1wLFxuICAgICAgICAgICAgICAgIHVybDogZnVsbFVybCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFeHBvcnRzIGEgV2FsbGV0XG4gICAgICAgICAqXG4gICAgICAgICAqIFNpZ24gdGhlIHByb3ZpZGVkIGBURXhwb3J0V2FsbGV0Qm9keWAgd2l0aCB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbiwgYW5kIHN1Ym1pdCB0aGUgcmVxdWVzdCAoUE9TVCAvcHVibGljL3YxL3N1Ym1pdC9leHBvcnRfd2FsbGV0KS5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIHN0YW1wRXhwb3J0V2FsbGV0fS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZXhwb3J0V2FsbGV0ID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KFwiL3B1YmxpYy92MS9zdWJtaXQvZXhwb3J0X3dhbGxldFwiLCBpbnB1dCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9kdWNlIGEgYFNpZ25lZFJlcXVlc3RgIGZyb20gYFRFeHBvcnRXYWxsZXRCb2R5YCBieSB1c2luZyB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIEV4cG9ydFdhbGxldH0uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YW1wRXhwb3J0V2FsbGV0ID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmdWxsVXJsID0gdGhpcy5jb25maWcuYmFzZVVybCArIFwiL3B1YmxpYy92MS9zdWJtaXQvZXhwb3J0X3dhbGxldFwiO1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KGlucHV0KTtcbiAgICAgICAgICAgIGNvbnN0IHN0YW1wID0gYXdhaXQgdGhpcy5zdGFtcGVyLnN0YW1wKGJvZHkpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgICAgIHN0YW1wOiBzdGFtcCxcbiAgICAgICAgICAgICAgICB1cmw6IGZ1bGxVcmwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRXhwb3J0cyBhIFdhbGxldCBBY2NvdW50XG4gICAgICAgICAqXG4gICAgICAgICAqIFNpZ24gdGhlIHByb3ZpZGVkIGBURXhwb3J0V2FsbGV0QWNjb3VudEJvZHlgIHdpdGggdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24sIGFuZCBzdWJtaXQgdGhlIHJlcXVlc3QgKFBPU1QgL3B1YmxpYy92MS9zdWJtaXQvZXhwb3J0X3dhbGxldF9hY2NvdW50KS5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIHN0YW1wRXhwb3J0V2FsbGV0QWNjb3VudH0uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmV4cG9ydFdhbGxldEFjY291bnQgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoXCIvcHVibGljL3YxL3N1Ym1pdC9leHBvcnRfd2FsbGV0X2FjY291bnRcIiwgaW5wdXQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZHVjZSBhIGBTaWduZWRSZXF1ZXN0YCBmcm9tIGBURXhwb3J0V2FsbGV0QWNjb3VudEJvZHlgIGJ5IHVzaW5nIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgRXhwb3J0V2FsbGV0QWNjb3VudH0uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YW1wRXhwb3J0V2FsbGV0QWNjb3VudCA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnVsbFVybCA9IHRoaXMuY29uZmlnLmJhc2VVcmwgKyBcIi9wdWJsaWMvdjEvc3VibWl0L2V4cG9ydF93YWxsZXRfYWNjb3VudFwiO1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KGlucHV0KTtcbiAgICAgICAgICAgIGNvbnN0IHN0YW1wID0gYXdhaXQgdGhpcy5zdGFtcGVyLnN0YW1wKGJvZHkpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgICAgIHN0YW1wOiBzdGFtcCxcbiAgICAgICAgICAgICAgICB1cmw6IGZ1bGxVcmwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXcgZW1haWwgcmVjb3ZlcnlcbiAgICAgICAgICpcbiAgICAgICAgICogU2lnbiB0aGUgcHJvdmlkZWQgYFRJbml0VXNlckVtYWlsUmVjb3ZlcnlCb2R5YCB3aXRoIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLCBhbmQgc3VibWl0IHRoZSByZXF1ZXN0IChQT1NUIC9wdWJsaWMvdjEvc3VibWl0L2luaXRfdXNlcl9lbWFpbF9yZWNvdmVyeSkuXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBhbHNvIHtAbGluayBzdGFtcEluaXRVc2VyRW1haWxSZWNvdmVyeX0uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmluaXRVc2VyRW1haWxSZWNvdmVyeSA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChcIi9wdWJsaWMvdjEvc3VibWl0L2luaXRfdXNlcl9lbWFpbF9yZWNvdmVyeVwiLCBpbnB1dCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9kdWNlIGEgYFNpZ25lZFJlcXVlc3RgIGZyb20gYFRJbml0VXNlckVtYWlsUmVjb3ZlcnlCb2R5YCBieSB1c2luZyB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIEluaXRVc2VyRW1haWxSZWNvdmVyeX0uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YW1wSW5pdFVzZXJFbWFpbFJlY292ZXJ5ID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmdWxsVXJsID0gdGhpcy5jb25maWcuYmFzZVVybCArIFwiL3B1YmxpYy92MS9zdWJtaXQvaW5pdF91c2VyX2VtYWlsX3JlY292ZXJ5XCI7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkoaW5wdXQpO1xuICAgICAgICAgICAgY29uc3Qgc3RhbXAgPSBhd2FpdCB0aGlzLnN0YW1wZXIuc3RhbXAoYm9keSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICAgICAgc3RhbXA6IHN0YW1wLFxuICAgICAgICAgICAgICAgIHVybDogZnVsbFVybCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21wbGV0ZXMgdGhlIHByb2Nlc3Mgb2YgcmVjb3ZlcmluZyBhIHVzZXIgYnkgYWRkaW5nIGFuIGF1dGhlbnRpY2F0b3JcbiAgICAgICAgICpcbiAgICAgICAgICogU2lnbiB0aGUgcHJvdmlkZWQgYFRSZWNvdmVyVXNlckJvZHlgIHdpdGggdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24sIGFuZCBzdWJtaXQgdGhlIHJlcXVlc3QgKFBPU1QgL3B1YmxpYy92MS9zdWJtaXQvcmVjb3Zlcl91c2VyKS5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIHN0YW1wUmVjb3ZlclVzZXJ9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZWNvdmVyVXNlciA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChcIi9wdWJsaWMvdjEvc3VibWl0L3JlY292ZXJfdXNlclwiLCBpbnB1dCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9kdWNlIGEgYFNpZ25lZFJlcXVlc3RgIGZyb20gYFRSZWNvdmVyVXNlckJvZHlgIGJ5IHVzaW5nIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgUmVjb3ZlclVzZXJ9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFtcFJlY292ZXJVc2VyID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmdWxsVXJsID0gdGhpcy5jb25maWcuYmFzZVVybCArIFwiL3B1YmxpYy92MS9zdWJtaXQvcmVjb3Zlcl91c2VyXCI7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkoaW5wdXQpO1xuICAgICAgICAgICAgY29uc3Qgc3RhbXAgPSBhd2FpdCB0aGlzLnN0YW1wZXIuc3RhbXAoYm9keSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICAgICAgc3RhbXA6IHN0YW1wLFxuICAgICAgICAgICAgICAgIHVybDogZnVsbFVybCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWplY3QgYW4gQWN0aXZpdHlcbiAgICAgICAgICpcbiAgICAgICAgICogU2lnbiB0aGUgcHJvdmlkZWQgYFRSZWplY3RBY3Rpdml0eUJvZHlgIHdpdGggdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24sIGFuZCBzdWJtaXQgdGhlIHJlcXVlc3QgKFBPU1QgL3B1YmxpYy92MS9zdWJtaXQvcmVqZWN0X2FjdGl2aXR5KS5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIHN0YW1wUmVqZWN0QWN0aXZpdHl9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZWplY3RBY3Rpdml0eSA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChcIi9wdWJsaWMvdjEvc3VibWl0L3JlamVjdF9hY3Rpdml0eVwiLCBpbnB1dCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9kdWNlIGEgYFNpZ25lZFJlcXVlc3RgIGZyb20gYFRSZWplY3RBY3Rpdml0eUJvZHlgIGJ5IHVzaW5nIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgUmVqZWN0QWN0aXZpdHl9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFtcFJlamVjdEFjdGl2aXR5ID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmdWxsVXJsID0gdGhpcy5jb25maWcuYmFzZVVybCArIFwiL3B1YmxpYy92MS9zdWJtaXQvcmVqZWN0X2FjdGl2aXR5XCI7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkoaW5wdXQpO1xuICAgICAgICAgICAgY29uc3Qgc3RhbXAgPSBhd2FpdCB0aGlzLnN0YW1wZXIuc3RhbXAoYm9keSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICAgICAgc3RhbXA6IHN0YW1wLFxuICAgICAgICAgICAgICAgIHVybDogZnVsbFVybCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIGFuIG9yZ2FuaXphdGlvbiBmZWF0dXJlXG4gICAgICAgICAqXG4gICAgICAgICAqIFNpZ24gdGhlIHByb3ZpZGVkIGBUUmVtb3ZlT3JnYW5pemF0aW9uRmVhdHVyZUJvZHlgIHdpdGggdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24sIGFuZCBzdWJtaXQgdGhlIHJlcXVlc3QgKFBPU1QgL3B1YmxpYy92MS9zdWJtaXQvcmVtb3ZlX29yZ2FuaXphdGlvbl9mZWF0dXJlKS5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIHN0YW1wUmVtb3ZlT3JnYW5pemF0aW9uRmVhdHVyZX0uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlbW92ZU9yZ2FuaXphdGlvbkZlYXR1cmUgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoXCIvcHVibGljL3YxL3N1Ym1pdC9yZW1vdmVfb3JnYW5pemF0aW9uX2ZlYXR1cmVcIiwgaW5wdXQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZHVjZSBhIGBTaWduZWRSZXF1ZXN0YCBmcm9tIGBUUmVtb3ZlT3JnYW5pemF0aW9uRmVhdHVyZUJvZHlgIGJ5IHVzaW5nIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgUmVtb3ZlT3JnYW5pemF0aW9uRmVhdHVyZX0uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YW1wUmVtb3ZlT3JnYW5pemF0aW9uRmVhdHVyZSA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnVsbFVybCA9IHRoaXMuY29uZmlnLmJhc2VVcmwgKyBcIi9wdWJsaWMvdjEvc3VibWl0L3JlbW92ZV9vcmdhbml6YXRpb25fZmVhdHVyZVwiO1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KGlucHV0KTtcbiAgICAgICAgICAgIGNvbnN0IHN0YW1wID0gYXdhaXQgdGhpcy5zdGFtcGVyLnN0YW1wKGJvZHkpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgICAgIHN0YW1wOiBzdGFtcCxcbiAgICAgICAgICAgICAgICB1cmw6IGZ1bGxVcmwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyBhbiBvcmdhbml6YXRpb24gZmVhdHVyZVxuICAgICAgICAgKlxuICAgICAgICAgKiBTaWduIHRoZSBwcm92aWRlZCBgVFNldE9yZ2FuaXphdGlvbkZlYXR1cmVCb2R5YCB3aXRoIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLCBhbmQgc3VibWl0IHRoZSByZXF1ZXN0IChQT1NUIC9wdWJsaWMvdjEvc3VibWl0L3NldF9vcmdhbml6YXRpb25fZmVhdHVyZSkuXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBhbHNvIHtAbGluayBzdGFtcFNldE9yZ2FuaXphdGlvbkZlYXR1cmV9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZXRPcmdhbml6YXRpb25GZWF0dXJlID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KFwiL3B1YmxpYy92MS9zdWJtaXQvc2V0X29yZ2FuaXphdGlvbl9mZWF0dXJlXCIsIGlucHV0KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb2R1Y2UgYSBgU2lnbmVkUmVxdWVzdGAgZnJvbSBgVFNldE9yZ2FuaXphdGlvbkZlYXR1cmVCb2R5YCBieSB1c2luZyB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIFNldE9yZ2FuaXphdGlvbkZlYXR1cmV9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFtcFNldE9yZ2FuaXphdGlvbkZlYXR1cmUgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZ1bGxVcmwgPSB0aGlzLmNvbmZpZy5iYXNlVXJsICsgXCIvcHVibGljL3YxL3N1Ym1pdC9zZXRfb3JnYW5pemF0aW9uX2ZlYXR1cmVcIjtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeShpbnB1dCk7XG4gICAgICAgICAgICBjb25zdCBzdGFtcCA9IGF3YWl0IHRoaXMuc3RhbXBlci5zdGFtcChib2R5KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgICAgICBzdGFtcDogc3RhbXAsXG4gICAgICAgICAgICAgICAgdXJsOiBmdWxsVXJsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNpZ24gYSByYXcgcGF5bG9hZFxuICAgICAgICAgKlxuICAgICAgICAgKiBTaWduIHRoZSBwcm92aWRlZCBgVFNpZ25SYXdQYXlsb2FkQm9keWAgd2l0aCB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbiwgYW5kIHN1Ym1pdCB0aGUgcmVxdWVzdCAoUE9TVCAvcHVibGljL3YxL3N1Ym1pdC9zaWduX3Jhd19wYXlsb2FkKS5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIHN0YW1wU2lnblJhd1BheWxvYWR9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zaWduUmF3UGF5bG9hZCA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChcIi9wdWJsaWMvdjEvc3VibWl0L3NpZ25fcmF3X3BheWxvYWRcIiwgaW5wdXQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZHVjZSBhIGBTaWduZWRSZXF1ZXN0YCBmcm9tIGBUU2lnblJhd1BheWxvYWRCb2R5YCBieSB1c2luZyB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIFNpZ25SYXdQYXlsb2FkfS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhbXBTaWduUmF3UGF5bG9hZCA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnVsbFVybCA9IHRoaXMuY29uZmlnLmJhc2VVcmwgKyBcIi9wdWJsaWMvdjEvc3VibWl0L3NpZ25fcmF3X3BheWxvYWRcIjtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeShpbnB1dCk7XG4gICAgICAgICAgICBjb25zdCBzdGFtcCA9IGF3YWl0IHRoaXMuc3RhbXBlci5zdGFtcChib2R5KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgICAgICBzdGFtcDogc3RhbXAsXG4gICAgICAgICAgICAgICAgdXJsOiBmdWxsVXJsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNpZ24gYSB0cmFuc2FjdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBTaWduIHRoZSBwcm92aWRlZCBgVFNpZ25UcmFuc2FjdGlvbkJvZHlgIHdpdGggdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24sIGFuZCBzdWJtaXQgdGhlIHJlcXVlc3QgKFBPU1QgL3B1YmxpYy92MS9zdWJtaXQvc2lnbl90cmFuc2FjdGlvbikuXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBhbHNvIHtAbGluayBzdGFtcFNpZ25UcmFuc2FjdGlvbn0uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNpZ25UcmFuc2FjdGlvbiA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChcIi9wdWJsaWMvdjEvc3VibWl0L3NpZ25fdHJhbnNhY3Rpb25cIiwgaW5wdXQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZHVjZSBhIGBTaWduZWRSZXF1ZXN0YCBmcm9tIGBUU2lnblRyYW5zYWN0aW9uQm9keWAgYnkgdXNpbmcgdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBhbHNvIHtAbGluayBTaWduVHJhbnNhY3Rpb259LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFtcFNpZ25UcmFuc2FjdGlvbiA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnVsbFVybCA9IHRoaXMuY29uZmlnLmJhc2VVcmwgKyBcIi9wdWJsaWMvdjEvc3VibWl0L3NpZ25fdHJhbnNhY3Rpb25cIjtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeShpbnB1dCk7XG4gICAgICAgICAgICBjb25zdCBzdGFtcCA9IGF3YWl0IHRoaXMuc3RhbXBlci5zdGFtcChib2R5KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgICAgICBzdGFtcDogc3RhbXAsXG4gICAgICAgICAgICAgICAgdXJsOiBmdWxsVXJsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSBhbiBleGlzdGluZyBQb2xpY3lcbiAgICAgICAgICpcbiAgICAgICAgICogU2lnbiB0aGUgcHJvdmlkZWQgYFRVcGRhdGVQb2xpY3lCb2R5YCB3aXRoIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLCBhbmQgc3VibWl0IHRoZSByZXF1ZXN0IChQT1NUIC9wdWJsaWMvdjEvc3VibWl0L3VwZGF0ZV9wb2xpY3kpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgc3RhbXBVcGRhdGVQb2xpY3l9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51cGRhdGVQb2xpY3kgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoXCIvcHVibGljL3YxL3N1Ym1pdC91cGRhdGVfcG9saWN5XCIsIGlucHV0KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb2R1Y2UgYSBgU2lnbmVkUmVxdWVzdGAgZnJvbSBgVFVwZGF0ZVBvbGljeUJvZHlgIGJ5IHVzaW5nIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgVXBkYXRlUG9saWN5fS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhbXBVcGRhdGVQb2xpY3kgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZ1bGxVcmwgPSB0aGlzLmNvbmZpZy5iYXNlVXJsICsgXCIvcHVibGljL3YxL3N1Ym1pdC91cGRhdGVfcG9saWN5XCI7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkoaW5wdXQpO1xuICAgICAgICAgICAgY29uc3Qgc3RhbXAgPSBhd2FpdCB0aGlzLnN0YW1wZXIuc3RhbXAoYm9keSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICAgICAgc3RhbXA6IHN0YW1wLFxuICAgICAgICAgICAgICAgIHVybDogZnVsbFVybCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGUgaHVtYW4tcmVhZGFibGUgbmFtZSBvciBhc3NvY2lhdGVkIHByaXZhdGUga2V5cy4gTm90ZSB0aGF0IHRoaXMgYWN0aXZpdHkgaXMgYXRvbWljOiBhbGwgb2YgdGhlIHVwZGF0ZXMgd2lsbCBzdWNjZWVkIGF0IG9uY2UsIG9yIGFsbCBvZiB0aGVtIHdpbGwgZmFpbC5cbiAgICAgICAgICpcbiAgICAgICAgICogU2lnbiB0aGUgcHJvdmlkZWQgYFRVcGRhdGVQcml2YXRlS2V5VGFnQm9keWAgd2l0aCB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbiwgYW5kIHN1Ym1pdCB0aGUgcmVxdWVzdCAoUE9TVCAvcHVibGljL3YxL3N1Ym1pdC91cGRhdGVfcHJpdmF0ZV9rZXlfdGFnKS5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIHN0YW1wVXBkYXRlUHJpdmF0ZUtleVRhZ30uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVwZGF0ZVByaXZhdGVLZXlUYWcgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoXCIvcHVibGljL3YxL3N1Ym1pdC91cGRhdGVfcHJpdmF0ZV9rZXlfdGFnXCIsIGlucHV0KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb2R1Y2UgYSBgU2lnbmVkUmVxdWVzdGAgZnJvbSBgVFVwZGF0ZVByaXZhdGVLZXlUYWdCb2R5YCBieSB1c2luZyB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIFVwZGF0ZVByaXZhdGVLZXlUYWd9LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFtcFVwZGF0ZVByaXZhdGVLZXlUYWcgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZ1bGxVcmwgPSB0aGlzLmNvbmZpZy5iYXNlVXJsICsgXCIvcHVibGljL3YxL3N1Ym1pdC91cGRhdGVfcHJpdmF0ZV9rZXlfdGFnXCI7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkoaW5wdXQpO1xuICAgICAgICAgICAgY29uc3Qgc3RhbXAgPSBhd2FpdCB0aGlzLnN0YW1wZXIuc3RhbXAoYm9keSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICAgICAgc3RhbXA6IHN0YW1wLFxuICAgICAgICAgICAgICAgIHVybDogZnVsbFVybCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIHRocmVzaG9sZCBhbmQgbWVtYmVycyBvZiB0aGUgcm9vdCBxdW9ydW0uIFRoaXMgbXVzdCBiZSBhcHByb3ZlZCBieSB0aGUgY3VycmVudCByb290IHF1b3J1bS5cbiAgICAgICAgICpcbiAgICAgICAgICogU2lnbiB0aGUgcHJvdmlkZWQgYFRVcGRhdGVSb290UXVvcnVtQm9keWAgd2l0aCB0aGUgY2xpZW50J3MgYHN0YW1wYCBmdW5jdGlvbiwgYW5kIHN1Ym1pdCB0aGUgcmVxdWVzdCAoUE9TVCAvcHVibGljL3YxL3N1Ym1pdC91cGRhdGVfcm9vdF9xdW9ydW0pLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgc3RhbXBVcGRhdGVSb290UXVvcnVtfS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudXBkYXRlUm9vdFF1b3J1bSA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChcIi9wdWJsaWMvdjEvc3VibWl0L3VwZGF0ZV9yb290X3F1b3J1bVwiLCBpbnB1dCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9kdWNlIGEgYFNpZ25lZFJlcXVlc3RgIGZyb20gYFRVcGRhdGVSb290UXVvcnVtQm9keWAgYnkgdXNpbmcgdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBhbHNvIHtAbGluayBVcGRhdGVSb290UXVvcnVtfS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhbXBVcGRhdGVSb290UXVvcnVtID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmdWxsVXJsID0gdGhpcy5jb25maWcuYmFzZVVybCArIFwiL3B1YmxpYy92MS9zdWJtaXQvdXBkYXRlX3Jvb3RfcXVvcnVtXCI7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkoaW5wdXQpO1xuICAgICAgICAgICAgY29uc3Qgc3RhbXAgPSBhd2FpdCB0aGlzLnN0YW1wZXIuc3RhbXAoYm9keSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICAgICAgc3RhbXA6IHN0YW1wLFxuICAgICAgICAgICAgICAgIHVybDogZnVsbFVybCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGUgYSBVc2VyIGluIGFuIGV4aXN0aW5nIE9yZ2FuaXphdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBTaWduIHRoZSBwcm92aWRlZCBgVFVwZGF0ZVVzZXJCb2R5YCB3aXRoIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLCBhbmQgc3VibWl0IHRoZSByZXF1ZXN0IChQT1NUIC9wdWJsaWMvdjEvc3VibWl0L3VwZGF0ZV91c2VyKS5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIHN0YW1wVXBkYXRlVXNlcn0uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVwZGF0ZVVzZXIgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoXCIvcHVibGljL3YxL3N1Ym1pdC91cGRhdGVfdXNlclwiLCBpbnB1dCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9kdWNlIGEgYFNpZ25lZFJlcXVlc3RgIGZyb20gYFRVcGRhdGVVc2VyQm9keWAgYnkgdXNpbmcgdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBhbHNvIHtAbGluayBVcGRhdGVVc2VyfS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhbXBVcGRhdGVVc2VyID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmdWxsVXJsID0gdGhpcy5jb25maWcuYmFzZVVybCArIFwiL3B1YmxpYy92MS9zdWJtaXQvdXBkYXRlX3VzZXJcIjtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeShpbnB1dCk7XG4gICAgICAgICAgICBjb25zdCBzdGFtcCA9IGF3YWl0IHRoaXMuc3RhbXBlci5zdGFtcChib2R5KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgICAgICBzdGFtcDogc3RhbXAsXG4gICAgICAgICAgICAgICAgdXJsOiBmdWxsVXJsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9yIGFzc29jaWF0ZWQgdXNlcnMuIE5vdGUgdGhhdCB0aGlzIGFjdGl2aXR5IGlzIGF0b21pYzogYWxsIG9mIHRoZSB1cGRhdGVzIHdpbGwgc3VjY2VlZCBhdCBvbmNlLCBvciBhbGwgb2YgdGhlbSB3aWxsIGZhaWwuXG4gICAgICAgICAqXG4gICAgICAgICAqIFNpZ24gdGhlIHByb3ZpZGVkIGBUVXBkYXRlVXNlclRhZ0JvZHlgIHdpdGggdGhlIGNsaWVudCdzIGBzdGFtcGAgZnVuY3Rpb24sIGFuZCBzdWJtaXQgdGhlIHJlcXVlc3QgKFBPU1QgL3B1YmxpYy92MS9zdWJtaXQvdXBkYXRlX3VzZXJfdGFnKS5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIGFsc28ge0BsaW5rIHN0YW1wVXBkYXRlVXNlclRhZ30uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVwZGF0ZVVzZXJUYWcgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoXCIvcHVibGljL3YxL3N1Ym1pdC91cGRhdGVfdXNlcl90YWdcIiwgaW5wdXQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZHVjZSBhIGBTaWduZWRSZXF1ZXN0YCBmcm9tIGBUVXBkYXRlVXNlclRhZ0JvZHlgIGJ5IHVzaW5nIHRoZSBjbGllbnQncyBgc3RhbXBgIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYWxzbyB7QGxpbmsgVXBkYXRlVXNlclRhZ30uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YW1wVXBkYXRlVXNlclRhZyA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnVsbFVybCA9IHRoaXMuY29uZmlnLmJhc2VVcmwgKyBcIi9wdWJsaWMvdjEvc3VibWl0L3VwZGF0ZV91c2VyX3RhZ1wiO1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KGlucHV0KTtcbiAgICAgICAgICAgIGNvbnN0IHN0YW1wID0gYXdhaXQgdGhpcy5zdGFtcGVyLnN0YW1wKGJvZHkpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgICAgIHN0YW1wOiBzdGFtcCxcbiAgICAgICAgICAgICAgICB1cmw6IGZ1bGxVcmwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICBpZiAoIWNvbmZpZy5iYXNlVXJsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1pc3NpbmcgYmFzZSBVUkwuIFBsZWFzZSB2ZXJpZnkgZW52IHZhcnMuYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMuc3RhbXBlciA9IHN0YW1wZXI7XG4gICAgfVxuICAgIGFzeW5jIHJlcXVlc3QodXJsLCBib2R5KSB7XG4gICAgICAgIGNvbnN0IGZ1bGxVcmwgPSB0aGlzLmNvbmZpZy5iYXNlVXJsICsgdXJsO1xuICAgICAgICBjb25zdCBzdHJpbmdpZmllZEJvZHkgPSBKU09OLnN0cmluZ2lmeShib2R5KTtcbiAgICAgICAgY29uc3Qgc3RhbXAgPSBhd2FpdCB0aGlzLnN0YW1wZXIuc3RhbXAoc3RyaW5naWZpZWRCb2R5KTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChmdWxsVXJsLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgIFtzdGFtcC5zdGFtcEhlYWRlck5hbWVdOiBzdGFtcC5zdGFtcEhlYWRlclZhbHVlLFxuICAgICAgICAgICAgICAgIFwiWC1DbGllbnQtVmVyc2lvblwiOiBWRVJTSU9OLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJvZHk6IHN0cmluZ2lmaWVkQm9keSxcbiAgICAgICAgICAgIHJlZGlyZWN0OiBcImZvbGxvd1wiLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgbGV0IHJlcztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHVybmtleVJlcXVlc3RFcnJvcihyZXMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgVHVybmtleUNsaWVudCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHVibGljX2FwaS5jbGllbnQubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/__generated__/services/coordinator/public/v1/public_api.client.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/__generated__/services/coordinator/public/v1/public_api.fetcher.mjs":
/*!******************************************************************************************************************************************!*\
  !*** ./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/__generated__/services/coordinator/public/v1/public_api.fetcher.mjs ***!
  \******************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   approveActivity: () => (/* binding */ approveActivity),\n/* harmony export */   createApiKeys: () => (/* binding */ createApiKeys),\n/* harmony export */   createApiOnlyUsers: () => (/* binding */ createApiOnlyUsers),\n/* harmony export */   createAuthenticators: () => (/* binding */ createAuthenticators),\n/* harmony export */   createInvitations: () => (/* binding */ createInvitations),\n/* harmony export */   createPolicy: () => (/* binding */ createPolicy),\n/* harmony export */   createPrivateKeyTag: () => (/* binding */ createPrivateKeyTag),\n/* harmony export */   createPrivateKeys: () => (/* binding */ createPrivateKeys),\n/* harmony export */   createSubOrganization: () => (/* binding */ createSubOrganization),\n/* harmony export */   createUserTag: () => (/* binding */ createUserTag),\n/* harmony export */   createUsers: () => (/* binding */ createUsers),\n/* harmony export */   createWallet: () => (/* binding */ createWallet),\n/* harmony export */   createWalletAccounts: () => (/* binding */ createWalletAccounts),\n/* harmony export */   deleteApiKeys: () => (/* binding */ deleteApiKeys),\n/* harmony export */   deleteAuthenticators: () => (/* binding */ deleteAuthenticators),\n/* harmony export */   deleteInvitation: () => (/* binding */ deleteInvitation),\n/* harmony export */   deletePolicy: () => (/* binding */ deletePolicy),\n/* harmony export */   emailAuth: () => (/* binding */ emailAuth),\n/* harmony export */   exportPrivateKey: () => (/* binding */ exportPrivateKey),\n/* harmony export */   exportWallet: () => (/* binding */ exportWallet),\n/* harmony export */   exportWalletAccount: () => (/* binding */ exportWalletAccount),\n/* harmony export */   getActivities: () => (/* binding */ getActivities),\n/* harmony export */   getActivity: () => (/* binding */ getActivity),\n/* harmony export */   getApiKey: () => (/* binding */ getApiKey),\n/* harmony export */   getApiKeys: () => (/* binding */ getApiKeys),\n/* harmony export */   getAuthenticator: () => (/* binding */ getAuthenticator),\n/* harmony export */   getAuthenticators: () => (/* binding */ getAuthenticators),\n/* harmony export */   getOrganization: () => (/* binding */ getOrganization),\n/* harmony export */   getPolicies: () => (/* binding */ getPolicies),\n/* harmony export */   getPolicy: () => (/* binding */ getPolicy),\n/* harmony export */   getPrivateKey: () => (/* binding */ getPrivateKey),\n/* harmony export */   getPrivateKeys: () => (/* binding */ getPrivateKeys),\n/* harmony export */   getUser: () => (/* binding */ getUser),\n/* harmony export */   getUsers: () => (/* binding */ getUsers),\n/* harmony export */   getWallet: () => (/* binding */ getWallet),\n/* harmony export */   getWalletAccounts: () => (/* binding */ getWalletAccounts),\n/* harmony export */   getWallets: () => (/* binding */ getWallets),\n/* harmony export */   getWhoami: () => (/* binding */ getWhoami),\n/* harmony export */   initUserEmailRecovery: () => (/* binding */ initUserEmailRecovery),\n/* harmony export */   listPrivateKeyTags: () => (/* binding */ listPrivateKeyTags),\n/* harmony export */   listUserTags: () => (/* binding */ listUserTags),\n/* harmony export */   nOOPCodegenAnchor: () => (/* binding */ nOOPCodegenAnchor),\n/* harmony export */   recoverUser: () => (/* binding */ recoverUser),\n/* harmony export */   rejectActivity: () => (/* binding */ rejectActivity),\n/* harmony export */   removeOrganizationFeature: () => (/* binding */ removeOrganizationFeature),\n/* harmony export */   setOrganizationFeature: () => (/* binding */ setOrganizationFeature),\n/* harmony export */   signApproveActivity: () => (/* binding */ signApproveActivity),\n/* harmony export */   signCreateApiKeys: () => (/* binding */ signCreateApiKeys),\n/* harmony export */   signCreateApiOnlyUsers: () => (/* binding */ signCreateApiOnlyUsers),\n/* harmony export */   signCreateAuthenticators: () => (/* binding */ signCreateAuthenticators),\n/* harmony export */   signCreateInvitations: () => (/* binding */ signCreateInvitations),\n/* harmony export */   signCreatePolicy: () => (/* binding */ signCreatePolicy),\n/* harmony export */   signCreatePrivateKeyTag: () => (/* binding */ signCreatePrivateKeyTag),\n/* harmony export */   signCreatePrivateKeys: () => (/* binding */ signCreatePrivateKeys),\n/* harmony export */   signCreateSubOrganization: () => (/* binding */ signCreateSubOrganization),\n/* harmony export */   signCreateUserTag: () => (/* binding */ signCreateUserTag),\n/* harmony export */   signCreateUsers: () => (/* binding */ signCreateUsers),\n/* harmony export */   signCreateWallet: () => (/* binding */ signCreateWallet),\n/* harmony export */   signCreateWalletAccounts: () => (/* binding */ signCreateWalletAccounts),\n/* harmony export */   signDeleteApiKeys: () => (/* binding */ signDeleteApiKeys),\n/* harmony export */   signDeleteAuthenticators: () => (/* binding */ signDeleteAuthenticators),\n/* harmony export */   signDeleteInvitation: () => (/* binding */ signDeleteInvitation),\n/* harmony export */   signDeletePolicy: () => (/* binding */ signDeletePolicy),\n/* harmony export */   signEmailAuth: () => (/* binding */ signEmailAuth),\n/* harmony export */   signExportPrivateKey: () => (/* binding */ signExportPrivateKey),\n/* harmony export */   signExportWallet: () => (/* binding */ signExportWallet),\n/* harmony export */   signExportWalletAccount: () => (/* binding */ signExportWalletAccount),\n/* harmony export */   signGetActivities: () => (/* binding */ signGetActivities),\n/* harmony export */   signGetActivity: () => (/* binding */ signGetActivity),\n/* harmony export */   signGetApiKey: () => (/* binding */ signGetApiKey),\n/* harmony export */   signGetApiKeys: () => (/* binding */ signGetApiKeys),\n/* harmony export */   signGetAuthenticator: () => (/* binding */ signGetAuthenticator),\n/* harmony export */   signGetAuthenticators: () => (/* binding */ signGetAuthenticators),\n/* harmony export */   signGetOrganization: () => (/* binding */ signGetOrganization),\n/* harmony export */   signGetPolicies: () => (/* binding */ signGetPolicies),\n/* harmony export */   signGetPolicy: () => (/* binding */ signGetPolicy),\n/* harmony export */   signGetPrivateKey: () => (/* binding */ signGetPrivateKey),\n/* harmony export */   signGetPrivateKeys: () => (/* binding */ signGetPrivateKeys),\n/* harmony export */   signGetUser: () => (/* binding */ signGetUser),\n/* harmony export */   signGetUsers: () => (/* binding */ signGetUsers),\n/* harmony export */   signGetWallet: () => (/* binding */ signGetWallet),\n/* harmony export */   signGetWalletAccounts: () => (/* binding */ signGetWalletAccounts),\n/* harmony export */   signGetWallets: () => (/* binding */ signGetWallets),\n/* harmony export */   signGetWhoami: () => (/* binding */ signGetWhoami),\n/* harmony export */   signInitUserEmailRecovery: () => (/* binding */ signInitUserEmailRecovery),\n/* harmony export */   signListPrivateKeyTags: () => (/* binding */ signListPrivateKeyTags),\n/* harmony export */   signListUserTags: () => (/* binding */ signListUserTags),\n/* harmony export */   signNOOPCodegenAnchor: () => (/* binding */ signNOOPCodegenAnchor),\n/* harmony export */   signRawPayload: () => (/* binding */ signRawPayload),\n/* harmony export */   signRecoverUser: () => (/* binding */ signRecoverUser),\n/* harmony export */   signRejectActivity: () => (/* binding */ signRejectActivity),\n/* harmony export */   signRemoveOrganizationFeature: () => (/* binding */ signRemoveOrganizationFeature),\n/* harmony export */   signSetOrganizationFeature: () => (/* binding */ signSetOrganizationFeature),\n/* harmony export */   signSignRawPayload: () => (/* binding */ signSignRawPayload),\n/* harmony export */   signSignTransaction: () => (/* binding */ signSignTransaction),\n/* harmony export */   signTransaction: () => (/* binding */ signTransaction),\n/* harmony export */   signUpdatePolicy: () => (/* binding */ signUpdatePolicy),\n/* harmony export */   signUpdatePrivateKeyTag: () => (/* binding */ signUpdatePrivateKeyTag),\n/* harmony export */   signUpdateRootQuorum: () => (/* binding */ signUpdateRootQuorum),\n/* harmony export */   signUpdateUser: () => (/* binding */ signUpdateUser),\n/* harmony export */   signUpdateUserTag: () => (/* binding */ signUpdateUserTag),\n/* harmony export */   updatePolicy: () => (/* binding */ updatePolicy),\n/* harmony export */   updatePrivateKeyTag: () => (/* binding */ updatePrivateKeyTag),\n/* harmony export */   updateRootQuorum: () => (/* binding */ updateRootQuorum),\n/* harmony export */   updateUser: () => (/* binding */ updateUser),\n/* harmony export */   updateUserTag: () => (/* binding */ updateUserTag)\n/* harmony export */ });\n/* harmony import */ var _base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../base.mjs */ \"(ssr)/./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/base.mjs\");\n\n\n/* @generated by `@turnkey/fetchers`. DO NOT EDIT BY HAND */\n/**\n * Get Activity\n *\n * Get details about an Activity\n *\n * `POST /public/v1/query/get_activity`\n */\nconst getActivity = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/query/get_activity\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `GetActivity` request, ready to be POSTed to Turnkey.\n *\n * See {@link GetActivity}\n */\nconst signGetActivity = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/query/get_activity\",\n    body: input.body,\n    options,\n});\n/**\n * Get API key\n *\n * Get details about an API key\n *\n * `POST /public/v1/query/get_api_key`\n */\nconst getApiKey = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/query/get_api_key\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `GetApiKey` request, ready to be POSTed to Turnkey.\n *\n * See {@link GetApiKey}\n */\nconst signGetApiKey = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/query/get_api_key\",\n    body: input.body,\n    options,\n});\n/**\n * Get API key\n *\n * Get details about API keys for a user\n *\n * `POST /public/v1/query/get_api_keys`\n */\nconst getApiKeys = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/query/get_api_keys\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `GetApiKeys` request, ready to be POSTed to Turnkey.\n *\n * See {@link GetApiKeys}\n */\nconst signGetApiKeys = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/query/get_api_keys\",\n    body: input.body,\n    options,\n});\n/**\n * Get Authenticator\n *\n * Get details about an authenticator\n *\n * `POST /public/v1/query/get_authenticator`\n */\nconst getAuthenticator = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/query/get_authenticator\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `GetAuthenticator` request, ready to be POSTed to Turnkey.\n *\n * See {@link GetAuthenticator}\n */\nconst signGetAuthenticator = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/query/get_authenticator\",\n    body: input.body,\n    options,\n});\n/**\n * Get Authenticators\n *\n * Get details about authenticators for a user\n *\n * `POST /public/v1/query/get_authenticators`\n */\nconst getAuthenticators = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/query/get_authenticators\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `GetAuthenticators` request, ready to be POSTed to Turnkey.\n *\n * See {@link GetAuthenticators}\n */\nconst signGetAuthenticators = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/query/get_authenticators\",\n    body: input.body,\n    options,\n});\n/**\n * Get Organization\n *\n * Get details about an Organization\n *\n * `POST /public/v1/query/get_organization`\n */\nconst getOrganization = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/query/get_organization\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `GetOrganization` request, ready to be POSTed to Turnkey.\n *\n * See {@link GetOrganization}\n */\nconst signGetOrganization = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/query/get_organization\",\n    body: input.body,\n    options,\n});\n/**\n * Get Policy\n *\n * Get details about a Policy\n *\n * `POST /public/v1/query/get_policy`\n */\nconst getPolicy = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/query/get_policy\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `GetPolicy` request, ready to be POSTed to Turnkey.\n *\n * See {@link GetPolicy}\n */\nconst signGetPolicy = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/query/get_policy\",\n    body: input.body,\n    options,\n});\n/**\n * Get Private Key\n *\n * Get details about a Private Key\n *\n * `POST /public/v1/query/get_private_key`\n */\nconst getPrivateKey = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/query/get_private_key\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `GetPrivateKey` request, ready to be POSTed to Turnkey.\n *\n * See {@link GetPrivateKey}\n */\nconst signGetPrivateKey = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/query/get_private_key\",\n    body: input.body,\n    options,\n});\n/**\n * Get User\n *\n * Get details about a User\n *\n * `POST /public/v1/query/get_user`\n */\nconst getUser = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/query/get_user\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `GetUser` request, ready to be POSTed to Turnkey.\n *\n * See {@link GetUser}\n */\nconst signGetUser = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/query/get_user\",\n    body: input.body,\n    options,\n});\n/**\n * Get Wallet\n *\n * Get details about a Wallet\n *\n * `POST /public/v1/query/get_wallet`\n */\nconst getWallet = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/query/get_wallet\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `GetWallet` request, ready to be POSTed to Turnkey.\n *\n * See {@link GetWallet}\n */\nconst signGetWallet = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/query/get_wallet\",\n    body: input.body,\n    options,\n});\n/**\n * List Activities\n *\n * List all Activities within an Organization\n *\n * `POST /public/v1/query/list_activities`\n */\nconst getActivities = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/query/list_activities\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `GetActivities` request, ready to be POSTed to Turnkey.\n *\n * See {@link GetActivities}\n */\nconst signGetActivities = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/query/list_activities\",\n    body: input.body,\n    options,\n});\n/**\n * List Policies\n *\n * List all Policies within an Organization\n *\n * `POST /public/v1/query/list_policies`\n */\nconst getPolicies = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/query/list_policies\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `GetPolicies` request, ready to be POSTed to Turnkey.\n *\n * See {@link GetPolicies}\n */\nconst signGetPolicies = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/query/list_policies\",\n    body: input.body,\n    options,\n});\n/**\n * List Private Key Tags\n *\n * List all Private Key Tags within an Organization\n *\n * `POST /public/v1/query/list_private_key_tags`\n */\nconst listPrivateKeyTags = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/query/list_private_key_tags\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `ListPrivateKeyTags` request, ready to be POSTed to Turnkey.\n *\n * See {@link ListPrivateKeyTags}\n */\nconst signListPrivateKeyTags = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/query/list_private_key_tags\",\n    body: input.body,\n    options,\n});\n/**\n * List Private Keys\n *\n * List all Private Keys within an Organization\n *\n * `POST /public/v1/query/list_private_keys`\n */\nconst getPrivateKeys = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/query/list_private_keys\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `GetPrivateKeys` request, ready to be POSTed to Turnkey.\n *\n * See {@link GetPrivateKeys}\n */\nconst signGetPrivateKeys = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/query/list_private_keys\",\n    body: input.body,\n    options,\n});\n/**\n * List User Tags\n *\n * List all User Tags within an Organization\n *\n * `POST /public/v1/query/list_user_tags`\n */\nconst listUserTags = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/query/list_user_tags\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `ListUserTags` request, ready to be POSTed to Turnkey.\n *\n * See {@link ListUserTags}\n */\nconst signListUserTags = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/query/list_user_tags\",\n    body: input.body,\n    options,\n});\n/**\n * List Users\n *\n * List all Users within an Organization\n *\n * `POST /public/v1/query/list_users`\n */\nconst getUsers = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/query/list_users\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `GetUsers` request, ready to be POSTed to Turnkey.\n *\n * See {@link GetUsers}\n */\nconst signGetUsers = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/query/list_users\",\n    body: input.body,\n    options,\n});\n/**\n * List Wallets Accounts\n *\n * List all Accounts wirhin a Wallet\n *\n * `POST /public/v1/query/list_wallet_accounts`\n */\nconst getWalletAccounts = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/query/list_wallet_accounts\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `GetWalletAccounts` request, ready to be POSTed to Turnkey.\n *\n * See {@link GetWalletAccounts}\n */\nconst signGetWalletAccounts = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/query/list_wallet_accounts\",\n    body: input.body,\n    options,\n});\n/**\n * List Wallets\n *\n * List all Wallets within an Organization\n *\n * `POST /public/v1/query/list_wallets`\n */\nconst getWallets = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/query/list_wallets\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `GetWallets` request, ready to be POSTed to Turnkey.\n *\n * See {@link GetWallets}\n */\nconst signGetWallets = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/query/list_wallets\",\n    body: input.body,\n    options,\n});\n/**\n * Who am I?\n *\n * Get basic information about your current API or WebAuthN user and their organization. Affords Sub-Organization look ups via Parent Organization for WebAuthN users.\n *\n * `POST /public/v1/query/whoami`\n */\nconst getWhoami = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/query/whoami\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `GetWhoami` request, ready to be POSTed to Turnkey.\n *\n * See {@link GetWhoami}\n */\nconst signGetWhoami = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/query/whoami\",\n    body: input.body,\n    options,\n});\n/**\n * Approve Activity\n *\n * Approve an Activity\n *\n * `POST /public/v1/submit/approve_activity`\n */\nconst approveActivity = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/approve_activity\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `ApproveActivity` request, ready to be POSTed to Turnkey.\n *\n * See {@link ApproveActivity}\n */\nconst signApproveActivity = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/approve_activity\",\n    body: input.body,\n    options,\n});\n/**\n * Create API Keys\n *\n * Add api keys to an existing User\n *\n * `POST /public/v1/submit/create_api_keys`\n */\nconst createApiKeys = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/create_api_keys\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `CreateApiKeys` request, ready to be POSTed to Turnkey.\n *\n * See {@link CreateApiKeys}\n */\nconst signCreateApiKeys = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/create_api_keys\",\n    body: input.body,\n    options,\n});\n/**\n * Create API-only Users\n *\n * Create API-only Users in an existing Organization\n *\n * `POST /public/v1/submit/create_api_only_users`\n */\nconst createApiOnlyUsers = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/create_api_only_users\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `CreateApiOnlyUsers` request, ready to be POSTed to Turnkey.\n *\n * See {@link CreateApiOnlyUsers}\n */\nconst signCreateApiOnlyUsers = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/create_api_only_users\",\n    body: input.body,\n    options,\n});\n/**\n * Create Authenticators\n *\n * Create Authenticators to authenticate requests to Turnkey\n *\n * `POST /public/v1/submit/create_authenticators`\n */\nconst createAuthenticators = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/create_authenticators\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `CreateAuthenticators` request, ready to be POSTed to Turnkey.\n *\n * See {@link CreateAuthenticators}\n */\nconst signCreateAuthenticators = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/create_authenticators\",\n    body: input.body,\n    options,\n});\n/**\n * Create Invitations\n *\n * Create Invitations to join an existing Organization\n *\n * `POST /public/v1/submit/create_invitations`\n */\nconst createInvitations = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/create_invitations\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `CreateInvitations` request, ready to be POSTed to Turnkey.\n *\n * See {@link CreateInvitations}\n */\nconst signCreateInvitations = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/create_invitations\",\n    body: input.body,\n    options,\n});\n/**\n * Create Policy\n *\n * Create a new Policy\n *\n * `POST /public/v1/submit/create_policy`\n */\nconst createPolicy = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/create_policy\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `CreatePolicy` request, ready to be POSTed to Turnkey.\n *\n * See {@link CreatePolicy}\n */\nconst signCreatePolicy = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/create_policy\",\n    body: input.body,\n    options,\n});\n/**\n * Create Private Key Tag\n *\n * Create a private key tag and add it to private keys.\n *\n * `POST /public/v1/submit/create_private_key_tag`\n */\nconst createPrivateKeyTag = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/create_private_key_tag\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `CreatePrivateKeyTag` request, ready to be POSTed to Turnkey.\n *\n * See {@link CreatePrivateKeyTag}\n */\nconst signCreatePrivateKeyTag = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/create_private_key_tag\",\n    body: input.body,\n    options,\n});\n/**\n * Create Private Keys\n *\n * Create new Private Keys\n *\n * `POST /public/v1/submit/create_private_keys`\n */\nconst createPrivateKeys = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/create_private_keys\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `CreatePrivateKeys` request, ready to be POSTed to Turnkey.\n *\n * See {@link CreatePrivateKeys}\n */\nconst signCreatePrivateKeys = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/create_private_keys\",\n    body: input.body,\n    options,\n});\n/**\n * Create Sub-Organization\n *\n * Create a new Sub-Organization\n *\n * `POST /public/v1/submit/create_sub_organization`\n */\nconst createSubOrganization = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/create_sub_organization\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `CreateSubOrganization` request, ready to be POSTed to Turnkey.\n *\n * See {@link CreateSubOrganization}\n */\nconst signCreateSubOrganization = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/create_sub_organization\",\n    body: input.body,\n    options,\n});\n/**\n * Create User Tag\n *\n * Create a user tag and add it to users.\n *\n * `POST /public/v1/submit/create_user_tag`\n */\nconst createUserTag = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/create_user_tag\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `CreateUserTag` request, ready to be POSTed to Turnkey.\n *\n * See {@link CreateUserTag}\n */\nconst signCreateUserTag = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/create_user_tag\",\n    body: input.body,\n    options,\n});\n/**\n * Create Users\n *\n * Create Users in an existing Organization\n *\n * `POST /public/v1/submit/create_users`\n */\nconst createUsers = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/create_users\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `CreateUsers` request, ready to be POSTed to Turnkey.\n *\n * See {@link CreateUsers}\n */\nconst signCreateUsers = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/create_users\",\n    body: input.body,\n    options,\n});\n/**\n * Create Wallet\n *\n * Create a Wallet and derive addresses\n *\n * `POST /public/v1/submit/create_wallet`\n */\nconst createWallet = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/create_wallet\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `CreateWallet` request, ready to be POSTed to Turnkey.\n *\n * See {@link CreateWallet}\n */\nconst signCreateWallet = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/create_wallet\",\n    body: input.body,\n    options,\n});\n/**\n * Create Wallet Accounts\n *\n * Derive additional addresses using an existing wallet\n *\n * `POST /public/v1/submit/create_wallet_accounts`\n */\nconst createWalletAccounts = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/create_wallet_accounts\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `CreateWalletAccounts` request, ready to be POSTed to Turnkey.\n *\n * See {@link CreateWalletAccounts}\n */\nconst signCreateWalletAccounts = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/create_wallet_accounts\",\n    body: input.body,\n    options,\n});\n/**\n * Delete API Keys\n *\n * Remove api keys from a User\n *\n * `POST /public/v1/submit/delete_api_keys`\n */\nconst deleteApiKeys = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/delete_api_keys\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `DeleteApiKeys` request, ready to be POSTed to Turnkey.\n *\n * See {@link DeleteApiKeys}\n */\nconst signDeleteApiKeys = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/delete_api_keys\",\n    body: input.body,\n    options,\n});\n/**\n * Delete Authenticators\n *\n * Remove authenticators from a User\n *\n * `POST /public/v1/submit/delete_authenticators`\n */\nconst deleteAuthenticators = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/delete_authenticators\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `DeleteAuthenticators` request, ready to be POSTed to Turnkey.\n *\n * See {@link DeleteAuthenticators}\n */\nconst signDeleteAuthenticators = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/delete_authenticators\",\n    body: input.body,\n    options,\n});\n/**\n * Delete Invitation\n *\n * Delete an existing Invitation\n *\n * `POST /public/v1/submit/delete_invitation`\n */\nconst deleteInvitation = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/delete_invitation\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `DeleteInvitation` request, ready to be POSTed to Turnkey.\n *\n * See {@link DeleteInvitation}\n */\nconst signDeleteInvitation = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/delete_invitation\",\n    body: input.body,\n    options,\n});\n/**\n * Delete Policy\n *\n * Delete an existing Policy\n *\n * `POST /public/v1/submit/delete_policy`\n */\nconst deletePolicy = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/delete_policy\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `DeletePolicy` request, ready to be POSTed to Turnkey.\n *\n * See {@link DeletePolicy}\n */\nconst signDeletePolicy = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/delete_policy\",\n    body: input.body,\n    options,\n});\n/**\n * Perform Email Auth\n *\n * Authenticate a user via Email\n *\n * `POST /public/v1/submit/email_auth`\n */\nconst emailAuth = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/email_auth\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `EmailAuth` request, ready to be POSTed to Turnkey.\n *\n * See {@link EmailAuth}\n */\nconst signEmailAuth = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/email_auth\",\n    body: input.body,\n    options,\n});\n/**\n * Export Private Key\n *\n * Exports a Private Key\n *\n * `POST /public/v1/submit/export_private_key`\n */\nconst exportPrivateKey = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/export_private_key\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `ExportPrivateKey` request, ready to be POSTed to Turnkey.\n *\n * See {@link ExportPrivateKey}\n */\nconst signExportPrivateKey = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/export_private_key\",\n    body: input.body,\n    options,\n});\n/**\n * Export Wallet\n *\n * Exports a Wallet\n *\n * `POST /public/v1/submit/export_wallet`\n */\nconst exportWallet = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/export_wallet\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `ExportWallet` request, ready to be POSTed to Turnkey.\n *\n * See {@link ExportWallet}\n */\nconst signExportWallet = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/export_wallet\",\n    body: input.body,\n    options,\n});\n/**\n * Export Wallet Account\n *\n * Exports a Wallet Account\n *\n * `POST /public/v1/submit/export_wallet_account`\n */\nconst exportWalletAccount = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/export_wallet_account\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `ExportWalletAccount` request, ready to be POSTed to Turnkey.\n *\n * See {@link ExportWalletAccount}\n */\nconst signExportWalletAccount = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/export_wallet_account\",\n    body: input.body,\n    options,\n});\n/**\n * Init Email Recovery\n *\n * Initializes a new email recovery\n *\n * `POST /public/v1/submit/init_user_email_recovery`\n */\nconst initUserEmailRecovery = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/init_user_email_recovery\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `InitUserEmailRecovery` request, ready to be POSTed to Turnkey.\n *\n * See {@link InitUserEmailRecovery}\n */\nconst signInitUserEmailRecovery = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/init_user_email_recovery\",\n    body: input.body,\n    options,\n});\n/**\n * Recover a user\n *\n * Completes the process of recovering a user by adding an authenticator\n *\n * `POST /public/v1/submit/recover_user`\n */\nconst recoverUser = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/recover_user\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `RecoverUser` request, ready to be POSTed to Turnkey.\n *\n * See {@link RecoverUser}\n */\nconst signRecoverUser = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/recover_user\",\n    body: input.body,\n    options,\n});\n/**\n * Reject Activity\n *\n * Reject an Activity\n *\n * `POST /public/v1/submit/reject_activity`\n */\nconst rejectActivity = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/reject_activity\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `RejectActivity` request, ready to be POSTed to Turnkey.\n *\n * See {@link RejectActivity}\n */\nconst signRejectActivity = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/reject_activity\",\n    body: input.body,\n    options,\n});\n/**\n * Remove Organization Feature\n *\n * Removes an organization feature\n *\n * `POST /public/v1/submit/remove_organization_feature`\n */\nconst removeOrganizationFeature = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/remove_organization_feature\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `RemoveOrganizationFeature` request, ready to be POSTed to Turnkey.\n *\n * See {@link RemoveOrganizationFeature}\n */\nconst signRemoveOrganizationFeature = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/remove_organization_feature\",\n    body: input.body,\n    options,\n});\n/**\n * Set Organization Feature\n *\n * Sets an organization feature\n *\n * `POST /public/v1/submit/set_organization_feature`\n */\nconst setOrganizationFeature = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/set_organization_feature\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `SetOrganizationFeature` request, ready to be POSTed to Turnkey.\n *\n * See {@link SetOrganizationFeature}\n */\nconst signSetOrganizationFeature = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/set_organization_feature\",\n    body: input.body,\n    options,\n});\n/**\n * Sign Raw Payload\n *\n * Sign a raw payload\n *\n * `POST /public/v1/submit/sign_raw_payload`\n */\nconst signRawPayload = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/sign_raw_payload\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `SignRawPayload` request, ready to be POSTed to Turnkey.\n *\n * See {@link SignRawPayload}\n */\nconst signSignRawPayload = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/sign_raw_payload\",\n    body: input.body,\n    options,\n});\n/**\n * Sign Transaction\n *\n * Sign a transaction\n *\n * `POST /public/v1/submit/sign_transaction`\n */\nconst signTransaction = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/sign_transaction\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `SignTransaction` request, ready to be POSTed to Turnkey.\n *\n * See {@link SignTransaction}\n */\nconst signSignTransaction = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/sign_transaction\",\n    body: input.body,\n    options,\n});\n/**\n * Update Policy\n *\n * Update an existing Policy\n *\n * `POST /public/v1/submit/update_policy`\n */\nconst updatePolicy = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/update_policy\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `UpdatePolicy` request, ready to be POSTed to Turnkey.\n *\n * See {@link UpdatePolicy}\n */\nconst signUpdatePolicy = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/update_policy\",\n    body: input.body,\n    options,\n});\n/**\n * Update Private Key Tag\n *\n * Update human-readable name or associated private keys. Note that this activity is atomic: all of the updates will succeed at once, or all of them will fail.\n *\n * `POST /public/v1/submit/update_private_key_tag`\n */\nconst updatePrivateKeyTag = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/update_private_key_tag\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `UpdatePrivateKeyTag` request, ready to be POSTed to Turnkey.\n *\n * See {@link UpdatePrivateKeyTag}\n */\nconst signUpdatePrivateKeyTag = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/update_private_key_tag\",\n    body: input.body,\n    options,\n});\n/**\n * Update Root Quorum\n *\n * Set the threshold and members of the root quorum. This must be approved by the current root quorum.\n *\n * `POST /public/v1/submit/update_root_quorum`\n */\nconst updateRootQuorum = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/update_root_quorum\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `UpdateRootQuorum` request, ready to be POSTed to Turnkey.\n *\n * See {@link UpdateRootQuorum}\n */\nconst signUpdateRootQuorum = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/update_root_quorum\",\n    body: input.body,\n    options,\n});\n/**\n * Update User\n *\n * Update a User in an existing Organization\n *\n * `POST /public/v1/submit/update_user`\n */\nconst updateUser = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/update_user\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `UpdateUser` request, ready to be POSTed to Turnkey.\n *\n * See {@link UpdateUser}\n */\nconst signUpdateUser = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/update_user\",\n    body: input.body,\n    options,\n});\n/**\n * Update User Tag\n *\n * Update human-readable name or associated users. Note that this activity is atomic: all of the updates will succeed at once, or all of them will fail.\n *\n * `POST /public/v1/submit/update_user_tag`\n */\nconst updateUserTag = (input) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/public/v1/submit/update_user_tag\",\n    method: \"POST\",\n    body: input.body,\n});\n/**\n * Request a WebAuthn assertion and return a signed `UpdateUserTag` request, ready to be POSTed to Turnkey.\n *\n * See {@link UpdateUserTag}\n */\nconst signUpdateUserTag = (input, options) => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/public/v1/submit/update_user_tag\",\n    body: input.body,\n    options,\n});\n/**\n * `POST /tkhq/api/v1/noop-codegen-anchor`\n */\nconst nOOPCodegenAnchor = () => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.request)({\n    uri: \"/tkhq/api/v1/noop-codegen-anchor\",\n    method: \"POST\",\n});\n/**\n * Request a WebAuthn assertion and return a signed `NOOPCodegenAnchor` request, ready to be POSTed to Turnkey.\n *\n * See {@link NOOPCodegenAnchor}\n */\nconst signNOOPCodegenAnchor = () => (0,_base_mjs__WEBPACK_IMPORTED_MODULE_0__.signedRequest)({\n    uri: \"/tkhq/api/v1/noop-codegen-anchor\",\n});\n\n\n//# sourceMappingURL=public_api.fetcher.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvc29sYW5hL25vZGVfbW9kdWxlcy9AdHVybmtleS9odHRwL2Rpc3QvX19nZW5lcmF0ZWRfXy9zZXJ2aWNlcy9jb29yZGluYXRvci9wdWJsaWMvdjEvcHVibGljX2FwaS5mZXRjaGVyLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFpRTs7QUFFakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixrREFBTztBQUN0QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsNENBQTRDLHdEQUFhO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixrREFBTztBQUNwQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsMENBQTBDLHdEQUFhO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrREFBTztBQUNyQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsMkNBQTJDLHdEQUFhO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxrREFBTztBQUMzQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsaURBQWlELHdEQUFhO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxrREFBTztBQUM1QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esa0RBQWtELHdEQUFhO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxrREFBTztBQUMxQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsZ0RBQWdELHdEQUFhO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixrREFBTztBQUNwQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsMENBQTBDLHdEQUFhO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrREFBTztBQUN4QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsOENBQThDLHdEQUFhO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrREFBTztBQUNsQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esd0NBQXdDLHdEQUFhO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixrREFBTztBQUNwQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsMENBQTBDLHdEQUFhO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrREFBTztBQUN4QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsOENBQThDLHdEQUFhO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixrREFBTztBQUN0QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsNENBQTRDLHdEQUFhO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxrREFBTztBQUM3QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsbURBQW1ELHdEQUFhO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxrREFBTztBQUN6QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsK0NBQStDLHdEQUFhO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxrREFBTztBQUN2QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsNkNBQTZDLHdEQUFhO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrREFBTztBQUNuQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EseUNBQXlDLHdEQUFhO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxrREFBTztBQUM1QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esa0RBQWtELHdEQUFhO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrREFBTztBQUNyQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsMkNBQTJDLHdEQUFhO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixrREFBTztBQUNwQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsMENBQTBDLHdEQUFhO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxrREFBTztBQUMxQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsZ0RBQWdELHdEQUFhO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrREFBTztBQUN4QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsOENBQThDLHdEQUFhO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxrREFBTztBQUM3QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsbURBQW1ELHdEQUFhO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxrREFBTztBQUMvQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EscURBQXFELHdEQUFhO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxrREFBTztBQUM1QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esa0RBQWtELHdEQUFhO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxrREFBTztBQUN2QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsNkNBQTZDLHdEQUFhO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxrREFBTztBQUM5QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esb0RBQW9ELHdEQUFhO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxrREFBTztBQUM1QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esa0RBQWtELHdEQUFhO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxrREFBTztBQUNoRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esc0RBQXNELHdEQUFhO0FBQ25FO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrREFBTztBQUN4QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsOENBQThDLHdEQUFhO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixrREFBTztBQUN0QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsNENBQTRDLHdEQUFhO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxrREFBTztBQUN2QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsNkNBQTZDLHdEQUFhO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxrREFBTztBQUMvQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EscURBQXFELHdEQUFhO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrREFBTztBQUN4QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsOENBQThDLHdEQUFhO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxrREFBTztBQUMvQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EscURBQXFELHdEQUFhO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxrREFBTztBQUMzQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsaURBQWlELHdEQUFhO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxrREFBTztBQUN2QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsNkNBQTZDLHdEQUFhO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixrREFBTztBQUNwQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsMENBQTBDLHdEQUFhO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxrREFBTztBQUMzQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsaURBQWlELHdEQUFhO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxrREFBTztBQUN2QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsNkNBQTZDLHdEQUFhO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxrREFBTztBQUM5QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esb0RBQW9ELHdEQUFhO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxrREFBTztBQUNoRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esc0RBQXNELHdEQUFhO0FBQ25FO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixrREFBTztBQUN0QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsNENBQTRDLHdEQUFhO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxrREFBTztBQUN6QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsK0NBQStDLHdEQUFhO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxrREFBTztBQUNwRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsMERBQTBELHdEQUFhO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxrREFBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsdURBQXVELHdEQUFhO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxrREFBTztBQUN6QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsK0NBQStDLHdEQUFhO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxrREFBTztBQUMxQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsZ0RBQWdELHdEQUFhO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxrREFBTztBQUN2QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsNkNBQTZDLHdEQUFhO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxrREFBTztBQUM5QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esb0RBQW9ELHdEQUFhO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxrREFBTztBQUMzQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsaURBQWlELHdEQUFhO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrREFBTztBQUNyQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsMkNBQTJDLHdEQUFhO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrREFBTztBQUN4QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsOENBQThDLHdEQUFhO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msa0RBQU87QUFDdkM7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxvQ0FBb0Msd0RBQWE7QUFDakQ7QUFDQSxDQUFDOztBQUVxNkQ7QUFDdDZEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbnVyc2VibG9jLy4vbm9kZV9tb2R1bGVzL0B0dXJua2V5L3NvbGFuYS9ub2RlX21vZHVsZXMvQHR1cm5rZXkvaHR0cC9kaXN0L19fZ2VuZXJhdGVkX18vc2VydmljZXMvY29vcmRpbmF0b3IvcHVibGljL3YxL3B1YmxpY19hcGkuZmV0Y2hlci5tanM/YzYxZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByZXF1ZXN0LCBzaWduZWRSZXF1ZXN0IH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vYmFzZS5tanMnO1xuXG4vKiBAZ2VuZXJhdGVkIGJ5IGBAdHVybmtleS9mZXRjaGVyc2AuIERPIE5PVCBFRElUIEJZIEhBTkQgKi9cbi8qKlxuICogR2V0IEFjdGl2aXR5XG4gKlxuICogR2V0IGRldGFpbHMgYWJvdXQgYW4gQWN0aXZpdHlcbiAqXG4gKiBgUE9TVCAvcHVibGljL3YxL3F1ZXJ5L2dldF9hY3Rpdml0eWBcbiAqL1xuY29uc3QgZ2V0QWN0aXZpdHkgPSAoaW5wdXQpID0+IHJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3F1ZXJ5L2dldF9hY3Rpdml0eVwiLFxuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbn0pO1xuLyoqXG4gKiBSZXF1ZXN0IGEgV2ViQXV0aG4gYXNzZXJ0aW9uIGFuZCByZXR1cm4gYSBzaWduZWQgYEdldEFjdGl2aXR5YCByZXF1ZXN0LCByZWFkeSB0byBiZSBQT1NUZWQgdG8gVHVybmtleS5cbiAqXG4gKiBTZWUge0BsaW5rIEdldEFjdGl2aXR5fVxuICovXG5jb25zdCBzaWduR2V0QWN0aXZpdHkgPSAoaW5wdXQsIG9wdGlvbnMpID0+IHNpZ25lZFJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3F1ZXJ5L2dldF9hY3Rpdml0eVwiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG4gICAgb3B0aW9ucyxcbn0pO1xuLyoqXG4gKiBHZXQgQVBJIGtleVxuICpcbiAqIEdldCBkZXRhaWxzIGFib3V0IGFuIEFQSSBrZXlcbiAqXG4gKiBgUE9TVCAvcHVibGljL3YxL3F1ZXJ5L2dldF9hcGlfa2V5YFxuICovXG5jb25zdCBnZXRBcGlLZXkgPSAoaW5wdXQpID0+IHJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3F1ZXJ5L2dldF9hcGlfa2V5XCIsXG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxufSk7XG4vKipcbiAqIFJlcXVlc3QgYSBXZWJBdXRobiBhc3NlcnRpb24gYW5kIHJldHVybiBhIHNpZ25lZCBgR2V0QXBpS2V5YCByZXF1ZXN0LCByZWFkeSB0byBiZSBQT1NUZWQgdG8gVHVybmtleS5cbiAqXG4gKiBTZWUge0BsaW5rIEdldEFwaUtleX1cbiAqL1xuY29uc3Qgc2lnbkdldEFwaUtleSA9IChpbnB1dCwgb3B0aW9ucykgPT4gc2lnbmVkUmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvcXVlcnkvZ2V0X2FwaV9rZXlcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxuICAgIG9wdGlvbnMsXG59KTtcbi8qKlxuICogR2V0IEFQSSBrZXlcbiAqXG4gKiBHZXQgZGV0YWlscyBhYm91dCBBUEkga2V5cyBmb3IgYSB1c2VyXG4gKlxuICogYFBPU1QgL3B1YmxpYy92MS9xdWVyeS9nZXRfYXBpX2tleXNgXG4gKi9cbmNvbnN0IGdldEFwaUtleXMgPSAoaW5wdXQpID0+IHJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3F1ZXJ5L2dldF9hcGlfa2V5c1wiLFxuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbn0pO1xuLyoqXG4gKiBSZXF1ZXN0IGEgV2ViQXV0aG4gYXNzZXJ0aW9uIGFuZCByZXR1cm4gYSBzaWduZWQgYEdldEFwaUtleXNgIHJlcXVlc3QsIHJlYWR5IHRvIGJlIFBPU1RlZCB0byBUdXJua2V5LlxuICpcbiAqIFNlZSB7QGxpbmsgR2V0QXBpS2V5c31cbiAqL1xuY29uc3Qgc2lnbkdldEFwaUtleXMgPSAoaW5wdXQsIG9wdGlvbnMpID0+IHNpZ25lZFJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3F1ZXJ5L2dldF9hcGlfa2V5c1wiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG4gICAgb3B0aW9ucyxcbn0pO1xuLyoqXG4gKiBHZXQgQXV0aGVudGljYXRvclxuICpcbiAqIEdldCBkZXRhaWxzIGFib3V0IGFuIGF1dGhlbnRpY2F0b3JcbiAqXG4gKiBgUE9TVCAvcHVibGljL3YxL3F1ZXJ5L2dldF9hdXRoZW50aWNhdG9yYFxuICovXG5jb25zdCBnZXRBdXRoZW50aWNhdG9yID0gKGlucHV0KSA9PiByZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9xdWVyeS9nZXRfYXV0aGVudGljYXRvclwiLFxuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbn0pO1xuLyoqXG4gKiBSZXF1ZXN0IGEgV2ViQXV0aG4gYXNzZXJ0aW9uIGFuZCByZXR1cm4gYSBzaWduZWQgYEdldEF1dGhlbnRpY2F0b3JgIHJlcXVlc3QsIHJlYWR5IHRvIGJlIFBPU1RlZCB0byBUdXJua2V5LlxuICpcbiAqIFNlZSB7QGxpbmsgR2V0QXV0aGVudGljYXRvcn1cbiAqL1xuY29uc3Qgc2lnbkdldEF1dGhlbnRpY2F0b3IgPSAoaW5wdXQsIG9wdGlvbnMpID0+IHNpZ25lZFJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3F1ZXJ5L2dldF9hdXRoZW50aWNhdG9yXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbiAgICBvcHRpb25zLFxufSk7XG4vKipcbiAqIEdldCBBdXRoZW50aWNhdG9yc1xuICpcbiAqIEdldCBkZXRhaWxzIGFib3V0IGF1dGhlbnRpY2F0b3JzIGZvciBhIHVzZXJcbiAqXG4gKiBgUE9TVCAvcHVibGljL3YxL3F1ZXJ5L2dldF9hdXRoZW50aWNhdG9yc2BcbiAqL1xuY29uc3QgZ2V0QXV0aGVudGljYXRvcnMgPSAoaW5wdXQpID0+IHJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3F1ZXJ5L2dldF9hdXRoZW50aWNhdG9yc1wiLFxuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbn0pO1xuLyoqXG4gKiBSZXF1ZXN0IGEgV2ViQXV0aG4gYXNzZXJ0aW9uIGFuZCByZXR1cm4gYSBzaWduZWQgYEdldEF1dGhlbnRpY2F0b3JzYCByZXF1ZXN0LCByZWFkeSB0byBiZSBQT1NUZWQgdG8gVHVybmtleS5cbiAqXG4gKiBTZWUge0BsaW5rIEdldEF1dGhlbnRpY2F0b3JzfVxuICovXG5jb25zdCBzaWduR2V0QXV0aGVudGljYXRvcnMgPSAoaW5wdXQsIG9wdGlvbnMpID0+IHNpZ25lZFJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3F1ZXJ5L2dldF9hdXRoZW50aWNhdG9yc1wiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG4gICAgb3B0aW9ucyxcbn0pO1xuLyoqXG4gKiBHZXQgT3JnYW5pemF0aW9uXG4gKlxuICogR2V0IGRldGFpbHMgYWJvdXQgYW4gT3JnYW5pemF0aW9uXG4gKlxuICogYFBPU1QgL3B1YmxpYy92MS9xdWVyeS9nZXRfb3JnYW5pemF0aW9uYFxuICovXG5jb25zdCBnZXRPcmdhbml6YXRpb24gPSAoaW5wdXQpID0+IHJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3F1ZXJ5L2dldF9vcmdhbml6YXRpb25cIixcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG59KTtcbi8qKlxuICogUmVxdWVzdCBhIFdlYkF1dGhuIGFzc2VydGlvbiBhbmQgcmV0dXJuIGEgc2lnbmVkIGBHZXRPcmdhbml6YXRpb25gIHJlcXVlc3QsIHJlYWR5IHRvIGJlIFBPU1RlZCB0byBUdXJua2V5LlxuICpcbiAqIFNlZSB7QGxpbmsgR2V0T3JnYW5pemF0aW9ufVxuICovXG5jb25zdCBzaWduR2V0T3JnYW5pemF0aW9uID0gKGlucHV0LCBvcHRpb25zKSA9PiBzaWduZWRSZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9xdWVyeS9nZXRfb3JnYW5pemF0aW9uXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbiAgICBvcHRpb25zLFxufSk7XG4vKipcbiAqIEdldCBQb2xpY3lcbiAqXG4gKiBHZXQgZGV0YWlscyBhYm91dCBhIFBvbGljeVxuICpcbiAqIGBQT1NUIC9wdWJsaWMvdjEvcXVlcnkvZ2V0X3BvbGljeWBcbiAqL1xuY29uc3QgZ2V0UG9saWN5ID0gKGlucHV0KSA9PiByZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9xdWVyeS9nZXRfcG9saWN5XCIsXG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxufSk7XG4vKipcbiAqIFJlcXVlc3QgYSBXZWJBdXRobiBhc3NlcnRpb24gYW5kIHJldHVybiBhIHNpZ25lZCBgR2V0UG9saWN5YCByZXF1ZXN0LCByZWFkeSB0byBiZSBQT1NUZWQgdG8gVHVybmtleS5cbiAqXG4gKiBTZWUge0BsaW5rIEdldFBvbGljeX1cbiAqL1xuY29uc3Qgc2lnbkdldFBvbGljeSA9IChpbnB1dCwgb3B0aW9ucykgPT4gc2lnbmVkUmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvcXVlcnkvZ2V0X3BvbGljeVwiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG4gICAgb3B0aW9ucyxcbn0pO1xuLyoqXG4gKiBHZXQgUHJpdmF0ZSBLZXlcbiAqXG4gKiBHZXQgZGV0YWlscyBhYm91dCBhIFByaXZhdGUgS2V5XG4gKlxuICogYFBPU1QgL3B1YmxpYy92MS9xdWVyeS9nZXRfcHJpdmF0ZV9rZXlgXG4gKi9cbmNvbnN0IGdldFByaXZhdGVLZXkgPSAoaW5wdXQpID0+IHJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3F1ZXJ5L2dldF9wcml2YXRlX2tleVwiLFxuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbn0pO1xuLyoqXG4gKiBSZXF1ZXN0IGEgV2ViQXV0aG4gYXNzZXJ0aW9uIGFuZCByZXR1cm4gYSBzaWduZWQgYEdldFByaXZhdGVLZXlgIHJlcXVlc3QsIHJlYWR5IHRvIGJlIFBPU1RlZCB0byBUdXJua2V5LlxuICpcbiAqIFNlZSB7QGxpbmsgR2V0UHJpdmF0ZUtleX1cbiAqL1xuY29uc3Qgc2lnbkdldFByaXZhdGVLZXkgPSAoaW5wdXQsIG9wdGlvbnMpID0+IHNpZ25lZFJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3F1ZXJ5L2dldF9wcml2YXRlX2tleVwiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG4gICAgb3B0aW9ucyxcbn0pO1xuLyoqXG4gKiBHZXQgVXNlclxuICpcbiAqIEdldCBkZXRhaWxzIGFib3V0IGEgVXNlclxuICpcbiAqIGBQT1NUIC9wdWJsaWMvdjEvcXVlcnkvZ2V0X3VzZXJgXG4gKi9cbmNvbnN0IGdldFVzZXIgPSAoaW5wdXQpID0+IHJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3F1ZXJ5L2dldF91c2VyXCIsXG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxufSk7XG4vKipcbiAqIFJlcXVlc3QgYSBXZWJBdXRobiBhc3NlcnRpb24gYW5kIHJldHVybiBhIHNpZ25lZCBgR2V0VXNlcmAgcmVxdWVzdCwgcmVhZHkgdG8gYmUgUE9TVGVkIHRvIFR1cm5rZXkuXG4gKlxuICogU2VlIHtAbGluayBHZXRVc2VyfVxuICovXG5jb25zdCBzaWduR2V0VXNlciA9IChpbnB1dCwgb3B0aW9ucykgPT4gc2lnbmVkUmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvcXVlcnkvZ2V0X3VzZXJcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxuICAgIG9wdGlvbnMsXG59KTtcbi8qKlxuICogR2V0IFdhbGxldFxuICpcbiAqIEdldCBkZXRhaWxzIGFib3V0IGEgV2FsbGV0XG4gKlxuICogYFBPU1QgL3B1YmxpYy92MS9xdWVyeS9nZXRfd2FsbGV0YFxuICovXG5jb25zdCBnZXRXYWxsZXQgPSAoaW5wdXQpID0+IHJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3F1ZXJ5L2dldF93YWxsZXRcIixcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG59KTtcbi8qKlxuICogUmVxdWVzdCBhIFdlYkF1dGhuIGFzc2VydGlvbiBhbmQgcmV0dXJuIGEgc2lnbmVkIGBHZXRXYWxsZXRgIHJlcXVlc3QsIHJlYWR5IHRvIGJlIFBPU1RlZCB0byBUdXJua2V5LlxuICpcbiAqIFNlZSB7QGxpbmsgR2V0V2FsbGV0fVxuICovXG5jb25zdCBzaWduR2V0V2FsbGV0ID0gKGlucHV0LCBvcHRpb25zKSA9PiBzaWduZWRSZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9xdWVyeS9nZXRfd2FsbGV0XCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbiAgICBvcHRpb25zLFxufSk7XG4vKipcbiAqIExpc3QgQWN0aXZpdGllc1xuICpcbiAqIExpc3QgYWxsIEFjdGl2aXRpZXMgd2l0aGluIGFuIE9yZ2FuaXphdGlvblxuICpcbiAqIGBQT1NUIC9wdWJsaWMvdjEvcXVlcnkvbGlzdF9hY3Rpdml0aWVzYFxuICovXG5jb25zdCBnZXRBY3Rpdml0aWVzID0gKGlucHV0KSA9PiByZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9xdWVyeS9saXN0X2FjdGl2aXRpZXNcIixcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG59KTtcbi8qKlxuICogUmVxdWVzdCBhIFdlYkF1dGhuIGFzc2VydGlvbiBhbmQgcmV0dXJuIGEgc2lnbmVkIGBHZXRBY3Rpdml0aWVzYCByZXF1ZXN0LCByZWFkeSB0byBiZSBQT1NUZWQgdG8gVHVybmtleS5cbiAqXG4gKiBTZWUge0BsaW5rIEdldEFjdGl2aXRpZXN9XG4gKi9cbmNvbnN0IHNpZ25HZXRBY3Rpdml0aWVzID0gKGlucHV0LCBvcHRpb25zKSA9PiBzaWduZWRSZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9xdWVyeS9saXN0X2FjdGl2aXRpZXNcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxuICAgIG9wdGlvbnMsXG59KTtcbi8qKlxuICogTGlzdCBQb2xpY2llc1xuICpcbiAqIExpc3QgYWxsIFBvbGljaWVzIHdpdGhpbiBhbiBPcmdhbml6YXRpb25cbiAqXG4gKiBgUE9TVCAvcHVibGljL3YxL3F1ZXJ5L2xpc3RfcG9saWNpZXNgXG4gKi9cbmNvbnN0IGdldFBvbGljaWVzID0gKGlucHV0KSA9PiByZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9xdWVyeS9saXN0X3BvbGljaWVzXCIsXG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxufSk7XG4vKipcbiAqIFJlcXVlc3QgYSBXZWJBdXRobiBhc3NlcnRpb24gYW5kIHJldHVybiBhIHNpZ25lZCBgR2V0UG9saWNpZXNgIHJlcXVlc3QsIHJlYWR5IHRvIGJlIFBPU1RlZCB0byBUdXJua2V5LlxuICpcbiAqIFNlZSB7QGxpbmsgR2V0UG9saWNpZXN9XG4gKi9cbmNvbnN0IHNpZ25HZXRQb2xpY2llcyA9IChpbnB1dCwgb3B0aW9ucykgPT4gc2lnbmVkUmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvcXVlcnkvbGlzdF9wb2xpY2llc1wiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG4gICAgb3B0aW9ucyxcbn0pO1xuLyoqXG4gKiBMaXN0IFByaXZhdGUgS2V5IFRhZ3NcbiAqXG4gKiBMaXN0IGFsbCBQcml2YXRlIEtleSBUYWdzIHdpdGhpbiBhbiBPcmdhbml6YXRpb25cbiAqXG4gKiBgUE9TVCAvcHVibGljL3YxL3F1ZXJ5L2xpc3RfcHJpdmF0ZV9rZXlfdGFnc2BcbiAqL1xuY29uc3QgbGlzdFByaXZhdGVLZXlUYWdzID0gKGlucHV0KSA9PiByZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9xdWVyeS9saXN0X3ByaXZhdGVfa2V5X3RhZ3NcIixcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG59KTtcbi8qKlxuICogUmVxdWVzdCBhIFdlYkF1dGhuIGFzc2VydGlvbiBhbmQgcmV0dXJuIGEgc2lnbmVkIGBMaXN0UHJpdmF0ZUtleVRhZ3NgIHJlcXVlc3QsIHJlYWR5IHRvIGJlIFBPU1RlZCB0byBUdXJua2V5LlxuICpcbiAqIFNlZSB7QGxpbmsgTGlzdFByaXZhdGVLZXlUYWdzfVxuICovXG5jb25zdCBzaWduTGlzdFByaXZhdGVLZXlUYWdzID0gKGlucHV0LCBvcHRpb25zKSA9PiBzaWduZWRSZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9xdWVyeS9saXN0X3ByaXZhdGVfa2V5X3RhZ3NcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxuICAgIG9wdGlvbnMsXG59KTtcbi8qKlxuICogTGlzdCBQcml2YXRlIEtleXNcbiAqXG4gKiBMaXN0IGFsbCBQcml2YXRlIEtleXMgd2l0aGluIGFuIE9yZ2FuaXphdGlvblxuICpcbiAqIGBQT1NUIC9wdWJsaWMvdjEvcXVlcnkvbGlzdF9wcml2YXRlX2tleXNgXG4gKi9cbmNvbnN0IGdldFByaXZhdGVLZXlzID0gKGlucHV0KSA9PiByZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9xdWVyeS9saXN0X3ByaXZhdGVfa2V5c1wiLFxuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbn0pO1xuLyoqXG4gKiBSZXF1ZXN0IGEgV2ViQXV0aG4gYXNzZXJ0aW9uIGFuZCByZXR1cm4gYSBzaWduZWQgYEdldFByaXZhdGVLZXlzYCByZXF1ZXN0LCByZWFkeSB0byBiZSBQT1NUZWQgdG8gVHVybmtleS5cbiAqXG4gKiBTZWUge0BsaW5rIEdldFByaXZhdGVLZXlzfVxuICovXG5jb25zdCBzaWduR2V0UHJpdmF0ZUtleXMgPSAoaW5wdXQsIG9wdGlvbnMpID0+IHNpZ25lZFJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3F1ZXJ5L2xpc3RfcHJpdmF0ZV9rZXlzXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbiAgICBvcHRpb25zLFxufSk7XG4vKipcbiAqIExpc3QgVXNlciBUYWdzXG4gKlxuICogTGlzdCBhbGwgVXNlciBUYWdzIHdpdGhpbiBhbiBPcmdhbml6YXRpb25cbiAqXG4gKiBgUE9TVCAvcHVibGljL3YxL3F1ZXJ5L2xpc3RfdXNlcl90YWdzYFxuICovXG5jb25zdCBsaXN0VXNlclRhZ3MgPSAoaW5wdXQpID0+IHJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3F1ZXJ5L2xpc3RfdXNlcl90YWdzXCIsXG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxufSk7XG4vKipcbiAqIFJlcXVlc3QgYSBXZWJBdXRobiBhc3NlcnRpb24gYW5kIHJldHVybiBhIHNpZ25lZCBgTGlzdFVzZXJUYWdzYCByZXF1ZXN0LCByZWFkeSB0byBiZSBQT1NUZWQgdG8gVHVybmtleS5cbiAqXG4gKiBTZWUge0BsaW5rIExpc3RVc2VyVGFnc31cbiAqL1xuY29uc3Qgc2lnbkxpc3RVc2VyVGFncyA9IChpbnB1dCwgb3B0aW9ucykgPT4gc2lnbmVkUmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvcXVlcnkvbGlzdF91c2VyX3RhZ3NcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxuICAgIG9wdGlvbnMsXG59KTtcbi8qKlxuICogTGlzdCBVc2Vyc1xuICpcbiAqIExpc3QgYWxsIFVzZXJzIHdpdGhpbiBhbiBPcmdhbml6YXRpb25cbiAqXG4gKiBgUE9TVCAvcHVibGljL3YxL3F1ZXJ5L2xpc3RfdXNlcnNgXG4gKi9cbmNvbnN0IGdldFVzZXJzID0gKGlucHV0KSA9PiByZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9xdWVyeS9saXN0X3VzZXJzXCIsXG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxufSk7XG4vKipcbiAqIFJlcXVlc3QgYSBXZWJBdXRobiBhc3NlcnRpb24gYW5kIHJldHVybiBhIHNpZ25lZCBgR2V0VXNlcnNgIHJlcXVlc3QsIHJlYWR5IHRvIGJlIFBPU1RlZCB0byBUdXJua2V5LlxuICpcbiAqIFNlZSB7QGxpbmsgR2V0VXNlcnN9XG4gKi9cbmNvbnN0IHNpZ25HZXRVc2VycyA9IChpbnB1dCwgb3B0aW9ucykgPT4gc2lnbmVkUmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvcXVlcnkvbGlzdF91c2Vyc1wiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG4gICAgb3B0aW9ucyxcbn0pO1xuLyoqXG4gKiBMaXN0IFdhbGxldHMgQWNjb3VudHNcbiAqXG4gKiBMaXN0IGFsbCBBY2NvdW50cyB3aXJoaW4gYSBXYWxsZXRcbiAqXG4gKiBgUE9TVCAvcHVibGljL3YxL3F1ZXJ5L2xpc3Rfd2FsbGV0X2FjY291bnRzYFxuICovXG5jb25zdCBnZXRXYWxsZXRBY2NvdW50cyA9IChpbnB1dCkgPT4gcmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvcXVlcnkvbGlzdF93YWxsZXRfYWNjb3VudHNcIixcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG59KTtcbi8qKlxuICogUmVxdWVzdCBhIFdlYkF1dGhuIGFzc2VydGlvbiBhbmQgcmV0dXJuIGEgc2lnbmVkIGBHZXRXYWxsZXRBY2NvdW50c2AgcmVxdWVzdCwgcmVhZHkgdG8gYmUgUE9TVGVkIHRvIFR1cm5rZXkuXG4gKlxuICogU2VlIHtAbGluayBHZXRXYWxsZXRBY2NvdW50c31cbiAqL1xuY29uc3Qgc2lnbkdldFdhbGxldEFjY291bnRzID0gKGlucHV0LCBvcHRpb25zKSA9PiBzaWduZWRSZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9xdWVyeS9saXN0X3dhbGxldF9hY2NvdW50c1wiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG4gICAgb3B0aW9ucyxcbn0pO1xuLyoqXG4gKiBMaXN0IFdhbGxldHNcbiAqXG4gKiBMaXN0IGFsbCBXYWxsZXRzIHdpdGhpbiBhbiBPcmdhbml6YXRpb25cbiAqXG4gKiBgUE9TVCAvcHVibGljL3YxL3F1ZXJ5L2xpc3Rfd2FsbGV0c2BcbiAqL1xuY29uc3QgZ2V0V2FsbGV0cyA9IChpbnB1dCkgPT4gcmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvcXVlcnkvbGlzdF93YWxsZXRzXCIsXG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxufSk7XG4vKipcbiAqIFJlcXVlc3QgYSBXZWJBdXRobiBhc3NlcnRpb24gYW5kIHJldHVybiBhIHNpZ25lZCBgR2V0V2FsbGV0c2AgcmVxdWVzdCwgcmVhZHkgdG8gYmUgUE9TVGVkIHRvIFR1cm5rZXkuXG4gKlxuICogU2VlIHtAbGluayBHZXRXYWxsZXRzfVxuICovXG5jb25zdCBzaWduR2V0V2FsbGV0cyA9IChpbnB1dCwgb3B0aW9ucykgPT4gc2lnbmVkUmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvcXVlcnkvbGlzdF93YWxsZXRzXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbiAgICBvcHRpb25zLFxufSk7XG4vKipcbiAqIFdobyBhbSBJP1xuICpcbiAqIEdldCBiYXNpYyBpbmZvcm1hdGlvbiBhYm91dCB5b3VyIGN1cnJlbnQgQVBJIG9yIFdlYkF1dGhOIHVzZXIgYW5kIHRoZWlyIG9yZ2FuaXphdGlvbi4gQWZmb3JkcyBTdWItT3JnYW5pemF0aW9uIGxvb2sgdXBzIHZpYSBQYXJlbnQgT3JnYW5pemF0aW9uIGZvciBXZWJBdXRoTiB1c2Vycy5cbiAqXG4gKiBgUE9TVCAvcHVibGljL3YxL3F1ZXJ5L3dob2FtaWBcbiAqL1xuY29uc3QgZ2V0V2hvYW1pID0gKGlucHV0KSA9PiByZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9xdWVyeS93aG9hbWlcIixcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG59KTtcbi8qKlxuICogUmVxdWVzdCBhIFdlYkF1dGhuIGFzc2VydGlvbiBhbmQgcmV0dXJuIGEgc2lnbmVkIGBHZXRXaG9hbWlgIHJlcXVlc3QsIHJlYWR5IHRvIGJlIFBPU1RlZCB0byBUdXJua2V5LlxuICpcbiAqIFNlZSB7QGxpbmsgR2V0V2hvYW1pfVxuICovXG5jb25zdCBzaWduR2V0V2hvYW1pID0gKGlucHV0LCBvcHRpb25zKSA9PiBzaWduZWRSZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9xdWVyeS93aG9hbWlcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxuICAgIG9wdGlvbnMsXG59KTtcbi8qKlxuICogQXBwcm92ZSBBY3Rpdml0eVxuICpcbiAqIEFwcHJvdmUgYW4gQWN0aXZpdHlcbiAqXG4gKiBgUE9TVCAvcHVibGljL3YxL3N1Ym1pdC9hcHByb3ZlX2FjdGl2aXR5YFxuICovXG5jb25zdCBhcHByb3ZlQWN0aXZpdHkgPSAoaW5wdXQpID0+IHJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3N1Ym1pdC9hcHByb3ZlX2FjdGl2aXR5XCIsXG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxufSk7XG4vKipcbiAqIFJlcXVlc3QgYSBXZWJBdXRobiBhc3NlcnRpb24gYW5kIHJldHVybiBhIHNpZ25lZCBgQXBwcm92ZUFjdGl2aXR5YCByZXF1ZXN0LCByZWFkeSB0byBiZSBQT1NUZWQgdG8gVHVybmtleS5cbiAqXG4gKiBTZWUge0BsaW5rIEFwcHJvdmVBY3Rpdml0eX1cbiAqL1xuY29uc3Qgc2lnbkFwcHJvdmVBY3Rpdml0eSA9IChpbnB1dCwgb3B0aW9ucykgPT4gc2lnbmVkUmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvc3VibWl0L2FwcHJvdmVfYWN0aXZpdHlcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxuICAgIG9wdGlvbnMsXG59KTtcbi8qKlxuICogQ3JlYXRlIEFQSSBLZXlzXG4gKlxuICogQWRkIGFwaSBrZXlzIHRvIGFuIGV4aXN0aW5nIFVzZXJcbiAqXG4gKiBgUE9TVCAvcHVibGljL3YxL3N1Ym1pdC9jcmVhdGVfYXBpX2tleXNgXG4gKi9cbmNvbnN0IGNyZWF0ZUFwaUtleXMgPSAoaW5wdXQpID0+IHJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3N1Ym1pdC9jcmVhdGVfYXBpX2tleXNcIixcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG59KTtcbi8qKlxuICogUmVxdWVzdCBhIFdlYkF1dGhuIGFzc2VydGlvbiBhbmQgcmV0dXJuIGEgc2lnbmVkIGBDcmVhdGVBcGlLZXlzYCByZXF1ZXN0LCByZWFkeSB0byBiZSBQT1NUZWQgdG8gVHVybmtleS5cbiAqXG4gKiBTZWUge0BsaW5rIENyZWF0ZUFwaUtleXN9XG4gKi9cbmNvbnN0IHNpZ25DcmVhdGVBcGlLZXlzID0gKGlucHV0LCBvcHRpb25zKSA9PiBzaWduZWRSZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9zdWJtaXQvY3JlYXRlX2FwaV9rZXlzXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbiAgICBvcHRpb25zLFxufSk7XG4vKipcbiAqIENyZWF0ZSBBUEktb25seSBVc2Vyc1xuICpcbiAqIENyZWF0ZSBBUEktb25seSBVc2VycyBpbiBhbiBleGlzdGluZyBPcmdhbml6YXRpb25cbiAqXG4gKiBgUE9TVCAvcHVibGljL3YxL3N1Ym1pdC9jcmVhdGVfYXBpX29ubHlfdXNlcnNgXG4gKi9cbmNvbnN0IGNyZWF0ZUFwaU9ubHlVc2VycyA9IChpbnB1dCkgPT4gcmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvc3VibWl0L2NyZWF0ZV9hcGlfb25seV91c2Vyc1wiLFxuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbn0pO1xuLyoqXG4gKiBSZXF1ZXN0IGEgV2ViQXV0aG4gYXNzZXJ0aW9uIGFuZCByZXR1cm4gYSBzaWduZWQgYENyZWF0ZUFwaU9ubHlVc2Vyc2AgcmVxdWVzdCwgcmVhZHkgdG8gYmUgUE9TVGVkIHRvIFR1cm5rZXkuXG4gKlxuICogU2VlIHtAbGluayBDcmVhdGVBcGlPbmx5VXNlcnN9XG4gKi9cbmNvbnN0IHNpZ25DcmVhdGVBcGlPbmx5VXNlcnMgPSAoaW5wdXQsIG9wdGlvbnMpID0+IHNpZ25lZFJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3N1Ym1pdC9jcmVhdGVfYXBpX29ubHlfdXNlcnNcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxuICAgIG9wdGlvbnMsXG59KTtcbi8qKlxuICogQ3JlYXRlIEF1dGhlbnRpY2F0b3JzXG4gKlxuICogQ3JlYXRlIEF1dGhlbnRpY2F0b3JzIHRvIGF1dGhlbnRpY2F0ZSByZXF1ZXN0cyB0byBUdXJua2V5XG4gKlxuICogYFBPU1QgL3B1YmxpYy92MS9zdWJtaXQvY3JlYXRlX2F1dGhlbnRpY2F0b3JzYFxuICovXG5jb25zdCBjcmVhdGVBdXRoZW50aWNhdG9ycyA9IChpbnB1dCkgPT4gcmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvc3VibWl0L2NyZWF0ZV9hdXRoZW50aWNhdG9yc1wiLFxuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbn0pO1xuLyoqXG4gKiBSZXF1ZXN0IGEgV2ViQXV0aG4gYXNzZXJ0aW9uIGFuZCByZXR1cm4gYSBzaWduZWQgYENyZWF0ZUF1dGhlbnRpY2F0b3JzYCByZXF1ZXN0LCByZWFkeSB0byBiZSBQT1NUZWQgdG8gVHVybmtleS5cbiAqXG4gKiBTZWUge0BsaW5rIENyZWF0ZUF1dGhlbnRpY2F0b3JzfVxuICovXG5jb25zdCBzaWduQ3JlYXRlQXV0aGVudGljYXRvcnMgPSAoaW5wdXQsIG9wdGlvbnMpID0+IHNpZ25lZFJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3N1Ym1pdC9jcmVhdGVfYXV0aGVudGljYXRvcnNcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxuICAgIG9wdGlvbnMsXG59KTtcbi8qKlxuICogQ3JlYXRlIEludml0YXRpb25zXG4gKlxuICogQ3JlYXRlIEludml0YXRpb25zIHRvIGpvaW4gYW4gZXhpc3RpbmcgT3JnYW5pemF0aW9uXG4gKlxuICogYFBPU1QgL3B1YmxpYy92MS9zdWJtaXQvY3JlYXRlX2ludml0YXRpb25zYFxuICovXG5jb25zdCBjcmVhdGVJbnZpdGF0aW9ucyA9IChpbnB1dCkgPT4gcmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvc3VibWl0L2NyZWF0ZV9pbnZpdGF0aW9uc1wiLFxuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbn0pO1xuLyoqXG4gKiBSZXF1ZXN0IGEgV2ViQXV0aG4gYXNzZXJ0aW9uIGFuZCByZXR1cm4gYSBzaWduZWQgYENyZWF0ZUludml0YXRpb25zYCByZXF1ZXN0LCByZWFkeSB0byBiZSBQT1NUZWQgdG8gVHVybmtleS5cbiAqXG4gKiBTZWUge0BsaW5rIENyZWF0ZUludml0YXRpb25zfVxuICovXG5jb25zdCBzaWduQ3JlYXRlSW52aXRhdGlvbnMgPSAoaW5wdXQsIG9wdGlvbnMpID0+IHNpZ25lZFJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3N1Ym1pdC9jcmVhdGVfaW52aXRhdGlvbnNcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxuICAgIG9wdGlvbnMsXG59KTtcbi8qKlxuICogQ3JlYXRlIFBvbGljeVxuICpcbiAqIENyZWF0ZSBhIG5ldyBQb2xpY3lcbiAqXG4gKiBgUE9TVCAvcHVibGljL3YxL3N1Ym1pdC9jcmVhdGVfcG9saWN5YFxuICovXG5jb25zdCBjcmVhdGVQb2xpY3kgPSAoaW5wdXQpID0+IHJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3N1Ym1pdC9jcmVhdGVfcG9saWN5XCIsXG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxufSk7XG4vKipcbiAqIFJlcXVlc3QgYSBXZWJBdXRobiBhc3NlcnRpb24gYW5kIHJldHVybiBhIHNpZ25lZCBgQ3JlYXRlUG9saWN5YCByZXF1ZXN0LCByZWFkeSB0byBiZSBQT1NUZWQgdG8gVHVybmtleS5cbiAqXG4gKiBTZWUge0BsaW5rIENyZWF0ZVBvbGljeX1cbiAqL1xuY29uc3Qgc2lnbkNyZWF0ZVBvbGljeSA9IChpbnB1dCwgb3B0aW9ucykgPT4gc2lnbmVkUmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvc3VibWl0L2NyZWF0ZV9wb2xpY3lcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxuICAgIG9wdGlvbnMsXG59KTtcbi8qKlxuICogQ3JlYXRlIFByaXZhdGUgS2V5IFRhZ1xuICpcbiAqIENyZWF0ZSBhIHByaXZhdGUga2V5IHRhZyBhbmQgYWRkIGl0IHRvIHByaXZhdGUga2V5cy5cbiAqXG4gKiBgUE9TVCAvcHVibGljL3YxL3N1Ym1pdC9jcmVhdGVfcHJpdmF0ZV9rZXlfdGFnYFxuICovXG5jb25zdCBjcmVhdGVQcml2YXRlS2V5VGFnID0gKGlucHV0KSA9PiByZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9zdWJtaXQvY3JlYXRlX3ByaXZhdGVfa2V5X3RhZ1wiLFxuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbn0pO1xuLyoqXG4gKiBSZXF1ZXN0IGEgV2ViQXV0aG4gYXNzZXJ0aW9uIGFuZCByZXR1cm4gYSBzaWduZWQgYENyZWF0ZVByaXZhdGVLZXlUYWdgIHJlcXVlc3QsIHJlYWR5IHRvIGJlIFBPU1RlZCB0byBUdXJua2V5LlxuICpcbiAqIFNlZSB7QGxpbmsgQ3JlYXRlUHJpdmF0ZUtleVRhZ31cbiAqL1xuY29uc3Qgc2lnbkNyZWF0ZVByaXZhdGVLZXlUYWcgPSAoaW5wdXQsIG9wdGlvbnMpID0+IHNpZ25lZFJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3N1Ym1pdC9jcmVhdGVfcHJpdmF0ZV9rZXlfdGFnXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbiAgICBvcHRpb25zLFxufSk7XG4vKipcbiAqIENyZWF0ZSBQcml2YXRlIEtleXNcbiAqXG4gKiBDcmVhdGUgbmV3IFByaXZhdGUgS2V5c1xuICpcbiAqIGBQT1NUIC9wdWJsaWMvdjEvc3VibWl0L2NyZWF0ZV9wcml2YXRlX2tleXNgXG4gKi9cbmNvbnN0IGNyZWF0ZVByaXZhdGVLZXlzID0gKGlucHV0KSA9PiByZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9zdWJtaXQvY3JlYXRlX3ByaXZhdGVfa2V5c1wiLFxuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbn0pO1xuLyoqXG4gKiBSZXF1ZXN0IGEgV2ViQXV0aG4gYXNzZXJ0aW9uIGFuZCByZXR1cm4gYSBzaWduZWQgYENyZWF0ZVByaXZhdGVLZXlzYCByZXF1ZXN0LCByZWFkeSB0byBiZSBQT1NUZWQgdG8gVHVybmtleS5cbiAqXG4gKiBTZWUge0BsaW5rIENyZWF0ZVByaXZhdGVLZXlzfVxuICovXG5jb25zdCBzaWduQ3JlYXRlUHJpdmF0ZUtleXMgPSAoaW5wdXQsIG9wdGlvbnMpID0+IHNpZ25lZFJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3N1Ym1pdC9jcmVhdGVfcHJpdmF0ZV9rZXlzXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbiAgICBvcHRpb25zLFxufSk7XG4vKipcbiAqIENyZWF0ZSBTdWItT3JnYW5pemF0aW9uXG4gKlxuICogQ3JlYXRlIGEgbmV3IFN1Yi1Pcmdhbml6YXRpb25cbiAqXG4gKiBgUE9TVCAvcHVibGljL3YxL3N1Ym1pdC9jcmVhdGVfc3ViX29yZ2FuaXphdGlvbmBcbiAqL1xuY29uc3QgY3JlYXRlU3ViT3JnYW5pemF0aW9uID0gKGlucHV0KSA9PiByZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9zdWJtaXQvY3JlYXRlX3N1Yl9vcmdhbml6YXRpb25cIixcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG59KTtcbi8qKlxuICogUmVxdWVzdCBhIFdlYkF1dGhuIGFzc2VydGlvbiBhbmQgcmV0dXJuIGEgc2lnbmVkIGBDcmVhdGVTdWJPcmdhbml6YXRpb25gIHJlcXVlc3QsIHJlYWR5IHRvIGJlIFBPU1RlZCB0byBUdXJua2V5LlxuICpcbiAqIFNlZSB7QGxpbmsgQ3JlYXRlU3ViT3JnYW5pemF0aW9ufVxuICovXG5jb25zdCBzaWduQ3JlYXRlU3ViT3JnYW5pemF0aW9uID0gKGlucHV0LCBvcHRpb25zKSA9PiBzaWduZWRSZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9zdWJtaXQvY3JlYXRlX3N1Yl9vcmdhbml6YXRpb25cIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxuICAgIG9wdGlvbnMsXG59KTtcbi8qKlxuICogQ3JlYXRlIFVzZXIgVGFnXG4gKlxuICogQ3JlYXRlIGEgdXNlciB0YWcgYW5kIGFkZCBpdCB0byB1c2Vycy5cbiAqXG4gKiBgUE9TVCAvcHVibGljL3YxL3N1Ym1pdC9jcmVhdGVfdXNlcl90YWdgXG4gKi9cbmNvbnN0IGNyZWF0ZVVzZXJUYWcgPSAoaW5wdXQpID0+IHJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3N1Ym1pdC9jcmVhdGVfdXNlcl90YWdcIixcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG59KTtcbi8qKlxuICogUmVxdWVzdCBhIFdlYkF1dGhuIGFzc2VydGlvbiBhbmQgcmV0dXJuIGEgc2lnbmVkIGBDcmVhdGVVc2VyVGFnYCByZXF1ZXN0LCByZWFkeSB0byBiZSBQT1NUZWQgdG8gVHVybmtleS5cbiAqXG4gKiBTZWUge0BsaW5rIENyZWF0ZVVzZXJUYWd9XG4gKi9cbmNvbnN0IHNpZ25DcmVhdGVVc2VyVGFnID0gKGlucHV0LCBvcHRpb25zKSA9PiBzaWduZWRSZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9zdWJtaXQvY3JlYXRlX3VzZXJfdGFnXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbiAgICBvcHRpb25zLFxufSk7XG4vKipcbiAqIENyZWF0ZSBVc2Vyc1xuICpcbiAqIENyZWF0ZSBVc2VycyBpbiBhbiBleGlzdGluZyBPcmdhbml6YXRpb25cbiAqXG4gKiBgUE9TVCAvcHVibGljL3YxL3N1Ym1pdC9jcmVhdGVfdXNlcnNgXG4gKi9cbmNvbnN0IGNyZWF0ZVVzZXJzID0gKGlucHV0KSA9PiByZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9zdWJtaXQvY3JlYXRlX3VzZXJzXCIsXG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxufSk7XG4vKipcbiAqIFJlcXVlc3QgYSBXZWJBdXRobiBhc3NlcnRpb24gYW5kIHJldHVybiBhIHNpZ25lZCBgQ3JlYXRlVXNlcnNgIHJlcXVlc3QsIHJlYWR5IHRvIGJlIFBPU1RlZCB0byBUdXJua2V5LlxuICpcbiAqIFNlZSB7QGxpbmsgQ3JlYXRlVXNlcnN9XG4gKi9cbmNvbnN0IHNpZ25DcmVhdGVVc2VycyA9IChpbnB1dCwgb3B0aW9ucykgPT4gc2lnbmVkUmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvc3VibWl0L2NyZWF0ZV91c2Vyc1wiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG4gICAgb3B0aW9ucyxcbn0pO1xuLyoqXG4gKiBDcmVhdGUgV2FsbGV0XG4gKlxuICogQ3JlYXRlIGEgV2FsbGV0IGFuZCBkZXJpdmUgYWRkcmVzc2VzXG4gKlxuICogYFBPU1QgL3B1YmxpYy92MS9zdWJtaXQvY3JlYXRlX3dhbGxldGBcbiAqL1xuY29uc3QgY3JlYXRlV2FsbGV0ID0gKGlucHV0KSA9PiByZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9zdWJtaXQvY3JlYXRlX3dhbGxldFwiLFxuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbn0pO1xuLyoqXG4gKiBSZXF1ZXN0IGEgV2ViQXV0aG4gYXNzZXJ0aW9uIGFuZCByZXR1cm4gYSBzaWduZWQgYENyZWF0ZVdhbGxldGAgcmVxdWVzdCwgcmVhZHkgdG8gYmUgUE9TVGVkIHRvIFR1cm5rZXkuXG4gKlxuICogU2VlIHtAbGluayBDcmVhdGVXYWxsZXR9XG4gKi9cbmNvbnN0IHNpZ25DcmVhdGVXYWxsZXQgPSAoaW5wdXQsIG9wdGlvbnMpID0+IHNpZ25lZFJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3N1Ym1pdC9jcmVhdGVfd2FsbGV0XCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbiAgICBvcHRpb25zLFxufSk7XG4vKipcbiAqIENyZWF0ZSBXYWxsZXQgQWNjb3VudHNcbiAqXG4gKiBEZXJpdmUgYWRkaXRpb25hbCBhZGRyZXNzZXMgdXNpbmcgYW4gZXhpc3Rpbmcgd2FsbGV0XG4gKlxuICogYFBPU1QgL3B1YmxpYy92MS9zdWJtaXQvY3JlYXRlX3dhbGxldF9hY2NvdW50c2BcbiAqL1xuY29uc3QgY3JlYXRlV2FsbGV0QWNjb3VudHMgPSAoaW5wdXQpID0+IHJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3N1Ym1pdC9jcmVhdGVfd2FsbGV0X2FjY291bnRzXCIsXG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxufSk7XG4vKipcbiAqIFJlcXVlc3QgYSBXZWJBdXRobiBhc3NlcnRpb24gYW5kIHJldHVybiBhIHNpZ25lZCBgQ3JlYXRlV2FsbGV0QWNjb3VudHNgIHJlcXVlc3QsIHJlYWR5IHRvIGJlIFBPU1RlZCB0byBUdXJua2V5LlxuICpcbiAqIFNlZSB7QGxpbmsgQ3JlYXRlV2FsbGV0QWNjb3VudHN9XG4gKi9cbmNvbnN0IHNpZ25DcmVhdGVXYWxsZXRBY2NvdW50cyA9IChpbnB1dCwgb3B0aW9ucykgPT4gc2lnbmVkUmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvc3VibWl0L2NyZWF0ZV93YWxsZXRfYWNjb3VudHNcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxuICAgIG9wdGlvbnMsXG59KTtcbi8qKlxuICogRGVsZXRlIEFQSSBLZXlzXG4gKlxuICogUmVtb3ZlIGFwaSBrZXlzIGZyb20gYSBVc2VyXG4gKlxuICogYFBPU1QgL3B1YmxpYy92MS9zdWJtaXQvZGVsZXRlX2FwaV9rZXlzYFxuICovXG5jb25zdCBkZWxldGVBcGlLZXlzID0gKGlucHV0KSA9PiByZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9zdWJtaXQvZGVsZXRlX2FwaV9rZXlzXCIsXG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxufSk7XG4vKipcbiAqIFJlcXVlc3QgYSBXZWJBdXRobiBhc3NlcnRpb24gYW5kIHJldHVybiBhIHNpZ25lZCBgRGVsZXRlQXBpS2V5c2AgcmVxdWVzdCwgcmVhZHkgdG8gYmUgUE9TVGVkIHRvIFR1cm5rZXkuXG4gKlxuICogU2VlIHtAbGluayBEZWxldGVBcGlLZXlzfVxuICovXG5jb25zdCBzaWduRGVsZXRlQXBpS2V5cyA9IChpbnB1dCwgb3B0aW9ucykgPT4gc2lnbmVkUmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvc3VibWl0L2RlbGV0ZV9hcGlfa2V5c1wiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG4gICAgb3B0aW9ucyxcbn0pO1xuLyoqXG4gKiBEZWxldGUgQXV0aGVudGljYXRvcnNcbiAqXG4gKiBSZW1vdmUgYXV0aGVudGljYXRvcnMgZnJvbSBhIFVzZXJcbiAqXG4gKiBgUE9TVCAvcHVibGljL3YxL3N1Ym1pdC9kZWxldGVfYXV0aGVudGljYXRvcnNgXG4gKi9cbmNvbnN0IGRlbGV0ZUF1dGhlbnRpY2F0b3JzID0gKGlucHV0KSA9PiByZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9zdWJtaXQvZGVsZXRlX2F1dGhlbnRpY2F0b3JzXCIsXG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxufSk7XG4vKipcbiAqIFJlcXVlc3QgYSBXZWJBdXRobiBhc3NlcnRpb24gYW5kIHJldHVybiBhIHNpZ25lZCBgRGVsZXRlQXV0aGVudGljYXRvcnNgIHJlcXVlc3QsIHJlYWR5IHRvIGJlIFBPU1RlZCB0byBUdXJua2V5LlxuICpcbiAqIFNlZSB7QGxpbmsgRGVsZXRlQXV0aGVudGljYXRvcnN9XG4gKi9cbmNvbnN0IHNpZ25EZWxldGVBdXRoZW50aWNhdG9ycyA9IChpbnB1dCwgb3B0aW9ucykgPT4gc2lnbmVkUmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvc3VibWl0L2RlbGV0ZV9hdXRoZW50aWNhdG9yc1wiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG4gICAgb3B0aW9ucyxcbn0pO1xuLyoqXG4gKiBEZWxldGUgSW52aXRhdGlvblxuICpcbiAqIERlbGV0ZSBhbiBleGlzdGluZyBJbnZpdGF0aW9uXG4gKlxuICogYFBPU1QgL3B1YmxpYy92MS9zdWJtaXQvZGVsZXRlX2ludml0YXRpb25gXG4gKi9cbmNvbnN0IGRlbGV0ZUludml0YXRpb24gPSAoaW5wdXQpID0+IHJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3N1Ym1pdC9kZWxldGVfaW52aXRhdGlvblwiLFxuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbn0pO1xuLyoqXG4gKiBSZXF1ZXN0IGEgV2ViQXV0aG4gYXNzZXJ0aW9uIGFuZCByZXR1cm4gYSBzaWduZWQgYERlbGV0ZUludml0YXRpb25gIHJlcXVlc3QsIHJlYWR5IHRvIGJlIFBPU1RlZCB0byBUdXJua2V5LlxuICpcbiAqIFNlZSB7QGxpbmsgRGVsZXRlSW52aXRhdGlvbn1cbiAqL1xuY29uc3Qgc2lnbkRlbGV0ZUludml0YXRpb24gPSAoaW5wdXQsIG9wdGlvbnMpID0+IHNpZ25lZFJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3N1Ym1pdC9kZWxldGVfaW52aXRhdGlvblwiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG4gICAgb3B0aW9ucyxcbn0pO1xuLyoqXG4gKiBEZWxldGUgUG9saWN5XG4gKlxuICogRGVsZXRlIGFuIGV4aXN0aW5nIFBvbGljeVxuICpcbiAqIGBQT1NUIC9wdWJsaWMvdjEvc3VibWl0L2RlbGV0ZV9wb2xpY3lgXG4gKi9cbmNvbnN0IGRlbGV0ZVBvbGljeSA9IChpbnB1dCkgPT4gcmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvc3VibWl0L2RlbGV0ZV9wb2xpY3lcIixcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG59KTtcbi8qKlxuICogUmVxdWVzdCBhIFdlYkF1dGhuIGFzc2VydGlvbiBhbmQgcmV0dXJuIGEgc2lnbmVkIGBEZWxldGVQb2xpY3lgIHJlcXVlc3QsIHJlYWR5IHRvIGJlIFBPU1RlZCB0byBUdXJua2V5LlxuICpcbiAqIFNlZSB7QGxpbmsgRGVsZXRlUG9saWN5fVxuICovXG5jb25zdCBzaWduRGVsZXRlUG9saWN5ID0gKGlucHV0LCBvcHRpb25zKSA9PiBzaWduZWRSZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9zdWJtaXQvZGVsZXRlX3BvbGljeVwiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG4gICAgb3B0aW9ucyxcbn0pO1xuLyoqXG4gKiBQZXJmb3JtIEVtYWlsIEF1dGhcbiAqXG4gKiBBdXRoZW50aWNhdGUgYSB1c2VyIHZpYSBFbWFpbFxuICpcbiAqIGBQT1NUIC9wdWJsaWMvdjEvc3VibWl0L2VtYWlsX2F1dGhgXG4gKi9cbmNvbnN0IGVtYWlsQXV0aCA9IChpbnB1dCkgPT4gcmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvc3VibWl0L2VtYWlsX2F1dGhcIixcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG59KTtcbi8qKlxuICogUmVxdWVzdCBhIFdlYkF1dGhuIGFzc2VydGlvbiBhbmQgcmV0dXJuIGEgc2lnbmVkIGBFbWFpbEF1dGhgIHJlcXVlc3QsIHJlYWR5IHRvIGJlIFBPU1RlZCB0byBUdXJua2V5LlxuICpcbiAqIFNlZSB7QGxpbmsgRW1haWxBdXRofVxuICovXG5jb25zdCBzaWduRW1haWxBdXRoID0gKGlucHV0LCBvcHRpb25zKSA9PiBzaWduZWRSZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9zdWJtaXQvZW1haWxfYXV0aFwiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG4gICAgb3B0aW9ucyxcbn0pO1xuLyoqXG4gKiBFeHBvcnQgUHJpdmF0ZSBLZXlcbiAqXG4gKiBFeHBvcnRzIGEgUHJpdmF0ZSBLZXlcbiAqXG4gKiBgUE9TVCAvcHVibGljL3YxL3N1Ym1pdC9leHBvcnRfcHJpdmF0ZV9rZXlgXG4gKi9cbmNvbnN0IGV4cG9ydFByaXZhdGVLZXkgPSAoaW5wdXQpID0+IHJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3N1Ym1pdC9leHBvcnRfcHJpdmF0ZV9rZXlcIixcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG59KTtcbi8qKlxuICogUmVxdWVzdCBhIFdlYkF1dGhuIGFzc2VydGlvbiBhbmQgcmV0dXJuIGEgc2lnbmVkIGBFeHBvcnRQcml2YXRlS2V5YCByZXF1ZXN0LCByZWFkeSB0byBiZSBQT1NUZWQgdG8gVHVybmtleS5cbiAqXG4gKiBTZWUge0BsaW5rIEV4cG9ydFByaXZhdGVLZXl9XG4gKi9cbmNvbnN0IHNpZ25FeHBvcnRQcml2YXRlS2V5ID0gKGlucHV0LCBvcHRpb25zKSA9PiBzaWduZWRSZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9zdWJtaXQvZXhwb3J0X3ByaXZhdGVfa2V5XCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbiAgICBvcHRpb25zLFxufSk7XG4vKipcbiAqIEV4cG9ydCBXYWxsZXRcbiAqXG4gKiBFeHBvcnRzIGEgV2FsbGV0XG4gKlxuICogYFBPU1QgL3B1YmxpYy92MS9zdWJtaXQvZXhwb3J0X3dhbGxldGBcbiAqL1xuY29uc3QgZXhwb3J0V2FsbGV0ID0gKGlucHV0KSA9PiByZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9zdWJtaXQvZXhwb3J0X3dhbGxldFwiLFxuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbn0pO1xuLyoqXG4gKiBSZXF1ZXN0IGEgV2ViQXV0aG4gYXNzZXJ0aW9uIGFuZCByZXR1cm4gYSBzaWduZWQgYEV4cG9ydFdhbGxldGAgcmVxdWVzdCwgcmVhZHkgdG8gYmUgUE9TVGVkIHRvIFR1cm5rZXkuXG4gKlxuICogU2VlIHtAbGluayBFeHBvcnRXYWxsZXR9XG4gKi9cbmNvbnN0IHNpZ25FeHBvcnRXYWxsZXQgPSAoaW5wdXQsIG9wdGlvbnMpID0+IHNpZ25lZFJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3N1Ym1pdC9leHBvcnRfd2FsbGV0XCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbiAgICBvcHRpb25zLFxufSk7XG4vKipcbiAqIEV4cG9ydCBXYWxsZXQgQWNjb3VudFxuICpcbiAqIEV4cG9ydHMgYSBXYWxsZXQgQWNjb3VudFxuICpcbiAqIGBQT1NUIC9wdWJsaWMvdjEvc3VibWl0L2V4cG9ydF93YWxsZXRfYWNjb3VudGBcbiAqL1xuY29uc3QgZXhwb3J0V2FsbGV0QWNjb3VudCA9IChpbnB1dCkgPT4gcmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvc3VibWl0L2V4cG9ydF93YWxsZXRfYWNjb3VudFwiLFxuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbn0pO1xuLyoqXG4gKiBSZXF1ZXN0IGEgV2ViQXV0aG4gYXNzZXJ0aW9uIGFuZCByZXR1cm4gYSBzaWduZWQgYEV4cG9ydFdhbGxldEFjY291bnRgIHJlcXVlc3QsIHJlYWR5IHRvIGJlIFBPU1RlZCB0byBUdXJua2V5LlxuICpcbiAqIFNlZSB7QGxpbmsgRXhwb3J0V2FsbGV0QWNjb3VudH1cbiAqL1xuY29uc3Qgc2lnbkV4cG9ydFdhbGxldEFjY291bnQgPSAoaW5wdXQsIG9wdGlvbnMpID0+IHNpZ25lZFJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3N1Ym1pdC9leHBvcnRfd2FsbGV0X2FjY291bnRcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxuICAgIG9wdGlvbnMsXG59KTtcbi8qKlxuICogSW5pdCBFbWFpbCBSZWNvdmVyeVxuICpcbiAqIEluaXRpYWxpemVzIGEgbmV3IGVtYWlsIHJlY292ZXJ5XG4gKlxuICogYFBPU1QgL3B1YmxpYy92MS9zdWJtaXQvaW5pdF91c2VyX2VtYWlsX3JlY292ZXJ5YFxuICovXG5jb25zdCBpbml0VXNlckVtYWlsUmVjb3ZlcnkgPSAoaW5wdXQpID0+IHJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3N1Ym1pdC9pbml0X3VzZXJfZW1haWxfcmVjb3ZlcnlcIixcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG59KTtcbi8qKlxuICogUmVxdWVzdCBhIFdlYkF1dGhuIGFzc2VydGlvbiBhbmQgcmV0dXJuIGEgc2lnbmVkIGBJbml0VXNlckVtYWlsUmVjb3ZlcnlgIHJlcXVlc3QsIHJlYWR5IHRvIGJlIFBPU1RlZCB0byBUdXJua2V5LlxuICpcbiAqIFNlZSB7QGxpbmsgSW5pdFVzZXJFbWFpbFJlY292ZXJ5fVxuICovXG5jb25zdCBzaWduSW5pdFVzZXJFbWFpbFJlY292ZXJ5ID0gKGlucHV0LCBvcHRpb25zKSA9PiBzaWduZWRSZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9zdWJtaXQvaW5pdF91c2VyX2VtYWlsX3JlY292ZXJ5XCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbiAgICBvcHRpb25zLFxufSk7XG4vKipcbiAqIFJlY292ZXIgYSB1c2VyXG4gKlxuICogQ29tcGxldGVzIHRoZSBwcm9jZXNzIG9mIHJlY292ZXJpbmcgYSB1c2VyIGJ5IGFkZGluZyBhbiBhdXRoZW50aWNhdG9yXG4gKlxuICogYFBPU1QgL3B1YmxpYy92MS9zdWJtaXQvcmVjb3Zlcl91c2VyYFxuICovXG5jb25zdCByZWNvdmVyVXNlciA9IChpbnB1dCkgPT4gcmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvc3VibWl0L3JlY292ZXJfdXNlclwiLFxuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbn0pO1xuLyoqXG4gKiBSZXF1ZXN0IGEgV2ViQXV0aG4gYXNzZXJ0aW9uIGFuZCByZXR1cm4gYSBzaWduZWQgYFJlY292ZXJVc2VyYCByZXF1ZXN0LCByZWFkeSB0byBiZSBQT1NUZWQgdG8gVHVybmtleS5cbiAqXG4gKiBTZWUge0BsaW5rIFJlY292ZXJVc2VyfVxuICovXG5jb25zdCBzaWduUmVjb3ZlclVzZXIgPSAoaW5wdXQsIG9wdGlvbnMpID0+IHNpZ25lZFJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3N1Ym1pdC9yZWNvdmVyX3VzZXJcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxuICAgIG9wdGlvbnMsXG59KTtcbi8qKlxuICogUmVqZWN0IEFjdGl2aXR5XG4gKlxuICogUmVqZWN0IGFuIEFjdGl2aXR5XG4gKlxuICogYFBPU1QgL3B1YmxpYy92MS9zdWJtaXQvcmVqZWN0X2FjdGl2aXR5YFxuICovXG5jb25zdCByZWplY3RBY3Rpdml0eSA9IChpbnB1dCkgPT4gcmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvc3VibWl0L3JlamVjdF9hY3Rpdml0eVwiLFxuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbn0pO1xuLyoqXG4gKiBSZXF1ZXN0IGEgV2ViQXV0aG4gYXNzZXJ0aW9uIGFuZCByZXR1cm4gYSBzaWduZWQgYFJlamVjdEFjdGl2aXR5YCByZXF1ZXN0LCByZWFkeSB0byBiZSBQT1NUZWQgdG8gVHVybmtleS5cbiAqXG4gKiBTZWUge0BsaW5rIFJlamVjdEFjdGl2aXR5fVxuICovXG5jb25zdCBzaWduUmVqZWN0QWN0aXZpdHkgPSAoaW5wdXQsIG9wdGlvbnMpID0+IHNpZ25lZFJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3N1Ym1pdC9yZWplY3RfYWN0aXZpdHlcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxuICAgIG9wdGlvbnMsXG59KTtcbi8qKlxuICogUmVtb3ZlIE9yZ2FuaXphdGlvbiBGZWF0dXJlXG4gKlxuICogUmVtb3ZlcyBhbiBvcmdhbml6YXRpb24gZmVhdHVyZVxuICpcbiAqIGBQT1NUIC9wdWJsaWMvdjEvc3VibWl0L3JlbW92ZV9vcmdhbml6YXRpb25fZmVhdHVyZWBcbiAqL1xuY29uc3QgcmVtb3ZlT3JnYW5pemF0aW9uRmVhdHVyZSA9IChpbnB1dCkgPT4gcmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvc3VibWl0L3JlbW92ZV9vcmdhbml6YXRpb25fZmVhdHVyZVwiLFxuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbn0pO1xuLyoqXG4gKiBSZXF1ZXN0IGEgV2ViQXV0aG4gYXNzZXJ0aW9uIGFuZCByZXR1cm4gYSBzaWduZWQgYFJlbW92ZU9yZ2FuaXphdGlvbkZlYXR1cmVgIHJlcXVlc3QsIHJlYWR5IHRvIGJlIFBPU1RlZCB0byBUdXJua2V5LlxuICpcbiAqIFNlZSB7QGxpbmsgUmVtb3ZlT3JnYW5pemF0aW9uRmVhdHVyZX1cbiAqL1xuY29uc3Qgc2lnblJlbW92ZU9yZ2FuaXphdGlvbkZlYXR1cmUgPSAoaW5wdXQsIG9wdGlvbnMpID0+IHNpZ25lZFJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3N1Ym1pdC9yZW1vdmVfb3JnYW5pemF0aW9uX2ZlYXR1cmVcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxuICAgIG9wdGlvbnMsXG59KTtcbi8qKlxuICogU2V0IE9yZ2FuaXphdGlvbiBGZWF0dXJlXG4gKlxuICogU2V0cyBhbiBvcmdhbml6YXRpb24gZmVhdHVyZVxuICpcbiAqIGBQT1NUIC9wdWJsaWMvdjEvc3VibWl0L3NldF9vcmdhbml6YXRpb25fZmVhdHVyZWBcbiAqL1xuY29uc3Qgc2V0T3JnYW5pemF0aW9uRmVhdHVyZSA9IChpbnB1dCkgPT4gcmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvc3VibWl0L3NldF9vcmdhbml6YXRpb25fZmVhdHVyZVwiLFxuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbn0pO1xuLyoqXG4gKiBSZXF1ZXN0IGEgV2ViQXV0aG4gYXNzZXJ0aW9uIGFuZCByZXR1cm4gYSBzaWduZWQgYFNldE9yZ2FuaXphdGlvbkZlYXR1cmVgIHJlcXVlc3QsIHJlYWR5IHRvIGJlIFBPU1RlZCB0byBUdXJua2V5LlxuICpcbiAqIFNlZSB7QGxpbmsgU2V0T3JnYW5pemF0aW9uRmVhdHVyZX1cbiAqL1xuY29uc3Qgc2lnblNldE9yZ2FuaXphdGlvbkZlYXR1cmUgPSAoaW5wdXQsIG9wdGlvbnMpID0+IHNpZ25lZFJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3N1Ym1pdC9zZXRfb3JnYW5pemF0aW9uX2ZlYXR1cmVcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxuICAgIG9wdGlvbnMsXG59KTtcbi8qKlxuICogU2lnbiBSYXcgUGF5bG9hZFxuICpcbiAqIFNpZ24gYSByYXcgcGF5bG9hZFxuICpcbiAqIGBQT1NUIC9wdWJsaWMvdjEvc3VibWl0L3NpZ25fcmF3X3BheWxvYWRgXG4gKi9cbmNvbnN0IHNpZ25SYXdQYXlsb2FkID0gKGlucHV0KSA9PiByZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9zdWJtaXQvc2lnbl9yYXdfcGF5bG9hZFwiLFxuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbn0pO1xuLyoqXG4gKiBSZXF1ZXN0IGEgV2ViQXV0aG4gYXNzZXJ0aW9uIGFuZCByZXR1cm4gYSBzaWduZWQgYFNpZ25SYXdQYXlsb2FkYCByZXF1ZXN0LCByZWFkeSB0byBiZSBQT1NUZWQgdG8gVHVybmtleS5cbiAqXG4gKiBTZWUge0BsaW5rIFNpZ25SYXdQYXlsb2FkfVxuICovXG5jb25zdCBzaWduU2lnblJhd1BheWxvYWQgPSAoaW5wdXQsIG9wdGlvbnMpID0+IHNpZ25lZFJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3N1Ym1pdC9zaWduX3Jhd19wYXlsb2FkXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbiAgICBvcHRpb25zLFxufSk7XG4vKipcbiAqIFNpZ24gVHJhbnNhY3Rpb25cbiAqXG4gKiBTaWduIGEgdHJhbnNhY3Rpb25cbiAqXG4gKiBgUE9TVCAvcHVibGljL3YxL3N1Ym1pdC9zaWduX3RyYW5zYWN0aW9uYFxuICovXG5jb25zdCBzaWduVHJhbnNhY3Rpb24gPSAoaW5wdXQpID0+IHJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3N1Ym1pdC9zaWduX3RyYW5zYWN0aW9uXCIsXG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxufSk7XG4vKipcbiAqIFJlcXVlc3QgYSBXZWJBdXRobiBhc3NlcnRpb24gYW5kIHJldHVybiBhIHNpZ25lZCBgU2lnblRyYW5zYWN0aW9uYCByZXF1ZXN0LCByZWFkeSB0byBiZSBQT1NUZWQgdG8gVHVybmtleS5cbiAqXG4gKiBTZWUge0BsaW5rIFNpZ25UcmFuc2FjdGlvbn1cbiAqL1xuY29uc3Qgc2lnblNpZ25UcmFuc2FjdGlvbiA9IChpbnB1dCwgb3B0aW9ucykgPT4gc2lnbmVkUmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvc3VibWl0L3NpZ25fdHJhbnNhY3Rpb25cIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxuICAgIG9wdGlvbnMsXG59KTtcbi8qKlxuICogVXBkYXRlIFBvbGljeVxuICpcbiAqIFVwZGF0ZSBhbiBleGlzdGluZyBQb2xpY3lcbiAqXG4gKiBgUE9TVCAvcHVibGljL3YxL3N1Ym1pdC91cGRhdGVfcG9saWN5YFxuICovXG5jb25zdCB1cGRhdGVQb2xpY3kgPSAoaW5wdXQpID0+IHJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3N1Ym1pdC91cGRhdGVfcG9saWN5XCIsXG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxufSk7XG4vKipcbiAqIFJlcXVlc3QgYSBXZWJBdXRobiBhc3NlcnRpb24gYW5kIHJldHVybiBhIHNpZ25lZCBgVXBkYXRlUG9saWN5YCByZXF1ZXN0LCByZWFkeSB0byBiZSBQT1NUZWQgdG8gVHVybmtleS5cbiAqXG4gKiBTZWUge0BsaW5rIFVwZGF0ZVBvbGljeX1cbiAqL1xuY29uc3Qgc2lnblVwZGF0ZVBvbGljeSA9IChpbnB1dCwgb3B0aW9ucykgPT4gc2lnbmVkUmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvc3VibWl0L3VwZGF0ZV9wb2xpY3lcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxuICAgIG9wdGlvbnMsXG59KTtcbi8qKlxuICogVXBkYXRlIFByaXZhdGUgS2V5IFRhZ1xuICpcbiAqIFVwZGF0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9yIGFzc29jaWF0ZWQgcHJpdmF0ZSBrZXlzLiBOb3RlIHRoYXQgdGhpcyBhY3Rpdml0eSBpcyBhdG9taWM6IGFsbCBvZiB0aGUgdXBkYXRlcyB3aWxsIHN1Y2NlZWQgYXQgb25jZSwgb3IgYWxsIG9mIHRoZW0gd2lsbCBmYWlsLlxuICpcbiAqIGBQT1NUIC9wdWJsaWMvdjEvc3VibWl0L3VwZGF0ZV9wcml2YXRlX2tleV90YWdgXG4gKi9cbmNvbnN0IHVwZGF0ZVByaXZhdGVLZXlUYWcgPSAoaW5wdXQpID0+IHJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3N1Ym1pdC91cGRhdGVfcHJpdmF0ZV9rZXlfdGFnXCIsXG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxufSk7XG4vKipcbiAqIFJlcXVlc3QgYSBXZWJBdXRobiBhc3NlcnRpb24gYW5kIHJldHVybiBhIHNpZ25lZCBgVXBkYXRlUHJpdmF0ZUtleVRhZ2AgcmVxdWVzdCwgcmVhZHkgdG8gYmUgUE9TVGVkIHRvIFR1cm5rZXkuXG4gKlxuICogU2VlIHtAbGluayBVcGRhdGVQcml2YXRlS2V5VGFnfVxuICovXG5jb25zdCBzaWduVXBkYXRlUHJpdmF0ZUtleVRhZyA9IChpbnB1dCwgb3B0aW9ucykgPT4gc2lnbmVkUmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvc3VibWl0L3VwZGF0ZV9wcml2YXRlX2tleV90YWdcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxuICAgIG9wdGlvbnMsXG59KTtcbi8qKlxuICogVXBkYXRlIFJvb3QgUXVvcnVtXG4gKlxuICogU2V0IHRoZSB0aHJlc2hvbGQgYW5kIG1lbWJlcnMgb2YgdGhlIHJvb3QgcXVvcnVtLiBUaGlzIG11c3QgYmUgYXBwcm92ZWQgYnkgdGhlIGN1cnJlbnQgcm9vdCBxdW9ydW0uXG4gKlxuICogYFBPU1QgL3B1YmxpYy92MS9zdWJtaXQvdXBkYXRlX3Jvb3RfcXVvcnVtYFxuICovXG5jb25zdCB1cGRhdGVSb290UXVvcnVtID0gKGlucHV0KSA9PiByZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3B1YmxpYy92MS9zdWJtaXQvdXBkYXRlX3Jvb3RfcXVvcnVtXCIsXG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxufSk7XG4vKipcbiAqIFJlcXVlc3QgYSBXZWJBdXRobiBhc3NlcnRpb24gYW5kIHJldHVybiBhIHNpZ25lZCBgVXBkYXRlUm9vdFF1b3J1bWAgcmVxdWVzdCwgcmVhZHkgdG8gYmUgUE9TVGVkIHRvIFR1cm5rZXkuXG4gKlxuICogU2VlIHtAbGluayBVcGRhdGVSb290UXVvcnVtfVxuICovXG5jb25zdCBzaWduVXBkYXRlUm9vdFF1b3J1bSA9IChpbnB1dCwgb3B0aW9ucykgPT4gc2lnbmVkUmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvc3VibWl0L3VwZGF0ZV9yb290X3F1b3J1bVwiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG4gICAgb3B0aW9ucyxcbn0pO1xuLyoqXG4gKiBVcGRhdGUgVXNlclxuICpcbiAqIFVwZGF0ZSBhIFVzZXIgaW4gYW4gZXhpc3RpbmcgT3JnYW5pemF0aW9uXG4gKlxuICogYFBPU1QgL3B1YmxpYy92MS9zdWJtaXQvdXBkYXRlX3VzZXJgXG4gKi9cbmNvbnN0IHVwZGF0ZVVzZXIgPSAoaW5wdXQpID0+IHJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3N1Ym1pdC91cGRhdGVfdXNlclwiLFxuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbn0pO1xuLyoqXG4gKiBSZXF1ZXN0IGEgV2ViQXV0aG4gYXNzZXJ0aW9uIGFuZCByZXR1cm4gYSBzaWduZWQgYFVwZGF0ZVVzZXJgIHJlcXVlc3QsIHJlYWR5IHRvIGJlIFBPU1RlZCB0byBUdXJua2V5LlxuICpcbiAqIFNlZSB7QGxpbmsgVXBkYXRlVXNlcn1cbiAqL1xuY29uc3Qgc2lnblVwZGF0ZVVzZXIgPSAoaW5wdXQsIG9wdGlvbnMpID0+IHNpZ25lZFJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3N1Ym1pdC91cGRhdGVfdXNlclwiLFxuICAgIGJvZHk6IGlucHV0LmJvZHksXG4gICAgb3B0aW9ucyxcbn0pO1xuLyoqXG4gKiBVcGRhdGUgVXNlciBUYWdcbiAqXG4gKiBVcGRhdGUgaHVtYW4tcmVhZGFibGUgbmFtZSBvciBhc3NvY2lhdGVkIHVzZXJzLiBOb3RlIHRoYXQgdGhpcyBhY3Rpdml0eSBpcyBhdG9taWM6IGFsbCBvZiB0aGUgdXBkYXRlcyB3aWxsIHN1Y2NlZWQgYXQgb25jZSwgb3IgYWxsIG9mIHRoZW0gd2lsbCBmYWlsLlxuICpcbiAqIGBQT1NUIC9wdWJsaWMvdjEvc3VibWl0L3VwZGF0ZV91c2VyX3RhZ2BcbiAqL1xuY29uc3QgdXBkYXRlVXNlclRhZyA9IChpbnB1dCkgPT4gcmVxdWVzdCh7XG4gICAgdXJpOiBcIi9wdWJsaWMvdjEvc3VibWl0L3VwZGF0ZV91c2VyX3RhZ1wiLFxuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgYm9keTogaW5wdXQuYm9keSxcbn0pO1xuLyoqXG4gKiBSZXF1ZXN0IGEgV2ViQXV0aG4gYXNzZXJ0aW9uIGFuZCByZXR1cm4gYSBzaWduZWQgYFVwZGF0ZVVzZXJUYWdgIHJlcXVlc3QsIHJlYWR5IHRvIGJlIFBPU1RlZCB0byBUdXJua2V5LlxuICpcbiAqIFNlZSB7QGxpbmsgVXBkYXRlVXNlclRhZ31cbiAqL1xuY29uc3Qgc2lnblVwZGF0ZVVzZXJUYWcgPSAoaW5wdXQsIG9wdGlvbnMpID0+IHNpZ25lZFJlcXVlc3Qoe1xuICAgIHVyaTogXCIvcHVibGljL3YxL3N1Ym1pdC91cGRhdGVfdXNlcl90YWdcIixcbiAgICBib2R5OiBpbnB1dC5ib2R5LFxuICAgIG9wdGlvbnMsXG59KTtcbi8qKlxuICogYFBPU1QgL3RraHEvYXBpL3YxL25vb3AtY29kZWdlbi1hbmNob3JgXG4gKi9cbmNvbnN0IG5PT1BDb2RlZ2VuQW5jaG9yID0gKCkgPT4gcmVxdWVzdCh7XG4gICAgdXJpOiBcIi90a2hxL2FwaS92MS9ub29wLWNvZGVnZW4tYW5jaG9yXCIsXG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbn0pO1xuLyoqXG4gKiBSZXF1ZXN0IGEgV2ViQXV0aG4gYXNzZXJ0aW9uIGFuZCByZXR1cm4gYSBzaWduZWQgYE5PT1BDb2RlZ2VuQW5jaG9yYCByZXF1ZXN0LCByZWFkeSB0byBiZSBQT1NUZWQgdG8gVHVybmtleS5cbiAqXG4gKiBTZWUge0BsaW5rIE5PT1BDb2RlZ2VuQW5jaG9yfVxuICovXG5jb25zdCBzaWduTk9PUENvZGVnZW5BbmNob3IgPSAoKSA9PiBzaWduZWRSZXF1ZXN0KHtcbiAgICB1cmk6IFwiL3RraHEvYXBpL3YxL25vb3AtY29kZWdlbi1hbmNob3JcIixcbn0pO1xuXG5leHBvcnQgeyBhcHByb3ZlQWN0aXZpdHksIGNyZWF0ZUFwaUtleXMsIGNyZWF0ZUFwaU9ubHlVc2VycywgY3JlYXRlQXV0aGVudGljYXRvcnMsIGNyZWF0ZUludml0YXRpb25zLCBjcmVhdGVQb2xpY3ksIGNyZWF0ZVByaXZhdGVLZXlUYWcsIGNyZWF0ZVByaXZhdGVLZXlzLCBjcmVhdGVTdWJPcmdhbml6YXRpb24sIGNyZWF0ZVVzZXJUYWcsIGNyZWF0ZVVzZXJzLCBjcmVhdGVXYWxsZXQsIGNyZWF0ZVdhbGxldEFjY291bnRzLCBkZWxldGVBcGlLZXlzLCBkZWxldGVBdXRoZW50aWNhdG9ycywgZGVsZXRlSW52aXRhdGlvbiwgZGVsZXRlUG9saWN5LCBlbWFpbEF1dGgsIGV4cG9ydFByaXZhdGVLZXksIGV4cG9ydFdhbGxldCwgZXhwb3J0V2FsbGV0QWNjb3VudCwgZ2V0QWN0aXZpdGllcywgZ2V0QWN0aXZpdHksIGdldEFwaUtleSwgZ2V0QXBpS2V5cywgZ2V0QXV0aGVudGljYXRvciwgZ2V0QXV0aGVudGljYXRvcnMsIGdldE9yZ2FuaXphdGlvbiwgZ2V0UG9saWNpZXMsIGdldFBvbGljeSwgZ2V0UHJpdmF0ZUtleSwgZ2V0UHJpdmF0ZUtleXMsIGdldFVzZXIsIGdldFVzZXJzLCBnZXRXYWxsZXQsIGdldFdhbGxldEFjY291bnRzLCBnZXRXYWxsZXRzLCBnZXRXaG9hbWksIGluaXRVc2VyRW1haWxSZWNvdmVyeSwgbGlzdFByaXZhdGVLZXlUYWdzLCBsaXN0VXNlclRhZ3MsIG5PT1BDb2RlZ2VuQW5jaG9yLCByZWNvdmVyVXNlciwgcmVqZWN0QWN0aXZpdHksIHJlbW92ZU9yZ2FuaXphdGlvbkZlYXR1cmUsIHNldE9yZ2FuaXphdGlvbkZlYXR1cmUsIHNpZ25BcHByb3ZlQWN0aXZpdHksIHNpZ25DcmVhdGVBcGlLZXlzLCBzaWduQ3JlYXRlQXBpT25seVVzZXJzLCBzaWduQ3JlYXRlQXV0aGVudGljYXRvcnMsIHNpZ25DcmVhdGVJbnZpdGF0aW9ucywgc2lnbkNyZWF0ZVBvbGljeSwgc2lnbkNyZWF0ZVByaXZhdGVLZXlUYWcsIHNpZ25DcmVhdGVQcml2YXRlS2V5cywgc2lnbkNyZWF0ZVN1Yk9yZ2FuaXphdGlvbiwgc2lnbkNyZWF0ZVVzZXJUYWcsIHNpZ25DcmVhdGVVc2Vycywgc2lnbkNyZWF0ZVdhbGxldCwgc2lnbkNyZWF0ZVdhbGxldEFjY291bnRzLCBzaWduRGVsZXRlQXBpS2V5cywgc2lnbkRlbGV0ZUF1dGhlbnRpY2F0b3JzLCBzaWduRGVsZXRlSW52aXRhdGlvbiwgc2lnbkRlbGV0ZVBvbGljeSwgc2lnbkVtYWlsQXV0aCwgc2lnbkV4cG9ydFByaXZhdGVLZXksIHNpZ25FeHBvcnRXYWxsZXQsIHNpZ25FeHBvcnRXYWxsZXRBY2NvdW50LCBzaWduR2V0QWN0aXZpdGllcywgc2lnbkdldEFjdGl2aXR5LCBzaWduR2V0QXBpS2V5LCBzaWduR2V0QXBpS2V5cywgc2lnbkdldEF1dGhlbnRpY2F0b3IsIHNpZ25HZXRBdXRoZW50aWNhdG9ycywgc2lnbkdldE9yZ2FuaXphdGlvbiwgc2lnbkdldFBvbGljaWVzLCBzaWduR2V0UG9saWN5LCBzaWduR2V0UHJpdmF0ZUtleSwgc2lnbkdldFByaXZhdGVLZXlzLCBzaWduR2V0VXNlciwgc2lnbkdldFVzZXJzLCBzaWduR2V0V2FsbGV0LCBzaWduR2V0V2FsbGV0QWNjb3VudHMsIHNpZ25HZXRXYWxsZXRzLCBzaWduR2V0V2hvYW1pLCBzaWduSW5pdFVzZXJFbWFpbFJlY292ZXJ5LCBzaWduTGlzdFByaXZhdGVLZXlUYWdzLCBzaWduTGlzdFVzZXJUYWdzLCBzaWduTk9PUENvZGVnZW5BbmNob3IsIHNpZ25SYXdQYXlsb2FkLCBzaWduUmVjb3ZlclVzZXIsIHNpZ25SZWplY3RBY3Rpdml0eSwgc2lnblJlbW92ZU9yZ2FuaXphdGlvbkZlYXR1cmUsIHNpZ25TZXRPcmdhbml6YXRpb25GZWF0dXJlLCBzaWduU2lnblJhd1BheWxvYWQsIHNpZ25TaWduVHJhbnNhY3Rpb24sIHNpZ25UcmFuc2FjdGlvbiwgc2lnblVwZGF0ZVBvbGljeSwgc2lnblVwZGF0ZVByaXZhdGVLZXlUYWcsIHNpZ25VcGRhdGVSb290UXVvcnVtLCBzaWduVXBkYXRlVXNlciwgc2lnblVwZGF0ZVVzZXJUYWcsIHVwZGF0ZVBvbGljeSwgdXBkYXRlUHJpdmF0ZUtleVRhZywgdXBkYXRlUm9vdFF1b3J1bSwgdXBkYXRlVXNlciwgdXBkYXRlVXNlclRhZyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHVibGljX2FwaS5mZXRjaGVyLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/__generated__/services/coordinator/public/v1/public_api.fetcher.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/async.mjs":
/*!********************************************************************************!*\
  !*** ./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/async.mjs ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createActivityPoller: () => (/* binding */ createActivityPoller),\n/* harmony export */   withAsyncPolling: () => (/* binding */ withAsyncPolling)\n/* harmony export */ });\n/* harmony import */ var _generated_services_coordinator_public_v1_public_api_fetcher_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./__generated__/services/coordinator/public/v1/public_api.fetcher.mjs */ \"(ssr)/./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/__generated__/services/coordinator/public/v1/public_api.fetcher.mjs\");\n/* harmony import */ var _shared_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shared.mjs */ \"(ssr)/./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/shared.mjs\");\n\n\n\nconst DEFAULT_REFRESH_INTERVAL_MS = 500;\n/**\n * Wraps a request to create a fetcher with built-in async polling support.\n *\n * @deprecated this function only works with {@link TurnkeyApi}.\n * Use {@link TurnkeyClient} and {@link createActivityPoller} instead.\n */\nfunction withAsyncPolling(params) {\n    const { request, refreshIntervalMs = DEFAULT_REFRESH_INTERVAL_MS } = params;\n    return async (input) => {\n        const initialResponse = await request(input);\n        let activity = initialResponse.activity;\n        while (true) {\n            switch (activity.status) {\n                case \"ACTIVITY_STATUS_COMPLETED\": {\n                    return activity;\n                }\n                case \"ACTIVITY_STATUS_CREATED\": {\n                    // Async pending state -- keep polling\n                    break;\n                }\n                case \"ACTIVITY_STATUS_PENDING\": {\n                    // Async pending state -- keep polling\n                    break;\n                }\n                case \"ACTIVITY_STATUS_CONSENSUS_NEEDED\": {\n                    // If the activity requires consensus, we shouldn't be polling forever.\n                    // You can read the `TurnkeyActivityError` thrown to get the `activityId`,\n                    // store it somewhere, then re-fetch the activity via `.postGetActivity(...)`\n                    // when the required approvals/rejections are in place.\n                    throw new _shared_mjs__WEBPACK_IMPORTED_MODULE_1__.TurnkeyActivityError({\n                        message: `Consensus needed for activity ${activity.id}`,\n                        activityId: activity.id,\n                        activityStatus: activity.status,\n                        activityType: activity.type,\n                    });\n                }\n                case \"ACTIVITY_STATUS_FAILED\": {\n                    // Activity failed\n                    throw new _shared_mjs__WEBPACK_IMPORTED_MODULE_1__.TurnkeyActivityError({\n                        message: `Activity ${activity.id} failed`,\n                        activityId: activity.id,\n                        activityStatus: activity.status,\n                        activityType: activity.type,\n                    });\n                }\n                case \"ACTIVITY_STATUS_REJECTED\": {\n                    // Activity was rejected\n                    throw new _shared_mjs__WEBPACK_IMPORTED_MODULE_1__.TurnkeyActivityError({\n                        message: `Activity ${activity.id} was rejected`,\n                        activityId: activity.id,\n                        activityStatus: activity.status,\n                        activityType: activity.type,\n                    });\n                }\n                default: {\n                    // Make sure the switch block is exhaustive\n                    assertNever(activity.status);\n                }\n            }\n            await sleep(refreshIntervalMs);\n            const pollingResponse = await (0,_generated_services_coordinator_public_v1_public_api_fetcher_mjs__WEBPACK_IMPORTED_MODULE_0__.getActivity)({\n                body: {\n                    activityId: activity.id,\n                    organizationId: activity.organizationId,\n                },\n            });\n            activity = pollingResponse.activity;\n        }\n    };\n}\n/**\n * Wraps a client request function (e.g. `client.createPrivateKeys`) in a poller.\n * The default refresh interval is 500ms.\n *\n * The returned poller will poll until the activity becomes `COMPLETED`.\n * If the activity becomes `FAILED` or `REJECTED` or is flagged as `NEEDS_CONSENSUS`, an error is thrown.\n *\n * @example\n * const activityPoller = createActivityPoller(client, client.createPrivateKeys);\n * const activity = await activityPoller(input);\n * console.log(activity.result); // activity is completed\n */\nfunction createActivityPoller(params) {\n    const { client, requestFn, refreshIntervalMs = DEFAULT_REFRESH_INTERVAL_MS, } = params;\n    return async (input) => {\n        const initialResponse = await requestFn(input);\n        let activity = initialResponse.activity;\n        while (true) {\n            switch (activity.status) {\n                case \"ACTIVITY_STATUS_COMPLETED\": {\n                    return activity;\n                }\n                case \"ACTIVITY_STATUS_CREATED\": {\n                    // Async pending state -- keep polling\n                    break;\n                }\n                case \"ACTIVITY_STATUS_PENDING\": {\n                    // Async pending state -- keep polling\n                    break;\n                }\n                case \"ACTIVITY_STATUS_CONSENSUS_NEEDED\": {\n                    // If the activity requires consensus, we shouldn't be polling forever.\n                    // You can read the `TurnkeyActivityError` thrown to get the `activityId`,\n                    // store it somewhere, then re-fetch the activity via `.postGetActivity(...)`\n                    // when the required approvals/rejections are in place.\n                    throw new _shared_mjs__WEBPACK_IMPORTED_MODULE_1__.TurnkeyActivityError({\n                        message: `Consensus needed for activity ${activity.id}`,\n                        activityId: activity.id,\n                        activityStatus: activity.status,\n                        activityType: activity.type,\n                    });\n                }\n                case \"ACTIVITY_STATUS_FAILED\": {\n                    // Activity failed\n                    throw new _shared_mjs__WEBPACK_IMPORTED_MODULE_1__.TurnkeyActivityError({\n                        message: `Activity ${activity.id} failed`,\n                        activityId: activity.id,\n                        activityStatus: activity.status,\n                        activityType: activity.type,\n                    });\n                }\n                case \"ACTIVITY_STATUS_REJECTED\": {\n                    // Activity was rejected\n                    throw new _shared_mjs__WEBPACK_IMPORTED_MODULE_1__.TurnkeyActivityError({\n                        message: `Activity ${activity.id} was rejected`,\n                        activityId: activity.id,\n                        activityStatus: activity.status,\n                        activityType: activity.type,\n                    });\n                }\n                default: {\n                    // Make sure the switch block is exhaustive\n                    assertNever(activity.status);\n                }\n            }\n            await sleep(refreshIntervalMs);\n            const pollingResponse = await client.getActivity({\n                activityId: activity.id,\n                organizationId: activity.organizationId,\n            });\n            activity = pollingResponse.activity;\n        }\n    };\n}\nfunction sleep(ms) {\n    return new Promise((resolve) => {\n        setTimeout(() => {\n            resolve();\n        }, ms);\n    });\n}\nfunction assertNever(input, message) {\n    throw new Error(message != null ? message : `Unexpected case: ${JSON.stringify(input)}`);\n}\n\n\n//# sourceMappingURL=async.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvc29sYW5hL25vZGVfbW9kdWxlcy9AdHVybmtleS9odHRwL2Rpc3QvYXN5bmMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBb0c7QUFDaEQ7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGlCQUFpQjtBQUMvRCxRQUFRLHFCQUFxQixLQUFLLDRCQUE0QjtBQUM5RDtBQUNBO0FBQ0EsWUFBWSwyREFBMkQ7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDZEQUFvQjtBQUNsRCxrRUFBa0UsWUFBWTtBQUM5RTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDZEQUFvQjtBQUNsRCw2Q0FBNkMsYUFBYTtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDZEQUFvQjtBQUNsRCw2Q0FBNkMsYUFBYTtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsNkdBQVc7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxZQUFZLHNFQUFzRTtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsNkRBQW9CO0FBQ2xELGtFQUFrRSxZQUFZO0FBQzlFO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsNkRBQW9CO0FBQ2xELDZDQUE2QyxhQUFhO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsNkRBQW9CO0FBQ2xELDZDQUE2QyxhQUFhO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0Esb0VBQW9FLHNCQUFzQjtBQUMxRjs7QUFFa0Q7QUFDbEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9udXJzZWJsb2MvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvc29sYW5hL25vZGVfbW9kdWxlcy9AdHVybmtleS9odHRwL2Rpc3QvYXN5bmMubWpzPzQ1MjEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0QWN0aXZpdHkgfSBmcm9tICcuL19fZ2VuZXJhdGVkX18vc2VydmljZXMvY29vcmRpbmF0b3IvcHVibGljL3YxL3B1YmxpY19hcGkuZmV0Y2hlci5tanMnO1xuaW1wb3J0IHsgVHVybmtleUFjdGl2aXR5RXJyb3IgfSBmcm9tICcuL3NoYXJlZC5tanMnO1xuXG5jb25zdCBERUZBVUxUX1JFRlJFU0hfSU5URVJWQUxfTVMgPSA1MDA7XG4vKipcbiAqIFdyYXBzIGEgcmVxdWVzdCB0byBjcmVhdGUgYSBmZXRjaGVyIHdpdGggYnVpbHQtaW4gYXN5bmMgcG9sbGluZyBzdXBwb3J0LlxuICpcbiAqIEBkZXByZWNhdGVkIHRoaXMgZnVuY3Rpb24gb25seSB3b3JrcyB3aXRoIHtAbGluayBUdXJua2V5QXBpfS5cbiAqIFVzZSB7QGxpbmsgVHVybmtleUNsaWVudH0gYW5kIHtAbGluayBjcmVhdGVBY3Rpdml0eVBvbGxlcn0gaW5zdGVhZC5cbiAqL1xuZnVuY3Rpb24gd2l0aEFzeW5jUG9sbGluZyhwYXJhbXMpIHtcbiAgICBjb25zdCB7IHJlcXVlc3QsIHJlZnJlc2hJbnRlcnZhbE1zID0gREVGQVVMVF9SRUZSRVNIX0lOVEVSVkFMX01TIH0gPSBwYXJhbXM7XG4gICAgcmV0dXJuIGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICBjb25zdCBpbml0aWFsUmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0KGlucHV0KTtcbiAgICAgICAgbGV0IGFjdGl2aXR5ID0gaW5pdGlhbFJlc3BvbnNlLmFjdGl2aXR5O1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgc3dpdGNoIChhY3Rpdml0eS5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiQUNUSVZJVFlfU1RBVFVTX0NPTVBMRVRFRFwiOiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhY3Rpdml0eTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcIkFDVElWSVRZX1NUQVRVU19DUkVBVEVEXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXN5bmMgcGVuZGluZyBzdGF0ZSAtLSBrZWVwIHBvbGxpbmdcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJBQ1RJVklUWV9TVEFUVVNfUEVORElOR1wiOiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFzeW5jIHBlbmRpbmcgc3RhdGUgLS0ga2VlcCBwb2xsaW5nXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwiQUNUSVZJVFlfU1RBVFVTX0NPTlNFTlNVU19ORUVERURcIjoge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgYWN0aXZpdHkgcmVxdWlyZXMgY29uc2Vuc3VzLCB3ZSBzaG91bGRuJ3QgYmUgcG9sbGluZyBmb3JldmVyLlxuICAgICAgICAgICAgICAgICAgICAvLyBZb3UgY2FuIHJlYWQgdGhlIGBUdXJua2V5QWN0aXZpdHlFcnJvcmAgdGhyb3duIHRvIGdldCB0aGUgYGFjdGl2aXR5SWRgLFxuICAgICAgICAgICAgICAgICAgICAvLyBzdG9yZSBpdCBzb21ld2hlcmUsIHRoZW4gcmUtZmV0Y2ggdGhlIGFjdGl2aXR5IHZpYSBgLnBvc3RHZXRBY3Rpdml0eSguLi4pYFxuICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIHRoZSByZXF1aXJlZCBhcHByb3ZhbHMvcmVqZWN0aW9ucyBhcmUgaW4gcGxhY2UuXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUdXJua2V5QWN0aXZpdHlFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgQ29uc2Vuc3VzIG5lZWRlZCBmb3IgYWN0aXZpdHkgJHthY3Rpdml0eS5pZH1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZpdHlJZDogYWN0aXZpdHkuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpdml0eVN0YXR1czogYWN0aXZpdHkuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZpdHlUeXBlOiBhY3Rpdml0eS50eXBlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcIkFDVElWSVRZX1NUQVRVU19GQUlMRURcIjoge1xuICAgICAgICAgICAgICAgICAgICAvLyBBY3Rpdml0eSBmYWlsZWRcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR1cm5rZXlBY3Rpdml0eUVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBBY3Rpdml0eSAke2FjdGl2aXR5LmlkfSBmYWlsZWRgLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZpdHlJZDogYWN0aXZpdHkuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpdml0eVN0YXR1czogYWN0aXZpdHkuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZpdHlUeXBlOiBhY3Rpdml0eS50eXBlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcIkFDVElWSVRZX1NUQVRVU19SRUpFQ1RFRFwiOiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFjdGl2aXR5IHdhcyByZWplY3RlZFxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHVybmtleUFjdGl2aXR5RXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYEFjdGl2aXR5ICR7YWN0aXZpdHkuaWR9IHdhcyByZWplY3RlZGAsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpdml0eUlkOiBhY3Rpdml0eS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2aXR5U3RhdHVzOiBhY3Rpdml0eS5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpdml0eVR5cGU6IGFjdGl2aXR5LnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgc3dpdGNoIGJsb2NrIGlzIGV4aGF1c3RpdmVcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0TmV2ZXIoYWN0aXZpdHkuc3RhdHVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCBzbGVlcChyZWZyZXNoSW50ZXJ2YWxNcyk7XG4gICAgICAgICAgICBjb25zdCBwb2xsaW5nUmVzcG9uc2UgPSBhd2FpdCBnZXRBY3Rpdml0eSh7XG4gICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICBhY3Rpdml0eUlkOiBhY3Rpdml0eS5pZCxcbiAgICAgICAgICAgICAgICAgICAgb3JnYW5pemF0aW9uSWQ6IGFjdGl2aXR5Lm9yZ2FuaXphdGlvbklkLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGFjdGl2aXR5ID0gcG9sbGluZ1Jlc3BvbnNlLmFjdGl2aXR5O1xuICAgICAgICB9XG4gICAgfTtcbn1cbi8qKlxuICogV3JhcHMgYSBjbGllbnQgcmVxdWVzdCBmdW5jdGlvbiAoZS5nLiBgY2xpZW50LmNyZWF0ZVByaXZhdGVLZXlzYCkgaW4gYSBwb2xsZXIuXG4gKiBUaGUgZGVmYXVsdCByZWZyZXNoIGludGVydmFsIGlzIDUwMG1zLlxuICpcbiAqIFRoZSByZXR1cm5lZCBwb2xsZXIgd2lsbCBwb2xsIHVudGlsIHRoZSBhY3Rpdml0eSBiZWNvbWVzIGBDT01QTEVURURgLlxuICogSWYgdGhlIGFjdGl2aXR5IGJlY29tZXMgYEZBSUxFRGAgb3IgYFJFSkVDVEVEYCBvciBpcyBmbGFnZ2VkIGFzIGBORUVEU19DT05TRU5TVVNgLCBhbiBlcnJvciBpcyB0aHJvd24uXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IGFjdGl2aXR5UG9sbGVyID0gY3JlYXRlQWN0aXZpdHlQb2xsZXIoY2xpZW50LCBjbGllbnQuY3JlYXRlUHJpdmF0ZUtleXMpO1xuICogY29uc3QgYWN0aXZpdHkgPSBhd2FpdCBhY3Rpdml0eVBvbGxlcihpbnB1dCk7XG4gKiBjb25zb2xlLmxvZyhhY3Rpdml0eS5yZXN1bHQpOyAvLyBhY3Rpdml0eSBpcyBjb21wbGV0ZWRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQWN0aXZpdHlQb2xsZXIocGFyYW1zKSB7XG4gICAgY29uc3QgeyBjbGllbnQsIHJlcXVlc3RGbiwgcmVmcmVzaEludGVydmFsTXMgPSBERUZBVUxUX1JFRlJFU0hfSU5URVJWQUxfTVMsIH0gPSBwYXJhbXM7XG4gICAgcmV0dXJuIGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICBjb25zdCBpbml0aWFsUmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0Rm4oaW5wdXQpO1xuICAgICAgICBsZXQgYWN0aXZpdHkgPSBpbml0aWFsUmVzcG9uc2UuYWN0aXZpdHk7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGFjdGl2aXR5LnN0YXR1cykge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJBQ1RJVklUWV9TVEFUVVNfQ09NUExFVEVEXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjdGl2aXR5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwiQUNUSVZJVFlfU1RBVFVTX0NSRUFURURcIjoge1xuICAgICAgICAgICAgICAgICAgICAvLyBBc3luYyBwZW5kaW5nIHN0YXRlIC0tIGtlZXAgcG9sbGluZ1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcIkFDVElWSVRZX1NUQVRVU19QRU5ESU5HXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXN5bmMgcGVuZGluZyBzdGF0ZSAtLSBrZWVwIHBvbGxpbmdcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJBQ1RJVklUWV9TVEFUVVNfQ09OU0VOU1VTX05FRURFRFwiOiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBhY3Rpdml0eSByZXF1aXJlcyBjb25zZW5zdXMsIHdlIHNob3VsZG4ndCBiZSBwb2xsaW5nIGZvcmV2ZXIuXG4gICAgICAgICAgICAgICAgICAgIC8vIFlvdSBjYW4gcmVhZCB0aGUgYFR1cm5rZXlBY3Rpdml0eUVycm9yYCB0aHJvd24gdG8gZ2V0IHRoZSBgYWN0aXZpdHlJZGAsXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0b3JlIGl0IHNvbWV3aGVyZSwgdGhlbiByZS1mZXRjaCB0aGUgYWN0aXZpdHkgdmlhIGAucG9zdEdldEFjdGl2aXR5KC4uLilgXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gdGhlIHJlcXVpcmVkIGFwcHJvdmFscy9yZWplY3Rpb25zIGFyZSBpbiBwbGFjZS5cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR1cm5rZXlBY3Rpdml0eUVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBDb25zZW5zdXMgbmVlZGVkIGZvciBhY3Rpdml0eSAke2FjdGl2aXR5LmlkfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpdml0eUlkOiBhY3Rpdml0eS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2aXR5U3RhdHVzOiBhY3Rpdml0eS5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpdml0eVR5cGU6IGFjdGl2aXR5LnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwiQUNUSVZJVFlfU1RBVFVTX0ZBSUxFRFwiOiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFjdGl2aXR5IGZhaWxlZFxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHVybmtleUFjdGl2aXR5RXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYEFjdGl2aXR5ICR7YWN0aXZpdHkuaWR9IGZhaWxlZGAsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpdml0eUlkOiBhY3Rpdml0eS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2aXR5U3RhdHVzOiBhY3Rpdml0eS5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpdml0eVR5cGU6IGFjdGl2aXR5LnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwiQUNUSVZJVFlfU1RBVFVTX1JFSkVDVEVEXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWN0aXZpdHkgd2FzIHJlamVjdGVkXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUdXJua2V5QWN0aXZpdHlFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgQWN0aXZpdHkgJHthY3Rpdml0eS5pZH0gd2FzIHJlamVjdGVkYCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2aXR5SWQ6IGFjdGl2aXR5LmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZpdHlTdGF0dXM6IGFjdGl2aXR5LnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2aXR5VHlwZTogYWN0aXZpdHkudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBzd2l0Y2ggYmxvY2sgaXMgZXhoYXVzdGl2ZVxuICAgICAgICAgICAgICAgICAgICBhc3NlcnROZXZlcihhY3Rpdml0eS5zdGF0dXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IHNsZWVwKHJlZnJlc2hJbnRlcnZhbE1zKTtcbiAgICAgICAgICAgIGNvbnN0IHBvbGxpbmdSZXNwb25zZSA9IGF3YWl0IGNsaWVudC5nZXRBY3Rpdml0eSh7XG4gICAgICAgICAgICAgICAgYWN0aXZpdHlJZDogYWN0aXZpdHkuaWQsXG4gICAgICAgICAgICAgICAgb3JnYW5pemF0aW9uSWQ6IGFjdGl2aXR5Lm9yZ2FuaXphdGlvbklkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhY3Rpdml0eSA9IHBvbGxpbmdSZXNwb25zZS5hY3Rpdml0eTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBzbGVlcChtcykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSwgbXMpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gYXNzZXJ0TmV2ZXIoaW5wdXQsIG1lc3NhZ2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSAhPSBudWxsID8gbWVzc2FnZSA6IGBVbmV4cGVjdGVkIGNhc2U6ICR7SlNPTi5zdHJpbmdpZnkoaW5wdXQpfWApO1xufVxuXG5leHBvcnQgeyBjcmVhdGVBY3Rpdml0eVBvbGxlciwgd2l0aEFzeW5jUG9sbGluZyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXN5bmMubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/async.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/base.mjs":
/*!*******************************************************************************!*\
  !*** ./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/base.mjs ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TurnkeyRequestError: () => (/* binding */ TurnkeyRequestError),\n/* harmony export */   fetch: () => (/* reexport safe */ _universal_mjs__WEBPACK_IMPORTED_MODULE_1__.fetch),\n/* harmony export */   request: () => (/* binding */ request),\n/* harmony export */   sealAndStampRequestBody: () => (/* binding */ sealAndStampRequestBody),\n/* harmony export */   signedRequest: () => (/* binding */ signedRequest)\n/* harmony export */ });\n/* harmony import */ var _turnkey_api_key_stamper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @turnkey/api-key-stamper */ \"(ssr)/./node_modules/@turnkey/api-key-stamper/dist/index.mjs\");\n/* harmony import */ var _universal_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./universal.mjs */ \"(ssr)/./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/universal.mjs\");\n/* harmony import */ var _config_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./config.mjs */ \"(ssr)/./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/config.mjs\");\n/* harmony import */ var _turnkey_encoding__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @turnkey/encoding */ \"(ssr)/./node_modules/@turnkey/encoding/dist/index.mjs\");\n/* harmony import */ var _webauthn_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./webauthn.mjs */ \"(ssr)/./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/webauthn.mjs\");\n\n\n\n\n\n\nconst sharedHeaders = {};\nconst sharedRequestOptions = {\n    redirect: \"follow\",\n};\n/**\n * @deprecated\n */\nasync function signedRequest(input) {\n    const { uri: inputUri, query: inputQuery = {}, substitution: inputSubstitution = {}, body: inputBody = {}, } = input;\n    const url = constructUrl({\n        uri: inputUri,\n        query: inputQuery,\n        substitution: inputSubstitution,\n    });\n    const body = JSON.stringify(inputBody);\n    const stamp = await (0,_webauthn_mjs__WEBPACK_IMPORTED_MODULE_4__.getWebAuthnAssertion)(body, input.options);\n    return {\n        url: url.toString(),\n        body,\n        stamp,\n    };\n}\nasync function request(input) {\n    const { uri: inputUri, method, headers: inputHeaders = {}, query: inputQuery = {}, substitution: inputSubstitution = {}, body: inputBody = {}, } = input;\n    const url = constructUrl({\n        uri: inputUri,\n        query: inputQuery,\n        substitution: inputSubstitution,\n    });\n    const { sealedBody, xStamp } = await sealAndStampRequestBody({\n        body: inputBody,\n    });\n    const response = await (0,_universal_mjs__WEBPACK_IMPORTED_MODULE_1__.fetch)(url.toString(), {\n        ...sharedRequestOptions,\n        method,\n        headers: {\n            ...sharedHeaders,\n            ...inputHeaders,\n            \"X-Stamp\": xStamp,\n        },\n        body: sealedBody,\n    });\n    if (!response.ok) {\n        // Can't use native `cause` here because it's not well supported on Node v16\n        // https://node.green/#ES2022-features-Error-cause-property\n        let res;\n        try {\n            res = await response.json();\n        }\n        catch (_) {\n            throw new Error(`${response.status} ${response.statusText}`);\n        }\n        throw new TurnkeyRequestError(res);\n    }\n    const data = await response.json();\n    return data;\n}\nfunction constructUrl(input) {\n    const { uri, query, substitution } = input;\n    const baseUrl = getBaseUrl();\n    const url = new URL(substitutePath(uri, substitution), baseUrl);\n    for (const key in query) {\n        const value = query[key];\n        if (Array.isArray(value)) {\n            for (const item of value) {\n                url.searchParams.append(key, item);\n            }\n        }\n        else {\n            url.searchParams.append(key, value ?? \"\");\n        }\n    }\n    return url;\n}\nfunction getBaseUrl() {\n    try {\n        const { baseUrl } = (0,_config_mjs__WEBPACK_IMPORTED_MODULE_2__.getConfig)();\n        return baseUrl;\n    }\n    catch (e) {\n        const { baseUrl } = (0,_config_mjs__WEBPACK_IMPORTED_MODULE_2__.getBrowserConfig)();\n        return baseUrl;\n    }\n}\nfunction substitutePath(uri, substitutionMap) {\n    let result = uri;\n    const keyList = Object.keys(substitutionMap);\n    for (const key of keyList) {\n        const output = result.replaceAll(`{${key}}`, substitutionMap[key]);\n        invariant(output !== result, `Substitution error: cannot find \"${key}\" in URI \"${uri}\". \\`substitutionMap\\`: ${JSON.stringify(substitutionMap)}`);\n        result = output;\n    }\n    invariant(!/\\{.*\\}/.test(result), `Substitution error: found unsubstituted components in \"${result}\"`);\n    return result;\n}\nfunction invariant(condition, message) {\n    if (!condition) {\n        throw new Error(message);\n    }\n}\nfunction stableStringify(input) {\n    return JSON.stringify(input);\n}\n/**\n * Seals and stamps the request body with your Turnkey API credentials.\n *\n * You can either:\n * - Before calling `sealAndStampRequestBody(...)`, initialize with your Turnkey API credentials via `init(...)`\n * - Or, provide `apiPublicKey` and `apiPrivateKey` here as arguments\n */\nasync function sealAndStampRequestBody(input) {\n    const { body } = input;\n    let { apiPublicKey, apiPrivateKey } = input;\n    if (!apiPublicKey) {\n        const config = (0,_config_mjs__WEBPACK_IMPORTED_MODULE_2__.getConfig)();\n        apiPublicKey = config.apiPublicKey;\n    }\n    if (!apiPrivateKey) {\n        const config = (0,_config_mjs__WEBPACK_IMPORTED_MODULE_2__.getConfig)();\n        apiPrivateKey = config.apiPrivateKey;\n    }\n    const sealedBody = stableStringify(body);\n    const signature = await (0,_turnkey_api_key_stamper__WEBPACK_IMPORTED_MODULE_0__.signWithApiKey)({\n        content: sealedBody,\n        privateKey: apiPrivateKey,\n        publicKey: apiPublicKey,\n    });\n    const sealedStamp = stableStringify({\n        publicKey: apiPublicKey,\n        scheme: \"SIGNATURE_SCHEME_TK_API_P256\",\n        signature: signature,\n    });\n    const xStamp = (0,_turnkey_encoding__WEBPACK_IMPORTED_MODULE_3__.stringToBase64urlString)(sealedStamp);\n    return {\n        sealedBody,\n        xStamp,\n    };\n}\nclass TurnkeyRequestError extends Error {\n    constructor(input) {\n        let turnkeyErrorMessage = `Turnkey error ${input.code}: ${input.message}`;\n        if (input.details != null) {\n            turnkeyErrorMessage += ` (Details: ${JSON.stringify(input.details)})`;\n        }\n        super(turnkeyErrorMessage);\n        this.name = \"TurnkeyRequestError\";\n        this.details = input.details ?? null;\n        this.code = input.code;\n    }\n}\n\n\n//# sourceMappingURL=base.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvc29sYW5hL25vZGVfbW9kdWxlcy9AdHVybmtleS9odHRwL2Rpc3QvYmFzZS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUEwRDtBQUNsQjtBQUNtQjtBQUNDO0FBQ047O0FBRXREO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFDQUFxQyxzQ0FBc0Msc0JBQXNCLElBQUk7QUFDakg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3QkFBd0IsbUVBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpREFBaUQsd0JBQXdCLHNDQUFzQyxzQkFBc0IsSUFBSTtBQUNySjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxZQUFZLHFCQUFxQjtBQUNqQztBQUNBLEtBQUs7QUFDTCwyQkFBMkIscURBQUs7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsaUJBQWlCLEVBQUUsb0JBQW9CO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwyQkFBMkI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVLEVBQUUsc0RBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVUsRUFBRSw2REFBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsRUFBRSxLQUFLO0FBQ2xELHlFQUF5RSxJQUFJLFlBQVksSUFBSSwwQkFBMEIsZ0NBQWdDO0FBQ3ZKO0FBQ0E7QUFDQSxrQkFBa0IsSUFBSSwwRUFBMEUsT0FBTztBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsVUFBVSw4QkFBOEI7QUFDeEM7QUFDQSx1QkFBdUIsc0RBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNEQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix3RUFBYztBQUMxQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsbUJBQW1CLDBFQUF1QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxXQUFXLElBQUksY0FBYztBQUNoRjtBQUNBLGlEQUFpRCw4QkFBOEI7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXVGO0FBQ3ZGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbnVyc2VibG9jLy4vbm9kZV9tb2R1bGVzL0B0dXJua2V5L3NvbGFuYS9ub2RlX21vZHVsZXMvQHR1cm5rZXkvaHR0cC9kaXN0L2Jhc2UubWpzPzhmOWYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc2lnbldpdGhBcGlLZXkgfSBmcm9tICdAdHVybmtleS9hcGkta2V5LXN0YW1wZXInO1xuaW1wb3J0IHsgZmV0Y2ggfSBmcm9tICcuL3VuaXZlcnNhbC5tanMnO1xuaW1wb3J0IHsgZ2V0Q29uZmlnLCBnZXRCcm93c2VyQ29uZmlnIH0gZnJvbSAnLi9jb25maWcubWpzJztcbmltcG9ydCB7IHN0cmluZ1RvQmFzZTY0dXJsU3RyaW5nIH0gZnJvbSAnQHR1cm5rZXkvZW5jb2RpbmcnO1xuaW1wb3J0IHsgZ2V0V2ViQXV0aG5Bc3NlcnRpb24gfSBmcm9tICcuL3dlYmF1dGhuLm1qcyc7XG5cbmNvbnN0IHNoYXJlZEhlYWRlcnMgPSB7fTtcbmNvbnN0IHNoYXJlZFJlcXVlc3RPcHRpb25zID0ge1xuICAgIHJlZGlyZWN0OiBcImZvbGxvd1wiLFxufTtcbi8qKlxuICogQGRlcHJlY2F0ZWRcbiAqL1xuYXN5bmMgZnVuY3Rpb24gc2lnbmVkUmVxdWVzdChpbnB1dCkge1xuICAgIGNvbnN0IHsgdXJpOiBpbnB1dFVyaSwgcXVlcnk6IGlucHV0UXVlcnkgPSB7fSwgc3Vic3RpdHV0aW9uOiBpbnB1dFN1YnN0aXR1dGlvbiA9IHt9LCBib2R5OiBpbnB1dEJvZHkgPSB7fSwgfSA9IGlucHV0O1xuICAgIGNvbnN0IHVybCA9IGNvbnN0cnVjdFVybCh7XG4gICAgICAgIHVyaTogaW5wdXRVcmksXG4gICAgICAgIHF1ZXJ5OiBpbnB1dFF1ZXJ5LFxuICAgICAgICBzdWJzdGl0dXRpb246IGlucHV0U3Vic3RpdHV0aW9uLFxuICAgIH0pO1xuICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeShpbnB1dEJvZHkpO1xuICAgIGNvbnN0IHN0YW1wID0gYXdhaXQgZ2V0V2ViQXV0aG5Bc3NlcnRpb24oYm9keSwgaW5wdXQub3B0aW9ucyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXJsOiB1cmwudG9TdHJpbmcoKSxcbiAgICAgICAgYm9keSxcbiAgICAgICAgc3RhbXAsXG4gICAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHJlcXVlc3QoaW5wdXQpIHtcbiAgICBjb25zdCB7IHVyaTogaW5wdXRVcmksIG1ldGhvZCwgaGVhZGVyczogaW5wdXRIZWFkZXJzID0ge30sIHF1ZXJ5OiBpbnB1dFF1ZXJ5ID0ge30sIHN1YnN0aXR1dGlvbjogaW5wdXRTdWJzdGl0dXRpb24gPSB7fSwgYm9keTogaW5wdXRCb2R5ID0ge30sIH0gPSBpbnB1dDtcbiAgICBjb25zdCB1cmwgPSBjb25zdHJ1Y3RVcmwoe1xuICAgICAgICB1cmk6IGlucHV0VXJpLFxuICAgICAgICBxdWVyeTogaW5wdXRRdWVyeSxcbiAgICAgICAgc3Vic3RpdHV0aW9uOiBpbnB1dFN1YnN0aXR1dGlvbixcbiAgICB9KTtcbiAgICBjb25zdCB7IHNlYWxlZEJvZHksIHhTdGFtcCB9ID0gYXdhaXQgc2VhbEFuZFN0YW1wUmVxdWVzdEJvZHkoe1xuICAgICAgICBib2R5OiBpbnB1dEJvZHksXG4gICAgfSk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwudG9TdHJpbmcoKSwge1xuICAgICAgICAuLi5zaGFyZWRSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgbWV0aG9kLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAuLi5zaGFyZWRIZWFkZXJzLFxuICAgICAgICAgICAgLi4uaW5wdXRIZWFkZXJzLFxuICAgICAgICAgICAgXCJYLVN0YW1wXCI6IHhTdGFtcCxcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogc2VhbGVkQm9keSxcbiAgICB9KTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIC8vIENhbid0IHVzZSBuYXRpdmUgYGNhdXNlYCBoZXJlIGJlY2F1c2UgaXQncyBub3Qgd2VsbCBzdXBwb3J0ZWQgb24gTm9kZSB2MTZcbiAgICAgICAgLy8gaHR0cHM6Ly9ub2RlLmdyZWVuLyNFUzIwMjItZmVhdHVyZXMtRXJyb3ItY2F1c2UtcHJvcGVydHlcbiAgICAgICAgbGV0IHJlcztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlcyA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoXykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBUdXJua2V5UmVxdWVzdEVycm9yKHJlcyk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgcmV0dXJuIGRhdGE7XG59XG5mdW5jdGlvbiBjb25zdHJ1Y3RVcmwoaW5wdXQpIHtcbiAgICBjb25zdCB7IHVyaSwgcXVlcnksIHN1YnN0aXR1dGlvbiB9ID0gaW5wdXQ7XG4gICAgY29uc3QgYmFzZVVybCA9IGdldEJhc2VVcmwoKTtcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHN1YnN0aXR1dGVQYXRoKHVyaSwgc3Vic3RpdHV0aW9uKSwgYmFzZVVybCk7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcXVlcnkpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBxdWVyeVtrZXldO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHZhbHVlID8/IFwiXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1cmw7XG59XG5mdW5jdGlvbiBnZXRCYXNlVXJsKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHsgYmFzZVVybCB9ID0gZ2V0Q29uZmlnKCk7XG4gICAgICAgIHJldHVybiBiYXNlVXJsO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBjb25zdCB7IGJhc2VVcmwgfSA9IGdldEJyb3dzZXJDb25maWcoKTtcbiAgICAgICAgcmV0dXJuIGJhc2VVcmw7XG4gICAgfVxufVxuZnVuY3Rpb24gc3Vic3RpdHV0ZVBhdGgodXJpLCBzdWJzdGl0dXRpb25NYXApIHtcbiAgICBsZXQgcmVzdWx0ID0gdXJpO1xuICAgIGNvbnN0IGtleUxpc3QgPSBPYmplY3Qua2V5cyhzdWJzdGl0dXRpb25NYXApO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleUxpc3QpIHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gcmVzdWx0LnJlcGxhY2VBbGwoYHske2tleX19YCwgc3Vic3RpdHV0aW9uTWFwW2tleV0pO1xuICAgICAgICBpbnZhcmlhbnQob3V0cHV0ICE9PSByZXN1bHQsIGBTdWJzdGl0dXRpb24gZXJyb3I6IGNhbm5vdCBmaW5kIFwiJHtrZXl9XCIgaW4gVVJJIFwiJHt1cml9XCIuIFxcYHN1YnN0aXR1dGlvbk1hcFxcYDogJHtKU09OLnN0cmluZ2lmeShzdWJzdGl0dXRpb25NYXApfWApO1xuICAgICAgICByZXN1bHQgPSBvdXRwdXQ7XG4gICAgfVxuICAgIGludmFyaWFudCghL1xcey4qXFx9Ly50ZXN0KHJlc3VsdCksIGBTdWJzdGl0dXRpb24gZXJyb3I6IGZvdW5kIHVuc3Vic3RpdHV0ZWQgY29tcG9uZW50cyBpbiBcIiR7cmVzdWx0fVwiYCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gc3RhYmxlU3RyaW5naWZ5KGlucHV0KSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGlucHV0KTtcbn1cbi8qKlxuICogU2VhbHMgYW5kIHN0YW1wcyB0aGUgcmVxdWVzdCBib2R5IHdpdGggeW91ciBUdXJua2V5IEFQSSBjcmVkZW50aWFscy5cbiAqXG4gKiBZb3UgY2FuIGVpdGhlcjpcbiAqIC0gQmVmb3JlIGNhbGxpbmcgYHNlYWxBbmRTdGFtcFJlcXVlc3RCb2R5KC4uLilgLCBpbml0aWFsaXplIHdpdGggeW91ciBUdXJua2V5IEFQSSBjcmVkZW50aWFscyB2aWEgYGluaXQoLi4uKWBcbiAqIC0gT3IsIHByb3ZpZGUgYGFwaVB1YmxpY0tleWAgYW5kIGBhcGlQcml2YXRlS2V5YCBoZXJlIGFzIGFyZ3VtZW50c1xuICovXG5hc3luYyBmdW5jdGlvbiBzZWFsQW5kU3RhbXBSZXF1ZXN0Qm9keShpbnB1dCkge1xuICAgIGNvbnN0IHsgYm9keSB9ID0gaW5wdXQ7XG4gICAgbGV0IHsgYXBpUHVibGljS2V5LCBhcGlQcml2YXRlS2V5IH0gPSBpbnB1dDtcbiAgICBpZiAoIWFwaVB1YmxpY0tleSkge1xuICAgICAgICBjb25zdCBjb25maWcgPSBnZXRDb25maWcoKTtcbiAgICAgICAgYXBpUHVibGljS2V5ID0gY29uZmlnLmFwaVB1YmxpY0tleTtcbiAgICB9XG4gICAgaWYgKCFhcGlQcml2YXRlS2V5KSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IGdldENvbmZpZygpO1xuICAgICAgICBhcGlQcml2YXRlS2V5ID0gY29uZmlnLmFwaVByaXZhdGVLZXk7XG4gICAgfVxuICAgIGNvbnN0IHNlYWxlZEJvZHkgPSBzdGFibGVTdHJpbmdpZnkoYm9keSk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgc2lnbldpdGhBcGlLZXkoe1xuICAgICAgICBjb250ZW50OiBzZWFsZWRCb2R5LFxuICAgICAgICBwcml2YXRlS2V5OiBhcGlQcml2YXRlS2V5LFxuICAgICAgICBwdWJsaWNLZXk6IGFwaVB1YmxpY0tleSxcbiAgICB9KTtcbiAgICBjb25zdCBzZWFsZWRTdGFtcCA9IHN0YWJsZVN0cmluZ2lmeSh7XG4gICAgICAgIHB1YmxpY0tleTogYXBpUHVibGljS2V5LFxuICAgICAgICBzY2hlbWU6IFwiU0lHTkFUVVJFX1NDSEVNRV9US19BUElfUDI1NlwiLFxuICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZSxcbiAgICB9KTtcbiAgICBjb25zdCB4U3RhbXAgPSBzdHJpbmdUb0Jhc2U2NHVybFN0cmluZyhzZWFsZWRTdGFtcCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2VhbGVkQm9keSxcbiAgICAgICAgeFN0YW1wLFxuICAgIH07XG59XG5jbGFzcyBUdXJua2V5UmVxdWVzdEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGlucHV0KSB7XG4gICAgICAgIGxldCB0dXJua2V5RXJyb3JNZXNzYWdlID0gYFR1cm5rZXkgZXJyb3IgJHtpbnB1dC5jb2RlfTogJHtpbnB1dC5tZXNzYWdlfWA7XG4gICAgICAgIGlmIChpbnB1dC5kZXRhaWxzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHR1cm5rZXlFcnJvck1lc3NhZ2UgKz0gYCAoRGV0YWlsczogJHtKU09OLnN0cmluZ2lmeShpbnB1dC5kZXRhaWxzKX0pYDtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcih0dXJua2V5RXJyb3JNZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJUdXJua2V5UmVxdWVzdEVycm9yXCI7XG4gICAgICAgIHRoaXMuZGV0YWlscyA9IGlucHV0LmRldGFpbHMgPz8gbnVsbDtcbiAgICAgICAgdGhpcy5jb2RlID0gaW5wdXQuY29kZTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IFR1cm5rZXlSZXF1ZXN0RXJyb3IsIGZldGNoLCByZXF1ZXN0LCBzZWFsQW5kU3RhbXBSZXF1ZXN0Qm9keSwgc2lnbmVkUmVxdWVzdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZS5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/base.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/config.mjs":
/*!*********************************************************************************!*\
  !*** ./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/config.mjs ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   browserInit: () => (/* binding */ browserInit),\n/* harmony export */   getBrowserConfig: () => (/* binding */ getBrowserConfig),\n/* harmony export */   getConfig: () => (/* binding */ getConfig),\n/* harmony export */   init: () => (/* binding */ init)\n/* harmony export */ });\nconst config = {\n    apiPublicKey: null,\n    apiPrivateKey: null,\n    baseUrl: null,\n};\nconst browserConfig = {\n    baseUrl: null,\n};\n/**\n * @deprecated use {@link TurnkeyClient} instead, which doesn't rely on global initialization logic.\n */\nfunction browserInit(value) {\n    browserConfig.baseUrl = assertNonEmptyString(value.baseUrl, \"baseUrl\");\n}\n/**\n * @deprecated use {@link TurnkeyClient} instead, which doesn't rely on global initialization logic.\n */\nfunction init(value) {\n    config.apiPublicKey = assertNonEmptyString(value.apiPublicKey, \"apiPublicKey\");\n    config.apiPrivateKey = assertNonEmptyString(value.apiPrivateKey, \"apiPrivateKey\");\n    config.baseUrl = assertNonEmptyString(value.baseUrl, \"baseUrl\");\n}\nfunction getConfig() {\n    return {\n        apiPublicKey: assertNonEmptyString(config.apiPublicKey, \"apiPublicKey\"),\n        apiPrivateKey: assertNonEmptyString(config.apiPrivateKey, \"apiPrivateKey\"),\n        baseUrl: assertNonEmptyString(config.baseUrl, \"baseUrl\"),\n    };\n}\nfunction getBrowserConfig() {\n    return {\n        baseUrl: assertNonEmptyString(browserConfig.baseUrl, \"baseUrl\"),\n    };\n}\nfunction assertNonEmptyString(input, name) {\n    if (typeof input !== \"string\" || !input) {\n        throw new Error(`\"${name}\" must be a non-empty string`);\n    }\n    return input;\n}\n\n\n//# sourceMappingURL=config.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvc29sYW5hL25vZGVfbW9kdWxlcy9AdHVybmtleS9odHRwL2Rpc3QvY29uZmlnLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLEtBQUs7QUFDakM7QUFDQTtBQUNBOztBQUUwRDtBQUMxRCIsInNvdXJjZXMiOlsid2VicGFjazovL251cnNlYmxvYy8uL25vZGVfbW9kdWxlcy9AdHVybmtleS9zb2xhbmEvbm9kZV9tb2R1bGVzL0B0dXJua2V5L2h0dHAvZGlzdC9jb25maWcubWpzPzI0ZTMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgY29uZmlnID0ge1xuICAgIGFwaVB1YmxpY0tleTogbnVsbCxcbiAgICBhcGlQcml2YXRlS2V5OiBudWxsLFxuICAgIGJhc2VVcmw6IG51bGwsXG59O1xuY29uc3QgYnJvd3NlckNvbmZpZyA9IHtcbiAgICBiYXNlVXJsOiBudWxsLFxufTtcbi8qKlxuICogQGRlcHJlY2F0ZWQgdXNlIHtAbGluayBUdXJua2V5Q2xpZW50fSBpbnN0ZWFkLCB3aGljaCBkb2Vzbid0IHJlbHkgb24gZ2xvYmFsIGluaXRpYWxpemF0aW9uIGxvZ2ljLlxuICovXG5mdW5jdGlvbiBicm93c2VySW5pdCh2YWx1ZSkge1xuICAgIGJyb3dzZXJDb25maWcuYmFzZVVybCA9IGFzc2VydE5vbkVtcHR5U3RyaW5nKHZhbHVlLmJhc2VVcmwsIFwiYmFzZVVybFwiKTtcbn1cbi8qKlxuICogQGRlcHJlY2F0ZWQgdXNlIHtAbGluayBUdXJua2V5Q2xpZW50fSBpbnN0ZWFkLCB3aGljaCBkb2Vzbid0IHJlbHkgb24gZ2xvYmFsIGluaXRpYWxpemF0aW9uIGxvZ2ljLlxuICovXG5mdW5jdGlvbiBpbml0KHZhbHVlKSB7XG4gICAgY29uZmlnLmFwaVB1YmxpY0tleSA9IGFzc2VydE5vbkVtcHR5U3RyaW5nKHZhbHVlLmFwaVB1YmxpY0tleSwgXCJhcGlQdWJsaWNLZXlcIik7XG4gICAgY29uZmlnLmFwaVByaXZhdGVLZXkgPSBhc3NlcnROb25FbXB0eVN0cmluZyh2YWx1ZS5hcGlQcml2YXRlS2V5LCBcImFwaVByaXZhdGVLZXlcIik7XG4gICAgY29uZmlnLmJhc2VVcmwgPSBhc3NlcnROb25FbXB0eVN0cmluZyh2YWx1ZS5iYXNlVXJsLCBcImJhc2VVcmxcIik7XG59XG5mdW5jdGlvbiBnZXRDb25maWcoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYXBpUHVibGljS2V5OiBhc3NlcnROb25FbXB0eVN0cmluZyhjb25maWcuYXBpUHVibGljS2V5LCBcImFwaVB1YmxpY0tleVwiKSxcbiAgICAgICAgYXBpUHJpdmF0ZUtleTogYXNzZXJ0Tm9uRW1wdHlTdHJpbmcoY29uZmlnLmFwaVByaXZhdGVLZXksIFwiYXBpUHJpdmF0ZUtleVwiKSxcbiAgICAgICAgYmFzZVVybDogYXNzZXJ0Tm9uRW1wdHlTdHJpbmcoY29uZmlnLmJhc2VVcmwsIFwiYmFzZVVybFwiKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0QnJvd3NlckNvbmZpZygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBiYXNlVXJsOiBhc3NlcnROb25FbXB0eVN0cmluZyhicm93c2VyQ29uZmlnLmJhc2VVcmwsIFwiYmFzZVVybFwiKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gYXNzZXJ0Tm9uRW1wdHlTdHJpbmcoaW5wdXQsIG5hbWUpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ICE9PSBcInN0cmluZ1wiIHx8ICFpbnB1dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHtuYW1lfVwiIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nYCk7XG4gICAgfVxuICAgIHJldHVybiBpbnB1dDtcbn1cblxuZXhwb3J0IHsgYnJvd3NlckluaXQsIGdldEJyb3dzZXJDb25maWcsIGdldENvbmZpZywgaW5pdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uZmlnLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/config.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/index.mjs":
/*!********************************************************************************!*\
  !*** ./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/index.mjs ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PublicApiService: () => (/* binding */ PublicApiService),\n/* harmony export */   TurnkeyActivityError: () => (/* reexport safe */ _shared_mjs__WEBPACK_IMPORTED_MODULE_4__.TurnkeyActivityError),\n/* harmony export */   TurnkeyApi: () => (/* reexport module object */ _generated_services_coordinator_public_v1_public_api_fetcher_mjs__WEBPACK_IMPORTED_MODULE_0__),\n/* harmony export */   TurnkeyClient: () => (/* reexport safe */ _generated_services_coordinator_public_v1_public_api_client_mjs__WEBPACK_IMPORTED_MODULE_1__.TurnkeyClient),\n/* harmony export */   TurnkeyRequestError: () => (/* reexport safe */ _base_mjs__WEBPACK_IMPORTED_MODULE_3__.TurnkeyRequestError),\n/* harmony export */   VERSION: () => (/* reexport safe */ _version_mjs__WEBPACK_IMPORTED_MODULE_7__.VERSION),\n/* harmony export */   browserInit: () => (/* reexport safe */ _config_mjs__WEBPACK_IMPORTED_MODULE_2__.browserInit),\n/* harmony export */   createActivityPoller: () => (/* reexport safe */ _async_mjs__WEBPACK_IMPORTED_MODULE_6__.createActivityPoller),\n/* harmony export */   getWebAuthnAttestation: () => (/* reexport safe */ _webauthn_mjs__WEBPACK_IMPORTED_MODULE_5__.getWebAuthnAttestation),\n/* harmony export */   init: () => (/* reexport safe */ _config_mjs__WEBPACK_IMPORTED_MODULE_2__.init),\n/* harmony export */   sealAndStampRequestBody: () => (/* reexport safe */ _base_mjs__WEBPACK_IMPORTED_MODULE_3__.sealAndStampRequestBody),\n/* harmony export */   withAsyncPolling: () => (/* reexport safe */ _async_mjs__WEBPACK_IMPORTED_MODULE_6__.withAsyncPolling)\n/* harmony export */ });\n/* harmony import */ var _generated_services_coordinator_public_v1_public_api_fetcher_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./__generated__/services/coordinator/public/v1/public_api.fetcher.mjs */ \"(ssr)/./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/__generated__/services/coordinator/public/v1/public_api.fetcher.mjs\");\n/* harmony import */ var _generated_services_coordinator_public_v1_public_api_client_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./__generated__/services/coordinator/public/v1/public_api.client.mjs */ \"(ssr)/./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/__generated__/services/coordinator/public/v1/public_api.client.mjs\");\n/* harmony import */ var _config_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./config.mjs */ \"(ssr)/./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/config.mjs\");\n/* harmony import */ var _base_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./base.mjs */ \"(ssr)/./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/base.mjs\");\n/* harmony import */ var _shared_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./shared.mjs */ \"(ssr)/./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/shared.mjs\");\n/* harmony import */ var _webauthn_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./webauthn.mjs */ \"(ssr)/./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/webauthn.mjs\");\n/* harmony import */ var _async_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./async.mjs */ \"(ssr)/./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/async.mjs\");\n/* harmony import */ var _version_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./version.mjs */ \"(ssr)/./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/version.mjs\");\n\n\n\n\n\n\n\n\n\n/**\n * @deprecated use `TurnkeyApi` instead\n */\nconst PublicApiService = _generated_services_coordinator_public_v1_public_api_fetcher_mjs__WEBPACK_IMPORTED_MODULE_0__;\n\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvc29sYW5hL25vZGVfbW9kdWxlcy9AdHVybmtleS9odHRwL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTRHO0FBQ1A7QUFDcEQ7QUFDeUI7QUFDdEI7QUFDSTtBQUNhO0FBQzdCOztBQUV4QztBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNkZBQWtCOztBQUVtQjtBQUM5RCIsInNvdXJjZXMiOlsid2VicGFjazovL251cnNlYmxvYy8uL25vZGVfbW9kdWxlcy9AdHVybmtleS9zb2xhbmEvbm9kZV9tb2R1bGVzL0B0dXJua2V5L2h0dHAvZGlzdC9pbmRleC5tanM/MWQwOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBwdWJsaWNfYXBpX2ZldGNoZXIgZnJvbSAnLi9fX2dlbmVyYXRlZF9fL3NlcnZpY2VzL2Nvb3JkaW5hdG9yL3B1YmxpYy92MS9wdWJsaWNfYXBpLmZldGNoZXIubWpzJztcbmV4cG9ydCB7IFR1cm5rZXlDbGllbnQgfSBmcm9tICcuL19fZ2VuZXJhdGVkX18vc2VydmljZXMvY29vcmRpbmF0b3IvcHVibGljL3YxL3B1YmxpY19hcGkuY2xpZW50Lm1qcyc7XG5leHBvcnQgeyBicm93c2VySW5pdCwgaW5pdCB9IGZyb20gJy4vY29uZmlnLm1qcyc7XG5leHBvcnQgeyBUdXJua2V5UmVxdWVzdEVycm9yLCBzZWFsQW5kU3RhbXBSZXF1ZXN0Qm9keSB9IGZyb20gJy4vYmFzZS5tanMnO1xuZXhwb3J0IHsgVHVybmtleUFjdGl2aXR5RXJyb3IgfSBmcm9tICcuL3NoYXJlZC5tanMnO1xuZXhwb3J0IHsgZ2V0V2ViQXV0aG5BdHRlc3RhdGlvbiB9IGZyb20gJy4vd2ViYXV0aG4ubWpzJztcbmV4cG9ydCB7IGNyZWF0ZUFjdGl2aXR5UG9sbGVyLCB3aXRoQXN5bmNQb2xsaW5nIH0gZnJvbSAnLi9hc3luYy5tanMnO1xuZXhwb3J0IHsgVkVSU0lPTiB9IGZyb20gJy4vdmVyc2lvbi5tanMnO1xuXG4vKipcbiAqIEBkZXByZWNhdGVkIHVzZSBgVHVybmtleUFwaWAgaW5zdGVhZFxuICovXG5jb25zdCBQdWJsaWNBcGlTZXJ2aWNlID0gcHVibGljX2FwaV9mZXRjaGVyO1xuXG5leHBvcnQgeyBQdWJsaWNBcGlTZXJ2aWNlLCBwdWJsaWNfYXBpX2ZldGNoZXIgYXMgVHVybmtleUFwaSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/shared.mjs":
/*!*********************************************************************************!*\
  !*** ./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/shared.mjs ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TurnkeyActivityError: () => (/* binding */ TurnkeyActivityError)\n/* harmony export */ });\nclass TurnkeyActivityError extends Error {\n    constructor(input) {\n        const { message, cause, activityId, activityStatus, activityType } = input;\n        super(message);\n        this.name = \"TurnkeyActivityError\";\n        this.activityId = activityId ?? null;\n        this.activityStatus = activityStatus ?? null;\n        this.activityType = activityType ?? null;\n        this.cause = cause ?? null;\n    }\n}\n\n\n//# sourceMappingURL=shared.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvc29sYW5hL25vZGVfbW9kdWxlcy9AdHVybmtleS9odHRwL2Rpc3Qvc2hhcmVkLm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBLGdCQUFnQiwyREFBMkQ7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZ0M7QUFDaEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9udXJzZWJsb2MvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvc29sYW5hL25vZGVfbW9kdWxlcy9AdHVybmtleS9odHRwL2Rpc3Qvc2hhcmVkLm1qcz82MmNhIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIFR1cm5rZXlBY3Rpdml0eUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZSwgY2F1c2UsIGFjdGl2aXR5SWQsIGFjdGl2aXR5U3RhdHVzLCBhY3Rpdml0eVR5cGUgfSA9IGlucHV0O1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJUdXJua2V5QWN0aXZpdHlFcnJvclwiO1xuICAgICAgICB0aGlzLmFjdGl2aXR5SWQgPSBhY3Rpdml0eUlkID8/IG51bGw7XG4gICAgICAgIHRoaXMuYWN0aXZpdHlTdGF0dXMgPSBhY3Rpdml0eVN0YXR1cyA/PyBudWxsO1xuICAgICAgICB0aGlzLmFjdGl2aXR5VHlwZSA9IGFjdGl2aXR5VHlwZSA/PyBudWxsO1xuICAgICAgICB0aGlzLmNhdXNlID0gY2F1c2UgPz8gbnVsbDtcbiAgICB9XG59XG5cbmV4cG9ydCB7IFR1cm5rZXlBY3Rpdml0eUVycm9yIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGFyZWQubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/shared.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/universal.mjs":
/*!************************************************************************************!*\
  !*** ./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/universal.mjs ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fetch: () => (/* binding */ fetch)\n/* harmony export */ });\n/* harmony import */ var cross_fetch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cross-fetch */ \"(ssr)/./node_modules/cross-fetch/dist/node-ponyfill.js\");\n\n\n/// <reference lib=\"dom\" />\n// This is useful for mocking fetch in tests.\nconst fetch = cross_fetch__WEBPACK_IMPORTED_MODULE_0__.fetch;\n\n\n//# sourceMappingURL=universal.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvc29sYW5hL25vZGVfbW9kdWxlcy9AdHVybmtleS9odHRwL2Rpc3QvdW5pdmVyc2FsLm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUErQzs7QUFFL0M7QUFDQTtBQUNBLGNBQWMsOENBQU87O0FBRUo7QUFDakIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9udXJzZWJsb2MvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvc29sYW5hL25vZGVfbW9kdWxlcy9AdHVybmtleS9odHRwL2Rpc3QvdW5pdmVyc2FsLm1qcz80NDA4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGZldGNoIGFzIGZldGNoJDEgfSBmcm9tICdjcm9zcy1mZXRjaCc7XG5cbi8vLyA8cmVmZXJlbmNlIGxpYj1cImRvbVwiIC8+XG4vLyBUaGlzIGlzIHVzZWZ1bCBmb3IgbW9ja2luZyBmZXRjaCBpbiB0ZXN0cy5cbmNvbnN0IGZldGNoID0gZmV0Y2gkMTtcblxuZXhwb3J0IHsgZmV0Y2ggfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVuaXZlcnNhbC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/universal.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/version.mjs":
/*!**********************************************************************************!*\
  !*** ./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/version.mjs ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   VERSION: () => (/* binding */ VERSION)\n/* harmony export */ });\nconst VERSION = \"@turnkey/http@2.7.1\";\n\n\n//# sourceMappingURL=version.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvc29sYW5hL25vZGVfbW9kdWxlcy9AdHVybmtleS9odHRwL2Rpc3QvdmVyc2lvbi5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBOztBQUVtQjtBQUNuQiIsInNvdXJjZXMiOlsid2VicGFjazovL251cnNlYmxvYy8uL25vZGVfbW9kdWxlcy9AdHVybmtleS9zb2xhbmEvbm9kZV9tb2R1bGVzL0B0dXJua2V5L2h0dHAvZGlzdC92ZXJzaW9uLm1qcz9jNTBlIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFZFUlNJT04gPSBcIkB0dXJua2V5L2h0dHBAMi43LjFcIjtcblxuZXhwb3J0IHsgVkVSU0lPTiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVyc2lvbi5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/version.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/webauthn-json/api.mjs":
/*!********************************************************************************************!*\
  !*** ./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/webauthn-json/api.mjs ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createResponseToJSON: () => (/* binding */ createResponseToJSON),\n/* harmony export */   getResponseToJSON: () => (/* binding */ getResponseToJSON)\n/* harmony export */ });\n/* harmony import */ var _base64url_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base64url.mjs */ \"(ssr)/./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/webauthn-json/base64url.mjs\");\n/* harmony import */ var _convert_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./convert.mjs */ \"(ssr)/./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/webauthn-json/convert.mjs\");\n/* harmony import */ var _schema_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./schema.mjs */ \"(ssr)/./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/webauthn-json/schema.mjs\");\n\n\n\n\nfunction createResponseToJSON(credential) {\n    return (0,_convert_mjs__WEBPACK_IMPORTED_MODULE_1__.convert)(_base64url_mjs__WEBPACK_IMPORTED_MODULE_0__.bufferToBase64url, _schema_mjs__WEBPACK_IMPORTED_MODULE_2__.publicKeyCredentialWithAttestation, credential);\n}\nfunction getResponseToJSON(credential) {\n    return (0,_convert_mjs__WEBPACK_IMPORTED_MODULE_1__.convert)(_base64url_mjs__WEBPACK_IMPORTED_MODULE_0__.bufferToBase64url, _schema_mjs__WEBPACK_IMPORTED_MODULE_2__.publicKeyCredentialWithAssertion, credential);\n}\n\n\n//# sourceMappingURL=api.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvc29sYW5hL25vZGVfbW9kdWxlcy9AdHVybmtleS9odHRwL2Rpc3Qvd2ViYXV0aG4tanNvbi9hcGkubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQW9EO0FBQ1o7QUFDNEQ7O0FBRXBHO0FBQ0EsV0FBVyxxREFBTyxDQUFDLDZEQUFpQixFQUFFLDJFQUFrQztBQUN4RTtBQUNBO0FBQ0EsV0FBVyxxREFBTyxDQUFDLDZEQUFpQixFQUFFLHlFQUFnQztBQUN0RTs7QUFFbUQ7QUFDbkQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9udXJzZWJsb2MvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvc29sYW5hL25vZGVfbW9kdWxlcy9AdHVybmtleS9odHRwL2Rpc3Qvd2ViYXV0aG4tanNvbi9hcGkubWpzPzQ1NjciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYnVmZmVyVG9CYXNlNjR1cmwgfSBmcm9tICcuL2Jhc2U2NHVybC5tanMnO1xuaW1wb3J0IHsgY29udmVydCB9IGZyb20gJy4vY29udmVydC5tanMnO1xuaW1wb3J0IHsgcHVibGljS2V5Q3JlZGVudGlhbFdpdGhBdHRlc3RhdGlvbiwgcHVibGljS2V5Q3JlZGVudGlhbFdpdGhBc3NlcnRpb24gfSBmcm9tICcuL3NjaGVtYS5tanMnO1xuXG5mdW5jdGlvbiBjcmVhdGVSZXNwb25zZVRvSlNPTihjcmVkZW50aWFsKSB7XG4gICAgcmV0dXJuIGNvbnZlcnQoYnVmZmVyVG9CYXNlNjR1cmwsIHB1YmxpY0tleUNyZWRlbnRpYWxXaXRoQXR0ZXN0YXRpb24sIGNyZWRlbnRpYWwpO1xufVxuZnVuY3Rpb24gZ2V0UmVzcG9uc2VUb0pTT04oY3JlZGVudGlhbCkge1xuICAgIHJldHVybiBjb252ZXJ0KGJ1ZmZlclRvQmFzZTY0dXJsLCBwdWJsaWNLZXlDcmVkZW50aWFsV2l0aEFzc2VydGlvbiwgY3JlZGVudGlhbCk7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZVJlc3BvbnNlVG9KU09OLCBnZXRSZXNwb25zZVRvSlNPTiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBpLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/webauthn-json/api.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/webauthn-json/base64url.mjs":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/webauthn-json/base64url.mjs ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bufferToBase64url: () => (/* binding */ bufferToBase64url)\n/* harmony export */ });\nfunction bufferToBase64url(buffer) {\n    // Buffer to binary string\n    const byteView = new Uint8Array(buffer);\n    let str = \"\";\n    for (const charCode of byteView) {\n        str += String.fromCharCode(charCode);\n    }\n    // Binary string to base64\n    const base64String = btoa(str);\n    // Base64 to base64url\n    // We assume that the base64url string is well-formed.\n    const base64urlString = base64String\n        .replace(/\\+/g, \"-\")\n        .replace(/\\//g, \"_\")\n        .replace(/=/g, \"\");\n    return base64urlString;\n}\n\n\n//# sourceMappingURL=base64url.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvc29sYW5hL25vZGVfbW9kdWxlcy9AdHVybmtleS9odHRwL2Rpc3Qvd2ViYXV0aG4tanNvbi9iYXNlNjR1cmwubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU2QjtBQUM3QiIsInNvdXJjZXMiOlsid2VicGFjazovL251cnNlYmxvYy8uL25vZGVfbW9kdWxlcy9AdHVybmtleS9zb2xhbmEvbm9kZV9tb2R1bGVzL0B0dXJua2V5L2h0dHAvZGlzdC93ZWJhdXRobi1qc29uL2Jhc2U2NHVybC5tanM/MjJiMiJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBidWZmZXJUb0Jhc2U2NHVybChidWZmZXIpIHtcbiAgICAvLyBCdWZmZXIgdG8gYmluYXJ5IHN0cmluZ1xuICAgIGNvbnN0IGJ5dGVWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICBsZXQgc3RyID0gXCJcIjtcbiAgICBmb3IgKGNvbnN0IGNoYXJDb2RlIG9mIGJ5dGVWaWV3KSB7XG4gICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKTtcbiAgICB9XG4gICAgLy8gQmluYXJ5IHN0cmluZyB0byBiYXNlNjRcbiAgICBjb25zdCBiYXNlNjRTdHJpbmcgPSBidG9hKHN0cik7XG4gICAgLy8gQmFzZTY0IHRvIGJhc2U2NHVybFxuICAgIC8vIFdlIGFzc3VtZSB0aGF0IHRoZSBiYXNlNjR1cmwgc3RyaW5nIGlzIHdlbGwtZm9ybWVkLlxuICAgIGNvbnN0IGJhc2U2NHVybFN0cmluZyA9IGJhc2U2NFN0cmluZ1xuICAgICAgICAucmVwbGFjZSgvXFwrL2csIFwiLVwiKVxuICAgICAgICAucmVwbGFjZSgvXFwvL2csIFwiX1wiKVxuICAgICAgICAucmVwbGFjZSgvPS9nLCBcIlwiKTtcbiAgICByZXR1cm4gYmFzZTY0dXJsU3RyaW5nO1xufVxuXG5leHBvcnQgeyBidWZmZXJUb0Jhc2U2NHVybCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZTY0dXJsLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/webauthn-json/base64url.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/webauthn-json/convert.mjs":
/*!************************************************************************************************!*\
  !*** ./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/webauthn-json/convert.mjs ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   convert: () => (/* binding */ convert),\n/* harmony export */   convertValue: () => (/* binding */ convertValue),\n/* harmony export */   copyValue: () => (/* binding */ copyValue),\n/* harmony export */   derived: () => (/* binding */ derived),\n/* harmony export */   optional: () => (/* binding */ optional),\n/* harmony export */   required: () => (/* binding */ required)\n/* harmony export */ });\n// We export these values in order so that they can be used to deduplicate\n// schema definitions in minified JS code.\n// TODO: Parcel isn't deduplicating these values.\nconst copyValue = \"copy\";\nconst convertValue = \"convert\";\nfunction convert(conversionFn, schema, input) {\n    if (schema === copyValue) {\n        return input;\n    }\n    if (schema === convertValue) {\n        return conversionFn(input);\n    }\n    if (schema instanceof Array) {\n        return input.map((v) => convert(conversionFn, schema[0], v));\n    }\n    if (schema instanceof Object) {\n        const output = {};\n        for (const [key, schemaField] of Object.entries(schema)) {\n            if (schemaField.derive) {\n                const v = schemaField.derive(input);\n                if (v !== undefined) {\n                    input[key] = v;\n                }\n            }\n            if (!(key in input)) {\n                if (schemaField.required) {\n                    throw new Error(`Missing key: ${key}`);\n                }\n                continue;\n            }\n            // Fields can be null (rather than missing or `undefined`), e.g. the\n            // `userHandle` field of the `AuthenticatorAssertionResponse`:\n            // https://www.w3.org/TR/webauthn/#iface-authenticatorassertionresponse\n            if (input[key] == null) {\n                output[key] = null;\n                continue;\n            }\n            output[key] = convert(conversionFn, schemaField.schema, input[key]);\n        }\n        return output;\n    }\n}\nfunction derived(schema, derive) {\n    return {\n        required: true,\n        schema,\n        derive,\n    };\n}\nfunction required(schema) {\n    return {\n        required: true,\n        schema,\n    };\n}\nfunction optional(schema) {\n    return {\n        required: false,\n        schema,\n    };\n}\n\n\n//# sourceMappingURL=convert.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvc29sYW5hL25vZGVfbW9kdWxlcy9AdHVybmtleS9odHRwL2Rpc3Qvd2ViYXV0aG4tanNvbi9jb252ZXJ0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELElBQUk7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXlFO0FBQ3pFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbnVyc2VibG9jLy4vbm9kZV9tb2R1bGVzL0B0dXJua2V5L3NvbGFuYS9ub2RlX21vZHVsZXMvQHR1cm5rZXkvaHR0cC9kaXN0L3dlYmF1dGhuLWpzb24vY29udmVydC5tanM/ZjE3MSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBXZSBleHBvcnQgdGhlc2UgdmFsdWVzIGluIG9yZGVyIHNvIHRoYXQgdGhleSBjYW4gYmUgdXNlZCB0byBkZWR1cGxpY2F0ZVxuLy8gc2NoZW1hIGRlZmluaXRpb25zIGluIG1pbmlmaWVkIEpTIGNvZGUuXG4vLyBUT0RPOiBQYXJjZWwgaXNuJ3QgZGVkdXBsaWNhdGluZyB0aGVzZSB2YWx1ZXMuXG5jb25zdCBjb3B5VmFsdWUgPSBcImNvcHlcIjtcbmNvbnN0IGNvbnZlcnRWYWx1ZSA9IFwiY29udmVydFwiO1xuZnVuY3Rpb24gY29udmVydChjb252ZXJzaW9uRm4sIHNjaGVtYSwgaW5wdXQpIHtcbiAgICBpZiAoc2NoZW1hID09PSBjb3B5VmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgIH1cbiAgICBpZiAoc2NoZW1hID09PSBjb252ZXJ0VmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGNvbnZlcnNpb25GbihpbnB1dCk7XG4gICAgfVxuICAgIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICByZXR1cm4gaW5wdXQubWFwKCh2KSA9PiBjb252ZXJ0KGNvbnZlcnNpb25Gbiwgc2NoZW1hWzBdLCB2KSk7XG4gICAgfVxuICAgIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0ge307XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgc2NoZW1hRmllbGRdIG9mIE9iamVjdC5lbnRyaWVzKHNjaGVtYSkpIHtcbiAgICAgICAgICAgIGlmIChzY2hlbWFGaWVsZC5kZXJpdmUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2ID0gc2NoZW1hRmllbGQuZGVyaXZlKGlucHV0KTtcbiAgICAgICAgICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0W2tleV0gPSB2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghKGtleSBpbiBpbnB1dCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2NoZW1hRmllbGQucmVxdWlyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIGtleTogJHtrZXl9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmllbGRzIGNhbiBiZSBudWxsIChyYXRoZXIgdGhhbiBtaXNzaW5nIG9yIGB1bmRlZmluZWRgKSwgZS5nLiB0aGVcbiAgICAgICAgICAgIC8vIGB1c2VySGFuZGxlYCBmaWVsZCBvZiB0aGUgYEF1dGhlbnRpY2F0b3JBc3NlcnRpb25SZXNwb25zZWA6XG4gICAgICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvd2ViYXV0aG4vI2lmYWNlLWF1dGhlbnRpY2F0b3Jhc3NlcnRpb25yZXNwb25zZVxuICAgICAgICAgICAgaWYgKGlucHV0W2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG91dHB1dFtrZXldID0gbnVsbDtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dHB1dFtrZXldID0gY29udmVydChjb252ZXJzaW9uRm4sIHNjaGVtYUZpZWxkLnNjaGVtYSwgaW5wdXRba2V5XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG59XG5mdW5jdGlvbiBkZXJpdmVkKHNjaGVtYSwgZGVyaXZlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICAgIHNjaGVtYSxcbiAgICAgICAgZGVyaXZlLFxuICAgIH07XG59XG5mdW5jdGlvbiByZXF1aXJlZChzY2hlbWEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgICAgc2NoZW1hLFxuICAgIH07XG59XG5mdW5jdGlvbiBvcHRpb25hbChzY2hlbWEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICByZXF1aXJlZDogZmFsc2UsXG4gICAgICAgIHNjaGVtYSxcbiAgICB9O1xufVxuXG5leHBvcnQgeyBjb252ZXJ0LCBjb252ZXJ0VmFsdWUsIGNvcHlWYWx1ZSwgZGVyaXZlZCwgb3B0aW9uYWwsIHJlcXVpcmVkIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb252ZXJ0Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/webauthn-json/convert.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/webauthn-json/index.mjs":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/webauthn-json/index.mjs ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   create: () => (/* binding */ create),\n/* harmony export */   get: () => (/* binding */ get)\n/* harmony export */ });\n/* harmony import */ var _api_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./api.mjs */ \"(ssr)/./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/webauthn-json/api.mjs\");\n\n\nasync function create(options) {\n    const response = (await navigator.credentials.create(options));\n    response.toJSON = () => (0,_api_mjs__WEBPACK_IMPORTED_MODULE_0__.createResponseToJSON)(response);\n    return response;\n}\nasync function get(options) {\n    const response = (await navigator.credentials.get(options));\n    response.toJSON = () => (0,_api_mjs__WEBPACK_IMPORTED_MODULE_0__.getResponseToJSON)(response);\n    return response;\n}\n\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvc29sYW5hL25vZGVfbW9kdWxlcy9AdHVybmtleS9odHRwL2Rpc3Qvd2ViYXV0aG4tanNvbi9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQW9FOztBQUVwRTtBQUNBO0FBQ0EsNEJBQTRCLDhEQUFvQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwyREFBaUI7QUFDN0M7QUFDQTs7QUFFdUI7QUFDdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9udXJzZWJsb2MvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvc29sYW5hL25vZGVfbW9kdWxlcy9AdHVybmtleS9odHRwL2Rpc3Qvd2ViYXV0aG4tanNvbi9pbmRleC5tanM/NTA2ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVSZXNwb25zZVRvSlNPTiwgZ2V0UmVzcG9uc2VUb0pTT04gfSBmcm9tICcuL2FwaS5tanMnO1xuXG5hc3luYyBmdW5jdGlvbiBjcmVhdGUob3B0aW9ucykge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gKGF3YWl0IG5hdmlnYXRvci5jcmVkZW50aWFscy5jcmVhdGUob3B0aW9ucykpO1xuICAgIHJlc3BvbnNlLnRvSlNPTiA9ICgpID0+IGNyZWF0ZVJlc3BvbnNlVG9KU09OKHJlc3BvbnNlKTtcbiAgICByZXR1cm4gcmVzcG9uc2U7XG59XG5hc3luYyBmdW5jdGlvbiBnZXQob3B0aW9ucykge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gKGF3YWl0IG5hdmlnYXRvci5jcmVkZW50aWFscy5nZXQob3B0aW9ucykpO1xuICAgIHJlc3BvbnNlLnRvSlNPTiA9ICgpID0+IGdldFJlc3BvbnNlVG9KU09OKHJlc3BvbnNlKTtcbiAgICByZXR1cm4gcmVzcG9uc2U7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZSwgZ2V0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/webauthn-json/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/webauthn-json/schema.mjs":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/webauthn-json/schema.mjs ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   publicKeyCredentialWithAssertion: () => (/* binding */ publicKeyCredentialWithAssertion),\n/* harmony export */   publicKeyCredentialWithAttestation: () => (/* binding */ publicKeyCredentialWithAttestation)\n/* harmony export */ });\n/* harmony import */ var _convert_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./convert.mjs */ \"(ssr)/./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/webauthn-json/convert.mjs\");\n\n\nconst simplifiedClientExtensionResultsSchema = {\n    appid: (0,_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.optional)(_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.copyValue),\n    appidExclude: (0,_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.optional)(_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.copyValue),\n    credProps: (0,_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.optional)(_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.copyValue),\n};\n// `navigator.create()` response\nconst publicKeyCredentialWithAttestation = {\n    type: (0,_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.required)(_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.copyValue),\n    id: (0,_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.required)(_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.copyValue),\n    rawId: (0,_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.required)(_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.convertValue),\n    authenticatorAttachment: (0,_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.optional)(_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.copyValue),\n    response: (0,_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.required)({\n        clientDataJSON: (0,_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.required)(_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.convertValue),\n        attestationObject: (0,_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.required)(_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.convertValue),\n        transports: (0,_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.derived)(_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.copyValue, (response) => response.getTransports?.() || []),\n    }),\n    clientExtensionResults: (0,_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.derived)(simplifiedClientExtensionResultsSchema, (pkc) => pkc.getClientExtensionResults()),\n};\n// `navigator.get()` response\nconst publicKeyCredentialWithAssertion = {\n    type: (0,_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.required)(_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.copyValue),\n    id: (0,_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.required)(_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.copyValue),\n    rawId: (0,_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.required)(_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.convertValue),\n    authenticatorAttachment: (0,_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.optional)(_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.copyValue),\n    response: (0,_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.required)({\n        clientDataJSON: (0,_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.required)(_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.convertValue),\n        authenticatorData: (0,_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.required)(_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.convertValue),\n        signature: (0,_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.required)(_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.convertValue),\n        userHandle: (0,_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.required)(_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.convertValue),\n    }),\n    clientExtensionResults: (0,_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.derived)(simplifiedClientExtensionResultsSchema, (pkc) => pkc.getClientExtensionResults()),\n};\n\n\n//# sourceMappingURL=schema.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvc29sYW5hL25vZGVfbW9kdWxlcy9AdHVybmtleS9odHRwL2Rpc3Qvd2ViYXV0aG4tanNvbi9zY2hlbWEubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFxRjs7QUFFckY7QUFDQSxXQUFXLHNEQUFRLENBQUMsbURBQVM7QUFDN0Isa0JBQWtCLHNEQUFRLENBQUMsbURBQVM7QUFDcEMsZUFBZSxzREFBUSxDQUFDLG1EQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLFVBQVUsc0RBQVEsQ0FBQyxtREFBUztBQUM1QixRQUFRLHNEQUFRLENBQUMsbURBQVM7QUFDMUIsV0FBVyxzREFBUSxDQUFDLHNEQUFZO0FBQ2hDLDZCQUE2QixzREFBUSxDQUFDLG1EQUFTO0FBQy9DLGNBQWMsc0RBQVE7QUFDdEIsd0JBQXdCLHNEQUFRLENBQUMsc0RBQVk7QUFDN0MsMkJBQTJCLHNEQUFRLENBQUMsc0RBQVk7QUFDaEQsb0JBQW9CLHFEQUFPLENBQUMsbURBQVM7QUFDckMsS0FBSztBQUNMLDRCQUE0QixxREFBTztBQUNuQztBQUNBO0FBQ0E7QUFDQSxVQUFVLHNEQUFRLENBQUMsbURBQVM7QUFDNUIsUUFBUSxzREFBUSxDQUFDLG1EQUFTO0FBQzFCLFdBQVcsc0RBQVEsQ0FBQyxzREFBWTtBQUNoQyw2QkFBNkIsc0RBQVEsQ0FBQyxtREFBUztBQUMvQyxjQUFjLHNEQUFRO0FBQ3RCLHdCQUF3QixzREFBUSxDQUFDLHNEQUFZO0FBQzdDLDJCQUEyQixzREFBUSxDQUFDLHNEQUFZO0FBQ2hELG1CQUFtQixzREFBUSxDQUFDLHNEQUFZO0FBQ3hDLG9CQUFvQixzREFBUSxDQUFDLHNEQUFZO0FBQ3pDLEtBQUs7QUFDTCw0QkFBNEIscURBQU87QUFDbkM7O0FBRWdGO0FBQ2hGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbnVyc2VibG9jLy4vbm9kZV9tb2R1bGVzL0B0dXJua2V5L3NvbGFuYS9ub2RlX21vZHVsZXMvQHR1cm5rZXkvaHR0cC9kaXN0L3dlYmF1dGhuLWpzb24vc2NoZW1hLm1qcz9hMTZjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHJlcXVpcmVkLCBvcHRpb25hbCwgZGVyaXZlZCwgY29weVZhbHVlLCBjb252ZXJ0VmFsdWUgfSBmcm9tICcuL2NvbnZlcnQubWpzJztcblxuY29uc3Qgc2ltcGxpZmllZENsaWVudEV4dGVuc2lvblJlc3VsdHNTY2hlbWEgPSB7XG4gICAgYXBwaWQ6IG9wdGlvbmFsKGNvcHlWYWx1ZSksXG4gICAgYXBwaWRFeGNsdWRlOiBvcHRpb25hbChjb3B5VmFsdWUpLFxuICAgIGNyZWRQcm9wczogb3B0aW9uYWwoY29weVZhbHVlKSxcbn07XG4vLyBgbmF2aWdhdG9yLmNyZWF0ZSgpYCByZXNwb25zZVxuY29uc3QgcHVibGljS2V5Q3JlZGVudGlhbFdpdGhBdHRlc3RhdGlvbiA9IHtcbiAgICB0eXBlOiByZXF1aXJlZChjb3B5VmFsdWUpLFxuICAgIGlkOiByZXF1aXJlZChjb3B5VmFsdWUpLFxuICAgIHJhd0lkOiByZXF1aXJlZChjb252ZXJ0VmFsdWUpLFxuICAgIGF1dGhlbnRpY2F0b3JBdHRhY2htZW50OiBvcHRpb25hbChjb3B5VmFsdWUpLFxuICAgIHJlc3BvbnNlOiByZXF1aXJlZCh7XG4gICAgICAgIGNsaWVudERhdGFKU09OOiByZXF1aXJlZChjb252ZXJ0VmFsdWUpLFxuICAgICAgICBhdHRlc3RhdGlvbk9iamVjdDogcmVxdWlyZWQoY29udmVydFZhbHVlKSxcbiAgICAgICAgdHJhbnNwb3J0czogZGVyaXZlZChjb3B5VmFsdWUsIChyZXNwb25zZSkgPT4gcmVzcG9uc2UuZ2V0VHJhbnNwb3J0cz8uKCkgfHwgW10pLFxuICAgIH0pLFxuICAgIGNsaWVudEV4dGVuc2lvblJlc3VsdHM6IGRlcml2ZWQoc2ltcGxpZmllZENsaWVudEV4dGVuc2lvblJlc3VsdHNTY2hlbWEsIChwa2MpID0+IHBrYy5nZXRDbGllbnRFeHRlbnNpb25SZXN1bHRzKCkpLFxufTtcbi8vIGBuYXZpZ2F0b3IuZ2V0KClgIHJlc3BvbnNlXG5jb25zdCBwdWJsaWNLZXlDcmVkZW50aWFsV2l0aEFzc2VydGlvbiA9IHtcbiAgICB0eXBlOiByZXF1aXJlZChjb3B5VmFsdWUpLFxuICAgIGlkOiByZXF1aXJlZChjb3B5VmFsdWUpLFxuICAgIHJhd0lkOiByZXF1aXJlZChjb252ZXJ0VmFsdWUpLFxuICAgIGF1dGhlbnRpY2F0b3JBdHRhY2htZW50OiBvcHRpb25hbChjb3B5VmFsdWUpLFxuICAgIHJlc3BvbnNlOiByZXF1aXJlZCh7XG4gICAgICAgIGNsaWVudERhdGFKU09OOiByZXF1aXJlZChjb252ZXJ0VmFsdWUpLFxuICAgICAgICBhdXRoZW50aWNhdG9yRGF0YTogcmVxdWlyZWQoY29udmVydFZhbHVlKSxcbiAgICAgICAgc2lnbmF0dXJlOiByZXF1aXJlZChjb252ZXJ0VmFsdWUpLFxuICAgICAgICB1c2VySGFuZGxlOiByZXF1aXJlZChjb252ZXJ0VmFsdWUpLFxuICAgIH0pLFxuICAgIGNsaWVudEV4dGVuc2lvblJlc3VsdHM6IGRlcml2ZWQoc2ltcGxpZmllZENsaWVudEV4dGVuc2lvblJlc3VsdHNTY2hlbWEsIChwa2MpID0+IHBrYy5nZXRDbGllbnRFeHRlbnNpb25SZXN1bHRzKCkpLFxufTtcblxuZXhwb3J0IHsgcHVibGljS2V5Q3JlZGVudGlhbFdpdGhBc3NlcnRpb24sIHB1YmxpY0tleUNyZWRlbnRpYWxXaXRoQXR0ZXN0YXRpb24gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjaGVtYS5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/webauthn-json/schema.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/webauthn.mjs":
/*!***********************************************************************************!*\
  !*** ./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/webauthn.mjs ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getWebAuthnAssertion: () => (/* binding */ getWebAuthnAssertion),\n/* harmony export */   getWebAuthnAttestation: () => (/* binding */ getWebAuthnAttestation),\n/* harmony export */   protocolTransportEnumToInternalEnum: () => (/* binding */ protocolTransportEnumToInternalEnum)\n/* harmony export */ });\n/* harmony import */ var _webauthn_json_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webauthn-json/index.mjs */ \"(ssr)/./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/webauthn-json/index.mjs\");\n\n\nconst defaultTimeout = 5 * 60 * 1000; // five minutes\nconst defaultUserVerification = \"preferred\";\nconst defaultSigningOptions = {\n    publicKey: {\n        timeout: defaultTimeout,\n        userVerification: defaultUserVerification,\n    },\n};\nasync function getCredentialRequestOptions(payload, tkSigningOptions = defaultSigningOptions) {\n    const challenge = await getChallengeFromPayload(payload);\n    const signingOptions = {\n        ...tkSigningOptions,\n        publicKey: {\n            ...defaultSigningOptions.publicKey,\n            ...tkSigningOptions.publicKey,\n            challenge,\n        },\n    };\n    return signingOptions;\n}\nasync function getChallengeFromPayload(payload) {\n    const messageBuffer = new TextEncoder().encode(payload);\n    const hashBuffer = await crypto.subtle.digest(\"SHA-256\", messageBuffer);\n    const hexString = Buffer.from(hashBuffer).toString(\"hex\");\n    const hexBuffer = Buffer.from(hexString, \"utf8\");\n    return new Uint8Array(hexBuffer);\n}\n/* Pulled from https://www.w3.org/TR/webauthn-2/#enum-transport */\nfunction protocolTransportEnumToInternalEnum(protocolEnum) {\n    switch (protocolEnum) {\n        case \"internal\": {\n            return \"AUTHENTICATOR_TRANSPORT_INTERNAL\";\n        }\n        case \"usb\": {\n            return \"AUTHENTICATOR_TRANSPORT_USB\";\n        }\n        case \"nfc\": {\n            return \"AUTHENTICATOR_TRANSPORT_NFC\";\n        }\n        case \"ble\": {\n            return \"AUTHENTICATOR_TRANSPORT_BLE\";\n        }\n        case \"hybrid\": {\n            return \"AUTHENTICATOR_TRANSPORT_HYBRID\";\n        }\n        default: {\n            throw new Error(\"unsupported transport format\");\n        }\n    }\n}\nfunction toInternalAttestation(attestation) {\n    return {\n        credentialId: attestation.rawId,\n        attestationObject: attestation.response.attestationObject,\n        clientDataJson: attestation.response.clientDataJSON,\n        transports: attestation.response.transports.map(protocolTransportEnumToInternalEnum),\n    };\n}\nasync function getWebAuthnAssertion(payload, options) {\n    const webAuthnSupported = hasWebAuthnSupport();\n    if (!webAuthnSupported) {\n        throw new Error(\"webauthn is not supported by this browser\");\n    }\n    const signingOptions = await getCredentialRequestOptions(payload, options);\n    const clientGetResult = await (0,_webauthn_json_index_mjs__WEBPACK_IMPORTED_MODULE_0__.get)(signingOptions);\n    const assertion = clientGetResult.toJSON();\n    const stamp = {\n        authenticatorData: assertion.response.authenticatorData,\n        clientDataJson: assertion.response.clientDataJSON,\n        credentialId: assertion.id,\n        signature: assertion.response.signature,\n    };\n    return JSON.stringify(stamp);\n}\nasync function getWebAuthnAttestation(options) {\n    const webAuthnSupported = hasWebAuthnSupport();\n    if (!webAuthnSupported) {\n        throw new Error(\"webauthn is not supported by this browser\");\n    }\n    const res = await (0,_webauthn_json_index_mjs__WEBPACK_IMPORTED_MODULE_0__.create)(options);\n    return toInternalAttestation(res.toJSON());\n}\n// `hasWebAuthnSupport` checks for barebones webauthn support.\n// For additional details and granular settings, see:\n// https://web.dev/articles/passkey-form-autofill#feature-detection, https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredential\nfunction hasWebAuthnSupport() {\n    return !!window.PublicKeyCredential;\n}\n\n\n//# sourceMappingURL=webauthn.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvc29sYW5hL25vZGVfbW9kdWxlcy9AdHVybmtleS9odHRwL2Rpc3Qvd2ViYXV0aG4ubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBd0Q7O0FBRXhELHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDZEQUFHO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0VBQU07QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNkY7QUFDN0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9udXJzZWJsb2MvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvc29sYW5hL25vZGVfbW9kdWxlcy9AdHVybmtleS9odHRwL2Rpc3Qvd2ViYXV0aG4ubWpzPzMyMmYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlLCBnZXQgfSBmcm9tICcuL3dlYmF1dGhuLWpzb24vaW5kZXgubWpzJztcblxuY29uc3QgZGVmYXVsdFRpbWVvdXQgPSA1ICogNjAgKiAxMDAwOyAvLyBmaXZlIG1pbnV0ZXNcbmNvbnN0IGRlZmF1bHRVc2VyVmVyaWZpY2F0aW9uID0gXCJwcmVmZXJyZWRcIjtcbmNvbnN0IGRlZmF1bHRTaWduaW5nT3B0aW9ucyA9IHtcbiAgICBwdWJsaWNLZXk6IHtcbiAgICAgICAgdGltZW91dDogZGVmYXVsdFRpbWVvdXQsXG4gICAgICAgIHVzZXJWZXJpZmljYXRpb246IGRlZmF1bHRVc2VyVmVyaWZpY2F0aW9uLFxuICAgIH0sXG59O1xuYXN5bmMgZnVuY3Rpb24gZ2V0Q3JlZGVudGlhbFJlcXVlc3RPcHRpb25zKHBheWxvYWQsIHRrU2lnbmluZ09wdGlvbnMgPSBkZWZhdWx0U2lnbmluZ09wdGlvbnMpIHtcbiAgICBjb25zdCBjaGFsbGVuZ2UgPSBhd2FpdCBnZXRDaGFsbGVuZ2VGcm9tUGF5bG9hZChwYXlsb2FkKTtcbiAgICBjb25zdCBzaWduaW5nT3B0aW9ucyA9IHtcbiAgICAgICAgLi4udGtTaWduaW5nT3B0aW9ucyxcbiAgICAgICAgcHVibGljS2V5OiB7XG4gICAgICAgICAgICAuLi5kZWZhdWx0U2lnbmluZ09wdGlvbnMucHVibGljS2V5LFxuICAgICAgICAgICAgLi4udGtTaWduaW5nT3B0aW9ucy5wdWJsaWNLZXksXG4gICAgICAgICAgICBjaGFsbGVuZ2UsXG4gICAgICAgIH0sXG4gICAgfTtcbiAgICByZXR1cm4gc2lnbmluZ09wdGlvbnM7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRDaGFsbGVuZ2VGcm9tUGF5bG9hZChwYXlsb2FkKSB7XG4gICAgY29uc3QgbWVzc2FnZUJ1ZmZlciA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShwYXlsb2FkKTtcbiAgICBjb25zdCBoYXNoQnVmZmVyID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5kaWdlc3QoXCJTSEEtMjU2XCIsIG1lc3NhZ2VCdWZmZXIpO1xuICAgIGNvbnN0IGhleFN0cmluZyA9IEJ1ZmZlci5mcm9tKGhhc2hCdWZmZXIpLnRvU3RyaW5nKFwiaGV4XCIpO1xuICAgIGNvbnN0IGhleEJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGhleFN0cmluZywgXCJ1dGY4XCIpO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShoZXhCdWZmZXIpO1xufVxuLyogUHVsbGVkIGZyb20gaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYmF1dGhuLTIvI2VudW0tdHJhbnNwb3J0ICovXG5mdW5jdGlvbiBwcm90b2NvbFRyYW5zcG9ydEVudW1Ub0ludGVybmFsRW51bShwcm90b2NvbEVudW0pIHtcbiAgICBzd2l0Y2ggKHByb3RvY29sRW51bSkge1xuICAgICAgICBjYXNlIFwiaW50ZXJuYWxcIjoge1xuICAgICAgICAgICAgcmV0dXJuIFwiQVVUSEVOVElDQVRPUl9UUkFOU1BPUlRfSU5URVJOQUxcIjtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwidXNiXCI6IHtcbiAgICAgICAgICAgIHJldHVybiBcIkFVVEhFTlRJQ0FUT1JfVFJBTlNQT1JUX1VTQlwiO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJuZmNcIjoge1xuICAgICAgICAgICAgcmV0dXJuIFwiQVVUSEVOVElDQVRPUl9UUkFOU1BPUlRfTkZDXCI7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImJsZVwiOiB7XG4gICAgICAgICAgICByZXR1cm4gXCJBVVRIRU5USUNBVE9SX1RSQU5TUE9SVF9CTEVcIjtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiaHlicmlkXCI6IHtcbiAgICAgICAgICAgIHJldHVybiBcIkFVVEhFTlRJQ0FUT1JfVFJBTlNQT1JUX0hZQlJJRFwiO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIHRyYW5zcG9ydCBmb3JtYXRcIik7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiB0b0ludGVybmFsQXR0ZXN0YXRpb24oYXR0ZXN0YXRpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjcmVkZW50aWFsSWQ6IGF0dGVzdGF0aW9uLnJhd0lkLFxuICAgICAgICBhdHRlc3RhdGlvbk9iamVjdDogYXR0ZXN0YXRpb24ucmVzcG9uc2UuYXR0ZXN0YXRpb25PYmplY3QsXG4gICAgICAgIGNsaWVudERhdGFKc29uOiBhdHRlc3RhdGlvbi5yZXNwb25zZS5jbGllbnREYXRhSlNPTixcbiAgICAgICAgdHJhbnNwb3J0czogYXR0ZXN0YXRpb24ucmVzcG9uc2UudHJhbnNwb3J0cy5tYXAocHJvdG9jb2xUcmFuc3BvcnRFbnVtVG9JbnRlcm5hbEVudW0pLFxuICAgIH07XG59XG5hc3luYyBmdW5jdGlvbiBnZXRXZWJBdXRobkFzc2VydGlvbihwYXlsb2FkLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgd2ViQXV0aG5TdXBwb3J0ZWQgPSBoYXNXZWJBdXRoblN1cHBvcnQoKTtcbiAgICBpZiAoIXdlYkF1dGhuU3VwcG9ydGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIndlYmF1dGhuIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBicm93c2VyXCIpO1xuICAgIH1cbiAgICBjb25zdCBzaWduaW5nT3B0aW9ucyA9IGF3YWl0IGdldENyZWRlbnRpYWxSZXF1ZXN0T3B0aW9ucyhwYXlsb2FkLCBvcHRpb25zKTtcbiAgICBjb25zdCBjbGllbnRHZXRSZXN1bHQgPSBhd2FpdCBnZXQoc2lnbmluZ09wdGlvbnMpO1xuICAgIGNvbnN0IGFzc2VydGlvbiA9IGNsaWVudEdldFJlc3VsdC50b0pTT04oKTtcbiAgICBjb25zdCBzdGFtcCA9IHtcbiAgICAgICAgYXV0aGVudGljYXRvckRhdGE6IGFzc2VydGlvbi5yZXNwb25zZS5hdXRoZW50aWNhdG9yRGF0YSxcbiAgICAgICAgY2xpZW50RGF0YUpzb246IGFzc2VydGlvbi5yZXNwb25zZS5jbGllbnREYXRhSlNPTixcbiAgICAgICAgY3JlZGVudGlhbElkOiBhc3NlcnRpb24uaWQsXG4gICAgICAgIHNpZ25hdHVyZTogYXNzZXJ0aW9uLnJlc3BvbnNlLnNpZ25hdHVyZSxcbiAgICB9O1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShzdGFtcCk7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRXZWJBdXRobkF0dGVzdGF0aW9uKG9wdGlvbnMpIHtcbiAgICBjb25zdCB3ZWJBdXRoblN1cHBvcnRlZCA9IGhhc1dlYkF1dGhuU3VwcG9ydCgpO1xuICAgIGlmICghd2ViQXV0aG5TdXBwb3J0ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwid2ViYXV0aG4gaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIGJyb3dzZXJcIik7XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGNyZWF0ZShvcHRpb25zKTtcbiAgICByZXR1cm4gdG9JbnRlcm5hbEF0dGVzdGF0aW9uKHJlcy50b0pTT04oKSk7XG59XG4vLyBgaGFzV2ViQXV0aG5TdXBwb3J0YCBjaGVja3MgZm9yIGJhcmVib25lcyB3ZWJhdXRobiBzdXBwb3J0LlxuLy8gRm9yIGFkZGl0aW9uYWwgZGV0YWlscyBhbmQgZ3JhbnVsYXIgc2V0dGluZ3MsIHNlZTpcbi8vIGh0dHBzOi8vd2ViLmRldi9hcnRpY2xlcy9wYXNza2V5LWZvcm0tYXV0b2ZpbGwjZmVhdHVyZS1kZXRlY3Rpb24sIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9QdWJsaWNLZXlDcmVkZW50aWFsXG5mdW5jdGlvbiBoYXNXZWJBdXRoblN1cHBvcnQoKSB7XG4gICAgcmV0dXJuICEhd2luZG93LlB1YmxpY0tleUNyZWRlbnRpYWw7XG59XG5cbmV4cG9ydCB7IGdldFdlYkF1dGhuQXNzZXJ0aW9uLCBnZXRXZWJBdXRobkF0dGVzdGF0aW9uLCBwcm90b2NvbFRyYW5zcG9ydEVudW1Ub0ludGVybmFsRW51bSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2ViYXV0aG4ubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/solana/node_modules/@turnkey/http/dist/webauthn.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/viem/dist/index.mjs":
/*!***************************************************!*\
  !*** ./node_modules/@turnkey/viem/dist/index.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createAccount: () => (/* binding */ createAccount),\n/* harmony export */   createApiKeyAccount: () => (/* binding */ createApiKeyAccount)\n/* harmony export */ });\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/viem/_esm/utils/address/isAddress.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/viem/_esm/utils/transaction/serializeTransaction.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/viem/_esm/utils/signature/hashMessage.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/viem/_esm/utils/signature/hashTypedData.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/viem/_esm/utils/signature/signatureToHex.js\");\n/* harmony import */ var viem_accounts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! viem/accounts */ \"(ssr)/./node_modules/viem/_esm/accounts/toAccount.js\");\n/* harmony import */ var _turnkey_http__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @turnkey/http */ \"(ssr)/./node_modules/@turnkey/http/dist/index.mjs\");\n/* harmony import */ var _turnkey_api_key_stamper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @turnkey/api-key-stamper */ \"(ssr)/./node_modules/@turnkey/api-key-stamper/dist/index.mjs\");\n\n\n\n\n\nasync function createAccount(input) {\n    const { client, organizationId, signWith } = input;\n    let { ethereumAddress } = input;\n    if (!signWith) {\n        throw new _turnkey_http__WEBPACK_IMPORTED_MODULE_0__.TurnkeyActivityError({\n            message: `Missing signWith parameter`,\n        });\n    }\n    if ((0,viem__WEBPACK_IMPORTED_MODULE_2__.isAddress)(signWith)) {\n        // override provided `ethereumAddress`\n        ethereumAddress = signWith;\n    }\n    else if (!ethereumAddress) {\n        // we have a private key ID, but not an ethereumAddress\n        const data = await client.getPrivateKey({\n            privateKeyId: signWith,\n            organizationId: organizationId,\n        });\n        ethereumAddress = data.privateKey.addresses.find((item) => item.format === \"ADDRESS_FORMAT_ETHEREUM\")?.address;\n        if (typeof ethereumAddress !== \"string\" || !ethereumAddress) {\n            throw new _turnkey_http__WEBPACK_IMPORTED_MODULE_0__.TurnkeyActivityError({\n                message: `Unable to find Ethereum address for key ${signWith} under organization ${organizationId}`,\n            });\n        }\n    }\n    return (0,viem_accounts__WEBPACK_IMPORTED_MODULE_3__.toAccount)({\n        address: ethereumAddress,\n        signMessage: function ({ message, }) {\n            return signMessage(client, message, organizationId, signWith);\n        },\n        signTransaction: function (transaction, args) {\n            const serializer = !args?.serializer\n                ? viem__WEBPACK_IMPORTED_MODULE_4__.serializeTransaction\n                : args.serializer;\n            return signTransaction(client, transaction, serializer, organizationId, signWith);\n        },\n        signTypedData: function (typedData) {\n            return signTypedData(client, typedData, organizationId, signWith);\n        },\n    });\n}\n/**\n * Creates a new Custom Account backed by a Turnkey API key.\n * @deprecated use {@link createAccount} instead.\n */\nasync function createApiKeyAccount(config) {\n    const { apiPublicKey, apiPrivateKey, baseUrl, organizationId, privateKeyId } = config;\n    const stamper = new _turnkey_api_key_stamper__WEBPACK_IMPORTED_MODULE_1__.ApiKeyStamper({\n        apiPublicKey: apiPublicKey,\n        apiPrivateKey: apiPrivateKey,\n    });\n    const client = new _turnkey_http__WEBPACK_IMPORTED_MODULE_0__.TurnkeyClient({\n        baseUrl: baseUrl,\n    }, stamper);\n    const data = await client.getPrivateKey({\n        privateKeyId: privateKeyId,\n        organizationId: organizationId,\n    });\n    const ethereumAddress = data.privateKey.addresses.find((item) => item.format === \"ADDRESS_FORMAT_ETHEREUM\")?.address;\n    if (typeof ethereumAddress !== \"string\" || !ethereumAddress) {\n        throw new _turnkey_http__WEBPACK_IMPORTED_MODULE_0__.TurnkeyActivityError({\n            message: `Unable to find Ethereum address for key ${privateKeyId} under organization ${organizationId}`,\n        });\n    }\n    return (0,viem_accounts__WEBPACK_IMPORTED_MODULE_3__.toAccount)({\n        address: ethereumAddress,\n        signMessage: function ({ message, }) {\n            return signMessage(client, message, organizationId, privateKeyId);\n        },\n        signTransaction: function (transaction, args) {\n            const serializer = !args?.serializer\n                ? viem__WEBPACK_IMPORTED_MODULE_4__.serializeTransaction\n                : args.serializer;\n            return signTransaction(client, transaction, serializer, organizationId, privateKeyId);\n        },\n        signTypedData: function (typedData) {\n            return signTypedData(client, typedData, organizationId, privateKeyId);\n        },\n    });\n}\nasync function signMessage(client, message, organizationId, signWith) {\n    const hashedMessage = (0,viem__WEBPACK_IMPORTED_MODULE_5__.hashMessage)(message);\n    const signedMessage = await signMessageWithErrorWrapping(client, hashedMessage, organizationId, signWith);\n    return `${signedMessage}`;\n}\nasync function signTransaction(client, transaction, serializer, organizationId, signWith) {\n    const serializedTx = serializer(transaction);\n    const nonHexPrefixedSerializedTx = serializedTx.replace(/^0x/, \"\");\n    return await signTransactionWithErrorWrapping(client, nonHexPrefixedSerializedTx, organizationId, signWith);\n}\nasync function signTypedData(client, data, organizationId, signWith) {\n    const hashToSign = (0,viem__WEBPACK_IMPORTED_MODULE_6__.hashTypedData)(data);\n    return await signMessageWithErrorWrapping(client, hashToSign, organizationId, signWith);\n}\nasync function signTransactionWithErrorWrapping(client, unsignedTransaction, organizationId, signWith) {\n    let signedTx;\n    try {\n        signedTx = await signTransactionImpl(client, unsignedTransaction, organizationId, signWith);\n    }\n    catch (error) {\n        if (error instanceof _turnkey_http__WEBPACK_IMPORTED_MODULE_0__.TurnkeyActivityError) {\n            throw error;\n        }\n        throw new _turnkey_http__WEBPACK_IMPORTED_MODULE_0__.TurnkeyActivityError({\n            message: `Failed to sign transaction: ${error.message}`,\n            cause: error,\n        });\n    }\n    return `0x${signedTx}`;\n}\nasync function signTransactionImpl(client, unsignedTransaction, organizationId, signWith) {\n    const { activity } = await client.signTransaction({\n        type: \"ACTIVITY_TYPE_SIGN_TRANSACTION_V2\",\n        organizationId: organizationId,\n        parameters: {\n            signWith,\n            type: \"TRANSACTION_TYPE_ETHEREUM\",\n            unsignedTransaction: unsignedTransaction,\n        },\n        timestampMs: String(Date.now()), // millisecond timestamp\n    });\n    const { id, status, type } = activity;\n    if (activity.status === \"ACTIVITY_STATUS_COMPLETED\") {\n        return assertNonNull(activity?.result?.signTransactionResult?.signedTransaction);\n    }\n    throw new _turnkey_http__WEBPACK_IMPORTED_MODULE_0__.TurnkeyActivityError({\n        message: `Invalid activity status: ${activity.status}`,\n        activityId: id,\n        activityStatus: status,\n        activityType: type,\n    });\n}\nasync function signMessageWithErrorWrapping(client, message, organizationId, signWith) {\n    let signedMessage;\n    try {\n        signedMessage = await signMessageImpl(client, message, organizationId, signWith);\n    }\n    catch (error) {\n        if (error instanceof _turnkey_http__WEBPACK_IMPORTED_MODULE_0__.TurnkeyActivityError) {\n            throw error;\n        }\n        throw new _turnkey_http__WEBPACK_IMPORTED_MODULE_0__.TurnkeyActivityError({\n            message: `Failed to sign: ${error.message}`,\n            cause: error,\n        });\n    }\n    return signedMessage;\n}\nasync function signMessageImpl(client, message, organizationId, signWith) {\n    const { activity } = await client.signRawPayload({\n        type: \"ACTIVITY_TYPE_SIGN_RAW_PAYLOAD_V2\",\n        organizationId: organizationId,\n        parameters: {\n            signWith,\n            payload: message,\n            encoding: \"PAYLOAD_ENCODING_HEXADECIMAL\",\n            hashFunction: \"HASH_FUNCTION_NO_OP\",\n        },\n        timestampMs: String(Date.now()), // millisecond timestamp\n    });\n    const { id, status, type } = activity;\n    if (activity.status === \"ACTIVITY_STATUS_COMPLETED\") {\n        let result = assertNonNull(activity?.result?.signRawPayloadResult);\n        let assembled = (0,viem__WEBPACK_IMPORTED_MODULE_7__.signatureToHex)({\n            r: `0x${result.r}`,\n            s: `0x${result.s}`,\n            v: result.v === \"00\" ? 27n : 28n,\n        });\n        // Assemble the hex\n        return assertNonNull(assembled);\n    }\n    throw new _turnkey_http__WEBPACK_IMPORTED_MODULE_0__.TurnkeyActivityError({\n        message: `Invalid activity status: ${activity.status}`,\n        activityId: id,\n        activityStatus: status,\n        activityType: type,\n    });\n}\nfunction assertNonNull(input) {\n    if (input == null) {\n        throw new Error(`Got unexpected ${JSON.stringify(input)}`);\n    }\n    return input;\n}\n\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvdmllbS9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQW1HO0FBQ3pEO0FBQzBCO0FBQ1g7O0FBRXpEO0FBQ0EsWUFBWSxtQ0FBbUM7QUFDL0MsVUFBVSxrQkFBa0I7QUFDNUI7QUFDQSxrQkFBa0IsK0RBQW9CO0FBQ3RDO0FBQ0EsU0FBUztBQUNUO0FBQ0EsUUFBUSwrQ0FBUztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxzQkFBc0IsK0RBQW9CO0FBQzFDLG9FQUFvRSxVQUFVLHFCQUFxQixlQUFlO0FBQ2xILGFBQWE7QUFDYjtBQUNBO0FBQ0EsV0FBVyx3REFBUztBQUNwQjtBQUNBLGlDQUFpQyxVQUFVO0FBQzNDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxrQkFBa0Isc0RBQW9CO0FBQ3RDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0EsWUFBWSxxRUFBcUU7QUFDakYsd0JBQXdCLG1FQUFhO0FBQ3JDO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsdUJBQXVCLHdEQUFhO0FBQ3BDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esa0JBQWtCLCtEQUFvQjtBQUN0QyxnRUFBZ0UsY0FBYyxxQkFBcUIsZUFBZTtBQUNsSCxTQUFTO0FBQ1Q7QUFDQSxXQUFXLHdEQUFTO0FBQ3BCO0FBQ0EsaUNBQWlDLFVBQVU7QUFDM0M7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGtCQUFrQixzREFBb0I7QUFDdEM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0EsMEJBQTBCLGlEQUFXO0FBQ3JDO0FBQ0EsY0FBYyxjQUFjO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1EQUFhO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsK0RBQW9CO0FBQ2pEO0FBQ0E7QUFDQSxrQkFBa0IsK0RBQW9CO0FBQ3RDLG9EQUFvRCxjQUFjO0FBQ2xFO0FBQ0EsU0FBUztBQUNUO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0wsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsY0FBYywrREFBb0I7QUFDbEMsNkNBQTZDLGdCQUFnQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsK0RBQW9CO0FBQ2pEO0FBQ0E7QUFDQSxrQkFBa0IsK0RBQW9CO0FBQ3RDLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQSx3QkFBd0Isb0RBQWM7QUFDdEMsb0JBQW9CLFNBQVM7QUFDN0Isb0JBQW9CLFNBQVM7QUFDN0I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsY0FBYywrREFBb0I7QUFDbEMsNkNBQTZDLGdCQUFnQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHNCQUFzQjtBQUNoRTtBQUNBO0FBQ0E7O0FBRThDO0FBQzlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbnVyc2VibG9jLy4vbm9kZV9tb2R1bGVzL0B0dXJua2V5L3ZpZW0vZGlzdC9pbmRleC5tanM/NjQ1OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc0FkZHJlc3MsIHNlcmlhbGl6ZVRyYW5zYWN0aW9uLCBoYXNoTWVzc2FnZSwgaGFzaFR5cGVkRGF0YSwgc2lnbmF0dXJlVG9IZXggfSBmcm9tICd2aWVtJztcbmltcG9ydCB7IHRvQWNjb3VudCB9IGZyb20gJ3ZpZW0vYWNjb3VudHMnO1xuaW1wb3J0IHsgVHVybmtleUFjdGl2aXR5RXJyb3IsIFR1cm5rZXlDbGllbnQgfSBmcm9tICdAdHVybmtleS9odHRwJztcbmltcG9ydCB7IEFwaUtleVN0YW1wZXIgfSBmcm9tICdAdHVybmtleS9hcGkta2V5LXN0YW1wZXInO1xuXG5hc3luYyBmdW5jdGlvbiBjcmVhdGVBY2NvdW50KGlucHV0KSB7XG4gICAgY29uc3QgeyBjbGllbnQsIG9yZ2FuaXphdGlvbklkLCBzaWduV2l0aCB9ID0gaW5wdXQ7XG4gICAgbGV0IHsgZXRoZXJldW1BZGRyZXNzIH0gPSBpbnB1dDtcbiAgICBpZiAoIXNpZ25XaXRoKSB7XG4gICAgICAgIHRocm93IG5ldyBUdXJua2V5QWN0aXZpdHlFcnJvcih7XG4gICAgICAgICAgICBtZXNzYWdlOiBgTWlzc2luZyBzaWduV2l0aCBwYXJhbWV0ZXJgLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGlzQWRkcmVzcyhzaWduV2l0aCkpIHtcbiAgICAgICAgLy8gb3ZlcnJpZGUgcHJvdmlkZWQgYGV0aGVyZXVtQWRkcmVzc2BcbiAgICAgICAgZXRoZXJldW1BZGRyZXNzID0gc2lnbldpdGg7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFldGhlcmV1bUFkZHJlc3MpIHtcbiAgICAgICAgLy8gd2UgaGF2ZSBhIHByaXZhdGUga2V5IElELCBidXQgbm90IGFuIGV0aGVyZXVtQWRkcmVzc1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgY2xpZW50LmdldFByaXZhdGVLZXkoe1xuICAgICAgICAgICAgcHJpdmF0ZUtleUlkOiBzaWduV2l0aCxcbiAgICAgICAgICAgIG9yZ2FuaXphdGlvbklkOiBvcmdhbml6YXRpb25JZCxcbiAgICAgICAgfSk7XG4gICAgICAgIGV0aGVyZXVtQWRkcmVzcyA9IGRhdGEucHJpdmF0ZUtleS5hZGRyZXNzZXMuZmluZCgoaXRlbSkgPT4gaXRlbS5mb3JtYXQgPT09IFwiQUREUkVTU19GT1JNQVRfRVRIRVJFVU1cIik/LmFkZHJlc3M7XG4gICAgICAgIGlmICh0eXBlb2YgZXRoZXJldW1BZGRyZXNzICE9PSBcInN0cmluZ1wiIHx8ICFldGhlcmV1bUFkZHJlc3MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUdXJua2V5QWN0aXZpdHlFcnJvcih7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogYFVuYWJsZSB0byBmaW5kIEV0aGVyZXVtIGFkZHJlc3MgZm9yIGtleSAke3NpZ25XaXRofSB1bmRlciBvcmdhbml6YXRpb24gJHtvcmdhbml6YXRpb25JZH1gLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvQWNjb3VudCh7XG4gICAgICAgIGFkZHJlc3M6IGV0aGVyZXVtQWRkcmVzcyxcbiAgICAgICAgc2lnbk1lc3NhZ2U6IGZ1bmN0aW9uICh7IG1lc3NhZ2UsIH0pIHtcbiAgICAgICAgICAgIHJldHVybiBzaWduTWVzc2FnZShjbGllbnQsIG1lc3NhZ2UsIG9yZ2FuaXphdGlvbklkLCBzaWduV2l0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNpZ25UcmFuc2FjdGlvbjogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBhcmdzKSB7XG4gICAgICAgICAgICBjb25zdCBzZXJpYWxpemVyID0gIWFyZ3M/LnNlcmlhbGl6ZXJcbiAgICAgICAgICAgICAgICA/IHNlcmlhbGl6ZVRyYW5zYWN0aW9uXG4gICAgICAgICAgICAgICAgOiBhcmdzLnNlcmlhbGl6ZXI7XG4gICAgICAgICAgICByZXR1cm4gc2lnblRyYW5zYWN0aW9uKGNsaWVudCwgdHJhbnNhY3Rpb24sIHNlcmlhbGl6ZXIsIG9yZ2FuaXphdGlvbklkLCBzaWduV2l0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNpZ25UeXBlZERhdGE6IGZ1bmN0aW9uICh0eXBlZERhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBzaWduVHlwZWREYXRhKGNsaWVudCwgdHlwZWREYXRhLCBvcmdhbml6YXRpb25JZCwgc2lnbldpdGgpO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IEN1c3RvbSBBY2NvdW50IGJhY2tlZCBieSBhIFR1cm5rZXkgQVBJIGtleS5cbiAqIEBkZXByZWNhdGVkIHVzZSB7QGxpbmsgY3JlYXRlQWNjb3VudH0gaW5zdGVhZC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gY3JlYXRlQXBpS2V5QWNjb3VudChjb25maWcpIHtcbiAgICBjb25zdCB7IGFwaVB1YmxpY0tleSwgYXBpUHJpdmF0ZUtleSwgYmFzZVVybCwgb3JnYW5pemF0aW9uSWQsIHByaXZhdGVLZXlJZCB9ID0gY29uZmlnO1xuICAgIGNvbnN0IHN0YW1wZXIgPSBuZXcgQXBpS2V5U3RhbXBlcih7XG4gICAgICAgIGFwaVB1YmxpY0tleTogYXBpUHVibGljS2V5LFxuICAgICAgICBhcGlQcml2YXRlS2V5OiBhcGlQcml2YXRlS2V5LFxuICAgIH0pO1xuICAgIGNvbnN0IGNsaWVudCA9IG5ldyBUdXJua2V5Q2xpZW50KHtcbiAgICAgICAgYmFzZVVybDogYmFzZVVybCxcbiAgICB9LCBzdGFtcGVyKTtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgY2xpZW50LmdldFByaXZhdGVLZXkoe1xuICAgICAgICBwcml2YXRlS2V5SWQ6IHByaXZhdGVLZXlJZCxcbiAgICAgICAgb3JnYW5pemF0aW9uSWQ6IG9yZ2FuaXphdGlvbklkLFxuICAgIH0pO1xuICAgIGNvbnN0IGV0aGVyZXVtQWRkcmVzcyA9IGRhdGEucHJpdmF0ZUtleS5hZGRyZXNzZXMuZmluZCgoaXRlbSkgPT4gaXRlbS5mb3JtYXQgPT09IFwiQUREUkVTU19GT1JNQVRfRVRIRVJFVU1cIik/LmFkZHJlc3M7XG4gICAgaWYgKHR5cGVvZiBldGhlcmV1bUFkZHJlc3MgIT09IFwic3RyaW5nXCIgfHwgIWV0aGVyZXVtQWRkcmVzcykge1xuICAgICAgICB0aHJvdyBuZXcgVHVybmtleUFjdGl2aXR5RXJyb3Ioe1xuICAgICAgICAgICAgbWVzc2FnZTogYFVuYWJsZSB0byBmaW5kIEV0aGVyZXVtIGFkZHJlc3MgZm9yIGtleSAke3ByaXZhdGVLZXlJZH0gdW5kZXIgb3JnYW5pemF0aW9uICR7b3JnYW5pemF0aW9uSWR9YCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0b0FjY291bnQoe1xuICAgICAgICBhZGRyZXNzOiBldGhlcmV1bUFkZHJlc3MsXG4gICAgICAgIHNpZ25NZXNzYWdlOiBmdW5jdGlvbiAoeyBtZXNzYWdlLCB9KSB7XG4gICAgICAgICAgICByZXR1cm4gc2lnbk1lc3NhZ2UoY2xpZW50LCBtZXNzYWdlLCBvcmdhbml6YXRpb25JZCwgcHJpdmF0ZUtleUlkKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2lnblRyYW5zYWN0aW9uOiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIGFyZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlcmlhbGl6ZXIgPSAhYXJncz8uc2VyaWFsaXplclxuICAgICAgICAgICAgICAgID8gc2VyaWFsaXplVHJhbnNhY3Rpb25cbiAgICAgICAgICAgICAgICA6IGFyZ3Muc2VyaWFsaXplcjtcbiAgICAgICAgICAgIHJldHVybiBzaWduVHJhbnNhY3Rpb24oY2xpZW50LCB0cmFuc2FjdGlvbiwgc2VyaWFsaXplciwgb3JnYW5pemF0aW9uSWQsIHByaXZhdGVLZXlJZCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNpZ25UeXBlZERhdGE6IGZ1bmN0aW9uICh0eXBlZERhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBzaWduVHlwZWREYXRhKGNsaWVudCwgdHlwZWREYXRhLCBvcmdhbml6YXRpb25JZCwgcHJpdmF0ZUtleUlkKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNpZ25NZXNzYWdlKGNsaWVudCwgbWVzc2FnZSwgb3JnYW5pemF0aW9uSWQsIHNpZ25XaXRoKSB7XG4gICAgY29uc3QgaGFzaGVkTWVzc2FnZSA9IGhhc2hNZXNzYWdlKG1lc3NhZ2UpO1xuICAgIGNvbnN0IHNpZ25lZE1lc3NhZ2UgPSBhd2FpdCBzaWduTWVzc2FnZVdpdGhFcnJvcldyYXBwaW5nKGNsaWVudCwgaGFzaGVkTWVzc2FnZSwgb3JnYW5pemF0aW9uSWQsIHNpZ25XaXRoKTtcbiAgICByZXR1cm4gYCR7c2lnbmVkTWVzc2FnZX1gO1xufVxuYXN5bmMgZnVuY3Rpb24gc2lnblRyYW5zYWN0aW9uKGNsaWVudCwgdHJhbnNhY3Rpb24sIHNlcmlhbGl6ZXIsIG9yZ2FuaXphdGlvbklkLCBzaWduV2l0aCkge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRUeCA9IHNlcmlhbGl6ZXIodHJhbnNhY3Rpb24pO1xuICAgIGNvbnN0IG5vbkhleFByZWZpeGVkU2VyaWFsaXplZFR4ID0gc2VyaWFsaXplZFR4LnJlcGxhY2UoL14weC8sIFwiXCIpO1xuICAgIHJldHVybiBhd2FpdCBzaWduVHJhbnNhY3Rpb25XaXRoRXJyb3JXcmFwcGluZyhjbGllbnQsIG5vbkhleFByZWZpeGVkU2VyaWFsaXplZFR4LCBvcmdhbml6YXRpb25JZCwgc2lnbldpdGgpO1xufVxuYXN5bmMgZnVuY3Rpb24gc2lnblR5cGVkRGF0YShjbGllbnQsIGRhdGEsIG9yZ2FuaXphdGlvbklkLCBzaWduV2l0aCkge1xuICAgIGNvbnN0IGhhc2hUb1NpZ24gPSBoYXNoVHlwZWREYXRhKGRhdGEpO1xuICAgIHJldHVybiBhd2FpdCBzaWduTWVzc2FnZVdpdGhFcnJvcldyYXBwaW5nKGNsaWVudCwgaGFzaFRvU2lnbiwgb3JnYW5pemF0aW9uSWQsIHNpZ25XaXRoKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNpZ25UcmFuc2FjdGlvbldpdGhFcnJvcldyYXBwaW5nKGNsaWVudCwgdW5zaWduZWRUcmFuc2FjdGlvbiwgb3JnYW5pemF0aW9uSWQsIHNpZ25XaXRoKSB7XG4gICAgbGV0IHNpZ25lZFR4O1xuICAgIHRyeSB7XG4gICAgICAgIHNpZ25lZFR4ID0gYXdhaXQgc2lnblRyYW5zYWN0aW9uSW1wbChjbGllbnQsIHVuc2lnbmVkVHJhbnNhY3Rpb24sIG9yZ2FuaXphdGlvbklkLCBzaWduV2l0aCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBUdXJua2V5QWN0aXZpdHlFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IFR1cm5rZXlBY3Rpdml0eUVycm9yKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGBGYWlsZWQgdG8gc2lnbiB0cmFuc2FjdGlvbjogJHtlcnJvci5tZXNzYWdlfWAsXG4gICAgICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYDB4JHtzaWduZWRUeH1gO1xufVxuYXN5bmMgZnVuY3Rpb24gc2lnblRyYW5zYWN0aW9uSW1wbChjbGllbnQsIHVuc2lnbmVkVHJhbnNhY3Rpb24sIG9yZ2FuaXphdGlvbklkLCBzaWduV2l0aCkge1xuICAgIGNvbnN0IHsgYWN0aXZpdHkgfSA9IGF3YWl0IGNsaWVudC5zaWduVHJhbnNhY3Rpb24oe1xuICAgICAgICB0eXBlOiBcIkFDVElWSVRZX1RZUEVfU0lHTl9UUkFOU0FDVElPTl9WMlwiLFxuICAgICAgICBvcmdhbml6YXRpb25JZDogb3JnYW5pemF0aW9uSWQsXG4gICAgICAgIHBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgIHNpZ25XaXRoLFxuICAgICAgICAgICAgdHlwZTogXCJUUkFOU0FDVElPTl9UWVBFX0VUSEVSRVVNXCIsXG4gICAgICAgICAgICB1bnNpZ25lZFRyYW5zYWN0aW9uOiB1bnNpZ25lZFRyYW5zYWN0aW9uLFxuICAgICAgICB9LFxuICAgICAgICB0aW1lc3RhbXBNczogU3RyaW5nKERhdGUubm93KCkpLCAvLyBtaWxsaXNlY29uZCB0aW1lc3RhbXBcbiAgICB9KTtcbiAgICBjb25zdCB7IGlkLCBzdGF0dXMsIHR5cGUgfSA9IGFjdGl2aXR5O1xuICAgIGlmIChhY3Rpdml0eS5zdGF0dXMgPT09IFwiQUNUSVZJVFlfU1RBVFVTX0NPTVBMRVRFRFwiKSB7XG4gICAgICAgIHJldHVybiBhc3NlcnROb25OdWxsKGFjdGl2aXR5Py5yZXN1bHQ/LnNpZ25UcmFuc2FjdGlvblJlc3VsdD8uc2lnbmVkVHJhbnNhY3Rpb24pO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHVybmtleUFjdGl2aXR5RXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiBgSW52YWxpZCBhY3Rpdml0eSBzdGF0dXM6ICR7YWN0aXZpdHkuc3RhdHVzfWAsXG4gICAgICAgIGFjdGl2aXR5SWQ6IGlkLFxuICAgICAgICBhY3Rpdml0eVN0YXR1czogc3RhdHVzLFxuICAgICAgICBhY3Rpdml0eVR5cGU6IHR5cGUsXG4gICAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiBzaWduTWVzc2FnZVdpdGhFcnJvcldyYXBwaW5nKGNsaWVudCwgbWVzc2FnZSwgb3JnYW5pemF0aW9uSWQsIHNpZ25XaXRoKSB7XG4gICAgbGV0IHNpZ25lZE1lc3NhZ2U7XG4gICAgdHJ5IHtcbiAgICAgICAgc2lnbmVkTWVzc2FnZSA9IGF3YWl0IHNpZ25NZXNzYWdlSW1wbChjbGllbnQsIG1lc3NhZ2UsIG9yZ2FuaXphdGlvbklkLCBzaWduV2l0aCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBUdXJua2V5QWN0aXZpdHlFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IFR1cm5rZXlBY3Rpdml0eUVycm9yKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGBGYWlsZWQgdG8gc2lnbjogJHtlcnJvci5tZXNzYWdlfWAsXG4gICAgICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gc2lnbmVkTWVzc2FnZTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNpZ25NZXNzYWdlSW1wbChjbGllbnQsIG1lc3NhZ2UsIG9yZ2FuaXphdGlvbklkLCBzaWduV2l0aCkge1xuICAgIGNvbnN0IHsgYWN0aXZpdHkgfSA9IGF3YWl0IGNsaWVudC5zaWduUmF3UGF5bG9hZCh7XG4gICAgICAgIHR5cGU6IFwiQUNUSVZJVFlfVFlQRV9TSUdOX1JBV19QQVlMT0FEX1YyXCIsXG4gICAgICAgIG9yZ2FuaXphdGlvbklkOiBvcmdhbml6YXRpb25JZCxcbiAgICAgICAgcGFyYW1ldGVyczoge1xuICAgICAgICAgICAgc2lnbldpdGgsXG4gICAgICAgICAgICBwYXlsb2FkOiBtZXNzYWdlLFxuICAgICAgICAgICAgZW5jb2Rpbmc6IFwiUEFZTE9BRF9FTkNPRElOR19IRVhBREVDSU1BTFwiLFxuICAgICAgICAgICAgaGFzaEZ1bmN0aW9uOiBcIkhBU0hfRlVOQ1RJT05fTk9fT1BcIixcbiAgICAgICAgfSxcbiAgICAgICAgdGltZXN0YW1wTXM6IFN0cmluZyhEYXRlLm5vdygpKSwgLy8gbWlsbGlzZWNvbmQgdGltZXN0YW1wXG4gICAgfSk7XG4gICAgY29uc3QgeyBpZCwgc3RhdHVzLCB0eXBlIH0gPSBhY3Rpdml0eTtcbiAgICBpZiAoYWN0aXZpdHkuc3RhdHVzID09PSBcIkFDVElWSVRZX1NUQVRVU19DT01QTEVURURcIikge1xuICAgICAgICBsZXQgcmVzdWx0ID0gYXNzZXJ0Tm9uTnVsbChhY3Rpdml0eT8ucmVzdWx0Py5zaWduUmF3UGF5bG9hZFJlc3VsdCk7XG4gICAgICAgIGxldCBhc3NlbWJsZWQgPSBzaWduYXR1cmVUb0hleCh7XG4gICAgICAgICAgICByOiBgMHgke3Jlc3VsdC5yfWAsXG4gICAgICAgICAgICBzOiBgMHgke3Jlc3VsdC5zfWAsXG4gICAgICAgICAgICB2OiByZXN1bHQudiA9PT0gXCIwMFwiID8gMjduIDogMjhuLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQXNzZW1ibGUgdGhlIGhleFxuICAgICAgICByZXR1cm4gYXNzZXJ0Tm9uTnVsbChhc3NlbWJsZWQpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHVybmtleUFjdGl2aXR5RXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiBgSW52YWxpZCBhY3Rpdml0eSBzdGF0dXM6ICR7YWN0aXZpdHkuc3RhdHVzfWAsXG4gICAgICAgIGFjdGl2aXR5SWQ6IGlkLFxuICAgICAgICBhY3Rpdml0eVN0YXR1czogc3RhdHVzLFxuICAgICAgICBhY3Rpdml0eVR5cGU6IHR5cGUsXG4gICAgfSk7XG59XG5mdW5jdGlvbiBhc3NlcnROb25OdWxsKGlucHV0KSB7XG4gICAgaWYgKGlucHV0ID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBHb3QgdW5leHBlY3RlZCAke0pTT04uc3RyaW5naWZ5KGlucHV0KX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGlucHV0O1xufVxuXG5leHBvcnQgeyBjcmVhdGVBY2NvdW50LCBjcmVhdGVBcGlLZXlBY2NvdW50IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/viem/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/webauthn-stamper/dist/index.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@turnkey/webauthn-stamper/dist/index.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WebauthnStamper: () => (/* binding */ WebauthnStamper)\n/* harmony export */ });\n/* harmony import */ var _webauthn_json_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webauthn-json/index.mjs */ \"(ssr)/./node_modules/@turnkey/webauthn-stamper/dist/webauthn-json/index.mjs\");\n/* harmony import */ var _universal_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./universal.mjs */ \"(ssr)/./node_modules/@turnkey/webauthn-stamper/dist/universal.mjs\");\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/@noble/hashes/esm/sha256.js\");\n\n\n\n\n/// <reference lib=\"dom\" />\n// Header name for a webauthn stamp\nconst stampHeaderName = \"X-Stamp-Webauthn\";\nconst defaultTimeout = 5 * 60 * 1000; // five minutes\nconst defaultUserVerification = \"preferred\";\n/**\n * Stamper to use with `@turnkey/http`'s `TurnkeyClient`\n */\nclass WebauthnStamper {\n    constructor(config) {\n        this.rpId = config.rpId;\n        this.timeout = config.timeout || defaultTimeout;\n        this.userVerification = config.userVerification || defaultUserVerification;\n        this.allowCredentials = config.allowCredentials || [];\n    }\n    async stamp(payload) {\n        const challenge = getChallengeFromPayload(payload);\n        const signingOptions = {\n            publicKey: {\n                rpId: this.rpId,\n                challenge: challenge,\n                allowCredentials: this.allowCredentials,\n                timeout: this.timeout,\n                userVerification: this.userVerification,\n            },\n        };\n        const clientGetResult = await (0,_webauthn_json_index_mjs__WEBPACK_IMPORTED_MODULE_0__.get)(signingOptions);\n        const assertion = clientGetResult.toJSON();\n        const stamp = {\n            authenticatorData: assertion.response.authenticatorData,\n            clientDataJson: assertion.response.clientDataJSON,\n            credentialId: assertion.id,\n            signature: assertion.response.signature,\n        };\n        return {\n            stampHeaderName: stampHeaderName,\n            stampHeaderValue: JSON.stringify(stamp),\n        };\n    }\n}\nfunction getChallengeFromPayload(payload) {\n    const messageBuffer = new TextEncoder().encode(payload);\n    const hashBuffer = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256)(messageBuffer);\n    const hexString = _universal_mjs__WEBPACK_IMPORTED_MODULE_1__.buffer.from(hashBuffer).toString(\"hex\");\n    const hexBuffer = _universal_mjs__WEBPACK_IMPORTED_MODULE_1__.buffer.from(hexString, \"utf8\");\n    return new Uint8Array(hexBuffer);\n}\n\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvd2ViYXV0aG4tc3RhbXBlci9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWdEO0FBQ1A7QUFDSzs7QUFFOUM7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxzQ0FBc0MsNkRBQUc7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDREQUFNO0FBQzdCLHNCQUFzQixrREFBTTtBQUM1QixzQkFBc0Isa0RBQU07QUFDNUI7QUFDQTs7QUFFMkI7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9udXJzZWJsb2MvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvd2ViYXV0aG4tc3RhbXBlci9kaXN0L2luZGV4Lm1qcz83OWM2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldCB9IGZyb20gJy4vd2ViYXV0aG4tanNvbi9pbmRleC5tanMnO1xuaW1wb3J0IHsgYnVmZmVyIH0gZnJvbSAnLi91bml2ZXJzYWwubWpzJztcbmltcG9ydCB7IHNoYTI1NiB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhMjU2JztcblxuLy8vIDxyZWZlcmVuY2UgbGliPVwiZG9tXCIgLz5cbi8vIEhlYWRlciBuYW1lIGZvciBhIHdlYmF1dGhuIHN0YW1wXG5jb25zdCBzdGFtcEhlYWRlck5hbWUgPSBcIlgtU3RhbXAtV2ViYXV0aG5cIjtcbmNvbnN0IGRlZmF1bHRUaW1lb3V0ID0gNSAqIDYwICogMTAwMDsgLy8gZml2ZSBtaW51dGVzXG5jb25zdCBkZWZhdWx0VXNlclZlcmlmaWNhdGlvbiA9IFwicHJlZmVycmVkXCI7XG4vKipcbiAqIFN0YW1wZXIgdG8gdXNlIHdpdGggYEB0dXJua2V5L2h0dHBgJ3MgYFR1cm5rZXlDbGllbnRgXG4gKi9cbmNsYXNzIFdlYmF1dGhuU3RhbXBlciB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHRoaXMucnBJZCA9IGNvbmZpZy5ycElkO1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSBjb25maWcudGltZW91dCB8fCBkZWZhdWx0VGltZW91dDtcbiAgICAgICAgdGhpcy51c2VyVmVyaWZpY2F0aW9uID0gY29uZmlnLnVzZXJWZXJpZmljYXRpb24gfHwgZGVmYXVsdFVzZXJWZXJpZmljYXRpb247XG4gICAgICAgIHRoaXMuYWxsb3dDcmVkZW50aWFscyA9IGNvbmZpZy5hbGxvd0NyZWRlbnRpYWxzIHx8IFtdO1xuICAgIH1cbiAgICBhc3luYyBzdGFtcChwYXlsb2FkKSB7XG4gICAgICAgIGNvbnN0IGNoYWxsZW5nZSA9IGdldENoYWxsZW5nZUZyb21QYXlsb2FkKHBheWxvYWQpO1xuICAgICAgICBjb25zdCBzaWduaW5nT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHB1YmxpY0tleToge1xuICAgICAgICAgICAgICAgIHJwSWQ6IHRoaXMucnBJZCxcbiAgICAgICAgICAgICAgICBjaGFsbGVuZ2U6IGNoYWxsZW5nZSxcbiAgICAgICAgICAgICAgICBhbGxvd0NyZWRlbnRpYWxzOiB0aGlzLmFsbG93Q3JlZGVudGlhbHMsXG4gICAgICAgICAgICAgICAgdGltZW91dDogdGhpcy50aW1lb3V0LFxuICAgICAgICAgICAgICAgIHVzZXJWZXJpZmljYXRpb246IHRoaXMudXNlclZlcmlmaWNhdGlvbixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNsaWVudEdldFJlc3VsdCA9IGF3YWl0IGdldChzaWduaW5nT3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGFzc2VydGlvbiA9IGNsaWVudEdldFJlc3VsdC50b0pTT04oKTtcbiAgICAgICAgY29uc3Qgc3RhbXAgPSB7XG4gICAgICAgICAgICBhdXRoZW50aWNhdG9yRGF0YTogYXNzZXJ0aW9uLnJlc3BvbnNlLmF1dGhlbnRpY2F0b3JEYXRhLFxuICAgICAgICAgICAgY2xpZW50RGF0YUpzb246IGFzc2VydGlvbi5yZXNwb25zZS5jbGllbnREYXRhSlNPTixcbiAgICAgICAgICAgIGNyZWRlbnRpYWxJZDogYXNzZXJ0aW9uLmlkLFxuICAgICAgICAgICAgc2lnbmF0dXJlOiBhc3NlcnRpb24ucmVzcG9uc2Uuc2lnbmF0dXJlLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhbXBIZWFkZXJOYW1lOiBzdGFtcEhlYWRlck5hbWUsXG4gICAgICAgICAgICBzdGFtcEhlYWRlclZhbHVlOiBKU09OLnN0cmluZ2lmeShzdGFtcCksXG4gICAgICAgIH07XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0Q2hhbGxlbmdlRnJvbVBheWxvYWQocGF5bG9hZCkge1xuICAgIGNvbnN0IG1lc3NhZ2VCdWZmZXIgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUocGF5bG9hZCk7XG4gICAgY29uc3QgaGFzaEJ1ZmZlciA9IHNoYTI1NihtZXNzYWdlQnVmZmVyKTtcbiAgICBjb25zdCBoZXhTdHJpbmcgPSBidWZmZXIuZnJvbShoYXNoQnVmZmVyKS50b1N0cmluZyhcImhleFwiKTtcbiAgICBjb25zdCBoZXhCdWZmZXIgPSBidWZmZXIuZnJvbShoZXhTdHJpbmcsIFwidXRmOFwiKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoaGV4QnVmZmVyKTtcbn1cblxuZXhwb3J0IHsgV2ViYXV0aG5TdGFtcGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/webauthn-stamper/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/webauthn-stamper/dist/universal.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@turnkey/webauthn-stamper/dist/universal.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buffer: () => (/* binding */ buffer)\n/* harmony export */ });\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! buffer */ \"buffer\");\n\n\n/// <reference lib=\"dom\" />\nlet buffer;\nif (typeof globalThis?.Buffer !== \"undefined\") {\n    buffer = globalThis.Buffer;\n}\nelse {\n    buffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer;\n}\n\n\n//# sourceMappingURL=universal.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvd2ViYXV0aG4tc3RhbXBlci9kaXN0L3VuaXZlcnNhbC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBZ0M7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsMENBQU07QUFDbkI7O0FBRWtCO0FBQ2xCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbnVyc2VibG9jLy4vbm9kZV9tb2R1bGVzL0B0dXJua2V5L3dlYmF1dGhuLXN0YW1wZXIvZGlzdC91bml2ZXJzYWwubWpzP2YzMDQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQnVmZmVyIH0gZnJvbSAnYnVmZmVyJztcblxuLy8vIDxyZWZlcmVuY2UgbGliPVwiZG9tXCIgLz5cbmxldCBidWZmZXI7XG5pZiAodHlwZW9mIGdsb2JhbFRoaXM/LkJ1ZmZlciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGJ1ZmZlciA9IGdsb2JhbFRoaXMuQnVmZmVyO1xufVxuZWxzZSB7XG4gICAgYnVmZmVyID0gQnVmZmVyO1xufVxuXG5leHBvcnQgeyBidWZmZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVuaXZlcnNhbC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/webauthn-stamper/dist/universal.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/webauthn-stamper/dist/webauthn-json/api.mjs":
/*!***************************************************************************!*\
  !*** ./node_modules/@turnkey/webauthn-stamper/dist/webauthn-json/api.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getResponseToJSON: () => (/* binding */ getResponseToJSON)\n/* harmony export */ });\n/* harmony import */ var _base64url_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base64url.mjs */ \"(ssr)/./node_modules/@turnkey/webauthn-stamper/dist/webauthn-json/base64url.mjs\");\n/* harmony import */ var _convert_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./convert.mjs */ \"(ssr)/./node_modules/@turnkey/webauthn-stamper/dist/webauthn-json/convert.mjs\");\n/* harmony import */ var _schema_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./schema.mjs */ \"(ssr)/./node_modules/@turnkey/webauthn-stamper/dist/webauthn-json/schema.mjs\");\n\n\n\n\nfunction getResponseToJSON(credential) {\n    return (0,_convert_mjs__WEBPACK_IMPORTED_MODULE_1__.convert)(_base64url_mjs__WEBPACK_IMPORTED_MODULE_0__.bufferToBase64url, _schema_mjs__WEBPACK_IMPORTED_MODULE_2__.publicKeyCredentialWithAssertion, credential);\n}\n\n\n//# sourceMappingURL=api.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvd2ViYXV0aG4tc3RhbXBlci9kaXN0L3dlYmF1dGhuLWpzb24vYXBpLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQW9EO0FBQ1o7QUFDd0I7O0FBRWhFO0FBQ0EsV0FBVyxxREFBTyxDQUFDLDZEQUFpQixFQUFFLHlFQUFnQztBQUN0RTs7QUFFNkI7QUFDN0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9udXJzZWJsb2MvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvd2ViYXV0aG4tc3RhbXBlci9kaXN0L3dlYmF1dGhuLWpzb24vYXBpLm1qcz9jZmFhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGJ1ZmZlclRvQmFzZTY0dXJsIH0gZnJvbSAnLi9iYXNlNjR1cmwubWpzJztcbmltcG9ydCB7IGNvbnZlcnQgfSBmcm9tICcuL2NvbnZlcnQubWpzJztcbmltcG9ydCB7IHB1YmxpY0tleUNyZWRlbnRpYWxXaXRoQXNzZXJ0aW9uIH0gZnJvbSAnLi9zY2hlbWEubWpzJztcblxuZnVuY3Rpb24gZ2V0UmVzcG9uc2VUb0pTT04oY3JlZGVudGlhbCkge1xuICAgIHJldHVybiBjb252ZXJ0KGJ1ZmZlclRvQmFzZTY0dXJsLCBwdWJsaWNLZXlDcmVkZW50aWFsV2l0aEFzc2VydGlvbiwgY3JlZGVudGlhbCk7XG59XG5cbmV4cG9ydCB7IGdldFJlc3BvbnNlVG9KU09OIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcGkubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/webauthn-stamper/dist/webauthn-json/api.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/webauthn-stamper/dist/webauthn-json/base64url.mjs":
/*!*********************************************************************************!*\
  !*** ./node_modules/@turnkey/webauthn-stamper/dist/webauthn-json/base64url.mjs ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bufferToBase64url: () => (/* binding */ bufferToBase64url)\n/* harmony export */ });\nfunction bufferToBase64url(buffer) {\n    // Buffer to binary string\n    const byteView = new Uint8Array(buffer);\n    let str = \"\";\n    for (const charCode of byteView) {\n        str += String.fromCharCode(charCode);\n    }\n    // Binary string to base64\n    const base64String = btoa(str);\n    // Base64 to base64url\n    // We assume that the base64url string is well-formed.\n    const base64urlString = base64String\n        .replace(/\\+/g, \"-\")\n        .replace(/\\//g, \"_\")\n        .replace(/=/g, \"\");\n    return base64urlString;\n}\n\n\n//# sourceMappingURL=base64url.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvd2ViYXV0aG4tc3RhbXBlci9kaXN0L3dlYmF1dGhuLWpzb24vYmFzZTY0dXJsLm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNkI7QUFDN0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9udXJzZWJsb2MvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvd2ViYXV0aG4tc3RhbXBlci9kaXN0L3dlYmF1dGhuLWpzb24vYmFzZTY0dXJsLm1qcz9iNjhiIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGJ1ZmZlclRvQmFzZTY0dXJsKGJ1ZmZlcikge1xuICAgIC8vIEJ1ZmZlciB0byBiaW5hcnkgc3RyaW5nXG4gICAgY29uc3QgYnl0ZVZpZXcgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgIGxldCBzdHIgPSBcIlwiO1xuICAgIGZvciAoY29uc3QgY2hhckNvZGUgb2YgYnl0ZVZpZXcpIHtcbiAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xuICAgIH1cbiAgICAvLyBCaW5hcnkgc3RyaW5nIHRvIGJhc2U2NFxuICAgIGNvbnN0IGJhc2U2NFN0cmluZyA9IGJ0b2Eoc3RyKTtcbiAgICAvLyBCYXNlNjQgdG8gYmFzZTY0dXJsXG4gICAgLy8gV2UgYXNzdW1lIHRoYXQgdGhlIGJhc2U2NHVybCBzdHJpbmcgaXMgd2VsbC1mb3JtZWQuXG4gICAgY29uc3QgYmFzZTY0dXJsU3RyaW5nID0gYmFzZTY0U3RyaW5nXG4gICAgICAgIC5yZXBsYWNlKC9cXCsvZywgXCItXCIpXG4gICAgICAgIC5yZXBsYWNlKC9cXC8vZywgXCJfXCIpXG4gICAgICAgIC5yZXBsYWNlKC89L2csIFwiXCIpO1xuICAgIHJldHVybiBiYXNlNjR1cmxTdHJpbmc7XG59XG5cbmV4cG9ydCB7IGJ1ZmZlclRvQmFzZTY0dXJsIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlNjR1cmwubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/webauthn-stamper/dist/webauthn-json/base64url.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/webauthn-stamper/dist/webauthn-json/convert.mjs":
/*!*******************************************************************************!*\
  !*** ./node_modules/@turnkey/webauthn-stamper/dist/webauthn-json/convert.mjs ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   convert: () => (/* binding */ convert),\n/* harmony export */   convertValue: () => (/* binding */ convertValue),\n/* harmony export */   copyValue: () => (/* binding */ copyValue),\n/* harmony export */   derived: () => (/* binding */ derived),\n/* harmony export */   optional: () => (/* binding */ optional),\n/* harmony export */   required: () => (/* binding */ required)\n/* harmony export */ });\n// We export these values in order so that they can be used to deduplicate\n// schema definitions in minified JS code.\n// TODO: Parcel isn't deduplicating these values.\nconst copyValue = \"copy\";\nconst convertValue = \"convert\";\nfunction convert(conversionFn, schema, input) {\n    if (schema === copyValue) {\n        return input;\n    }\n    if (schema === convertValue) {\n        return conversionFn(input);\n    }\n    if (schema instanceof Array) {\n        return input.map((v) => convert(conversionFn, schema[0], v));\n    }\n    if (schema instanceof Object) {\n        const output = {};\n        for (const [key, schemaField] of Object.entries(schema)) {\n            if (schemaField.derive) {\n                const v = schemaField.derive(input);\n                if (v !== undefined) {\n                    input[key] = v;\n                }\n            }\n            if (!(key in input)) {\n                if (schemaField.required) {\n                    throw new Error(`Missing key: ${key}`);\n                }\n                continue;\n            }\n            // Fields can be null (rather than missing or `undefined`), e.g. the\n            // `userHandle` field of the `AuthenticatorAssertionResponse`:\n            // https://www.w3.org/TR/webauthn/#iface-authenticatorassertionresponse\n            if (input[key] == null) {\n                output[key] = null;\n                continue;\n            }\n            output[key] = convert(conversionFn, schemaField.schema, input[key]);\n        }\n        return output;\n    }\n}\nfunction derived(schema, derive) {\n    return {\n        required: true,\n        schema,\n        derive,\n    };\n}\nfunction required(schema) {\n    return {\n        required: true,\n        schema,\n    };\n}\nfunction optional(schema) {\n    return {\n        required: false,\n        schema,\n    };\n}\n\n\n//# sourceMappingURL=convert.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvd2ViYXV0aG4tc3RhbXBlci9kaXN0L3dlYmF1dGhuLWpzb24vY29udmVydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxJQUFJO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV5RTtBQUN6RSIsInNvdXJjZXMiOlsid2VicGFjazovL251cnNlYmxvYy8uL25vZGVfbW9kdWxlcy9AdHVybmtleS93ZWJhdXRobi1zdGFtcGVyL2Rpc3Qvd2ViYXV0aG4tanNvbi9jb252ZXJ0Lm1qcz8wYjUyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFdlIGV4cG9ydCB0aGVzZSB2YWx1ZXMgaW4gb3JkZXIgc28gdGhhdCB0aGV5IGNhbiBiZSB1c2VkIHRvIGRlZHVwbGljYXRlXG4vLyBzY2hlbWEgZGVmaW5pdGlvbnMgaW4gbWluaWZpZWQgSlMgY29kZS5cbi8vIFRPRE86IFBhcmNlbCBpc24ndCBkZWR1cGxpY2F0aW5nIHRoZXNlIHZhbHVlcy5cbmNvbnN0IGNvcHlWYWx1ZSA9IFwiY29weVwiO1xuY29uc3QgY29udmVydFZhbHVlID0gXCJjb252ZXJ0XCI7XG5mdW5jdGlvbiBjb252ZXJ0KGNvbnZlcnNpb25Gbiwgc2NoZW1hLCBpbnB1dCkge1xuICAgIGlmIChzY2hlbWEgPT09IGNvcHlWYWx1ZSkge1xuICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuICAgIGlmIChzY2hlbWEgPT09IGNvbnZlcnRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gY29udmVyc2lvbkZuKGlucHV0KTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIHJldHVybiBpbnB1dC5tYXAoKHYpID0+IGNvbnZlcnQoY29udmVyc2lvbkZuLCBzY2hlbWFbMF0sIHYpKTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCBzY2hlbWFGaWVsZF0gb2YgT2JqZWN0LmVudHJpZXMoc2NoZW1hKSkge1xuICAgICAgICAgICAgaWYgKHNjaGVtYUZpZWxkLmRlcml2ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHYgPSBzY2hlbWFGaWVsZC5kZXJpdmUoaW5wdXQpO1xuICAgICAgICAgICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRba2V5XSA9IHY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEoa2V5IGluIGlucHV0KSkge1xuICAgICAgICAgICAgICAgIGlmIChzY2hlbWFGaWVsZC5yZXF1aXJlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1pc3Npbmcga2V5OiAke2tleX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGaWVsZHMgY2FuIGJlIG51bGwgKHJhdGhlciB0aGFuIG1pc3Npbmcgb3IgYHVuZGVmaW5lZGApLCBlLmcuIHRoZVxuICAgICAgICAgICAgLy8gYHVzZXJIYW5kbGVgIGZpZWxkIG9mIHRoZSBgQXV0aGVudGljYXRvckFzc2VydGlvblJlc3BvbnNlYDpcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJhdXRobi8jaWZhY2UtYXV0aGVudGljYXRvcmFzc2VydGlvbnJlc3BvbnNlXG4gICAgICAgICAgICBpZiAoaW5wdXRba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W2tleV0gPSBudWxsO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0cHV0W2tleV0gPSBjb252ZXJ0KGNvbnZlcnNpb25Gbiwgc2NoZW1hRmllbGQuc2NoZW1hLCBpbnB1dFtrZXldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRlcml2ZWQoc2NoZW1hLCBkZXJpdmUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgICAgc2NoZW1hLFxuICAgICAgICBkZXJpdmUsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJlcXVpcmVkKHNjaGVtYSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgICBzY2hlbWEsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIG9wdGlvbmFsKHNjaGVtYSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHJlcXVpcmVkOiBmYWxzZSxcbiAgICAgICAgc2NoZW1hLFxuICAgIH07XG59XG5cbmV4cG9ydCB7IGNvbnZlcnQsIGNvbnZlcnRWYWx1ZSwgY29weVZhbHVlLCBkZXJpdmVkLCBvcHRpb25hbCwgcmVxdWlyZWQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnZlcnQubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/webauthn-stamper/dist/webauthn-json/convert.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/webauthn-stamper/dist/webauthn-json/index.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/@turnkey/webauthn-stamper/dist/webauthn-json/index.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   get: () => (/* binding */ get)\n/* harmony export */ });\n/* harmony import */ var _api_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./api.mjs */ \"(ssr)/./node_modules/@turnkey/webauthn-stamper/dist/webauthn-json/api.mjs\");\n\n\nasync function get(options) {\n    const response = (await navigator.credentials.get(options));\n    response.toJSON = () => (0,_api_mjs__WEBPACK_IMPORTED_MODULE_0__.getResponseToJSON)(response);\n    return response;\n}\n\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvd2ViYXV0aG4tc3RhbXBlci9kaXN0L3dlYmF1dGhuLWpzb24vaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQThDOztBQUU5QztBQUNBO0FBQ0EsNEJBQTRCLDJEQUFpQjtBQUM3QztBQUNBOztBQUVlO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9udXJzZWJsb2MvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvd2ViYXV0aG4tc3RhbXBlci9kaXN0L3dlYmF1dGhuLWpzb24vaW5kZXgubWpzPzA3ZGQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0UmVzcG9uc2VUb0pTT04gfSBmcm9tICcuL2FwaS5tanMnO1xuXG5hc3luYyBmdW5jdGlvbiBnZXQob3B0aW9ucykge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gKGF3YWl0IG5hdmlnYXRvci5jcmVkZW50aWFscy5nZXQob3B0aW9ucykpO1xuICAgIHJlc3BvbnNlLnRvSlNPTiA9ICgpID0+IGdldFJlc3BvbnNlVG9KU09OKHJlc3BvbnNlKTtcbiAgICByZXR1cm4gcmVzcG9uc2U7XG59XG5cbmV4cG9ydCB7IGdldCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/webauthn-stamper/dist/webauthn-json/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@turnkey/webauthn-stamper/dist/webauthn-json/schema.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/@turnkey/webauthn-stamper/dist/webauthn-json/schema.mjs ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   publicKeyCredentialWithAssertion: () => (/* binding */ publicKeyCredentialWithAssertion)\n/* harmony export */ });\n/* harmony import */ var _convert_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./convert.mjs */ \"(ssr)/./node_modules/@turnkey/webauthn-stamper/dist/webauthn-json/convert.mjs\");\n\n\nconst simplifiedClientExtensionResultsSchema = {\n    appid: (0,_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.optional)(_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.copyValue),\n    appidExclude: (0,_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.optional)(_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.copyValue),\n    credProps: (0,_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.optional)(_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.copyValue),\n};\n// `navigator.get()` response\nconst publicKeyCredentialWithAssertion = {\n    type: (0,_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.required)(_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.copyValue),\n    id: (0,_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.required)(_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.copyValue),\n    rawId: (0,_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.required)(_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.convertValue),\n    authenticatorAttachment: (0,_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.optional)(_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.copyValue),\n    response: (0,_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.required)({\n        clientDataJSON: (0,_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.required)(_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.convertValue),\n        authenticatorData: (0,_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.required)(_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.convertValue),\n        signature: (0,_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.required)(_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.convertValue),\n        userHandle: (0,_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.required)(_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.convertValue),\n    }),\n    clientExtensionResults: (0,_convert_mjs__WEBPACK_IMPORTED_MODULE_0__.derived)(simplifiedClientExtensionResultsSchema, (pkc) => pkc.getClientExtensionResults()),\n};\n\n\n//# sourceMappingURL=schema.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvd2ViYXV0aG4tc3RhbXBlci9kaXN0L3dlYmF1dGhuLWpzb24vc2NoZW1hLm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFxRjs7QUFFckY7QUFDQSxXQUFXLHNEQUFRLENBQUMsbURBQVM7QUFDN0Isa0JBQWtCLHNEQUFRLENBQUMsbURBQVM7QUFDcEMsZUFBZSxzREFBUSxDQUFDLG1EQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLFVBQVUsc0RBQVEsQ0FBQyxtREFBUztBQUM1QixRQUFRLHNEQUFRLENBQUMsbURBQVM7QUFDMUIsV0FBVyxzREFBUSxDQUFDLHNEQUFZO0FBQ2hDLDZCQUE2QixzREFBUSxDQUFDLG1EQUFTO0FBQy9DLGNBQWMsc0RBQVE7QUFDdEIsd0JBQXdCLHNEQUFRLENBQUMsc0RBQVk7QUFDN0MsMkJBQTJCLHNEQUFRLENBQUMsc0RBQVk7QUFDaEQsbUJBQW1CLHNEQUFRLENBQUMsc0RBQVk7QUFDeEMsb0JBQW9CLHNEQUFRLENBQUMsc0RBQVk7QUFDekMsS0FBSztBQUNMLDRCQUE0QixxREFBTztBQUNuQzs7QUFFNEM7QUFDNUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9udXJzZWJsb2MvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvd2ViYXV0aG4tc3RhbXBlci9kaXN0L3dlYmF1dGhuLWpzb24vc2NoZW1hLm1qcz9kNzE2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHJlcXVpcmVkLCBvcHRpb25hbCwgZGVyaXZlZCwgY29weVZhbHVlLCBjb252ZXJ0VmFsdWUgfSBmcm9tICcuL2NvbnZlcnQubWpzJztcblxuY29uc3Qgc2ltcGxpZmllZENsaWVudEV4dGVuc2lvblJlc3VsdHNTY2hlbWEgPSB7XG4gICAgYXBwaWQ6IG9wdGlvbmFsKGNvcHlWYWx1ZSksXG4gICAgYXBwaWRFeGNsdWRlOiBvcHRpb25hbChjb3B5VmFsdWUpLFxuICAgIGNyZWRQcm9wczogb3B0aW9uYWwoY29weVZhbHVlKSxcbn07XG4vLyBgbmF2aWdhdG9yLmdldCgpYCByZXNwb25zZVxuY29uc3QgcHVibGljS2V5Q3JlZGVudGlhbFdpdGhBc3NlcnRpb24gPSB7XG4gICAgdHlwZTogcmVxdWlyZWQoY29weVZhbHVlKSxcbiAgICBpZDogcmVxdWlyZWQoY29weVZhbHVlKSxcbiAgICByYXdJZDogcmVxdWlyZWQoY29udmVydFZhbHVlKSxcbiAgICBhdXRoZW50aWNhdG9yQXR0YWNobWVudDogb3B0aW9uYWwoY29weVZhbHVlKSxcbiAgICByZXNwb25zZTogcmVxdWlyZWQoe1xuICAgICAgICBjbGllbnREYXRhSlNPTjogcmVxdWlyZWQoY29udmVydFZhbHVlKSxcbiAgICAgICAgYXV0aGVudGljYXRvckRhdGE6IHJlcXVpcmVkKGNvbnZlcnRWYWx1ZSksXG4gICAgICAgIHNpZ25hdHVyZTogcmVxdWlyZWQoY29udmVydFZhbHVlKSxcbiAgICAgICAgdXNlckhhbmRsZTogcmVxdWlyZWQoY29udmVydFZhbHVlKSxcbiAgICB9KSxcbiAgICBjbGllbnRFeHRlbnNpb25SZXN1bHRzOiBkZXJpdmVkKHNpbXBsaWZpZWRDbGllbnRFeHRlbnNpb25SZXN1bHRzU2NoZW1hLCAocGtjKSA9PiBwa2MuZ2V0Q2xpZW50RXh0ZW5zaW9uUmVzdWx0cygpKSxcbn07XG5cbmV4cG9ydCB7IHB1YmxpY0tleUNyZWRlbnRpYWxXaXRoQXNzZXJ0aW9uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY2hlbWEubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@turnkey/webauthn-stamper/dist/webauthn-json/schema.mjs\n");

/***/ })

};
;