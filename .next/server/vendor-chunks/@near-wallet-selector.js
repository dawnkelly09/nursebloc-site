"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@near-wallet-selector";
exports.ids = ["vendor-chunks/@near-wallet-selector"];
exports.modules = {

/***/ "(ssr)/./node_modules/@near-wallet-selector/modal-ui/styles.css":
/*!****************************************************************!*\
  !*** ./node_modules/@near-wallet-selector/modal-ui/styles.css ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"df4941ab9649\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5lYXItd2FsbGV0LXNlbGVjdG9yL21vZGFsLXVpL3N0eWxlcy5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxLQUFVLEVBQUUsRUFBdUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9udXJzZWJsb2MvLi9ub2RlX21vZHVsZXMvQG5lYXItd2FsbGV0LXNlbGVjdG9yL21vZGFsLXVpL3N0eWxlcy5jc3M/ZTcxZCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcImRmNDk0MWFiOTY0OVwiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@near-wallet-selector/modal-ui/styles.css\n");

/***/ }),

/***/ "(ssr)/./node_modules/@near-wallet-selector/core/index.cjs":
/*!***********************************************************!*\
  !*** ./node_modules/@near-wallet-selector/core/index.cjs ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar nearAPI = __webpack_require__(/*! near-api-js */ \"(ssr)/./node_modules/near-api-js/lib/index.js\");\nvar events = __webpack_require__(/*! events */ \"events\");\nvar rxjs = __webpack_require__(/*! rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/index.js\");\nvar borsh = __webpack_require__(/*! borsh */ \"(ssr)/./node_modules/borsh/lib/index.js\");\nvar jsSha256 = __webpack_require__(/*! js-sha256 */ \"(ssr)/./node_modules/js-sha256/src/sha256.js\");\n\nfunction _interopNamespace(e) {\n    if (e && e.__esModule) return e;\n    var n = Object.create(null);\n    if (e) {\n        Object.keys(e).forEach(function (k) {\n            if (k !== 'default') {\n                var d = Object.getOwnPropertyDescriptor(e, k);\n                Object.defineProperty(n, k, d.get ? d : {\n                    enumerable: true,\n                    get: function () { return e[k]; }\n                });\n            }\n        });\n    }\n    n[\"default\"] = e;\n    return Object.freeze(n);\n}\n\nvar nearAPI__namespace = /*#__PURE__*/_interopNamespace(nearAPI);\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\n\nclass Provider {\n  constructor(url) {\n    this.provider = new nearAPI__namespace.providers.JsonRpcProvider({\n      url\n    });\n  }\n  query(params) {\n    return this.provider.query(params);\n  }\n  viewAccessKey({\n    accountId,\n    publicKey\n  }) {\n    return this.query({\n      request_type: \"view_access_key\",\n      finality: \"final\",\n      account_id: accountId,\n      public_key: publicKey\n    });\n  }\n  block(reference) {\n    return this.provider.block(reference);\n  }\n  sendTransaction(signedTransaction) {\n    return this.provider.sendTransaction(signedTransaction);\n  }\n}\n\nconst KEY_DELIMITER = \":\";\nclass JsonStorage {\n  constructor(storage, namespace) {\n    this.storage = storage;\n    this.namespace = Array.isArray(namespace) ? namespace.join(KEY_DELIMITER) : namespace;\n  }\n  resolveKey(key) {\n    return [this.namespace, key].join(KEY_DELIMITER);\n  }\n  getItem(key) {\n    return this.storage.getItem(this.resolveKey(key)).then(item => {\n      return typeof item === \"string\" ? JSON.parse(item) : null;\n    });\n  }\n  setItem(key, value) {\n    return this.storage.setItem(this.resolveKey(key), JSON.stringify(value));\n  }\n  removeItem(key) {\n    return this.storage.removeItem(this.resolveKey(key));\n  }\n}\n\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nvar check = function (it) {\n  return it && it.Math == Math && it;\n};\n\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global$t =\n  // eslint-disable-next-line es-x/no-global-this -- safe\n  check(typeof globalThis == 'object' && globalThis) ||\n  check(typeof window == 'object' && window) ||\n  // eslint-disable-next-line no-restricted-globals -- safe\n  check(typeof self == 'object' && self) ||\n  check(typeof commonjsGlobal == 'object' && commonjsGlobal) ||\n  // eslint-disable-next-line no-new-func -- fallback\n  (function () { return this; })() || Function('return this')();\n\nvar objectGetOwnPropertyDescriptor = {};\n\nvar fails$s = function (exec) {\n  try {\n    return !!exec();\n  } catch (error) {\n    return true;\n  }\n};\n\nvar fails$r = fails$s;\n\n// Detect IE8's incomplete defineProperty implementation\nvar descriptors = !fails$r(function () {\n  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;\n});\n\nvar fails$q = fails$s;\n\nvar functionBindNative = !fails$q(function () {\n  // eslint-disable-next-line es-x/no-function-prototype-bind -- safe\n  var test = (function () { /* empty */ }).bind();\n  // eslint-disable-next-line no-prototype-builtins -- safe\n  return typeof test != 'function' || test.hasOwnProperty('prototype');\n});\n\nvar NATIVE_BIND$3 = functionBindNative;\n\nvar call$l = Function.prototype.call;\n\nvar functionCall = NATIVE_BIND$3 ? call$l.bind(call$l) : function () {\n  return call$l.apply(call$l, arguments);\n};\n\nvar objectPropertyIsEnumerable = {};\n\nvar $propertyIsEnumerable = {}.propertyIsEnumerable;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar getOwnPropertyDescriptor$2 = Object.getOwnPropertyDescriptor;\n\n// Nashorn ~ JDK8 bug\nvar NASHORN_BUG = getOwnPropertyDescriptor$2 && !$propertyIsEnumerable.call({ 1: 2 }, 1);\n\n// `Object.prototype.propertyIsEnumerable` method implementation\n// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable\nobjectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n  var descriptor = getOwnPropertyDescriptor$2(this, V);\n  return !!descriptor && descriptor.enumerable;\n} : $propertyIsEnumerable;\n\nvar createPropertyDescriptor$5 = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n\nvar NATIVE_BIND$2 = functionBindNative;\n\nvar FunctionPrototype$2 = Function.prototype;\nvar bind$7 = FunctionPrototype$2.bind;\nvar call$k = FunctionPrototype$2.call;\nvar uncurryThis$p = NATIVE_BIND$2 && bind$7.bind(call$k, call$k);\n\nvar functionUncurryThis = NATIVE_BIND$2 ? function (fn) {\n  return fn && uncurryThis$p(fn);\n} : function (fn) {\n  return fn && function () {\n    return call$k.apply(fn, arguments);\n  };\n};\n\nvar uncurryThis$o = functionUncurryThis;\n\nvar toString$7 = uncurryThis$o({}.toString);\nvar stringSlice$3 = uncurryThis$o(''.slice);\n\nvar classofRaw$1 = function (it) {\n  return stringSlice$3(toString$7(it), 8, -1);\n};\n\nvar uncurryThis$n = functionUncurryThis;\nvar fails$p = fails$s;\nvar classof$b = classofRaw$1;\n\nvar $Object$4 = Object;\nvar split = uncurryThis$n(''.split);\n\n// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar indexedObject = fails$p(function () {\n  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n  // eslint-disable-next-line no-prototype-builtins -- safe\n  return !$Object$4('z').propertyIsEnumerable(0);\n}) ? function (it) {\n  return classof$b(it) == 'String' ? split(it, '') : $Object$4(it);\n} : $Object$4;\n\nvar $TypeError$f = TypeError;\n\n// `RequireObjectCoercible` abstract operation\n// https://tc39.es/ecma262/#sec-requireobjectcoercible\nvar requireObjectCoercible$6 = function (it) {\n  if (it == undefined) throw $TypeError$f(\"Can't call method on \" + it);\n  return it;\n};\n\n// toObject with fallback for non-array-like ES3 strings\nvar IndexedObject$3 = indexedObject;\nvar requireObjectCoercible$5 = requireObjectCoercible$6;\n\nvar toIndexedObject$6 = function (it) {\n  return IndexedObject$3(requireObjectCoercible$5(it));\n};\n\n// `IsCallable` abstract operation\n// https://tc39.es/ecma262/#sec-iscallable\nvar isCallable$n = function (argument) {\n  return typeof argument == 'function';\n};\n\nvar isCallable$m = isCallable$n;\n\nvar isObject$d = function (it) {\n  return typeof it == 'object' ? it !== null : isCallable$m(it);\n};\n\nvar global$s = global$t;\nvar isCallable$l = isCallable$n;\n\nvar aFunction = function (argument) {\n  return isCallable$l(argument) ? argument : undefined;\n};\n\nvar getBuiltIn$8 = function (namespace, method) {\n  return arguments.length < 2 ? aFunction(global$s[namespace]) : global$s[namespace] && global$s[namespace][method];\n};\n\nvar uncurryThis$m = functionUncurryThis;\n\nvar objectIsPrototypeOf = uncurryThis$m({}.isPrototypeOf);\n\nvar getBuiltIn$7 = getBuiltIn$8;\n\nvar engineUserAgent = getBuiltIn$7('navigator', 'userAgent') || '';\n\nvar global$r = global$t;\nvar userAgent$5 = engineUserAgent;\n\nvar process$3 = global$r.process;\nvar Deno$1 = global$r.Deno;\nvar versions = process$3 && process$3.versions || Deno$1 && Deno$1.version;\nvar v8 = versions && versions.v8;\nvar match, version;\n\nif (v8) {\n  match = v8.split('.');\n  // in old Chrome, versions of V8 isn't V8 = Chrome / 10\n  // but their correct versions are not interesting for us\n  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);\n}\n\n// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`\n// so check `userAgent` even if `.v8` exists, but 0\nif (!version && userAgent$5) {\n  match = userAgent$5.match(/Edge\\/(\\d+)/);\n  if (!match || match[1] >= 74) {\n    match = userAgent$5.match(/Chrome\\/(\\d+)/);\n    if (match) version = +match[1];\n  }\n}\n\nvar engineV8Version = version;\n\n/* eslint-disable es-x/no-symbol -- required for testing */\n\nvar V8_VERSION$1 = engineV8Version;\nvar fails$o = fails$s;\n\n// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- required for testing\nvar nativeSymbol = !!Object.getOwnPropertySymbols && !fails$o(function () {\n  var symbol = Symbol();\n  // Chrome 38 Symbol has incorrect toString conversion\n  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances\n  return !String(symbol) || !(Object(symbol) instanceof Symbol) ||\n    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances\n    !Symbol.sham && V8_VERSION$1 && V8_VERSION$1 < 41;\n});\n\n/* eslint-disable es-x/no-symbol -- required for testing */\n\nvar NATIVE_SYMBOL$1 = nativeSymbol;\n\nvar useSymbolAsUid = NATIVE_SYMBOL$1\n  && !Symbol.sham\n  && typeof Symbol.iterator == 'symbol';\n\nvar getBuiltIn$6 = getBuiltIn$8;\nvar isCallable$k = isCallable$n;\nvar isPrototypeOf$4 = objectIsPrototypeOf;\nvar USE_SYMBOL_AS_UID$1 = useSymbolAsUid;\n\nvar $Object$3 = Object;\n\nvar isSymbol$3 = USE_SYMBOL_AS_UID$1 ? function (it) {\n  return typeof it == 'symbol';\n} : function (it) {\n  var $Symbol = getBuiltIn$6('Symbol');\n  return isCallable$k($Symbol) && isPrototypeOf$4($Symbol.prototype, $Object$3(it));\n};\n\nvar $String$3 = String;\n\nvar tryToString$5 = function (argument) {\n  try {\n    return $String$3(argument);\n  } catch (error) {\n    return 'Object';\n  }\n};\n\nvar isCallable$j = isCallable$n;\nvar tryToString$4 = tryToString$5;\n\nvar $TypeError$e = TypeError;\n\n// `Assert: IsCallable(argument) is true`\nvar aCallable$9 = function (argument) {\n  if (isCallable$j(argument)) return argument;\n  throw $TypeError$e(tryToString$4(argument) + ' is not a function');\n};\n\nvar aCallable$8 = aCallable$9;\n\n// `GetMethod` abstract operation\n// https://tc39.es/ecma262/#sec-getmethod\nvar getMethod$4 = function (V, P) {\n  var func = V[P];\n  return func == null ? undefined : aCallable$8(func);\n};\n\nvar call$j = functionCall;\nvar isCallable$i = isCallable$n;\nvar isObject$c = isObject$d;\n\nvar $TypeError$d = TypeError;\n\n// `OrdinaryToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-ordinarytoprimitive\nvar ordinaryToPrimitive$1 = function (input, pref) {\n  var fn, val;\n  if (pref === 'string' && isCallable$i(fn = input.toString) && !isObject$c(val = call$j(fn, input))) return val;\n  if (isCallable$i(fn = input.valueOf) && !isObject$c(val = call$j(fn, input))) return val;\n  if (pref !== 'string' && isCallable$i(fn = input.toString) && !isObject$c(val = call$j(fn, input))) return val;\n  throw $TypeError$d(\"Can't convert object to primitive value\");\n};\n\nvar shared$4 = {exports: {}};\n\nvar global$q = global$t;\n\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar defineProperty$7 = Object.defineProperty;\n\nvar defineGlobalProperty$3 = function (key, value) {\n  try {\n    defineProperty$7(global$q, key, { value: value, configurable: true, writable: true });\n  } catch (error) {\n    global$q[key] = value;\n  } return value;\n};\n\nvar global$p = global$t;\nvar defineGlobalProperty$2 = defineGlobalProperty$3;\n\nvar SHARED = '__core-js_shared__';\nvar store$3 = global$p[SHARED] || defineGlobalProperty$2(SHARED, {});\n\nvar sharedStore = store$3;\n\nvar store$2 = sharedStore;\n\n(shared$4.exports = function (key, value) {\n  return store$2[key] || (store$2[key] = value !== undefined ? value : {});\n})('versions', []).push({\n  version: '3.23.3',\n  mode: 'global',\n  copyright: '© 2014-2022 Denis Pushkarev (zloirock.ru)',\n  license: 'https://github.com/zloirock/core-js/blob/v3.23.3/LICENSE',\n  source: 'https://github.com/zloirock/core-js'\n});\n\nvar requireObjectCoercible$4 = requireObjectCoercible$6;\n\nvar $Object$2 = Object;\n\n// `ToObject` abstract operation\n// https://tc39.es/ecma262/#sec-toobject\nvar toObject$7 = function (argument) {\n  return $Object$2(requireObjectCoercible$4(argument));\n};\n\nvar uncurryThis$l = functionUncurryThis;\nvar toObject$6 = toObject$7;\n\nvar hasOwnProperty = uncurryThis$l({}.hasOwnProperty);\n\n// `HasOwnProperty` abstract operation\n// https://tc39.es/ecma262/#sec-hasownproperty\n// eslint-disable-next-line es-x/no-object-hasown -- safe\nvar hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {\n  return hasOwnProperty(toObject$6(it), key);\n};\n\nvar uncurryThis$k = functionUncurryThis;\n\nvar id = 0;\nvar postfix = Math.random();\nvar toString$6 = uncurryThis$k(1.0.toString);\n\nvar uid$3 = function (key) {\n  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString$6(++id + postfix, 36);\n};\n\nvar global$o = global$t;\nvar shared$3 = shared$4.exports;\nvar hasOwn$b = hasOwnProperty_1;\nvar uid$2 = uid$3;\nvar NATIVE_SYMBOL = nativeSymbol;\nvar USE_SYMBOL_AS_UID = useSymbolAsUid;\n\nvar WellKnownSymbolsStore = shared$3('wks');\nvar Symbol$1 = global$o.Symbol;\nvar symbolFor = Symbol$1 && Symbol$1['for'];\nvar createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid$2;\n\nvar wellKnownSymbol$j = function (name) {\n  if (!hasOwn$b(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == 'string')) {\n    var description = 'Symbol.' + name;\n    if (NATIVE_SYMBOL && hasOwn$b(Symbol$1, name)) {\n      WellKnownSymbolsStore[name] = Symbol$1[name];\n    } else if (USE_SYMBOL_AS_UID && symbolFor) {\n      WellKnownSymbolsStore[name] = symbolFor(description);\n    } else {\n      WellKnownSymbolsStore[name] = createWellKnownSymbol(description);\n    }\n  } return WellKnownSymbolsStore[name];\n};\n\nvar call$i = functionCall;\nvar isObject$b = isObject$d;\nvar isSymbol$2 = isSymbol$3;\nvar getMethod$3 = getMethod$4;\nvar ordinaryToPrimitive = ordinaryToPrimitive$1;\nvar wellKnownSymbol$i = wellKnownSymbol$j;\n\nvar $TypeError$c = TypeError;\nvar TO_PRIMITIVE = wellKnownSymbol$i('toPrimitive');\n\n// `ToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-toprimitive\nvar toPrimitive$2 = function (input, pref) {\n  if (!isObject$b(input) || isSymbol$2(input)) return input;\n  var exoticToPrim = getMethod$3(input, TO_PRIMITIVE);\n  var result;\n  if (exoticToPrim) {\n    if (pref === undefined) pref = 'default';\n    result = call$i(exoticToPrim, input, pref);\n    if (!isObject$b(result) || isSymbol$2(result)) return result;\n    throw $TypeError$c(\"Can't convert object to primitive value\");\n  }\n  if (pref === undefined) pref = 'number';\n  return ordinaryToPrimitive(input, pref);\n};\n\nvar toPrimitive$1 = toPrimitive$2;\nvar isSymbol$1 = isSymbol$3;\n\n// `ToPropertyKey` abstract operation\n// https://tc39.es/ecma262/#sec-topropertykey\nvar toPropertyKey$4 = function (argument) {\n  var key = toPrimitive$1(argument, 'string');\n  return isSymbol$1(key) ? key : key + '';\n};\n\nvar global$n = global$t;\nvar isObject$a = isObject$d;\n\nvar document$3 = global$n.document;\n// typeof document.createElement is 'object' in old IE\nvar EXISTS$1 = isObject$a(document$3) && isObject$a(document$3.createElement);\n\nvar documentCreateElement$2 = function (it) {\n  return EXISTS$1 ? document$3.createElement(it) : {};\n};\n\nvar DESCRIPTORS$d = descriptors;\nvar fails$n = fails$s;\nvar createElement$1 = documentCreateElement$2;\n\n// Thanks to IE8 for its funny defineProperty\nvar ie8DomDefine = !DESCRIPTORS$d && !fails$n(function () {\n  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n  return Object.defineProperty(createElement$1('div'), 'a', {\n    get: function () { return 7; }\n  }).a != 7;\n});\n\nvar DESCRIPTORS$c = descriptors;\nvar call$h = functionCall;\nvar propertyIsEnumerableModule$1 = objectPropertyIsEnumerable;\nvar createPropertyDescriptor$4 = createPropertyDescriptor$5;\nvar toIndexedObject$5 = toIndexedObject$6;\nvar toPropertyKey$3 = toPropertyKey$4;\nvar hasOwn$a = hasOwnProperty_1;\nvar IE8_DOM_DEFINE$1 = ie8DomDefine;\n\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;\n\n// `Object.getOwnPropertyDescriptor` method\n// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor\nobjectGetOwnPropertyDescriptor.f = DESCRIPTORS$c ? $getOwnPropertyDescriptor$1 : function getOwnPropertyDescriptor(O, P) {\n  O = toIndexedObject$5(O);\n  P = toPropertyKey$3(P);\n  if (IE8_DOM_DEFINE$1) try {\n    return $getOwnPropertyDescriptor$1(O, P);\n  } catch (error) { /* empty */ }\n  if (hasOwn$a(O, P)) return createPropertyDescriptor$4(!call$h(propertyIsEnumerableModule$1.f, O, P), O[P]);\n};\n\nvar objectDefineProperty = {};\n\nvar DESCRIPTORS$b = descriptors;\nvar fails$m = fails$s;\n\n// V8 ~ Chrome 36-\n// https://bugs.chromium.org/p/v8/issues/detail?id=3334\nvar v8PrototypeDefineBug = DESCRIPTORS$b && fails$m(function () {\n  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n  return Object.defineProperty(function () { /* empty */ }, 'prototype', {\n    value: 42,\n    writable: false\n  }).prototype != 42;\n});\n\nvar isObject$9 = isObject$d;\n\nvar $String$2 = String;\nvar $TypeError$b = TypeError;\n\n// `Assert: Type(argument) is Object`\nvar anObject$e = function (argument) {\n  if (isObject$9(argument)) return argument;\n  throw $TypeError$b($String$2(argument) + ' is not an object');\n};\n\nvar DESCRIPTORS$a = descriptors;\nvar IE8_DOM_DEFINE = ie8DomDefine;\nvar V8_PROTOTYPE_DEFINE_BUG$1 = v8PrototypeDefineBug;\nvar anObject$d = anObject$e;\nvar toPropertyKey$2 = toPropertyKey$4;\n\nvar $TypeError$a = TypeError;\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar $defineProperty = Object.defineProperty;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar ENUMERABLE = 'enumerable';\nvar CONFIGURABLE$1 = 'configurable';\nvar WRITABLE = 'writable';\n\n// `Object.defineProperty` method\n// https://tc39.es/ecma262/#sec-object.defineproperty\nobjectDefineProperty.f = DESCRIPTORS$a ? V8_PROTOTYPE_DEFINE_BUG$1 ? function defineProperty(O, P, Attributes) {\n  anObject$d(O);\n  P = toPropertyKey$2(P);\n  anObject$d(Attributes);\n  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {\n    var current = $getOwnPropertyDescriptor(O, P);\n    if (current && current[WRITABLE]) {\n      O[P] = Attributes.value;\n      Attributes = {\n        configurable: CONFIGURABLE$1 in Attributes ? Attributes[CONFIGURABLE$1] : current[CONFIGURABLE$1],\n        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],\n        writable: false\n      };\n    }\n  } return $defineProperty(O, P, Attributes);\n} : $defineProperty : function defineProperty(O, P, Attributes) {\n  anObject$d(O);\n  P = toPropertyKey$2(P);\n  anObject$d(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return $defineProperty(O, P, Attributes);\n  } catch (error) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw $TypeError$a('Accessors not supported');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n\nvar DESCRIPTORS$9 = descriptors;\nvar definePropertyModule$6 = objectDefineProperty;\nvar createPropertyDescriptor$3 = createPropertyDescriptor$5;\n\nvar createNonEnumerableProperty$8 = DESCRIPTORS$9 ? function (object, key, value) {\n  return definePropertyModule$6.f(object, key, createPropertyDescriptor$3(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n\nvar makeBuiltIn$2 = {exports: {}};\n\nvar DESCRIPTORS$8 = descriptors;\nvar hasOwn$9 = hasOwnProperty_1;\n\nvar FunctionPrototype$1 = Function.prototype;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar getDescriptor = DESCRIPTORS$8 && Object.getOwnPropertyDescriptor;\n\nvar EXISTS = hasOwn$9(FunctionPrototype$1, 'name');\n// additional protection from minified / mangled / dropped function names\nvar PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';\nvar CONFIGURABLE = EXISTS && (!DESCRIPTORS$8 || (DESCRIPTORS$8 && getDescriptor(FunctionPrototype$1, 'name').configurable));\n\nvar functionName = {\n  EXISTS: EXISTS,\n  PROPER: PROPER,\n  CONFIGURABLE: CONFIGURABLE\n};\n\nvar uncurryThis$j = functionUncurryThis;\nvar isCallable$h = isCallable$n;\nvar store$1 = sharedStore;\n\nvar functionToString = uncurryThis$j(Function.toString);\n\n// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper\nif (!isCallable$h(store$1.inspectSource)) {\n  store$1.inspectSource = function (it) {\n    return functionToString(it);\n  };\n}\n\nvar inspectSource$4 = store$1.inspectSource;\n\nvar global$m = global$t;\nvar isCallable$g = isCallable$n;\nvar inspectSource$3 = inspectSource$4;\n\nvar WeakMap$1 = global$m.WeakMap;\n\nvar nativeWeakMap = isCallable$g(WeakMap$1) && /native code/.test(inspectSource$3(WeakMap$1));\n\nvar shared$2 = shared$4.exports;\nvar uid$1 = uid$3;\n\nvar keys$1 = shared$2('keys');\n\nvar sharedKey$3 = function (key) {\n  return keys$1[key] || (keys$1[key] = uid$1(key));\n};\n\nvar hiddenKeys$4 = {};\n\nvar NATIVE_WEAK_MAP = nativeWeakMap;\nvar global$l = global$t;\nvar uncurryThis$i = functionUncurryThis;\nvar isObject$8 = isObject$d;\nvar createNonEnumerableProperty$7 = createNonEnumerableProperty$8;\nvar hasOwn$8 = hasOwnProperty_1;\nvar shared$1 = sharedStore;\nvar sharedKey$2 = sharedKey$3;\nvar hiddenKeys$3 = hiddenKeys$4;\n\nvar OBJECT_ALREADY_INITIALIZED = 'Object already initialized';\nvar TypeError$3 = global$l.TypeError;\nvar WeakMap = global$l.WeakMap;\nvar set$2, get$1, has;\n\nvar enforce = function (it) {\n  return has(it) ? get$1(it) : set$2(it, {});\n};\n\nvar getterFor = function (TYPE) {\n  return function (it) {\n    var state;\n    if (!isObject$8(it) || (state = get$1(it)).type !== TYPE) {\n      throw TypeError$3('Incompatible receiver, ' + TYPE + ' required');\n    } return state;\n  };\n};\n\nif (NATIVE_WEAK_MAP || shared$1.state) {\n  var store = shared$1.state || (shared$1.state = new WeakMap());\n  var wmget = uncurryThis$i(store.get);\n  var wmhas = uncurryThis$i(store.has);\n  var wmset = uncurryThis$i(store.set);\n  set$2 = function (it, metadata) {\n    if (wmhas(store, it)) throw new TypeError$3(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    wmset(store, it, metadata);\n    return metadata;\n  };\n  get$1 = function (it) {\n    return wmget(store, it) || {};\n  };\n  has = function (it) {\n    return wmhas(store, it);\n  };\n} else {\n  var STATE = sharedKey$2('state');\n  hiddenKeys$3[STATE] = true;\n  set$2 = function (it, metadata) {\n    if (hasOwn$8(it, STATE)) throw new TypeError$3(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    createNonEnumerableProperty$7(it, STATE, metadata);\n    return metadata;\n  };\n  get$1 = function (it) {\n    return hasOwn$8(it, STATE) ? it[STATE] : {};\n  };\n  has = function (it) {\n    return hasOwn$8(it, STATE);\n  };\n}\n\nvar internalState = {\n  set: set$2,\n  get: get$1,\n  has: has,\n  enforce: enforce,\n  getterFor: getterFor\n};\n\nvar fails$l = fails$s;\nvar isCallable$f = isCallable$n;\nvar hasOwn$7 = hasOwnProperty_1;\nvar DESCRIPTORS$7 = descriptors;\nvar CONFIGURABLE_FUNCTION_NAME$2 = functionName.CONFIGURABLE;\nvar inspectSource$2 = inspectSource$4;\nvar InternalStateModule$5 = internalState;\n\nvar enforceInternalState$2 = InternalStateModule$5.enforce;\nvar getInternalState$5 = InternalStateModule$5.get;\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar defineProperty$6 = Object.defineProperty;\n\nvar CONFIGURABLE_LENGTH = DESCRIPTORS$7 && !fails$l(function () {\n  return defineProperty$6(function () { /* empty */ }, 'length', { value: 8 }).length !== 8;\n});\n\nvar TEMPLATE = String(String).split('String');\n\nvar makeBuiltIn$1 = makeBuiltIn$2.exports = function (value, name, options) {\n  if (String(name).slice(0, 7) === 'Symbol(') {\n    name = '[' + String(name).replace(/^Symbol\\(([^)]*)\\)/, '$1') + ']';\n  }\n  if (options && options.getter) name = 'get ' + name;\n  if (options && options.setter) name = 'set ' + name;\n  if (!hasOwn$7(value, 'name') || (CONFIGURABLE_FUNCTION_NAME$2 && value.name !== name)) {\n    if (DESCRIPTORS$7) defineProperty$6(value, 'name', { value: name, configurable: true });\n    else value.name = name;\n  }\n  if (CONFIGURABLE_LENGTH && options && hasOwn$7(options, 'arity') && value.length !== options.arity) {\n    defineProperty$6(value, 'length', { value: options.arity });\n  }\n  try {\n    if (options && hasOwn$7(options, 'constructor') && options.constructor) {\n      if (DESCRIPTORS$7) defineProperty$6(value, 'prototype', { writable: false });\n    // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable\n    } else if (value.prototype) value.prototype = undefined;\n  } catch (error) { /* empty */ }\n  var state = enforceInternalState$2(value);\n  if (!hasOwn$7(state, 'source')) {\n    state.source = TEMPLATE.join(typeof name == 'string' ? name : '');\n  } return value;\n};\n\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n// eslint-disable-next-line no-extend-native -- required\nFunction.prototype.toString = makeBuiltIn$1(function toString() {\n  return isCallable$f(this) && getInternalState$5(this).source || inspectSource$2(this);\n}, 'toString');\n\nvar isCallable$e = isCallable$n;\nvar definePropertyModule$5 = objectDefineProperty;\nvar makeBuiltIn = makeBuiltIn$2.exports;\nvar defineGlobalProperty$1 = defineGlobalProperty$3;\n\nvar defineBuiltIn$8 = function (O, key, value, options) {\n  if (!options) options = {};\n  var simple = options.enumerable;\n  var name = options.name !== undefined ? options.name : key;\n  if (isCallable$e(value)) makeBuiltIn(value, name, options);\n  if (options.global) {\n    if (simple) O[key] = value;\n    else defineGlobalProperty$1(key, value);\n  } else {\n    try {\n      if (!options.unsafe) delete O[key];\n      else if (O[key]) simple = true;\n    } catch (error) { /* empty */ }\n    if (simple) O[key] = value;\n    else definePropertyModule$5.f(O, key, {\n      value: value,\n      enumerable: false,\n      configurable: !options.nonConfigurable,\n      writable: !options.nonWritable\n    });\n  } return O;\n};\n\nvar objectGetOwnPropertyNames = {};\n\nvar ceil = Math.ceil;\nvar floor$3 = Math.floor;\n\n// `Math.trunc` method\n// https://tc39.es/ecma262/#sec-math.trunc\n// eslint-disable-next-line es-x/no-math-trunc -- safe\nvar mathTrunc = Math.trunc || function trunc(x) {\n  var n = +x;\n  return (n > 0 ? floor$3 : ceil)(n);\n};\n\nvar trunc = mathTrunc;\n\n// `ToIntegerOrInfinity` abstract operation\n// https://tc39.es/ecma262/#sec-tointegerorinfinity\nvar toIntegerOrInfinity$6 = function (argument) {\n  var number = +argument;\n  // eslint-disable-next-line no-self-compare -- NaN check\n  return number !== number || number === 0 ? 0 : trunc(number);\n};\n\nvar toIntegerOrInfinity$5 = toIntegerOrInfinity$6;\n\nvar max$1 = Math.max;\nvar min$2 = Math.min;\n\n// Helper for a popular repeating case of the spec:\n// Let integer be ? ToInteger(index).\n// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).\nvar toAbsoluteIndex$4 = function (index, length) {\n  var integer = toIntegerOrInfinity$5(index);\n  return integer < 0 ? max$1(integer + length, 0) : min$2(integer, length);\n};\n\nvar toIntegerOrInfinity$4 = toIntegerOrInfinity$6;\n\nvar min$1 = Math.min;\n\n// `ToLength` abstract operation\n// https://tc39.es/ecma262/#sec-tolength\nvar toLength$6 = function (argument) {\n  return argument > 0 ? min$1(toIntegerOrInfinity$4(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n};\n\nvar toLength$5 = toLength$6;\n\n// `LengthOfArrayLike` abstract operation\n// https://tc39.es/ecma262/#sec-lengthofarraylike\nvar lengthOfArrayLike$8 = function (obj) {\n  return toLength$5(obj.length);\n};\n\nvar toIndexedObject$4 = toIndexedObject$6;\nvar toAbsoluteIndex$3 = toAbsoluteIndex$4;\nvar lengthOfArrayLike$7 = lengthOfArrayLike$8;\n\n// `Array.prototype.{ indexOf, includes }` methods implementation\nvar createMethod$4 = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIndexedObject$4($this);\n    var length = lengthOfArrayLike$7(O);\n    var index = toAbsoluteIndex$3(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare -- NaN check\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare -- NaN check\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) {\n      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\nvar arrayIncludes = {\n  // `Array.prototype.includes` method\n  // https://tc39.es/ecma262/#sec-array.prototype.includes\n  includes: createMethod$4(true),\n  // `Array.prototype.indexOf` method\n  // https://tc39.es/ecma262/#sec-array.prototype.indexof\n  indexOf: createMethod$4(false)\n};\n\nvar uncurryThis$h = functionUncurryThis;\nvar hasOwn$6 = hasOwnProperty_1;\nvar toIndexedObject$3 = toIndexedObject$6;\nvar indexOf$1 = arrayIncludes.indexOf;\nvar hiddenKeys$2 = hiddenKeys$4;\n\nvar push$2 = uncurryThis$h([].push);\n\nvar objectKeysInternal = function (object, names) {\n  var O = toIndexedObject$3(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) !hasOwn$6(hiddenKeys$2, key) && hasOwn$6(O, key) && push$2(result, key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (hasOwn$6(O, key = names[i++])) {\n    ~indexOf$1(result, key) || push$2(result, key);\n  }\n  return result;\n};\n\n// IE8- don't enum bug keys\nvar enumBugKeys$3 = [\n  'constructor',\n  'hasOwnProperty',\n  'isPrototypeOf',\n  'propertyIsEnumerable',\n  'toLocaleString',\n  'toString',\n  'valueOf'\n];\n\nvar internalObjectKeys$1 = objectKeysInternal;\nvar enumBugKeys$2 = enumBugKeys$3;\n\nvar hiddenKeys$1 = enumBugKeys$2.concat('length', 'prototype');\n\n// `Object.getOwnPropertyNames` method\n// https://tc39.es/ecma262/#sec-object.getownpropertynames\n// eslint-disable-next-line es-x/no-object-getownpropertynames -- safe\nobjectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return internalObjectKeys$1(O, hiddenKeys$1);\n};\n\nvar objectGetOwnPropertySymbols = {};\n\n// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- safe\nobjectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;\n\nvar getBuiltIn$5 = getBuiltIn$8;\nvar uncurryThis$g = functionUncurryThis;\nvar getOwnPropertyNamesModule = objectGetOwnPropertyNames;\nvar getOwnPropertySymbolsModule$1 = objectGetOwnPropertySymbols;\nvar anObject$c = anObject$e;\n\nvar concat$1 = uncurryThis$g([].concat);\n\n// all object keys, includes non-enumerable and symbols\nvar ownKeys$1 = getBuiltIn$5('Reflect', 'ownKeys') || function ownKeys(it) {\n  var keys = getOwnPropertyNamesModule.f(anObject$c(it));\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule$1.f;\n  return getOwnPropertySymbols ? concat$1(keys, getOwnPropertySymbols(it)) : keys;\n};\n\nvar hasOwn$5 = hasOwnProperty_1;\nvar ownKeys = ownKeys$1;\nvar getOwnPropertyDescriptorModule$1 = objectGetOwnPropertyDescriptor;\nvar definePropertyModule$4 = objectDefineProperty;\n\nvar copyConstructorProperties$1 = function (target, source, exceptions) {\n  var keys = ownKeys(source);\n  var defineProperty = definePropertyModule$4.f;\n  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule$1.f;\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    if (!hasOwn$5(target, key) && !(exceptions && hasOwn$5(exceptions, key))) {\n      defineProperty(target, key, getOwnPropertyDescriptor(source, key));\n    }\n  }\n};\n\nvar fails$k = fails$s;\nvar isCallable$d = isCallable$n;\n\nvar replacement = /#|\\.prototype\\./;\n\nvar isForced$2 = function (feature, detection) {\n  var value = data[normalize(feature)];\n  return value == POLYFILL ? true\n    : value == NATIVE ? false\n    : isCallable$d(detection) ? fails$k(detection)\n    : !!detection;\n};\n\nvar normalize = isForced$2.normalize = function (string) {\n  return String(string).replace(replacement, '.').toLowerCase();\n};\n\nvar data = isForced$2.data = {};\nvar NATIVE = isForced$2.NATIVE = 'N';\nvar POLYFILL = isForced$2.POLYFILL = 'P';\n\nvar isForced_1 = isForced$2;\n\nvar global$k = global$t;\nvar getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;\nvar createNonEnumerableProperty$6 = createNonEnumerableProperty$8;\nvar defineBuiltIn$7 = defineBuiltIn$8;\nvar defineGlobalProperty = defineGlobalProperty$3;\nvar copyConstructorProperties = copyConstructorProperties$1;\nvar isForced$1 = isForced_1;\n\n/*\n  options.target         - name of the target object\n  options.global         - target is the global object\n  options.stat           - export as static methods of target\n  options.proto          - export as prototype methods of target\n  options.real           - real prototype method for the `pure` version\n  options.forced         - export even if the native feature is available\n  options.bind           - bind methods to the target, required for the `pure` version\n  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version\n  options.unsafe         - use the simple assignment of property instead of delete + defineProperty\n  options.sham           - add a flag to not completely full polyfills\n  options.enumerable     - export as enumerable property\n  options.dontCallGetSet - prevent calling a getter on target\n  options.name           - the .name of the function if it does not match the key\n*/\nvar _export = function (options, source) {\n  var TARGET = options.target;\n  var GLOBAL = options.global;\n  var STATIC = options.stat;\n  var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n  if (GLOBAL) {\n    target = global$k;\n  } else if (STATIC) {\n    target = global$k[TARGET] || defineGlobalProperty(TARGET, {});\n  } else {\n    target = (global$k[TARGET] || {}).prototype;\n  }\n  if (target) for (key in source) {\n    sourceProperty = source[key];\n    if (options.dontCallGetSet) {\n      descriptor = getOwnPropertyDescriptor$1(target, key);\n      targetProperty = descriptor && descriptor.value;\n    } else targetProperty = target[key];\n    FORCED = isForced$1(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);\n    // contained in target\n    if (!FORCED && targetProperty !== undefined) {\n      if (typeof sourceProperty == typeof targetProperty) continue;\n      copyConstructorProperties(sourceProperty, targetProperty);\n    }\n    // add a flag to not completely full polyfills\n    if (options.sham || (targetProperty && targetProperty.sham)) {\n      createNonEnumerableProperty$6(sourceProperty, 'sham', true);\n    }\n    defineBuiltIn$7(target, key, sourceProperty, options);\n  }\n};\n\nvar classof$a = classofRaw$1;\nvar global$j = global$t;\n\nvar engineIsNode = classof$a(global$j.process) == 'process';\n\nvar isCallable$c = isCallable$n;\n\nvar $String$1 = String;\nvar $TypeError$9 = TypeError;\n\nvar aPossiblePrototype$1 = function (argument) {\n  if (typeof argument == 'object' || isCallable$c(argument)) return argument;\n  throw $TypeError$9(\"Can't set \" + $String$1(argument) + ' as a prototype');\n};\n\n/* eslint-disable no-proto -- safe */\n\nvar uncurryThis$f = functionUncurryThis;\nvar anObject$b = anObject$e;\nvar aPossiblePrototype = aPossiblePrototype$1;\n\n// `Object.setPrototypeOf` method\n// https://tc39.es/ecma262/#sec-object.setprototypeof\n// Works with __proto__ only. Old v8 can't work with null proto objects.\n// eslint-disable-next-line es-x/no-object-setprototypeof -- safe\nvar objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {\n  var CORRECT_SETTER = false;\n  var test = {};\n  var setter;\n  try {\n    // eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\n    setter = uncurryThis$f(Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set);\n    setter(test, []);\n    CORRECT_SETTER = test instanceof Array;\n  } catch (error) { /* empty */ }\n  return function setPrototypeOf(O, proto) {\n    anObject$b(O);\n    aPossiblePrototype(proto);\n    if (CORRECT_SETTER) setter(O, proto);\n    else O.__proto__ = proto;\n    return O;\n  };\n}() : undefined);\n\nvar defineProperty$5 = objectDefineProperty.f;\nvar hasOwn$4 = hasOwnProperty_1;\nvar wellKnownSymbol$h = wellKnownSymbol$j;\n\nvar TO_STRING_TAG$4 = wellKnownSymbol$h('toStringTag');\n\nvar setToStringTag$4 = function (target, TAG, STATIC) {\n  if (target && !STATIC) target = target.prototype;\n  if (target && !hasOwn$4(target, TO_STRING_TAG$4)) {\n    defineProperty$5(target, TO_STRING_TAG$4, { configurable: true, value: TAG });\n  }\n};\n\nvar getBuiltIn$4 = getBuiltIn$8;\nvar definePropertyModule$3 = objectDefineProperty;\nvar wellKnownSymbol$g = wellKnownSymbol$j;\nvar DESCRIPTORS$6 = descriptors;\n\nvar SPECIES$4 = wellKnownSymbol$g('species');\n\nvar setSpecies$2 = function (CONSTRUCTOR_NAME) {\n  var Constructor = getBuiltIn$4(CONSTRUCTOR_NAME);\n  var defineProperty = definePropertyModule$3.f;\n\n  if (DESCRIPTORS$6 && Constructor && !Constructor[SPECIES$4]) {\n    defineProperty(Constructor, SPECIES$4, {\n      configurable: true,\n      get: function () { return this; }\n    });\n  }\n};\n\nvar isPrototypeOf$3 = objectIsPrototypeOf;\n\nvar $TypeError$8 = TypeError;\n\nvar anInstance$3 = function (it, Prototype) {\n  if (isPrototypeOf$3(Prototype, it)) return it;\n  throw $TypeError$8('Incorrect invocation');\n};\n\nvar wellKnownSymbol$f = wellKnownSymbol$j;\n\nvar TO_STRING_TAG$3 = wellKnownSymbol$f('toStringTag');\nvar test = {};\n\ntest[TO_STRING_TAG$3] = 'z';\n\nvar toStringTagSupport = String(test) === '[object z]';\n\nvar TO_STRING_TAG_SUPPORT = toStringTagSupport;\nvar isCallable$b = isCallable$n;\nvar classofRaw = classofRaw$1;\nvar wellKnownSymbol$e = wellKnownSymbol$j;\n\nvar TO_STRING_TAG$2 = wellKnownSymbol$e('toStringTag');\nvar $Object$1 = Object;\n\n// ES3 wrong here\nvar CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function (it, key) {\n  try {\n    return it[key];\n  } catch (error) { /* empty */ }\n};\n\n// getting tag from ES6+ `Object.prototype.toString`\nvar classof$9 = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {\n  var O, tag, result;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (tag = tryGet(O = $Object$1(it), TO_STRING_TAG$2)) == 'string' ? tag\n    // builtinTag case\n    : CORRECT_ARGUMENTS ? classofRaw(O)\n    // ES3 arguments fallback\n    : (result = classofRaw(O)) == 'Object' && isCallable$b(O.callee) ? 'Arguments' : result;\n};\n\nvar uncurryThis$e = functionUncurryThis;\nvar fails$j = fails$s;\nvar isCallable$a = isCallable$n;\nvar classof$8 = classof$9;\nvar getBuiltIn$3 = getBuiltIn$8;\nvar inspectSource$1 = inspectSource$4;\n\nvar noop = function () { /* empty */ };\nvar empty = [];\nvar construct = getBuiltIn$3('Reflect', 'construct');\nvar constructorRegExp = /^\\s*(?:class|function)\\b/;\nvar exec$2 = uncurryThis$e(constructorRegExp.exec);\nvar INCORRECT_TO_STRING = !constructorRegExp.exec(noop);\n\nvar isConstructorModern = function isConstructor(argument) {\n  if (!isCallable$a(argument)) return false;\n  try {\n    construct(noop, empty, argument);\n    return true;\n  } catch (error) {\n    return false;\n  }\n};\n\nvar isConstructorLegacy = function isConstructor(argument) {\n  if (!isCallable$a(argument)) return false;\n  switch (classof$8(argument)) {\n    case 'AsyncFunction':\n    case 'GeneratorFunction':\n    case 'AsyncGeneratorFunction': return false;\n  }\n  try {\n    // we can't check .prototype since constructors produced by .bind haven't it\n    // `Function#toString` throws on some built-it function in some legacy engines\n    // (for example, `DOMQuad` and similar in FF41-)\n    return INCORRECT_TO_STRING || !!exec$2(constructorRegExp, inspectSource$1(argument));\n  } catch (error) {\n    return true;\n  }\n};\n\nisConstructorLegacy.sham = true;\n\n// `IsConstructor` abstract operation\n// https://tc39.es/ecma262/#sec-isconstructor\nvar isConstructor$2 = !construct || fails$j(function () {\n  var called;\n  return isConstructorModern(isConstructorModern.call)\n    || !isConstructorModern(Object)\n    || !isConstructorModern(function () { called = true; })\n    || called;\n}) ? isConstructorLegacy : isConstructorModern;\n\nvar isConstructor$1 = isConstructor$2;\nvar tryToString$3 = tryToString$5;\n\nvar $TypeError$7 = TypeError;\n\n// `Assert: IsConstructor(argument) is true`\nvar aConstructor$2 = function (argument) {\n  if (isConstructor$1(argument)) return argument;\n  throw $TypeError$7(tryToString$3(argument) + ' is not a constructor');\n};\n\nvar anObject$a = anObject$e;\nvar aConstructor$1 = aConstructor$2;\nvar wellKnownSymbol$d = wellKnownSymbol$j;\n\nvar SPECIES$3 = wellKnownSymbol$d('species');\n\n// `SpeciesConstructor` abstract operation\n// https://tc39.es/ecma262/#sec-speciesconstructor\nvar speciesConstructor$3 = function (O, defaultConstructor) {\n  var C = anObject$a(O).constructor;\n  var S;\n  return C === undefined || (S = anObject$a(C)[SPECIES$3]) == undefined ? defaultConstructor : aConstructor$1(S);\n};\n\nvar NATIVE_BIND$1 = functionBindNative;\n\nvar FunctionPrototype = Function.prototype;\nvar apply$3 = FunctionPrototype.apply;\nvar call$g = FunctionPrototype.call;\n\n// eslint-disable-next-line es-x/no-reflect -- safe\nvar functionApply = typeof Reflect == 'object' && Reflect.apply || (NATIVE_BIND$1 ? call$g.bind(apply$3) : function () {\n  return call$g.apply(apply$3, arguments);\n});\n\nvar uncurryThis$d = functionUncurryThis;\nvar aCallable$7 = aCallable$9;\nvar NATIVE_BIND = functionBindNative;\n\nvar bind$6 = uncurryThis$d(uncurryThis$d.bind);\n\n// optional / simple context binding\nvar functionBindContext = function (fn, that) {\n  aCallable$7(fn);\n  return that === undefined ? fn : NATIVE_BIND ? bind$6(fn, that) : function (/* ...args */) {\n    return fn.apply(that, arguments);\n  };\n};\n\nvar getBuiltIn$2 = getBuiltIn$8;\n\nvar html$2 = getBuiltIn$2('document', 'documentElement');\n\nvar uncurryThis$c = functionUncurryThis;\n\nvar arraySlice$5 = uncurryThis$c([].slice);\n\nvar $TypeError$6 = TypeError;\n\nvar validateArgumentsLength$1 = function (passed, required) {\n  if (passed < required) throw $TypeError$6('Not enough arguments');\n  return passed;\n};\n\nvar userAgent$4 = engineUserAgent;\n\nvar engineIsIos = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent$4);\n\nvar global$i = global$t;\nvar apply$2 = functionApply;\nvar bind$5 = functionBindContext;\nvar isCallable$9 = isCallable$n;\nvar hasOwn$3 = hasOwnProperty_1;\nvar fails$i = fails$s;\nvar html$1 = html$2;\nvar arraySlice$4 = arraySlice$5;\nvar createElement = documentCreateElement$2;\nvar validateArgumentsLength = validateArgumentsLength$1;\nvar IS_IOS$1 = engineIsIos;\nvar IS_NODE$3 = engineIsNode;\n\nvar set$1 = global$i.setImmediate;\nvar clear = global$i.clearImmediate;\nvar process$2 = global$i.process;\nvar Dispatch = global$i.Dispatch;\nvar Function$1 = global$i.Function;\nvar MessageChannel = global$i.MessageChannel;\nvar String$1 = global$i.String;\nvar counter = 0;\nvar queue$1 = {};\nvar ONREADYSTATECHANGE = 'onreadystatechange';\nvar location, defer, channel, port;\n\ntry {\n  // Deno throws a ReferenceError on `location` access without `--location` flag\n  location = global$i.location;\n} catch (error) { /* empty */ }\n\nvar run = function (id) {\n  if (hasOwn$3(queue$1, id)) {\n    var fn = queue$1[id];\n    delete queue$1[id];\n    fn();\n  }\n};\n\nvar runner = function (id) {\n  return function () {\n    run(id);\n  };\n};\n\nvar listener = function (event) {\n  run(event.data);\n};\n\nvar post = function (id) {\n  // old engines have not location.origin\n  global$i.postMessage(String$1(id), location.protocol + '//' + location.host);\n};\n\n// Node.js 0.9+ & IE10+ has setImmediate, otherwise:\nif (!set$1 || !clear) {\n  set$1 = function setImmediate(handler) {\n    validateArgumentsLength(arguments.length, 1);\n    var fn = isCallable$9(handler) ? handler : Function$1(handler);\n    var args = arraySlice$4(arguments, 1);\n    queue$1[++counter] = function () {\n      apply$2(fn, undefined, args);\n    };\n    defer(counter);\n    return counter;\n  };\n  clear = function clearImmediate(id) {\n    delete queue$1[id];\n  };\n  // Node.js 0.8-\n  if (IS_NODE$3) {\n    defer = function (id) {\n      process$2.nextTick(runner(id));\n    };\n  // Sphere (JS game engine) Dispatch API\n  } else if (Dispatch && Dispatch.now) {\n    defer = function (id) {\n      Dispatch.now(runner(id));\n    };\n  // Browsers with MessageChannel, includes WebWorkers\n  // except iOS - https://github.com/zloirock/core-js/issues/624\n  } else if (MessageChannel && !IS_IOS$1) {\n    channel = new MessageChannel();\n    port = channel.port2;\n    channel.port1.onmessage = listener;\n    defer = bind$5(port.postMessage, port);\n  // Browsers with postMessage, skip WebWorkers\n  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'\n  } else if (\n    global$i.addEventListener &&\n    isCallable$9(global$i.postMessage) &&\n    !global$i.importScripts &&\n    location && location.protocol !== 'file:' &&\n    !fails$i(post)\n  ) {\n    defer = post;\n    global$i.addEventListener('message', listener, false);\n  // IE8-\n  } else if (ONREADYSTATECHANGE in createElement('script')) {\n    defer = function (id) {\n      html$1.appendChild(createElement('script'))[ONREADYSTATECHANGE] = function () {\n        html$1.removeChild(this);\n        run(id);\n      };\n    };\n  // Rest old browsers\n  } else {\n    defer = function (id) {\n      setTimeout(runner(id), 0);\n    };\n  }\n}\n\nvar task$1 = {\n  set: set$1,\n  clear: clear\n};\n\nvar userAgent$3 = engineUserAgent;\nvar global$h = global$t;\n\nvar engineIsIosPebble = /ipad|iphone|ipod/i.test(userAgent$3) && global$h.Pebble !== undefined;\n\nvar userAgent$2 = engineUserAgent;\n\nvar engineIsWebosWebkit = /web0s(?!.*chrome)/i.test(userAgent$2);\n\nvar global$g = global$t;\nvar bind$4 = functionBindContext;\nvar getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;\nvar macrotask = task$1.set;\nvar IS_IOS = engineIsIos;\nvar IS_IOS_PEBBLE = engineIsIosPebble;\nvar IS_WEBOS_WEBKIT = engineIsWebosWebkit;\nvar IS_NODE$2 = engineIsNode;\n\nvar MutationObserver = global$g.MutationObserver || global$g.WebKitMutationObserver;\nvar document$2 = global$g.document;\nvar process$1 = global$g.process;\nvar Promise$1 = global$g.Promise;\n// Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`\nvar queueMicrotaskDescriptor = getOwnPropertyDescriptor(global$g, 'queueMicrotask');\nvar queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;\n\nvar flush, head, last, notify$1, toggle, node, promise, then;\n\n// modern engines have queueMicrotask method\nif (!queueMicrotask) {\n  flush = function () {\n    var parent, fn;\n    if (IS_NODE$2 && (parent = process$1.domain)) parent.exit();\n    while (head) {\n      fn = head.fn;\n      head = head.next;\n      try {\n        fn();\n      } catch (error) {\n        if (head) notify$1();\n        else last = undefined;\n        throw error;\n      }\n    } last = undefined;\n    if (parent) parent.enter();\n  };\n\n  // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339\n  // also except WebOS Webkit https://github.com/zloirock/core-js/issues/898\n  if (!IS_IOS && !IS_NODE$2 && !IS_WEBOS_WEBKIT && MutationObserver && document$2) {\n    toggle = true;\n    node = document$2.createTextNode('');\n    new MutationObserver(flush).observe(node, { characterData: true });\n    notify$1 = function () {\n      node.data = toggle = !toggle;\n    };\n  // environments with maybe non-completely correct, but existent Promise\n  } else if (!IS_IOS_PEBBLE && Promise$1 && Promise$1.resolve) {\n    // Promise.resolve without an argument throws an error in LG WebOS 2\n    promise = Promise$1.resolve(undefined);\n    // workaround of WebKit ~ iOS Safari 10.1 bug\n    promise.constructor = Promise$1;\n    then = bind$4(promise.then, promise);\n    notify$1 = function () {\n      then(flush);\n    };\n  // Node.js without promises\n  } else if (IS_NODE$2) {\n    notify$1 = function () {\n      process$1.nextTick(flush);\n    };\n  // for other environments - macrotask based on:\n  // - setImmediate\n  // - MessageChannel\n  // - window.postMessage\n  // - onreadystatechange\n  // - setTimeout\n  } else {\n    // strange IE + webpack dev server bug - use .bind(global)\n    macrotask = bind$4(macrotask, global$g);\n    notify$1 = function () {\n      macrotask(flush);\n    };\n  }\n}\n\nvar microtask$1 = queueMicrotask || function (fn) {\n  var task = { fn: fn, next: undefined };\n  if (last) last.next = task;\n  if (!head) {\n    head = task;\n    notify$1();\n  } last = task;\n};\n\nvar global$f = global$t;\n\nvar hostReportErrors$1 = function (a, b) {\n  var console = global$f.console;\n  if (console && console.error) {\n    arguments.length == 1 ? console.error(a) : console.error(a, b);\n  }\n};\n\nvar perform$3 = function (exec) {\n  try {\n    return { error: false, value: exec() };\n  } catch (error) {\n    return { error: true, value: error };\n  }\n};\n\nvar Queue$1 = function () {\n  this.head = null;\n  this.tail = null;\n};\n\nQueue$1.prototype = {\n  add: function (item) {\n    var entry = { item: item, next: null };\n    if (this.head) this.tail.next = entry;\n    else this.head = entry;\n    this.tail = entry;\n  },\n  get: function () {\n    var entry = this.head;\n    if (entry) {\n      this.head = entry.next;\n      if (this.tail === entry) this.tail = null;\n      return entry.item;\n    }\n  }\n};\n\nvar queue = Queue$1;\n\nvar global$e = global$t;\n\nvar promiseNativeConstructor = global$e.Promise;\n\nvar engineIsBrowser = typeof window == 'object' && typeof Deno != 'object';\n\nvar global$d = global$t;\nvar NativePromiseConstructor$3 = promiseNativeConstructor;\nvar isCallable$8 = isCallable$n;\nvar isForced = isForced_1;\nvar inspectSource = inspectSource$4;\nvar wellKnownSymbol$c = wellKnownSymbol$j;\nvar IS_BROWSER = engineIsBrowser;\nvar V8_VERSION = engineV8Version;\n\nNativePromiseConstructor$3 && NativePromiseConstructor$3.prototype;\nvar SPECIES$2 = wellKnownSymbol$c('species');\nvar SUBCLASSING = false;\nvar NATIVE_PROMISE_REJECTION_EVENT$1 = isCallable$8(global$d.PromiseRejectionEvent);\n\nvar FORCED_PROMISE_CONSTRUCTOR$5 = isForced('Promise', function () {\n  var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(NativePromiseConstructor$3);\n  var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(NativePromiseConstructor$3);\n  // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=830565\n  // We can't detect it synchronously, so just check versions\n  if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66) return true;\n  // We can't use @@species feature detection in V8 since it causes\n  // deoptimization and performance degradation\n  // https://github.com/zloirock/core-js/issues/679\n  if (V8_VERSION >= 51 && /native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) return false;\n  // Detect correctness of subclassing with @@species support\n  var promise = new NativePromiseConstructor$3(function (resolve) { resolve(1); });\n  var FakePromise = function (exec) {\n    exec(function () { /* empty */ }, function () { /* empty */ });\n  };\n  var constructor = promise.constructor = {};\n  constructor[SPECIES$2] = FakePromise;\n  SUBCLASSING = promise.then(function () { /* empty */ }) instanceof FakePromise;\n  if (!SUBCLASSING) return true;\n  // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test\n  return !GLOBAL_CORE_JS_PROMISE && IS_BROWSER && !NATIVE_PROMISE_REJECTION_EVENT$1;\n});\n\nvar promiseConstructorDetection = {\n  CONSTRUCTOR: FORCED_PROMISE_CONSTRUCTOR$5,\n  REJECTION_EVENT: NATIVE_PROMISE_REJECTION_EVENT$1,\n  SUBCLASSING: SUBCLASSING\n};\n\nvar newPromiseCapability$2 = {};\n\nvar aCallable$6 = aCallable$9;\n\nvar PromiseCapability = function (C) {\n  var resolve, reject;\n  this.promise = new C(function ($$resolve, $$reject) {\n    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');\n    resolve = $$resolve;\n    reject = $$reject;\n  });\n  this.resolve = aCallable$6(resolve);\n  this.reject = aCallable$6(reject);\n};\n\n// `NewPromiseCapability` abstract operation\n// https://tc39.es/ecma262/#sec-newpromisecapability\nnewPromiseCapability$2.f = function (C) {\n  return new PromiseCapability(C);\n};\n\nvar $$e = _export;\nvar IS_NODE$1 = engineIsNode;\nvar global$c = global$t;\nvar call$f = functionCall;\nvar defineBuiltIn$6 = defineBuiltIn$8;\nvar setPrototypeOf$5 = objectSetPrototypeOf;\nvar setToStringTag$3 = setToStringTag$4;\nvar setSpecies$1 = setSpecies$2;\nvar aCallable$5 = aCallable$9;\nvar isCallable$7 = isCallable$n;\nvar isObject$7 = isObject$d;\nvar anInstance$2 = anInstance$3;\nvar speciesConstructor$2 = speciesConstructor$3;\nvar task = task$1.set;\nvar microtask = microtask$1;\nvar hostReportErrors = hostReportErrors$1;\nvar perform$2 = perform$3;\nvar Queue = queue;\nvar InternalStateModule$4 = internalState;\nvar NativePromiseConstructor$2 = promiseNativeConstructor;\nvar PromiseConstructorDetection = promiseConstructorDetection;\nvar newPromiseCapabilityModule$3 = newPromiseCapability$2;\n\nvar PROMISE = 'Promise';\nvar FORCED_PROMISE_CONSTRUCTOR$4 = PromiseConstructorDetection.CONSTRUCTOR;\nvar NATIVE_PROMISE_REJECTION_EVENT = PromiseConstructorDetection.REJECTION_EVENT;\nvar NATIVE_PROMISE_SUBCLASSING = PromiseConstructorDetection.SUBCLASSING;\nvar getInternalPromiseState = InternalStateModule$4.getterFor(PROMISE);\nvar setInternalState$3 = InternalStateModule$4.set;\nvar NativePromisePrototype$1 = NativePromiseConstructor$2 && NativePromiseConstructor$2.prototype;\nvar PromiseConstructor = NativePromiseConstructor$2;\nvar PromisePrototype = NativePromisePrototype$1;\nvar TypeError$2 = global$c.TypeError;\nvar document$1 = global$c.document;\nvar process = global$c.process;\nvar newPromiseCapability$1 = newPromiseCapabilityModule$3.f;\nvar newGenericPromiseCapability = newPromiseCapability$1;\n\nvar DISPATCH_EVENT = !!(document$1 && document$1.createEvent && global$c.dispatchEvent);\nvar UNHANDLED_REJECTION = 'unhandledrejection';\nvar REJECTION_HANDLED = 'rejectionhandled';\nvar PENDING = 0;\nvar FULFILLED = 1;\nvar REJECTED = 2;\nvar HANDLED = 1;\nvar UNHANDLED = 2;\n\nvar Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;\n\n// helpers\nvar isThenable = function (it) {\n  var then;\n  return isObject$7(it) && isCallable$7(then = it.then) ? then : false;\n};\n\nvar callReaction = function (reaction, state) {\n  var value = state.value;\n  var ok = state.state == FULFILLED;\n  var handler = ok ? reaction.ok : reaction.fail;\n  var resolve = reaction.resolve;\n  var reject = reaction.reject;\n  var domain = reaction.domain;\n  var result, then, exited;\n  try {\n    if (handler) {\n      if (!ok) {\n        if (state.rejection === UNHANDLED) onHandleUnhandled(state);\n        state.rejection = HANDLED;\n      }\n      if (handler === true) result = value;\n      else {\n        if (domain) domain.enter();\n        result = handler(value); // can throw\n        if (domain) {\n          domain.exit();\n          exited = true;\n        }\n      }\n      if (result === reaction.promise) {\n        reject(TypeError$2('Promise-chain cycle'));\n      } else if (then = isThenable(result)) {\n        call$f(then, result, resolve, reject);\n      } else resolve(result);\n    } else reject(value);\n  } catch (error) {\n    if (domain && !exited) domain.exit();\n    reject(error);\n  }\n};\n\nvar notify = function (state, isReject) {\n  if (state.notified) return;\n  state.notified = true;\n  microtask(function () {\n    var reactions = state.reactions;\n    var reaction;\n    while (reaction = reactions.get()) {\n      callReaction(reaction, state);\n    }\n    state.notified = false;\n    if (isReject && !state.rejection) onUnhandled(state);\n  });\n};\n\nvar dispatchEvent = function (name, promise, reason) {\n  var event, handler;\n  if (DISPATCH_EVENT) {\n    event = document$1.createEvent('Event');\n    event.promise = promise;\n    event.reason = reason;\n    event.initEvent(name, false, true);\n    global$c.dispatchEvent(event);\n  } else event = { promise: promise, reason: reason };\n  if (!NATIVE_PROMISE_REJECTION_EVENT && (handler = global$c['on' + name])) handler(event);\n  else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);\n};\n\nvar onUnhandled = function (state) {\n  call$f(task, global$c, function () {\n    var promise = state.facade;\n    var value = state.value;\n    var IS_UNHANDLED = isUnhandled(state);\n    var result;\n    if (IS_UNHANDLED) {\n      result = perform$2(function () {\n        if (IS_NODE$1) {\n          process.emit('unhandledRejection', value, promise);\n        } else dispatchEvent(UNHANDLED_REJECTION, promise, value);\n      });\n      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should\n      state.rejection = IS_NODE$1 || isUnhandled(state) ? UNHANDLED : HANDLED;\n      if (result.error) throw result.value;\n    }\n  });\n};\n\nvar isUnhandled = function (state) {\n  return state.rejection !== HANDLED && !state.parent;\n};\n\nvar onHandleUnhandled = function (state) {\n  call$f(task, global$c, function () {\n    var promise = state.facade;\n    if (IS_NODE$1) {\n      process.emit('rejectionHandled', promise);\n    } else dispatchEvent(REJECTION_HANDLED, promise, state.value);\n  });\n};\n\nvar bind$3 = function (fn, state, unwrap) {\n  return function (value) {\n    fn(state, value, unwrap);\n  };\n};\n\nvar internalReject = function (state, value, unwrap) {\n  if (state.done) return;\n  state.done = true;\n  if (unwrap) state = unwrap;\n  state.value = value;\n  state.state = REJECTED;\n  notify(state, true);\n};\n\nvar internalResolve = function (state, value, unwrap) {\n  if (state.done) return;\n  state.done = true;\n  if (unwrap) state = unwrap;\n  try {\n    if (state.facade === value) throw TypeError$2(\"Promise can't be resolved itself\");\n    var then = isThenable(value);\n    if (then) {\n      microtask(function () {\n        var wrapper = { done: false };\n        try {\n          call$f(then, value,\n            bind$3(internalResolve, wrapper, state),\n            bind$3(internalReject, wrapper, state)\n          );\n        } catch (error) {\n          internalReject(wrapper, error, state);\n        }\n      });\n    } else {\n      state.value = value;\n      state.state = FULFILLED;\n      notify(state, false);\n    }\n  } catch (error) {\n    internalReject({ done: false }, error, state);\n  }\n};\n\n// constructor polyfill\nif (FORCED_PROMISE_CONSTRUCTOR$4) {\n  // 25.4.3.1 Promise(executor)\n  PromiseConstructor = function Promise(executor) {\n    anInstance$2(this, PromisePrototype);\n    aCallable$5(executor);\n    call$f(Internal, this);\n    var state = getInternalPromiseState(this);\n    try {\n      executor(bind$3(internalResolve, state), bind$3(internalReject, state));\n    } catch (error) {\n      internalReject(state, error);\n    }\n  };\n\n  PromisePrototype = PromiseConstructor.prototype;\n\n  // eslint-disable-next-line no-unused-vars -- required for `.length`\n  Internal = function Promise(executor) {\n    setInternalState$3(this, {\n      type: PROMISE,\n      done: false,\n      notified: false,\n      parent: false,\n      reactions: new Queue(),\n      rejection: false,\n      state: PENDING,\n      value: undefined\n    });\n  };\n\n  // `Promise.prototype.then` method\n  // https://tc39.es/ecma262/#sec-promise.prototype.then\n  Internal.prototype = defineBuiltIn$6(PromisePrototype, 'then', function then(onFulfilled, onRejected) {\n    var state = getInternalPromiseState(this);\n    var reaction = newPromiseCapability$1(speciesConstructor$2(this, PromiseConstructor));\n    state.parent = true;\n    reaction.ok = isCallable$7(onFulfilled) ? onFulfilled : true;\n    reaction.fail = isCallable$7(onRejected) && onRejected;\n    reaction.domain = IS_NODE$1 ? process.domain : undefined;\n    if (state.state == PENDING) state.reactions.add(reaction);\n    else microtask(function () {\n      callReaction(reaction, state);\n    });\n    return reaction.promise;\n  });\n\n  OwnPromiseCapability = function () {\n    var promise = new Internal();\n    var state = getInternalPromiseState(promise);\n    this.promise = promise;\n    this.resolve = bind$3(internalResolve, state);\n    this.reject = bind$3(internalReject, state);\n  };\n\n  newPromiseCapabilityModule$3.f = newPromiseCapability$1 = function (C) {\n    return C === PromiseConstructor || C === PromiseWrapper\n      ? new OwnPromiseCapability(C)\n      : newGenericPromiseCapability(C);\n  };\n\n  if (isCallable$7(NativePromiseConstructor$2) && NativePromisePrototype$1 !== Object.prototype) {\n    nativeThen = NativePromisePrototype$1.then;\n\n    if (!NATIVE_PROMISE_SUBCLASSING) {\n      // make `Promise#then` return a polyfilled `Promise` for native promise-based APIs\n      defineBuiltIn$6(NativePromisePrototype$1, 'then', function then(onFulfilled, onRejected) {\n        var that = this;\n        return new PromiseConstructor(function (resolve, reject) {\n          call$f(nativeThen, that, resolve, reject);\n        }).then(onFulfilled, onRejected);\n      // https://github.com/zloirock/core-js/issues/640\n      }, { unsafe: true });\n    }\n\n    // make `.constructor === Promise` work for native promise-based APIs\n    try {\n      delete NativePromisePrototype$1.constructor;\n    } catch (error) { /* empty */ }\n\n    // make `instanceof Promise` work for native promise-based APIs\n    if (setPrototypeOf$5) {\n      setPrototypeOf$5(NativePromisePrototype$1, PromisePrototype);\n    }\n  }\n}\n\n$$e({ global: true, constructor: true, wrap: true, forced: FORCED_PROMISE_CONSTRUCTOR$4 }, {\n  Promise: PromiseConstructor\n});\n\nsetToStringTag$3(PromiseConstructor, PROMISE, false);\nsetSpecies$1(PROMISE);\n\nvar iterators = {};\n\nvar wellKnownSymbol$b = wellKnownSymbol$j;\nvar Iterators$4 = iterators;\n\nvar ITERATOR$5 = wellKnownSymbol$b('iterator');\nvar ArrayPrototype$1 = Array.prototype;\n\n// check on default Array iterator\nvar isArrayIteratorMethod$2 = function (it) {\n  return it !== undefined && (Iterators$4.Array === it || ArrayPrototype$1[ITERATOR$5] === it);\n};\n\nvar classof$7 = classof$9;\nvar getMethod$2 = getMethod$4;\nvar Iterators$3 = iterators;\nvar wellKnownSymbol$a = wellKnownSymbol$j;\n\nvar ITERATOR$4 = wellKnownSymbol$a('iterator');\n\nvar getIteratorMethod$3 = function (it) {\n  if (it != undefined) return getMethod$2(it, ITERATOR$4)\n    || getMethod$2(it, '@@iterator')\n    || Iterators$3[classof$7(it)];\n};\n\nvar call$e = functionCall;\nvar aCallable$4 = aCallable$9;\nvar anObject$9 = anObject$e;\nvar tryToString$2 = tryToString$5;\nvar getIteratorMethod$2 = getIteratorMethod$3;\n\nvar $TypeError$5 = TypeError;\n\nvar getIterator$2 = function (argument, usingIterator) {\n  var iteratorMethod = arguments.length < 2 ? getIteratorMethod$2(argument) : usingIterator;\n  if (aCallable$4(iteratorMethod)) return anObject$9(call$e(iteratorMethod, argument));\n  throw $TypeError$5(tryToString$2(argument) + ' is not iterable');\n};\n\nvar call$d = functionCall;\nvar anObject$8 = anObject$e;\nvar getMethod$1 = getMethod$4;\n\nvar iteratorClose$1 = function (iterator, kind, value) {\n  var innerResult, innerError;\n  anObject$8(iterator);\n  try {\n    innerResult = getMethod$1(iterator, 'return');\n    if (!innerResult) {\n      if (kind === 'throw') throw value;\n      return value;\n    }\n    innerResult = call$d(innerResult, iterator);\n  } catch (error) {\n    innerError = true;\n    innerResult = error;\n  }\n  if (kind === 'throw') throw value;\n  if (innerError) throw innerResult;\n  anObject$8(innerResult);\n  return value;\n};\n\nvar bind$2 = functionBindContext;\nvar call$c = functionCall;\nvar anObject$7 = anObject$e;\nvar tryToString$1 = tryToString$5;\nvar isArrayIteratorMethod$1 = isArrayIteratorMethod$2;\nvar lengthOfArrayLike$6 = lengthOfArrayLike$8;\nvar isPrototypeOf$2 = objectIsPrototypeOf;\nvar getIterator$1 = getIterator$2;\nvar getIteratorMethod$1 = getIteratorMethod$3;\nvar iteratorClose = iteratorClose$1;\n\nvar $TypeError$4 = TypeError;\n\nvar Result = function (stopped, result) {\n  this.stopped = stopped;\n  this.result = result;\n};\n\nvar ResultPrototype = Result.prototype;\n\nvar iterate$2 = function (iterable, unboundFunction, options) {\n  var that = options && options.that;\n  var AS_ENTRIES = !!(options && options.AS_ENTRIES);\n  var IS_ITERATOR = !!(options && options.IS_ITERATOR);\n  var INTERRUPTED = !!(options && options.INTERRUPTED);\n  var fn = bind$2(unboundFunction, that);\n  var iterator, iterFn, index, length, result, next, step;\n\n  var stop = function (condition) {\n    if (iterator) iteratorClose(iterator, 'normal', condition);\n    return new Result(true, condition);\n  };\n\n  var callFn = function (value) {\n    if (AS_ENTRIES) {\n      anObject$7(value);\n      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);\n    } return INTERRUPTED ? fn(value, stop) : fn(value);\n  };\n\n  if (IS_ITERATOR) {\n    iterator = iterable;\n  } else {\n    iterFn = getIteratorMethod$1(iterable);\n    if (!iterFn) throw $TypeError$4(tryToString$1(iterable) + ' is not iterable');\n    // optimisation for array iterators\n    if (isArrayIteratorMethod$1(iterFn)) {\n      for (index = 0, length = lengthOfArrayLike$6(iterable); length > index; index++) {\n        result = callFn(iterable[index]);\n        if (result && isPrototypeOf$2(ResultPrototype, result)) return result;\n      } return new Result(false);\n    }\n    iterator = getIterator$1(iterable, iterFn);\n  }\n\n  next = iterator.next;\n  while (!(step = call$c(next, iterator)).done) {\n    try {\n      result = callFn(step.value);\n    } catch (error) {\n      iteratorClose(iterator, 'throw', error);\n    }\n    if (typeof result == 'object' && result && isPrototypeOf$2(ResultPrototype, result)) return result;\n  } return new Result(false);\n};\n\nvar wellKnownSymbol$9 = wellKnownSymbol$j;\n\nvar ITERATOR$3 = wellKnownSymbol$9('iterator');\nvar SAFE_CLOSING = false;\n\ntry {\n  var called = 0;\n  var iteratorWithReturn = {\n    next: function () {\n      return { done: !!called++ };\n    },\n    'return': function () {\n      SAFE_CLOSING = true;\n    }\n  };\n  iteratorWithReturn[ITERATOR$3] = function () {\n    return this;\n  };\n  // eslint-disable-next-line es-x/no-array-from, no-throw-literal -- required for testing\n  Array.from(iteratorWithReturn, function () { throw 2; });\n} catch (error) { /* empty */ }\n\nvar checkCorrectnessOfIteration$2 = function (exec, SKIP_CLOSING) {\n  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;\n  var ITERATION_SUPPORT = false;\n  try {\n    var object = {};\n    object[ITERATOR$3] = function () {\n      return {\n        next: function () {\n          return { done: ITERATION_SUPPORT = true };\n        }\n      };\n    };\n    exec(object);\n  } catch (error) { /* empty */ }\n  return ITERATION_SUPPORT;\n};\n\nvar NativePromiseConstructor$1 = promiseNativeConstructor;\nvar checkCorrectnessOfIteration$1 = checkCorrectnessOfIteration$2;\nvar FORCED_PROMISE_CONSTRUCTOR$3 = promiseConstructorDetection.CONSTRUCTOR;\n\nvar promiseStaticsIncorrectIteration = FORCED_PROMISE_CONSTRUCTOR$3 || !checkCorrectnessOfIteration$1(function (iterable) {\n  NativePromiseConstructor$1.all(iterable).then(undefined, function () { /* empty */ });\n});\n\nvar $$d = _export;\nvar call$b = functionCall;\nvar aCallable$3 = aCallable$9;\nvar newPromiseCapabilityModule$2 = newPromiseCapability$2;\nvar perform$1 = perform$3;\nvar iterate$1 = iterate$2;\nvar PROMISE_STATICS_INCORRECT_ITERATION$1 = promiseStaticsIncorrectIteration;\n\n// `Promise.all` method\n// https://tc39.es/ecma262/#sec-promise.all\n$$d({ target: 'Promise', stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION$1 }, {\n  all: function all(iterable) {\n    var C = this;\n    var capability = newPromiseCapabilityModule$2.f(C);\n    var resolve = capability.resolve;\n    var reject = capability.reject;\n    var result = perform$1(function () {\n      var $promiseResolve = aCallable$3(C.resolve);\n      var values = [];\n      var counter = 0;\n      var remaining = 1;\n      iterate$1(iterable, function (promise) {\n        var index = counter++;\n        var alreadyCalled = false;\n        remaining++;\n        call$b($promiseResolve, C, promise).then(function (value) {\n          if (alreadyCalled) return;\n          alreadyCalled = true;\n          values[index] = value;\n          --remaining || resolve(values);\n        }, reject);\n      });\n      --remaining || resolve(values);\n    });\n    if (result.error) reject(result.value);\n    return capability.promise;\n  }\n});\n\nvar $$c = _export;\nvar FORCED_PROMISE_CONSTRUCTOR$2 = promiseConstructorDetection.CONSTRUCTOR;\nvar NativePromiseConstructor = promiseNativeConstructor;\nvar getBuiltIn$1 = getBuiltIn$8;\nvar isCallable$6 = isCallable$n;\nvar defineBuiltIn$5 = defineBuiltIn$8;\n\nvar NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;\n\n// `Promise.prototype.catch` method\n// https://tc39.es/ecma262/#sec-promise.prototype.catch\n$$c({ target: 'Promise', proto: true, forced: FORCED_PROMISE_CONSTRUCTOR$2, real: true }, {\n  'catch': function (onRejected) {\n    return this.then(undefined, onRejected);\n  }\n});\n\n// makes sure that native promise-based APIs `Promise#catch` properly works with patched `Promise#then`\nif (isCallable$6(NativePromiseConstructor)) {\n  var method = getBuiltIn$1('Promise').prototype['catch'];\n  if (NativePromisePrototype['catch'] !== method) {\n    defineBuiltIn$5(NativePromisePrototype, 'catch', method, { unsafe: true });\n  }\n}\n\nvar $$b = _export;\nvar call$a = functionCall;\nvar aCallable$2 = aCallable$9;\nvar newPromiseCapabilityModule$1 = newPromiseCapability$2;\nvar perform = perform$3;\nvar iterate = iterate$2;\nvar PROMISE_STATICS_INCORRECT_ITERATION = promiseStaticsIncorrectIteration;\n\n// `Promise.race` method\n// https://tc39.es/ecma262/#sec-promise.race\n$$b({ target: 'Promise', stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {\n  race: function race(iterable) {\n    var C = this;\n    var capability = newPromiseCapabilityModule$1.f(C);\n    var reject = capability.reject;\n    var result = perform(function () {\n      var $promiseResolve = aCallable$2(C.resolve);\n      iterate(iterable, function (promise) {\n        call$a($promiseResolve, C, promise).then(capability.resolve, reject);\n      });\n    });\n    if (result.error) reject(result.value);\n    return capability.promise;\n  }\n});\n\nvar $$a = _export;\nvar call$9 = functionCall;\nvar newPromiseCapabilityModule = newPromiseCapability$2;\nvar FORCED_PROMISE_CONSTRUCTOR$1 = promiseConstructorDetection.CONSTRUCTOR;\n\n// `Promise.reject` method\n// https://tc39.es/ecma262/#sec-promise.reject\n$$a({ target: 'Promise', stat: true, forced: FORCED_PROMISE_CONSTRUCTOR$1 }, {\n  reject: function reject(r) {\n    var capability = newPromiseCapabilityModule.f(this);\n    call$9(capability.reject, undefined, r);\n    return capability.promise;\n  }\n});\n\nvar anObject$6 = anObject$e;\nvar isObject$6 = isObject$d;\nvar newPromiseCapability = newPromiseCapability$2;\n\nvar promiseResolve$1 = function (C, x) {\n  anObject$6(C);\n  if (isObject$6(x) && x.constructor === C) return x;\n  var promiseCapability = newPromiseCapability.f(C);\n  var resolve = promiseCapability.resolve;\n  resolve(x);\n  return promiseCapability.promise;\n};\n\nvar $$9 = _export;\nvar getBuiltIn = getBuiltIn$8;\nvar FORCED_PROMISE_CONSTRUCTOR = promiseConstructorDetection.CONSTRUCTOR;\nvar promiseResolve = promiseResolve$1;\n\ngetBuiltIn('Promise');\n\n// `Promise.resolve` method\n// https://tc39.es/ecma262/#sec-promise.resolve\n$$9({ target: 'Promise', stat: true, forced: FORCED_PROMISE_CONSTRUCTOR }, {\n  resolve: function resolve(x) {\n    return promiseResolve(this, x);\n  }\n});\n\nclass WebStorageService {\n  getItem(key) {\n    return new Promise(resolve => {\n      const value = localStorage.getItem(key);\n      resolve(value);\n    });\n  }\n  setItem(key, value) {\n    return new Promise(resolve => {\n      localStorage.setItem(key, value);\n      resolve();\n    });\n  }\n  removeItem(key) {\n    return new Promise(resolve => {\n      localStorage.removeItem(key);\n      resolve();\n    });\n  }\n}\n\nvar objectDefineProperties = {};\n\nvar internalObjectKeys = objectKeysInternal;\nvar enumBugKeys$1 = enumBugKeys$3;\n\n// `Object.keys` method\n// https://tc39.es/ecma262/#sec-object.keys\n// eslint-disable-next-line es-x/no-object-keys -- safe\nvar objectKeys$2 = Object.keys || function keys(O) {\n  return internalObjectKeys(O, enumBugKeys$1);\n};\n\nvar DESCRIPTORS$5 = descriptors;\nvar V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;\nvar definePropertyModule$2 = objectDefineProperty;\nvar anObject$5 = anObject$e;\nvar toIndexedObject$2 = toIndexedObject$6;\nvar objectKeys$1 = objectKeys$2;\n\n// `Object.defineProperties` method\n// https://tc39.es/ecma262/#sec-object.defineproperties\n// eslint-disable-next-line es-x/no-object-defineproperties -- safe\nobjectDefineProperties.f = DESCRIPTORS$5 && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {\n  anObject$5(O);\n  var props = toIndexedObject$2(Properties);\n  var keys = objectKeys$1(Properties);\n  var length = keys.length;\n  var index = 0;\n  var key;\n  while (length > index) definePropertyModule$2.f(O, key = keys[index++], props[key]);\n  return O;\n};\n\n/* global ActiveXObject -- old IE, WSH */\n\nvar anObject$4 = anObject$e;\nvar definePropertiesModule = objectDefineProperties;\nvar enumBugKeys = enumBugKeys$3;\nvar hiddenKeys = hiddenKeys$4;\nvar html = html$2;\nvar documentCreateElement$1 = documentCreateElement$2;\nvar sharedKey$1 = sharedKey$3;\n\nvar GT = '>';\nvar LT = '<';\nvar PROTOTYPE$1 = 'prototype';\nvar SCRIPT = 'script';\nvar IE_PROTO$1 = sharedKey$1('IE_PROTO');\n\nvar EmptyConstructor = function () { /* empty */ };\n\nvar scriptTag = function (content) {\n  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;\n};\n\n// Create object with fake `null` prototype: use ActiveX Object with cleared prototype\nvar NullProtoObjectViaActiveX = function (activeXDocument) {\n  activeXDocument.write(scriptTag(''));\n  activeXDocument.close();\n  var temp = activeXDocument.parentWindow.Object;\n  activeXDocument = null; // avoid memory leak\n  return temp;\n};\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar NullProtoObjectViaIFrame = function () {\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = documentCreateElement$1('iframe');\n  var JS = 'java' + SCRIPT + ':';\n  var iframeDocument;\n  iframe.style.display = 'none';\n  html.appendChild(iframe);\n  // https://github.com/zloirock/core-js/issues/475\n  iframe.src = String(JS);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(scriptTag('document.F=Object'));\n  iframeDocument.close();\n  return iframeDocument.F;\n};\n\n// Check for document.domain and active x support\n// No need to use active x approach when document.domain is not set\n// see https://github.com/es-shims/es5-shim/issues/150\n// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346\n// avoid IE GC bug\nvar activeXDocument;\nvar NullProtoObject = function () {\n  try {\n    activeXDocument = new ActiveXObject('htmlfile');\n  } catch (error) { /* ignore */ }\n  NullProtoObject = typeof document != 'undefined'\n    ? document.domain && activeXDocument\n      ? NullProtoObjectViaActiveX(activeXDocument) // old IE\n      : NullProtoObjectViaIFrame()\n    : NullProtoObjectViaActiveX(activeXDocument); // WSH\n  var length = enumBugKeys.length;\n  while (length--) delete NullProtoObject[PROTOTYPE$1][enumBugKeys[length]];\n  return NullProtoObject();\n};\n\nhiddenKeys[IE_PROTO$1] = true;\n\n// `Object.create` method\n// https://tc39.es/ecma262/#sec-object.create\n// eslint-disable-next-line es-x/no-object-create -- safe\nvar objectCreate = Object.create || function create(O, Properties) {\n  var result;\n  if (O !== null) {\n    EmptyConstructor[PROTOTYPE$1] = anObject$4(O);\n    result = new EmptyConstructor();\n    EmptyConstructor[PROTOTYPE$1] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO$1] = O;\n  } else result = NullProtoObject();\n  return Properties === undefined ? result : definePropertiesModule.f(result, Properties);\n};\n\nvar wellKnownSymbol$8 = wellKnownSymbol$j;\nvar create$3 = objectCreate;\nvar defineProperty$4 = objectDefineProperty.f;\n\nvar UNSCOPABLES = wellKnownSymbol$8('unscopables');\nvar ArrayPrototype = Array.prototype;\n\n// Array.prototype[@@unscopables]\n// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\nif (ArrayPrototype[UNSCOPABLES] == undefined) {\n  defineProperty$4(ArrayPrototype, UNSCOPABLES, {\n    configurable: true,\n    value: create$3(null)\n  });\n}\n\n// add a key to Array.prototype[@@unscopables]\nvar addToUnscopables$2 = function (key) {\n  ArrayPrototype[UNSCOPABLES][key] = true;\n};\n\nvar fails$h = fails$s;\n\nvar correctPrototypeGetter = !fails$h(function () {\n  function F() { /* empty */ }\n  F.prototype.constructor = null;\n  // eslint-disable-next-line es-x/no-object-getprototypeof -- required for testing\n  return Object.getPrototypeOf(new F()) !== F.prototype;\n});\n\nvar hasOwn$2 = hasOwnProperty_1;\nvar isCallable$5 = isCallable$n;\nvar toObject$5 = toObject$7;\nvar sharedKey = sharedKey$3;\nvar CORRECT_PROTOTYPE_GETTER = correctPrototypeGetter;\n\nvar IE_PROTO = sharedKey('IE_PROTO');\nvar $Object = Object;\nvar ObjectPrototype$2 = $Object.prototype;\n\n// `Object.getPrototypeOf` method\n// https://tc39.es/ecma262/#sec-object.getprototypeof\n// eslint-disable-next-line es-x/no-object-getprototypeof -- safe\nvar objectGetPrototypeOf = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function (O) {\n  var object = toObject$5(O);\n  if (hasOwn$2(object, IE_PROTO)) return object[IE_PROTO];\n  var constructor = object.constructor;\n  if (isCallable$5(constructor) && object instanceof constructor) {\n    return constructor.prototype;\n  } return object instanceof $Object ? ObjectPrototype$2 : null;\n};\n\nvar fails$g = fails$s;\nvar isCallable$4 = isCallable$n;\nvar getPrototypeOf$3 = objectGetPrototypeOf;\nvar defineBuiltIn$4 = defineBuiltIn$8;\nvar wellKnownSymbol$7 = wellKnownSymbol$j;\n\nvar ITERATOR$2 = wellKnownSymbol$7('iterator');\nvar BUGGY_SAFARI_ITERATORS$1 = false;\n\n// `%IteratorPrototype%` object\n// https://tc39.es/ecma262/#sec-%iteratorprototype%-object\nvar IteratorPrototype$2, PrototypeOfArrayIteratorPrototype, arrayIterator;\n\n/* eslint-disable es-x/no-array-prototype-keys -- safe */\nif ([].keys) {\n  arrayIterator = [].keys();\n  // Safari 8 has buggy iterators w/o `next`\n  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS$1 = true;\n  else {\n    PrototypeOfArrayIteratorPrototype = getPrototypeOf$3(getPrototypeOf$3(arrayIterator));\n    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype$2 = PrototypeOfArrayIteratorPrototype;\n  }\n}\n\nvar NEW_ITERATOR_PROTOTYPE = IteratorPrototype$2 == undefined || fails$g(function () {\n  var test = {};\n  // FF44- legacy iterators case\n  return IteratorPrototype$2[ITERATOR$2].call(test) !== test;\n});\n\nif (NEW_ITERATOR_PROTOTYPE) IteratorPrototype$2 = {};\n\n// `%IteratorPrototype%[@@iterator]()` method\n// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator\nif (!isCallable$4(IteratorPrototype$2[ITERATOR$2])) {\n  defineBuiltIn$4(IteratorPrototype$2, ITERATOR$2, function () {\n    return this;\n  });\n}\n\nvar iteratorsCore = {\n  IteratorPrototype: IteratorPrototype$2,\n  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1\n};\n\nvar IteratorPrototype$1 = iteratorsCore.IteratorPrototype;\nvar create$2 = objectCreate;\nvar createPropertyDescriptor$2 = createPropertyDescriptor$5;\nvar setToStringTag$2 = setToStringTag$4;\nvar Iterators$2 = iterators;\n\nvar returnThis$1 = function () { return this; };\n\nvar createIteratorConstructor$1 = function (IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {\n  var TO_STRING_TAG = NAME + ' Iterator';\n  IteratorConstructor.prototype = create$2(IteratorPrototype$1, { next: createPropertyDescriptor$2(+!ENUMERABLE_NEXT, next) });\n  setToStringTag$2(IteratorConstructor, TO_STRING_TAG, false);\n  Iterators$2[TO_STRING_TAG] = returnThis$1;\n  return IteratorConstructor;\n};\n\nvar $$8 = _export;\nvar call$8 = functionCall;\nvar FunctionName$1 = functionName;\nvar isCallable$3 = isCallable$n;\nvar createIteratorConstructor = createIteratorConstructor$1;\nvar getPrototypeOf$2 = objectGetPrototypeOf;\nvar setPrototypeOf$4 = objectSetPrototypeOf;\nvar setToStringTag$1 = setToStringTag$4;\nvar createNonEnumerableProperty$5 = createNonEnumerableProperty$8;\nvar defineBuiltIn$3 = defineBuiltIn$8;\nvar wellKnownSymbol$6 = wellKnownSymbol$j;\nvar Iterators$1 = iterators;\nvar IteratorsCore = iteratorsCore;\n\nvar PROPER_FUNCTION_NAME$2 = FunctionName$1.PROPER;\nvar CONFIGURABLE_FUNCTION_NAME$1 = FunctionName$1.CONFIGURABLE;\nvar IteratorPrototype = IteratorsCore.IteratorPrototype;\nvar BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;\nvar ITERATOR$1 = wellKnownSymbol$6('iterator');\nvar KEYS = 'keys';\nvar VALUES = 'values';\nvar ENTRIES = 'entries';\n\nvar returnThis = function () { return this; };\n\nvar defineIterator$1 = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {\n  createIteratorConstructor(IteratorConstructor, NAME, next);\n\n  var getIterationMethod = function (KIND) {\n    if (KIND === DEFAULT && defaultIterator) return defaultIterator;\n    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];\n    switch (KIND) {\n      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };\n      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };\n      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };\n    } return function () { return new IteratorConstructor(this); };\n  };\n\n  var TO_STRING_TAG = NAME + ' Iterator';\n  var INCORRECT_VALUES_NAME = false;\n  var IterablePrototype = Iterable.prototype;\n  var nativeIterator = IterablePrototype[ITERATOR$1]\n    || IterablePrototype['@@iterator']\n    || DEFAULT && IterablePrototype[DEFAULT];\n  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);\n  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;\n  var CurrentIteratorPrototype, methods, KEY;\n\n  // fix native\n  if (anyNativeIterator) {\n    CurrentIteratorPrototype = getPrototypeOf$2(anyNativeIterator.call(new Iterable()));\n    if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {\n      if (getPrototypeOf$2(CurrentIteratorPrototype) !== IteratorPrototype) {\n        if (setPrototypeOf$4) {\n          setPrototypeOf$4(CurrentIteratorPrototype, IteratorPrototype);\n        } else if (!isCallable$3(CurrentIteratorPrototype[ITERATOR$1])) {\n          defineBuiltIn$3(CurrentIteratorPrototype, ITERATOR$1, returnThis);\n        }\n      }\n      // Set @@toStringTag to native iterators\n      setToStringTag$1(CurrentIteratorPrototype, TO_STRING_TAG, true);\n    }\n  }\n\n  // fix Array.prototype.{ values, @@iterator }.name in V8 / FF\n  if (PROPER_FUNCTION_NAME$2 && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {\n    if (CONFIGURABLE_FUNCTION_NAME$1) {\n      createNonEnumerableProperty$5(IterablePrototype, 'name', VALUES);\n    } else {\n      INCORRECT_VALUES_NAME = true;\n      defaultIterator = function values() { return call$8(nativeIterator, this); };\n    }\n  }\n\n  // export additional methods\n  if (DEFAULT) {\n    methods = {\n      values: getIterationMethod(VALUES),\n      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),\n      entries: getIterationMethod(ENTRIES)\n    };\n    if (FORCED) for (KEY in methods) {\n      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {\n        defineBuiltIn$3(IterablePrototype, KEY, methods[KEY]);\n      }\n    } else $$8({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);\n  }\n\n  // define iterator\n  if (IterablePrototype[ITERATOR$1] !== defaultIterator) {\n    defineBuiltIn$3(IterablePrototype, ITERATOR$1, defaultIterator, { name: DEFAULT });\n  }\n  Iterators$1[NAME] = defaultIterator;\n\n  return methods;\n};\n\nvar toIndexedObject$1 = toIndexedObject$6;\nvar addToUnscopables$1 = addToUnscopables$2;\nvar Iterators = iterators;\nvar InternalStateModule$3 = internalState;\nvar defineProperty$3 = objectDefineProperty.f;\nvar defineIterator = defineIterator$1;\nvar DESCRIPTORS$4 = descriptors;\n\nvar ARRAY_ITERATOR = 'Array Iterator';\nvar setInternalState$2 = InternalStateModule$3.set;\nvar getInternalState$4 = InternalStateModule$3.getterFor(ARRAY_ITERATOR);\n\n// `Array.prototype.entries` method\n// https://tc39.es/ecma262/#sec-array.prototype.entries\n// `Array.prototype.keys` method\n// https://tc39.es/ecma262/#sec-array.prototype.keys\n// `Array.prototype.values` method\n// https://tc39.es/ecma262/#sec-array.prototype.values\n// `Array.prototype[@@iterator]` method\n// https://tc39.es/ecma262/#sec-array.prototype-@@iterator\n// `CreateArrayIterator` internal method\n// https://tc39.es/ecma262/#sec-createarrayiterator\nvar es_array_iterator = defineIterator(Array, 'Array', function (iterated, kind) {\n  setInternalState$2(this, {\n    type: ARRAY_ITERATOR,\n    target: toIndexedObject$1(iterated), // target\n    index: 0,                          // next index\n    kind: kind                         // kind\n  });\n// `%ArrayIteratorPrototype%.next` method\n// https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next\n}, function () {\n  var state = getInternalState$4(this);\n  var target = state.target;\n  var kind = state.kind;\n  var index = state.index++;\n  if (!target || index >= target.length) {\n    state.target = undefined;\n    return { value: undefined, done: true };\n  }\n  if (kind == 'keys') return { value: index, done: false };\n  if (kind == 'values') return { value: target[index], done: false };\n  return { value: [index, target[index]], done: false };\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values%\n// https://tc39.es/ecma262/#sec-createunmappedargumentsobject\n// https://tc39.es/ecma262/#sec-createmappedargumentsobject\nvar values = Iterators.Arguments = Iterators.Array;\n\n// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\naddToUnscopables$1('keys');\naddToUnscopables$1('values');\naddToUnscopables$1('entries');\n\n// V8 ~ Chrome 45- bug\nif (DESCRIPTORS$4 && values.name !== 'values') try {\n  defineProperty$3(values, 'name', { value: 'values' });\n} catch (error) { /* empty */ }\n\n// iterable DOM collections\n// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods\nvar domIterables = {\n  CSSRuleList: 0,\n  CSSStyleDeclaration: 0,\n  CSSValueList: 0,\n  ClientRectList: 0,\n  DOMRectList: 0,\n  DOMStringList: 0,\n  DOMTokenList: 1,\n  DataTransferItemList: 0,\n  FileList: 0,\n  HTMLAllCollection: 0,\n  HTMLCollection: 0,\n  HTMLFormElement: 0,\n  HTMLSelectElement: 0,\n  MediaList: 0,\n  MimeTypeArray: 0,\n  NamedNodeMap: 0,\n  NodeList: 1,\n  PaintRequestList: 0,\n  Plugin: 0,\n  PluginArray: 0,\n  SVGLengthList: 0,\n  SVGNumberList: 0,\n  SVGPathSegList: 0,\n  SVGPointList: 0,\n  SVGStringList: 0,\n  SVGTransformList: 0,\n  SourceBufferList: 0,\n  StyleSheetList: 0,\n  TextTrackCueList: 0,\n  TextTrackList: 0,\n  TouchList: 0\n};\n\n// in old WebKit versions, `element.classList` is not an instance of global `DOMTokenList`\nvar documentCreateElement = documentCreateElement$2;\n\nvar classList = documentCreateElement('span').classList;\nvar DOMTokenListPrototype$1 = classList && classList.constructor && classList.constructor.prototype;\n\nvar domTokenListPrototype = DOMTokenListPrototype$1 === Object.prototype ? undefined : DOMTokenListPrototype$1;\n\nvar global$b = global$t;\nvar DOMIterables = domIterables;\nvar DOMTokenListPrototype = domTokenListPrototype;\nvar ArrayIteratorMethods = es_array_iterator;\nvar createNonEnumerableProperty$4 = createNonEnumerableProperty$8;\nvar wellKnownSymbol$5 = wellKnownSymbol$j;\n\nvar ITERATOR = wellKnownSymbol$5('iterator');\nvar TO_STRING_TAG$1 = wellKnownSymbol$5('toStringTag');\nvar ArrayValues = ArrayIteratorMethods.values;\n\nvar handlePrototype = function (CollectionPrototype, COLLECTION_NAME) {\n  if (CollectionPrototype) {\n    // some Chrome versions have non-configurable methods on DOMTokenList\n    if (CollectionPrototype[ITERATOR] !== ArrayValues) try {\n      createNonEnumerableProperty$4(CollectionPrototype, ITERATOR, ArrayValues);\n    } catch (error) {\n      CollectionPrototype[ITERATOR] = ArrayValues;\n    }\n    if (!CollectionPrototype[TO_STRING_TAG$1]) {\n      createNonEnumerableProperty$4(CollectionPrototype, TO_STRING_TAG$1, COLLECTION_NAME);\n    }\n    if (DOMIterables[COLLECTION_NAME]) for (var METHOD_NAME in ArrayIteratorMethods) {\n      // some Chrome versions have non-configurable methods on DOMTokenList\n      if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {\n        createNonEnumerableProperty$4(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);\n      } catch (error) {\n        CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];\n      }\n    }\n  }\n};\n\nfor (var COLLECTION_NAME in DOMIterables) {\n  handlePrototype(global$b[COLLECTION_NAME] && global$b[COLLECTION_NAME].prototype, COLLECTION_NAME);\n}\n\nhandlePrototype(DOMTokenListPrototype, 'DOMTokenList');\n\nclass Logger {\n  constructor(namespace) {\n    this.namespace = namespace;\n  }\n  emit(method, ...params) {\n    if (!Logger.debug) {\n      return;\n    }\n    if (this.namespace && method !== \"error\") {\n      // eslint-disable-next-line no-console\n      console[method](this.namespace, ...params);\n      return;\n    }\n    // eslint-disable-next-line no-console\n    console[method](...params);\n  }\n  log(...params) {\n    this.emit(\"log\", ...params);\n  }\n  info(...params) {\n    this.emit(\"info\", ...params);\n  }\n  warn(...params) {\n    this.emit(\"warn\", ...params);\n  }\n  error(...params) {\n    this.emit(\"error\", ...params);\n  }\n}\nLogger.debug = false;\nconst logger = new Logger();\n\nvar $$7 = _export;\nvar $includes = arrayIncludes.includes;\nvar fails$f = fails$s;\nvar addToUnscopables = addToUnscopables$2;\n\n// FF99+ bug\nvar BROKEN_ON_SPARSE = fails$f(function () {\n  return !Array(1).includes();\n});\n\n// `Array.prototype.includes` method\n// https://tc39.es/ecma262/#sec-array.prototype.includes\n$$7({ target: 'Array', proto: true, forced: BROKEN_ON_SPARSE }, {\n  includes: function includes(el /* , fromIndex = 0 */) {\n    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n\n// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\naddToUnscopables('includes');\n\nvar isObject$5 = isObject$d;\nvar classof$6 = classofRaw$1;\nvar wellKnownSymbol$4 = wellKnownSymbol$j;\n\nvar MATCH$1 = wellKnownSymbol$4('match');\n\n// `IsRegExp` abstract operation\n// https://tc39.es/ecma262/#sec-isregexp\nvar isRegexp = function (it) {\n  var isRegExp;\n  return isObject$5(it) && ((isRegExp = it[MATCH$1]) !== undefined ? !!isRegExp : classof$6(it) == 'RegExp');\n};\n\nvar isRegExp$1 = isRegexp;\n\nvar $TypeError$3 = TypeError;\n\nvar notARegexp = function (it) {\n  if (isRegExp$1(it)) {\n    throw $TypeError$3(\"The method doesn't accept regular expressions\");\n  } return it;\n};\n\nvar classof$5 = classof$9;\n\nvar $String = String;\n\nvar toString$5 = function (argument) {\n  if (classof$5(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');\n  return $String(argument);\n};\n\nvar wellKnownSymbol$3 = wellKnownSymbol$j;\n\nvar MATCH = wellKnownSymbol$3('match');\n\nvar correctIsRegexpLogic = function (METHOD_NAME) {\n  var regexp = /./;\n  try {\n    '/./'[METHOD_NAME](regexp);\n  } catch (error1) {\n    try {\n      regexp[MATCH] = false;\n      return '/./'[METHOD_NAME](regexp);\n    } catch (error2) { /* empty */ }\n  } return false;\n};\n\nvar $$6 = _export;\nvar uncurryThis$b = functionUncurryThis;\nvar notARegExp = notARegexp;\nvar requireObjectCoercible$3 = requireObjectCoercible$6;\nvar toString$4 = toString$5;\nvar correctIsRegExpLogic = correctIsRegexpLogic;\n\nvar stringIndexOf = uncurryThis$b(''.indexOf);\n\n// `String.prototype.includes` method\n// https://tc39.es/ecma262/#sec-string.prototype.includes\n$$6({ target: 'String', proto: true, forced: !correctIsRegExpLogic('includes') }, {\n  includes: function includes(searchString /* , position = 0 */) {\n    return !!~stringIndexOf(\n      toString$4(requireObjectCoercible$3(this)),\n      toString$4(notARegExp(searchString)),\n      arguments.length > 1 ? arguments[1] : undefined\n    );\n  }\n});\n\n// a string of all valid unicode whitespaces\nvar whitespaces$2 = '\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u2000\\u2001\\u2002' +\n  '\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF';\n\nvar uncurryThis$a = functionUncurryThis;\nvar requireObjectCoercible$2 = requireObjectCoercible$6;\nvar toString$3 = toString$5;\nvar whitespaces$1 = whitespaces$2;\n\nvar replace$1 = uncurryThis$a(''.replace);\nvar whitespace = '[' + whitespaces$1 + ']';\nvar ltrim = RegExp('^' + whitespace + whitespace + '*');\nvar rtrim = RegExp(whitespace + whitespace + '*$');\n\n// `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation\nvar createMethod$3 = function (TYPE) {\n  return function ($this) {\n    var string = toString$3(requireObjectCoercible$2($this));\n    if (TYPE & 1) string = replace$1(string, ltrim, '');\n    if (TYPE & 2) string = replace$1(string, rtrim, '');\n    return string;\n  };\n};\n\nvar stringTrim = {\n  // `String.prototype.{ trimLeft, trimStart }` methods\n  // https://tc39.es/ecma262/#sec-string.prototype.trimstart\n  start: createMethod$3(1),\n  // `String.prototype.{ trimRight, trimEnd }` methods\n  // https://tc39.es/ecma262/#sec-string.prototype.trimend\n  end: createMethod$3(2),\n  // `String.prototype.trim` method\n  // https://tc39.es/ecma262/#sec-string.prototype.trim\n  trim: createMethod$3(3)\n};\n\nvar PROPER_FUNCTION_NAME$1 = functionName.PROPER;\nvar fails$e = fails$s;\nvar whitespaces = whitespaces$2;\n\nvar non = '\\u200B\\u0085\\u180E';\n\n// check that a method works with the correct list\n// of whitespaces and has a correct name\nvar stringTrimForced = function (METHOD_NAME) {\n  return fails$e(function () {\n    return !!whitespaces[METHOD_NAME]()\n      || non[METHOD_NAME]() !== non\n      || (PROPER_FUNCTION_NAME$1 && whitespaces[METHOD_NAME].name !== METHOD_NAME);\n  });\n};\n\nvar $$5 = _export;\nvar $trim = stringTrim.trim;\nvar forcedStringTrimMethod = stringTrimForced;\n\n// `String.prototype.trim` method\n// https://tc39.es/ecma262/#sec-string.prototype.trim\n$$5({ target: 'String', proto: true, forced: forcedStringTrimMethod('trim') }, {\n  trim: function trim() {\n    return $trim(this);\n  }\n});\n\nvar DESCRIPTORS$3 = descriptors;\nvar uncurryThis$9 = functionUncurryThis;\nvar call$7 = functionCall;\nvar fails$d = fails$s;\nvar objectKeys = objectKeys$2;\nvar getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;\nvar propertyIsEnumerableModule = objectPropertyIsEnumerable;\nvar toObject$4 = toObject$7;\nvar IndexedObject$2 = indexedObject;\n\n// eslint-disable-next-line es-x/no-object-assign -- safe\nvar $assign = Object.assign;\n// eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\nvar defineProperty$2 = Object.defineProperty;\nvar concat = uncurryThis$9([].concat);\n\n// `Object.assign` method\n// https://tc39.es/ecma262/#sec-object.assign\nvar objectAssign = !$assign || fails$d(function () {\n  // should have correct order of operations (Edge bug)\n  if (DESCRIPTORS$3 && $assign({ b: 1 }, $assign(defineProperty$2({}, 'a', {\n    enumerable: true,\n    get: function () {\n      defineProperty$2(this, 'b', {\n        value: 3,\n        enumerable: false\n      });\n    }\n  }), { b: 2 })).b !== 1) return true;\n  // should work with symbols and should have deterministic property order (V8 bug)\n  var A = {};\n  var B = {};\n  // eslint-disable-next-line es-x/no-symbol -- safe\n  var symbol = Symbol();\n  var alphabet = 'abcdefghijklmnopqrst';\n  A[symbol] = 7;\n  alphabet.split('').forEach(function (chr) { B[chr] = chr; });\n  return $assign({}, A)[symbol] != 7 || objectKeys($assign({}, B)).join('') != alphabet;\n}) ? function assign(target, source) { // eslint-disable-line no-unused-vars -- required for `.length`\n  var T = toObject$4(target);\n  var argumentsLength = arguments.length;\n  var index = 1;\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n  var propertyIsEnumerable = propertyIsEnumerableModule.f;\n  while (argumentsLength > index) {\n    var S = IndexedObject$2(arguments[index++]);\n    var keys = getOwnPropertySymbols ? concat(objectKeys(S), getOwnPropertySymbols(S)) : objectKeys(S);\n    var length = keys.length;\n    var j = 0;\n    var key;\n    while (length > j) {\n      key = keys[j++];\n      if (!DESCRIPTORS$3 || call$7(propertyIsEnumerable, S, key)) T[key] = S[key];\n    }\n  } return T;\n} : $assign;\n\nvar $$4 = _export;\nvar assign = objectAssign;\n\n// `Object.assign` method\n// https://tc39.es/ecma262/#sec-object.assign\n// eslint-disable-next-line es-x/no-object-assign -- required for testing\n$$4({ target: 'Object', stat: true, arity: 2, forced: Object.assign !== assign }, {\n  assign: assign\n});\n\nclass EventEmitter {\n  constructor() {\n    this.emitter = new events.EventEmitter();\n  }\n  on(eventName, callback) {\n    this.emitter.on(eventName, callback);\n    return {\n      remove: () => this.emitter.off(eventName, callback)\n    };\n  }\n  off(eventName, callback) {\n    this.emitter.off(eventName, callback);\n  }\n  emit(eventName, event) {\n    this.emitter.emit(eventName, event);\n  }\n}\n\nconst PACKAGE_NAME = \"near-wallet-selector\";\nconst RECENTLY_SIGNED_IN_WALLETS = \"recentlySignedInWallets\";\nconst CONTRACT = \"contract\";\nconst PENDING_CONTRACT = \"contract:pending\";\nconst SELECTED_WALLET_ID = `selectedWalletId`;\nconst PENDING_SELECTED_WALLET_ID = `selectedWalletId:pending`;\n\nclass WalletModules {\n  constructor({\n    factories,\n    storage,\n    options,\n    store,\n    emitter,\n    provider\n  }) {\n    this.factories = factories;\n    this.storage = storage;\n    this.options = options;\n    this.store = store;\n    this.emitter = emitter;\n    this.provider = provider;\n    this.modules = [];\n    this.instances = {};\n  }\n  validateWallet(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let accounts = [];\n      const wallet = yield this.getWallet(id);\n      if (wallet) {\n        // Ensure our persistent state aligns with the selected wallet.\n        // For example a wallet is selected, but it returns no accounts (not signed in).\n        accounts = yield wallet.getAccounts().catch(err => {\n          logger.log(`Failed to validate ${wallet.id} during setup`);\n          logger.error(err);\n          return [];\n        });\n      }\n      return accounts;\n    });\n  }\n  resolveStorageState() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const jsonStorage = new JsonStorage(this.storage, PACKAGE_NAME);\n      const pendingSelectedWalletId = yield jsonStorage.getItem(PENDING_SELECTED_WALLET_ID);\n      const pendingContract = yield jsonStorage.getItem(PENDING_CONTRACT);\n      if (pendingSelectedWalletId && pendingContract) {\n        const _accounts = yield this.validateWallet(pendingSelectedWalletId);\n        yield jsonStorage.removeItem(PENDING_SELECTED_WALLET_ID);\n        yield jsonStorage.removeItem(PENDING_CONTRACT);\n        if (_accounts.length) {\n          const {\n            selectedWalletId: _selectedWalletId\n          } = this.store.getState();\n          const selectedWallet = yield this.getWallet(_selectedWalletId);\n          if (selectedWallet && pendingSelectedWalletId !== _selectedWalletId) {\n            yield selectedWallet.signOut().catch(err => {\n              logger.log(\"Failed to sign out existing wallet\");\n              logger.error(err);\n            });\n          }\n          const recentlySignedInWalletsFromPending = yield this.setWalletAsRecentlySignedIn(pendingSelectedWalletId);\n          return {\n            accounts: _accounts,\n            contract: pendingContract,\n            selectedWalletId: pendingSelectedWalletId,\n            recentlySignedInWallets: recentlySignedInWalletsFromPending\n          };\n        }\n      }\n      const {\n        contract,\n        selectedWalletId\n      } = this.store.getState();\n      const accounts = yield this.validateWallet(selectedWalletId);\n      const recentlySignedInWallets = yield jsonStorage.getItem(RECENTLY_SIGNED_IN_WALLETS);\n      if (!accounts.length) {\n        return {\n          accounts: [],\n          contract: null,\n          selectedWalletId: null,\n          recentlySignedInWallets: recentlySignedInWallets || []\n        };\n      }\n      return {\n        accounts,\n        contract,\n        selectedWalletId,\n        recentlySignedInWallets: recentlySignedInWallets || []\n      };\n    });\n  }\n  setWalletAsRecentlySignedIn(walletId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const jsonStorage = new JsonStorage(this.storage, PACKAGE_NAME);\n      let recentlySignedInWallets = yield jsonStorage.getItem(RECENTLY_SIGNED_IN_WALLETS);\n      if (!recentlySignedInWallets) {\n        recentlySignedInWallets = [];\n      }\n      if (!recentlySignedInWallets.includes(walletId)) {\n        recentlySignedInWallets.unshift(walletId);\n        recentlySignedInWallets = recentlySignedInWallets.slice(0, 5);\n        yield jsonStorage.setItem(RECENTLY_SIGNED_IN_WALLETS, recentlySignedInWallets);\n      }\n      return recentlySignedInWallets;\n    });\n  }\n  signOutWallet(walletId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const wallet = yield this.getWallet(walletId);\n      yield wallet.signOut().catch(err => {\n        logger.log(`Failed to sign out ${wallet.id}`);\n        logger.error(err);\n        // At least clean up state on our side.\n        this.onWalletSignedOut(wallet.id);\n      });\n    });\n  }\n  onWalletSignedIn(walletId, {\n    accounts,\n    contractId,\n    methodNames\n  }) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        selectedWalletId\n      } = this.store.getState();\n      const jsonStorage = new JsonStorage(this.storage, PACKAGE_NAME);\n      const contract = {\n        contractId,\n        methodNames\n      };\n      if (!accounts.length) {\n        const module = this.getModule(walletId);\n        // We can't guarantee the user will actually sign in with browser wallets.\n        // Best we can do is set in storage and validate on init.\n        if (module.type === \"browser\") {\n          yield jsonStorage.setItem(PENDING_SELECTED_WALLET_ID, walletId);\n          yield jsonStorage.setItem(PENDING_CONTRACT, contract);\n        }\n        return;\n      }\n      if (selectedWalletId && selectedWalletId !== walletId) {\n        yield this.signOutWallet(selectedWalletId);\n      }\n      const recentlySignedInWallets = yield this.setWalletAsRecentlySignedIn(walletId);\n      this.store.dispatch({\n        type: \"WALLET_CONNECTED\",\n        payload: {\n          walletId,\n          contract,\n          accounts,\n          recentlySignedInWallets\n        }\n      });\n      this.emitter.emit(\"signedIn\", {\n        walletId,\n        contractId,\n        methodNames,\n        accounts\n      });\n    });\n  }\n  onWalletSignedOut(walletId) {\n    this.store.dispatch({\n      type: \"WALLET_DISCONNECTED\",\n      payload: {\n        walletId\n      }\n    });\n    this.emitter.emit(\"signedOut\", {\n      walletId\n    });\n  }\n  setupWalletEmitter(module) {\n    const emitter = new EventEmitter();\n    emitter.on(\"signedOut\", () => {\n      this.onWalletSignedOut(module.id);\n    });\n    emitter.on(\"signedIn\", event => {\n      this.onWalletSignedIn(module.id, event);\n    });\n    emitter.on(\"accountsChanged\", ({\n      accounts\n    }) => __awaiter(this, void 0, void 0, function* () {\n      this.emitter.emit(\"accountsChanged\", {\n        walletId: module.id,\n        accounts\n      });\n      if (!accounts.length) {\n        return this.signOutWallet(module.id);\n      }\n      this.store.dispatch({\n        type: \"ACCOUNTS_CHANGED\",\n        payload: {\n          walletId: module.id,\n          accounts\n        }\n      });\n    }));\n    emitter.on(\"networkChanged\", ({\n      networkId\n    }) => {\n      this.emitter.emit(\"networkChanged\", {\n        walletId: module.id,\n        networkId\n      });\n    });\n    emitter.on(\"uriChanged\", ({\n      uri\n    }) => {\n      this.emitter.emit(\"uriChanged\", {\n        walletId: module.id,\n        uri\n      });\n    });\n    return emitter;\n  }\n  validateSignMessageParams({\n    message,\n    nonce,\n    recipient\n  }) {\n    if (!message || message.trim() === \"\") {\n      throw new Error(\"Invalid message. It must be a non-empty string.\");\n    }\n    if (!Buffer.isBuffer(nonce) || nonce.length !== 32) {\n      throw new Error(\"Invalid nonce. It must be a Buffer with a length of 32 bytes.\");\n    }\n    if (!recipient || recipient.trim() === \"\") {\n      throw new Error(\"Invalid recipient. It must be a non-empty string.\");\n    }\n  }\n  decorateWallet(wallet) {\n    const _signIn = wallet.signIn;\n    const _signOut = wallet.signOut;\n    const _signMessage = wallet.signMessage;\n    wallet.signIn = params => __awaiter(this, void 0, void 0, function* () {\n      const accounts = yield _signIn(params);\n      const {\n        contractId,\n        methodNames = []\n      } = params;\n      yield this.onWalletSignedIn(wallet.id, {\n        accounts,\n        contractId,\n        methodNames\n      });\n      return accounts;\n    });\n    wallet.signOut = () => __awaiter(this, void 0, void 0, function* () {\n      yield _signOut();\n      this.onWalletSignedOut(wallet.id);\n    });\n    wallet.signMessage = params => __awaiter(this, void 0, void 0, function* () {\n      if (_signMessage === undefined) {\n        throw Error(`The signMessage method is not supported by ${wallet.metadata.name}`);\n      }\n      this.validateSignMessageParams(params);\n      return yield _signMessage(params);\n    });\n    return wallet;\n  }\n  setupInstance(module) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!module.metadata.available) {\n        const message = module.type === \"injected\" ? \"not installed\" : \"not available\";\n        throw Error(`${module.metadata.name} is ${message}`);\n      }\n      const wallet = Object.assign({\n        id: module.id,\n        type: module.type,\n        metadata: module.metadata\n      }, yield module.init({\n        id: module.id,\n        type: module.type,\n        metadata: module.metadata,\n        options: this.options,\n        store: this.store.toReadOnly(),\n        provider: this.provider,\n        emitter: this.setupWalletEmitter(module),\n        logger: new Logger(module.id),\n        storage: new JsonStorage(this.storage, [PACKAGE_NAME, module.id])\n      }));\n      return this.decorateWallet(wallet);\n    });\n  }\n  getModule(id) {\n    return this.modules.find(x => x.id === id);\n  }\n  getWallet(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const module = this.getModule(id);\n      if (!module) {\n        return null;\n      }\n      const {\n        selectedWalletId\n      } = this.store.getState();\n      // If user uninstalled/removed a wallet which was previously signed in with\n      // best we can do is clean up state on our side.\n      if (!module.metadata.available && selectedWalletId) {\n        this.onWalletSignedOut(selectedWalletId);\n        return null;\n      }\n      return yield module.wallet();\n    });\n  }\n  setup() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const modules = [];\n      for (let i = 0; i < this.factories.length; i += 1) {\n        const module = yield this.factories[i]({\n          options: this.options\n        }).catch(err => {\n          logger.log(\"Failed to setup module\");\n          logger.error(err);\n          return null;\n        });\n        // Filter out wallets that aren't available.\n        if (!module) {\n          continue;\n        }\n        // Skip duplicated module.\n        if (modules.some(x => x.id === module.id)) {\n          continue;\n        }\n        modules.push({\n          id: module.id,\n          type: module.type,\n          metadata: module.metadata,\n          wallet: () => __awaiter(this, void 0, void 0, function* () {\n            let instance = this.instances[module.id];\n            if (instance) {\n              return instance;\n            }\n            instance = yield this.setupInstance(module);\n            this.instances[module.id] = instance;\n            return instance;\n          })\n        });\n      }\n      this.modules = modules;\n      const {\n        accounts,\n        contract,\n        selectedWalletId,\n        recentlySignedInWallets\n      } = yield this.resolveStorageState();\n      this.store.dispatch({\n        type: \"SETUP_WALLET_MODULES\",\n        payload: {\n          modules,\n          accounts,\n          contract,\n          selectedWalletId,\n          recentlySignedInWallets\n        }\n      });\n      for (let i = 0; i < this.modules.length; i++) {\n        if (this.modules[i].type !== \"instant-link\") {\n          continue;\n        }\n        const wallet = yield this.modules[i].wallet();\n        if (!wallet.metadata.runOnStartup) {\n          continue;\n        }\n        try {\n          yield wallet.signIn({\n            contractId: wallet.getContractId()\n          });\n        } catch (err) {\n          logger.error(\"Failed to sign in to wallet. \" + err);\n        }\n      }\n    });\n  }\n}\n\nconst getNetworkPreset = networkId => {\n  switch (networkId) {\n    case \"mainnet\":\n      return {\n        networkId,\n        nodeUrl: \"https://rpc.mainnet.near.org\",\n        helperUrl: \"https://helper.mainnet.near.org\",\n        explorerUrl: \"https://nearblocks.io\",\n        indexerUrl: \"https://api.kitwallet.app\"\n      };\n    case \"testnet\":\n      return {\n        networkId,\n        nodeUrl: \"https://rpc.testnet.near.org\",\n        helperUrl: \"https://helper.testnet.near.org\",\n        explorerUrl: \"https://testnet.nearblocks.io\",\n        indexerUrl: \"https://testnet-api.kitwallet.app\"\n      };\n    default:\n      throw Error(`Failed to find config for: '${networkId}'`);\n  }\n};\nconst resolveNetwork = network => {\n  return typeof network === \"string\" ? getNetworkPreset(network) : network;\n};\nconst resolveOptions = params => {\n  const options = {\n    languageCode: params.languageCode || undefined,\n    network: resolveNetwork(params.network),\n    debug: params.debug || false,\n    optimizeWalletOrder: params.optimizeWalletOrder === false ? false : true,\n    randomizeWalletOrder: params.randomizeWalletOrder || false,\n    relayerUrl: params.relayerUrl || undefined\n  };\n  return {\n    options,\n    storage: params.storage || new WebStorageService()\n  };\n};\n\nconst reducer = (state, action) => {\n  logger.log(\"Store Action\", action);\n  switch (action.type) {\n    case \"SETUP_WALLET_MODULES\":\n      {\n        const {\n          modules,\n          accounts,\n          contract,\n          selectedWalletId,\n          recentlySignedInWallets\n        } = action.payload;\n        const accountStates = accounts.map((account, i) => {\n          return Object.assign(Object.assign({}, account), {\n            active: i === 0\n          });\n        });\n        return Object.assign(Object.assign({}, state), {\n          modules,\n          accounts: accountStates,\n          contract,\n          selectedWalletId,\n          recentlySignedInWallets\n        });\n      }\n    case \"WALLET_CONNECTED\":\n      {\n        const {\n          walletId,\n          contract,\n          accounts,\n          recentlySignedInWallets\n        } = action.payload;\n        if (!accounts.length) {\n          return state;\n        }\n        const activeAccountIndex = state.accounts.findIndex(account => account.active);\n        const accountStates = accounts.map((account, i) => {\n          return Object.assign(Object.assign({}, account), {\n            active: i === (activeAccountIndex > -1 ? activeAccountIndex : 0)\n          });\n        });\n        return Object.assign(Object.assign({}, state), {\n          contract,\n          accounts: accountStates,\n          selectedWalletId: walletId,\n          recentlySignedInWallets\n        });\n      }\n    case \"WALLET_DISCONNECTED\":\n      {\n        const {\n          walletId\n        } = action.payload;\n        if (walletId !== state.selectedWalletId) {\n          return state;\n        }\n        return Object.assign(Object.assign({}, state), {\n          contract: null,\n          accounts: [],\n          selectedWalletId: null\n        });\n      }\n    case \"ACCOUNTS_CHANGED\":\n      {\n        const {\n          walletId,\n          accounts\n        } = action.payload;\n        if (walletId !== state.selectedWalletId) {\n          return state;\n        }\n        const activeAccount = state.accounts.find(account => account.active);\n        const isActiveAccountRemoved = !accounts.some(account => account.accountId === (activeAccount === null || activeAccount === void 0 ? void 0 : activeAccount.accountId));\n        const accountStates = accounts.map((account, i) => {\n          return Object.assign(Object.assign({}, account), {\n            active: isActiveAccountRemoved ? i === 0 : account.accountId === (activeAccount === null || activeAccount === void 0 ? void 0 : activeAccount.accountId)\n          });\n        });\n        return Object.assign(Object.assign({}, state), {\n          accounts: accountStates\n        });\n      }\n    case \"SET_ACTIVE_ACCOUNT\":\n      {\n        const {\n          accountId\n        } = action.payload;\n        const accountStates = state.accounts.map(account => {\n          return Object.assign(Object.assign({}, account), {\n            active: account.accountId === accountId\n          });\n        });\n        return Object.assign(Object.assign({}, state), {\n          accounts: accountStates\n        });\n      }\n    default:\n      return state;\n  }\n};\nconst createStore = storage => __awaiter(void 0, void 0, void 0, function* () {\n  const jsonStorage = new JsonStorage(storage, PACKAGE_NAME);\n  const initialState = {\n    modules: [],\n    accounts: [],\n    contract: yield jsonStorage.getItem(CONTRACT),\n    selectedWalletId: yield jsonStorage.getItem(SELECTED_WALLET_ID),\n    recentlySignedInWallets: (yield jsonStorage.getItem(RECENTLY_SIGNED_IN_WALLETS)) || []\n  };\n  const state$ = new rxjs.BehaviorSubject(initialState);\n  const actions$ = new rxjs.Subject();\n  actions$.pipe(rxjs.scan(reducer, initialState)).subscribe(state$);\n  const syncStorage = (prevState, state, storageKey, property) => __awaiter(void 0, void 0, void 0, function* () {\n    if (state[property] === prevState[property]) {\n      return;\n    }\n    if (state[property]) {\n      yield jsonStorage.setItem(storageKey, state[property]);\n      return;\n    }\n    yield jsonStorage.removeItem(storageKey);\n  });\n  let prevState = state$.getValue();\n  state$.subscribe(state => {\n    syncStorage(prevState, state, SELECTED_WALLET_ID, \"selectedWalletId\");\n    syncStorage(prevState, state, CONTRACT, \"contract\");\n    syncStorage(prevState, state, RECENTLY_SIGNED_IN_WALLETS, \"recentlySignedInWallets\");\n    prevState = state;\n  });\n  return {\n    observable: state$,\n    getState: () => state$.getValue(),\n    dispatch: action => actions$.next(action),\n    toReadOnly: () => ({\n      getState: () => state$.getValue(),\n      observable: state$.asObservable()\n    })\n  };\n});\n\nlet walletSelectorInstance = null;\nconst createSelector = (options, store, walletModules, emitter) => {\n  return {\n    options,\n    store: store.toReadOnly(),\n    wallet: id => __awaiter(void 0, void 0, void 0, function* () {\n      const {\n        selectedWalletId\n      } = store.getState();\n      const wallet = yield walletModules.getWallet(id || selectedWalletId);\n      if (!wallet) {\n        if (id) {\n          throw new Error(\"Invalid wallet id\");\n        }\n        throw new Error(\"No wallet selected\");\n      }\n      return wallet;\n    }),\n    setActiveAccount: accountId => {\n      const {\n        accounts\n      } = store.getState();\n      if (!accounts.some(account => account.accountId === accountId)) {\n        throw new Error(\"Invalid account id\");\n      }\n      store.dispatch({\n        type: \"SET_ACTIVE_ACCOUNT\",\n        payload: {\n          accountId\n        }\n      });\n    },\n    isSignedIn() {\n      const {\n        accounts\n      } = store.getState();\n      return Boolean(accounts.length);\n    },\n    on: (eventName, callback) => {\n      return emitter.on(eventName, callback);\n    },\n    off: (eventName, callback) => {\n      emitter.off(eventName, callback);\n    }\n  };\n};\n/**\r\n * Initiates a wallet selector instance\r\n * @param {WalletSelectorParams} params Selector parameters (network, modules...)\r\n * @returns {Promise<WalletSelector>} Returns a WalletSelector object\r\n */\nconst setupWalletSelector = params => __awaiter(void 0, void 0, void 0, function* () {\n  const {\n    options,\n    storage\n  } = resolveOptions(params);\n  Logger.debug = options.debug;\n  const emitter = new EventEmitter();\n  const store = yield createStore(storage);\n  const walletModules = new WalletModules({\n    factories: params.modules,\n    storage,\n    options,\n    store,\n    emitter,\n    provider: new Provider(options.network.nodeUrl)\n  });\n  yield walletModules.setup();\n  if (params.allowMultipleSelectors) {\n    return createSelector(options, store, walletModules, emitter);\n  }\n  if (!walletSelectorInstance) {\n    walletSelectorInstance = createSelector(options, store, walletModules, emitter);\n  }\n  return walletSelectorInstance;\n});\n\nconst wait = ms => {\n  return new Promise(resolve => setTimeout(resolve, ms));\n};\nconst poll = (cb, interval, remaining) => __awaiter(void 0, void 0, void 0, function* () {\n  const result = cb();\n  if (result) {\n    return result;\n  }\n  if (!remaining) {\n    throw new Error(\"Exceeded timeout\");\n  }\n  return wait(interval).then(() => poll(cb, interval, remaining - 1));\n});\nconst waitFor = (cb, opts = {}) => __awaiter(void 0, void 0, void 0, function* () {\n  const {\n    timeout = 100,\n    interval = 50\n  } = opts;\n  return Promise.race([wait(timeout).then(() => {\n    throw new Error(\"Exceeded timeout\");\n  }), poll(cb, interval, Math.floor(timeout / interval))]);\n});\n\nconst getActiveAccount = state => {\n  return state.accounts.find(account => account.active) || null;\n};\n\nvar aCallable$1 = aCallable$9;\nvar toObject$3 = toObject$7;\nvar IndexedObject$1 = indexedObject;\nvar lengthOfArrayLike$5 = lengthOfArrayLike$8;\n\nvar $TypeError$2 = TypeError;\n\n// `Array.prototype.{ reduce, reduceRight }` methods implementation\nvar createMethod$2 = function (IS_RIGHT) {\n  return function (that, callbackfn, argumentsLength, memo) {\n    aCallable$1(callbackfn);\n    var O = toObject$3(that);\n    var self = IndexedObject$1(O);\n    var length = lengthOfArrayLike$5(O);\n    var index = IS_RIGHT ? length - 1 : 0;\n    var i = IS_RIGHT ? -1 : 1;\n    if (argumentsLength < 2) while (true) {\n      if (index in self) {\n        memo = self[index];\n        index += i;\n        break;\n      }\n      index += i;\n      if (IS_RIGHT ? index < 0 : length <= index) {\n        throw $TypeError$2('Reduce of empty array with no initial value');\n      }\n    }\n    for (;IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {\n      memo = callbackfn(memo, self[index], index, O);\n    }\n    return memo;\n  };\n};\n\nvar arrayReduce = {\n  // `Array.prototype.reduce` method\n  // https://tc39.es/ecma262/#sec-array.prototype.reduce\n  left: createMethod$2(false),\n  // `Array.prototype.reduceRight` method\n  // https://tc39.es/ecma262/#sec-array.prototype.reduceright\n  right: createMethod$2(true)\n};\n\nvar fails$c = fails$s;\n\nvar arrayMethodIsStrict$1 = function (METHOD_NAME, argument) {\n  var method = [][METHOD_NAME];\n  return !!method && fails$c(function () {\n    // eslint-disable-next-line no-useless-call -- required for testing\n    method.call(null, argument || function () { return 1; }, 1);\n  });\n};\n\nvar $$3 = _export;\nvar $reduce = arrayReduce.left;\nvar arrayMethodIsStrict = arrayMethodIsStrict$1;\nvar CHROME_VERSION = engineV8Version;\nvar IS_NODE = engineIsNode;\n\nvar STRICT_METHOD = arrayMethodIsStrict('reduce');\n// Chrome 80-82 has a critical bug\n// https://bugs.chromium.org/p/chromium/issues/detail?id=1049982\nvar CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83;\n\n// `Array.prototype.reduce` method\n// https://tc39.es/ecma262/#sec-array.prototype.reduce\n$$3({ target: 'Array', proto: true, forced: !STRICT_METHOD || CHROME_BUG }, {\n  reduce: function reduce(callbackfn /* , initialValue */) {\n    var length = arguments.length;\n    return $reduce(this, callbackfn, length, length > 1 ? arguments[1] : undefined);\n  }\n});\n\nvar anObject$3 = anObject$e;\n\n// `RegExp.prototype.flags` getter implementation\n// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags\nvar regexpFlags$1 = function () {\n  var that = anObject$3(this);\n  var result = '';\n  if (that.hasIndices) result += 'd';\n  if (that.global) result += 'g';\n  if (that.ignoreCase) result += 'i';\n  if (that.multiline) result += 'm';\n  if (that.dotAll) result += 's';\n  if (that.unicode) result += 'u';\n  if (that.unicodeSets) result += 'v';\n  if (that.sticky) result += 'y';\n  return result;\n};\n\nvar fails$b = fails$s;\nvar global$a = global$t;\n\n// babel-minify and Closure Compiler transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError\nvar $RegExp$2 = global$a.RegExp;\n\nvar UNSUPPORTED_Y$2 = fails$b(function () {\n  var re = $RegExp$2('a', 'y');\n  re.lastIndex = 2;\n  return re.exec('abcd') != null;\n});\n\n// UC Browser bug\n// https://github.com/zloirock/core-js/issues/1008\nvar MISSED_STICKY = UNSUPPORTED_Y$2 || fails$b(function () {\n  return !$RegExp$2('a', 'y').sticky;\n});\n\nvar BROKEN_CARET = UNSUPPORTED_Y$2 || fails$b(function () {\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=773687\n  var re = $RegExp$2('^r', 'gy');\n  re.lastIndex = 2;\n  return re.exec('str') != null;\n});\n\nvar regexpStickyHelpers = {\n  BROKEN_CARET: BROKEN_CARET,\n  MISSED_STICKY: MISSED_STICKY,\n  UNSUPPORTED_Y: UNSUPPORTED_Y$2\n};\n\nvar fails$a = fails$s;\nvar global$9 = global$t;\n\n// babel-minify and Closure Compiler transpiles RegExp('.', 's') -> /./s and it causes SyntaxError\nvar $RegExp$1 = global$9.RegExp;\n\nvar regexpUnsupportedDotAll = fails$a(function () {\n  var re = $RegExp$1('.', 's');\n  return !(re.dotAll && re.exec('\\n') && re.flags === 's');\n});\n\nvar fails$9 = fails$s;\nvar global$8 = global$t;\n\n// babel-minify and Closure Compiler transpiles RegExp('(?<a>b)', 'g') -> /(?<a>b)/g and it causes SyntaxError\nvar $RegExp = global$8.RegExp;\n\nvar regexpUnsupportedNcg = fails$9(function () {\n  var re = $RegExp('(?<a>b)', 'g');\n  return re.exec('b').groups.a !== 'b' ||\n    'b'.replace(re, '$<a>c') !== 'bc';\n});\n\n/* eslint-disable regexp/no-empty-capturing-group, regexp/no-empty-group, regexp/no-lazy-ends -- testing */\n/* eslint-disable regexp/no-useless-quantifier -- testing */\nvar call$6 = functionCall;\nvar uncurryThis$8 = functionUncurryThis;\nvar toString$2 = toString$5;\nvar regexpFlags = regexpFlags$1;\nvar stickyHelpers$1 = regexpStickyHelpers;\nvar shared = shared$4.exports;\nvar create$1 = objectCreate;\nvar getInternalState$3 = internalState.get;\nvar UNSUPPORTED_DOT_ALL = regexpUnsupportedDotAll;\nvar UNSUPPORTED_NCG = regexpUnsupportedNcg;\n\nvar nativeReplace = shared('native-string-replace', String.prototype.replace);\nvar nativeExec = RegExp.prototype.exec;\nvar patchedExec = nativeExec;\nvar charAt$2 = uncurryThis$8(''.charAt);\nvar indexOf = uncurryThis$8(''.indexOf);\nvar replace = uncurryThis$8(''.replace);\nvar stringSlice$2 = uncurryThis$8(''.slice);\n\nvar UPDATES_LAST_INDEX_WRONG = (function () {\n  var re1 = /a/;\n  var re2 = /b*/g;\n  call$6(nativeExec, re1, 'a');\n  call$6(nativeExec, re2, 'a');\n  return re1.lastIndex !== 0 || re2.lastIndex !== 0;\n})();\n\nvar UNSUPPORTED_Y$1 = stickyHelpers$1.BROKEN_CARET;\n\n// nonparticipating capturing group, copied from es5-shim's String#split patch.\nvar NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;\n\nvar PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y$1 || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG;\n\nif (PATCH) {\n  patchedExec = function exec(string) {\n    var re = this;\n    var state = getInternalState$3(re);\n    var str = toString$2(string);\n    var raw = state.raw;\n    var result, reCopy, lastIndex, match, i, object, group;\n\n    if (raw) {\n      raw.lastIndex = re.lastIndex;\n      result = call$6(patchedExec, raw, str);\n      re.lastIndex = raw.lastIndex;\n      return result;\n    }\n\n    var groups = state.groups;\n    var sticky = UNSUPPORTED_Y$1 && re.sticky;\n    var flags = call$6(regexpFlags, re);\n    var source = re.source;\n    var charsAdded = 0;\n    var strCopy = str;\n\n    if (sticky) {\n      flags = replace(flags, 'y', '');\n      if (indexOf(flags, 'g') === -1) {\n        flags += 'g';\n      }\n\n      strCopy = stringSlice$2(str, re.lastIndex);\n      // Support anchored sticky behavior.\n      if (re.lastIndex > 0 && (!re.multiline || re.multiline && charAt$2(str, re.lastIndex - 1) !== '\\n')) {\n        source = '(?: ' + source + ')';\n        strCopy = ' ' + strCopy;\n        charsAdded++;\n      }\n      // ^(? + rx + ) is needed, in combination with some str slicing, to\n      // simulate the 'y' flag.\n      reCopy = new RegExp('^(?:' + source + ')', flags);\n    }\n\n    if (NPCG_INCLUDED) {\n      reCopy = new RegExp('^' + source + '$(?!\\\\s)', flags);\n    }\n    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;\n\n    match = call$6(nativeExec, sticky ? reCopy : re, strCopy);\n\n    if (sticky) {\n      if (match) {\n        match.input = stringSlice$2(match.input, charsAdded);\n        match[0] = stringSlice$2(match[0], charsAdded);\n        match.index = re.lastIndex;\n        re.lastIndex += match[0].length;\n      } else re.lastIndex = 0;\n    } else if (UPDATES_LAST_INDEX_WRONG && match) {\n      re.lastIndex = re.global ? match.index + match[0].length : lastIndex;\n    }\n    if (NPCG_INCLUDED && match && match.length > 1) {\n      // Fix browsers whose `exec` methods don't consistently return `undefined`\n      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/\n      call$6(nativeReplace, match[0], reCopy, function () {\n        for (i = 1; i < arguments.length - 2; i++) {\n          if (arguments[i] === undefined) match[i] = undefined;\n        }\n      });\n    }\n\n    if (match && groups) {\n      match.groups = object = create$1(null);\n      for (i = 0; i < groups.length; i++) {\n        group = groups[i];\n        object[group[0]] = match[group[1]];\n      }\n    }\n\n    return match;\n  };\n}\n\nvar regexpExec$3 = patchedExec;\n\nvar $$2 = _export;\nvar exec$1 = regexpExec$3;\n\n// `RegExp.prototype.exec` method\n// https://tc39.es/ecma262/#sec-regexp.prototype.exec\n$$2({ target: 'RegExp', proto: true, forced: /./.exec !== exec$1 }, {\n  exec: exec$1\n});\n\n/* eslint-disable no-useless-escape */\n// https://github.com/DamonOehlman/detect-browser/blob/master/src/index.ts\nconst SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;\nconst userAgentRules = [[\"aol\", /AOLShield\\/([0-9\\._]+)/], [\"edge\", /Edge\\/([0-9\\._]+)/], [\"edge-ios\", /EdgiOS\\/([0-9\\._]+)/], [\"yandexbrowser\", /YaBrowser\\/([0-9\\._]+)/], [\"kakaotalk\", /KAKAOTALK\\s([0-9\\.]+)/], [\"samsung\", /SamsungBrowser\\/([0-9\\.]+)/], [\"silk\", /\\bSilk\\/([0-9._-]+)\\b/], [\"miui\", /MiuiBrowser\\/([0-9\\.]+)$/], [\"beaker\", /BeakerBrowser\\/([0-9\\.]+)/], [\"edge-chromium\", /EdgA?\\/([0-9\\.]+)/], [\"chromium-webview\", /(?!Chrom.*OPR)wv\\).*Chrom(?:e|ium)\\/([0-9\\.]+)(:?\\s|$)/], [\"chrome\", /(?!Chrom.*OPR)Chrom(?:e|ium)\\/([0-9\\.]+)(:?\\s|$)/], [\"phantomjs\", /PhantomJS\\/([0-9\\.]+)(:?\\s|$)/], [\"crios\", /CriOS\\/([0-9\\.]+)(:?\\s|$)/], [\"firefox\", /Firefox\\/([0-9\\.]+)(?:\\s|$)/], [\"fxios\", /FxiOS\\/([0-9\\.]+)/], [\"opera-mini\", /Opera Mini.*Version\\/([0-9\\.]+)/], [\"opera\", /Opera\\/([0-9\\.]+)(?:\\s|$)/], [\"opera\", /OPR\\/([0-9\\.]+)(:?\\s|$)/], [\"pie\", /^Microsoft Pocket Internet Explorer\\/(\\d+\\.\\d+)$/], [\"pie\", /^Mozilla\\/\\d\\.\\d+\\s\\(compatible;\\s(?:MSP?IE|MSInternet Explorer) (\\d+\\.\\d+);.*Windows CE.*\\)$/], [\"netfront\", /^Mozilla\\/\\d\\.\\d+.*NetFront\\/(\\d.\\d)/], [\"ie\", /Trident\\/7\\.0.*rv\\:([0-9\\.]+).*\\).*Gecko$/], [\"ie\", /MSIE\\s([0-9\\.]+);.*Trident\\/[4-7].0/], [\"ie\", /MSIE\\s(7\\.0)/], [\"bb10\", /BB10;\\sTouch.*Version\\/([0-9\\.]+)/], [\"android\", /Android\\s([0-9\\.]+)/], [\"ios\", /Version\\/([0-9\\._]+).*Mobile.*Safari.*/], [\"safari\", /Version\\/([0-9\\._]+).*Safari/], [\"facebook\", /FB[AS]V\\/([0-9\\.]+)/], [\"instagram\", /Instagram\\s([0-9\\.]+)/], [\"ios-webview\", /AppleWebKit\\/([0-9\\.]+).*Mobile/], [\"ios-webview\", /AppleWebKit\\/([0-9\\.]+).*Gecko\\)$/], [\"curl\", /^curl\\/([0-9\\.]+)$/], [\"searchbot\", SEARCHBOX_UA_REGEX]];\nconst matchUserAgent = ua => {\n  return ua !== \"\" && userAgentRules.reduce((matched, [browser, regex]) => {\n    if (matched) {\n      return matched;\n    }\n    const uaMatch = regex.exec(ua);\n    return !!uaMatch && [browser, uaMatch];\n  }, false);\n};\nconst isCurrentBrowserSupported = supportedBrowser => {\n  if (typeof navigator === \"undefined\") {\n    return false;\n  }\n  const matchedRule = matchUserAgent(navigator.userAgent);\n  if (!matchedRule) {\n    return false;\n  }\n  const [name] = matchedRule;\n  if (name === \"searchbot\") {\n    return false;\n  }\n  return !!supportedBrowser.find(item => item === name);\n};\n\n// eslint-disable-next-line es-x/no-typed-arrays -- safe\nvar arrayBufferNative = typeof ArrayBuffer != 'undefined' && typeof DataView != 'undefined';\n\nvar NATIVE_ARRAY_BUFFER$1 = arrayBufferNative;\nvar DESCRIPTORS$2 = descriptors;\nvar global$7 = global$t;\nvar isCallable$2 = isCallable$n;\nvar isObject$4 = isObject$d;\nvar hasOwn$1 = hasOwnProperty_1;\nvar classof$4 = classof$9;\nvar tryToString = tryToString$5;\nvar createNonEnumerableProperty$3 = createNonEnumerableProperty$8;\nvar defineBuiltIn$2 = defineBuiltIn$8;\nvar defineProperty$1 = objectDefineProperty.f;\nvar isPrototypeOf$1 = objectIsPrototypeOf;\nvar getPrototypeOf$1 = objectGetPrototypeOf;\nvar setPrototypeOf$3 = objectSetPrototypeOf;\nvar wellKnownSymbol$2 = wellKnownSymbol$j;\nvar uid = uid$3;\nvar InternalStateModule$2 = internalState;\n\nvar enforceInternalState$1 = InternalStateModule$2.enforce;\nvar getInternalState$2 = InternalStateModule$2.get;\nvar Int8Array$4 = global$7.Int8Array;\nvar Int8ArrayPrototype$1 = Int8Array$4 && Int8Array$4.prototype;\nvar Uint8ClampedArray$1 = global$7.Uint8ClampedArray;\nvar Uint8ClampedArrayPrototype = Uint8ClampedArray$1 && Uint8ClampedArray$1.prototype;\nvar TypedArray$1 = Int8Array$4 && getPrototypeOf$1(Int8Array$4);\nvar TypedArrayPrototype$1 = Int8ArrayPrototype$1 && getPrototypeOf$1(Int8ArrayPrototype$1);\nvar ObjectPrototype$1 = Object.prototype;\nvar TypeError$1 = global$7.TypeError;\n\nvar TO_STRING_TAG = wellKnownSymbol$2('toStringTag');\nvar TYPED_ARRAY_TAG$1 = uid('TYPED_ARRAY_TAG');\nvar TYPED_ARRAY_CONSTRUCTOR = 'TypedArrayConstructor';\n// Fixing native typed arrays in Opera Presto crashes the browser, see #595\nvar NATIVE_ARRAY_BUFFER_VIEWS$2 = NATIVE_ARRAY_BUFFER$1 && !!setPrototypeOf$3 && classof$4(global$7.opera) !== 'Opera';\nvar TYPED_ARRAY_TAG_REQUIRED = false;\nvar NAME, Constructor, Prototype;\n\nvar TypedArrayConstructorsList = {\n  Int8Array: 1,\n  Uint8Array: 1,\n  Uint8ClampedArray: 1,\n  Int16Array: 2,\n  Uint16Array: 2,\n  Int32Array: 4,\n  Uint32Array: 4,\n  Float32Array: 4,\n  Float64Array: 8\n};\n\nvar BigIntArrayConstructorsList = {\n  BigInt64Array: 8,\n  BigUint64Array: 8\n};\n\nvar isView = function isView(it) {\n  if (!isObject$4(it)) return false;\n  var klass = classof$4(it);\n  return klass === 'DataView'\n    || hasOwn$1(TypedArrayConstructorsList, klass)\n    || hasOwn$1(BigIntArrayConstructorsList, klass);\n};\n\nvar getTypedArrayConstructor = function (it) {\n  var proto = getPrototypeOf$1(it);\n  if (!isObject$4(proto)) return;\n  var state = getInternalState$2(proto);\n  return (state && hasOwn$1(state, TYPED_ARRAY_CONSTRUCTOR)) ? state[TYPED_ARRAY_CONSTRUCTOR] : getTypedArrayConstructor(proto);\n};\n\nvar isTypedArray$1 = function (it) {\n  if (!isObject$4(it)) return false;\n  var klass = classof$4(it);\n  return hasOwn$1(TypedArrayConstructorsList, klass)\n    || hasOwn$1(BigIntArrayConstructorsList, klass);\n};\n\nvar aTypedArray$4 = function (it) {\n  if (isTypedArray$1(it)) return it;\n  throw TypeError$1('Target is not a typed array');\n};\n\nvar aTypedArrayConstructor$2 = function (C) {\n  if (isCallable$2(C) && (!setPrototypeOf$3 || isPrototypeOf$1(TypedArray$1, C))) return C;\n  throw TypeError$1(tryToString(C) + ' is not a typed array constructor');\n};\n\nvar exportTypedArrayMethod$4 = function (KEY, property, forced, options) {\n  if (!DESCRIPTORS$2) return;\n  if (forced) for (var ARRAY in TypedArrayConstructorsList) {\n    var TypedArrayConstructor = global$7[ARRAY];\n    if (TypedArrayConstructor && hasOwn$1(TypedArrayConstructor.prototype, KEY)) try {\n      delete TypedArrayConstructor.prototype[KEY];\n    } catch (error) {\n      // old WebKit bug - some methods are non-configurable\n      try {\n        TypedArrayConstructor.prototype[KEY] = property;\n      } catch (error2) { /* empty */ }\n    }\n  }\n  if (!TypedArrayPrototype$1[KEY] || forced) {\n    defineBuiltIn$2(TypedArrayPrototype$1, KEY, forced ? property\n      : NATIVE_ARRAY_BUFFER_VIEWS$2 && Int8ArrayPrototype$1[KEY] || property, options);\n  }\n};\n\nvar exportTypedArrayStaticMethod$1 = function (KEY, property, forced) {\n  var ARRAY, TypedArrayConstructor;\n  if (!DESCRIPTORS$2) return;\n  if (setPrototypeOf$3) {\n    if (forced) for (ARRAY in TypedArrayConstructorsList) {\n      TypedArrayConstructor = global$7[ARRAY];\n      if (TypedArrayConstructor && hasOwn$1(TypedArrayConstructor, KEY)) try {\n        delete TypedArrayConstructor[KEY];\n      } catch (error) { /* empty */ }\n    }\n    if (!TypedArray$1[KEY] || forced) {\n      // V8 ~ Chrome 49-50 `%TypedArray%` methods are non-writable non-configurable\n      try {\n        return defineBuiltIn$2(TypedArray$1, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS$2 && TypedArray$1[KEY] || property);\n      } catch (error) { /* empty */ }\n    } else return;\n  }\n  for (ARRAY in TypedArrayConstructorsList) {\n    TypedArrayConstructor = global$7[ARRAY];\n    if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {\n      defineBuiltIn$2(TypedArrayConstructor, KEY, property);\n    }\n  }\n};\n\nfor (NAME in TypedArrayConstructorsList) {\n  Constructor = global$7[NAME];\n  Prototype = Constructor && Constructor.prototype;\n  if (Prototype) enforceInternalState$1(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;\n  else NATIVE_ARRAY_BUFFER_VIEWS$2 = false;\n}\n\nfor (NAME in BigIntArrayConstructorsList) {\n  Constructor = global$7[NAME];\n  Prototype = Constructor && Constructor.prototype;\n  if (Prototype) enforceInternalState$1(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;\n}\n\n// WebKit bug - typed arrays constructors prototype is Object.prototype\nif (!NATIVE_ARRAY_BUFFER_VIEWS$2 || !isCallable$2(TypedArray$1) || TypedArray$1 === Function.prototype) {\n  // eslint-disable-next-line no-shadow -- safe\n  TypedArray$1 = function TypedArray() {\n    throw TypeError$1('Incorrect invocation');\n  };\n  if (NATIVE_ARRAY_BUFFER_VIEWS$2) for (NAME in TypedArrayConstructorsList) {\n    if (global$7[NAME]) setPrototypeOf$3(global$7[NAME], TypedArray$1);\n  }\n}\n\nif (!NATIVE_ARRAY_BUFFER_VIEWS$2 || !TypedArrayPrototype$1 || TypedArrayPrototype$1 === ObjectPrototype$1) {\n  TypedArrayPrototype$1 = TypedArray$1.prototype;\n  if (NATIVE_ARRAY_BUFFER_VIEWS$2) for (NAME in TypedArrayConstructorsList) {\n    if (global$7[NAME]) setPrototypeOf$3(global$7[NAME].prototype, TypedArrayPrototype$1);\n  }\n}\n\n// WebKit bug - one more object in Uint8ClampedArray prototype chain\nif (NATIVE_ARRAY_BUFFER_VIEWS$2 && getPrototypeOf$1(Uint8ClampedArrayPrototype) !== TypedArrayPrototype$1) {\n  setPrototypeOf$3(Uint8ClampedArrayPrototype, TypedArrayPrototype$1);\n}\n\nif (DESCRIPTORS$2 && !hasOwn$1(TypedArrayPrototype$1, TO_STRING_TAG)) {\n  TYPED_ARRAY_TAG_REQUIRED = true;\n  defineProperty$1(TypedArrayPrototype$1, TO_STRING_TAG, { get: function () {\n    return isObject$4(this) ? this[TYPED_ARRAY_TAG$1] : undefined;\n  } });\n  for (NAME in TypedArrayConstructorsList) if (global$7[NAME]) {\n    createNonEnumerableProperty$3(global$7[NAME], TYPED_ARRAY_TAG$1, NAME);\n  }\n}\n\nvar arrayBufferViewCore = {\n  NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS$2,\n  TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQUIRED && TYPED_ARRAY_TAG$1,\n  aTypedArray: aTypedArray$4,\n  aTypedArrayConstructor: aTypedArrayConstructor$2,\n  exportTypedArrayMethod: exportTypedArrayMethod$4,\n  exportTypedArrayStaticMethod: exportTypedArrayStaticMethod$1,\n  getTypedArrayConstructor: getTypedArrayConstructor,\n  isView: isView,\n  isTypedArray: isTypedArray$1,\n  TypedArray: TypedArray$1,\n  TypedArrayPrototype: TypedArrayPrototype$1\n};\n\n/* eslint-disable no-new -- required for testing */\n\nvar global$6 = global$t;\nvar fails$8 = fails$s;\nvar checkCorrectnessOfIteration = checkCorrectnessOfIteration$2;\nvar NATIVE_ARRAY_BUFFER_VIEWS$1 = arrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;\n\nvar ArrayBuffer$3 = global$6.ArrayBuffer;\nvar Int8Array$3 = global$6.Int8Array;\n\nvar typedArrayConstructorsRequireWrappers = !NATIVE_ARRAY_BUFFER_VIEWS$1 || !fails$8(function () {\n  Int8Array$3(1);\n}) || !fails$8(function () {\n  new Int8Array$3(-1);\n}) || !checkCorrectnessOfIteration(function (iterable) {\n  new Int8Array$3();\n  new Int8Array$3(null);\n  new Int8Array$3(1.5);\n  new Int8Array$3(iterable);\n}, true) || fails$8(function () {\n  // Safari (11+) bug - a reason why even Safari 13 should load a typed array polyfill\n  return new Int8Array$3(new ArrayBuffer$3(2), 1, undefined).length !== 1;\n});\n\nvar bind$1 = functionBindContext;\nvar call$5 = functionCall;\nvar aConstructor = aConstructor$2;\nvar toObject$2 = toObject$7;\nvar lengthOfArrayLike$4 = lengthOfArrayLike$8;\nvar getIterator = getIterator$2;\nvar getIteratorMethod = getIteratorMethod$3;\nvar isArrayIteratorMethod = isArrayIteratorMethod$2;\nvar aTypedArrayConstructor$1 = arrayBufferViewCore.aTypedArrayConstructor;\n\nvar typedArrayFrom$2 = function from(source /* , mapfn, thisArg */) {\n  var C = aConstructor(this);\n  var O = toObject$2(source);\n  var argumentsLength = arguments.length;\n  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;\n  var mapping = mapfn !== undefined;\n  var iteratorMethod = getIteratorMethod(O);\n  var i, length, result, step, iterator, next;\n  if (iteratorMethod && !isArrayIteratorMethod(iteratorMethod)) {\n    iterator = getIterator(O, iteratorMethod);\n    next = iterator.next;\n    O = [];\n    while (!(step = call$5(next, iterator)).done) {\n      O.push(step.value);\n    }\n  }\n  if (mapping && argumentsLength > 2) {\n    mapfn = bind$1(mapfn, arguments[2]);\n  }\n  length = lengthOfArrayLike$4(O);\n  result = new (aTypedArrayConstructor$1(C))(length);\n  for (i = 0; length > i; i++) {\n    result[i] = mapping ? mapfn(O[i], i) : O[i];\n  }\n  return result;\n};\n\nvar TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS$1 = typedArrayConstructorsRequireWrappers;\nvar exportTypedArrayStaticMethod = arrayBufferViewCore.exportTypedArrayStaticMethod;\nvar typedArrayFrom$1 = typedArrayFrom$2;\n\n// `%TypedArray%.from` method\n// https://tc39.es/ecma262/#sec-%typedarray%.from\nexportTypedArrayStaticMethod('from', typedArrayFrom$1, TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS$1);\n\nvar defineBuiltIn$1 = defineBuiltIn$8;\n\nvar defineBuiltIns$1 = function (target, src, options) {\n  for (var key in src) defineBuiltIn$1(target, key, src[key], options);\n  return target;\n};\n\nvar toIntegerOrInfinity$3 = toIntegerOrInfinity$6;\nvar toLength$4 = toLength$6;\n\nvar $RangeError$2 = RangeError;\n\n// `ToIndex` abstract operation\n// https://tc39.es/ecma262/#sec-toindex\nvar toIndex$2 = function (it) {\n  if (it === undefined) return 0;\n  var number = toIntegerOrInfinity$3(it);\n  var length = toLength$4(number);\n  if (number !== length) throw $RangeError$2('Wrong length or index');\n  return length;\n};\n\n// IEEE754 conversions based on https://github.com/feross/ieee754\nvar $Array$2 = Array;\nvar abs = Math.abs;\nvar pow = Math.pow;\nvar floor$2 = Math.floor;\nvar log = Math.log;\nvar LN2 = Math.LN2;\n\nvar pack = function (number, mantissaLength, bytes) {\n  var buffer = $Array$2(bytes);\n  var exponentLength = bytes * 8 - mantissaLength - 1;\n  var eMax = (1 << exponentLength) - 1;\n  var eBias = eMax >> 1;\n  var rt = mantissaLength === 23 ? pow(2, -24) - pow(2, -77) : 0;\n  var sign = number < 0 || number === 0 && 1 / number < 0 ? 1 : 0;\n  var index = 0;\n  var exponent, mantissa, c;\n  number = abs(number);\n  // eslint-disable-next-line no-self-compare -- NaN check\n  if (number != number || number === Infinity) {\n    // eslint-disable-next-line no-self-compare -- NaN check\n    mantissa = number != number ? 1 : 0;\n    exponent = eMax;\n  } else {\n    exponent = floor$2(log(number) / LN2);\n    c = pow(2, -exponent);\n    if (number * c < 1) {\n      exponent--;\n      c *= 2;\n    }\n    if (exponent + eBias >= 1) {\n      number += rt / c;\n    } else {\n      number += rt * pow(2, 1 - eBias);\n    }\n    if (number * c >= 2) {\n      exponent++;\n      c /= 2;\n    }\n    if (exponent + eBias >= eMax) {\n      mantissa = 0;\n      exponent = eMax;\n    } else if (exponent + eBias >= 1) {\n      mantissa = (number * c - 1) * pow(2, mantissaLength);\n      exponent = exponent + eBias;\n    } else {\n      mantissa = number * pow(2, eBias - 1) * pow(2, mantissaLength);\n      exponent = 0;\n    }\n  }\n  while (mantissaLength >= 8) {\n    buffer[index++] = mantissa & 255;\n    mantissa /= 256;\n    mantissaLength -= 8;\n  }\n  exponent = exponent << mantissaLength | mantissa;\n  exponentLength += mantissaLength;\n  while (exponentLength > 0) {\n    buffer[index++] = exponent & 255;\n    exponent /= 256;\n    exponentLength -= 8;\n  }\n  buffer[--index] |= sign * 128;\n  return buffer;\n};\n\nvar unpack = function (buffer, mantissaLength) {\n  var bytes = buffer.length;\n  var exponentLength = bytes * 8 - mantissaLength - 1;\n  var eMax = (1 << exponentLength) - 1;\n  var eBias = eMax >> 1;\n  var nBits = exponentLength - 7;\n  var index = bytes - 1;\n  var sign = buffer[index--];\n  var exponent = sign & 127;\n  var mantissa;\n  sign >>= 7;\n  while (nBits > 0) {\n    exponent = exponent * 256 + buffer[index--];\n    nBits -= 8;\n  }\n  mantissa = exponent & (1 << -nBits) - 1;\n  exponent >>= -nBits;\n  nBits += mantissaLength;\n  while (nBits > 0) {\n    mantissa = mantissa * 256 + buffer[index--];\n    nBits -= 8;\n  }\n  if (exponent === 0) {\n    exponent = 1 - eBias;\n  } else if (exponent === eMax) {\n    return mantissa ? NaN : sign ? -Infinity : Infinity;\n  } else {\n    mantissa = mantissa + pow(2, mantissaLength);\n    exponent = exponent - eBias;\n  } return (sign ? -1 : 1) * mantissa * pow(2, exponent - mantissaLength);\n};\n\nvar ieee754 = {\n  pack: pack,\n  unpack: unpack\n};\n\nvar toObject$1 = toObject$7;\nvar toAbsoluteIndex$2 = toAbsoluteIndex$4;\nvar lengthOfArrayLike$3 = lengthOfArrayLike$8;\n\n// `Array.prototype.fill` method implementation\n// https://tc39.es/ecma262/#sec-array.prototype.fill\nvar arrayFill$1 = function fill(value /* , start = 0, end = @length */) {\n  var O = toObject$1(this);\n  var length = lengthOfArrayLike$3(O);\n  var argumentsLength = arguments.length;\n  var index = toAbsoluteIndex$2(argumentsLength > 1 ? arguments[1] : undefined, length);\n  var end = argumentsLength > 2 ? arguments[2] : undefined;\n  var endPos = end === undefined ? length : toAbsoluteIndex$2(end, length);\n  while (endPos > index) O[index++] = value;\n  return O;\n};\n\nvar toPropertyKey$1 = toPropertyKey$4;\nvar definePropertyModule$1 = objectDefineProperty;\nvar createPropertyDescriptor$1 = createPropertyDescriptor$5;\n\nvar createProperty$1 = function (object, key, value) {\n  var propertyKey = toPropertyKey$1(key);\n  if (propertyKey in object) definePropertyModule$1.f(object, propertyKey, createPropertyDescriptor$1(0, value));\n  else object[propertyKey] = value;\n};\n\nvar toAbsoluteIndex$1 = toAbsoluteIndex$4;\nvar lengthOfArrayLike$2 = lengthOfArrayLike$8;\nvar createProperty = createProperty$1;\n\nvar $Array$1 = Array;\nvar max = Math.max;\n\nvar arraySliceSimple = function (O, start, end) {\n  var length = lengthOfArrayLike$2(O);\n  var k = toAbsoluteIndex$1(start, length);\n  var fin = toAbsoluteIndex$1(end === undefined ? length : end, length);\n  var result = $Array$1(max(fin - k, 0));\n  for (var n = 0; k < fin; k++, n++) createProperty(result, n, O[k]);\n  result.length = n;\n  return result;\n};\n\nvar global$5 = global$t;\nvar uncurryThis$7 = functionUncurryThis;\nvar DESCRIPTORS$1 = descriptors;\nvar NATIVE_ARRAY_BUFFER = arrayBufferNative;\nvar FunctionName = functionName;\nvar createNonEnumerableProperty$2 = createNonEnumerableProperty$8;\nvar defineBuiltIns = defineBuiltIns$1;\nvar fails$7 = fails$s;\nvar anInstance$1 = anInstance$3;\nvar toIntegerOrInfinity$2 = toIntegerOrInfinity$6;\nvar toLength$3 = toLength$6;\nvar toIndex$1 = toIndex$2;\nvar IEEE754 = ieee754;\nvar getPrototypeOf = objectGetPrototypeOf;\nvar setPrototypeOf$2 = objectSetPrototypeOf;\nvar getOwnPropertyNames$1 = objectGetOwnPropertyNames.f;\nvar defineProperty = objectDefineProperty.f;\nvar arrayFill = arrayFill$1;\nvar arraySlice$3 = arraySliceSimple;\nvar setToStringTag = setToStringTag$4;\nvar InternalStateModule$1 = internalState;\n\nvar PROPER_FUNCTION_NAME = FunctionName.PROPER;\nvar CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;\nvar getInternalState$1 = InternalStateModule$1.get;\nvar setInternalState$1 = InternalStateModule$1.set;\nvar ARRAY_BUFFER = 'ArrayBuffer';\nvar DATA_VIEW = 'DataView';\nvar PROTOTYPE = 'prototype';\nvar WRONG_LENGTH$1 = 'Wrong length';\nvar WRONG_INDEX = 'Wrong index';\nvar NativeArrayBuffer = global$5[ARRAY_BUFFER];\nvar $ArrayBuffer = NativeArrayBuffer;\nvar ArrayBufferPrototype$1 = $ArrayBuffer && $ArrayBuffer[PROTOTYPE];\nvar $DataView = global$5[DATA_VIEW];\nvar DataViewPrototype$1 = $DataView && $DataView[PROTOTYPE];\nvar ObjectPrototype = Object.prototype;\nvar Array$1 = global$5.Array;\nvar RangeError$3 = global$5.RangeError;\nvar fill = uncurryThis$7(arrayFill);\nvar reverse = uncurryThis$7([].reverse);\n\nvar packIEEE754 = IEEE754.pack;\nvar unpackIEEE754 = IEEE754.unpack;\n\nvar packInt8 = function (number) {\n  return [number & 0xFF];\n};\n\nvar packInt16 = function (number) {\n  return [number & 0xFF, number >> 8 & 0xFF];\n};\n\nvar packInt32 = function (number) {\n  return [number & 0xFF, number >> 8 & 0xFF, number >> 16 & 0xFF, number >> 24 & 0xFF];\n};\n\nvar unpackInt32 = function (buffer) {\n  return buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];\n};\n\nvar packFloat32 = function (number) {\n  return packIEEE754(number, 23, 4);\n};\n\nvar packFloat64 = function (number) {\n  return packIEEE754(number, 52, 8);\n};\n\nvar addGetter$1 = function (Constructor, key) {\n  defineProperty(Constructor[PROTOTYPE], key, { get: function () { return getInternalState$1(this)[key]; } });\n};\n\nvar get = function (view, count, index, isLittleEndian) {\n  var intIndex = toIndex$1(index);\n  var store = getInternalState$1(view);\n  if (intIndex + count > store.byteLength) throw RangeError$3(WRONG_INDEX);\n  var bytes = getInternalState$1(store.buffer).bytes;\n  var start = intIndex + store.byteOffset;\n  var pack = arraySlice$3(bytes, start, start + count);\n  return isLittleEndian ? pack : reverse(pack);\n};\n\nvar set = function (view, count, index, conversion, value, isLittleEndian) {\n  var intIndex = toIndex$1(index);\n  var store = getInternalState$1(view);\n  if (intIndex + count > store.byteLength) throw RangeError$3(WRONG_INDEX);\n  var bytes = getInternalState$1(store.buffer).bytes;\n  var start = intIndex + store.byteOffset;\n  var pack = conversion(+value);\n  for (var i = 0; i < count; i++) bytes[start + i] = pack[isLittleEndian ? i : count - i - 1];\n};\n\nif (!NATIVE_ARRAY_BUFFER) {\n  $ArrayBuffer = function ArrayBuffer(length) {\n    anInstance$1(this, ArrayBufferPrototype$1);\n    var byteLength = toIndex$1(length);\n    setInternalState$1(this, {\n      bytes: fill(Array$1(byteLength), 0),\n      byteLength: byteLength\n    });\n    if (!DESCRIPTORS$1) this.byteLength = byteLength;\n  };\n\n  ArrayBufferPrototype$1 = $ArrayBuffer[PROTOTYPE];\n\n  $DataView = function DataView(buffer, byteOffset, byteLength) {\n    anInstance$1(this, DataViewPrototype$1);\n    anInstance$1(buffer, ArrayBufferPrototype$1);\n    var bufferLength = getInternalState$1(buffer).byteLength;\n    var offset = toIntegerOrInfinity$2(byteOffset);\n    if (offset < 0 || offset > bufferLength) throw RangeError$3('Wrong offset');\n    byteLength = byteLength === undefined ? bufferLength - offset : toLength$3(byteLength);\n    if (offset + byteLength > bufferLength) throw RangeError$3(WRONG_LENGTH$1);\n    setInternalState$1(this, {\n      buffer: buffer,\n      byteLength: byteLength,\n      byteOffset: offset\n    });\n    if (!DESCRIPTORS$1) {\n      this.buffer = buffer;\n      this.byteLength = byteLength;\n      this.byteOffset = offset;\n    }\n  };\n\n  DataViewPrototype$1 = $DataView[PROTOTYPE];\n\n  if (DESCRIPTORS$1) {\n    addGetter$1($ArrayBuffer, 'byteLength');\n    addGetter$1($DataView, 'buffer');\n    addGetter$1($DataView, 'byteLength');\n    addGetter$1($DataView, 'byteOffset');\n  }\n\n  defineBuiltIns(DataViewPrototype$1, {\n    getInt8: function getInt8(byteOffset) {\n      return get(this, 1, byteOffset)[0] << 24 >> 24;\n    },\n    getUint8: function getUint8(byteOffset) {\n      return get(this, 1, byteOffset)[0];\n    },\n    getInt16: function getInt16(byteOffset /* , littleEndian */) {\n      var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);\n      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;\n    },\n    getUint16: function getUint16(byteOffset /* , littleEndian */) {\n      var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);\n      return bytes[1] << 8 | bytes[0];\n    },\n    getInt32: function getInt32(byteOffset /* , littleEndian */) {\n      return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined));\n    },\n    getUint32: function getUint32(byteOffset /* , littleEndian */) {\n      return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined)) >>> 0;\n    },\n    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {\n      return unpackIEEE754(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 23);\n    },\n    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {\n      return unpackIEEE754(get(this, 8, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 52);\n    },\n    setInt8: function setInt8(byteOffset, value) {\n      set(this, 1, byteOffset, packInt8, value);\n    },\n    setUint8: function setUint8(byteOffset, value) {\n      set(this, 1, byteOffset, packInt8, value);\n    },\n    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {\n      set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);\n    },\n    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {\n      set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);\n    },\n    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {\n      set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);\n    },\n    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {\n      set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);\n    },\n    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {\n      set(this, 4, byteOffset, packFloat32, value, arguments.length > 2 ? arguments[2] : undefined);\n    },\n    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {\n      set(this, 8, byteOffset, packFloat64, value, arguments.length > 2 ? arguments[2] : undefined);\n    }\n  });\n} else {\n  var INCORRECT_ARRAY_BUFFER_NAME = PROPER_FUNCTION_NAME && NativeArrayBuffer.name !== ARRAY_BUFFER;\n  /* eslint-disable no-new -- required for testing */\n  if (!fails$7(function () {\n    NativeArrayBuffer(1);\n  }) || !fails$7(function () {\n    new NativeArrayBuffer(-1);\n  }) || fails$7(function () {\n    new NativeArrayBuffer();\n    new NativeArrayBuffer(1.5);\n    new NativeArrayBuffer(NaN);\n    return INCORRECT_ARRAY_BUFFER_NAME && !CONFIGURABLE_FUNCTION_NAME;\n  })) {\n  /* eslint-enable no-new -- required for testing */\n    $ArrayBuffer = function ArrayBuffer(length) {\n      anInstance$1(this, ArrayBufferPrototype$1);\n      return new NativeArrayBuffer(toIndex$1(length));\n    };\n\n    $ArrayBuffer[PROTOTYPE] = ArrayBufferPrototype$1;\n\n    for (var keys = getOwnPropertyNames$1(NativeArrayBuffer), j = 0, key; keys.length > j;) {\n      if (!((key = keys[j++]) in $ArrayBuffer)) {\n        createNonEnumerableProperty$2($ArrayBuffer, key, NativeArrayBuffer[key]);\n      }\n    }\n\n    ArrayBufferPrototype$1.constructor = $ArrayBuffer;\n  } else if (INCORRECT_ARRAY_BUFFER_NAME && CONFIGURABLE_FUNCTION_NAME) {\n    createNonEnumerableProperty$2(NativeArrayBuffer, 'name', ARRAY_BUFFER);\n  }\n\n  // WebKit bug - the same parent prototype for typed arrays and data view\n  if (setPrototypeOf$2 && getPrototypeOf(DataViewPrototype$1) !== ObjectPrototype) {\n    setPrototypeOf$2(DataViewPrototype$1, ObjectPrototype);\n  }\n\n  // iOS Safari 7.x bug\n  var testView = new $DataView(new $ArrayBuffer(2));\n  var $setInt8 = uncurryThis$7(DataViewPrototype$1.setInt8);\n  testView.setInt8(0, 2147483648);\n  testView.setInt8(1, 2147483649);\n  if (testView.getInt8(0) || !testView.getInt8(1)) defineBuiltIns(DataViewPrototype$1, {\n    setInt8: function setInt8(byteOffset, value) {\n      $setInt8(this, byteOffset, value << 24 >> 24);\n    },\n    setUint8: function setUint8(byteOffset, value) {\n      $setInt8(this, byteOffset, value << 24 >> 24);\n    }\n  }, { unsafe: true });\n}\n\nsetToStringTag($ArrayBuffer, ARRAY_BUFFER);\nsetToStringTag($DataView, DATA_VIEW);\n\nvar arrayBuffer = {\n  ArrayBuffer: $ArrayBuffer,\n  DataView: $DataView\n};\n\nvar $$1 = _export;\nvar uncurryThis$6 = functionUncurryThis;\nvar fails$6 = fails$s;\nvar ArrayBufferModule$1 = arrayBuffer;\nvar anObject$2 = anObject$e;\nvar toAbsoluteIndex = toAbsoluteIndex$4;\nvar toLength$2 = toLength$6;\nvar speciesConstructor$1 = speciesConstructor$3;\n\nvar ArrayBuffer$2 = ArrayBufferModule$1.ArrayBuffer;\nvar DataView$2 = ArrayBufferModule$1.DataView;\nvar DataViewPrototype = DataView$2.prototype;\nvar un$ArrayBufferSlice = uncurryThis$6(ArrayBuffer$2.prototype.slice);\nvar getUint8 = uncurryThis$6(DataViewPrototype.getUint8);\nvar setUint8 = uncurryThis$6(DataViewPrototype.setUint8);\n\nvar INCORRECT_SLICE = fails$6(function () {\n  return !new ArrayBuffer$2(2).slice(1, undefined).byteLength;\n});\n\n// `ArrayBuffer.prototype.slice` method\n// https://tc39.es/ecma262/#sec-arraybuffer.prototype.slice\n$$1({ target: 'ArrayBuffer', proto: true, unsafe: true, forced: INCORRECT_SLICE }, {\n  slice: function slice(start, end) {\n    if (un$ArrayBufferSlice && end === undefined) {\n      return un$ArrayBufferSlice(anObject$2(this), start); // FF fix\n    }\n    var length = anObject$2(this).byteLength;\n    var first = toAbsoluteIndex(start, length);\n    var fin = toAbsoluteIndex(end === undefined ? length : end, length);\n    var result = new (speciesConstructor$1(this, ArrayBuffer$2))(toLength$2(fin - first));\n    var viewSource = new DataView$2(this);\n    var viewTarget = new DataView$2(result);\n    var index = 0;\n    while (first < fin) {\n      setUint8(viewTarget, index++, getUint8(viewSource, first++));\n    } return result;\n  }\n});\n\nvar typedArrayConstructor = {exports: {}};\n\nvar isObject$3 = isObject$d;\n\nvar floor$1 = Math.floor;\n\n// `IsIntegralNumber` abstract operation\n// https://tc39.es/ecma262/#sec-isintegralnumber\n// eslint-disable-next-line es-x/no-number-isinteger -- safe\nvar isIntegralNumber$1 = Number.isInteger || function isInteger(it) {\n  return !isObject$3(it) && isFinite(it) && floor$1(it) === it;\n};\n\nvar toIntegerOrInfinity$1 = toIntegerOrInfinity$6;\n\nvar $RangeError$1 = RangeError;\n\nvar toPositiveInteger$1 = function (it) {\n  var result = toIntegerOrInfinity$1(it);\n  if (result < 0) throw $RangeError$1(\"The argument can't be less than 0\");\n  return result;\n};\n\nvar toPositiveInteger = toPositiveInteger$1;\n\nvar $RangeError = RangeError;\n\nvar toOffset$2 = function (it, BYTES) {\n  var offset = toPositiveInteger(it);\n  if (offset % BYTES) throw $RangeError('Wrong offset');\n  return offset;\n};\n\nvar classof$3 = classofRaw$1;\n\n// `IsArray` abstract operation\n// https://tc39.es/ecma262/#sec-isarray\n// eslint-disable-next-line es-x/no-array-isarray -- safe\nvar isArray$1 = Array.isArray || function isArray(argument) {\n  return classof$3(argument) == 'Array';\n};\n\nvar isArray = isArray$1;\nvar isConstructor = isConstructor$2;\nvar isObject$2 = isObject$d;\nvar wellKnownSymbol$1 = wellKnownSymbol$j;\n\nvar SPECIES$1 = wellKnownSymbol$1('species');\nvar $Array = Array;\n\n// a part of `ArraySpeciesCreate` abstract operation\n// https://tc39.es/ecma262/#sec-arrayspeciescreate\nvar arraySpeciesConstructor$1 = function (originalArray) {\n  var C;\n  if (isArray(originalArray)) {\n    C = originalArray.constructor;\n    // cross-realm fallback\n    if (isConstructor(C) && (C === $Array || isArray(C.prototype))) C = undefined;\n    else if (isObject$2(C)) {\n      C = C[SPECIES$1];\n      if (C === null) C = undefined;\n    }\n  } return C === undefined ? $Array : C;\n};\n\nvar arraySpeciesConstructor = arraySpeciesConstructor$1;\n\n// `ArraySpeciesCreate` abstract operation\n// https://tc39.es/ecma262/#sec-arrayspeciescreate\nvar arraySpeciesCreate$1 = function (originalArray, length) {\n  return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);\n};\n\nvar bind = functionBindContext;\nvar uncurryThis$5 = functionUncurryThis;\nvar IndexedObject = indexedObject;\nvar toObject = toObject$7;\nvar lengthOfArrayLike$1 = lengthOfArrayLike$8;\nvar arraySpeciesCreate = arraySpeciesCreate$1;\n\nvar push$1 = uncurryThis$5([].push);\n\n// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterReject }` methods implementation\nvar createMethod$1 = function (TYPE) {\n  var IS_MAP = TYPE == 1;\n  var IS_FILTER = TYPE == 2;\n  var IS_SOME = TYPE == 3;\n  var IS_EVERY = TYPE == 4;\n  var IS_FIND_INDEX = TYPE == 6;\n  var IS_FILTER_REJECT = TYPE == 7;\n  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;\n  return function ($this, callbackfn, that, specificCreate) {\n    var O = toObject($this);\n    var self = IndexedObject(O);\n    var boundFunction = bind(callbackfn, that);\n    var length = lengthOfArrayLike$1(self);\n    var index = 0;\n    var create = specificCreate || arraySpeciesCreate;\n    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : undefined;\n    var value, result;\n    for (;length > index; index++) if (NO_HOLES || index in self) {\n      value = self[index];\n      result = boundFunction(value, index, O);\n      if (TYPE) {\n        if (IS_MAP) target[index] = result; // map\n        else if (result) switch (TYPE) {\n          case 3: return true;              // some\n          case 5: return value;             // find\n          case 6: return index;             // findIndex\n          case 2: push$1(target, value);      // filter\n        } else switch (TYPE) {\n          case 4: return false;             // every\n          case 7: push$1(target, value);      // filterReject\n        }\n      }\n    }\n    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;\n  };\n};\n\nvar arrayIteration = {\n  // `Array.prototype.forEach` method\n  // https://tc39.es/ecma262/#sec-array.prototype.foreach\n  forEach: createMethod$1(0),\n  // `Array.prototype.map` method\n  // https://tc39.es/ecma262/#sec-array.prototype.map\n  map: createMethod$1(1),\n  // `Array.prototype.filter` method\n  // https://tc39.es/ecma262/#sec-array.prototype.filter\n  filter: createMethod$1(2),\n  // `Array.prototype.some` method\n  // https://tc39.es/ecma262/#sec-array.prototype.some\n  some: createMethod$1(3),\n  // `Array.prototype.every` method\n  // https://tc39.es/ecma262/#sec-array.prototype.every\n  every: createMethod$1(4),\n  // `Array.prototype.find` method\n  // https://tc39.es/ecma262/#sec-array.prototype.find\n  find: createMethod$1(5),\n  // `Array.prototype.findIndex` method\n  // https://tc39.es/ecma262/#sec-array.prototype.findIndex\n  findIndex: createMethod$1(6),\n  // `Array.prototype.filterReject` method\n  // https://github.com/tc39/proposal-array-filtering\n  filterReject: createMethod$1(7)\n};\n\nvar isCallable$1 = isCallable$n;\nvar isObject$1 = isObject$d;\nvar setPrototypeOf$1 = objectSetPrototypeOf;\n\n// makes subclassing work correct for wrapped built-ins\nvar inheritIfRequired$1 = function ($this, dummy, Wrapper) {\n  var NewTarget, NewTargetPrototype;\n  if (\n    // it can work only with native `setPrototypeOf`\n    setPrototypeOf$1 &&\n    // we haven't completely correct pre-ES6 way for getting `new.target`, so use this\n    isCallable$1(NewTarget = dummy.constructor) &&\n    NewTarget !== Wrapper &&\n    isObject$1(NewTargetPrototype = NewTarget.prototype) &&\n    NewTargetPrototype !== Wrapper.prototype\n  ) setPrototypeOf$1($this, NewTargetPrototype);\n  return $this;\n};\n\nvar $ = _export;\nvar global$4 = global$t;\nvar call$4 = functionCall;\nvar DESCRIPTORS = descriptors;\nvar TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = typedArrayConstructorsRequireWrappers;\nvar ArrayBufferViewCore$4 = arrayBufferViewCore;\nvar ArrayBufferModule = arrayBuffer;\nvar anInstance = anInstance$3;\nvar createPropertyDescriptor = createPropertyDescriptor$5;\nvar createNonEnumerableProperty$1 = createNonEnumerableProperty$8;\nvar isIntegralNumber = isIntegralNumber$1;\nvar toLength$1 = toLength$6;\nvar toIndex = toIndex$2;\nvar toOffset$1 = toOffset$2;\nvar toPropertyKey = toPropertyKey$4;\nvar hasOwn = hasOwnProperty_1;\nvar classof$2 = classof$9;\nvar isObject = isObject$d;\nvar isSymbol = isSymbol$3;\nvar create = objectCreate;\nvar isPrototypeOf = objectIsPrototypeOf;\nvar setPrototypeOf = objectSetPrototypeOf;\nvar getOwnPropertyNames = objectGetOwnPropertyNames.f;\nvar typedArrayFrom = typedArrayFrom$2;\nvar forEach = arrayIteration.forEach;\nvar setSpecies = setSpecies$2;\nvar definePropertyModule = objectDefineProperty;\nvar getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;\nvar InternalStateModule = internalState;\nvar inheritIfRequired = inheritIfRequired$1;\n\nvar getInternalState = InternalStateModule.get;\nvar setInternalState = InternalStateModule.set;\nvar enforceInternalState = InternalStateModule.enforce;\nvar nativeDefineProperty = definePropertyModule.f;\nvar nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\nvar round = Math.round;\nvar RangeError$2 = global$4.RangeError;\nvar ArrayBuffer$1 = ArrayBufferModule.ArrayBuffer;\nvar ArrayBufferPrototype = ArrayBuffer$1.prototype;\nvar DataView$1 = ArrayBufferModule.DataView;\nvar NATIVE_ARRAY_BUFFER_VIEWS = ArrayBufferViewCore$4.NATIVE_ARRAY_BUFFER_VIEWS;\nvar TYPED_ARRAY_TAG = ArrayBufferViewCore$4.TYPED_ARRAY_TAG;\nvar TypedArray = ArrayBufferViewCore$4.TypedArray;\nvar TypedArrayPrototype = ArrayBufferViewCore$4.TypedArrayPrototype;\nvar aTypedArrayConstructor = ArrayBufferViewCore$4.aTypedArrayConstructor;\nvar isTypedArray = ArrayBufferViewCore$4.isTypedArray;\nvar BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';\nvar WRONG_LENGTH = 'Wrong length';\n\nvar fromList = function (C, list) {\n  aTypedArrayConstructor(C);\n  var index = 0;\n  var length = list.length;\n  var result = new C(length);\n  while (length > index) result[index] = list[index++];\n  return result;\n};\n\nvar addGetter = function (it, key) {\n  nativeDefineProperty(it, key, { get: function () {\n    return getInternalState(this)[key];\n  } });\n};\n\nvar isArrayBuffer = function (it) {\n  var klass;\n  return isPrototypeOf(ArrayBufferPrototype, it) || (klass = classof$2(it)) == 'ArrayBuffer' || klass == 'SharedArrayBuffer';\n};\n\nvar isTypedArrayIndex = function (target, key) {\n  return isTypedArray(target)\n    && !isSymbol(key)\n    && key in target\n    && isIntegralNumber(+key)\n    && key >= 0;\n};\n\nvar wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor(target, key) {\n  key = toPropertyKey(key);\n  return isTypedArrayIndex(target, key)\n    ? createPropertyDescriptor(2, target[key])\n    : nativeGetOwnPropertyDescriptor(target, key);\n};\n\nvar wrappedDefineProperty = function defineProperty(target, key, descriptor) {\n  key = toPropertyKey(key);\n  if (isTypedArrayIndex(target, key)\n    && isObject(descriptor)\n    && hasOwn(descriptor, 'value')\n    && !hasOwn(descriptor, 'get')\n    && !hasOwn(descriptor, 'set')\n    // TODO: add validation descriptor w/o calling accessors\n    && !descriptor.configurable\n    && (!hasOwn(descriptor, 'writable') || descriptor.writable)\n    && (!hasOwn(descriptor, 'enumerable') || descriptor.enumerable)\n  ) {\n    target[key] = descriptor.value;\n    return target;\n  } return nativeDefineProperty(target, key, descriptor);\n};\n\nif (DESCRIPTORS) {\n  if (!NATIVE_ARRAY_BUFFER_VIEWS) {\n    getOwnPropertyDescriptorModule.f = wrappedGetOwnPropertyDescriptor;\n    definePropertyModule.f = wrappedDefineProperty;\n    addGetter(TypedArrayPrototype, 'buffer');\n    addGetter(TypedArrayPrototype, 'byteOffset');\n    addGetter(TypedArrayPrototype, 'byteLength');\n    addGetter(TypedArrayPrototype, 'length');\n  }\n\n  $({ target: 'Object', stat: true, forced: !NATIVE_ARRAY_BUFFER_VIEWS }, {\n    getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,\n    defineProperty: wrappedDefineProperty\n  });\n\n  typedArrayConstructor.exports = function (TYPE, wrapper, CLAMPED) {\n    var BYTES = TYPE.match(/\\d+$/)[0] / 8;\n    var CONSTRUCTOR_NAME = TYPE + (CLAMPED ? 'Clamped' : '') + 'Array';\n    var GETTER = 'get' + TYPE;\n    var SETTER = 'set' + TYPE;\n    var NativeTypedArrayConstructor = global$4[CONSTRUCTOR_NAME];\n    var TypedArrayConstructor = NativeTypedArrayConstructor;\n    var TypedArrayConstructorPrototype = TypedArrayConstructor && TypedArrayConstructor.prototype;\n    var exported = {};\n\n    var getter = function (that, index) {\n      var data = getInternalState(that);\n      return data.view[GETTER](index * BYTES + data.byteOffset, true);\n    };\n\n    var setter = function (that, index, value) {\n      var data = getInternalState(that);\n      if (CLAMPED) value = (value = round(value)) < 0 ? 0 : value > 0xFF ? 0xFF : value & 0xFF;\n      data.view[SETTER](index * BYTES + data.byteOffset, value, true);\n    };\n\n    var addElement = function (that, index) {\n      nativeDefineProperty(that, index, {\n        get: function () {\n          return getter(this, index);\n        },\n        set: function (value) {\n          return setter(this, index, value);\n        },\n        enumerable: true\n      });\n    };\n\n    if (!NATIVE_ARRAY_BUFFER_VIEWS) {\n      TypedArrayConstructor = wrapper(function (that, data, offset, $length) {\n        anInstance(that, TypedArrayConstructorPrototype);\n        var index = 0;\n        var byteOffset = 0;\n        var buffer, byteLength, length;\n        if (!isObject(data)) {\n          length = toIndex(data);\n          byteLength = length * BYTES;\n          buffer = new ArrayBuffer$1(byteLength);\n        } else if (isArrayBuffer(data)) {\n          buffer = data;\n          byteOffset = toOffset$1(offset, BYTES);\n          var $len = data.byteLength;\n          if ($length === undefined) {\n            if ($len % BYTES) throw RangeError$2(WRONG_LENGTH);\n            byteLength = $len - byteOffset;\n            if (byteLength < 0) throw RangeError$2(WRONG_LENGTH);\n          } else {\n            byteLength = toLength$1($length) * BYTES;\n            if (byteLength + byteOffset > $len) throw RangeError$2(WRONG_LENGTH);\n          }\n          length = byteLength / BYTES;\n        } else if (isTypedArray(data)) {\n          return fromList(TypedArrayConstructor, data);\n        } else {\n          return call$4(typedArrayFrom, TypedArrayConstructor, data);\n        }\n        setInternalState(that, {\n          buffer: buffer,\n          byteOffset: byteOffset,\n          byteLength: byteLength,\n          length: length,\n          view: new DataView$1(buffer)\n        });\n        while (index < length) addElement(that, index++);\n      });\n\n      if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);\n      TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = create(TypedArrayPrototype);\n    } else if (TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS) {\n      TypedArrayConstructor = wrapper(function (dummy, data, typedArrayOffset, $length) {\n        anInstance(dummy, TypedArrayConstructorPrototype);\n        return inheritIfRequired(function () {\n          if (!isObject(data)) return new NativeTypedArrayConstructor(toIndex(data));\n          if (isArrayBuffer(data)) return $length !== undefined\n            ? new NativeTypedArrayConstructor(data, toOffset$1(typedArrayOffset, BYTES), $length)\n            : typedArrayOffset !== undefined\n              ? new NativeTypedArrayConstructor(data, toOffset$1(typedArrayOffset, BYTES))\n              : new NativeTypedArrayConstructor(data);\n          if (isTypedArray(data)) return fromList(TypedArrayConstructor, data);\n          return call$4(typedArrayFrom, TypedArrayConstructor, data);\n        }(), dummy, TypedArrayConstructor);\n      });\n\n      if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);\n      forEach(getOwnPropertyNames(NativeTypedArrayConstructor), function (key) {\n        if (!(key in TypedArrayConstructor)) {\n          createNonEnumerableProperty$1(TypedArrayConstructor, key, NativeTypedArrayConstructor[key]);\n        }\n      });\n      TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;\n    }\n\n    if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) {\n      createNonEnumerableProperty$1(TypedArrayConstructorPrototype, 'constructor', TypedArrayConstructor);\n    }\n\n    enforceInternalState(TypedArrayConstructorPrototype).TypedArrayConstructor = TypedArrayConstructor;\n\n    if (TYPED_ARRAY_TAG) {\n      createNonEnumerableProperty$1(TypedArrayConstructorPrototype, TYPED_ARRAY_TAG, CONSTRUCTOR_NAME);\n    }\n\n    var FORCED = TypedArrayConstructor != NativeTypedArrayConstructor;\n\n    exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;\n\n    $({ global: true, constructor: true, forced: FORCED, sham: !NATIVE_ARRAY_BUFFER_VIEWS }, exported);\n\n    if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {\n      createNonEnumerableProperty$1(TypedArrayConstructor, BYTES_PER_ELEMENT, BYTES);\n    }\n\n    if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {\n      createNonEnumerableProperty$1(TypedArrayConstructorPrototype, BYTES_PER_ELEMENT, BYTES);\n    }\n\n    setSpecies(CONSTRUCTOR_NAME);\n  };\n} else typedArrayConstructor.exports = function () { /* empty */ };\n\nvar createTypedArrayConstructor = typedArrayConstructor.exports;\n\n// `Uint8Array` constructor\n// https://tc39.es/ecma262/#sec-typedarray-objects\ncreateTypedArrayConstructor('Uint8', function (init) {\n  return function Uint8Array(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n});\n\nvar toPrimitive = toPrimitive$2;\n\nvar $TypeError$1 = TypeError;\n\n// `ToBigInt` abstract operation\n// https://tc39.es/ecma262/#sec-tobigint\nvar toBigInt$1 = function (argument) {\n  var prim = toPrimitive(argument, 'number');\n  if (typeof prim == 'number') throw $TypeError$1(\"Can't convert number to bigint\");\n  // eslint-disable-next-line es-x/no-bigint -- safe\n  return BigInt(prim);\n};\n\nvar ArrayBufferViewCore$3 = arrayBufferViewCore;\nvar $fill = arrayFill$1;\nvar toBigInt = toBigInt$1;\nvar classof$1 = classof$9;\nvar call$3 = functionCall;\nvar uncurryThis$4 = functionUncurryThis;\nvar fails$5 = fails$s;\n\nvar aTypedArray$3 = ArrayBufferViewCore$3.aTypedArray;\nvar exportTypedArrayMethod$3 = ArrayBufferViewCore$3.exportTypedArrayMethod;\nvar slice = uncurryThis$4(''.slice);\n\n// V8 ~ Chrome < 59, Safari < 14.1, FF < 55, Edge <=18\nvar CONVERSION_BUG = fails$5(function () {\n  var count = 0;\n  // eslint-disable-next-line es-x/no-typed-arrays -- safe\n  new Int8Array(2).fill({ valueOf: function () { return count++; } });\n  return count !== 1;\n});\n\n// `%TypedArray%.prototype.fill` method\n// https://tc39.es/ecma262/#sec-%typedarray%.prototype.fill\nexportTypedArrayMethod$3('fill', function fill(value /* , start, end */) {\n  var length = arguments.length;\n  aTypedArray$3(this);\n  var actualValue = slice(classof$1(this), 0, 3) === 'Big' ? toBigInt(value) : +value;\n  return call$3($fill, this, actualValue, length > 1 ? arguments[1] : undefined, length > 2 ? arguments[2] : undefined);\n}, CONVERSION_BUG);\n\nvar global$3 = global$t;\nvar call$2 = functionCall;\nvar ArrayBufferViewCore$2 = arrayBufferViewCore;\nvar lengthOfArrayLike = lengthOfArrayLike$8;\nvar toOffset = toOffset$2;\nvar toIndexedObject = toObject$7;\nvar fails$4 = fails$s;\n\nvar RangeError$1 = global$3.RangeError;\nvar Int8Array$2 = global$3.Int8Array;\nvar Int8ArrayPrototype = Int8Array$2 && Int8Array$2.prototype;\nvar $set = Int8ArrayPrototype && Int8ArrayPrototype.set;\nvar aTypedArray$2 = ArrayBufferViewCore$2.aTypedArray;\nvar exportTypedArrayMethod$2 = ArrayBufferViewCore$2.exportTypedArrayMethod;\n\nvar WORKS_WITH_OBJECTS_AND_GEERIC_ON_TYPED_ARRAYS = !fails$4(function () {\n  // eslint-disable-next-line es-x/no-typed-arrays -- required for testing\n  var array = new Uint8ClampedArray(2);\n  call$2($set, array, { length: 1, 0: 3 }, 1);\n  return array[1] !== 3;\n});\n\n// https://bugs.chromium.org/p/v8/issues/detail?id=11294 and other\nvar TO_OBJECT_BUG = WORKS_WITH_OBJECTS_AND_GEERIC_ON_TYPED_ARRAYS && ArrayBufferViewCore$2.NATIVE_ARRAY_BUFFER_VIEWS && fails$4(function () {\n  var array = new Int8Array$2(2);\n  array.set(1);\n  array.set('2', 1);\n  return array[0] !== 0 || array[1] !== 2;\n});\n\n// `%TypedArray%.prototype.set` method\n// https://tc39.es/ecma262/#sec-%typedarray%.prototype.set\nexportTypedArrayMethod$2('set', function set(arrayLike /* , offset */) {\n  aTypedArray$2(this);\n  var offset = toOffset(arguments.length > 1 ? arguments[1] : undefined, 1);\n  var src = toIndexedObject(arrayLike);\n  if (WORKS_WITH_OBJECTS_AND_GEERIC_ON_TYPED_ARRAYS) return call$2($set, this, src, offset);\n  var length = this.length;\n  var len = lengthOfArrayLike(src);\n  var index = 0;\n  if (len + offset > length) throw RangeError$1('Wrong length');\n  while (index < len) this[offset + index] = src[index++];\n}, !WORKS_WITH_OBJECTS_AND_GEERIC_ON_TYPED_ARRAYS || TO_OBJECT_BUG);\n\nvar arraySlice$2 = arraySliceSimple;\n\nvar floor = Math.floor;\n\nvar mergeSort = function (array, comparefn) {\n  var length = array.length;\n  var middle = floor(length / 2);\n  return length < 8 ? insertionSort(array, comparefn) : merge(\n    array,\n    mergeSort(arraySlice$2(array, 0, middle), comparefn),\n    mergeSort(arraySlice$2(array, middle), comparefn),\n    comparefn\n  );\n};\n\nvar insertionSort = function (array, comparefn) {\n  var length = array.length;\n  var i = 1;\n  var element, j;\n\n  while (i < length) {\n    j = i;\n    element = array[i];\n    while (j && comparefn(array[j - 1], element) > 0) {\n      array[j] = array[--j];\n    }\n    if (j !== i++) array[j] = element;\n  } return array;\n};\n\nvar merge = function (array, left, right, comparefn) {\n  var llength = left.length;\n  var rlength = right.length;\n  var lindex = 0;\n  var rindex = 0;\n\n  while (lindex < llength || rindex < rlength) {\n    array[lindex + rindex] = (lindex < llength && rindex < rlength)\n      ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++]\n      : lindex < llength ? left[lindex++] : right[rindex++];\n  } return array;\n};\n\nvar arraySort = mergeSort;\n\nvar userAgent$1 = engineUserAgent;\n\nvar firefox = userAgent$1.match(/firefox\\/(\\d+)/i);\n\nvar engineFfVersion = !!firefox && +firefox[1];\n\nvar UA = engineUserAgent;\n\nvar engineIsIeOrEdge = /MSIE|Trident/.test(UA);\n\nvar userAgent = engineUserAgent;\n\nvar webkit = userAgent.match(/AppleWebKit\\/(\\d+)\\./);\n\nvar engineWebkitVersion = !!webkit && +webkit[1];\n\nvar global$2 = global$t;\nvar uncurryThis$3 = functionUncurryThis;\nvar fails$3 = fails$s;\nvar aCallable = aCallable$9;\nvar internalSort = arraySort;\nvar ArrayBufferViewCore$1 = arrayBufferViewCore;\nvar FF = engineFfVersion;\nvar IE_OR_EDGE = engineIsIeOrEdge;\nvar V8 = engineV8Version;\nvar WEBKIT = engineWebkitVersion;\n\nvar aTypedArray$1 = ArrayBufferViewCore$1.aTypedArray;\nvar exportTypedArrayMethod$1 = ArrayBufferViewCore$1.exportTypedArrayMethod;\nvar Uint16Array = global$2.Uint16Array;\nvar un$Sort = Uint16Array && uncurryThis$3(Uint16Array.prototype.sort);\n\n// WebKit\nvar ACCEPT_INCORRECT_ARGUMENTS = !!un$Sort && !(fails$3(function () {\n  un$Sort(new Uint16Array(2), null);\n}) && fails$3(function () {\n  un$Sort(new Uint16Array(2), {});\n}));\n\nvar STABLE_SORT = !!un$Sort && !fails$3(function () {\n  // feature detection can be too slow, so check engines versions\n  if (V8) return V8 < 74;\n  if (FF) return FF < 67;\n  if (IE_OR_EDGE) return true;\n  if (WEBKIT) return WEBKIT < 602;\n\n  var array = new Uint16Array(516);\n  var expected = Array(516);\n  var index, mod;\n\n  for (index = 0; index < 516; index++) {\n    mod = index % 4;\n    array[index] = 515 - index;\n    expected[index] = index - 2 * mod + 3;\n  }\n\n  un$Sort(array, function (a, b) {\n    return (a / 4 | 0) - (b / 4 | 0);\n  });\n\n  for (index = 0; index < 516; index++) {\n    if (array[index] !== expected[index]) return true;\n  }\n});\n\nvar getSortCompare = function (comparefn) {\n  return function (x, y) {\n    if (comparefn !== undefined) return +comparefn(x, y) || 0;\n    // eslint-disable-next-line no-self-compare -- NaN check\n    if (y !== y) return -1;\n    // eslint-disable-next-line no-self-compare -- NaN check\n    if (x !== x) return 1;\n    if (x === 0 && y === 0) return 1 / x > 0 && 1 / y < 0 ? 1 : -1;\n    return x > y;\n  };\n};\n\n// `%TypedArray%.prototype.sort` method\n// https://tc39.es/ecma262/#sec-%typedarray%.prototype.sort\nexportTypedArrayMethod$1('sort', function sort(comparefn) {\n  if (comparefn !== undefined) aCallable(comparefn);\n  if (STABLE_SORT) return un$Sort(this, comparefn);\n\n  return internalSort(aTypedArray$1(this), getSortCompare(comparefn));\n}, !STABLE_SORT || ACCEPT_INCORRECT_ARGUMENTS);\n\nvar global$1 = global$t;\nvar apply$1 = functionApply;\nvar ArrayBufferViewCore = arrayBufferViewCore;\nvar fails$2 = fails$s;\nvar arraySlice$1 = arraySlice$5;\n\nvar Int8Array$1 = global$1.Int8Array;\nvar aTypedArray = ArrayBufferViewCore.aTypedArray;\nvar exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;\nvar $toLocaleString = [].toLocaleString;\n\n// iOS Safari 6.x fails here\nvar TO_LOCALE_STRING_BUG = !!Int8Array$1 && fails$2(function () {\n  $toLocaleString.call(new Int8Array$1(1));\n});\n\nvar FORCED = fails$2(function () {\n  return [1, 2].toLocaleString() != new Int8Array$1([1, 2]).toLocaleString();\n}) || !fails$2(function () {\n  Int8Array$1.prototype.toLocaleString.call([1, 2]);\n});\n\n// `%TypedArray%.prototype.toLocaleString` method\n// https://tc39.es/ecma262/#sec-%typedarray%.prototype.tolocalestring\nexportTypedArrayMethod('toLocaleString', function toLocaleString() {\n  return apply$1(\n    $toLocaleString,\n    TO_LOCALE_STRING_BUG ? arraySlice$1(aTypedArray(this)) : aTypedArray(this),\n    arraySlice$1(arguments)\n  );\n}, FORCED);\n\nclass Payload {\n  constructor(data) {\n    // The tag's value is a hardcoded value as per\n    // defined in the NEP [NEP413](https://github.com/near/NEPs/blob/master/neps/nep-0413.md)\n    this.tag = 2147484061;\n    this.message = data.message;\n    this.nonce = data.nonce;\n    this.recipient = data.recipient;\n    if (data.callbackUrl) {\n      this.callbackUrl = data.callbackUrl;\n    }\n  }\n}\nconst payloadSchema = new Map([[Payload, {\n  kind: \"struct\",\n  fields: [[\"tag\", \"u32\"], [\"message\", \"string\"], [\"nonce\", [32]], [\"recipient\", \"string\"], [\"callbackUrl\", {\n    kind: \"option\",\n    type: \"string\"\n  }]]\n}]]);\nconst serializeNep413 = signMessageParams => {\n  const payload = new Payload(Object.assign({}, signMessageParams));\n  return Buffer.from(borsh.serialize(payloadSchema, payload));\n};\n\nconst verifySignature = ({\n  publicKey,\n  signature,\n  message,\n  nonce,\n  recipient,\n  callbackUrl\n}) => {\n  // Reconstruct the payload that was **actually signed**\n  const payload = new Payload({\n    message,\n    nonce,\n    recipient,\n    callbackUrl\n  });\n  // Serialize payload based on payloadSchema\n  const borshPayload = borsh.serialize(payloadSchema, payload);\n  // Hash the payload as in the NEP0413 referenced example\n  // https://github.com/near/NEPs/blob/master/neps/nep-0413.md#references\n  // https://github.com/gagdiez/near-login/blob/main/authenticate/wallet-authenticate.js#L21\n  const hashedPayload = Uint8Array.from(jsSha256.sha256.array(borshPayload));\n  // Convert real signature to buffer base64\n  const realSignature = Buffer.from(signature, \"base64\");\n  const pk = nearAPI.utils.PublicKey.from(publicKey);\n  // Verify the signature\n  return pk.verify(hashedPayload, realSignature);\n};\nconst fetchAllUserKeys = ({\n  accountId,\n  network,\n  publicKey\n}) => __awaiter(void 0, void 0, void 0, function* () {\n  const provider = new nearAPI.providers.JsonRpcProvider({\n    url: network.nodeUrl\n  });\n  const key = yield provider.query({\n    request_type: \"view_access_key\",\n    account_id: accountId,\n    finality: \"final\",\n    public_key: publicKey\n  });\n  return key;\n});\nconst verifyFullKeyBelongsToUser = ({\n  publicKey,\n  accountId,\n  network\n}) => __awaiter(void 0, void 0, void 0, function* () {\n  const {\n    permission\n  } = yield fetchAllUserKeys({\n    accountId,\n    network,\n    publicKey\n  });\n  return permission === \"FullAccess\";\n});\n\n// TODO: Remove from `core-js@4` since it's moved to entry points\n\nvar uncurryThis$2 = functionUncurryThis;\nvar defineBuiltIn = defineBuiltIn$8;\nvar regexpExec$2 = regexpExec$3;\nvar fails$1 = fails$s;\nvar wellKnownSymbol = wellKnownSymbol$j;\nvar createNonEnumerableProperty = createNonEnumerableProperty$8;\n\nvar SPECIES = wellKnownSymbol('species');\nvar RegExpPrototype = RegExp.prototype;\n\nvar fixRegexpWellKnownSymbolLogic = function (KEY, exec, FORCED, SHAM) {\n  var SYMBOL = wellKnownSymbol(KEY);\n\n  var DELEGATES_TO_SYMBOL = !fails$1(function () {\n    // String methods call symbol-named RegEp methods\n    var O = {};\n    O[SYMBOL] = function () { return 7; };\n    return ''[KEY](O) != 7;\n  });\n\n  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails$1(function () {\n    // Symbol-named RegExp methods call .exec\n    var execCalled = false;\n    var re = /a/;\n\n    if (KEY === 'split') {\n      // We can't use real regex here since it causes deoptimization\n      // and serious performance degradation in V8\n      // https://github.com/zloirock/core-js/issues/306\n      re = {};\n      // RegExp[@@split] doesn't call the regex's exec method, but first creates\n      // a new one. We need to return the patched regex when creating the new one.\n      re.constructor = {};\n      re.constructor[SPECIES] = function () { return re; };\n      re.flags = '';\n      re[SYMBOL] = /./[SYMBOL];\n    }\n\n    re.exec = function () { execCalled = true; return null; };\n\n    re[SYMBOL]('');\n    return !execCalled;\n  });\n\n  if (\n    !DELEGATES_TO_SYMBOL ||\n    !DELEGATES_TO_EXEC ||\n    FORCED\n  ) {\n    var uncurriedNativeRegExpMethod = uncurryThis$2(/./[SYMBOL]);\n    var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {\n      var uncurriedNativeMethod = uncurryThis$2(nativeMethod);\n      var $exec = regexp.exec;\n      if ($exec === regexpExec$2 || $exec === RegExpPrototype.exec) {\n        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {\n          // The native String method already delegates to @@method (this\n          // polyfilled function), leasing to infinite recursion.\n          // We avoid it by directly calling the native @@method method.\n          return { done: true, value: uncurriedNativeRegExpMethod(regexp, str, arg2) };\n        }\n        return { done: true, value: uncurriedNativeMethod(str, regexp, arg2) };\n      }\n      return { done: false };\n    });\n\n    defineBuiltIn(String.prototype, KEY, methods[0]);\n    defineBuiltIn(RegExpPrototype, SYMBOL, methods[1]);\n  }\n\n  if (SHAM) createNonEnumerableProperty(RegExpPrototype[SYMBOL], 'sham', true);\n};\n\nvar uncurryThis$1 = functionUncurryThis;\nvar toIntegerOrInfinity = toIntegerOrInfinity$6;\nvar toString$1 = toString$5;\nvar requireObjectCoercible$1 = requireObjectCoercible$6;\n\nvar charAt$1 = uncurryThis$1(''.charAt);\nvar charCodeAt = uncurryThis$1(''.charCodeAt);\nvar stringSlice$1 = uncurryThis$1(''.slice);\n\nvar createMethod = function (CONVERT_TO_STRING) {\n  return function ($this, pos) {\n    var S = toString$1(requireObjectCoercible$1($this));\n    var position = toIntegerOrInfinity(pos);\n    var size = S.length;\n    var first, second;\n    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;\n    first = charCodeAt(S, position);\n    return first < 0xD800 || first > 0xDBFF || position + 1 === size\n      || (second = charCodeAt(S, position + 1)) < 0xDC00 || second > 0xDFFF\n        ? CONVERT_TO_STRING\n          ? charAt$1(S, position)\n          : first\n        : CONVERT_TO_STRING\n          ? stringSlice$1(S, position, position + 2)\n          : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;\n  };\n};\n\nvar stringMultibyte = {\n  // `String.prototype.codePointAt` method\n  // https://tc39.es/ecma262/#sec-string.prototype.codepointat\n  codeAt: createMethod(false),\n  // `String.prototype.at` method\n  // https://github.com/mathiasbynens/String.prototype.at\n  charAt: createMethod(true)\n};\n\nvar charAt = stringMultibyte.charAt;\n\n// `AdvanceStringIndex` abstract operation\n// https://tc39.es/ecma262/#sec-advancestringindex\nvar advanceStringIndex$1 = function (S, index, unicode) {\n  return index + (unicode ? charAt(S, index).length : 1);\n};\n\nvar call$1 = functionCall;\nvar anObject$1 = anObject$e;\nvar isCallable = isCallable$n;\nvar classof = classofRaw$1;\nvar regexpExec$1 = regexpExec$3;\n\nvar $TypeError = TypeError;\n\n// `RegExpExec` abstract operation\n// https://tc39.es/ecma262/#sec-regexpexec\nvar regexpExecAbstract = function (R, S) {\n  var exec = R.exec;\n  if (isCallable(exec)) {\n    var result = call$1(exec, R, S);\n    if (result !== null) anObject$1(result);\n    return result;\n  }\n  if (classof(R) === 'RegExp') return call$1(regexpExec$1, R, S);\n  throw $TypeError('RegExp#exec called on incompatible receiver');\n};\n\nvar apply = functionApply;\nvar call = functionCall;\nvar uncurryThis = functionUncurryThis;\nvar fixRegExpWellKnownSymbolLogic = fixRegexpWellKnownSymbolLogic;\nvar isRegExp = isRegexp;\nvar anObject = anObject$e;\nvar requireObjectCoercible = requireObjectCoercible$6;\nvar speciesConstructor = speciesConstructor$3;\nvar advanceStringIndex = advanceStringIndex$1;\nvar toLength = toLength$6;\nvar toString = toString$5;\nvar getMethod = getMethod$4;\nvar arraySlice = arraySliceSimple;\nvar callRegExpExec = regexpExecAbstract;\nvar regexpExec = regexpExec$3;\nvar stickyHelpers = regexpStickyHelpers;\nvar fails = fails$s;\n\nvar UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;\nvar MAX_UINT32 = 0xFFFFFFFF;\nvar min = Math.min;\nvar $push = [].push;\nvar exec = uncurryThis(/./.exec);\nvar push = uncurryThis($push);\nvar stringSlice = uncurryThis(''.slice);\n\n// Chrome 51 has a buggy \"split\" implementation when RegExp#exec !== nativeExec\n// Weex JS has frozen built-in prototypes, so use try / catch wrapper\nvar SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function () {\n  // eslint-disable-next-line regexp/no-empty-group -- required for testing\n  var re = /(?:)/;\n  var originalExec = re.exec;\n  re.exec = function () { return originalExec.apply(this, arguments); };\n  var result = 'ab'.split(re);\n  return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';\n});\n\n// @@split logic\nfixRegExpWellKnownSymbolLogic('split', function (SPLIT, nativeSplit, maybeCallNative) {\n  var internalSplit;\n  if (\n    'abbc'.split(/(b)*/)[1] == 'c' ||\n    // eslint-disable-next-line regexp/no-empty-group -- required for testing\n    'test'.split(/(?:)/, -1).length != 4 ||\n    'ab'.split(/(?:ab)*/).length != 2 ||\n    '.'.split(/(.?)(.?)/).length != 4 ||\n    // eslint-disable-next-line regexp/no-empty-capturing-group, regexp/no-empty-group -- required for testing\n    '.'.split(/()()/).length > 1 ||\n    ''.split(/.?/).length\n  ) {\n    // based on es5-shim implementation, need to rework it\n    internalSplit = function (separator, limit) {\n      var string = toString(requireObjectCoercible(this));\n      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;\n      if (lim === 0) return [];\n      if (separator === undefined) return [string];\n      // If `separator` is not a regex, use native split\n      if (!isRegExp(separator)) {\n        return call(nativeSplit, string, separator, lim);\n      }\n      var output = [];\n      var flags = (separator.ignoreCase ? 'i' : '') +\n                  (separator.multiline ? 'm' : '') +\n                  (separator.unicode ? 'u' : '') +\n                  (separator.sticky ? 'y' : '');\n      var lastLastIndex = 0;\n      // Make `global` and avoid `lastIndex` issues by working with a copy\n      var separatorCopy = new RegExp(separator.source, flags + 'g');\n      var match, lastIndex, lastLength;\n      while (match = call(regexpExec, separatorCopy, string)) {\n        lastIndex = separatorCopy.lastIndex;\n        if (lastIndex > lastLastIndex) {\n          push(output, stringSlice(string, lastLastIndex, match.index));\n          if (match.length > 1 && match.index < string.length) apply($push, output, arraySlice(match, 1));\n          lastLength = match[0].length;\n          lastLastIndex = lastIndex;\n          if (output.length >= lim) break;\n        }\n        if (separatorCopy.lastIndex === match.index) separatorCopy.lastIndex++; // Avoid an infinite loop\n      }\n      if (lastLastIndex === string.length) {\n        if (lastLength || !exec(separatorCopy, '')) push(output, '');\n      } else push(output, stringSlice(string, lastLastIndex));\n      return output.length > lim ? arraySlice(output, 0, lim) : output;\n    };\n  // Chakra, V8\n  } else if ('0'.split(undefined, 0).length) {\n    internalSplit = function (separator, limit) {\n      return separator === undefined && limit === 0 ? [] : call(nativeSplit, this, separator, limit);\n    };\n  } else internalSplit = nativeSplit;\n\n  return [\n    // `String.prototype.split` method\n    // https://tc39.es/ecma262/#sec-string.prototype.split\n    function split(separator, limit) {\n      var O = requireObjectCoercible(this);\n      var splitter = separator == undefined ? undefined : getMethod(separator, SPLIT);\n      return splitter\n        ? call(splitter, separator, O, limit)\n        : call(internalSplit, toString(O), separator, limit);\n    },\n    // `RegExp.prototype[@@split]` method\n    // https://tc39.es/ecma262/#sec-regexp.prototype-@@split\n    //\n    // NOTE: This cannot be properly polyfilled in engines that don't support\n    // the 'y' flag.\n    function (string, limit) {\n      var rx = anObject(this);\n      var S = toString(string);\n      var res = maybeCallNative(internalSplit, rx, S, limit, internalSplit !== nativeSplit);\n\n      if (res.done) return res.value;\n\n      var C = speciesConstructor(rx, RegExp);\n\n      var unicodeMatching = rx.unicode;\n      var flags = (rx.ignoreCase ? 'i' : '') +\n                  (rx.multiline ? 'm' : '') +\n                  (rx.unicode ? 'u' : '') +\n                  (UNSUPPORTED_Y ? 'g' : 'y');\n\n      // ^(? + rx + ) is needed, in combination with some S slicing, to\n      // simulate the 'y' flag.\n      var splitter = new C(UNSUPPORTED_Y ? '^(?:' + rx.source + ')' : rx, flags);\n      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;\n      if (lim === 0) return [];\n      if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : [];\n      var p = 0;\n      var q = 0;\n      var A = [];\n      while (q < S.length) {\n        splitter.lastIndex = UNSUPPORTED_Y ? 0 : q;\n        var z = callRegExpExec(splitter, UNSUPPORTED_Y ? stringSlice(S, q) : S);\n        var e;\n        if (\n          z === null ||\n          (e = min(toLength(splitter.lastIndex + (UNSUPPORTED_Y ? q : 0)), S.length)) === p\n        ) {\n          q = advanceStringIndex(S, q, unicodeMatching);\n        } else {\n          push(A, stringSlice(S, p, q));\n          if (A.length === lim) return A;\n          for (var i = 1; i <= z.length - 1; i++) {\n            push(A, z[i]);\n            if (A.length === lim) return A;\n          }\n          q = p = e;\n        }\n      }\n      push(A, stringSlice(S, p));\n      return A;\n    }\n  ];\n}, !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC, UNSUPPORTED_Y);\n\nvar modal$b = {\n\twallet: {\n\t\tconnectYourWallet: \"Connect Your Wallet\",\n\t\twhatIsAWallet: \"What is a Wallet?\",\n\t\tsecureAndManage: \"Secure & Manage Your Digital Assets\",\n\t\tsafelyStore: \"Safely store and transfer your crypto and NFTs.\",\n\t\tlogInToAny: \"Log In to Any NEAR App\",\n\t\tnoNeedToCreate: \"No need to create new accounts or credentials. Connect your wallet and you are good to go!\",\n\t\tgetAWallet: \"Get a Wallet\",\n\t\tuseAWallet: \"Use a wallet to secure and manage your NEAR assets, and to log in to any NEAR app without the need for usernames and passwords.\",\n\t\tconnectionFailed: \"Connection Failed\",\n\t\tconnectionSuccessful: \"Connection Successful\",\n\t\tconnected: \"Connected\",\n\t\tconnectingTo: \"Connecting to\",\n\t\tconnectingMessage: {\n\t\t\tinjected: \"Confirm the connection in the extension window\",\n\t\t\tbrowser: \"Confirm the connection in the wallet after redirect\",\n\t\t\thardware: \"Confirm the connection in the ledger device\",\n\t\t\tbridge: \"Confirm the connection in the wallet\"\n\t\t}\n\t},\n\tledger: {\n\t\tconnectWithLedger: \"Connect with Ledger\",\n\t\tmakeSureYourLedger: \"Make sure your Ledger is connected securely, and that the NEAR app is open on your device\",\n\t\t\"continue\": \"Continue\",\n\t\tspecifyHDPath: \"Specify HD Path\",\n\t\tenterYourPreferredHDPath: \"Enter your preferred HD path, then scan for any active accounts.\",\n\t\tscan: \"Scan\",\n\t\tretry: \"Retry\",\n\t\tledgerIsNotAvailable: \"Ledger is not available\",\n\t\taccessDeniedToUseLedgerDevice: \"Access denied to use Ledger device\",\n\t\tnoAccountsFound: \"No Accounts Found\",\n\t\tselectYourAccounts: \"Select Your Accounts\",\n\t\tconnecting1Account: \"Connecting 1 Account\",\n\t\tcantFindAnyAccount: \"Can't find any account associated with this Ledger. Please create a new NEAR account on\",\n\t\torConnectAnAnotherLedger: \"or connect an another Ledger.\",\n\t\tconnecting: \"Connecting\",\n\t\tofAccounts: \"of Accounts\",\n\t\tfailedToAutomatically: \"Failed to automatically find account id. Provide it manually:\",\n\t\toverviewTheListOfAuthorized: \"Overview the list of authorized account(s), complete sign in by clicking the button below.\",\n\t\tfinish: \"Finish\"\n\t},\n\tinstall: {\n\t\tyoullNeedToInstall: \"You'll need to install\",\n\t\ttoContinueAfterInstalling: \"to continue. After installing\",\n\t\trefreshThePage: \"refresh the page.\",\n\t\topen: \"Open\"\n\t},\n\tqr: {\n\t\tcopiedToClipboard: \"Copied to clipboard\",\n\t\tfailedToCopy: \"Failed to copy to clipboard\",\n\t\tscanWithYourMobile: \"Scan with Your Mobile Device\",\n\t\tcopyToClipboard: \" Copy to clipboard\",\n\t\tpreferTheOfficial: \"Prefer the official dialogue of\",\n\t\topen: \"Open\"\n\t},\n\twalletTypes: {\n\t\thardware: \"Hardware Wallet\",\n\t\tbrowser: \"Browser Wallet\",\n\t\tinjected: \"Wallet Extension\",\n\t\tbridge: \"Bridge Wallet\",\n\t\tmobile: \"Mobile Wallet\",\n\t\t\"instant-link\": \"Instant Wallet\"\n\t},\n\texportAccounts: {\n\t\tchooseAWallet: \"Choose a Wallet\",\n\t\ttransferYourAccounts: \"Transfer Your Accounts\",\n\t\tselectAWallet: \"Select a wallet that fits your needs and supports your connected accounts.\",\n\t\tselectYourAccounts: \"Select Your Accounts\",\n\t\tafterDecide: \"After you decide on a wallet, you can select which accounts you want to transfer.\",\n\t\tdisclaimer: \"You won’t be able to transfer accounts that have never been funded or used on NEAR.\",\n\t\twarning: \"does not support account export at this time. Please select another wallet.\",\n\t\twalletTypes: {\n\t\t\thardware: \"Hardware Wallet\",\n\t\t\tbrowser: \"Browser Wallet\",\n\t\t\tinjected: \"Wallet Extension\",\n\t\t\tbridge: \"Bridge Wallet\",\n\t\t\tmobile: \"Mobile Wallet\"\n\t\t},\n\t\tselectAccounts: {\n\t\t\ttitle: \"Select Accounts to Transfer\",\n\t\t\tbutton: \"Continue\",\n\t\t\tdeselectAll: \"Deselect All\",\n\t\t\tselectAll: \"Select All\",\n\t\t\tunavailable: \"Transfer Unavailable\",\n\t\t\terror: \"Account does not exist\",\n\t\t\twarningLedger: \"Ledger support required\",\n\t\t\tnoBalance: \"Account not funded\"\n\t\t},\n\t\tgetPassphrase: {\n\t\t\ttitle: \"Copy Temporary Password\",\n\t\t\tdesc: \"You’ll need to enter this password when you begin exporting your accounts to a different wallet.\",\n\t\t\tbutton: \"Continue\",\n\t\t\ttransferButton: \"Transfer Accounts\",\n\t\t\tlabel: \"Click to Copy\",\n\t\t\tcheckLabel: \"I copied or wrote down the password\"\n\t\t},\n\t\tcomplete: {\n\t\t\ttitle: \"Complete the Transfer\",\n\t\t\tdescOne: \"You will now be redirected to the wallet you selected to complete the transfer.\",\n\t\t\tdescTwo: \"Once import part of process is completed from selected wallet, press button to complete the transfer process.\",\n\t\t\tstartOverButton: \"Start Over\",\n\t\t\tbutton: \"Complete\"\n\t\t}\n\t}\n};\nvar component$1 = {\n\tclickToCopy: {\n\t\tlabel: \"Copied\",\n\t\ttooltip: \"Click to copy\"\n\t}\n};\nvar en = {\n\tmodal: modal$b,\n\tcomponent: component$1\n};\n\nvar modal$a = {\n\twallet: {\n\t\tconnectYourWallet: \"Conecta Tu Billetera\",\n\t\twhatIsAWallet: \"¿Que es una Billetera?\",\n\t\tsecureAndManage: \"Resguarda y Administrar Tus Activos Digitales\",\n\t\tsafelyStore: \"Almacena de forma segura y transfiere tus cryptos y NFT's\",\n\t\tlogInToAny: \"Inicie sesión en Cualquier Aplicacion NEAR\",\n\t\tnoNeedToCreate: \"No es necesario crear nuevas cuentas o credenciales, ¡Conecta tu billetera y listo!\",\n\t\tgetAWallet: \"Obten una Billetera\",\n\t\tuseAWallet: \"Usa tu Billetera para resguardar y administrar tus activos en NEAR, e Iniciar sesión en cualquier aplicacion NEAR sin la necesidad de nombres de usuarios y contraseñas\",\n\t\tconnectionFailed: \"Conexión Fallida\",\n\t\tconnectionSuccessful: \"Conexión Existosa\",\n\t\tconnected: \"Conectado\",\n\t\tconnectingTo: \"Conectando a \",\n\t\tconnectingMessage: {\n\t\t\tinjected: \"Confirme la conexión en la ventana de extensión\",\n\t\t\tbrowser: \"Confirme la conexión en la billetera después de la redirección\",\n\t\t\thardware: \"Confirme la conexión en el dispositivo de libro mayor\",\n\t\t\tbridge: \"Confirmar la conexión en la billetera\"\n\t\t}\n\t},\n\tledger: {\n\t\tconnectWithLedger: \"Conectar con Ledger\",\n\t\tmakeSureYourLedger: \"Asegúrese de que su ledger está conectada de forma segura y que la aplicacion NEAR esté abierta en su dispositivo\",\n\t\t\"continue\": \"Continuar\",\n\t\tspecifyHDPath: \"Especifique la ruta HD\",\n\t\tenterYourPreferredHDPath: \"Ingrese su ruta HD prerida,y luego busque cualquier cuenta activa.\",\n\t\tscan: \"Escanear\",\n\t\tretry: \"Reintentar\",\n\t\tledgerIsNotAvailable: \"El Ledger no está disponible\",\n\t\taccessDeniedToUseLedgerDevice: \"Acceso denegado para usar el dispositivo ledger\",\n\t\tnoAccountsFound: \"No se encontraron cuentas\",\n\t\tselectYourAccounts: \"Selecciona tus cuentas\",\n\t\tconnecting1Account: \"Conectando a 1 cuenta\",\n\t\tcantFindAnyAccount: \"No se pudo encontrar ninguna cuenta asociada con este ledger,Por favor crea una nueva cuenta en NEAR\",\n\t\torConnectAnAnotherLedger: \"o conecta otro ledger\",\n\t\tconnecting: \"Conectando\",\n\t\tofAccounts: \"de Cuentas\",\n\t\tfailedToAutomatically: \"No se pudo encontrar automaticamente el id de la cuenta,Ingresalo manualmente:\",\n\t\toverviewTheListOfAuthorized: \"Revise la lista de las cuentas autorizadas,Complete el inicio de sesión haciedo click a countinuacion.\",\n\t\tfinish: \"Finalizar\"\n\t},\n\tinstall: {\n\t\tyoullNeedToInstall: \"Tendrás que instalar\",\n\t\ttoContinueAfterInstalling: \"Para continuar, Despues de instalar\",\n\t\trefreshThePage: \"Recarga la pagina\",\n\t\topen: \"Abrir\"\n\t},\n\tqr: {\n\t\tcopiedToClipboard: \"Copiado al Portapapeles\",\n\t\tfailedToCopy: \"Falló la copia al Portapapeles\",\n\t\tscanWithYourMobile: \"Busca con tu dispositivo movil\",\n\t\tcopyToClipboard: \" Copiar al Portapapeles\",\n\t\tpreferTheOfficial: \"¿Prefires el diálogo oficial de\",\n\t\topen: \"Abrir\"\n\t},\n\twalletTypes: {\n\t\thardware: \"Hardware Wallet\",\n\t\tbrowser: \"Browser Wallet\",\n\t\tinjected: \"Wallet Extension\",\n\t\tbridge: \"Bridge Wallet\",\n\t\tmobile: \"Mobile Wallet\",\n\t\t\"instant-link\": \"Instant Wallet\"\n\t}\n};\nvar es = {\n\tmodal: modal$a\n};\n\nvar modal$9 = {\n\twallet: {\n\t\tconnectYourWallet: \"连接你的钱包\",\n\t\twhatIsAWallet: \"什么是钱包？\",\n\t\tsecureAndManage: \"保护和管理你的数字资产\",\n\t\tsafelyStore: \"安全存储和转移你的加密货币和NFT\",\n\t\tlogInToAny: \"登录任何 NEAR 应用\",\n\t\tnoNeedToCreate: \"不需要创建新账户或密码。连接你的钱包，即可开始使用！\",\n\t\tgetAWallet: \"获取新账户\",\n\t\tuseAWallet: \"使用钱包来保护和管理你的 NEAR 资产，无需用户名和密码即可登录任何 NEAR 应用\",\n\t\tconnectionFailed: \"连接失败\",\n\t\tconnectionSuccessful: \"连接成功\",\n\t\tconnected: \"已连接\",\n\t\tconnectingTo: \"正在连接\"\n\t},\n\tledger: {\n\t\tconnectWithLedger: \"连接 Ledger\",\n\t\tmakeSureYourLedger: \"确保你的 Ledger 已经安全连接，并且 NEAR 应用已经在你设备上打开\",\n\t\t\"continue\": \"继续\",\n\t\tspecifyHDPath: \"指定 HD 路径\",\n\t\tenterYourPreferredHDPath: \"输入你偏好的 HD 路径，然后为任意活跃账户扫码\",\n\t\tscan: \"扫码\",\n\t\tretry: \"重试\",\n\t\tledgerIsNotAvailable: \"Ledger 不可用\",\n\t\taccessDeniedToUseLedgerDevice: \"访问 Ledger 设备被拒绝\",\n\t\tnoAccountsFound: \"没有找到账户\",\n\t\tselectYourAccounts: \"选择你的账户\",\n\t\tconnecting1Account: \"正在连接1个账户\",\n\t\tcantFindAnyAccount: \"没有找到任何与这个 Ledger 相关联的账户。请创建新账户于\",\n\t\t\"orConnectAnAnotherLedger.\": \"或连接另一个 Ledger\",\n\t\tconnecting: \"正在连接\",\n\t\tofAccounts: \"个账户\",\n\t\tfailedToAutomatically: \"无法自动找到账户ID，请主动提供：\",\n\t\toverviewTheListOfAuthorized: \"请查看已授权的账户列表，点击以下按钮完成登录\",\n\t\tfinish: \"完成\"\n\t},\n\tinstall: {\n\t\tyoullNeedToInstall: \"你将需要安装\",\n\t\ttoContinueAfterInstalling: \"以继续。安装完\",\n\t\trefreshThePage: \"请刷新页面\",\n\t\topen: \"打开\"\n\t},\n\tqr: {\n\t\tcopiedToClipboard: \"复制到了剪贴板\",\n\t\tfailedToCopy: \"复制到剪贴板失败\",\n\t\tscanWithYourMobile: \"用你的移动设备扫码\",\n\t\tcopyToClipboard: \" 复制到剪贴板\",\n\t\tpreferTheOfficial: \"希望使用官方对话框于\",\n\t\topen: \"打开\"\n\t},\n\twalletTypes: {\n\t\thardware: \"Hardware Wallet\",\n\t\tbrowser: \"Browser Wallet\",\n\t\tinjected: \"Wallet Extension\",\n\t\tbridge: \"Bridge Wallet\",\n\t\tmobile: \"Mobile Wallet\",\n\t\t\"instant-link\": \"Instant Wallet\"\n\t}\n};\nvar zh = {\n\tmodal: modal$9\n};\n\nvar modal$8 = {\n\twallet: {\n\t\tconnectYourWallet: \"Свържете вашия Портфейл\",\n\t\twhatIsAWallet: \"Какво е Портфейл?\",\n\t\tsecureAndManage: \"Защитете и управлявайте дигиталните си активи\",\n\t\tsafelyStore: \"Съхранявайте и прехвърляйте безопасно вашите крипто и NFT.\",\n\t\tlogInToAny: \"Използвайте всяко приложение на NEAR\",\n\t\tnoNeedToCreate: \"Няма нужда да създавате нови профили. Свържете портфейла си и сте готови!\",\n\t\tgetAWallet: \"Създайте Портфейл\",\n\t\tuseAWallet: \"Използвайте портфейла, за да защитите и управлявате активите си на NEAR както и да използвате всяко приложение на NEAR без нужда от потребителски имена и пароли.\",\n\t\tconnectionFailed: \"Свързването неуспешно\",\n\t\tconnectionSuccessful: \"Свързването успешно\",\n\t\tconnected: \"Свързан\",\n\t\tconnectingTo: \"Свързване към\",\n\t\tconnectingMessage: {\n\t\t\tinjected: \"Потвърдете свързването в прозореца на разширението\",\n\t\t\tbrowser: \"Потвърдете свързването в портфейла след пренасочването\",\n\t\t\thardware: \"Потвърдете свързването в хардуерния портфейл\",\n\t\t\tbridge: \"Потвърдете връзката в портфейла\"\n\t\t}\n\t},\n\tledger: {\n\t\tconnectWithLedger: \"Свържете се с Ledger\",\n\t\tmakeSureYourLedger: \"Уверете се, че вашият Ledger е свързан и че приложението NEAR е отворено нa него.\",\n\t\t\"continue\": \"Продължете\",\n\t\tspecifyHDPath: \"Посочете HD път\",\n\t\tenterYourPreferredHDPath: \"Въведете предпочитания HD път, след което сканирайте за активни акаунти.\",\n\t\tscan: \"Сканирайте\",\n\t\tretry: \"Опитайте отново\",\n\t\tledgerIsNotAvailable: \"Ledger устройството не е достъпно\",\n\t\taccessDeniedToUseLedgerDevice: \"Достъпът за използване на Ledger е отказан\",\n\t\tnoAccountsFound: \"Няма намерени профили\",\n\t\tselectYourAccounts: \"Изберете вашите профили\",\n\t\tconnecting1Account: \"Свързване на 1 профил\",\n\t\tcantFindAnyAccount: \"Няма намерени профили, съврзани с този Ledger. Моля, създайте нов NEAR профил на\",\n\t\torConnectAnAnotherLedger: \"или свържете друг Ledger.\",\n\t\tconnecting: \"Свързване\",\n\t\tofAccounts: \"от профили\",\n\t\tfailedToAutomatically: \"Автоматичното намиране на профила не бе успешно. Въведете го ръчно:\",\n\t\toverviewTheListOfAuthorized: \"Прегледайте списъка с упълномощени профили, завършете влизането, като щракнете върху бутона по-долу..\",\n\t\tfinish: \"Завършете\"\n\t},\n\tinstall: {\n\t\tyoullNeedToInstall: \"Ще трябва да инсталирате\",\n\t\ttoContinueAfterInstalling: \"за да продължите. След инсталиране\",\n\t\trefreshThePage: \"презаредете страницата.\",\n\t\topen: \"Отворете\"\n\t},\n\tqr: {\n\t\tcopiedToClipboard: \"Копирано в клипборда\",\n\t\tfailedToCopy: \"Неуспешно копиране в клипборда\",\n\t\tscanWithYourMobile: \" Сканирайте с мобилното си устройство\",\n\t\tcopyToClipboard: \" Копирайте в клипборда\",\n\t\tpreferTheOfficial: \"Предпочитан език за кореспонденция\",\n\t\topen: \"Отворете\"\n\t},\n\twalletTypes: {\n\t\thardware: \"Hardware Wallet\",\n\t\tbrowser: \"Browser Wallet\",\n\t\tinjected: \"Wallet Extension\",\n\t\tbridge: \"Bridge Wallet\",\n\t\tmobile: \"Mobile Wallet\",\n\t\t\"instant-link\": \"Instant Wallet\"\n\t}\n};\nvar bg = {\n\tmodal: modal$8\n};\n\nvar modal$7 = {\n\twallet: {\n\t\tconnectYourWallet: \"지갑 연결하기\",\n\t\twhatIsAWallet: \"지갑은 무슨 역할을 하나요?\",\n\t\tsecureAndManage: \"당신의 디지털 자산을 보호하고 관리합니다.\",\n\t\tsafelyStore: \"암호화폐와 NFT를 안전하게 저장하고 전송할 수 있습니다.\",\n\t\tlogInToAny: \"NEAR App에 로그인합니다.\",\n\t\tnoNeedToCreate: \"새로운 계정이나 비밀번호를 만들 필요 없이 지갑을 연결한 후 바로 사용할 수 있습니다.\",\n\t\tgetAWallet: \"지갑 가져오기\",\n\t\tuseAWallet: \"지갑을 사용하여 NEAR 자산을 보호·관리하고, 아이디와 비밀번호 없이 NEAR 앱에 로그인할 수 있습니다.\",\n\t\tconnectionFailed: \"연결 실패\",\n\t\tconnectionSuccessful: \"연결 성공\",\n\t\tconnected: \"Connected\",\n\t\tconnectingTo: \"연결 중: \",\n\t\tconnectingMessage: {\n\t\t\tinjected: \"익스텐션 창에서 연결을 확인하세요\",\n\t\t\tbrowser: \"리다이렉트 된 지갑에서 연결을 확인하세요\",\n\t\t\thardware: \"Ledger 기기에서 연결을 확인하세요\",\n\t\t\tbridge: \"지갑에서 연결 확인\"\n\t\t}\n\t},\n\tledger: {\n\t\tconnectWithLedger: \"Ledger 연결하기\",\n\t\tmakeSureYourLedger: \"Ledger가 안전하게 연결되어 있고, NEAR 앱이 열려 있는 지 확인하세요\",\n\t\t\"continue\": \"계속하기\",\n\t\tspecifyHDPath: \"HD Path 지정하기\",\n\t\tenterYourPreferredHDPath: \"원하는 HD Path를 선택하고, 활성화된 계정이 있는 지 검색하세요\",\n\t\tscan: \"검색\",\n\t\tretry: \"다시 시도\",\n\t\tledgerIsNotAvailable: \"Ledger를 사용할 수 없습니다\",\n\t\taccessDeniedToUseLedgerDevice: \"Ledger 기기 접근 권한이 거부되었습니다\",\n\t\tnoAccountsFound: \"계정을 찾을 수 없습니다\",\n\t\tselectYourAccounts: \"계정 선택하기\",\n\t\tconnecting1Account: \"하나의 계정에 연결\",\n\t\tcantFindAnyAccount: \"Ledger와 연결된 계정을 찾을 수 없습니다. 새로운 계정을 생성하거나 \",\n\t\torConnectAnAnotherLedger: \"다른 Ledger를 연결하세요\",\n\t\tconnecting: \"계정 연결하기: \",\n\t\tofAccounts: \"개 계정을 찾았습니다\",\n\t\tfailedToAutomatically: \"계정 ID를 찾지 못했습니다. 수동으로 입력해주세요.\",\n\t\toverviewTheListOfAuthorized: \"인증된 계정 목록을 확인한 후 아래 버튼을 클릭하여 로그인을 완료하세요\",\n\t\tfinish: \"완료\"\n\t},\n\twalletTypes: {\n\t\thardware: \"하드웨어 지갑\",\n\t\tbrowser: \"브라우저 지갑\",\n\t\tinjected: \"지갑 확장\",\n\t\tbridge: \"브리지 지갑\",\n\t\tmobile: \"모바일 지갑\",\n\t\t\"instant-link\": \"인스턴트 지갑\"\n\t},\n\tinstall: {\n\t\tyoullNeedToInstall: \"다음 확장 프로그램을 설치해주세요:\",\n\t\ttoContinueAfterInstalling: \". 설치 완료 후 페이지 새로 고침이 필요합니다. \",\n\t\trefreshThePage: \"새로 고침\",\n\t\topen: \"Open\"\n\t},\n\tqr: {\n\t\tcopiedToClipboard: \"클립보드에 복사 완료\",\n\t\tfailedToCopy: \"클립보드에 복사 실패\",\n\t\tscanWithYourMobile: \"모바일 장치를 사용하여 스캔해주세요\",\n\t\tcopyToClipboard: \" 클립보드에 복사하기\",\n\t\tpreferTheOfficial: \"다음 프로그램에서 제공하는 공식 프로세스를 선호하십니까: \",\n\t\topen: \"Open\"\n\t}\n};\nvar ko = {\n\tmodal: modal$7\n};\n\nvar modal$6 = {\n\twallet: {\n\t\tconnectYourWallet: \"Kết nối ví của bạn\",\n\t\twhatIsAWallet: \"Ví là gì?\",\n\t\tsecureAndManage: \"Bảo mật & Quản lý tài sản số của bạn\",\n\t\tsafelyStore: \"Lưu trữ và chuyển tiền điện tử và NFT của bạn một cách an toàn.\",\n\t\tlogInToAny: \"Đăng nhập vào bất kỳ ứng dụng trên NEAR\",\n\t\tnoNeedToCreate: \"Không cần tạo tài khoản hoặc thông tin đăng nhập mới. Kết nối ví của bạn và bắt đầu!\",\n\t\tgetAWallet: \"Tạo Ví\",\n\t\tuseAWallet: \"Sử dụng ví để bảo mật và quản lý tài sản trên NEAR của bạn và đăng nhập vào bất kỳ ứng dụng NEAR nào, không cần tên người dùng và mật khẩu.\",\n\t\tconnectionFailed: \"Kết nối thất bại\",\n\t\tconnectionSuccessful: \"Kết nối thành công\",\n\t\tconnected: \"Đã kết nối\",\n\t\tconnectingTo: \"Đang kết nối tới\",\n\t\tconnectingMessage: {\n\t\t\tinjected: \"Xác nhận kết nối trong cửa sổ tiện ích mở rộng\",\n\t\t\tbrowser: \"Xác nhận kết nối trong ví sau khi được chuyển hướng\",\n\t\t\thardware: \"Xác nhận kết nối với ví lạnh\",\n\t\t\tbridge: \"Xác nhận kết nối trong ví\"\n\t\t}\n\t},\n\tledger: {\n\t\tconnectWithLedger: \"Kết nối ví Ledger\",\n\t\tmakeSureYourLedger: \"Đảm bảo Ledger của bạn được kết nối an toàn và ứng dụng NEAR đang mở sẵn trên thiết bị\",\n\t\t\"continue\": \"Tiếp tục\",\n\t\tspecifyHDPath: \"Chỉ định HD Path\",\n\t\tenterYourPreferredHDPath: \"Nhập HD Path của bạn, sau đó quét tìm các tài khoản hoạt động\",\n\t\tscan: \"Quét\",\n\t\tretry: \"Thử lại\",\n\t\tledgerIsNotAvailable: \"Ledger không khả dụng\",\n\t\taccessDeniedToUseLedgerDevice: \"Truy cập Ledger bị từ chối\",\n\t\tnoAccountsFound: \"Không tìm thấy tài khoản\",\n\t\tselectYourAccounts: \"Chọn tài khoản của bạn\",\n\t\tconnecting1Account: \"Đang kết nối 1 tài khoản\",\n\t\tcantFindAnyAccount: \"Không thể tìm thấy bất kỳ tài khoản nào được liên kết với Ledger này. Vui lòng tạo một tài khoản NEAR mới\",\n\t\torConnectAnAnotherLedger: \"hoặc kết nối với ví Ledger khác.\",\n\t\tconnecting: \"Đang kết nối\",\n\t\tofAccounts: \"của tài khoản\",\n\t\tfailedToAutomatically: \"Không thể tự động tìm id tài khoản. Nhập thủ công:\",\n\t\toverviewTheListOfAuthorized: \"Tổng quan danh sách các tài khoản được ủy quyền, hoàn tất đăng nhập bằng cách bấm vào nút bên dưới.\",\n\t\tfinish: \"Hoàn thành\"\n\t},\n\tinstall: {\n\t\tyoullNeedToInstall: \"Bạn sẽ cần cài đặt\",\n\t\ttoContinueAfterInstalling: \"để bắt đầu. Sau khi cài đặt xong\",\n\t\trefreshThePage: \"Tải lại trang.\",\n\t\topen: \"Mở\"\n\t},\n\tqr: {\n\t\tcopiedToClipboard: \"Đã sao chép vào bảng ghi tạm\",\n\t\tfailedToCopy: \"Sao chép vào bảng ghi tạm thất bại\",\n\t\tscanWithYourMobile: \"Quét với điện thoại của bạn\",\n\t\tcopyToClipboard: \" Sao chép vào bảng ghi tạm\",\n\t\tpreferTheOfficial: \"Dialogue chính thức của\",\n\t\topen: \"Mở\"\n\t},\n\twalletTypes: {\n\t\thardware: \"Ví lạnh\",\n\t\tbrowser: \"Ví trình duyệt\",\n\t\tinjected: \"Ví tiện ích mở rộng\",\n\t\tbridge: \"Ví Cầu\",\n\t\tmobile: \"Ví Mobile\",\n\t\t\"instant-link\": \"Ví tức thì\"\n\t},\n\texportAccounts: {\n\t\tchooseAWallet: \"Chọn ví\",\n\t\ttransferYourAccounts: \"Chuyển tài khoản\",\n\t\tselectAWallet: \"Chọn ví phù hợp với nhu cầu của bạn, ví được chọn cần hỗ trợ các tài khoản đang sử dụng.\",\n\t\tselectYourAccounts: \"Chọn tài khoản\",\n\t\tafterDecide: \"Sau khi chọn được tài khoản bạn có chuyển.\",\n\t\tdisclaimer: \"Bạn không thể chuyển tài khoản nếu tài khoản đó chưa được nhận tiền hoặc chưa phát sinh giao dịch trên NEAR.\",\n\t\twarning: \"không hỗ trợ xuất tài khoản. Vui lòng chọn ví khác.\",\n\t\twalletTypes: {\n\t\t\thardware: \"Ví lạnh\",\n\t\t\tbrowser: \"Ví trình duyệt\",\n\t\t\tinjected: \"Ví tiện ích mở rộng\",\n\t\t\tbridge: \"Ví Cầu\",\n\t\t\tmobile: \"Ví Mobile\"\n\t\t},\n\t\tselectAccounts: {\n\t\t\ttitle: \"Chọn tài khoản để chuyển\",\n\t\t\tbutton: \"Lấy cụm mật khẩu\",\n\t\t\tdeselectAll: \"Bỏ chọn tất cả\",\n\t\t\tselectAll: \"Chọn tất cả\",\n\t\t\tunavailable: \"Chuyển không khả dụng\",\n\t\t\terror: \"Tài khoản không tồn tại\",\n\t\t\twarningLedger: \"Yêu cầu hỗ trợ Ledger\",\n\t\t\tnoBalance: \"Tài khoản trống\"\n\t\t},\n\t\tgetPassphrase: {\n\t\t\ttitle: \"Sao chép mật khẩu tạm thời\",\n\t\t\tdesc: \"Bạn sẽ cần nhập mật khẩu khi bắt đầu xuất các khoản tới ví khác.\",\n\t\t\tbutton: \"Tiếp tục\",\n\t\t\tlabel: \"Bấm để sao chép\",\n\t\t\tcheckLabel: \"Tôi đã chép hoặc ghi lại mật khẩu\"\n\t\t},\n\t\tcomplete: {\n\t\t\ttitle: \"Hoàn thành chuyển\",\n\t\t\tdescOne: \"Bạn sẽ được chuyển hướng tới tài khoản đã chọn để hoàn tất quá trình.\",\n\t\t\tdescTwo: \"Sau khi nhập, nhấn nút để hoàn tất quy trình chuyển.\",\n\t\t\tbutton: \"Hoàn thành\"\n\t\t}\n\t}\n};\nvar component = {\n\tclickToCopy: {\n\t\tlabel: \"Đã sao chép\",\n\t\ttooltip: \"Bấm để sao chép\"\n\t}\n};\nvar vi = {\n\tmodal: modal$6,\n\tcomponent: component\n};\n\nvar modal$5 = {\n\twallet: {\n\t\tconnectYourWallet: \"अपना वॉलेट (Wallet) कनेक्ट करें।\",\n\t\twhatIsAWallet: \"वॉलेट क्या है?\",\n\t\tsecureAndManage: \"सुरक्षित और प्रबंधित करें।\",\n\t\tsafelyStore: \"अपनी क्रिप्टोकरेंसी और एनएफटी को सुरक्षित रूप से स्टोर और ट्रांसफर करें।\",\n\t\tlogInToAny: \"NEAR पर किसी भी ऐप में साइन इन करें।\",\n\t\tnoNeedToCreate: \"नए खाते या लॉगिन बनाने की आवश्यकता नहीं है। अपना वॉलेट(NEAR Wallet)कनेक्ट करें और आरंभ करें।\",\n\t\tgetAWallet: \"एक वॉलेट बनाएँ।\",\n\t\tuseAWallet: \"अपनी NEAR संपत्तियों को सुरक्षित और प्रबंधित करने के लिए वॉलेट का उपयोग करें और किसी भी NEAR ऐप (app) में लॉग इन करें, किसी उपयोगकर्ता (user) नाम और पासवर्ड की आवश्यकता नहीं है।\",\n\t\tconnectionFailed: \"कनेक्शन विफल|\",\n\t\tconnectionSuccessful: \"कनेक्शन सफल|\",\n\t\tconnected: \"वॉलेट जुड़ गया|\",\n\t\tconnectingTo: \"वॉलेट जुड़ रहा हे|\",\n\t\tconnectingMessage: {\n\t\t\tinjected: \"एक्सटेंशन विंडो में कनेक्शन की पुष्टि करें|\",\n\t\t\tbrowser: \"रीडायरेक्ट होने के बाद वॉलेट में कनेक्शन की पुष्टि करें|\",\n\t\t\thardware: \"कोल्ड वॉलेट के साथ कनेक्शन की पुष्टि करें|\"\n\t\t}\n\t},\n\tledger: {\n\t\tconnectWithLedger: \"लेजर(Ledger)वॉलेट कनेक्ट करें|\",\n\t\tmakeSureYourLedger: \"सुनिश्चित करें कि आपका लेजर सुरक्षित रूप से जुड़ा हुआ है और NEAR ऐप आपके डिवाइस (Device)पर पहले से ही खुला है|\",\n\t\t\"continue\": \"जारी रखे|\",\n\t\tspecifyHDPath: \"हार्ड डिस्क(Hard Disk)पथ(Path)निर्धारित करे|\",\n\t\tenterYourPreferredHDPath: \"अपना एचडी पथ दर्ज करें, फिर सक्रिय खातों के लिए स्कैन करें|\",\n\t\tscan: \"स्कैन करे|\",\n\t\tretry: \"दोबारा प्रयास करे|\",\n\t\tledgerIsNotAvailable: \"लेजर उपलब्ध नहीं है|\",\n\t\taccessDeniedToUseLedgerDevice: \"लेजर डिवाइस का उपयोग करने के लिए प्रवेश निषेध|\",\n\t\tnoAccountsFound: \"खाता नहीं मिला|\",\n\t\tselectYourAccounts: \"अपने खाते चुनें|\",\n\t\tconnecting1Account: \"एक खाता कनेक्ट हो रहा है|\",\n\t\tcantFindAnyAccount: \"इस लेजर से जुड़ा कोई खाता नहीं मिला। कृपया एक नया NEAR खाता बनाएँ|\",\n\t\torConnectAnAnotherLedger: \"अथवा दूसरे लेजर वॉलेट से कनेक्ट करें।\",\n\t\tconnecting: \"जुड़ रहा हे|\",\n\t\tofAccounts: \"खाता अब जुड़ा नहीं हे|\",\n\t\tfailedToAutomatically: \"खाता आईडी स्वचालित रूप से खोजने में असमर्थ। मैन्युअल (Manuall) रूप से कोशिश करें|\",\n\t\toverviewTheListOfAuthorized: \"अवलोकन अधिकृत की सूची, नीचे दिए गए बटन पर क्लिक करके लॉगिन पूरा करें।\",\n\t\tfinish: \"समाप्त|\"\n\t},\n\tinstall: {\n\t\tyoullNeedToInstall: \"आपको इंस्टॉल करना होगा|\",\n\t\ttoContinueAfterInstalling: \"इंस्टॉल करने के बाद जारी रखे|\",\n\t\trefreshThePage: \"पुन: लोड करें।\",\n\t\topen: \"खोले|\"\n\t},\n\tqr: {\n\t\tcopiedToClipboard: \"क्लिपबोर्ड(Clipboard)पर कॉपी किया गया|\",\n\t\tfailedToCopy: \"क्लिपबोर्ड पर कॉपी करना विफल रहा|\",\n\t\tscanWithYourMobile: \"अपने फोन (Mobile)से स्कैन करें|\",\n\t\tcopyToClipboard: \" क्लिपबोर्ड पर कॉपी करें|\",\n\t\tpreferTheOfficial: \"आधिकारिक संवाद को प्राथमिकता दें|\",\n\t\topen: \"खोले|\"\n\t},\n\twalletTypes: {\n\t\thardware: \"Hardware Wallet\",\n\t\tbrowser: \"Browser Wallet\",\n\t\tinjected: \"Wallet Extension\",\n\t\tbridge: \"Bridge Wallet\",\n\t\tmobile: \"Mobile Wallet\",\n\t\t\"instant-link\": \"Instant Wallet\"\n\t}\n};\nvar hi = {\n\tmodal: modal$5\n};\n\nvar modal$4 = {\n\twallet: {\n\t\tconnectYourWallet: \"صل محفظتك\",\n\t\twhatIsAWallet: \"ما هي المحفظة؟\",\n\t\tsecureAndManage: \"تأمين وإدارة الممتلكات الرقمية الخاصة بك\",\n\t\tsafelyStore: \"قم بتخزين و ارسال عملاتك و أصولك الرقمية بأمان\",\n\t\tlogInToAny: \"سجل الدخول إلى أي تطبيق يستخدم نير\",\n\t\tnoNeedToCreate: \".لا داعي لإنشاء حساب جديد. فقط قم بتوصيل محفظتك وانطلق\",\n\t\tgetAWallet: \"احصل على محفظة\",\n\t\tuseAWallet: \"استخدم محفظة لتأمين وإدارة أصول نير الخاصة بك، وادخل لأي تطبيق يستخدم نير دون الحاجة إلى اسم المستخدم وكلمةالمرور\",\n\t\tconnectionFailed: \"اتصال فاشل\",\n\t\tconnectionSuccessful: \"اتصال ناجح\",\n\t\tconnected: \"متصل\",\n\t\tconnectingTo: \"جاري الاتصال ب\",\n\t\tconnectingMessage: {\n\t\t\tinjected: \"وافق على الاتصال في نافذة الإضافة\",\n\t\t\tbrowser: \"وافق على الاتصال في المحفظة بعد إعادة توجيه\",\n\t\t\thardware: \"وافق على الاتصال في جهاز ليدجر\",\n\t\t\tbridge: \"وافق على الاتصال في المحفظة\"\n\t\t}\n\t},\n\tledger: {\n\t\tconnectWithLedger: \"اتصل مع ليدجر\",\n\t\tmakeSureYourLedger: \"تأكد أن ليدجر متصل بأمان, و أن تطبيق نير مفتوح في جهازك\",\n\t\t\"continue\": \"تابع\",\n\t\tspecifyHDPath: \"حدد مسار الحساب\",\n\t\tenterYourPreferredHDPath: \"أدخل مسار الحساب المفضل، ثم ابحث عن كل الحسابات النشطة\",\n\t\tscan: \"مسح\",\n\t\tretry: \"أعد المحاولة\",\n\t\tledgerIsNotAvailable: \"ليدجر غير متوفر\",\n\t\taccessDeniedToUseLedgerDevice: \"تم رفض الاتصال بليدجر\",\n\t\tnoAccountsFound: \"لم يتم العثور على أي حسابات\",\n\t\tselectYourAccounts: \"حدد حساباتك\",\n\t\tconnecting1Account: \"جاري الاتصال بحساب واحد\",\n\t\tcantFindAnyAccount: \"لا يمكن العثور على أي حساب مرتبط بهذا ليدجر الرجاء إنشاء حساب نير جديد على\",\n\t\torConnectAnAnotherLedger: \"او اربط جهاز ليدجر آخر\",\n\t\tconnecting: \"جاري الاتصال\",\n\t\tofAccounts: \"من الحسابات\",\n\t\tfailedToAutomatically: \"فشل في الاتصال بالحساب تلقائيا. يرجى الاتصال بالحساب يدويا\",\n\t\toverviewTheListOfAuthorized: \"لائحة الحسابات المصرح بها, أكمل تسجيل الدخول بالنقر على الزر أدناه\",\n\t\tfinish: \"إنهاء\"\n\t},\n\tinstall: {\n\t\tyoullNeedToInstall: \"ستحتاج لتثبيت\",\n\t\ttoContinueAfterInstalling: \"للاستكمال. بعد التثبيت\",\n\t\trefreshThePage: \"قم بتحديث الصفحة\",\n\t\topen: \"افتح\"\n\t},\n\tqr: {\n\t\tcopiedToClipboard: \"تم النسخ\",\n\t\tfailedToCopy: \"فشل النسخ\",\n\t\tscanWithYourMobile: \"امسح بجهازك المحمول\",\n\t\tcopyToClipboard: \"نسخ\",\n\t\tpreferTheOfficial: \"تفضل الحوار الرسمي ل\",\n\t\topen: \"فتح\"\n\t},\n\twalletTypes: {\n\t\thardware: \"Hardware Wallet\",\n\t\tbrowser: \"Browser Wallet\",\n\t\tinjected: \"Wallet Extension\",\n\t\tbridge: \"Bridge Wallet\",\n\t\tmobile: \"Mobile Wallet\",\n\t\t\"instant-link\": \"Instant Wallet\"\n\t}\n};\nvar ar = {\n\tmodal: modal$4\n};\n\nvar modal$3 = {\n\twallet: {\n\t\tconnectYourWallet: \"Spojite crypto novčanik!\",\n\t\twhatIsAWallet: \"Što je to crypto novčanik?\",\n\t\tsecureAndManage: \"Osigurajte i upravljajte svojom digitalnom imovinom.\",\n\t\tsafelyStore: \"Sigurno pohranite i prebacite svoj crypto i NFT-eve.\",\n\t\tlogInToAny: \" Prijavite se u bilo koju NEAR aplikaciju\",\n\t\tnoNeedToCreate: \"Nema potrebe za stvaranjem novih naloga ili korisničkih podataka. Spojite svoj crypto novčanik i spremni ste!\",\n\t\tgetAWallet: \"Otvorite crypto novčanik\",\n\t\tuseAWallet: \"Koristite crypto novčanik da biste osigurali i upravljali svojom NEAR imovinom, te se prijavite u bilo koju NEAR aplikaciju bez korisničkog imena i lozinke.\",\n\t\tconnectionFailed: \"Neuspješno povezivanje.\",\n\t\tconnectionSuccessful: \"Uspješno povezivanje.\",\n\t\tconnected: \"Povezano.\",\n\t\tconnectingTo: \"Povezivanje u tijeku\",\n\t\tconnectingMessage: {\n\t\t\tinjected: \"Potvrdite vezu u eksternom prozoru\",\n\t\t\tbrowser: \"Nakon redirekcije, potvrdite vezu u novčaniku\",\n\t\t\thardware: \"Potvrdite vezu sa novčanikom\",\n\t\t\tbridge: \"Potvrdite vezu u novčaniku\"\n\t\t}\n\t},\n\tledger: {\n\t\tconnectWithLedger: \"Povežite se hardverskim novčanikom\",\n\t\tmakeSureYourLedger: \"Osigurajte sigurnu vezu s hardverskim novčanikom, te da je NEAR aplikacija otvorena na vašem uređaju\",\n\t\t\"continue\": \"Nastavite\",\n\t\tspecifyHDPath: \"Specificirajte HD putanju\",\n\t\tenterYourPreferredHDPath: \"Upišite preferiranu HD putanju, zatim skenirajte aktivne naloge\",\n\t\tscan: \"Skenirajte\",\n\t\tretry: \"Pokušajte ponovno\",\n\t\tledgerIsNotAvailable: \"Hardverski novčanik nije dostupan.\",\n\t\taccessDeniedToUseLedgerDevice: \"Odbijen pristup za korištenjem hardverskog novčanika\",\n\t\tnoAccountsFound: \"Nalozi nisu pronađeni\",\n\t\tselectYourAccounts: \"Odaberite svoje naloge\",\n\t\tconnecting1Account: \"Povezivanje 1 naloga\",\n\t\tcantFindAnyAccount: \"Nije moguće pronaći niti jedan nalog povezan s ovim hardverskim novčanikom. Molimo vas, kreirajte novi NEAR nalog\",\n\t\torConnectAnAnotherLedger: \"Ili povežite drugi hardverski novčanik.\",\n\t\tconnecting: \"Povezivanje\",\n\t\tofAccounts: \"naloga\",\n\t\tfailedToAutomatically: \"Neuspješno automatsko pronalaženje ID naloga. Unesite ručno:\",\n\t\toverviewTheListOfAuthorized: \"Pregledajte popis odobrenih naloga, završite prijavu pritiskom na niže prikazani gumb.\",\n\t\tfinish: \"Završite\"\n\t},\n\tinstall: {\n\t\tyoullNeedToInstall: \" Potrebno je instalirati modal\",\n\t\ttoContinueAfterInstalling: \"za nastavak. Nakon instalacije\",\n\t\trefreshThePage: \"osvježite stranicu.\",\n\t\topen: \"Otvorite QR modal\"\n\t},\n\tqr: {\n\t\tcopiedToClipboard: \"Kopirano u međuspremnik\",\n\t\tfailedToCopy: \"Neupsješno kopiranje u međuspremnik\",\n\t\tscanWithYourMobile: \"Skenirajte svojim mobilnim uređajem\",\n\t\tcopyToClipboard: \" Kopirajte u međuspremnik\",\n\t\tpreferTheOfficial: \"Odaberite službeni dijalog\",\n\t\topen: \"Otvorite\"\n\t},\n\twalletTypes: {\n\t\thardware: \"Hardware Wallet\",\n\t\tbrowser: \"Browser Wallet\",\n\t\tinjected: \"Wallet Extension\",\n\t\tbridge: \"Bridge Wallet\",\n\t\tmobile: \"Mobile Wallet\",\n\t\t\"instant-link\": \"Instant Wallet\"\n\t},\n\texportAccounts: {\n\t\tchooseAWallet: \"Odaberi Wallet\",\n\t\ttransferYourAccounts: \"Prenesi svoje naloge\",\n\t\tselectAWallet: \"Odaberite wallet koji odgovara vašim potrebama i podržava vaše povezane naloge.\",\n\t\tselectYourAccounts: \"Odaberi svoje naloge\",\n\t\tafterDecide: \"Nakon što odlučite koji wallet koristite, možete odabrati koje račune želite prebaciti.\",\n\t\tdisclaimer: \"Nećete moći prebaciti naloge koji nisu nikada bili korišteni na NEAR-u.\",\n\t\twarning: \"ne podržava izvoz naloga u ovom trenutku. Molimo odaberite drugi wallet.\",\n\t\twalletTypes: {\n\t\t\thardware: \"Hardware Wallet\",\n\t\t\tbrowser: \"Browser Wallet\",\n\t\t\tinjected: \"Wallet Extension\",\n\t\t\tbridge: \"Bridge Wallet\",\n\t\t\tmobile: \"Mobile Wallet\"\n\t\t},\n\t\tselectAccounts: {\n\t\t\ttitle: \"Odaberi naloge za prijenos\",\n\t\t\tbutton: \"Generiraj lozinku\",\n\t\t\tdeselectAll: \"Makni odabir sa svih\",\n\t\t\tselectAll: \"Odaberi sve\",\n\t\t\tunavailable: \"Prijenos nije dostupan\",\n\t\t\terror: \"Nalog ne postoji\",\n\t\t\twarningLedger: \"Potrebna ledger podrška\",\n\t\t\tnoBalance: \"Nalog nema sredstava\"\n\t\t},\n\t\tgetPassphrase: {\n\t\t\ttitle: \"Kopiraj privremenu lozinku\",\n\t\t\tdesc: \"Bit će potrebno unijeti ovu lozinku na početku izvoza naloga na drugi wallet.\",\n\t\t\tbutton: \"Nastavi\",\n\t\t\tlabel: \"Klikni za kopiju\",\n\t\t\tcheckLabel: \"Kopirao sam ili zapisao lozinku\"\n\t\t},\n\t\tcomplete: {\n\t\t\ttitle: \"Završi prijenos\",\n\t\t\tdescOne: \"You will now be redirected to the wallet you selected to complete the transfer.\",\n\t\t\tdescTwo: \"Kada je unos s odabranog walleta završen, pritisnite gumb da biste završili prijenos.\",\n\t\t\tbutton: \"Završi\"\n\t\t}\n\t}\n};\nvar hr = {\n\tmodal: modal$3\n};\n\nvar modal$2 = {\n\twallet: {\n\t\tconnectYourWallet: \"Поврзете го вашиот новчаник!\",\n\t\twhatIsAWallet: \"Што е новчаник?\",\n\t\tsecureAndManage: \"Заштитете ги и управувајте со вашите дигитални средства.\",\n\t\tsafelyStore: \"Безбедно складирајте и извршувајте трансакции со вашите крипто и NFT.\",\n\t\tlogInToAny: \"Најавете се на која било NEAR апликација\",\n\t\tnoNeedToCreate: \"Нема потреба да креирате нови сметки или ингеренции. Поврзете го вашиот паричник и сте подготвени!\",\n\t\tgetAWallet: \"Направете новчаник\",\n\t\tuseAWallet: \"Користете паричник за да ги заштитите и управувате вашите NEAR средства и да се најавите на која било NEAR апликација без потреба од кориснички имиња и лозинки.\",\n\t\tconnectionFailed: \"Поврзувањето не беше успешно.\",\n\t\tconnectionSuccessful: \"Успешно поврзување.\",\n\t\tconnected: \"Поврзано.\",\n\t\tconnectingTo: \"Поврзување со\",\n\t\tconnectingMessage: {\n\t\t\tinjected: \"Потврдете го поврзувањето во екстерниот прозорец\",\n\t\t\tbrowser: \"По преусмерувањето, потврдете го поврзувањето од новчаниокт\",\n\t\t\thardware: \"Потврдете го поврзувањето со ладен новчаник\",\n\t\t\tbridge: \"Потврдете ја врската во новчаникот\"\n\t\t}\n\t},\n\tledger: {\n\t\tconnectWithLedger: \"Поврзете се со Леџер\",\n\t\tmakeSureYourLedger: \"Осигурајте се дека вашиот Леџер е поврзан безбедно, и дека NEAR апликацијата е отворена на вашиот уред\",\n\t\t\"continue\": \"Продолжете\",\n\t\tspecifyHDPath: \"Наведете ХД локација\",\n\t\tenterYourPreferredHDPath: \"Внесете ја вашата преферирана ХД локација, а потоа скенирајте да ги најдете активните сметки.\",\n\t\tscan: \"Скенирајте\",\n\t\tretry: \"Обидете се повторно\",\n\t\tledgerIsNotAvailable: \"Леџерот не е достапен.\",\n\t\taccessDeniedToUseLedgerDevice: \"Пристапот за користење на Леџер уред е одбиен\",\n\t\tnoAccountsFound: \"Нема најдени сметки\",\n\t\tselectYourAccounts: \"Изберете ги вашите сметки\",\n\t\tconnecting1Account: \"Поврзување на една сметка\",\n\t\tcantFindAnyAccount: \"Не се најдени сметки поврзани со овој Леџер. Ве молиме креирајте нова NEAR сметка \",\n\t\torConnectAnAnotherLedger: \"или поврзете друг Леџер.\",\n\t\tconnecting: \"Поврзување\",\n\t\tofAccounts: \"на сметки\",\n\t\tfailedToAutomatically: \"Неуспешно автоматско барање на ИД на сметката. Внесете го рачно:\",\n\t\toverviewTheListOfAuthorized: \"Преглед на листата на овластени сметки, завршете се најавата со кликнување на копчето подолу.\",\n\t\tfinish: \"Завршете\"\n\t},\n\tinstall: {\n\t\tyoullNeedToInstall: \"Треба да инсталирате\",\n\t\ttoContinueAfterInstalling: \"за да продолжите. По инсталирањето\",\n\t\trefreshThePage: \"Освежете ја страната.\",\n\t\topen: \"Отворете\"\n\t},\n\tqr: {\n\t\tcopiedToClipboard: \"Копирано на клипбордот\",\n\t\tfailedToCopy: \"Неуспешно копирање на клипборд\",\n\t\tscanWithYourMobile: \"Скенирајте со вашиот телефонски уред\",\n\t\tcopyToClipboard: \"Копирајте на клипборд\",\n\t\tpreferTheOfficial: \"Преферирајте официјален диалог на\",\n\t\topen: \"Отворете\"\n\t},\n\twalletTypes: {\n\t\thardware: \"Хардверски новчаник\",\n\t\tbrowser: \"Новчаник на интернет прелистувач\",\n\t\tinjected: \"Екстензија за новчаник\",\n\t\tbridge: \"Bridge новчаник\",\n\t\tmobile: \"Мобилен новчаник\",\n\t\t\"instant-link\": \"Инстант паричник\"\n\t},\n\texportAccounts: {\n\t\tchooseAWallet: \"Одберете паричник\",\n\t\ttransferYourAccounts: \"Префрлете ги вашите кориснички сметки\",\n\t\tselectAWallet: \"Изберетен новчаник кој ги задоволува вашите баранња и ги поддржува вашите поврзани кориснички сметки.\",\n\t\tselectYourAccounts: \"Изберете ги вашите кориснички сметки\",\n\t\tafterDecide: \"Одкако ќе изберете новчаник, можете да изберете кои кориснички сметки сакате да ги префрлите.\",\n\t\tdisclaimer: \"Не можете да прфрлате кориснички сметки кои никогаш не биле надополнати или користени на NEAR.\",\n\t\twarning: \"не поддржува извезување на кориснички сметки во овој момент. Ве молиме изберете друг новчаник.\",\n\t\twalletTypes: {\n\t\t\thardware: \"Хардверски новчаник\",\n\t\t\tbrowser: \"Новчаник на интернет прелистувач\",\n\t\t\tinjected: \"Екстензија за новчаник\",\n\t\t\tbridge: \"Bridge новчаник\",\n\t\t\tmobile: \"Мобилен новчаник\"\n\t\t},\n\t\tselectAccounts: {\n\t\t\ttitle: \"Изберете ги корисничките сметки за да ги префрлите.\",\n\t\t\tbutton: \"Добијте лозинка\",\n\t\t\tdeselectAll: \"Отселектирајте се\",\n\t\t\tselectAll: \"Изберете се\",\n\t\t\tunavailable: \"Трансферот е недостапен\",\n\t\t\terror: \"Корисничката сметка не постои\",\n\t\t\twarningLedger: \"Потребна е поддршка од Леџер\",\n\t\t\tnoBalance: \"Сметката не е финансирана\"\n\t\t},\n\t\tgetPassphrase: {\n\t\t\ttitle: \"Копирајте ја привремената лозинка\",\n\t\t\tdesc: \"Ќе треба да ја внесете оваа лозинка кога ќе започнете да ги извезувате вашите сметки на друг новчаник.\",\n\t\t\tbutton: \"Продолжете\",\n\t\t\tlabel: \"Кликнете за да копирате\",\n\t\t\tcheckLabel: \"Ја копирав или запишав лозинката\"\n\t\t},\n\t\tcomplete: {\n\t\t\ttitle: \"Завршете го преносот\",\n\t\t\tdescOne: \"Сега ќе бидете пренасочени на избраниот новчаник за завршување на преносот.\",\n\t\t\tdescTwo: \"Откако ќе заврши увозот од избраниот новчаник, притиснете го копчето за да го завршите преносот.\",\n\t\t\tbutton: \"Завршете\"\n\t\t}\n\t}\n};\nvar mk = {\n\tmodal: modal$2\n};\n\nvar modal$1 = {\n\twallet: {\n\t\tconnectYourWallet: \"Povežite svojo denarnico!\",\n\t\twhatIsAWallet: \"Kaj je denarnica?\",\n\t\tsecureAndManage: \"Zavarujte in upravljajte svoja digitalna sredstva.\",\n\t\tsafelyStore: \"Varno shranjujte in prenašajte svoje kriptovalute in NFTje.\",\n\t\tlogInToAny: \"Prijavite se v katero koli aplikacijo na NEAR\",\n\t\tnoNeedToCreate: \"Ni vam treba ustvarjati novih računov. Povežite svojo denarnico in začnite!\",\n\t\tgetAWallet: \"Ustvarite denarnico\",\n\t\tuseAWallet: \"Uporabite denarnico, da bi zavarovali in upravljali s svoja NEAR digitalna sredstva, in se prijavite v katero koli aplikacijo ekosistema NEAR\",\n\t\tconnectionFailed: \"Povezava ni bila uspešna.\",\n\t\tconnectionSuccessful: \"Povezava je bila uspešna.\",\n\t\tconnected: \"Vaša denarnica je povezana.\",\n\t\tconnectingTo: \"Povezovanje z\",\n\t\tconnectingMessage: {\n\t\t\tinjected: \"Potrdite povezavo v oknu razširitve\",\n\t\t\tbrowser: \"Po preusmeritvi potrdite povezavo v denarnici\",\n\t\t\thardware: \"Potrdite povezavo s hladno denarnico\",\n\t\t\tbridge: \"Potrdite povezavo v denarnici\"\n\t\t}\n\t},\n\tledger: {\n\t\tconnectWithLedger: \"Povežite se z Ledger\",\n\t\tmakeSureYourLedger: \"Prepričajte se, da je vaš Ledger varno povezan in da je aplikacija NEAR odprta v vaši napravi\",\n\t\t\"continue\": \"Nadaljuj\",\n\t\tspecifyHDPath: \"Določite HD pot\",\n\t\tenterYourPreferredHDPath: \"Vnesite želeno HD pot, nato poiščite vse aktivne račune.\",\n\t\tscan: \"Skenirajte\",\n\t\tretry: \"Poskusite znova\",\n\t\tledgerIsNotAvailable: \"Ledger ni na voljo\",\n\t\taccessDeniedToUseLedgerDevice: \"Dostop za uporabo naprave Ledger zavrnjen\",\n\t\tnoAccountsFound: \"Ni najdenih računov\",\n\t\tselectYourAccounts: \"Izberite Vaši računi\",\n\t\tconnecting1Account: \"Povezovanje enega računa\",\n\t\tcantFindAnyAccount: \"Ni mogoče najti nobenega računa, povezanega s tem Ledgerjem. Ustvarite nov NEAR račun \",\n\t\torConnectAnAnotherLedger: \"ali povežite drug Ledger..\",\n\t\tconnecting: \"Povezovanje\",\n\t\tofAccounts: \"računov\",\n\t\tfailedToAutomatically: \"ID-ja računa ni bilo mogoče samodejno najti. Zagotovite ga ročno:\",\n\t\toverviewTheListOfAuthorized: \"Oglejte si seznam pooblaščenih računov, dokončajte prijavo s klikom na spodnji gumb.\",\n\t\tfinish: \"Končajte\"\n\t},\n\tinstall: {\n\t\tyoullNeedToInstall: \"Morali ga boste namestiti\",\n\t\ttoContinueAfterInstalling: \"nadaljevati. Po namestitvi\",\n\t\trefreshThePage: \"Osvežite stran.\",\n\t\topen: \"Odprite\"\n\t},\n\tqr: {\n\t\tcopiedToClipboard: \"Kopirano v podložni mapi\",\n\t\tfailedToCopy: \"Kopiranje v podložni mapi ni uspelo\",\n\t\tscanWithYourMobile: \"Skenirajte s svojo mobilno napravo\",\n\t\tcopyToClipboard: \" Kopirajte v podložni mapi\",\n\t\tpreferTheOfficial: \"Preferirajte uradno pogovorno okno\",\n\t\topen: \"Odprite\"\n\t},\n\twalletTypes: {\n\t\thardware: \"Hladna denarnica\",\n\t\tbrowser: \"Denarnica brskalnika\",\n\t\tinjected: \"Razširitev za denarnico\",\n\t\tbridge: \"Bridge denarnica\",\n\t\tmobile: \"Mobilna denarnica\",\n\t\t\"instant-link\": \"Takojšnja denarnica\"\n\t},\n\texportAccounts: {\n\t\tchooseAWallet: \"Izberite denarnico\",\n\t\ttransferYourAccounts: \"Prenesite svoje račune\",\n\t\tselectAWallet: \"Izberite denarnico, ki ustreza vašim potrebam in podpira vaše povezane račune.\",\n\t\tselectYourAccounts: \"Izberite vaši računi\",\n\t\tafterDecide: \"Ko se odločite za denarnico, lahko izberete, katere račune želite prenesti.\",\n\t\tdisclaimer: \"Ne boste mogli prenesti Računov, ki nikoli niso bili financirani ali uporabljeni na NEAR.\",\n\t\twarning: \"trenutno ne podpira izvoza računa. Izberite drugo denarnico\",\n\t\twalletTypes: {\n\t\t\thardware: \"Hladna denarnica\",\n\t\t\tbrowser: \"Denarnica brskalnika\",\n\t\t\tinjected: \"Razširitev za denarnico\",\n\t\t\tbridge: \"Bridge denarnica\",\n\t\t\tmobile: \"Mobilna denarnica\"\n\t\t},\n\t\tselectAccounts: {\n\t\t\ttitle: \"Izberite računi za prenos.\",\n\t\t\tbutton: \"Pridobite geslo\",\n\t\t\tdeselectAll: \"Prekliči izbiro vseh\",\n\t\t\tselectAll: \"Izberi vse\",\n\t\t\tunavailable: \"Prenos ni na voljo\",\n\t\t\terror: \"Račun ne obstaja\",\n\t\t\twarningLedger: \"Potrebna je podpora za Ledger\",\n\t\t\tnoBalance: \"Račun ni financiran\"\n\t\t},\n\t\tgetPassphrase: {\n\t\t\ttitle: \"Kopiraj začasno geslo\",\n\t\t\tdesc: \"To geslo boste morali vnesti, ko boste začeli izvažati svoje račune v drugo denarnico.\",\n\t\t\tbutton: \"Nadaljujte\",\n\t\t\tlabel: \"Kliknite za kopiranje\",\n\t\t\tcheckLabel: \"Geslo sem kopiral ali zapisal\"\n\t\t},\n\t\tcomplete: {\n\t\t\ttitle: \"Dokončajte prenos\",\n\t\t\tdescOne: \"Zdaj boste preusmerjeni v denarnico, ki ste jo izbrali za dokončanje prenosa.\",\n\t\t\tdescTwo: \"Ko je uvozni del postopka končan iz izbrane denarnice, pritisnite gumb za dokončanje postopka prenosa.\",\n\t\t\tbutton: \"Končajte\"\n\t\t}\n\t}\n};\nvar sl = {\n\tmodal: modal$1\n};\n\nvar modal = {\n\twallet: {\n\t\tconnectYourWallet: \"Повежите свој новчаник!\",\n\t\twhatIsAWallet: \"Шта је новчаник?\",\n\t\tsecureAndManage: \"Обезбедите и управљајте својом дигиталном имовином.\",\n\t\tsafelyStore: \"Безбедно чувајте и преносите своје криптовалуте и NFT.\",\n\t\tlogInToAny: \"Пријавите се на било коју апликацију NEAR\",\n\t\tnoNeedToCreate: \"Нема потребе да креирате нове налоге или акредитиве. Повежите новчаник и спремни стe!\",\n\t\tgetAWallet: \"Набавите новчаник\",\n\t\tuseAWallet: \"Користите новчаник да обезбедите и управљате својим NEAR средствима и да се пријавите у било коју апликацију NEAR без потребе за корисничким именима и лозинкама.\",\n\t\tconnectionFailed: \"Веза није успостављена.\",\n\t\tconnectionSuccessful: \"Веза је успела.\",\n\t\tconnected: \"Повезан.\",\n\t\tconnectingTo: \"Повезивање на\",\n\t\tconnectingMessage: {\n\t\t\tinjected: \"Потврдите везу у спољном прозору\",\n\t\t\tbrowser: \"Након преусмеравања, потврдите везу у новчанику\",\n\t\t\thardware: \"Потврдите везу са хладним новчаником\",\n\t\t\tbridge: \"Потврдите везу са новчаником\"\n\t\t}\n\t},\n\tledger: {\n\t\tconnectWithLedger: \"Повежите се са Ledger\",\n\t\tmakeSureYourLedger: \"Уверите се да је ваш Ledger безбедно повезан и да је апликација NEAR отворена на вашем уређају\",\n\t\t\"continue\": \"Настави\",\n\t\tspecifyHDPath: \"Наведите ХД путању\",\n\t\tenterYourPreferredHDPath: \"Унесите жељену жељену ХД путању, а затим скенирајте све активне налоге.\",\n\t\tscan: \"Скенирајте\",\n\t\tretry: \"Покушај поново\",\n\t\tledgerIsNotAvailable: \"Ledger није доступан.\",\n\t\taccessDeniedToUseLedgerDevice: \"Приступ је одбијен за коришћење Ledger уређаја\",\n\t\tnoAccountsFound: \"Наlози нису пронађени\",\n\t\tselectYourAccounts: \"Изаберите Ваш наlог\",\n\t\tconnecting1Account: \"Повезати 1 наlог\",\n\t\tcantFindAnyAccount: \"Није могуће пронаћи ниједан наlог повезан са овим Ledger-ом. Направите нови NEAR наlог\",\n\t\torConnectAnAnotherLedger: \"или повежите други Ledger.\",\n\t\tconnecting: \"Повезивање\",\n\t\tofAccounts: \"наlога\",\n\t\tfailedToAutomatically: \"Аутоматско проналажење ID-a наlога није успело. Наведите га ручно:\",\n\t\toverviewTheListOfAuthorized: \"Прегледајте листу овлашћених рачуна, завршите пријаву кликом на дугме испод.\",\n\t\tfinish: \"Заврши\"\n\t},\n\tinstall: {\n\t\tyoullNeedToInstall: \"Мораћете да инсталирате\",\n\t\ttoContinueAfterInstalling: \"за наставак. Након инсталирања\",\n\t\trefreshThePage: \"поново учитати страницу.\",\n\t\topen: \"Отвори\"\n\t},\n\tqr: {\n\t\tcopiedToClipboard: \"Копирано у међуспремник\",\n\t\tfailedToCopy: \"Копирање у међуспремник није успело\",\n\t\tscanWithYourMobile: \"Скенирајте помоћу мобилног уређаја\",\n\t\tcopyToClipboard: \" Копирај у међуспремник\",\n\t\tpreferTheOfficial: \"Преферирате званични дијалог од\",\n\t\topen: \"Отвори\"\n\t},\n\twalletTypes: {\n\t\thardware: \"Хардверски новчаник\",\n\t\tbrowser: \"Новчаник претраживача,\",\n\t\tinjected: \"Додатак за новчаник,\",\n\t\tbridge: \"Bridge новчаник\",\n\t\tmobile: \"Мобилни новчаник\",\n\t\t\"instant-link\": \"Инстант новчаник\"\n\t},\n\texportAccounts: {\n\t\tchooseAWallet: \"Изаберите новчаник\",\n\t\ttransferYourAccounts: \"Пренесите своје налоге\",\n\t\tselectAWallet: \"Изаберите новчаник који одговара вашим потребама и који подржава ваше повезане налоге.\",\n\t\tselectYourAccounts: \"Изаберите ваше налоге\",\n\t\tafterDecide: \"Након што се одлучите за новчаник, можете изабрати које налоге желите да пренесете.\",\n\t\tdisclaimer: \"Нећете моћи да пренесете налоге који никада нису били финансирани или коришћени на  NEAR.\",\n\t\twarning: \"тренутно не подржава извоз налога. Изаберите други новчаник.\",\n\t\twalletTypes: {\n\t\t\thardware: \"Хардверски новчаник\",\n\t\t\tbrowser: \"Новчаник претраживача,\",\n\t\t\tinjected: \"Додатак за новчаник,\",\n\t\t\tbridge: \"Bridge новчаник\",\n\t\t\tmobile: \"Мобилни новчаник\"\n\t\t},\n\t\tselectAccounts: {\n\t\t\ttitle: \"Изаберите налоге за пренос.\",\n\t\t\tbutton: \"Добијте приступну фразу\",\n\t\t\tdeselectAll: \"Поништите избор\",\n\t\t\tselectAll: \"Изаберите све\",\n\t\t\tunavailable: \"Трансфер није доступан\",\n\t\t\terror: \"Налог не постоји\",\n\t\t\twarningLedger: \"Потребна подршка за Ledger\",\n\t\t\tnoBalance: \"Налог није финансиран\"\n\t\t},\n\t\tgetPassphrase: {\n\t\t\ttitle: \"Копирај привремену лозинку\",\n\t\t\tdesc: \"Мораћете да унесете ову лозинку када почнете да извозите своје налоге у други новчаник.\",\n\t\t\tbutton: \"Наставите\",\n\t\t\tlabel: \"Кликните да бисте копирали\",\n\t\t\tcheckLabel: \"Копирао сам или записао лозинку\"\n\t\t},\n\t\tcomplete: {\n\t\t\ttitle: \"Довршите трансфер\",\n\t\t\tdescOne: \"Сада ћете бити преусмерени на новчаник који сте изабрали да завршите трансфер.\",\n\t\t\tdescTwo: \"Када се део процеса увоза заврши из изабраног новчаника, притисните дугме да завршите процес преноса.\",\n\t\t\tbutton: \"Завршите\"\n\t\t}\n\t}\n};\nvar sr = {\n\tmodal: modal\n};\n\nconst getLanguage = languageCode => {\n  switch (languageCode) {\n    case \"en\":\n      return en;\n    case \"es\":\n      return es;\n    case \"zh\":\n      return zh;\n    case \"bg\":\n      return bg;\n    case \"ko\":\n      return ko;\n    case \"vi\":\n      return vi;\n    case \"hi\":\n      return hi;\n    case \"ar\":\n      return ar;\n    case \"hr\":\n      return hr;\n    case \"mk\":\n      return mk;\n    case \"sl\":\n      return sl;\n    case \"sr\":\n      return sr;\n    default:\n      return en;\n  }\n};\nlet chosenLang;\nconst allowOnlyLanguage = langCode => {\n  chosenLang = langCode;\n};\n// (i.e en-CA returns just en)\nconst shortenLanguageCode = lang => {\n  return lang.indexOf(\"-\") !== -1 ? lang.split(\"-\")[0] : lang.split(\"_\")[0];\n};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst findObjectPropByStringPath = (obj, prop) => {\n  if (!obj) {\n    return \"\";\n  }\n  const _index = prop.indexOf(\".\");\n  if (_index > -1) {\n    const currentProp = prop.substring(0, _index);\n    const nextProp = prop.substring(_index + 1);\n    return findObjectPropByStringPath(obj[currentProp], nextProp);\n  }\n  return obj[prop];\n};\nconst translate = path => {\n  let browserLang = window.navigator.languages ? window.navigator.languages[0] : null;\n  browserLang = browserLang || window.navigator.language;\n  const languageCode = shortenLanguageCode(chosenLang || browserLang);\n  const selectedLanguage = getLanguage(languageCode);\n  const text = findObjectPropByStringPath(selectedLanguage, path);\n  return text && typeof text === \"string\" ? text : path;\n};\n\nexports.EventEmitter = EventEmitter;\nexports.allowOnlyLanguage = allowOnlyLanguage;\nexports.getActiveAccount = getActiveAccount;\nexports.isCurrentBrowserSupported = isCurrentBrowserSupported;\nexports.serializeNep413 = serializeNep413;\nexports.setupWalletSelector = setupWalletSelector;\nexports.translate = translate;\nexports.verifyFullKeyBelongsToUser = verifyFullKeyBelongsToUser;\nexports.verifySignature = verifySignature;\nexports.waitFor = waitFor;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5lYXItd2FsbGV0LXNlbGVjdG9yL2NvcmUvaW5kZXguY2pzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QyxFQUFFLGFBQWEsRUFBQzs7QUFFN0QsY0FBYyxtQkFBTyxDQUFDLGtFQUFhO0FBQ25DLGFBQWEsbUJBQU8sQ0FBQyxzQkFBUTtBQUM3QixXQUFXLG1CQUFPLENBQUMsMERBQU07QUFDekIsWUFBWSxtQkFBTyxDQUFDLHNEQUFPO0FBQzNCLGVBQWUsbUJBQU8sQ0FBQywrREFBVzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsZ0JBQWdCO0FBQzFEO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLGdCQUFnQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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TUFBTSxtRkFBbUY7QUFDekY7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsZ0JBQWdCO0FBQzlFO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFVBQVU7QUFDekQsRUFBRSxnQkFBZ0I7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdCQUFnQjtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlFQUF5RSxhQUFhO0FBQ3RGLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sOEVBQThFO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxrRkFBa0Y7QUFDeEY7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxjQUFjO0FBQzdFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sNEVBQTRFO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0scUVBQXFFO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLG1FQUFtRTtBQUN6RTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0JBQWdCO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBLGtFQUFrRSwyREFBMkQ7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0I7O0FBRS9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsOENBQThDO0FBQzlDLGdEQUFnRDtBQUNoRCxNQUFNLHFCQUFxQjtBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLG9CQUFvQjtBQUMvQztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxXQUFXLG9GQUFvRjtBQUNyRzs7QUFFQTtBQUNBO0FBQ0Esc0VBQXNFLGVBQWU7QUFDckY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLCtCQUErQjtBQUMvQixpQ0FBaUM7QUFDakMsV0FBVztBQUNYLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQyxpQkFBaUI7QUFDdEQsRUFBRSxnQkFBZ0I7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsTUFBTSx3REFBd0Q7QUFDOUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE1BQU0saUJBQWlCO0FBQ3ZCLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU0sMEVBQTBFO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLCtDQUErQztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLHFCQUFxQjtBQUM5QztBQUNBO0FBQ0EseUJBQXlCLG9CQUFvQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSx1RUFBdUU7QUFDN0U7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxNQUFNLDZCQUE2QjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRyxLQUFLLE1BQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxlQUFlO0FBQzdELG1CQUFtQiwwQ0FBMEM7QUFDN0QsQ0FBQyxzQ0FBc0M7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDBFQUEwRTtBQUNoRjtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFVBQVU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGtFQUFrRSxxQkFBcUI7QUFDdkY7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0IsS0FBSyxRQUFRO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwyQkFBMkI7QUFDakQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLHNCQUFzQix5QkFBeUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFVBQVU7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLCtDQUErQztBQUMvQztBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULDZDQUE2QztBQUM3QztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCw2Q0FBNkM7QUFDN0M7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHNCQUFzQjtBQUNqQyxhQUFhLHlCQUF5QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsc0JBQXNCLHFCQUFxQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsd0NBQXdDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxXQUFXO0FBQzNELEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLG9FQUFvRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLDREQUE0RDtBQUNsRTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsbzdCQUFvN0IsNENBQTRDLHlKQUF5Siw2REFBNkQ7QUFDdHJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlCQUFpQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnQkFBZ0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0JBQWdCO0FBQ3hCLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxZQUFZO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0RBQWdELG1CQUFtQix5Q0FBeUM7QUFDNUc7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFdBQVc7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMEVBQTBFLGdCQUFnQjtBQUMxRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRyxJQUFJLGNBQWM7QUFDckI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsTUFBTSwyRUFBMkU7QUFDakY7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLENBQUM7O0FBRUQsNkJBQTZCOztBQUU3Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzQkFBc0Isa0VBQWtFO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGdCQUFnQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQSw0Q0FBNEM7QUFDNUMsNENBQTRDO0FBQzVDLDRDQUE0QztBQUM1Qyw4Q0FBOEM7QUFDOUMsVUFBVTtBQUNWLDRDQUE0QztBQUM1Qyw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNLGtFQUFrRTtBQUN4RTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLFFBQVEsbUZBQW1GOztBQUUzRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFLG1EQUFtRDs7QUFFckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1QkFBdUIsbUJBQW1CO0FBQ3BFO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxnQ0FBZ0M7QUFDaEMsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixhQUFhO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVILGtCQUFrQixhQUFhO0FBQy9CO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLG1CQUFtQjs7QUFFL0M7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGVBQWU7QUFDZixLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0Y7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLDBCQUEwQixtQkFBbUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CO0FBQ3BCLHlCQUF5QjtBQUN6Qix3QkFBd0I7QUFDeEIsaUNBQWlDO0FBQ2pDLHVCQUF1QjtBQUN2QiwyQkFBMkI7QUFDM0IsaUJBQWlCO0FBQ2pCLGtDQUFrQztBQUNsQyx1QkFBdUI7QUFDdkIsZUFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL251cnNlYmxvYy8uL25vZGVfbW9kdWxlcy9AbmVhci13YWxsZXQtc2VsZWN0b3IvY29yZS9pbmRleC5janM/MGZjNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBuZWFyQVBJID0gcmVxdWlyZSgnbmVhci1hcGktanMnKTtcbnZhciBldmVudHMgPSByZXF1aXJlKCdldmVudHMnKTtcbnZhciByeGpzID0gcmVxdWlyZSgncnhqcycpO1xudmFyIGJvcnNoID0gcmVxdWlyZSgnYm9yc2gnKTtcbnZhciBqc1NoYTI1NiA9IHJlcXVpcmUoJ2pzLXNoYTI1NicpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcE5hbWVzcGFjZShlKSB7XG4gICAgaWYgKGUgJiYgZS5fX2VzTW9kdWxlKSByZXR1cm4gZTtcbiAgICB2YXIgbiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgaWYgKGUpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoZSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgaWYgKGsgIT09ICdkZWZhdWx0Jykge1xuICAgICAgICAgICAgICAgIHZhciBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBrKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgaywgZC5nZXQgPyBkIDoge1xuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVba107IH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5bXCJkZWZhdWx0XCJdID0gZTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShuKTtcbn1cblxudmFyIG5lYXJBUElfX25hbWVzcGFjZSA9IC8qI19fUFVSRV9fKi9faW50ZXJvcE5hbWVzcGFjZShuZWFyQVBJKTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblxyXG5mdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG50eXBlb2YgU3VwcHJlc3NlZEVycm9yID09PSBcImZ1bmN0aW9uXCIgPyBTdXBwcmVzc2VkRXJyb3IgOiBmdW5jdGlvbiAoZXJyb3IsIHN1cHByZXNzZWQsIG1lc3NhZ2UpIHtcclxuICAgIHZhciBlID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG4gICAgcmV0dXJuIGUubmFtZSA9IFwiU3VwcHJlc3NlZEVycm9yXCIsIGUuZXJyb3IgPSBlcnJvciwgZS5zdXBwcmVzc2VkID0gc3VwcHJlc3NlZCwgZTtcclxufTtcblxuY2xhc3MgUHJvdmlkZXIge1xuICBjb25zdHJ1Y3Rvcih1cmwpIHtcbiAgICB0aGlzLnByb3ZpZGVyID0gbmV3IG5lYXJBUElfX25hbWVzcGFjZS5wcm92aWRlcnMuSnNvblJwY1Byb3ZpZGVyKHtcbiAgICAgIHVybFxuICAgIH0pO1xuICB9XG4gIHF1ZXJ5KHBhcmFtcykge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLnF1ZXJ5KHBhcmFtcyk7XG4gIH1cbiAgdmlld0FjY2Vzc0tleSh7XG4gICAgYWNjb3VudElkLFxuICAgIHB1YmxpY0tleVxuICB9KSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnkoe1xuICAgICAgcmVxdWVzdF90eXBlOiBcInZpZXdfYWNjZXNzX2tleVwiLFxuICAgICAgZmluYWxpdHk6IFwiZmluYWxcIixcbiAgICAgIGFjY291bnRfaWQ6IGFjY291bnRJZCxcbiAgICAgIHB1YmxpY19rZXk6IHB1YmxpY0tleVxuICAgIH0pO1xuICB9XG4gIGJsb2NrKHJlZmVyZW5jZSkge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLmJsb2NrKHJlZmVyZW5jZSk7XG4gIH1cbiAgc2VuZFRyYW5zYWN0aW9uKHNpZ25lZFRyYW5zYWN0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuc2VuZFRyYW5zYWN0aW9uKHNpZ25lZFRyYW5zYWN0aW9uKTtcbiAgfVxufVxuXG5jb25zdCBLRVlfREVMSU1JVEVSID0gXCI6XCI7XG5jbGFzcyBKc29uU3RvcmFnZSB7XG4gIGNvbnN0cnVjdG9yKHN0b3JhZ2UsIG5hbWVzcGFjZSkge1xuICAgIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XG4gICAgdGhpcy5uYW1lc3BhY2UgPSBBcnJheS5pc0FycmF5KG5hbWVzcGFjZSkgPyBuYW1lc3BhY2Uuam9pbihLRVlfREVMSU1JVEVSKSA6IG5hbWVzcGFjZTtcbiAgfVxuICByZXNvbHZlS2V5KGtleSkge1xuICAgIHJldHVybiBbdGhpcy5uYW1lc3BhY2UsIGtleV0uam9pbihLRVlfREVMSU1JVEVSKTtcbiAgfVxuICBnZXRJdGVtKGtleSkge1xuICAgIHJldHVybiB0aGlzLnN0b3JhZ2UuZ2V0SXRlbSh0aGlzLnJlc29sdmVLZXkoa2V5KSkudGhlbihpdGVtID0+IHtcbiAgICAgIHJldHVybiB0eXBlb2YgaXRlbSA9PT0gXCJzdHJpbmdcIiA/IEpTT04ucGFyc2UoaXRlbSkgOiBudWxsO1xuICAgIH0pO1xuICB9XG4gIHNldEl0ZW0oa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLnN0b3JhZ2Uuc2V0SXRlbSh0aGlzLnJlc29sdmVLZXkoa2V5KSwgSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbiAgfVxuICByZW1vdmVJdGVtKGtleSkge1xuICAgIHJldHVybiB0aGlzLnN0b3JhZ2UucmVtb3ZlSXRlbSh0aGlzLnJlc29sdmVLZXkoa2V5KSk7XG4gIH1cbn1cblxudmFyIGNvbW1vbmpzR2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge307XG5cbnZhciBjaGVjayA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgJiYgaXQuTWF0aCA9PSBNYXRoICYmIGl0O1xufTtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwkdCA9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLWdsb2JhbC10aGlzIC0tIHNhZmVcbiAgY2hlY2sodHlwZW9mIGdsb2JhbFRoaXMgPT0gJ29iamVjdCcgJiYgZ2xvYmFsVGhpcykgfHxcbiAgY2hlY2sodHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cpIHx8XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHMgLS0gc2FmZVxuICBjaGVjayh0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmKSB8fFxuICBjaGVjayh0eXBlb2YgY29tbW9uanNHbG9iYWwgPT0gJ29iamVjdCcgJiYgY29tbW9uanNHbG9iYWwpIHx8XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuYyAtLSBmYWxsYmFja1xuICAoZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSkoKSB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG52YXIgb2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0ge307XG5cbnZhciBmYWlscyRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cbnZhciBmYWlscyRyID0gZmFpbHMkcztcblxuLy8gRGV0ZWN0IElFOCdzIGluY29tcGxldGUgZGVmaW5lUHJvcGVydHkgaW1wbGVtZW50YXRpb25cbnZhciBkZXNjcmlwdG9ycyA9ICFmYWlscyRyKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sIDEsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pWzFdICE9IDc7XG59KTtcblxudmFyIGZhaWxzJHEgPSBmYWlscyRzO1xuXG52YXIgZnVuY3Rpb25CaW5kTmF0aXZlID0gIWZhaWxzJHEoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1mdW5jdGlvbi1wcm90b3R5cGUtYmluZCAtLSBzYWZlXG4gIHZhciB0ZXN0ID0gKGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSkuYmluZCgpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zIC0tIHNhZmVcbiAgcmV0dXJuIHR5cGVvZiB0ZXN0ICE9ICdmdW5jdGlvbicgfHwgdGVzdC5oYXNPd25Qcm9wZXJ0eSgncHJvdG90eXBlJyk7XG59KTtcblxudmFyIE5BVElWRV9CSU5EJDMgPSBmdW5jdGlvbkJpbmROYXRpdmU7XG5cbnZhciBjYWxsJGwgPSBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbDtcblxudmFyIGZ1bmN0aW9uQ2FsbCA9IE5BVElWRV9CSU5EJDMgPyBjYWxsJGwuYmluZChjYWxsJGwpIDogZnVuY3Rpb24gKCkge1xuICByZXR1cm4gY2FsbCRsLmFwcGx5KGNhbGwkbCwgYXJndW1lbnRzKTtcbn07XG5cbnZhciBvYmplY3RQcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHt9O1xuXG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbi8vIE5hc2hvcm4gfiBKREs4IGJ1Z1xudmFyIE5BU0hPUk5fQlVHID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDIgJiYgISRwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHsgMTogMiB9LCAxKTtcblxuLy8gYE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGVgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QucHJvdG90eXBlLnByb3BlcnR5aXNlbnVtZXJhYmxlXG5vYmplY3RQcm9wZXJ0eUlzRW51bWVyYWJsZS5mID0gTkFTSE9STl9CVUcgPyBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShWKSB7XG4gIHZhciBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDIodGhpcywgVik7XG4gIHJldHVybiAhIWRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci5lbnVtZXJhYmxlO1xufSA6ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQ1ID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn07XG5cbnZhciBOQVRJVkVfQklORCQyID0gZnVuY3Rpb25CaW5kTmF0aXZlO1xuXG52YXIgRnVuY3Rpb25Qcm90b3R5cGUkMiA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbnZhciBiaW5kJDcgPSBGdW5jdGlvblByb3RvdHlwZSQyLmJpbmQ7XG52YXIgY2FsbCRrID0gRnVuY3Rpb25Qcm90b3R5cGUkMi5jYWxsO1xudmFyIHVuY3VycnlUaGlzJHAgPSBOQVRJVkVfQklORCQyICYmIGJpbmQkNy5iaW5kKGNhbGwkaywgY2FsbCRrKTtcblxudmFyIGZ1bmN0aW9uVW5jdXJyeVRoaXMgPSBOQVRJVkVfQklORCQyID8gZnVuY3Rpb24gKGZuKSB7XG4gIHJldHVybiBmbiAmJiB1bmN1cnJ5VGhpcyRwKGZuKTtcbn0gOiBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIGZuICYmIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY2FsbCRrLmFwcGx5KGZuLCBhcmd1bWVudHMpO1xuICB9O1xufTtcblxudmFyIHVuY3VycnlUaGlzJG8gPSBmdW5jdGlvblVuY3VycnlUaGlzO1xuXG52YXIgdG9TdHJpbmckNyA9IHVuY3VycnlUaGlzJG8oe30udG9TdHJpbmcpO1xudmFyIHN0cmluZ1NsaWNlJDMgPSB1bmN1cnJ5VGhpcyRvKCcnLnNsaWNlKTtcblxudmFyIGNsYXNzb2ZSYXckMSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gc3RyaW5nU2xpY2UkMyh0b1N0cmluZyQ3KGl0KSwgOCwgLTEpO1xufTtcblxudmFyIHVuY3VycnlUaGlzJG4gPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGZhaWxzJHAgPSBmYWlscyRzO1xudmFyIGNsYXNzb2YkYiA9IGNsYXNzb2ZSYXckMTtcblxudmFyICRPYmplY3QkNCA9IE9iamVjdDtcbnZhciBzcGxpdCA9IHVuY3VycnlUaGlzJG4oJycuc3BsaXQpO1xuXG4vLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xudmFyIGluZGV4ZWRPYmplY3QgPSBmYWlscyRwKGZ1bmN0aW9uICgpIHtcbiAgLy8gdGhyb3dzIGFuIGVycm9yIGluIHJoaW5vLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvcmhpbm8vaXNzdWVzLzM0NlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zIC0tIHNhZmVcbiAgcmV0dXJuICEkT2JqZWN0JDQoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKTtcbn0pID8gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBjbGFzc29mJGIoaXQpID09ICdTdHJpbmcnID8gc3BsaXQoaXQsICcnKSA6ICRPYmplY3QkNChpdCk7XG59IDogJE9iamVjdCQ0O1xuXG52YXIgJFR5cGVFcnJvciRmID0gVHlwZUVycm9yO1xuXG4vLyBgUmVxdWlyZU9iamVjdENvZXJjaWJsZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXJlcXVpcmVvYmplY3Rjb2VyY2libGVcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDYgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ID09IHVuZGVmaW5lZCkgdGhyb3cgJFR5cGVFcnJvciRmKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gXCIgKyBpdCk7XG4gIHJldHVybiBpdDtcbn07XG5cbi8vIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSW5kZXhlZE9iamVjdCQzID0gaW5kZXhlZE9iamVjdDtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDUgPSByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDY7XG5cbnZhciB0b0luZGV4ZWRPYmplY3QkNiA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gSW5kZXhlZE9iamVjdCQzKHJlcXVpcmVPYmplY3RDb2VyY2libGUkNShpdCkpO1xufTtcblxuLy8gYElzQ2FsbGFibGVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1pc2NhbGxhYmxlXG52YXIgaXNDYWxsYWJsZSRuID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiB0eXBlb2YgYXJndW1lbnQgPT0gJ2Z1bmN0aW9uJztcbn07XG5cbnZhciBpc0NhbGxhYmxlJG0gPSBpc0NhbGxhYmxlJG47XG5cbnZhciBpc09iamVjdCRkID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IGlzQ2FsbGFibGUkbShpdCk7XG59O1xuXG52YXIgZ2xvYmFsJHMgPSBnbG9iYWwkdDtcbnZhciBpc0NhbGxhYmxlJGwgPSBpc0NhbGxhYmxlJG47XG5cbnZhciBhRnVuY3Rpb24gPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIGlzQ2FsbGFibGUkbChhcmd1bWVudCkgPyBhcmd1bWVudCA6IHVuZGVmaW5lZDtcbn07XG5cbnZhciBnZXRCdWlsdEluJDggPSBmdW5jdGlvbiAobmFtZXNwYWNlLCBtZXRob2QpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPCAyID8gYUZ1bmN0aW9uKGdsb2JhbCRzW25hbWVzcGFjZV0pIDogZ2xvYmFsJHNbbmFtZXNwYWNlXSAmJiBnbG9iYWwkc1tuYW1lc3BhY2VdW21ldGhvZF07XG59O1xuXG52YXIgdW5jdXJyeVRoaXMkbSA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG5cbnZhciBvYmplY3RJc1Byb3RvdHlwZU9mID0gdW5jdXJyeVRoaXMkbSh7fS5pc1Byb3RvdHlwZU9mKTtcblxudmFyIGdldEJ1aWx0SW4kNyA9IGdldEJ1aWx0SW4kODtcblxudmFyIGVuZ2luZVVzZXJBZ2VudCA9IGdldEJ1aWx0SW4kNygnbmF2aWdhdG9yJywgJ3VzZXJBZ2VudCcpIHx8ICcnO1xuXG52YXIgZ2xvYmFsJHIgPSBnbG9iYWwkdDtcbnZhciB1c2VyQWdlbnQkNSA9IGVuZ2luZVVzZXJBZ2VudDtcblxudmFyIHByb2Nlc3MkMyA9IGdsb2JhbCRyLnByb2Nlc3M7XG52YXIgRGVubyQxID0gZ2xvYmFsJHIuRGVubztcbnZhciB2ZXJzaW9ucyA9IHByb2Nlc3MkMyAmJiBwcm9jZXNzJDMudmVyc2lvbnMgfHwgRGVubyQxICYmIERlbm8kMS52ZXJzaW9uO1xudmFyIHY4ID0gdmVyc2lvbnMgJiYgdmVyc2lvbnMudjg7XG52YXIgbWF0Y2gsIHZlcnNpb247XG5cbmlmICh2OCkge1xuICBtYXRjaCA9IHY4LnNwbGl0KCcuJyk7XG4gIC8vIGluIG9sZCBDaHJvbWUsIHZlcnNpb25zIG9mIFY4IGlzbid0IFY4ID0gQ2hyb21lIC8gMTBcbiAgLy8gYnV0IHRoZWlyIGNvcnJlY3QgdmVyc2lvbnMgYXJlIG5vdCBpbnRlcmVzdGluZyBmb3IgdXNcbiAgdmVyc2lvbiA9IG1hdGNoWzBdID4gMCAmJiBtYXRjaFswXSA8IDQgPyAxIDogKyhtYXRjaFswXSArIG1hdGNoWzFdKTtcbn1cblxuLy8gQnJvd3NlckZTIE5vZGVKUyBgcHJvY2Vzc2AgcG9seWZpbGwgaW5jb3JyZWN0bHkgc2V0IGAudjhgIHRvIGAwLjBgXG4vLyBzbyBjaGVjayBgdXNlckFnZW50YCBldmVuIGlmIGAudjhgIGV4aXN0cywgYnV0IDBcbmlmICghdmVyc2lvbiAmJiB1c2VyQWdlbnQkNSkge1xuICBtYXRjaCA9IHVzZXJBZ2VudCQ1Lm1hdGNoKC9FZGdlXFwvKFxcZCspLyk7XG4gIGlmICghbWF0Y2ggfHwgbWF0Y2hbMV0gPj0gNzQpIHtcbiAgICBtYXRjaCA9IHVzZXJBZ2VudCQ1Lm1hdGNoKC9DaHJvbWVcXC8oXFxkKykvKTtcbiAgICBpZiAobWF0Y2gpIHZlcnNpb24gPSArbWF0Y2hbMV07XG4gIH1cbn1cblxudmFyIGVuZ2luZVY4VmVyc2lvbiA9IHZlcnNpb247XG5cbi8qIGVzbGludC1kaXNhYmxlIGVzLXgvbm8tc3ltYm9sIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nICovXG5cbnZhciBWOF9WRVJTSU9OJDEgPSBlbmdpbmVWOFZlcnNpb247XG52YXIgZmFpbHMkbyA9IGZhaWxzJHM7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eXN5bWJvbHMgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbnZhciBuYXRpdmVTeW1ib2wgPSAhIU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgJiYgIWZhaWxzJG8oZnVuY3Rpb24gKCkge1xuICB2YXIgc3ltYm9sID0gU3ltYm9sKCk7XG4gIC8vIENocm9tZSAzOCBTeW1ib2wgaGFzIGluY29ycmVjdCB0b1N0cmluZyBjb252ZXJzaW9uXG4gIC8vIGBnZXQtb3duLXByb3BlcnR5LXN5bWJvbHNgIHBvbHlmaWxsIHN5bWJvbHMgY29udmVydGVkIHRvIG9iamVjdCBhcmUgbm90IFN5bWJvbCBpbnN0YW5jZXNcbiAgcmV0dXJuICFTdHJpbmcoc3ltYm9sKSB8fCAhKE9iamVjdChzeW1ib2wpIGluc3RhbmNlb2YgU3ltYm9sKSB8fFxuICAgIC8vIENocm9tZSAzOC00MCBzeW1ib2xzIGFyZSBub3QgaW5oZXJpdGVkIGZyb20gRE9NIGNvbGxlY3Rpb25zIHByb3RvdHlwZXMgdG8gaW5zdGFuY2VzXG4gICAgIVN5bWJvbC5zaGFtICYmIFY4X1ZFUlNJT04kMSAmJiBWOF9WRVJTSU9OJDEgPCA0MTtcbn0pO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBlcy14L25vLXN5bWJvbCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZyAqL1xuXG52YXIgTkFUSVZFX1NZTUJPTCQxID0gbmF0aXZlU3ltYm9sO1xuXG52YXIgdXNlU3ltYm9sQXNVaWQgPSBOQVRJVkVfU1lNQk9MJDFcbiAgJiYgIVN5bWJvbC5zaGFtXG4gICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT0gJ3N5bWJvbCc7XG5cbnZhciBnZXRCdWlsdEluJDYgPSBnZXRCdWlsdEluJDg7XG52YXIgaXNDYWxsYWJsZSRrID0gaXNDYWxsYWJsZSRuO1xudmFyIGlzUHJvdG90eXBlT2YkNCA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG52YXIgVVNFX1NZTUJPTF9BU19VSUQkMSA9IHVzZVN5bWJvbEFzVWlkO1xuXG52YXIgJE9iamVjdCQzID0gT2JqZWN0O1xuXG52YXIgaXNTeW1ib2wkMyA9IFVTRV9TWU1CT0xfQVNfVUlEJDEgPyBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJztcbn0gOiBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyICRTeW1ib2wgPSBnZXRCdWlsdEluJDYoJ1N5bWJvbCcpO1xuICByZXR1cm4gaXNDYWxsYWJsZSRrKCRTeW1ib2wpICYmIGlzUHJvdG90eXBlT2YkNCgkU3ltYm9sLnByb3RvdHlwZSwgJE9iamVjdCQzKGl0KSk7XG59O1xuXG52YXIgJFN0cmluZyQzID0gU3RyaW5nO1xuXG52YXIgdHJ5VG9TdHJpbmckNSA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICB0cnkge1xuICAgIHJldHVybiAkU3RyaW5nJDMoYXJndW1lbnQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiAnT2JqZWN0JztcbiAgfVxufTtcblxudmFyIGlzQ2FsbGFibGUkaiA9IGlzQ2FsbGFibGUkbjtcbnZhciB0cnlUb1N0cmluZyQ0ID0gdHJ5VG9TdHJpbmckNTtcblxudmFyICRUeXBlRXJyb3IkZSA9IFR5cGVFcnJvcjtcblxuLy8gYEFzc2VydDogSXNDYWxsYWJsZShhcmd1bWVudCkgaXMgdHJ1ZWBcbnZhciBhQ2FsbGFibGUkOSA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAoaXNDYWxsYWJsZSRqKGFyZ3VtZW50KSkgcmV0dXJuIGFyZ3VtZW50O1xuICB0aHJvdyAkVHlwZUVycm9yJGUodHJ5VG9TdHJpbmckNChhcmd1bWVudCkgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG59O1xuXG52YXIgYUNhbGxhYmxlJDggPSBhQ2FsbGFibGUkOTtcblxuLy8gYEdldE1ldGhvZGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWdldG1ldGhvZFxudmFyIGdldE1ldGhvZCQ0ID0gZnVuY3Rpb24gKFYsIFApIHtcbiAgdmFyIGZ1bmMgPSBWW1BdO1xuICByZXR1cm4gZnVuYyA9PSBudWxsID8gdW5kZWZpbmVkIDogYUNhbGxhYmxlJDgoZnVuYyk7XG59O1xuXG52YXIgY2FsbCRqID0gZnVuY3Rpb25DYWxsO1xudmFyIGlzQ2FsbGFibGUkaSA9IGlzQ2FsbGFibGUkbjtcbnZhciBpc09iamVjdCRjID0gaXNPYmplY3QkZDtcblxudmFyICRUeXBlRXJyb3IkZCA9IFR5cGVFcnJvcjtcblxuLy8gYE9yZGluYXJ5VG9QcmltaXRpdmVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vcmRpbmFyeXRvcHJpbWl0aXZlXG52YXIgb3JkaW5hcnlUb1ByaW1pdGl2ZSQxID0gZnVuY3Rpb24gKGlucHV0LCBwcmVmKSB7XG4gIHZhciBmbiwgdmFsO1xuICBpZiAocHJlZiA9PT0gJ3N0cmluZycgJiYgaXNDYWxsYWJsZSRpKGZuID0gaW5wdXQudG9TdHJpbmcpICYmICFpc09iamVjdCRjKHZhbCA9IGNhbGwkaihmbiwgaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKGlzQ2FsbGFibGUkaShmbiA9IGlucHV0LnZhbHVlT2YpICYmICFpc09iamVjdCRjKHZhbCA9IGNhbGwkaihmbiwgaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKHByZWYgIT09ICdzdHJpbmcnICYmIGlzQ2FsbGFibGUkaShmbiA9IGlucHV0LnRvU3RyaW5nKSAmJiAhaXNPYmplY3QkYyh2YWwgPSBjYWxsJGooZm4sIGlucHV0KSkpIHJldHVybiB2YWw7XG4gIHRocm93ICRUeXBlRXJyb3IkZChcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07XG5cbnZhciBzaGFyZWQkNCA9IHtleHBvcnRzOiB7fX07XG5cbnZhciBnbG9iYWwkcSA9IGdsb2JhbCR0O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gc2FmZVxudmFyIGRlZmluZVByb3BlcnR5JDcgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbnZhciBkZWZpbmVHbG9iYWxQcm9wZXJ0eSQzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgdHJ5IHtcbiAgICBkZWZpbmVQcm9wZXJ0eSQ3KGdsb2JhbCRxLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGdsb2JhbCRxW2tleV0gPSB2YWx1ZTtcbiAgfSByZXR1cm4gdmFsdWU7XG59O1xuXG52YXIgZ2xvYmFsJHAgPSBnbG9iYWwkdDtcbnZhciBkZWZpbmVHbG9iYWxQcm9wZXJ0eSQyID0gZGVmaW5lR2xvYmFsUHJvcGVydHkkMztcblxudmFyIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nO1xudmFyIHN0b3JlJDMgPSBnbG9iYWwkcFtTSEFSRURdIHx8IGRlZmluZUdsb2JhbFByb3BlcnR5JDIoU0hBUkVELCB7fSk7XG5cbnZhciBzaGFyZWRTdG9yZSA9IHN0b3JlJDM7XG5cbnZhciBzdG9yZSQyID0gc2hhcmVkU3RvcmU7XG5cbihzaGFyZWQkNC5leHBvcnRzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIHN0b3JlJDJba2V5XSB8fCAoc3RvcmUkMltrZXldID0gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoge30pO1xufSkoJ3ZlcnNpb25zJywgW10pLnB1c2goe1xuICB2ZXJzaW9uOiAnMy4yMy4zJyxcbiAgbW9kZTogJ2dsb2JhbCcsXG4gIGNvcHlyaWdodDogJ8KpIDIwMTQtMjAyMiBEZW5pcyBQdXNoa2FyZXYgKHpsb2lyb2NrLnJ1KScsXG4gIGxpY2Vuc2U6ICdodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9ibG9iL3YzLjIzLjMvTElDRU5TRScsXG4gIHNvdXJjZTogJ2h0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzJ1xufSk7XG5cbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDQgPSByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDY7XG5cbnZhciAkT2JqZWN0JDIgPSBPYmplY3Q7XG5cbi8vIGBUb09iamVjdGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvb2JqZWN0XG52YXIgdG9PYmplY3QkNyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gJE9iamVjdCQyKHJlcXVpcmVPYmplY3RDb2VyY2libGUkNChhcmd1bWVudCkpO1xufTtcblxudmFyIHVuY3VycnlUaGlzJGwgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIHRvT2JqZWN0JDYgPSB0b09iamVjdCQ3O1xuXG52YXIgaGFzT3duUHJvcGVydHkgPSB1bmN1cnJ5VGhpcyRsKHt9Lmhhc093blByb3BlcnR5KTtcblxuLy8gYEhhc093blByb3BlcnR5YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaGFzb3ducHJvcGVydHlcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1oYXNvd24gLS0gc2FmZVxudmFyIGhhc093blByb3BlcnR5XzEgPSBPYmplY3QuaGFzT3duIHx8IGZ1bmN0aW9uIGhhc093bihpdCwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eSh0b09iamVjdCQ2KGl0KSwga2V5KTtcbn07XG5cbnZhciB1bmN1cnJ5VGhpcyRrID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcblxudmFyIGlkID0gMDtcbnZhciBwb3N0Zml4ID0gTWF0aC5yYW5kb20oKTtcbnZhciB0b1N0cmluZyQ2ID0gdW5jdXJyeVRoaXMkaygxLjAudG9TdHJpbmcpO1xuXG52YXIgdWlkJDMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiAnU3ltYm9sKCcgKyAoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSkgKyAnKV8nICsgdG9TdHJpbmckNigrK2lkICsgcG9zdGZpeCwgMzYpO1xufTtcblxudmFyIGdsb2JhbCRvID0gZ2xvYmFsJHQ7XG52YXIgc2hhcmVkJDMgPSBzaGFyZWQkNC5leHBvcnRzO1xudmFyIGhhc093biRiID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciB1aWQkMiA9IHVpZCQzO1xudmFyIE5BVElWRV9TWU1CT0wgPSBuYXRpdmVTeW1ib2w7XG52YXIgVVNFX1NZTUJPTF9BU19VSUQgPSB1c2VTeW1ib2xBc1VpZDtcblxudmFyIFdlbGxLbm93blN5bWJvbHNTdG9yZSA9IHNoYXJlZCQzKCd3a3MnKTtcbnZhciBTeW1ib2wkMSA9IGdsb2JhbCRvLlN5bWJvbDtcbnZhciBzeW1ib2xGb3IgPSBTeW1ib2wkMSAmJiBTeW1ib2wkMVsnZm9yJ107XG52YXIgY3JlYXRlV2VsbEtub3duU3ltYm9sID0gVVNFX1NZTUJPTF9BU19VSUQgPyBTeW1ib2wkMSA6IFN5bWJvbCQxICYmIFN5bWJvbCQxLndpdGhvdXRTZXR0ZXIgfHwgdWlkJDI7XG5cbnZhciB3ZWxsS25vd25TeW1ib2wkaiA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGlmICghaGFzT3duJGIoV2VsbEtub3duU3ltYm9sc1N0b3JlLCBuYW1lKSB8fCAhKE5BVElWRV9TWU1CT0wgfHwgdHlwZW9mIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9PSAnc3RyaW5nJykpIHtcbiAgICB2YXIgZGVzY3JpcHRpb24gPSAnU3ltYm9sLicgKyBuYW1lO1xuICAgIGlmIChOQVRJVkVfU1lNQk9MICYmIGhhc093biRiKFN5bWJvbCQxLCBuYW1lKSkge1xuICAgICAgV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdID0gU3ltYm9sJDFbbmFtZV07XG4gICAgfSBlbHNlIGlmIChVU0VfU1lNQk9MX0FTX1VJRCAmJiBzeW1ib2xGb3IpIHtcbiAgICAgIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9IHN5bWJvbEZvcihkZXNjcmlwdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9IGNyZWF0ZVdlbGxLbm93blN5bWJvbChkZXNjcmlwdGlvbik7XG4gICAgfVxuICB9IHJldHVybiBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV07XG59O1xuXG52YXIgY2FsbCRpID0gZnVuY3Rpb25DYWxsO1xudmFyIGlzT2JqZWN0JGIgPSBpc09iamVjdCRkO1xudmFyIGlzU3ltYm9sJDIgPSBpc1N5bWJvbCQzO1xudmFyIGdldE1ldGhvZCQzID0gZ2V0TWV0aG9kJDQ7XG52YXIgb3JkaW5hcnlUb1ByaW1pdGl2ZSA9IG9yZGluYXJ5VG9QcmltaXRpdmUkMTtcbnZhciB3ZWxsS25vd25TeW1ib2wkaSA9IHdlbGxLbm93blN5bWJvbCRqO1xuXG52YXIgJFR5cGVFcnJvciRjID0gVHlwZUVycm9yO1xudmFyIFRPX1BSSU1JVElWRSA9IHdlbGxLbm93blN5bWJvbCRpKCd0b1ByaW1pdGl2ZScpO1xuXG4vLyBgVG9QcmltaXRpdmVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b3ByaW1pdGl2ZVxudmFyIHRvUHJpbWl0aXZlJDIgPSBmdW5jdGlvbiAoaW5wdXQsIHByZWYpIHtcbiAgaWYgKCFpc09iamVjdCRiKGlucHV0KSB8fCBpc1N5bWJvbCQyKGlucHV0KSkgcmV0dXJuIGlucHV0O1xuICB2YXIgZXhvdGljVG9QcmltID0gZ2V0TWV0aG9kJDMoaW5wdXQsIFRPX1BSSU1JVElWRSk7XG4gIHZhciByZXN1bHQ7XG4gIGlmIChleG90aWNUb1ByaW0pIHtcbiAgICBpZiAocHJlZiA9PT0gdW5kZWZpbmVkKSBwcmVmID0gJ2RlZmF1bHQnO1xuICAgIHJlc3VsdCA9IGNhbGwkaShleG90aWNUb1ByaW0sIGlucHV0LCBwcmVmKTtcbiAgICBpZiAoIWlzT2JqZWN0JGIocmVzdWx0KSB8fCBpc1N5bWJvbCQyKHJlc3VsdCkpIHJldHVybiByZXN1bHQ7XG4gICAgdGhyb3cgJFR5cGVFcnJvciRjKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xuICB9XG4gIGlmIChwcmVmID09PSB1bmRlZmluZWQpIHByZWYgPSAnbnVtYmVyJztcbiAgcmV0dXJuIG9yZGluYXJ5VG9QcmltaXRpdmUoaW5wdXQsIHByZWYpO1xufTtcblxudmFyIHRvUHJpbWl0aXZlJDEgPSB0b1ByaW1pdGl2ZSQyO1xudmFyIGlzU3ltYm9sJDEgPSBpc1N5bWJvbCQzO1xuXG4vLyBgVG9Qcm9wZXJ0eUtleWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvcHJvcGVydHlrZXlcbnZhciB0b1Byb3BlcnR5S2V5JDQgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgdmFyIGtleSA9IHRvUHJpbWl0aXZlJDEoYXJndW1lbnQsICdzdHJpbmcnKTtcbiAgcmV0dXJuIGlzU3ltYm9sJDEoa2V5KSA/IGtleSA6IGtleSArICcnO1xufTtcblxudmFyIGdsb2JhbCRuID0gZ2xvYmFsJHQ7XG52YXIgaXNPYmplY3QkYSA9IGlzT2JqZWN0JGQ7XG5cbnZhciBkb2N1bWVudCQzID0gZ2xvYmFsJG4uZG9jdW1lbnQ7XG4vLyB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0JyBpbiBvbGQgSUVcbnZhciBFWElTVFMkMSA9IGlzT2JqZWN0JGEoZG9jdW1lbnQkMykgJiYgaXNPYmplY3QkYShkb2N1bWVudCQzLmNyZWF0ZUVsZW1lbnQpO1xuXG52YXIgZG9jdW1lbnRDcmVhdGVFbGVtZW50JDIgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIEVYSVNUUyQxID8gZG9jdW1lbnQkMy5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTtcblxudmFyIERFU0NSSVBUT1JTJGQgPSBkZXNjcmlwdG9ycztcbnZhciBmYWlscyRuID0gZmFpbHMkcztcbnZhciBjcmVhdGVFbGVtZW50JDEgPSBkb2N1bWVudENyZWF0ZUVsZW1lbnQkMjtcblxuLy8gVGhhbmtzIHRvIElFOCBmb3IgaXRzIGZ1bm55IGRlZmluZVByb3BlcnR5XG52YXIgaWU4RG9tRGVmaW5lID0gIURFU0NSSVBUT1JTJGQgJiYgIWZhaWxzJG4oZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjcmVhdGVFbGVtZW50JDEoJ2RpdicpLCAnYScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH1cbiAgfSkuYSAhPSA3O1xufSk7XG5cbnZhciBERVNDUklQVE9SUyRjID0gZGVzY3JpcHRvcnM7XG52YXIgY2FsbCRoID0gZnVuY3Rpb25DYWxsO1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlJDEgPSBvYmplY3RQcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkNCA9IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQ1O1xudmFyIHRvSW5kZXhlZE9iamVjdCQ1ID0gdG9JbmRleGVkT2JqZWN0JDY7XG52YXIgdG9Qcm9wZXJ0eUtleSQzID0gdG9Qcm9wZXJ0eUtleSQ0O1xudmFyIGhhc093biRhID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBJRThfRE9NX0RFRklORSQxID0gaWU4RG9tRGVmaW5lO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG4vLyBgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3Jcbm9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvci5mID0gREVTQ1JJUFRPUlMkYyA/ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMSA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKSB7XG4gIE8gPSB0b0luZGV4ZWRPYmplY3QkNShPKTtcbiAgUCA9IHRvUHJvcGVydHlLZXkkMyhQKTtcbiAgaWYgKElFOF9ET01fREVGSU5FJDEpIHRyeSB7XG4gICAgcmV0dXJuICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMShPLCBQKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoaGFzT3duJGEoTywgUCkpIHJldHVybiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkNCghY2FsbCRoKHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlJDEuZiwgTywgUCksIE9bUF0pO1xufTtcblxudmFyIG9iamVjdERlZmluZVByb3BlcnR5ID0ge307XG5cbnZhciBERVNDUklQVE9SUyRiID0gZGVzY3JpcHRvcnM7XG52YXIgZmFpbHMkbSA9IGZhaWxzJHM7XG5cbi8vIFY4IH4gQ2hyb21lIDM2LVxuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzMzNFxudmFyIHY4UHJvdG90eXBlRGVmaW5lQnVnID0gREVTQ1JJUFRPUlMkYiAmJiBmYWlscyRtKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9LCAncHJvdG90eXBlJywge1xuICAgIHZhbHVlOiA0MixcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSkucHJvdG90eXBlICE9IDQyO1xufSk7XG5cbnZhciBpc09iamVjdCQ5ID0gaXNPYmplY3QkZDtcblxudmFyICRTdHJpbmckMiA9IFN0cmluZztcbnZhciAkVHlwZUVycm9yJGIgPSBUeXBlRXJyb3I7XG5cbi8vIGBBc3NlcnQ6IFR5cGUoYXJndW1lbnQpIGlzIE9iamVjdGBcbnZhciBhbk9iamVjdCRlID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmIChpc09iamVjdCQ5KGFyZ3VtZW50KSkgcmV0dXJuIGFyZ3VtZW50O1xuICB0aHJvdyAkVHlwZUVycm9yJGIoJFN0cmluZyQyKGFyZ3VtZW50KSArICcgaXMgbm90IGFuIG9iamVjdCcpO1xufTtcblxudmFyIERFU0NSSVBUT1JTJGEgPSBkZXNjcmlwdG9ycztcbnZhciBJRThfRE9NX0RFRklORSA9IGllOERvbURlZmluZTtcbnZhciBWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyQxID0gdjhQcm90b3R5cGVEZWZpbmVCdWc7XG52YXIgYW5PYmplY3QkZCA9IGFuT2JqZWN0JGU7XG52YXIgdG9Qcm9wZXJ0eUtleSQyID0gdG9Qcm9wZXJ0eUtleSQ0O1xuXG52YXIgJFR5cGVFcnJvciRhID0gVHlwZUVycm9yO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcbnZhciAkZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBFTlVNRVJBQkxFID0gJ2VudW1lcmFibGUnO1xudmFyIENPTkZJR1VSQUJMRSQxID0gJ2NvbmZpZ3VyYWJsZSc7XG52YXIgV1JJVEFCTEUgPSAnd3JpdGFibGUnO1xuXG4vLyBgT2JqZWN0LmRlZmluZVByb3BlcnR5YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnR5XG5vYmplY3REZWZpbmVQcm9wZXJ0eS5mID0gREVTQ1JJUFRPUlMkYSA/IFY4X1BST1RPVFlQRV9ERUZJTkVfQlVHJDEgPyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGFuT2JqZWN0JGQoTyk7XG4gIFAgPSB0b1Byb3BlcnR5S2V5JDIoUCk7XG4gIGFuT2JqZWN0JGQoQXR0cmlidXRlcyk7XG4gIGlmICh0eXBlb2YgTyA9PT0gJ2Z1bmN0aW9uJyAmJiBQID09PSAncHJvdG90eXBlJyAmJiAndmFsdWUnIGluIEF0dHJpYnV0ZXMgJiYgV1JJVEFCTEUgaW4gQXR0cmlidXRlcyAmJiAhQXR0cmlidXRlc1tXUklUQUJMRV0pIHtcbiAgICB2YXIgY3VycmVudCA9ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCk7XG4gICAgaWYgKGN1cnJlbnQgJiYgY3VycmVudFtXUklUQUJMRV0pIHtcbiAgICAgIE9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICAgICAgQXR0cmlidXRlcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBDT05GSUdVUkFCTEUkMSBpbiBBdHRyaWJ1dGVzID8gQXR0cmlidXRlc1tDT05GSUdVUkFCTEUkMV0gOiBjdXJyZW50W0NPTkZJR1VSQUJMRSQxXSxcbiAgICAgICAgZW51bWVyYWJsZTogRU5VTUVSQUJMRSBpbiBBdHRyaWJ1dGVzID8gQXR0cmlidXRlc1tFTlVNRVJBQkxFXSA6IGN1cnJlbnRbRU5VTUVSQUJMRV0sXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gIH0gcmV0dXJuICRkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKTtcbn0gOiAkZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGFuT2JqZWN0JGQoTyk7XG4gIFAgPSB0b1Byb3BlcnR5S2V5JDIoUCk7XG4gIGFuT2JqZWN0JGQoQXR0cmlidXRlcyk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gJGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIGlmICgnZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpIHRocm93ICRUeXBlRXJyb3IkYSgnQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgaWYgKCd2YWx1ZScgaW4gQXR0cmlidXRlcykgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTtcblxudmFyIERFU0NSSVBUT1JTJDkgPSBkZXNjcmlwdG9ycztcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQ2ID0gb2JqZWN0RGVmaW5lUHJvcGVydHk7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDMgPSBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkNTtcblxudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ4ID0gREVTQ1JJUFRPUlMkOSA/IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5TW9kdWxlJDYuZihvYmplY3QsIGtleSwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDMoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59O1xuXG52YXIgbWFrZUJ1aWx0SW4kMiA9IHtleHBvcnRzOiB7fX07XG5cbnZhciBERVNDUklQVE9SUyQ4ID0gZGVzY3JpcHRvcnM7XG52YXIgaGFzT3duJDkgPSBoYXNPd25Qcm9wZXJ0eV8xO1xuXG52YXIgRnVuY3Rpb25Qcm90b3R5cGUkMSA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxudmFyIGdldERlc2NyaXB0b3IgPSBERVNDUklQVE9SUyQ4ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbnZhciBFWElTVFMgPSBoYXNPd24kOShGdW5jdGlvblByb3RvdHlwZSQxLCAnbmFtZScpO1xuLy8gYWRkaXRpb25hbCBwcm90ZWN0aW9uIGZyb20gbWluaWZpZWQgLyBtYW5nbGVkIC8gZHJvcHBlZCBmdW5jdGlvbiBuYW1lc1xudmFyIFBST1BFUiA9IEVYSVNUUyAmJiAoZnVuY3Rpb24gc29tZXRoaW5nKCkgeyAvKiBlbXB0eSAqLyB9KS5uYW1lID09PSAnc29tZXRoaW5nJztcbnZhciBDT05GSUdVUkFCTEUgPSBFWElTVFMgJiYgKCFERVNDUklQVE9SUyQ4IHx8IChERVNDUklQVE9SUyQ4ICYmIGdldERlc2NyaXB0b3IoRnVuY3Rpb25Qcm90b3R5cGUkMSwgJ25hbWUnKS5jb25maWd1cmFibGUpKTtcblxudmFyIGZ1bmN0aW9uTmFtZSA9IHtcbiAgRVhJU1RTOiBFWElTVFMsXG4gIFBST1BFUjogUFJPUEVSLFxuICBDT05GSUdVUkFCTEU6IENPTkZJR1VSQUJMRVxufTtcblxudmFyIHVuY3VycnlUaGlzJGogPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGlzQ2FsbGFibGUkaCA9IGlzQ2FsbGFibGUkbjtcbnZhciBzdG9yZSQxID0gc2hhcmVkU3RvcmU7XG5cbnZhciBmdW5jdGlvblRvU3RyaW5nID0gdW5jdXJyeVRoaXMkaihGdW5jdGlvbi50b1N0cmluZyk7XG5cbi8vIHRoaXMgaGVscGVyIGJyb2tlbiBpbiBgY29yZS1qc0AzLjQuMS0zLjQuNGAsIHNvIHdlIGNhbid0IHVzZSBgc2hhcmVkYCBoZWxwZXJcbmlmICghaXNDYWxsYWJsZSRoKHN0b3JlJDEuaW5zcGVjdFNvdXJjZSkpIHtcbiAgc3RvcmUkMS5pbnNwZWN0U291cmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uVG9TdHJpbmcoaXQpO1xuICB9O1xufVxuXG52YXIgaW5zcGVjdFNvdXJjZSQ0ID0gc3RvcmUkMS5pbnNwZWN0U291cmNlO1xuXG52YXIgZ2xvYmFsJG0gPSBnbG9iYWwkdDtcbnZhciBpc0NhbGxhYmxlJGcgPSBpc0NhbGxhYmxlJG47XG52YXIgaW5zcGVjdFNvdXJjZSQzID0gaW5zcGVjdFNvdXJjZSQ0O1xuXG52YXIgV2Vha01hcCQxID0gZ2xvYmFsJG0uV2Vha01hcDtcblxudmFyIG5hdGl2ZVdlYWtNYXAgPSBpc0NhbGxhYmxlJGcoV2Vha01hcCQxKSAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoaW5zcGVjdFNvdXJjZSQzKFdlYWtNYXAkMSkpO1xuXG52YXIgc2hhcmVkJDIgPSBzaGFyZWQkNC5leHBvcnRzO1xudmFyIHVpZCQxID0gdWlkJDM7XG5cbnZhciBrZXlzJDEgPSBzaGFyZWQkMigna2V5cycpO1xuXG52YXIgc2hhcmVkS2V5JDMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBrZXlzJDFba2V5XSB8fCAoa2V5cyQxW2tleV0gPSB1aWQkMShrZXkpKTtcbn07XG5cbnZhciBoaWRkZW5LZXlzJDQgPSB7fTtcblxudmFyIE5BVElWRV9XRUFLX01BUCA9IG5hdGl2ZVdlYWtNYXA7XG52YXIgZ2xvYmFsJGwgPSBnbG9iYWwkdDtcbnZhciB1bmN1cnJ5VGhpcyRpID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBpc09iamVjdCQ4ID0gaXNPYmplY3QkZDtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNyA9IGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ4O1xudmFyIGhhc093biQ4ID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBzaGFyZWQkMSA9IHNoYXJlZFN0b3JlO1xudmFyIHNoYXJlZEtleSQyID0gc2hhcmVkS2V5JDM7XG52YXIgaGlkZGVuS2V5cyQzID0gaGlkZGVuS2V5cyQ0O1xuXG52YXIgT0JKRUNUX0FMUkVBRFlfSU5JVElBTElaRUQgPSAnT2JqZWN0IGFscmVhZHkgaW5pdGlhbGl6ZWQnO1xudmFyIFR5cGVFcnJvciQzID0gZ2xvYmFsJGwuVHlwZUVycm9yO1xudmFyIFdlYWtNYXAgPSBnbG9iYWwkbC5XZWFrTWFwO1xudmFyIHNldCQyLCBnZXQkMSwgaGFzO1xuXG52YXIgZW5mb3JjZSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaGFzKGl0KSA/IGdldCQxKGl0KSA6IHNldCQyKGl0LCB7fSk7XG59O1xuXG52YXIgZ2V0dGVyRm9yID0gZnVuY3Rpb24gKFRZUEUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpdCkge1xuICAgIHZhciBzdGF0ZTtcbiAgICBpZiAoIWlzT2JqZWN0JDgoaXQpIHx8IChzdGF0ZSA9IGdldCQxKGl0KSkudHlwZSAhPT0gVFlQRSkge1xuICAgICAgdGhyb3cgVHlwZUVycm9yJDMoJ0luY29tcGF0aWJsZSByZWNlaXZlciwgJyArIFRZUEUgKyAnIHJlcXVpcmVkJyk7XG4gICAgfSByZXR1cm4gc3RhdGU7XG4gIH07XG59O1xuXG5pZiAoTkFUSVZFX1dFQUtfTUFQIHx8IHNoYXJlZCQxLnN0YXRlKSB7XG4gIHZhciBzdG9yZSA9IHNoYXJlZCQxLnN0YXRlIHx8IChzaGFyZWQkMS5zdGF0ZSA9IG5ldyBXZWFrTWFwKCkpO1xuICB2YXIgd21nZXQgPSB1bmN1cnJ5VGhpcyRpKHN0b3JlLmdldCk7XG4gIHZhciB3bWhhcyA9IHVuY3VycnlUaGlzJGkoc3RvcmUuaGFzKTtcbiAgdmFyIHdtc2V0ID0gdW5jdXJyeVRoaXMkaShzdG9yZS5zZXQpO1xuICBzZXQkMiA9IGZ1bmN0aW9uIChpdCwgbWV0YWRhdGEpIHtcbiAgICBpZiAod21oYXMoc3RvcmUsIGl0KSkgdGhyb3cgbmV3IFR5cGVFcnJvciQzKE9CSkVDVF9BTFJFQURZX0lOSVRJQUxJWkVEKTtcbiAgICBtZXRhZGF0YS5mYWNhZGUgPSBpdDtcbiAgICB3bXNldChzdG9yZSwgaXQsIG1ldGFkYXRhKTtcbiAgICByZXR1cm4gbWV0YWRhdGE7XG4gIH07XG4gIGdldCQxID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIHdtZ2V0KHN0b3JlLCBpdCkgfHwge307XG4gIH07XG4gIGhhcyA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiB3bWhhcyhzdG9yZSwgaXQpO1xuICB9O1xufSBlbHNlIHtcbiAgdmFyIFNUQVRFID0gc2hhcmVkS2V5JDIoJ3N0YXRlJyk7XG4gIGhpZGRlbktleXMkM1tTVEFURV0gPSB0cnVlO1xuICBzZXQkMiA9IGZ1bmN0aW9uIChpdCwgbWV0YWRhdGEpIHtcbiAgICBpZiAoaGFzT3duJDgoaXQsIFNUQVRFKSkgdGhyb3cgbmV3IFR5cGVFcnJvciQzKE9CSkVDVF9BTFJFQURZX0lOSVRJQUxJWkVEKTtcbiAgICBtZXRhZGF0YS5mYWNhZGUgPSBpdDtcbiAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNyhpdCwgU1RBVEUsIG1ldGFkYXRhKTtcbiAgICByZXR1cm4gbWV0YWRhdGE7XG4gIH07XG4gIGdldCQxID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGhhc093biQ4KGl0LCBTVEFURSkgPyBpdFtTVEFURV0gOiB7fTtcbiAgfTtcbiAgaGFzID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGhhc093biQ4KGl0LCBTVEFURSk7XG4gIH07XG59XG5cbnZhciBpbnRlcm5hbFN0YXRlID0ge1xuICBzZXQ6IHNldCQyLFxuICBnZXQ6IGdldCQxLFxuICBoYXM6IGhhcyxcbiAgZW5mb3JjZTogZW5mb3JjZSxcbiAgZ2V0dGVyRm9yOiBnZXR0ZXJGb3Jcbn07XG5cbnZhciBmYWlscyRsID0gZmFpbHMkcztcbnZhciBpc0NhbGxhYmxlJGYgPSBpc0NhbGxhYmxlJG47XG52YXIgaGFzT3duJDcgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIERFU0NSSVBUT1JTJDcgPSBkZXNjcmlwdG9ycztcbnZhciBDT05GSUdVUkFCTEVfRlVOQ1RJT05fTkFNRSQyID0gZnVuY3Rpb25OYW1lLkNPTkZJR1VSQUJMRTtcbnZhciBpbnNwZWN0U291cmNlJDIgPSBpbnNwZWN0U291cmNlJDQ7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSQ1ID0gaW50ZXJuYWxTdGF0ZTtcblxudmFyIGVuZm9yY2VJbnRlcm5hbFN0YXRlJDIgPSBJbnRlcm5hbFN0YXRlTW9kdWxlJDUuZW5mb3JjZTtcbnZhciBnZXRJbnRlcm5hbFN0YXRlJDUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlJDUuZ2V0O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcbnZhciBkZWZpbmVQcm9wZXJ0eSQ2ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG52YXIgQ09ORklHVVJBQkxFX0xFTkdUSCA9IERFU0NSSVBUT1JTJDcgJiYgIWZhaWxzJGwoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZGVmaW5lUHJvcGVydHkkNihmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0sICdsZW5ndGgnLCB7IHZhbHVlOiA4IH0pLmxlbmd0aCAhPT0gODtcbn0pO1xuXG52YXIgVEVNUExBVEUgPSBTdHJpbmcoU3RyaW5nKS5zcGxpdCgnU3RyaW5nJyk7XG5cbnZhciBtYWtlQnVpbHRJbiQxID0gbWFrZUJ1aWx0SW4kMi5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlLCBuYW1lLCBvcHRpb25zKSB7XG4gIGlmIChTdHJpbmcobmFtZSkuc2xpY2UoMCwgNykgPT09ICdTeW1ib2woJykge1xuICAgIG5hbWUgPSAnWycgKyBTdHJpbmcobmFtZSkucmVwbGFjZSgvXlN5bWJvbFxcKChbXildKilcXCkvLCAnJDEnKSArICddJztcbiAgfVxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmdldHRlcikgbmFtZSA9ICdnZXQgJyArIG5hbWU7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuc2V0dGVyKSBuYW1lID0gJ3NldCAnICsgbmFtZTtcbiAgaWYgKCFoYXNPd24kNyh2YWx1ZSwgJ25hbWUnKSB8fCAoQ09ORklHVVJBQkxFX0ZVTkNUSU9OX05BTUUkMiAmJiB2YWx1ZS5uYW1lICE9PSBuYW1lKSkge1xuICAgIGlmIChERVNDUklQVE9SUyQ3KSBkZWZpbmVQcm9wZXJ0eSQ2KHZhbHVlLCAnbmFtZScsIHsgdmFsdWU6IG5hbWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcbiAgICBlbHNlIHZhbHVlLm5hbWUgPSBuYW1lO1xuICB9XG4gIGlmIChDT05GSUdVUkFCTEVfTEVOR1RIICYmIG9wdGlvbnMgJiYgaGFzT3duJDcob3B0aW9ucywgJ2FyaXR5JykgJiYgdmFsdWUubGVuZ3RoICE9PSBvcHRpb25zLmFyaXR5KSB7XG4gICAgZGVmaW5lUHJvcGVydHkkNih2YWx1ZSwgJ2xlbmd0aCcsIHsgdmFsdWU6IG9wdGlvbnMuYXJpdHkgfSk7XG4gIH1cbiAgdHJ5IHtcbiAgICBpZiAob3B0aW9ucyAmJiBoYXNPd24kNyhvcHRpb25zLCAnY29uc3RydWN0b3InKSAmJiBvcHRpb25zLmNvbnN0cnVjdG9yKSB7XG4gICAgICBpZiAoREVTQ1JJUFRPUlMkNykgZGVmaW5lUHJvcGVydHkkNih2YWx1ZSwgJ3Byb3RvdHlwZScsIHsgd3JpdGFibGU6IGZhbHNlIH0pO1xuICAgIC8vIGluIFY4IH4gQ2hyb21lIDUzLCBwcm90b3R5cGVzIG9mIHNvbWUgbWV0aG9kcywgbGlrZSBgQXJyYXkucHJvdG90eXBlLnZhbHVlc2AsIGFyZSBub24td3JpdGFibGVcbiAgICB9IGVsc2UgaWYgKHZhbHVlLnByb3RvdHlwZSkgdmFsdWUucHJvdG90eXBlID0gdW5kZWZpbmVkO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIHZhciBzdGF0ZSA9IGVuZm9yY2VJbnRlcm5hbFN0YXRlJDIodmFsdWUpO1xuICBpZiAoIWhhc093biQ3KHN0YXRlLCAnc291cmNlJykpIHtcbiAgICBzdGF0ZS5zb3VyY2UgPSBURU1QTEFURS5qb2luKHR5cGVvZiBuYW1lID09ICdzdHJpbmcnID8gbmFtZSA6ICcnKTtcbiAgfSByZXR1cm4gdmFsdWU7XG59O1xuXG4vLyBhZGQgZmFrZSBGdW5jdGlvbiN0b1N0cmluZyBmb3IgY29ycmVjdCB3b3JrIHdyYXBwZWQgbWV0aG9kcyAvIGNvbnN0cnVjdG9ycyB3aXRoIG1ldGhvZHMgbGlrZSBMb0Rhc2ggaXNOYXRpdmVcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1leHRlbmQtbmF0aXZlIC0tIHJlcXVpcmVkXG5GdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBtYWtlQnVpbHRJbiQxKGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gaXNDYWxsYWJsZSRmKHRoaXMpICYmIGdldEludGVybmFsU3RhdGUkNSh0aGlzKS5zb3VyY2UgfHwgaW5zcGVjdFNvdXJjZSQyKHRoaXMpO1xufSwgJ3RvU3RyaW5nJyk7XG5cbnZhciBpc0NhbGxhYmxlJGUgPSBpc0NhbGxhYmxlJG47XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUkNSA9IG9iamVjdERlZmluZVByb3BlcnR5O1xudmFyIG1ha2VCdWlsdEluID0gbWFrZUJ1aWx0SW4kMi5leHBvcnRzO1xudmFyIGRlZmluZUdsb2JhbFByb3BlcnR5JDEgPSBkZWZpbmVHbG9iYWxQcm9wZXJ0eSQzO1xuXG52YXIgZGVmaW5lQnVpbHRJbiQ4ID0gZnVuY3Rpb24gKE8sIGtleSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG4gIHZhciBzaW1wbGUgPSBvcHRpb25zLmVudW1lcmFibGU7XG4gIHZhciBuYW1lID0gb3B0aW9ucy5uYW1lICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm5hbWUgOiBrZXk7XG4gIGlmIChpc0NhbGxhYmxlJGUodmFsdWUpKSBtYWtlQnVpbHRJbih2YWx1ZSwgbmFtZSwgb3B0aW9ucyk7XG4gIGlmIChvcHRpb25zLmdsb2JhbCkge1xuICAgIGlmIChzaW1wbGUpIE9ba2V5XSA9IHZhbHVlO1xuICAgIGVsc2UgZGVmaW5lR2xvYmFsUHJvcGVydHkkMShrZXksIHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFvcHRpb25zLnVuc2FmZSkgZGVsZXRlIE9ba2V5XTtcbiAgICAgIGVsc2UgaWYgKE9ba2V5XSkgc2ltcGxlID0gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gICAgaWYgKHNpbXBsZSkgT1trZXldID0gdmFsdWU7XG4gICAgZWxzZSBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQ1LmYoTywga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogIW9wdGlvbnMubm9uQ29uZmlndXJhYmxlLFxuICAgICAgd3JpdGFibGU6ICFvcHRpb25zLm5vbldyaXRhYmxlXG4gICAgfSk7XG4gIH0gcmV0dXJuIE87XG59O1xuXG52YXIgb2JqZWN0R2V0T3duUHJvcGVydHlOYW1lcyA9IHt9O1xuXG52YXIgY2VpbCA9IE1hdGguY2VpbDtcbnZhciBmbG9vciQzID0gTWF0aC5mbG9vcjtcblxuLy8gYE1hdGgudHJ1bmNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXRoLnRydW5jXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1tYXRoLXRydW5jIC0tIHNhZmVcbnZhciBtYXRoVHJ1bmMgPSBNYXRoLnRydW5jIHx8IGZ1bmN0aW9uIHRydW5jKHgpIHtcbiAgdmFyIG4gPSAreDtcbiAgcmV0dXJuIChuID4gMCA/IGZsb29yJDMgOiBjZWlsKShuKTtcbn07XG5cbnZhciB0cnVuYyA9IG1hdGhUcnVuYztcblxuLy8gYFRvSW50ZWdlck9ySW5maW5pdHlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b2ludGVnZXJvcmluZmluaXR5XG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSQ2ID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHZhciBudW1iZXIgPSArYXJndW1lbnQ7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG4gIHJldHVybiBudW1iZXIgIT09IG51bWJlciB8fCBudW1iZXIgPT09IDAgPyAwIDogdHJ1bmMobnVtYmVyKTtcbn07XG5cbnZhciB0b0ludGVnZXJPckluZmluaXR5JDUgPSB0b0ludGVnZXJPckluZmluaXR5JDY7XG5cbnZhciBtYXgkMSA9IE1hdGgubWF4O1xudmFyIG1pbiQyID0gTWF0aC5taW47XG5cbi8vIEhlbHBlciBmb3IgYSBwb3B1bGFyIHJlcGVhdGluZyBjYXNlIG9mIHRoZSBzcGVjOlxuLy8gTGV0IGludGVnZXIgYmUgPyBUb0ludGVnZXIoaW5kZXgpLlxuLy8gSWYgaW50ZWdlciA8IDAsIGxldCByZXN1bHQgYmUgbWF4KChsZW5ndGggKyBpbnRlZ2VyKSwgMCk7IGVsc2UgbGV0IHJlc3VsdCBiZSBtaW4oaW50ZWdlciwgbGVuZ3RoKS5cbnZhciB0b0Fic29sdXRlSW5kZXgkNCA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XG4gIHZhciBpbnRlZ2VyID0gdG9JbnRlZ2VyT3JJbmZpbml0eSQ1KGluZGV4KTtcbiAgcmV0dXJuIGludGVnZXIgPCAwID8gbWF4JDEoaW50ZWdlciArIGxlbmd0aCwgMCkgOiBtaW4kMihpbnRlZ2VyLCBsZW5ndGgpO1xufTtcblxudmFyIHRvSW50ZWdlck9ySW5maW5pdHkkNCA9IHRvSW50ZWdlck9ySW5maW5pdHkkNjtcblxudmFyIG1pbiQxID0gTWF0aC5taW47XG5cbi8vIGBUb0xlbmd0aGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvbGVuZ3RoXG52YXIgdG9MZW5ndGgkNiA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gYXJndW1lbnQgPiAwID8gbWluJDEodG9JbnRlZ2VyT3JJbmZpbml0eSQ0KGFyZ3VtZW50KSwgMHgxRkZGRkZGRkZGRkZGRikgOiAwOyAvLyAyICoqIDUzIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59O1xuXG52YXIgdG9MZW5ndGgkNSA9IHRvTGVuZ3RoJDY7XG5cbi8vIGBMZW5ndGhPZkFycmF5TGlrZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWxlbmd0aG9mYXJyYXlsaWtlXG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UkOCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIHRvTGVuZ3RoJDUob2JqLmxlbmd0aCk7XG59O1xuXG52YXIgdG9JbmRleGVkT2JqZWN0JDQgPSB0b0luZGV4ZWRPYmplY3QkNjtcbnZhciB0b0Fic29sdXRlSW5kZXgkMyA9IHRvQWJzb2x1dGVJbmRleCQ0O1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlJDcgPSBsZW5ndGhPZkFycmF5TGlrZSQ4O1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLnsgaW5kZXhPZiwgaW5jbHVkZXMgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxudmFyIGNyZWF0ZU1ldGhvZCQ0ID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdCQ0KCR0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UkNyhPKTtcbiAgICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgkMyhmcm9tSW5kZXgsIGxlbmd0aCk7XG4gICAgdmFyIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xuICAgIGlmIChJU19JTkNMVURFUyAmJiBlbCAhPSBlbCkgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSB7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xuICAgICAgaWYgKHZhbHVlICE9IHZhbHVlKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSNpbmRleE9mIGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgICBpZiAoKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pICYmIE9baW5kZXhdID09PSBlbCkgcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcblxudmFyIGFycmF5SW5jbHVkZXMgPSB7XG4gIC8vIGBBcnJheS5wcm90b3R5cGUuaW5jbHVkZXNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmNsdWRlc1xuICBpbmNsdWRlczogY3JlYXRlTWV0aG9kJDQodHJ1ZSksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuaW5kZXhPZmAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmluZGV4b2ZcbiAgaW5kZXhPZjogY3JlYXRlTWV0aG9kJDQoZmFsc2UpXG59O1xuXG52YXIgdW5jdXJyeVRoaXMkaCA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgaGFzT3duJDYgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIHRvSW5kZXhlZE9iamVjdCQzID0gdG9JbmRleGVkT2JqZWN0JDY7XG52YXIgaW5kZXhPZiQxID0gYXJyYXlJbmNsdWRlcy5pbmRleE9mO1xudmFyIGhpZGRlbktleXMkMiA9IGhpZGRlbktleXMkNDtcblxudmFyIHB1c2gkMiA9IHVuY3VycnlUaGlzJGgoW10ucHVzaCk7XG5cbnZhciBvYmplY3RLZXlzSW50ZXJuYWwgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xuICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdCQzKG9iamVjdCk7XG4gIHZhciBpID0gMDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBPKSAhaGFzT3duJDYoaGlkZGVuS2V5cyQyLCBrZXkpICYmIGhhc093biQ2KE8sIGtleSkgJiYgcHVzaCQyKHJlc3VsdCwga2V5KTtcbiAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkgaWYgKGhhc093biQ2KE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICAgfmluZGV4T2YkMShyZXN1bHQsIGtleSkgfHwgcHVzaCQyKHJlc3VsdCwga2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gSUU4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG52YXIgZW51bUJ1Z0tleXMkMyA9IFtcbiAgJ2NvbnN0cnVjdG9yJyxcbiAgJ2hhc093blByb3BlcnR5JyxcbiAgJ2lzUHJvdG90eXBlT2YnLFxuICAncHJvcGVydHlJc0VudW1lcmFibGUnLFxuICAndG9Mb2NhbGVTdHJpbmcnLFxuICAndG9TdHJpbmcnLFxuICAndmFsdWVPZidcbl07XG5cbnZhciBpbnRlcm5hbE9iamVjdEtleXMkMSA9IG9iamVjdEtleXNJbnRlcm5hbDtcbnZhciBlbnVtQnVnS2V5cyQyID0gZW51bUJ1Z0tleXMkMztcblxudmFyIGhpZGRlbktleXMkMSA9IGVudW1CdWdLZXlzJDIuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7XG5cbi8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eW5hbWVzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0b3ducHJvcGVydHluYW1lcyAtLSBzYWZlXG5vYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pIHtcbiAgcmV0dXJuIGludGVybmFsT2JqZWN0S2V5cyQxKE8sIGhpZGRlbktleXMkMSk7XG59O1xuXG52YXIgb2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzID0ge307XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eXN5bWJvbHMgLS0gc2FmZVxub2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG52YXIgZ2V0QnVpbHRJbiQ1ID0gZ2V0QnVpbHRJbiQ4O1xudmFyIHVuY3VycnlUaGlzJGcgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSQxID0gb2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGFuT2JqZWN0JGMgPSBhbk9iamVjdCRlO1xuXG52YXIgY29uY2F0JDEgPSB1bmN1cnJ5VGhpcyRnKFtdLmNvbmNhdCk7XG5cbi8vIGFsbCBvYmplY3Qga2V5cywgaW5jbHVkZXMgbm9uLWVudW1lcmFibGUgYW5kIHN5bWJvbHNcbnZhciBvd25LZXlzJDEgPSBnZXRCdWlsdEluJDUoJ1JlZmxlY3QnLCAnb3duS2V5cycpIHx8IGZ1bmN0aW9uIG93bktleXMoaXQpIHtcbiAgdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlLmYoYW5PYmplY3QkYyhpdCkpO1xuICB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlJDEuZjtcbiAgcmV0dXJuIGdldE93blByb3BlcnR5U3ltYm9scyA/IGNvbmNhdCQxKGtleXMsIGdldE93blByb3BlcnR5U3ltYm9scyhpdCkpIDoga2V5cztcbn07XG5cbnZhciBoYXNPd24kNSA9IGhhc093blByb3BlcnR5XzE7XG52YXIgb3duS2V5cyA9IG93bktleXMkMTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUkMSA9IG9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQ0ID0gb2JqZWN0RGVmaW5lUHJvcGVydHk7XG5cbnZhciBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzJDEgPSBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UsIGV4Y2VwdGlvbnMpIHtcbiAgdmFyIGtleXMgPSBvd25LZXlzKHNvdXJjZSk7XG4gIHZhciBkZWZpbmVQcm9wZXJ0eSA9IGRlZmluZVByb3BlcnR5TW9kdWxlJDQuZjtcbiAgdmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZSQxLmY7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIGlmICghaGFzT3duJDUodGFyZ2V0LCBrZXkpICYmICEoZXhjZXB0aW9ucyAmJiBoYXNPd24kNShleGNlcHRpb25zLCBrZXkpKSkge1xuICAgICAgZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIGZhaWxzJGsgPSBmYWlscyRzO1xudmFyIGlzQ2FsbGFibGUkZCA9IGlzQ2FsbGFibGUkbjtcblxudmFyIHJlcGxhY2VtZW50ID0gLyN8XFwucHJvdG90eXBlXFwuLztcblxudmFyIGlzRm9yY2VkJDIgPSBmdW5jdGlvbiAoZmVhdHVyZSwgZGV0ZWN0aW9uKSB7XG4gIHZhciB2YWx1ZSA9IGRhdGFbbm9ybWFsaXplKGZlYXR1cmUpXTtcbiAgcmV0dXJuIHZhbHVlID09IFBPTFlGSUxMID8gdHJ1ZVxuICAgIDogdmFsdWUgPT0gTkFUSVZFID8gZmFsc2VcbiAgICA6IGlzQ2FsbGFibGUkZChkZXRlY3Rpb24pID8gZmFpbHMkayhkZXRlY3Rpb24pXG4gICAgOiAhIWRldGVjdGlvbjtcbn07XG5cbnZhciBub3JtYWxpemUgPSBpc0ZvcmNlZCQyLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgcmV0dXJuIFN0cmluZyhzdHJpbmcpLnJlcGxhY2UocmVwbGFjZW1lbnQsICcuJykudG9Mb3dlckNhc2UoKTtcbn07XG5cbnZhciBkYXRhID0gaXNGb3JjZWQkMi5kYXRhID0ge307XG52YXIgTkFUSVZFID0gaXNGb3JjZWQkMi5OQVRJVkUgPSAnTic7XG52YXIgUE9MWUZJTEwgPSBpc0ZvcmNlZCQyLlBPTFlGSUxMID0gJ1AnO1xuXG52YXIgaXNGb3JjZWRfMSA9IGlzRm9yY2VkJDI7XG5cbnZhciBnbG9iYWwkayA9IGdsb2JhbCR0O1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciQxID0gb2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLmY7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDYgPSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkODtcbnZhciBkZWZpbmVCdWlsdEluJDcgPSBkZWZpbmVCdWlsdEluJDg7XG52YXIgZGVmaW5lR2xvYmFsUHJvcGVydHkgPSBkZWZpbmVHbG9iYWxQcm9wZXJ0eSQzO1xudmFyIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMgPSBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzJDE7XG52YXIgaXNGb3JjZWQkMSA9IGlzRm9yY2VkXzE7XG5cbi8qXG4gIG9wdGlvbnMudGFyZ2V0ICAgICAgICAgLSBuYW1lIG9mIHRoZSB0YXJnZXQgb2JqZWN0XG4gIG9wdGlvbnMuZ2xvYmFsICAgICAgICAgLSB0YXJnZXQgaXMgdGhlIGdsb2JhbCBvYmplY3RcbiAgb3B0aW9ucy5zdGF0ICAgICAgICAgICAtIGV4cG9ydCBhcyBzdGF0aWMgbWV0aG9kcyBvZiB0YXJnZXRcbiAgb3B0aW9ucy5wcm90byAgICAgICAgICAtIGV4cG9ydCBhcyBwcm90b3R5cGUgbWV0aG9kcyBvZiB0YXJnZXRcbiAgb3B0aW9ucy5yZWFsICAgICAgICAgICAtIHJlYWwgcHJvdG90eXBlIG1ldGhvZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMuZm9yY2VkICAgICAgICAgLSBleHBvcnQgZXZlbiBpZiB0aGUgbmF0aXZlIGZlYXR1cmUgaXMgYXZhaWxhYmxlXG4gIG9wdGlvbnMuYmluZCAgICAgICAgICAgLSBiaW5kIG1ldGhvZHMgdG8gdGhlIHRhcmdldCwgcmVxdWlyZWQgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuICBvcHRpb25zLndyYXAgICAgICAgICAgIC0gd3JhcCBjb25zdHJ1Y3RvcnMgdG8gcHJldmVudGluZyBnbG9iYWwgcG9sbHV0aW9uLCByZXF1aXJlZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMudW5zYWZlICAgICAgICAgLSB1c2UgdGhlIHNpbXBsZSBhc3NpZ25tZW50IG9mIHByb3BlcnR5IGluc3RlYWQgb2YgZGVsZXRlICsgZGVmaW5lUHJvcGVydHlcbiAgb3B0aW9ucy5zaGFtICAgICAgICAgICAtIGFkZCBhIGZsYWcgdG8gbm90IGNvbXBsZXRlbHkgZnVsbCBwb2x5ZmlsbHNcbiAgb3B0aW9ucy5lbnVtZXJhYmxlICAgICAtIGV4cG9ydCBhcyBlbnVtZXJhYmxlIHByb3BlcnR5XG4gIG9wdGlvbnMuZG9udENhbGxHZXRTZXQgLSBwcmV2ZW50IGNhbGxpbmcgYSBnZXR0ZXIgb24gdGFyZ2V0XG4gIG9wdGlvbnMubmFtZSAgICAgICAgICAgLSB0aGUgLm5hbWUgb2YgdGhlIGZ1bmN0aW9uIGlmIGl0IGRvZXMgbm90IG1hdGNoIHRoZSBrZXlcbiovXG52YXIgX2V4cG9ydCA9IGZ1bmN0aW9uIChvcHRpb25zLCBzb3VyY2UpIHtcbiAgdmFyIFRBUkdFVCA9IG9wdGlvbnMudGFyZ2V0O1xuICB2YXIgR0xPQkFMID0gb3B0aW9ucy5nbG9iYWw7XG4gIHZhciBTVEFUSUMgPSBvcHRpb25zLnN0YXQ7XG4gIHZhciBGT1JDRUQsIHRhcmdldCwga2V5LCB0YXJnZXRQcm9wZXJ0eSwgc291cmNlUHJvcGVydHksIGRlc2NyaXB0b3I7XG4gIGlmIChHTE9CQUwpIHtcbiAgICB0YXJnZXQgPSBnbG9iYWwkaztcbiAgfSBlbHNlIGlmIChTVEFUSUMpIHtcbiAgICB0YXJnZXQgPSBnbG9iYWwka1tUQVJHRVRdIHx8IGRlZmluZUdsb2JhbFByb3BlcnR5KFRBUkdFVCwge30pO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldCA9IChnbG9iYWwka1tUQVJHRVRdIHx8IHt9KS5wcm90b3R5cGU7XG4gIH1cbiAgaWYgKHRhcmdldCkgZm9yIChrZXkgaW4gc291cmNlKSB7XG4gICAgc291cmNlUHJvcGVydHkgPSBzb3VyY2Vba2V5XTtcbiAgICBpZiAob3B0aW9ucy5kb250Q2FsbEdldFNldCkge1xuICAgICAgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvciQxKHRhcmdldCwga2V5KTtcbiAgICAgIHRhcmdldFByb3BlcnR5ID0gZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLnZhbHVlO1xuICAgIH0gZWxzZSB0YXJnZXRQcm9wZXJ0eSA9IHRhcmdldFtrZXldO1xuICAgIEZPUkNFRCA9IGlzRm9yY2VkJDEoR0xPQkFMID8ga2V5IDogVEFSR0VUICsgKFNUQVRJQyA/ICcuJyA6ICcjJykgKyBrZXksIG9wdGlvbnMuZm9yY2VkKTtcbiAgICAvLyBjb250YWluZWQgaW4gdGFyZ2V0XG4gICAgaWYgKCFGT1JDRUQgJiYgdGFyZ2V0UHJvcGVydHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHR5cGVvZiBzb3VyY2VQcm9wZXJ0eSA9PSB0eXBlb2YgdGFyZ2V0UHJvcGVydHkpIGNvbnRpbnVlO1xuICAgICAgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyhzb3VyY2VQcm9wZXJ0eSwgdGFyZ2V0UHJvcGVydHkpO1xuICAgIH1cbiAgICAvLyBhZGQgYSBmbGFnIHRvIG5vdCBjb21wbGV0ZWx5IGZ1bGwgcG9seWZpbGxzXG4gICAgaWYgKG9wdGlvbnMuc2hhbSB8fCAodGFyZ2V0UHJvcGVydHkgJiYgdGFyZ2V0UHJvcGVydHkuc2hhbSkpIHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ2KHNvdXJjZVByb3BlcnR5LCAnc2hhbScsIHRydWUpO1xuICAgIH1cbiAgICBkZWZpbmVCdWlsdEluJDcodGFyZ2V0LCBrZXksIHNvdXJjZVByb3BlcnR5LCBvcHRpb25zKTtcbiAgfVxufTtcblxudmFyIGNsYXNzb2YkYSA9IGNsYXNzb2ZSYXckMTtcbnZhciBnbG9iYWwkaiA9IGdsb2JhbCR0O1xuXG52YXIgZW5naW5lSXNOb2RlID0gY2xhc3NvZiRhKGdsb2JhbCRqLnByb2Nlc3MpID09ICdwcm9jZXNzJztcblxudmFyIGlzQ2FsbGFibGUkYyA9IGlzQ2FsbGFibGUkbjtcblxudmFyICRTdHJpbmckMSA9IFN0cmluZztcbnZhciAkVHlwZUVycm9yJDkgPSBUeXBlRXJyb3I7XG5cbnZhciBhUG9zc2libGVQcm90b3R5cGUkMSA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAodHlwZW9mIGFyZ3VtZW50ID09ICdvYmplY3QnIHx8IGlzQ2FsbGFibGUkYyhhcmd1bWVudCkpIHJldHVybiBhcmd1bWVudDtcbiAgdGhyb3cgJFR5cGVFcnJvciQ5KFwiQ2FuJ3Qgc2V0IFwiICsgJFN0cmluZyQxKGFyZ3VtZW50KSArICcgYXMgYSBwcm90b3R5cGUnKTtcbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvIC0tIHNhZmUgKi9cblxudmFyIHVuY3VycnlUaGlzJGYgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGFuT2JqZWN0JGIgPSBhbk9iamVjdCRlO1xudmFyIGFQb3NzaWJsZVByb3RvdHlwZSA9IGFQb3NzaWJsZVByb3RvdHlwZSQxO1xuXG4vLyBgT2JqZWN0LnNldFByb3RvdHlwZU9mYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LnNldHByb3RvdHlwZW9mXG4vLyBXb3JrcyB3aXRoIF9fcHJvdG9fXyBvbmx5LiBPbGQgdjggY2FuJ3Qgd29yayB3aXRoIG51bGwgcHJvdG8gb2JqZWN0cy5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1zZXRwcm90b3R5cGVvZiAtLSBzYWZlXG52YXIgb2JqZWN0U2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gZnVuY3Rpb24gKCkge1xuICB2YXIgQ09SUkVDVF9TRVRURVIgPSBmYWxzZTtcbiAgdmFyIHRlc3QgPSB7fTtcbiAgdmFyIHNldHRlcjtcbiAgdHJ5IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbiAgICBzZXR0ZXIgPSB1bmN1cnJ5VGhpcyRmKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycpLnNldCk7XG4gICAgc2V0dGVyKHRlc3QsIFtdKTtcbiAgICBDT1JSRUNUX1NFVFRFUiA9IHRlc3QgaW5zdGFuY2VvZiBBcnJheTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pIHtcbiAgICBhbk9iamVjdCRiKE8pO1xuICAgIGFQb3NzaWJsZVByb3RvdHlwZShwcm90byk7XG4gICAgaWYgKENPUlJFQ1RfU0VUVEVSKSBzZXR0ZXIoTywgcHJvdG8pO1xuICAgIGVsc2UgTy5fX3Byb3RvX18gPSBwcm90bztcbiAgICByZXR1cm4gTztcbiAgfTtcbn0oKSA6IHVuZGVmaW5lZCk7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSQ1ID0gb2JqZWN0RGVmaW5lUHJvcGVydHkuZjtcbnZhciBoYXNPd24kNCA9IGhhc093blByb3BlcnR5XzE7XG52YXIgd2VsbEtub3duU3ltYm9sJGggPSB3ZWxsS25vd25TeW1ib2wkajtcblxudmFyIFRPX1NUUklOR19UQUckNCA9IHdlbGxLbm93blN5bWJvbCRoKCd0b1N0cmluZ1RhZycpO1xuXG52YXIgc2V0VG9TdHJpbmdUYWckNCA9IGZ1bmN0aW9uICh0YXJnZXQsIFRBRywgU1RBVElDKSB7XG4gIGlmICh0YXJnZXQgJiYgIVNUQVRJQykgdGFyZ2V0ID0gdGFyZ2V0LnByb3RvdHlwZTtcbiAgaWYgKHRhcmdldCAmJiAhaGFzT3duJDQodGFyZ2V0LCBUT19TVFJJTkdfVEFHJDQpKSB7XG4gICAgZGVmaW5lUHJvcGVydHkkNSh0YXJnZXQsIFRPX1NUUklOR19UQUckNCwgeyBjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiBUQUcgfSk7XG4gIH1cbn07XG5cbnZhciBnZXRCdWlsdEluJDQgPSBnZXRCdWlsdEluJDg7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUkMyA9IG9iamVjdERlZmluZVByb3BlcnR5O1xudmFyIHdlbGxLbm93blN5bWJvbCRnID0gd2VsbEtub3duU3ltYm9sJGo7XG52YXIgREVTQ1JJUFRPUlMkNiA9IGRlc2NyaXB0b3JzO1xuXG52YXIgU1BFQ0lFUyQ0ID0gd2VsbEtub3duU3ltYm9sJGcoJ3NwZWNpZXMnKTtcblxudmFyIHNldFNwZWNpZXMkMiA9IGZ1bmN0aW9uIChDT05TVFJVQ1RPUl9OQU1FKSB7XG4gIHZhciBDb25zdHJ1Y3RvciA9IGdldEJ1aWx0SW4kNChDT05TVFJVQ1RPUl9OQU1FKTtcbiAgdmFyIGRlZmluZVByb3BlcnR5ID0gZGVmaW5lUHJvcGVydHlNb2R1bGUkMy5mO1xuXG4gIGlmIChERVNDUklQVE9SUyQ2ICYmIENvbnN0cnVjdG9yICYmICFDb25zdHJ1Y3RvcltTUEVDSUVTJDRdKSB7XG4gICAgZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFNQRUNJRVMkNCwge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9XG4gICAgfSk7XG4gIH1cbn07XG5cbnZhciBpc1Byb3RvdHlwZU9mJDMgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xuXG52YXIgJFR5cGVFcnJvciQ4ID0gVHlwZUVycm9yO1xuXG52YXIgYW5JbnN0YW5jZSQzID0gZnVuY3Rpb24gKGl0LCBQcm90b3R5cGUpIHtcbiAgaWYgKGlzUHJvdG90eXBlT2YkMyhQcm90b3R5cGUsIGl0KSkgcmV0dXJuIGl0O1xuICB0aHJvdyAkVHlwZUVycm9yJDgoJ0luY29ycmVjdCBpbnZvY2F0aW9uJyk7XG59O1xuXG52YXIgd2VsbEtub3duU3ltYm9sJGYgPSB3ZWxsS25vd25TeW1ib2wkajtcblxudmFyIFRPX1NUUklOR19UQUckMyA9IHdlbGxLbm93blN5bWJvbCRmKCd0b1N0cmluZ1RhZycpO1xudmFyIHRlc3QgPSB7fTtcblxudGVzdFtUT19TVFJJTkdfVEFHJDNdID0gJ3onO1xuXG52YXIgdG9TdHJpbmdUYWdTdXBwb3J0ID0gU3RyaW5nKHRlc3QpID09PSAnW29iamVjdCB6XSc7XG5cbnZhciBUT19TVFJJTkdfVEFHX1NVUFBPUlQgPSB0b1N0cmluZ1RhZ1N1cHBvcnQ7XG52YXIgaXNDYWxsYWJsZSRiID0gaXNDYWxsYWJsZSRuO1xudmFyIGNsYXNzb2ZSYXcgPSBjbGFzc29mUmF3JDE7XG52YXIgd2VsbEtub3duU3ltYm9sJGUgPSB3ZWxsS25vd25TeW1ib2wkajtcblxudmFyIFRPX1NUUklOR19UQUckMiA9IHdlbGxLbm93blN5bWJvbCRlKCd0b1N0cmluZ1RhZycpO1xudmFyICRPYmplY3QkMSA9IE9iamVjdDtcblxuLy8gRVMzIHdyb25nIGhlcmVcbnZhciBDT1JSRUNUX0FSR1VNRU5UUyA9IGNsYXNzb2ZSYXcoZnVuY3Rpb24gKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID09ICdBcmd1bWVudHMnO1xuXG4vLyBmYWxsYmFjayBmb3IgSUUxMSBTY3JpcHQgQWNjZXNzIERlbmllZCBlcnJvclxudmFyIHRyeUdldCA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGl0W2tleV07XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbn07XG5cbi8vIGdldHRpbmcgdGFnIGZyb20gRVM2KyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2BcbnZhciBjbGFzc29mJDkgPSBUT19TVFJJTkdfVEFHX1NVUFBPUlQgPyBjbGFzc29mUmF3IDogZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBPLCB0YWcsIHJlc3VsdDtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXG4gICAgLy8gQEB0b1N0cmluZ1RhZyBjYXNlXG4gICAgOiB0eXBlb2YgKHRhZyA9IHRyeUdldChPID0gJE9iamVjdCQxKGl0KSwgVE9fU1RSSU5HX1RBRyQyKSkgPT0gJ3N0cmluZycgPyB0YWdcbiAgICAvLyBidWlsdGluVGFnIGNhc2VcbiAgICA6IENPUlJFQ1RfQVJHVU1FTlRTID8gY2xhc3NvZlJhdyhPKVxuICAgIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcbiAgICA6IChyZXN1bHQgPSBjbGFzc29mUmF3KE8pKSA9PSAnT2JqZWN0JyAmJiBpc0NhbGxhYmxlJGIoTy5jYWxsZWUpID8gJ0FyZ3VtZW50cycgOiByZXN1bHQ7XG59O1xuXG52YXIgdW5jdXJyeVRoaXMkZSA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgZmFpbHMkaiA9IGZhaWxzJHM7XG52YXIgaXNDYWxsYWJsZSRhID0gaXNDYWxsYWJsZSRuO1xudmFyIGNsYXNzb2YkOCA9IGNsYXNzb2YkOTtcbnZhciBnZXRCdWlsdEluJDMgPSBnZXRCdWlsdEluJDg7XG52YXIgaW5zcGVjdFNvdXJjZSQxID0gaW5zcGVjdFNvdXJjZSQ0O1xuXG52YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbnZhciBlbXB0eSA9IFtdO1xudmFyIGNvbnN0cnVjdCA9IGdldEJ1aWx0SW4kMygnUmVmbGVjdCcsICdjb25zdHJ1Y3QnKTtcbnZhciBjb25zdHJ1Y3RvclJlZ0V4cCA9IC9eXFxzKig/OmNsYXNzfGZ1bmN0aW9uKVxcYi87XG52YXIgZXhlYyQyID0gdW5jdXJyeVRoaXMkZShjb25zdHJ1Y3RvclJlZ0V4cC5leGVjKTtcbnZhciBJTkNPUlJFQ1RfVE9fU1RSSU5HID0gIWNvbnN0cnVjdG9yUmVnRXhwLmV4ZWMobm9vcCk7XG5cbnZhciBpc0NvbnN0cnVjdG9yTW9kZXJuID0gZnVuY3Rpb24gaXNDb25zdHJ1Y3Rvcihhcmd1bWVudCkge1xuICBpZiAoIWlzQ2FsbGFibGUkYShhcmd1bWVudCkpIHJldHVybiBmYWxzZTtcbiAgdHJ5IHtcbiAgICBjb25zdHJ1Y3Qobm9vcCwgZW1wdHksIGFyZ3VtZW50KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbnZhciBpc0NvbnN0cnVjdG9yTGVnYWN5ID0gZnVuY3Rpb24gaXNDb25zdHJ1Y3Rvcihhcmd1bWVudCkge1xuICBpZiAoIWlzQ2FsbGFibGUkYShhcmd1bWVudCkpIHJldHVybiBmYWxzZTtcbiAgc3dpdGNoIChjbGFzc29mJDgoYXJndW1lbnQpKSB7XG4gICAgY2FzZSAnQXN5bmNGdW5jdGlvbic6XG4gICAgY2FzZSAnR2VuZXJhdG9yRnVuY3Rpb24nOlxuICAgIGNhc2UgJ0FzeW5jR2VuZXJhdG9yRnVuY3Rpb24nOiByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdHJ5IHtcbiAgICAvLyB3ZSBjYW4ndCBjaGVjayAucHJvdG90eXBlIHNpbmNlIGNvbnN0cnVjdG9ycyBwcm9kdWNlZCBieSAuYmluZCBoYXZlbid0IGl0XG4gICAgLy8gYEZ1bmN0aW9uI3RvU3RyaW5nYCB0aHJvd3Mgb24gc29tZSBidWlsdC1pdCBmdW5jdGlvbiBpbiBzb21lIGxlZ2FjeSBlbmdpbmVzXG4gICAgLy8gKGZvciBleGFtcGxlLCBgRE9NUXVhZGAgYW5kIHNpbWlsYXIgaW4gRkY0MS0pXG4gICAgcmV0dXJuIElOQ09SUkVDVF9UT19TVFJJTkcgfHwgISFleGVjJDIoY29uc3RydWN0b3JSZWdFeHAsIGluc3BlY3RTb3VyY2UkMShhcmd1bWVudCkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG5pc0NvbnN0cnVjdG9yTGVnYWN5LnNoYW0gPSB0cnVlO1xuXG4vLyBgSXNDb25zdHJ1Y3RvcmAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWlzY29uc3RydWN0b3JcbnZhciBpc0NvbnN0cnVjdG9yJDIgPSAhY29uc3RydWN0IHx8IGZhaWxzJGooZnVuY3Rpb24gKCkge1xuICB2YXIgY2FsbGVkO1xuICByZXR1cm4gaXNDb25zdHJ1Y3Rvck1vZGVybihpc0NvbnN0cnVjdG9yTW9kZXJuLmNhbGwpXG4gICAgfHwgIWlzQ29uc3RydWN0b3JNb2Rlcm4oT2JqZWN0KVxuICAgIHx8ICFpc0NvbnN0cnVjdG9yTW9kZXJuKGZ1bmN0aW9uICgpIHsgY2FsbGVkID0gdHJ1ZTsgfSlcbiAgICB8fCBjYWxsZWQ7XG59KSA/IGlzQ29uc3RydWN0b3JMZWdhY3kgOiBpc0NvbnN0cnVjdG9yTW9kZXJuO1xuXG52YXIgaXNDb25zdHJ1Y3RvciQxID0gaXNDb25zdHJ1Y3RvciQyO1xudmFyIHRyeVRvU3RyaW5nJDMgPSB0cnlUb1N0cmluZyQ1O1xuXG52YXIgJFR5cGVFcnJvciQ3ID0gVHlwZUVycm9yO1xuXG4vLyBgQXNzZXJ0OiBJc0NvbnN0cnVjdG9yKGFyZ3VtZW50KSBpcyB0cnVlYFxudmFyIGFDb25zdHJ1Y3RvciQyID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmIChpc0NvbnN0cnVjdG9yJDEoYXJndW1lbnQpKSByZXR1cm4gYXJndW1lbnQ7XG4gIHRocm93ICRUeXBlRXJyb3IkNyh0cnlUb1N0cmluZyQzKGFyZ3VtZW50KSArICcgaXMgbm90IGEgY29uc3RydWN0b3InKTtcbn07XG5cbnZhciBhbk9iamVjdCRhID0gYW5PYmplY3QkZTtcbnZhciBhQ29uc3RydWN0b3IkMSA9IGFDb25zdHJ1Y3RvciQyO1xudmFyIHdlbGxLbm93blN5bWJvbCRkID0gd2VsbEtub3duU3ltYm9sJGo7XG5cbnZhciBTUEVDSUVTJDMgPSB3ZWxsS25vd25TeW1ib2wkZCgnc3BlY2llcycpO1xuXG4vLyBgU3BlY2llc0NvbnN0cnVjdG9yYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3BlY2llc2NvbnN0cnVjdG9yXG52YXIgc3BlY2llc0NvbnN0cnVjdG9yJDMgPSBmdW5jdGlvbiAoTywgZGVmYXVsdENvbnN0cnVjdG9yKSB7XG4gIHZhciBDID0gYW5PYmplY3QkYShPKS5jb25zdHJ1Y3RvcjtcbiAgdmFyIFM7XG4gIHJldHVybiBDID09PSB1bmRlZmluZWQgfHwgKFMgPSBhbk9iamVjdCRhKEMpW1NQRUNJRVMkM10pID09IHVuZGVmaW5lZCA/IGRlZmF1bHRDb25zdHJ1Y3RvciA6IGFDb25zdHJ1Y3RvciQxKFMpO1xufTtcblxudmFyIE5BVElWRV9CSU5EJDEgPSBmdW5jdGlvbkJpbmROYXRpdmU7XG5cbnZhciBGdW5jdGlvblByb3RvdHlwZSA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbnZhciBhcHBseSQzID0gRnVuY3Rpb25Qcm90b3R5cGUuYXBwbHk7XG52YXIgY2FsbCRnID0gRnVuY3Rpb25Qcm90b3R5cGUuY2FsbDtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tcmVmbGVjdCAtLSBzYWZlXG52YXIgZnVuY3Rpb25BcHBseSA9IHR5cGVvZiBSZWZsZWN0ID09ICdvYmplY3QnICYmIFJlZmxlY3QuYXBwbHkgfHwgKE5BVElWRV9CSU5EJDEgPyBjYWxsJGcuYmluZChhcHBseSQzKSA6IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGNhbGwkZy5hcHBseShhcHBseSQzLCBhcmd1bWVudHMpO1xufSk7XG5cbnZhciB1bmN1cnJ5VGhpcyRkID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBhQ2FsbGFibGUkNyA9IGFDYWxsYWJsZSQ5O1xudmFyIE5BVElWRV9CSU5EID0gZnVuY3Rpb25CaW5kTmF0aXZlO1xuXG52YXIgYmluZCQ2ID0gdW5jdXJyeVRoaXMkZCh1bmN1cnJ5VGhpcyRkLmJpbmQpO1xuXG4vLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBmdW5jdGlvbkJpbmRDb250ZXh0ID0gZnVuY3Rpb24gKGZuLCB0aGF0KSB7XG4gIGFDYWxsYWJsZSQ3KGZuKTtcbiAgcmV0dXJuIHRoYXQgPT09IHVuZGVmaW5lZCA/IGZuIDogTkFUSVZFX0JJTkQgPyBiaW5kJDYoZm4sIHRoYXQpIDogZnVuY3Rpb24gKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG5cbnZhciBnZXRCdWlsdEluJDIgPSBnZXRCdWlsdEluJDg7XG5cbnZhciBodG1sJDIgPSBnZXRCdWlsdEluJDIoJ2RvY3VtZW50JywgJ2RvY3VtZW50RWxlbWVudCcpO1xuXG52YXIgdW5jdXJyeVRoaXMkYyA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG5cbnZhciBhcnJheVNsaWNlJDUgPSB1bmN1cnJ5VGhpcyRjKFtdLnNsaWNlKTtcblxudmFyICRUeXBlRXJyb3IkNiA9IFR5cGVFcnJvcjtcblxudmFyIHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoJDEgPSBmdW5jdGlvbiAocGFzc2VkLCByZXF1aXJlZCkge1xuICBpZiAocGFzc2VkIDwgcmVxdWlyZWQpIHRocm93ICRUeXBlRXJyb3IkNignTm90IGVub3VnaCBhcmd1bWVudHMnKTtcbiAgcmV0dXJuIHBhc3NlZDtcbn07XG5cbnZhciB1c2VyQWdlbnQkNCA9IGVuZ2luZVVzZXJBZ2VudDtcblxudmFyIGVuZ2luZUlzSW9zID0gLyg/OmlwYWR8aXBob25lfGlwb2QpLiphcHBsZXdlYmtpdC9pLnRlc3QodXNlckFnZW50JDQpO1xuXG52YXIgZ2xvYmFsJGkgPSBnbG9iYWwkdDtcbnZhciBhcHBseSQyID0gZnVuY3Rpb25BcHBseTtcbnZhciBiaW5kJDUgPSBmdW5jdGlvbkJpbmRDb250ZXh0O1xudmFyIGlzQ2FsbGFibGUkOSA9IGlzQ2FsbGFibGUkbjtcbnZhciBoYXNPd24kMyA9IGhhc093blByb3BlcnR5XzE7XG52YXIgZmFpbHMkaSA9IGZhaWxzJHM7XG52YXIgaHRtbCQxID0gaHRtbCQyO1xudmFyIGFycmF5U2xpY2UkNCA9IGFycmF5U2xpY2UkNTtcbnZhciBjcmVhdGVFbGVtZW50ID0gZG9jdW1lbnRDcmVhdGVFbGVtZW50JDI7XG52YXIgdmFsaWRhdGVBcmd1bWVudHNMZW5ndGggPSB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aCQxO1xudmFyIElTX0lPUyQxID0gZW5naW5lSXNJb3M7XG52YXIgSVNfTk9ERSQzID0gZW5naW5lSXNOb2RlO1xuXG52YXIgc2V0JDEgPSBnbG9iYWwkaS5zZXRJbW1lZGlhdGU7XG52YXIgY2xlYXIgPSBnbG9iYWwkaS5jbGVhckltbWVkaWF0ZTtcbnZhciBwcm9jZXNzJDIgPSBnbG9iYWwkaS5wcm9jZXNzO1xudmFyIERpc3BhdGNoID0gZ2xvYmFsJGkuRGlzcGF0Y2g7XG52YXIgRnVuY3Rpb24kMSA9IGdsb2JhbCRpLkZ1bmN0aW9uO1xudmFyIE1lc3NhZ2VDaGFubmVsID0gZ2xvYmFsJGkuTWVzc2FnZUNoYW5uZWw7XG52YXIgU3RyaW5nJDEgPSBnbG9iYWwkaS5TdHJpbmc7XG52YXIgY291bnRlciA9IDA7XG52YXIgcXVldWUkMSA9IHt9O1xudmFyIE9OUkVBRFlTVEFURUNIQU5HRSA9ICdvbnJlYWR5c3RhdGVjaGFuZ2UnO1xudmFyIGxvY2F0aW9uLCBkZWZlciwgY2hhbm5lbCwgcG9ydDtcblxudHJ5IHtcbiAgLy8gRGVubyB0aHJvd3MgYSBSZWZlcmVuY2VFcnJvciBvbiBgbG9jYXRpb25gIGFjY2VzcyB3aXRob3V0IGAtLWxvY2F0aW9uYCBmbGFnXG4gIGxvY2F0aW9uID0gZ2xvYmFsJGkubG9jYXRpb247XG59IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG5cbnZhciBydW4gPSBmdW5jdGlvbiAoaWQpIHtcbiAgaWYgKGhhc093biQzKHF1ZXVlJDEsIGlkKSkge1xuICAgIHZhciBmbiA9IHF1ZXVlJDFbaWRdO1xuICAgIGRlbGV0ZSBxdWV1ZSQxW2lkXTtcbiAgICBmbigpO1xuICB9XG59O1xuXG52YXIgcnVubmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcnVuKGlkKTtcbiAgfTtcbn07XG5cbnZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudCkge1xuICBydW4oZXZlbnQuZGF0YSk7XG59O1xuXG52YXIgcG9zdCA9IGZ1bmN0aW9uIChpZCkge1xuICAvLyBvbGQgZW5naW5lcyBoYXZlIG5vdCBsb2NhdGlvbi5vcmlnaW5cbiAgZ2xvYmFsJGkucG9zdE1lc3NhZ2UoU3RyaW5nJDEoaWQpLCBsb2NhdGlvbi5wcm90b2NvbCArICcvLycgKyBsb2NhdGlvbi5ob3N0KTtcbn07XG5cbi8vIE5vZGUuanMgMC45KyAmIElFMTArIGhhcyBzZXRJbW1lZGlhdGUsIG90aGVyd2lzZTpcbmlmICghc2V0JDEgfHwgIWNsZWFyKSB7XG4gIHNldCQxID0gZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGhhbmRsZXIpIHtcbiAgICB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aChhcmd1bWVudHMubGVuZ3RoLCAxKTtcbiAgICB2YXIgZm4gPSBpc0NhbGxhYmxlJDkoaGFuZGxlcikgPyBoYW5kbGVyIDogRnVuY3Rpb24kMShoYW5kbGVyKTtcbiAgICB2YXIgYXJncyA9IGFycmF5U2xpY2UkNChhcmd1bWVudHMsIDEpO1xuICAgIHF1ZXVlJDFbKytjb3VudGVyXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGFwcGx5JDIoZm4sIHVuZGVmaW5lZCwgYXJncyk7XG4gICAgfTtcbiAgICBkZWZlcihjb3VudGVyKTtcbiAgICByZXR1cm4gY291bnRlcjtcbiAgfTtcbiAgY2xlYXIgPSBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShpZCkge1xuICAgIGRlbGV0ZSBxdWV1ZSQxW2lkXTtcbiAgfTtcbiAgLy8gTm9kZS5qcyAwLjgtXG4gIGlmIChJU19OT0RFJDMpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgcHJvY2VzcyQyLm5leHRUaWNrKHJ1bm5lcihpZCkpO1xuICAgIH07XG4gIC8vIFNwaGVyZSAoSlMgZ2FtZSBlbmdpbmUpIERpc3BhdGNoIEFQSVxuICB9IGVsc2UgaWYgKERpc3BhdGNoICYmIERpc3BhdGNoLm5vdykge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBEaXNwYXRjaC5ub3cocnVubmVyKGlkKSk7XG4gICAgfTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBNZXNzYWdlQ2hhbm5lbCwgaW5jbHVkZXMgV2ViV29ya2Vyc1xuICAvLyBleGNlcHQgaU9TIC0gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzYyNFxuICB9IGVsc2UgaWYgKE1lc3NhZ2VDaGFubmVsICYmICFJU19JT1MkMSkge1xuICAgIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICBwb3J0ID0gY2hhbm5lbC5wb3J0MjtcbiAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGxpc3RlbmVyO1xuICAgIGRlZmVyID0gYmluZCQ1KHBvcnQucG9zdE1lc3NhZ2UsIHBvcnQpO1xuICAvLyBCcm93c2VycyB3aXRoIHBvc3RNZXNzYWdlLCBza2lwIFdlYldvcmtlcnNcbiAgLy8gSUU4IGhhcyBwb3N0TWVzc2FnZSwgYnV0IGl0J3Mgc3luYyAmIHR5cGVvZiBpdHMgcG9zdE1lc3NhZ2UgaXMgJ29iamVjdCdcbiAgfSBlbHNlIGlmIChcbiAgICBnbG9iYWwkaS5hZGRFdmVudExpc3RlbmVyICYmXG4gICAgaXNDYWxsYWJsZSQ5KGdsb2JhbCRpLnBvc3RNZXNzYWdlKSAmJlxuICAgICFnbG9iYWwkaS5pbXBvcnRTY3JpcHRzICYmXG4gICAgbG9jYXRpb24gJiYgbG9jYXRpb24ucHJvdG9jb2wgIT09ICdmaWxlOicgJiZcbiAgICAhZmFpbHMkaShwb3N0KVxuICApIHtcbiAgICBkZWZlciA9IHBvc3Q7XG4gICAgZ2xvYmFsJGkuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGxpc3RlbmVyLCBmYWxzZSk7XG4gIC8vIElFOC1cbiAgfSBlbHNlIGlmIChPTlJFQURZU1RBVEVDSEFOR0UgaW4gY3JlYXRlRWxlbWVudCgnc2NyaXB0JykpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgaHRtbCQxLmFwcGVuZENoaWxkKGNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpKVtPTlJFQURZU1RBVEVDSEFOR0VdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBodG1sJDEucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgICAgIHJ1bihpZCk7XG4gICAgICB9O1xuICAgIH07XG4gIC8vIFJlc3Qgb2xkIGJyb3dzZXJzXG4gIH0gZWxzZSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHNldFRpbWVvdXQocnVubmVyKGlkKSwgMCk7XG4gICAgfTtcbiAgfVxufVxuXG52YXIgdGFzayQxID0ge1xuICBzZXQ6IHNldCQxLFxuICBjbGVhcjogY2xlYXJcbn07XG5cbnZhciB1c2VyQWdlbnQkMyA9IGVuZ2luZVVzZXJBZ2VudDtcbnZhciBnbG9iYWwkaCA9IGdsb2JhbCR0O1xuXG52YXIgZW5naW5lSXNJb3NQZWJibGUgPSAvaXBhZHxpcGhvbmV8aXBvZC9pLnRlc3QodXNlckFnZW50JDMpICYmIGdsb2JhbCRoLlBlYmJsZSAhPT0gdW5kZWZpbmVkO1xuXG52YXIgdXNlckFnZW50JDIgPSBlbmdpbmVVc2VyQWdlbnQ7XG5cbnZhciBlbmdpbmVJc1dlYm9zV2Via2l0ID0gL3dlYjBzKD8hLipjaHJvbWUpL2kudGVzdCh1c2VyQWdlbnQkMik7XG5cbnZhciBnbG9iYWwkZyA9IGdsb2JhbCR0O1xudmFyIGJpbmQkNCA9IGZ1bmN0aW9uQmluZENvbnRleHQ7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gb2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLmY7XG52YXIgbWFjcm90YXNrID0gdGFzayQxLnNldDtcbnZhciBJU19JT1MgPSBlbmdpbmVJc0lvcztcbnZhciBJU19JT1NfUEVCQkxFID0gZW5naW5lSXNJb3NQZWJibGU7XG52YXIgSVNfV0VCT1NfV0VCS0lUID0gZW5naW5lSXNXZWJvc1dlYmtpdDtcbnZhciBJU19OT0RFJDIgPSBlbmdpbmVJc05vZGU7XG5cbnZhciBNdXRhdGlvbk9ic2VydmVyID0gZ2xvYmFsJGcuTXV0YXRpb25PYnNlcnZlciB8fCBnbG9iYWwkZy5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xudmFyIGRvY3VtZW50JDIgPSBnbG9iYWwkZy5kb2N1bWVudDtcbnZhciBwcm9jZXNzJDEgPSBnbG9iYWwkZy5wcm9jZXNzO1xudmFyIFByb21pc2UkMSA9IGdsb2JhbCRnLlByb21pc2U7XG4vLyBOb2RlLmpzIDExIHNob3dzIEV4cGVyaW1lbnRhbFdhcm5pbmcgb24gZ2V0dGluZyBgcXVldWVNaWNyb3Rhc2tgXG52YXIgcXVldWVNaWNyb3Rhc2tEZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGdsb2JhbCRnLCAncXVldWVNaWNyb3Rhc2snKTtcbnZhciBxdWV1ZU1pY3JvdGFzayA9IHF1ZXVlTWljcm90YXNrRGVzY3JpcHRvciAmJiBxdWV1ZU1pY3JvdGFza0Rlc2NyaXB0b3IudmFsdWU7XG5cbnZhciBmbHVzaCwgaGVhZCwgbGFzdCwgbm90aWZ5JDEsIHRvZ2dsZSwgbm9kZSwgcHJvbWlzZSwgdGhlbjtcblxuLy8gbW9kZXJuIGVuZ2luZXMgaGF2ZSBxdWV1ZU1pY3JvdGFzayBtZXRob2RcbmlmICghcXVldWVNaWNyb3Rhc2spIHtcbiAgZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBhcmVudCwgZm47XG4gICAgaWYgKElTX05PREUkMiAmJiAocGFyZW50ID0gcHJvY2VzcyQxLmRvbWFpbikpIHBhcmVudC5leGl0KCk7XG4gICAgd2hpbGUgKGhlYWQpIHtcbiAgICAgIGZuID0gaGVhZC5mbjtcbiAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICAgICB0cnkge1xuICAgICAgICBmbigpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGhlYWQpIG5vdGlmeSQxKCk7XG4gICAgICAgIGVsc2UgbGFzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSBsYXN0ID0gdW5kZWZpbmVkO1xuICAgIGlmIChwYXJlbnQpIHBhcmVudC5lbnRlcigpO1xuICB9O1xuXG4gIC8vIGJyb3dzZXJzIHdpdGggTXV0YXRpb25PYnNlcnZlciwgZXhjZXB0IGlPUyAtIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8zMzlcbiAgLy8gYWxzbyBleGNlcHQgV2ViT1MgV2Via2l0IGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84OThcbiAgaWYgKCFJU19JT1MgJiYgIUlTX05PREUkMiAmJiAhSVNfV0VCT1NfV0VCS0lUICYmIE11dGF0aW9uT2JzZXJ2ZXIgJiYgZG9jdW1lbnQkMikge1xuICAgIHRvZ2dsZSA9IHRydWU7XG4gICAgbm9kZSA9IGRvY3VtZW50JDIuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgIG5ldyBNdXRhdGlvbk9ic2VydmVyKGZsdXNoKS5vYnNlcnZlKG5vZGUsIHsgY2hhcmFjdGVyRGF0YTogdHJ1ZSB9KTtcbiAgICBub3RpZnkkMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIG5vZGUuZGF0YSA9IHRvZ2dsZSA9ICF0b2dnbGU7XG4gICAgfTtcbiAgLy8gZW52aXJvbm1lbnRzIHdpdGggbWF5YmUgbm9uLWNvbXBsZXRlbHkgY29ycmVjdCwgYnV0IGV4aXN0ZW50IFByb21pc2VcbiAgfSBlbHNlIGlmICghSVNfSU9TX1BFQkJMRSAmJiBQcm9taXNlJDEgJiYgUHJvbWlzZSQxLnJlc29sdmUpIHtcbiAgICAvLyBQcm9taXNlLnJlc29sdmUgd2l0aG91dCBhbiBhcmd1bWVudCB0aHJvd3MgYW4gZXJyb3IgaW4gTEcgV2ViT1MgMlxuICAgIHByb21pc2UgPSBQcm9taXNlJDEucmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgIC8vIHdvcmthcm91bmQgb2YgV2ViS2l0IH4gaU9TIFNhZmFyaSAxMC4xIGJ1Z1xuICAgIHByb21pc2UuY29uc3RydWN0b3IgPSBQcm9taXNlJDE7XG4gICAgdGhlbiA9IGJpbmQkNChwcm9taXNlLnRoZW4sIHByb21pc2UpO1xuICAgIG5vdGlmeSQxID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhlbihmbHVzaCk7XG4gICAgfTtcbiAgLy8gTm9kZS5qcyB3aXRob3V0IHByb21pc2VzXG4gIH0gZWxzZSBpZiAoSVNfTk9ERSQyKSB7XG4gICAgbm90aWZ5JDEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwcm9jZXNzJDEubmV4dFRpY2soZmx1c2gpO1xuICAgIH07XG4gIC8vIGZvciBvdGhlciBlbnZpcm9ubWVudHMgLSBtYWNyb3Rhc2sgYmFzZWQgb246XG4gIC8vIC0gc2V0SW1tZWRpYXRlXG4gIC8vIC0gTWVzc2FnZUNoYW5uZWxcbiAgLy8gLSB3aW5kb3cucG9zdE1lc3NhZ2VcbiAgLy8gLSBvbnJlYWR5c3RhdGVjaGFuZ2VcbiAgLy8gLSBzZXRUaW1lb3V0XG4gIH0gZWxzZSB7XG4gICAgLy8gc3RyYW5nZSBJRSArIHdlYnBhY2sgZGV2IHNlcnZlciBidWcgLSB1c2UgLmJpbmQoZ2xvYmFsKVxuICAgIG1hY3JvdGFzayA9IGJpbmQkNChtYWNyb3Rhc2ssIGdsb2JhbCRnKTtcbiAgICBub3RpZnkkMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIG1hY3JvdGFzayhmbHVzaCk7XG4gICAgfTtcbiAgfVxufVxuXG52YXIgbWljcm90YXNrJDEgPSBxdWV1ZU1pY3JvdGFzayB8fCBmdW5jdGlvbiAoZm4pIHtcbiAgdmFyIHRhc2sgPSB7IGZuOiBmbiwgbmV4dDogdW5kZWZpbmVkIH07XG4gIGlmIChsYXN0KSBsYXN0Lm5leHQgPSB0YXNrO1xuICBpZiAoIWhlYWQpIHtcbiAgICBoZWFkID0gdGFzaztcbiAgICBub3RpZnkkMSgpO1xuICB9IGxhc3QgPSB0YXNrO1xufTtcblxudmFyIGdsb2JhbCRmID0gZ2xvYmFsJHQ7XG5cbnZhciBob3N0UmVwb3J0RXJyb3JzJDEgPSBmdW5jdGlvbiAoYSwgYikge1xuICB2YXIgY29uc29sZSA9IGdsb2JhbCRmLmNvbnNvbGU7XG4gIGlmIChjb25zb2xlICYmIGNvbnNvbGUuZXJyb3IpIHtcbiAgICBhcmd1bWVudHMubGVuZ3RoID09IDEgPyBjb25zb2xlLmVycm9yKGEpIDogY29uc29sZS5lcnJvcihhLCBiKTtcbiAgfVxufTtcblxudmFyIHBlcmZvcm0kMyA9IGZ1bmN0aW9uIChleGVjKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHsgZXJyb3I6IGZhbHNlLCB2YWx1ZTogZXhlYygpIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHsgZXJyb3I6IHRydWUsIHZhbHVlOiBlcnJvciB9O1xuICB9XG59O1xuXG52YXIgUXVldWUkMSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5oZWFkID0gbnVsbDtcbiAgdGhpcy50YWlsID0gbnVsbDtcbn07XG5cblF1ZXVlJDEucHJvdG90eXBlID0ge1xuICBhZGQ6IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgdmFyIGVudHJ5ID0geyBpdGVtOiBpdGVtLCBuZXh0OiBudWxsIH07XG4gICAgaWYgKHRoaXMuaGVhZCkgdGhpcy50YWlsLm5leHQgPSBlbnRyeTtcbiAgICBlbHNlIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgIHRoaXMudGFpbCA9IGVudHJ5O1xuICB9LFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZW50cnkgPSB0aGlzLmhlYWQ7XG4gICAgaWYgKGVudHJ5KSB7XG4gICAgICB0aGlzLmhlYWQgPSBlbnRyeS5uZXh0O1xuICAgICAgaWYgKHRoaXMudGFpbCA9PT0gZW50cnkpIHRoaXMudGFpbCA9IG51bGw7XG4gICAgICByZXR1cm4gZW50cnkuaXRlbTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBxdWV1ZSA9IFF1ZXVlJDE7XG5cbnZhciBnbG9iYWwkZSA9IGdsb2JhbCR0O1xuXG52YXIgcHJvbWlzZU5hdGl2ZUNvbnN0cnVjdG9yID0gZ2xvYmFsJGUuUHJvbWlzZTtcblxudmFyIGVuZ2luZUlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgdHlwZW9mIERlbm8gIT0gJ29iamVjdCc7XG5cbnZhciBnbG9iYWwkZCA9IGdsb2JhbCR0O1xudmFyIE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQzID0gcHJvbWlzZU5hdGl2ZUNvbnN0cnVjdG9yO1xudmFyIGlzQ2FsbGFibGUkOCA9IGlzQ2FsbGFibGUkbjtcbnZhciBpc0ZvcmNlZCA9IGlzRm9yY2VkXzE7XG52YXIgaW5zcGVjdFNvdXJjZSA9IGluc3BlY3RTb3VyY2UkNDtcbnZhciB3ZWxsS25vd25TeW1ib2wkYyA9IHdlbGxLbm93blN5bWJvbCRqO1xudmFyIElTX0JST1dTRVIgPSBlbmdpbmVJc0Jyb3dzZXI7XG52YXIgVjhfVkVSU0lPTiA9IGVuZ2luZVY4VmVyc2lvbjtcblxuTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yJDMgJiYgTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yJDMucHJvdG90eXBlO1xudmFyIFNQRUNJRVMkMiA9IHdlbGxLbm93blN5bWJvbCRjKCdzcGVjaWVzJyk7XG52YXIgU1VCQ0xBU1NJTkcgPSBmYWxzZTtcbnZhciBOQVRJVkVfUFJPTUlTRV9SRUpFQ1RJT05fRVZFTlQkMSA9IGlzQ2FsbGFibGUkOChnbG9iYWwkZC5Qcm9taXNlUmVqZWN0aW9uRXZlbnQpO1xuXG52YXIgRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkNSA9IGlzRm9yY2VkKCdQcm9taXNlJywgZnVuY3Rpb24gKCkge1xuICB2YXIgUFJPTUlTRV9DT05TVFJVQ1RPUl9TT1VSQ0UgPSBpbnNwZWN0U291cmNlKE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQzKTtcbiAgdmFyIEdMT0JBTF9DT1JFX0pTX1BST01JU0UgPSBQUk9NSVNFX0NPTlNUUlVDVE9SX1NPVVJDRSAhPT0gU3RyaW5nKE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQzKTtcbiAgLy8gVjggNi42IChOb2RlIDEwIGFuZCBDaHJvbWUgNjYpIGhhdmUgYSBidWcgd2l0aCByZXNvbHZpbmcgY3VzdG9tIHRoZW5hYmxlc1xuICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD04MzA1NjVcbiAgLy8gV2UgY2FuJ3QgZGV0ZWN0IGl0IHN5bmNocm9ub3VzbHksIHNvIGp1c3QgY2hlY2sgdmVyc2lvbnNcbiAgaWYgKCFHTE9CQUxfQ09SRV9KU19QUk9NSVNFICYmIFY4X1ZFUlNJT04gPT09IDY2KSByZXR1cm4gdHJ1ZTtcbiAgLy8gV2UgY2FuJ3QgdXNlIEBAc3BlY2llcyBmZWF0dXJlIGRldGVjdGlvbiBpbiBWOCBzaW5jZSBpdCBjYXVzZXNcbiAgLy8gZGVvcHRpbWl6YXRpb24gYW5kIHBlcmZvcm1hbmNlIGRlZ3JhZGF0aW9uXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy82NzlcbiAgaWYgKFY4X1ZFUlNJT04gPj0gNTEgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KFBST01JU0VfQ09OU1RSVUNUT1JfU09VUkNFKSkgcmV0dXJuIGZhbHNlO1xuICAvLyBEZXRlY3QgY29ycmVjdG5lc3Mgb2Ygc3ViY2xhc3Npbmcgd2l0aCBAQHNwZWNpZXMgc3VwcG9ydFxuICB2YXIgcHJvbWlzZSA9IG5ldyBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMyhmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKDEpOyB9KTtcbiAgdmFyIEZha2VQcm9taXNlID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgICBleGVjKGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSwgZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9KTtcbiAgfTtcbiAgdmFyIGNvbnN0cnVjdG9yID0gcHJvbWlzZS5jb25zdHJ1Y3RvciA9IHt9O1xuICBjb25zdHJ1Y3RvcltTUEVDSUVTJDJdID0gRmFrZVByb21pc2U7XG4gIFNVQkNMQVNTSU5HID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSkgaW5zdGFuY2VvZiBGYWtlUHJvbWlzZTtcbiAgaWYgKCFTVUJDTEFTU0lORykgcmV0dXJuIHRydWU7XG4gIC8vIFVuaGFuZGxlZCByZWplY3Rpb25zIHRyYWNraW5nIHN1cHBvcnQsIE5vZGVKUyBQcm9taXNlIHdpdGhvdXQgaXQgZmFpbHMgQEBzcGVjaWVzIHRlc3RcbiAgcmV0dXJuICFHTE9CQUxfQ09SRV9KU19QUk9NSVNFICYmIElTX0JST1dTRVIgJiYgIU5BVElWRV9QUk9NSVNFX1JFSkVDVElPTl9FVkVOVCQxO1xufSk7XG5cbnZhciBwcm9taXNlQ29uc3RydWN0b3JEZXRlY3Rpb24gPSB7XG4gIENPTlNUUlVDVE9SOiBGT1JDRURfUFJPTUlTRV9DT05TVFJVQ1RPUiQ1LFxuICBSRUpFQ1RJT05fRVZFTlQ6IE5BVElWRV9QUk9NSVNFX1JFSkVDVElPTl9FVkVOVCQxLFxuICBTVUJDTEFTU0lORzogU1VCQ0xBU1NJTkdcbn07XG5cbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSQyID0ge307XG5cbnZhciBhQ2FsbGFibGUkNiA9IGFDYWxsYWJsZSQ5O1xuXG52YXIgUHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbiAoQykge1xuICB2YXIgcmVzb2x2ZSwgcmVqZWN0O1xuICB0aGlzLnByb21pc2UgPSBuZXcgQyhmdW5jdGlvbiAoJCRyZXNvbHZlLCAkJHJlamVjdCkge1xuICAgIGlmIChyZXNvbHZlICE9PSB1bmRlZmluZWQgfHwgcmVqZWN0ICE9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcignQmFkIFByb21pc2UgY29uc3RydWN0b3InKTtcbiAgICByZXNvbHZlID0gJCRyZXNvbHZlO1xuICAgIHJlamVjdCA9ICQkcmVqZWN0O1xuICB9KTtcbiAgdGhpcy5yZXNvbHZlID0gYUNhbGxhYmxlJDYocmVzb2x2ZSk7XG4gIHRoaXMucmVqZWN0ID0gYUNhbGxhYmxlJDYocmVqZWN0KTtcbn07XG5cbi8vIGBOZXdQcm9taXNlQ2FwYWJpbGl0eWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW5ld3Byb21pc2VjYXBhYmlsaXR5XG5uZXdQcm9taXNlQ2FwYWJpbGl0eSQyLmYgPSBmdW5jdGlvbiAoQykge1xuICByZXR1cm4gbmV3IFByb21pc2VDYXBhYmlsaXR5KEMpO1xufTtcblxudmFyICQkZSA9IF9leHBvcnQ7XG52YXIgSVNfTk9ERSQxID0gZW5naW5lSXNOb2RlO1xudmFyIGdsb2JhbCRjID0gZ2xvYmFsJHQ7XG52YXIgY2FsbCRmID0gZnVuY3Rpb25DYWxsO1xudmFyIGRlZmluZUJ1aWx0SW4kNiA9IGRlZmluZUJ1aWx0SW4kODtcbnZhciBzZXRQcm90b3R5cGVPZiQ1ID0gb2JqZWN0U2V0UHJvdG90eXBlT2Y7XG52YXIgc2V0VG9TdHJpbmdUYWckMyA9IHNldFRvU3RyaW5nVGFnJDQ7XG52YXIgc2V0U3BlY2llcyQxID0gc2V0U3BlY2llcyQyO1xudmFyIGFDYWxsYWJsZSQ1ID0gYUNhbGxhYmxlJDk7XG52YXIgaXNDYWxsYWJsZSQ3ID0gaXNDYWxsYWJsZSRuO1xudmFyIGlzT2JqZWN0JDcgPSBpc09iamVjdCRkO1xudmFyIGFuSW5zdGFuY2UkMiA9IGFuSW5zdGFuY2UkMztcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IkMiA9IHNwZWNpZXNDb25zdHJ1Y3RvciQzO1xudmFyIHRhc2sgPSB0YXNrJDEuc2V0O1xudmFyIG1pY3JvdGFzayA9IG1pY3JvdGFzayQxO1xudmFyIGhvc3RSZXBvcnRFcnJvcnMgPSBob3N0UmVwb3J0RXJyb3JzJDE7XG52YXIgcGVyZm9ybSQyID0gcGVyZm9ybSQzO1xudmFyIFF1ZXVlID0gcXVldWU7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSQ0ID0gaW50ZXJuYWxTdGF0ZTtcbnZhciBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMiA9IHByb21pc2VOYXRpdmVDb25zdHJ1Y3RvcjtcbnZhciBQcm9taXNlQ29uc3RydWN0b3JEZXRlY3Rpb24gPSBwcm9taXNlQ29uc3RydWN0b3JEZXRlY3Rpb247XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUkMyA9IG5ld1Byb21pc2VDYXBhYmlsaXR5JDI7XG5cbnZhciBQUk9NSVNFID0gJ1Byb21pc2UnO1xudmFyIEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SJDQgPSBQcm9taXNlQ29uc3RydWN0b3JEZXRlY3Rpb24uQ09OU1RSVUNUT1I7XG52YXIgTkFUSVZFX1BST01JU0VfUkVKRUNUSU9OX0VWRU5UID0gUHJvbWlzZUNvbnN0cnVjdG9yRGV0ZWN0aW9uLlJFSkVDVElPTl9FVkVOVDtcbnZhciBOQVRJVkVfUFJPTUlTRV9TVUJDTEFTU0lORyA9IFByb21pc2VDb25zdHJ1Y3RvckRldGVjdGlvbi5TVUJDTEFTU0lORztcbnZhciBnZXRJbnRlcm5hbFByb21pc2VTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUkNC5nZXR0ZXJGb3IoUFJPTUlTRSk7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSQzID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQ0LnNldDtcbnZhciBOYXRpdmVQcm9taXNlUHJvdG90eXBlJDEgPSBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMiAmJiBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMi5wcm90b3R5cGU7XG52YXIgUHJvbWlzZUNvbnN0cnVjdG9yID0gTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yJDI7XG52YXIgUHJvbWlzZVByb3RvdHlwZSA9IE5hdGl2ZVByb21pc2VQcm90b3R5cGUkMTtcbnZhciBUeXBlRXJyb3IkMiA9IGdsb2JhbCRjLlR5cGVFcnJvcjtcbnZhciBkb2N1bWVudCQxID0gZ2xvYmFsJGMuZG9jdW1lbnQ7XG52YXIgcHJvY2VzcyA9IGdsb2JhbCRjLnByb2Nlc3M7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkkMSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlJDMuZjtcbnZhciBuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSQxO1xuXG52YXIgRElTUEFUQ0hfRVZFTlQgPSAhIShkb2N1bWVudCQxICYmIGRvY3VtZW50JDEuY3JlYXRlRXZlbnQgJiYgZ2xvYmFsJGMuZGlzcGF0Y2hFdmVudCk7XG52YXIgVU5IQU5ETEVEX1JFSkVDVElPTiA9ICd1bmhhbmRsZWRyZWplY3Rpb24nO1xudmFyIFJFSkVDVElPTl9IQU5ETEVEID0gJ3JlamVjdGlvbmhhbmRsZWQnO1xudmFyIFBFTkRJTkcgPSAwO1xudmFyIEZVTEZJTExFRCA9IDE7XG52YXIgUkVKRUNURUQgPSAyO1xudmFyIEhBTkRMRUQgPSAxO1xudmFyIFVOSEFORExFRCA9IDI7XG5cbnZhciBJbnRlcm5hbCwgT3duUHJvbWlzZUNhcGFiaWxpdHksIFByb21pc2VXcmFwcGVyLCBuYXRpdmVUaGVuO1xuXG4vLyBoZWxwZXJzXG52YXIgaXNUaGVuYWJsZSA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgdGhlbjtcbiAgcmV0dXJuIGlzT2JqZWN0JDcoaXQpICYmIGlzQ2FsbGFibGUkNyh0aGVuID0gaXQudGhlbikgPyB0aGVuIDogZmFsc2U7XG59O1xuXG52YXIgY2FsbFJlYWN0aW9uID0gZnVuY3Rpb24gKHJlYWN0aW9uLCBzdGF0ZSkge1xuICB2YXIgdmFsdWUgPSBzdGF0ZS52YWx1ZTtcbiAgdmFyIG9rID0gc3RhdGUuc3RhdGUgPT0gRlVMRklMTEVEO1xuICB2YXIgaGFuZGxlciA9IG9rID8gcmVhY3Rpb24ub2sgOiByZWFjdGlvbi5mYWlsO1xuICB2YXIgcmVzb2x2ZSA9IHJlYWN0aW9uLnJlc29sdmU7XG4gIHZhciByZWplY3QgPSByZWFjdGlvbi5yZWplY3Q7XG4gIHZhciBkb21haW4gPSByZWFjdGlvbi5kb21haW47XG4gIHZhciByZXN1bHQsIHRoZW4sIGV4aXRlZDtcbiAgdHJ5IHtcbiAgICBpZiAoaGFuZGxlcikge1xuICAgICAgaWYgKCFvaykge1xuICAgICAgICBpZiAoc3RhdGUucmVqZWN0aW9uID09PSBVTkhBTkRMRUQpIG9uSGFuZGxlVW5oYW5kbGVkKHN0YXRlKTtcbiAgICAgICAgc3RhdGUucmVqZWN0aW9uID0gSEFORExFRDtcbiAgICAgIH1cbiAgICAgIGlmIChoYW5kbGVyID09PSB0cnVlKSByZXN1bHQgPSB2YWx1ZTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoZG9tYWluKSBkb21haW4uZW50ZXIoKTtcbiAgICAgICAgcmVzdWx0ID0gaGFuZGxlcih2YWx1ZSk7IC8vIGNhbiB0aHJvd1xuICAgICAgICBpZiAoZG9tYWluKSB7XG4gICAgICAgICAgZG9tYWluLmV4aXQoKTtcbiAgICAgICAgICBleGl0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0ID09PSByZWFjdGlvbi5wcm9taXNlKSB7XG4gICAgICAgIHJlamVjdChUeXBlRXJyb3IkMignUHJvbWlzZS1jaGFpbiBjeWNsZScpKTtcbiAgICAgIH0gZWxzZSBpZiAodGhlbiA9IGlzVGhlbmFibGUocmVzdWx0KSkge1xuICAgICAgICBjYWxsJGYodGhlbiwgcmVzdWx0LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgfSBlbHNlIHJlc29sdmUocmVzdWx0KTtcbiAgICB9IGVsc2UgcmVqZWN0KHZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoZG9tYWluICYmICFleGl0ZWQpIGRvbWFpbi5leGl0KCk7XG4gICAgcmVqZWN0KGVycm9yKTtcbiAgfVxufTtcblxudmFyIG5vdGlmeSA9IGZ1bmN0aW9uIChzdGF0ZSwgaXNSZWplY3QpIHtcbiAgaWYgKHN0YXRlLm5vdGlmaWVkKSByZXR1cm47XG4gIHN0YXRlLm5vdGlmaWVkID0gdHJ1ZTtcbiAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVhY3Rpb25zID0gc3RhdGUucmVhY3Rpb25zO1xuICAgIHZhciByZWFjdGlvbjtcbiAgICB3aGlsZSAocmVhY3Rpb24gPSByZWFjdGlvbnMuZ2V0KCkpIHtcbiAgICAgIGNhbGxSZWFjdGlvbihyZWFjdGlvbiwgc3RhdGUpO1xuICAgIH1cbiAgICBzdGF0ZS5ub3RpZmllZCA9IGZhbHNlO1xuICAgIGlmIChpc1JlamVjdCAmJiAhc3RhdGUucmVqZWN0aW9uKSBvblVuaGFuZGxlZChzdGF0ZSk7XG4gIH0pO1xufTtcblxudmFyIGRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbiAobmFtZSwgcHJvbWlzZSwgcmVhc29uKSB7XG4gIHZhciBldmVudCwgaGFuZGxlcjtcbiAgaWYgKERJU1BBVENIX0VWRU5UKSB7XG4gICAgZXZlbnQgPSBkb2N1bWVudCQxLmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgIGV2ZW50LnByb21pc2UgPSBwcm9taXNlO1xuICAgIGV2ZW50LnJlYXNvbiA9IHJlYXNvbjtcbiAgICBldmVudC5pbml0RXZlbnQobmFtZSwgZmFsc2UsIHRydWUpO1xuICAgIGdsb2JhbCRjLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICB9IGVsc2UgZXZlbnQgPSB7IHByb21pc2U6IHByb21pc2UsIHJlYXNvbjogcmVhc29uIH07XG4gIGlmICghTkFUSVZFX1BST01JU0VfUkVKRUNUSU9OX0VWRU5UICYmIChoYW5kbGVyID0gZ2xvYmFsJGNbJ29uJyArIG5hbWVdKSkgaGFuZGxlcihldmVudCk7XG4gIGVsc2UgaWYgKG5hbWUgPT09IFVOSEFORExFRF9SRUpFQ1RJT04pIGhvc3RSZXBvcnRFcnJvcnMoJ1VuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbicsIHJlYXNvbik7XG59O1xuXG52YXIgb25VbmhhbmRsZWQgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgY2FsbCRmKHRhc2ssIGdsb2JhbCRjLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByb21pc2UgPSBzdGF0ZS5mYWNhZGU7XG4gICAgdmFyIHZhbHVlID0gc3RhdGUudmFsdWU7XG4gICAgdmFyIElTX1VOSEFORExFRCA9IGlzVW5oYW5kbGVkKHN0YXRlKTtcbiAgICB2YXIgcmVzdWx0O1xuICAgIGlmIChJU19VTkhBTkRMRUQpIHtcbiAgICAgIHJlc3VsdCA9IHBlcmZvcm0kMihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChJU19OT0RFJDEpIHtcbiAgICAgICAgICBwcm9jZXNzLmVtaXQoJ3VuaGFuZGxlZFJlamVjdGlvbicsIHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgfSBlbHNlIGRpc3BhdGNoRXZlbnQoVU5IQU5ETEVEX1JFSkVDVElPTiwgcHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgICAvLyBCcm93c2VycyBzaG91bGQgbm90IHRyaWdnZXIgYHJlamVjdGlvbkhhbmRsZWRgIGV2ZW50IGlmIGl0IHdhcyBoYW5kbGVkIGhlcmUsIE5vZGVKUyAtIHNob3VsZFxuICAgICAgc3RhdGUucmVqZWN0aW9uID0gSVNfTk9ERSQxIHx8IGlzVW5oYW5kbGVkKHN0YXRlKSA/IFVOSEFORExFRCA6IEhBTkRMRUQ7XG4gICAgICBpZiAocmVzdWx0LmVycm9yKSB0aHJvdyByZXN1bHQudmFsdWU7XG4gICAgfVxuICB9KTtcbn07XG5cbnZhciBpc1VuaGFuZGxlZCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUucmVqZWN0aW9uICE9PSBIQU5ETEVEICYmICFzdGF0ZS5wYXJlbnQ7XG59O1xuXG52YXIgb25IYW5kbGVVbmhhbmRsZWQgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgY2FsbCRmKHRhc2ssIGdsb2JhbCRjLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByb21pc2UgPSBzdGF0ZS5mYWNhZGU7XG4gICAgaWYgKElTX05PREUkMSkge1xuICAgICAgcHJvY2Vzcy5lbWl0KCdyZWplY3Rpb25IYW5kbGVkJywgcHJvbWlzZSk7XG4gICAgfSBlbHNlIGRpc3BhdGNoRXZlbnQoUkVKRUNUSU9OX0hBTkRMRUQsIHByb21pc2UsIHN0YXRlLnZhbHVlKTtcbiAgfSk7XG59O1xuXG52YXIgYmluZCQzID0gZnVuY3Rpb24gKGZuLCBzdGF0ZSwgdW53cmFwKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBmbihzdGF0ZSwgdmFsdWUsIHVud3JhcCk7XG4gIH07XG59O1xuXG52YXIgaW50ZXJuYWxSZWplY3QgPSBmdW5jdGlvbiAoc3RhdGUsIHZhbHVlLCB1bndyYXApIHtcbiAgaWYgKHN0YXRlLmRvbmUpIHJldHVybjtcbiAgc3RhdGUuZG9uZSA9IHRydWU7XG4gIGlmICh1bndyYXApIHN0YXRlID0gdW53cmFwO1xuICBzdGF0ZS52YWx1ZSA9IHZhbHVlO1xuICBzdGF0ZS5zdGF0ZSA9IFJFSkVDVEVEO1xuICBub3RpZnkoc3RhdGUsIHRydWUpO1xufTtcblxudmFyIGludGVybmFsUmVzb2x2ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgdmFsdWUsIHVud3JhcCkge1xuICBpZiAoc3RhdGUuZG9uZSkgcmV0dXJuO1xuICBzdGF0ZS5kb25lID0gdHJ1ZTtcbiAgaWYgKHVud3JhcCkgc3RhdGUgPSB1bndyYXA7XG4gIHRyeSB7XG4gICAgaWYgKHN0YXRlLmZhY2FkZSA9PT0gdmFsdWUpIHRocm93IFR5cGVFcnJvciQyKFwiUHJvbWlzZSBjYW4ndCBiZSByZXNvbHZlZCBpdHNlbGZcIik7XG4gICAgdmFyIHRoZW4gPSBpc1RoZW5hYmxlKHZhbHVlKTtcbiAgICBpZiAodGhlbikge1xuICAgICAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHdyYXBwZXIgPSB7IGRvbmU6IGZhbHNlIH07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2FsbCRmKHRoZW4sIHZhbHVlLFxuICAgICAgICAgICAgYmluZCQzKGludGVybmFsUmVzb2x2ZSwgd3JhcHBlciwgc3RhdGUpLFxuICAgICAgICAgICAgYmluZCQzKGludGVybmFsUmVqZWN0LCB3cmFwcGVyLCBzdGF0ZSlcbiAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGludGVybmFsUmVqZWN0KHdyYXBwZXIsIGVycm9yLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS52YWx1ZSA9IHZhbHVlO1xuICAgICAgc3RhdGUuc3RhdGUgPSBGVUxGSUxMRUQ7XG4gICAgICBub3RpZnkoc3RhdGUsIGZhbHNlKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaW50ZXJuYWxSZWplY3QoeyBkb25lOiBmYWxzZSB9LCBlcnJvciwgc3RhdGUpO1xuICB9XG59O1xuXG4vLyBjb25zdHJ1Y3RvciBwb2x5ZmlsbFxuaWYgKEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SJDQpIHtcbiAgLy8gMjUuNC4zLjEgUHJvbWlzZShleGVjdXRvcilcbiAgUHJvbWlzZUNvbnN0cnVjdG9yID0gZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcikge1xuICAgIGFuSW5zdGFuY2UkMih0aGlzLCBQcm9taXNlUHJvdG90eXBlKTtcbiAgICBhQ2FsbGFibGUkNShleGVjdXRvcik7XG4gICAgY2FsbCRmKEludGVybmFsLCB0aGlzKTtcbiAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFByb21pc2VTdGF0ZSh0aGlzKTtcbiAgICB0cnkge1xuICAgICAgZXhlY3V0b3IoYmluZCQzKGludGVybmFsUmVzb2x2ZSwgc3RhdGUpLCBiaW5kJDMoaW50ZXJuYWxSZWplY3QsIHN0YXRlKSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGludGVybmFsUmVqZWN0KHN0YXRlLCBlcnJvcik7XG4gICAgfVxuICB9O1xuXG4gIFByb21pc2VQcm90b3R5cGUgPSBQcm9taXNlQ29uc3RydWN0b3IucHJvdG90eXBlO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFycyAtLSByZXF1aXJlZCBmb3IgYC5sZW5ndGhgXG4gIEludGVybmFsID0gZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcikge1xuICAgIHNldEludGVybmFsU3RhdGUkMyh0aGlzLCB7XG4gICAgICB0eXBlOiBQUk9NSVNFLFxuICAgICAgZG9uZTogZmFsc2UsXG4gICAgICBub3RpZmllZDogZmFsc2UsXG4gICAgICBwYXJlbnQ6IGZhbHNlLFxuICAgICAgcmVhY3Rpb25zOiBuZXcgUXVldWUoKSxcbiAgICAgIHJlamVjdGlvbjogZmFsc2UsXG4gICAgICBzdGF0ZTogUEVORElORyxcbiAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICB9KTtcbiAgfTtcblxuICAvLyBgUHJvbWlzZS5wcm90b3R5cGUudGhlbmAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcHJvbWlzZS5wcm90b3R5cGUudGhlblxuICBJbnRlcm5hbC5wcm90b3R5cGUgPSBkZWZpbmVCdWlsdEluJDYoUHJvbWlzZVByb3RvdHlwZSwgJ3RoZW4nLCBmdW5jdGlvbiB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxQcm9taXNlU3RhdGUodGhpcyk7XG4gICAgdmFyIHJlYWN0aW9uID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkkMShzcGVjaWVzQ29uc3RydWN0b3IkMih0aGlzLCBQcm9taXNlQ29uc3RydWN0b3IpKTtcbiAgICBzdGF0ZS5wYXJlbnQgPSB0cnVlO1xuICAgIHJlYWN0aW9uLm9rID0gaXNDYWxsYWJsZSQ3KG9uRnVsZmlsbGVkKSA/IG9uRnVsZmlsbGVkIDogdHJ1ZTtcbiAgICByZWFjdGlvbi5mYWlsID0gaXNDYWxsYWJsZSQ3KG9uUmVqZWN0ZWQpICYmIG9uUmVqZWN0ZWQ7XG4gICAgcmVhY3Rpb24uZG9tYWluID0gSVNfTk9ERSQxID8gcHJvY2Vzcy5kb21haW4gOiB1bmRlZmluZWQ7XG4gICAgaWYgKHN0YXRlLnN0YXRlID09IFBFTkRJTkcpIHN0YXRlLnJlYWN0aW9ucy5hZGQocmVhY3Rpb24pO1xuICAgIGVsc2UgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxSZWFjdGlvbihyZWFjdGlvbiwgc3RhdGUpO1xuICAgIH0pO1xuICAgIHJldHVybiByZWFjdGlvbi5wcm9taXNlO1xuICB9KTtcblxuICBPd25Qcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBJbnRlcm5hbCgpO1xuICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsUHJvbWlzZVN0YXRlKHByb21pc2UpO1xuICAgIHRoaXMucHJvbWlzZSA9IHByb21pc2U7XG4gICAgdGhpcy5yZXNvbHZlID0gYmluZCQzKGludGVybmFsUmVzb2x2ZSwgc3RhdGUpO1xuICAgIHRoaXMucmVqZWN0ID0gYmluZCQzKGludGVybmFsUmVqZWN0LCBzdGF0ZSk7XG4gIH07XG5cbiAgbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUkMy5mID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkkMSA9IGZ1bmN0aW9uIChDKSB7XG4gICAgcmV0dXJuIEMgPT09IFByb21pc2VDb25zdHJ1Y3RvciB8fCBDID09PSBQcm9taXNlV3JhcHBlclxuICAgICAgPyBuZXcgT3duUHJvbWlzZUNhcGFiaWxpdHkoQylcbiAgICAgIDogbmV3R2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5KEMpO1xuICB9O1xuXG4gIGlmIChpc0NhbGxhYmxlJDcoTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yJDIpICYmIE5hdGl2ZVByb21pc2VQcm90b3R5cGUkMSAhPT0gT2JqZWN0LnByb3RvdHlwZSkge1xuICAgIG5hdGl2ZVRoZW4gPSBOYXRpdmVQcm9taXNlUHJvdG90eXBlJDEudGhlbjtcblxuICAgIGlmICghTkFUSVZFX1BST01JU0VfU1VCQ0xBU1NJTkcpIHtcbiAgICAgIC8vIG1ha2UgYFByb21pc2UjdGhlbmAgcmV0dXJuIGEgcG9seWZpbGxlZCBgUHJvbWlzZWAgZm9yIG5hdGl2ZSBwcm9taXNlLWJhc2VkIEFQSXNcbiAgICAgIGRlZmluZUJ1aWx0SW4kNihOYXRpdmVQcm9taXNlUHJvdG90eXBlJDEsICd0aGVuJywgZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZUNvbnN0cnVjdG9yKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBjYWxsJGYobmF0aXZlVGhlbiwgdGhhdCwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSkudGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCk7XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNjQwXG4gICAgICB9LCB7IHVuc2FmZTogdHJ1ZSB9KTtcbiAgICB9XG5cbiAgICAvLyBtYWtlIGAuY29uc3RydWN0b3IgPT09IFByb21pc2VgIHdvcmsgZm9yIG5hdGl2ZSBwcm9taXNlLWJhc2VkIEFQSXNcbiAgICB0cnkge1xuICAgICAgZGVsZXRlIE5hdGl2ZVByb21pc2VQcm90b3R5cGUkMS5jb25zdHJ1Y3RvcjtcbiAgICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG5cbiAgICAvLyBtYWtlIGBpbnN0YW5jZW9mIFByb21pc2VgIHdvcmsgZm9yIG5hdGl2ZSBwcm9taXNlLWJhc2VkIEFQSXNcbiAgICBpZiAoc2V0UHJvdG90eXBlT2YkNSkge1xuICAgICAgc2V0UHJvdG90eXBlT2YkNShOYXRpdmVQcm9taXNlUHJvdG90eXBlJDEsIFByb21pc2VQcm90b3R5cGUpO1xuICAgIH1cbiAgfVxufVxuXG4kJGUoeyBnbG9iYWw6IHRydWUsIGNvbnN0cnVjdG9yOiB0cnVlLCB3cmFwOiB0cnVlLCBmb3JjZWQ6IEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SJDQgfSwge1xuICBQcm9taXNlOiBQcm9taXNlQ29uc3RydWN0b3Jcbn0pO1xuXG5zZXRUb1N0cmluZ1RhZyQzKFByb21pc2VDb25zdHJ1Y3RvciwgUFJPTUlTRSwgZmFsc2UpO1xuc2V0U3BlY2llcyQxKFBST01JU0UpO1xuXG52YXIgaXRlcmF0b3JzID0ge307XG5cbnZhciB3ZWxsS25vd25TeW1ib2wkYiA9IHdlbGxLbm93blN5bWJvbCRqO1xudmFyIEl0ZXJhdG9ycyQ0ID0gaXRlcmF0b3JzO1xuXG52YXIgSVRFUkFUT1IkNSA9IHdlbGxLbm93blN5bWJvbCRiKCdpdGVyYXRvcicpO1xudmFyIEFycmF5UHJvdG90eXBlJDEgPSBBcnJheS5wcm90b3R5cGU7XG5cbi8vIGNoZWNrIG9uIGRlZmF1bHQgQXJyYXkgaXRlcmF0b3JcbnZhciBpc0FycmF5SXRlcmF0b3JNZXRob2QkMiA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJiAoSXRlcmF0b3JzJDQuQXJyYXkgPT09IGl0IHx8IEFycmF5UHJvdG90eXBlJDFbSVRFUkFUT1IkNV0gPT09IGl0KTtcbn07XG5cbnZhciBjbGFzc29mJDcgPSBjbGFzc29mJDk7XG52YXIgZ2V0TWV0aG9kJDIgPSBnZXRNZXRob2QkNDtcbnZhciBJdGVyYXRvcnMkMyA9IGl0ZXJhdG9ycztcbnZhciB3ZWxsS25vd25TeW1ib2wkYSA9IHdlbGxLbm93blN5bWJvbCRqO1xuXG52YXIgSVRFUkFUT1IkNCA9IHdlbGxLbm93blN5bWJvbCRhKCdpdGVyYXRvcicpO1xuXG52YXIgZ2V0SXRlcmF0b3JNZXRob2QkMyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgIT0gdW5kZWZpbmVkKSByZXR1cm4gZ2V0TWV0aG9kJDIoaXQsIElURVJBVE9SJDQpXG4gICAgfHwgZ2V0TWV0aG9kJDIoaXQsICdAQGl0ZXJhdG9yJylcbiAgICB8fCBJdGVyYXRvcnMkM1tjbGFzc29mJDcoaXQpXTtcbn07XG5cbnZhciBjYWxsJGUgPSBmdW5jdGlvbkNhbGw7XG52YXIgYUNhbGxhYmxlJDQgPSBhQ2FsbGFibGUkOTtcbnZhciBhbk9iamVjdCQ5ID0gYW5PYmplY3QkZTtcbnZhciB0cnlUb1N0cmluZyQyID0gdHJ5VG9TdHJpbmckNTtcbnZhciBnZXRJdGVyYXRvck1ldGhvZCQyID0gZ2V0SXRlcmF0b3JNZXRob2QkMztcblxudmFyICRUeXBlRXJyb3IkNSA9IFR5cGVFcnJvcjtcblxudmFyIGdldEl0ZXJhdG9yJDIgPSBmdW5jdGlvbiAoYXJndW1lbnQsIHVzaW5nSXRlcmF0b3IpIHtcbiAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBnZXRJdGVyYXRvck1ldGhvZCQyKGFyZ3VtZW50KSA6IHVzaW5nSXRlcmF0b3I7XG4gIGlmIChhQ2FsbGFibGUkNChpdGVyYXRvck1ldGhvZCkpIHJldHVybiBhbk9iamVjdCQ5KGNhbGwkZShpdGVyYXRvck1ldGhvZCwgYXJndW1lbnQpKTtcbiAgdGhyb3cgJFR5cGVFcnJvciQ1KHRyeVRvU3RyaW5nJDIoYXJndW1lbnQpICsgJyBpcyBub3QgaXRlcmFibGUnKTtcbn07XG5cbnZhciBjYWxsJGQgPSBmdW5jdGlvbkNhbGw7XG52YXIgYW5PYmplY3QkOCA9IGFuT2JqZWN0JGU7XG52YXIgZ2V0TWV0aG9kJDEgPSBnZXRNZXRob2QkNDtcblxudmFyIGl0ZXJhdG9yQ2xvc2UkMSA9IGZ1bmN0aW9uIChpdGVyYXRvciwga2luZCwgdmFsdWUpIHtcbiAgdmFyIGlubmVyUmVzdWx0LCBpbm5lckVycm9yO1xuICBhbk9iamVjdCQ4KGl0ZXJhdG9yKTtcbiAgdHJ5IHtcbiAgICBpbm5lclJlc3VsdCA9IGdldE1ldGhvZCQxKGl0ZXJhdG9yLCAncmV0dXJuJyk7XG4gICAgaWYgKCFpbm5lclJlc3VsdCkge1xuICAgICAgaWYgKGtpbmQgPT09ICd0aHJvdycpIHRocm93IHZhbHVlO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpbm5lclJlc3VsdCA9IGNhbGwkZChpbm5lclJlc3VsdCwgaXRlcmF0b3IpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlubmVyRXJyb3IgPSB0cnVlO1xuICAgIGlubmVyUmVzdWx0ID0gZXJyb3I7XG4gIH1cbiAgaWYgKGtpbmQgPT09ICd0aHJvdycpIHRocm93IHZhbHVlO1xuICBpZiAoaW5uZXJFcnJvcikgdGhyb3cgaW5uZXJSZXN1bHQ7XG4gIGFuT2JqZWN0JDgoaW5uZXJSZXN1bHQpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuXG52YXIgYmluZCQyID0gZnVuY3Rpb25CaW5kQ29udGV4dDtcbnZhciBjYWxsJGMgPSBmdW5jdGlvbkNhbGw7XG52YXIgYW5PYmplY3QkNyA9IGFuT2JqZWN0JGU7XG52YXIgdHJ5VG9TdHJpbmckMSA9IHRyeVRvU3RyaW5nJDU7XG52YXIgaXNBcnJheUl0ZXJhdG9yTWV0aG9kJDEgPSBpc0FycmF5SXRlcmF0b3JNZXRob2QkMjtcbnZhciBsZW5ndGhPZkFycmF5TGlrZSQ2ID0gbGVuZ3RoT2ZBcnJheUxpa2UkODtcbnZhciBpc1Byb3RvdHlwZU9mJDIgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xudmFyIGdldEl0ZXJhdG9yJDEgPSBnZXRJdGVyYXRvciQyO1xudmFyIGdldEl0ZXJhdG9yTWV0aG9kJDEgPSBnZXRJdGVyYXRvck1ldGhvZCQzO1xudmFyIGl0ZXJhdG9yQ2xvc2UgPSBpdGVyYXRvckNsb3NlJDE7XG5cbnZhciAkVHlwZUVycm9yJDQgPSBUeXBlRXJyb3I7XG5cbnZhciBSZXN1bHQgPSBmdW5jdGlvbiAoc3RvcHBlZCwgcmVzdWx0KSB7XG4gIHRoaXMuc3RvcHBlZCA9IHN0b3BwZWQ7XG4gIHRoaXMucmVzdWx0ID0gcmVzdWx0O1xufTtcblxudmFyIFJlc3VsdFByb3RvdHlwZSA9IFJlc3VsdC5wcm90b3R5cGU7XG5cbnZhciBpdGVyYXRlJDIgPSBmdW5jdGlvbiAoaXRlcmFibGUsIHVuYm91bmRGdW5jdGlvbiwgb3B0aW9ucykge1xuICB2YXIgdGhhdCA9IG9wdGlvbnMgJiYgb3B0aW9ucy50aGF0O1xuICB2YXIgQVNfRU5UUklFUyA9ICEhKG9wdGlvbnMgJiYgb3B0aW9ucy5BU19FTlRSSUVTKTtcbiAgdmFyIElTX0lURVJBVE9SID0gISEob3B0aW9ucyAmJiBvcHRpb25zLklTX0lURVJBVE9SKTtcbiAgdmFyIElOVEVSUlVQVEVEID0gISEob3B0aW9ucyAmJiBvcHRpb25zLklOVEVSUlVQVEVEKTtcbiAgdmFyIGZuID0gYmluZCQyKHVuYm91bmRGdW5jdGlvbiwgdGhhdCk7XG4gIHZhciBpdGVyYXRvciwgaXRlckZuLCBpbmRleCwgbGVuZ3RoLCByZXN1bHQsIG5leHQsIHN0ZXA7XG5cbiAgdmFyIHN0b3AgPSBmdW5jdGlvbiAoY29uZGl0aW9uKSB7XG4gICAgaWYgKGl0ZXJhdG9yKSBpdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCAnbm9ybWFsJywgY29uZGl0aW9uKTtcbiAgICByZXR1cm4gbmV3IFJlc3VsdCh0cnVlLCBjb25kaXRpb24pO1xuICB9O1xuXG4gIHZhciBjYWxsRm4gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAoQVNfRU5UUklFUykge1xuICAgICAgYW5PYmplY3QkNyh2YWx1ZSk7XG4gICAgICByZXR1cm4gSU5URVJSVVBURUQgPyBmbih2YWx1ZVswXSwgdmFsdWVbMV0sIHN0b3ApIDogZm4odmFsdWVbMF0sIHZhbHVlWzFdKTtcbiAgICB9IHJldHVybiBJTlRFUlJVUFRFRCA/IGZuKHZhbHVlLCBzdG9wKSA6IGZuKHZhbHVlKTtcbiAgfTtcblxuICBpZiAoSVNfSVRFUkFUT1IpIHtcbiAgICBpdGVyYXRvciA9IGl0ZXJhYmxlO1xuICB9IGVsc2Uge1xuICAgIGl0ZXJGbiA9IGdldEl0ZXJhdG9yTWV0aG9kJDEoaXRlcmFibGUpO1xuICAgIGlmICghaXRlckZuKSB0aHJvdyAkVHlwZUVycm9yJDQodHJ5VG9TdHJpbmckMShpdGVyYWJsZSkgKyAnIGlzIG5vdCBpdGVyYWJsZScpO1xuICAgIC8vIG9wdGltaXNhdGlvbiBmb3IgYXJyYXkgaXRlcmF0b3JzXG4gICAgaWYgKGlzQXJyYXlJdGVyYXRvck1ldGhvZCQxKGl0ZXJGbikpIHtcbiAgICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBsZW5ndGhPZkFycmF5TGlrZSQ2KGl0ZXJhYmxlKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICAgICAgcmVzdWx0ID0gY2FsbEZuKGl0ZXJhYmxlW2luZGV4XSk7XG4gICAgICAgIGlmIChyZXN1bHQgJiYgaXNQcm90b3R5cGVPZiQyKFJlc3VsdFByb3RvdHlwZSwgcmVzdWx0KSkgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0gcmV0dXJuIG5ldyBSZXN1bHQoZmFsc2UpO1xuICAgIH1cbiAgICBpdGVyYXRvciA9IGdldEl0ZXJhdG9yJDEoaXRlcmFibGUsIGl0ZXJGbik7XG4gIH1cblxuICBuZXh0ID0gaXRlcmF0b3IubmV4dDtcbiAgd2hpbGUgKCEoc3RlcCA9IGNhbGwkYyhuZXh0LCBpdGVyYXRvcikpLmRvbmUpIHtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gY2FsbEZuKHN0ZXAudmFsdWUpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCAndGhyb3cnLCBlcnJvcik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcmVzdWx0ID09ICdvYmplY3QnICYmIHJlc3VsdCAmJiBpc1Byb3RvdHlwZU9mJDIoUmVzdWx0UHJvdG90eXBlLCByZXN1bHQpKSByZXR1cm4gcmVzdWx0O1xuICB9IHJldHVybiBuZXcgUmVzdWx0KGZhbHNlKTtcbn07XG5cbnZhciB3ZWxsS25vd25TeW1ib2wkOSA9IHdlbGxLbm93blN5bWJvbCRqO1xuXG52YXIgSVRFUkFUT1IkMyA9IHdlbGxLbm93blN5bWJvbCQ5KCdpdGVyYXRvcicpO1xudmFyIFNBRkVfQ0xPU0lORyA9IGZhbHNlO1xuXG50cnkge1xuICB2YXIgY2FsbGVkID0gMDtcbiAgdmFyIGl0ZXJhdG9yV2l0aFJldHVybiA9IHtcbiAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4geyBkb25lOiAhIWNhbGxlZCsrIH07XG4gICAgfSxcbiAgICAncmV0dXJuJzogZnVuY3Rpb24gKCkge1xuICAgICAgU0FGRV9DTE9TSU5HID0gdHJ1ZTtcbiAgICB9XG4gIH07XG4gIGl0ZXJhdG9yV2l0aFJldHVybltJVEVSQVRPUiQzXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tYXJyYXktZnJvbSwgbm8tdGhyb3ctbGl0ZXJhbCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICBBcnJheS5mcm9tKGl0ZXJhdG9yV2l0aFJldHVybiwgZnVuY3Rpb24gKCkgeyB0aHJvdyAyOyB9KTtcbn0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cblxudmFyIGNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbiQyID0gZnVuY3Rpb24gKGV4ZWMsIFNLSVBfQ0xPU0lORykge1xuICBpZiAoIVNLSVBfQ0xPU0lORyAmJiAhU0FGRV9DTE9TSU5HKSByZXR1cm4gZmFsc2U7XG4gIHZhciBJVEVSQVRJT05fU1VQUE9SVCA9IGZhbHNlO1xuICB0cnkge1xuICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICBvYmplY3RbSVRFUkFUT1IkM10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHsgZG9uZTogSVRFUkFUSU9OX1NVUFBPUlQgPSB0cnVlIH07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcbiAgICBleGVjKG9iamVjdCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIElURVJBVElPTl9TVVBQT1JUO1xufTtcblxudmFyIE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQxID0gcHJvbWlzZU5hdGl2ZUNvbnN0cnVjdG9yO1xudmFyIGNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbiQxID0gY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uJDI7XG52YXIgRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkMyA9IHByb21pc2VDb25zdHJ1Y3RvckRldGVjdGlvbi5DT05TVFJVQ1RPUjtcblxudmFyIHByb21pc2VTdGF0aWNzSW5jb3JyZWN0SXRlcmF0aW9uID0gRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkMyB8fCAhY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uJDEoZnVuY3Rpb24gKGl0ZXJhYmxlKSB7XG4gIE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQxLmFsbChpdGVyYWJsZSkudGhlbih1bmRlZmluZWQsIGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSk7XG59KTtcblxudmFyICQkZCA9IF9leHBvcnQ7XG52YXIgY2FsbCRiID0gZnVuY3Rpb25DYWxsO1xudmFyIGFDYWxsYWJsZSQzID0gYUNhbGxhYmxlJDk7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUkMiA9IG5ld1Byb21pc2VDYXBhYmlsaXR5JDI7XG52YXIgcGVyZm9ybSQxID0gcGVyZm9ybSQzO1xudmFyIGl0ZXJhdGUkMSA9IGl0ZXJhdGUkMjtcbnZhciBQUk9NSVNFX1NUQVRJQ1NfSU5DT1JSRUNUX0lURVJBVElPTiQxID0gcHJvbWlzZVN0YXRpY3NJbmNvcnJlY3RJdGVyYXRpb247XG5cbi8vIGBQcm9taXNlLmFsbGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXByb21pc2UuYWxsXG4kJGQoeyB0YXJnZXQ6ICdQcm9taXNlJywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBQUk9NSVNFX1NUQVRJQ1NfSU5DT1JSRUNUX0lURVJBVElPTiQxIH0sIHtcbiAgYWxsOiBmdW5jdGlvbiBhbGwoaXRlcmFibGUpIHtcbiAgICB2YXIgQyA9IHRoaXM7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSQyLmYoQyk7XG4gICAgdmFyIHJlc29sdmUgPSBjYXBhYmlsaXR5LnJlc29sdmU7XG4gICAgdmFyIHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciByZXN1bHQgPSBwZXJmb3JtJDEoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICRwcm9taXNlUmVzb2x2ZSA9IGFDYWxsYWJsZSQzKEMucmVzb2x2ZSk7XG4gICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICB2YXIgY291bnRlciA9IDA7XG4gICAgICB2YXIgcmVtYWluaW5nID0gMTtcbiAgICAgIGl0ZXJhdGUkMShpdGVyYWJsZSwgZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gY291bnRlcisrO1xuICAgICAgICB2YXIgYWxyZWFkeUNhbGxlZCA9IGZhbHNlO1xuICAgICAgICByZW1haW5pbmcrKztcbiAgICAgICAgY2FsbCRiKCRwcm9taXNlUmVzb2x2ZSwgQywgcHJvbWlzZSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICBpZiAoYWxyZWFkeUNhbGxlZCkgcmV0dXJuO1xuICAgICAgICAgIGFscmVhZHlDYWxsZWQgPSB0cnVlO1xuICAgICAgICAgIHZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICB9KTtcbiAgICBpZiAocmVzdWx0LmVycm9yKSByZWplY3QocmVzdWx0LnZhbHVlKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcblxudmFyICQkYyA9IF9leHBvcnQ7XG52YXIgRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkMiA9IHByb21pc2VDb25zdHJ1Y3RvckRldGVjdGlvbi5DT05TVFJVQ1RPUjtcbnZhciBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IgPSBwcm9taXNlTmF0aXZlQ29uc3RydWN0b3I7XG52YXIgZ2V0QnVpbHRJbiQxID0gZ2V0QnVpbHRJbiQ4O1xudmFyIGlzQ2FsbGFibGUkNiA9IGlzQ2FsbGFibGUkbjtcbnZhciBkZWZpbmVCdWlsdEluJDUgPSBkZWZpbmVCdWlsdEluJDg7XG5cbnZhciBOYXRpdmVQcm9taXNlUHJvdG90eXBlID0gTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yICYmIE5hdGl2ZVByb21pc2VDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG5cbi8vIGBQcm9taXNlLnByb3RvdHlwZS5jYXRjaGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXByb21pc2UucHJvdG90eXBlLmNhdGNoXG4kJGMoeyB0YXJnZXQ6ICdQcm9taXNlJywgcHJvdG86IHRydWUsIGZvcmNlZDogRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkMiwgcmVhbDogdHJ1ZSB9LCB7XG4gICdjYXRjaCc6IGZ1bmN0aW9uIChvblJlamVjdGVkKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIG9uUmVqZWN0ZWQpO1xuICB9XG59KTtcblxuLy8gbWFrZXMgc3VyZSB0aGF0IG5hdGl2ZSBwcm9taXNlLWJhc2VkIEFQSXMgYFByb21pc2UjY2F0Y2hgIHByb3Blcmx5IHdvcmtzIHdpdGggcGF0Y2hlZCBgUHJvbWlzZSN0aGVuYFxuaWYgKGlzQ2FsbGFibGUkNihOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IpKSB7XG4gIHZhciBtZXRob2QgPSBnZXRCdWlsdEluJDEoJ1Byb21pc2UnKS5wcm90b3R5cGVbJ2NhdGNoJ107XG4gIGlmIChOYXRpdmVQcm9taXNlUHJvdG90eXBlWydjYXRjaCddICE9PSBtZXRob2QpIHtcbiAgICBkZWZpbmVCdWlsdEluJDUoTmF0aXZlUHJvbWlzZVByb3RvdHlwZSwgJ2NhdGNoJywgbWV0aG9kLCB7IHVuc2FmZTogdHJ1ZSB9KTtcbiAgfVxufVxuXG52YXIgJCRiID0gX2V4cG9ydDtcbnZhciBjYWxsJGEgPSBmdW5jdGlvbkNhbGw7XG52YXIgYUNhbGxhYmxlJDIgPSBhQ2FsbGFibGUkOTtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSQxID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkkMjtcbnZhciBwZXJmb3JtID0gcGVyZm9ybSQzO1xudmFyIGl0ZXJhdGUgPSBpdGVyYXRlJDI7XG52YXIgUFJPTUlTRV9TVEFUSUNTX0lOQ09SUkVDVF9JVEVSQVRJT04gPSBwcm9taXNlU3RhdGljc0luY29ycmVjdEl0ZXJhdGlvbjtcblxuLy8gYFByb21pc2UucmFjZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXByb21pc2UucmFjZVxuJCRiKHsgdGFyZ2V0OiAnUHJvbWlzZScsIHN0YXQ6IHRydWUsIGZvcmNlZDogUFJPTUlTRV9TVEFUSUNTX0lOQ09SUkVDVF9JVEVSQVRJT04gfSwge1xuICByYWNlOiBmdW5jdGlvbiByYWNlKGl0ZXJhYmxlKSB7XG4gICAgdmFyIEMgPSB0aGlzO1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUkMS5mKEMpO1xuICAgIHZhciByZWplY3QgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICB2YXIgcmVzdWx0ID0gcGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHByb21pc2VSZXNvbHZlID0gYUNhbGxhYmxlJDIoQy5yZXNvbHZlKTtcbiAgICAgIGl0ZXJhdGUoaXRlcmFibGUsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgIGNhbGwkYSgkcHJvbWlzZVJlc29sdmUsIEMsIHByb21pc2UpLnRoZW4oY2FwYWJpbGl0eS5yZXNvbHZlLCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYgKHJlc3VsdC5lcnJvcikgcmVqZWN0KHJlc3VsdC52YWx1ZSk7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG5cbnZhciAkJGEgPSBfZXhwb3J0O1xudmFyIGNhbGwkOSA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5JDI7XG52YXIgRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkMSA9IHByb21pc2VDb25zdHJ1Y3RvckRldGVjdGlvbi5DT05TVFJVQ1RPUjtcblxuLy8gYFByb21pc2UucmVqZWN0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcHJvbWlzZS5yZWplY3RcbiQkYSh7IHRhcmdldDogJ1Byb21pc2UnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SJDEgfSwge1xuICByZWplY3Q6IGZ1bmN0aW9uIHJlamVjdChyKSB7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZS5mKHRoaXMpO1xuICAgIGNhbGwkOShjYXBhYmlsaXR5LnJlamVjdCwgdW5kZWZpbmVkLCByKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcblxudmFyIGFuT2JqZWN0JDYgPSBhbk9iamVjdCRlO1xudmFyIGlzT2JqZWN0JDYgPSBpc09iamVjdCRkO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkkMjtcblxudmFyIHByb21pc2VSZXNvbHZlJDEgPSBmdW5jdGlvbiAoQywgeCkge1xuICBhbk9iamVjdCQ2KEMpO1xuICBpZiAoaXNPYmplY3QkNih4KSAmJiB4LmNvbnN0cnVjdG9yID09PSBDKSByZXR1cm4geDtcbiAgdmFyIHByb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkuZihDKTtcbiAgdmFyIHJlc29sdmUgPSBwcm9taXNlQ2FwYWJpbGl0eS5yZXNvbHZlO1xuICByZXNvbHZlKHgpO1xuICByZXR1cm4gcHJvbWlzZUNhcGFiaWxpdHkucHJvbWlzZTtcbn07XG5cbnZhciAkJDkgPSBfZXhwb3J0O1xudmFyIGdldEJ1aWx0SW4gPSBnZXRCdWlsdEluJDg7XG52YXIgRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IgPSBwcm9taXNlQ29uc3RydWN0b3JEZXRlY3Rpb24uQ09OU1RSVUNUT1I7XG52YXIgcHJvbWlzZVJlc29sdmUgPSBwcm9taXNlUmVzb2x2ZSQxO1xuXG5nZXRCdWlsdEluKCdQcm9taXNlJyk7XG5cbi8vIGBQcm9taXNlLnJlc29sdmVgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1wcm9taXNlLnJlc29sdmVcbiQkOSh7IHRhcmdldDogJ1Byb21pc2UnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SIH0sIHtcbiAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZSh4KSB7XG4gICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKHRoaXMsIHgpO1xuICB9XG59KTtcblxuY2xhc3MgV2ViU3RvcmFnZVNlcnZpY2Uge1xuICBnZXRJdGVtKGtleSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KTtcbiAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgIH0pO1xuICB9XG4gIHNldEl0ZW0oa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGtleSwgdmFsdWUpO1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH0pO1xuICB9XG4gIHJlbW92ZUl0ZW0oa2V5KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcbiAgICAgIHJlc29sdmUoKTtcbiAgICB9KTtcbiAgfVxufVxuXG52YXIgb2JqZWN0RGVmaW5lUHJvcGVydGllcyA9IHt9O1xuXG52YXIgaW50ZXJuYWxPYmplY3RLZXlzID0gb2JqZWN0S2V5c0ludGVybmFsO1xudmFyIGVudW1CdWdLZXlzJDEgPSBlbnVtQnVnS2V5cyQzO1xuXG4vLyBgT2JqZWN0LmtleXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3Qua2V5c1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWtleXMgLS0gc2FmZVxudmFyIG9iamVjdEtleXMkMiA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTykge1xuICByZXR1cm4gaW50ZXJuYWxPYmplY3RLZXlzKE8sIGVudW1CdWdLZXlzJDEpO1xufTtcblxudmFyIERFU0NSSVBUT1JTJDUgPSBkZXNjcmlwdG9ycztcbnZhciBWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyA9IHY4UHJvdG90eXBlRGVmaW5lQnVnO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlJDIgPSBvYmplY3REZWZpbmVQcm9wZXJ0eTtcbnZhciBhbk9iamVjdCQ1ID0gYW5PYmplY3QkZTtcbnZhciB0b0luZGV4ZWRPYmplY3QkMiA9IHRvSW5kZXhlZE9iamVjdCQ2O1xudmFyIG9iamVjdEtleXMkMSA9IG9iamVjdEtleXMkMjtcblxuLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnRpZXNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0aWVzIC0tIHNhZmVcbm9iamVjdERlZmluZVByb3BlcnRpZXMuZiA9IERFU0NSSVBUT1JTJDUgJiYgIVY4X1BST1RPVFlQRV9ERUZJTkVfQlVHID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpIHtcbiAgYW5PYmplY3QkNShPKTtcbiAgdmFyIHByb3BzID0gdG9JbmRleGVkT2JqZWN0JDIoUHJvcGVydGllcyk7XG4gIHZhciBrZXlzID0gb2JqZWN0S2V5cyQxKFByb3BlcnRpZXMpO1xuICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChsZW5ndGggPiBpbmRleCkgZGVmaW5lUHJvcGVydHlNb2R1bGUkMi5mKE8sIGtleSA9IGtleXNbaW5kZXgrK10sIHByb3BzW2tleV0pO1xuICByZXR1cm4gTztcbn07XG5cbi8qIGdsb2JhbCBBY3RpdmVYT2JqZWN0IC0tIG9sZCBJRSwgV1NIICovXG5cbnZhciBhbk9iamVjdCQ0ID0gYW5PYmplY3QkZTtcbnZhciBkZWZpbmVQcm9wZXJ0aWVzTW9kdWxlID0gb2JqZWN0RGVmaW5lUHJvcGVydGllcztcbnZhciBlbnVtQnVnS2V5cyA9IGVudW1CdWdLZXlzJDM7XG52YXIgaGlkZGVuS2V5cyA9IGhpZGRlbktleXMkNDtcbnZhciBodG1sID0gaHRtbCQyO1xudmFyIGRvY3VtZW50Q3JlYXRlRWxlbWVudCQxID0gZG9jdW1lbnRDcmVhdGVFbGVtZW50JDI7XG52YXIgc2hhcmVkS2V5JDEgPSBzaGFyZWRLZXkkMztcblxudmFyIEdUID0gJz4nO1xudmFyIExUID0gJzwnO1xudmFyIFBST1RPVFlQRSQxID0gJ3Byb3RvdHlwZSc7XG52YXIgU0NSSVBUID0gJ3NjcmlwdCc7XG52YXIgSUVfUFJPVE8kMSA9IHNoYXJlZEtleSQxKCdJRV9QUk9UTycpO1xuXG52YXIgRW1wdHlDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcblxudmFyIHNjcmlwdFRhZyA9IGZ1bmN0aW9uIChjb250ZW50KSB7XG4gIHJldHVybiBMVCArIFNDUklQVCArIEdUICsgY29udGVudCArIExUICsgJy8nICsgU0NSSVBUICsgR1Q7XG59O1xuXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgQWN0aXZlWCBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxudmFyIE51bGxQcm90b09iamVjdFZpYUFjdGl2ZVggPSBmdW5jdGlvbiAoYWN0aXZlWERvY3VtZW50KSB7XG4gIGFjdGl2ZVhEb2N1bWVudC53cml0ZShzY3JpcHRUYWcoJycpKTtcbiAgYWN0aXZlWERvY3VtZW50LmNsb3NlKCk7XG4gIHZhciB0ZW1wID0gYWN0aXZlWERvY3VtZW50LnBhcmVudFdpbmRvdy5PYmplY3Q7XG4gIGFjdGl2ZVhEb2N1bWVudCA9IG51bGw7IC8vIGF2b2lkIG1lbW9yeSBsZWFrXG4gIHJldHVybiB0ZW1wO1xufTtcblxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIGlmcmFtZSBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxudmFyIE51bGxQcm90b09iamVjdFZpYUlGcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gVGhyYXNoLCB3YXN0ZSBhbmQgc29kb215OiBJRSBHQyBidWdcbiAgdmFyIGlmcmFtZSA9IGRvY3VtZW50Q3JlYXRlRWxlbWVudCQxKCdpZnJhbWUnKTtcbiAgdmFyIEpTID0gJ2phdmEnICsgU0NSSVBUICsgJzonO1xuICB2YXIgaWZyYW1lRG9jdW1lbnQ7XG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICBodG1sLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy80NzVcbiAgaWZyYW1lLnNyYyA9IFN0cmluZyhKUyk7XG4gIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcbiAgaWZyYW1lRG9jdW1lbnQud3JpdGUoc2NyaXB0VGFnKCdkb2N1bWVudC5GPU9iamVjdCcpKTtcbiAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcbiAgcmV0dXJuIGlmcmFtZURvY3VtZW50LkY7XG59O1xuXG4vLyBDaGVjayBmb3IgZG9jdW1lbnQuZG9tYWluIGFuZCBhY3RpdmUgeCBzdXBwb3J0XG4vLyBObyBuZWVkIHRvIHVzZSBhY3RpdmUgeCBhcHByb2FjaCB3aGVuIGRvY3VtZW50LmRvbWFpbiBpcyBub3Qgc2V0XG4vLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltL2lzc3Vlcy8xNTBcbi8vIHZhcmlhdGlvbiBvZiBodHRwczovL2dpdGh1Yi5jb20va2l0Y2FtYnJpZGdlL2VzNS1zaGltL2NvbW1pdC80ZjczOGFjMDY2MzQ2XG4vLyBhdm9pZCBJRSBHQyBidWdcbnZhciBhY3RpdmVYRG9jdW1lbnQ7XG52YXIgTnVsbFByb3RvT2JqZWN0ID0gZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIGFjdGl2ZVhEb2N1bWVudCA9IG5ldyBBY3RpdmVYT2JqZWN0KCdodG1sZmlsZScpO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBpZ25vcmUgKi8gfVxuICBOdWxsUHJvdG9PYmplY3QgPSB0eXBlb2YgZG9jdW1lbnQgIT0gJ3VuZGVmaW5lZCdcbiAgICA/IGRvY3VtZW50LmRvbWFpbiAmJiBhY3RpdmVYRG9jdW1lbnRcbiAgICAgID8gTnVsbFByb3RvT2JqZWN0VmlhQWN0aXZlWChhY3RpdmVYRG9jdW1lbnQpIC8vIG9sZCBJRVxuICAgICAgOiBOdWxsUHJvdG9PYmplY3RWaWFJRnJhbWUoKVxuICAgIDogTnVsbFByb3RvT2JqZWN0VmlhQWN0aXZlWChhY3RpdmVYRG9jdW1lbnQpOyAvLyBXU0hcbiAgdmFyIGxlbmd0aCA9IGVudW1CdWdLZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSBkZWxldGUgTnVsbFByb3RvT2JqZWN0W1BST1RPVFlQRSQxXVtlbnVtQnVnS2V5c1tsZW5ndGhdXTtcbiAgcmV0dXJuIE51bGxQcm90b09iamVjdCgpO1xufTtcblxuaGlkZGVuS2V5c1tJRV9QUk9UTyQxXSA9IHRydWU7XG5cbi8vIGBPYmplY3QuY3JlYXRlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmNyZWF0ZVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWNyZWF0ZSAtLSBzYWZlXG52YXIgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoTyAhPT0gbnVsbCkge1xuICAgIEVtcHR5Q29uc3RydWN0b3JbUFJPVE9UWVBFJDFdID0gYW5PYmplY3QkNChPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHlDb25zdHJ1Y3RvcigpO1xuICAgIEVtcHR5Q29uc3RydWN0b3JbUFJPVE9UWVBFJDFdID0gbnVsbDtcbiAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXG4gICAgcmVzdWx0W0lFX1BST1RPJDFdID0gTztcbiAgfSBlbHNlIHJlc3VsdCA9IE51bGxQcm90b09iamVjdCgpO1xuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZGVmaW5lUHJvcGVydGllc01vZHVsZS5mKHJlc3VsdCwgUHJvcGVydGllcyk7XG59O1xuXG52YXIgd2VsbEtub3duU3ltYm9sJDggPSB3ZWxsS25vd25TeW1ib2wkajtcbnZhciBjcmVhdGUkMyA9IG9iamVjdENyZWF0ZTtcbnZhciBkZWZpbmVQcm9wZXJ0eSQ0ID0gb2JqZWN0RGVmaW5lUHJvcGVydHkuZjtcblxudmFyIFVOU0NPUEFCTEVTID0gd2VsbEtub3duU3ltYm9sJDgoJ3Vuc2NvcGFibGVzJyk7XG52YXIgQXJyYXlQcm90b3R5cGUgPSBBcnJheS5wcm90b3R5cGU7XG5cbi8vIEFycmF5LnByb3RvdHlwZVtAQHVuc2NvcGFibGVzXVxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUtQEB1bnNjb3BhYmxlc1xuaWYgKEFycmF5UHJvdG90eXBlW1VOU0NPUEFCTEVTXSA9PSB1bmRlZmluZWQpIHtcbiAgZGVmaW5lUHJvcGVydHkkNChBcnJheVByb3RvdHlwZSwgVU5TQ09QQUJMRVMsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgdmFsdWU6IGNyZWF0ZSQzKG51bGwpXG4gIH0pO1xufVxuXG4vLyBhZGQgYSBrZXkgdG8gQXJyYXkucHJvdG90eXBlW0BAdW5zY29wYWJsZXNdXG52YXIgYWRkVG9VbnNjb3BhYmxlcyQyID0gZnVuY3Rpb24gKGtleSkge1xuICBBcnJheVByb3RvdHlwZVtVTlNDT1BBQkxFU11ba2V5XSA9IHRydWU7XG59O1xuXG52YXIgZmFpbHMkaCA9IGZhaWxzJHM7XG5cbnZhciBjb3JyZWN0UHJvdG90eXBlR2V0dGVyID0gIWZhaWxzJGgoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGKCkgeyAvKiBlbXB0eSAqLyB9XG4gIEYucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbnVsbDtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldHByb3RvdHlwZW9mIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YobmV3IEYoKSkgIT09IEYucHJvdG90eXBlO1xufSk7XG5cbnZhciBoYXNPd24kMiA9IGhhc093blByb3BlcnR5XzE7XG52YXIgaXNDYWxsYWJsZSQ1ID0gaXNDYWxsYWJsZSRuO1xudmFyIHRvT2JqZWN0JDUgPSB0b09iamVjdCQ3O1xudmFyIHNoYXJlZEtleSA9IHNoYXJlZEtleSQzO1xudmFyIENPUlJFQ1RfUFJPVE9UWVBFX0dFVFRFUiA9IGNvcnJlY3RQcm90b3R5cGVHZXR0ZXI7XG5cbnZhciBJRV9QUk9UTyA9IHNoYXJlZEtleSgnSUVfUFJPVE8nKTtcbnZhciAkT2JqZWN0ID0gT2JqZWN0O1xudmFyIE9iamVjdFByb3RvdHlwZSQyID0gJE9iamVjdC5wcm90b3R5cGU7XG5cbi8vIGBPYmplY3QuZ2V0UHJvdG90eXBlT2ZgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0cHJvdG90eXBlb2Zcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRwcm90b3R5cGVvZiAtLSBzYWZlXG52YXIgb2JqZWN0R2V0UHJvdG90eXBlT2YgPSBDT1JSRUNUX1BST1RPVFlQRV9HRVRURVIgPyAkT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gKE8pIHtcbiAgdmFyIG9iamVjdCA9IHRvT2JqZWN0JDUoTyk7XG4gIGlmIChoYXNPd24kMihvYmplY3QsIElFX1BST1RPKSkgcmV0dXJuIG9iamVjdFtJRV9QUk9UT107XG4gIHZhciBjb25zdHJ1Y3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgaWYgKGlzQ2FsbGFibGUkNShjb25zdHJ1Y3RvcikgJiYgb2JqZWN0IGluc3RhbmNlb2YgY29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gY29uc3RydWN0b3IucHJvdG90eXBlO1xuICB9IHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiAkT2JqZWN0ID8gT2JqZWN0UHJvdG90eXBlJDIgOiBudWxsO1xufTtcblxudmFyIGZhaWxzJGcgPSBmYWlscyRzO1xudmFyIGlzQ2FsbGFibGUkNCA9IGlzQ2FsbGFibGUkbjtcbnZhciBnZXRQcm90b3R5cGVPZiQzID0gb2JqZWN0R2V0UHJvdG90eXBlT2Y7XG52YXIgZGVmaW5lQnVpbHRJbiQ0ID0gZGVmaW5lQnVpbHRJbiQ4O1xudmFyIHdlbGxLbm93blN5bWJvbCQ3ID0gd2VsbEtub3duU3ltYm9sJGo7XG5cbnZhciBJVEVSQVRPUiQyID0gd2VsbEtub3duU3ltYm9sJDcoJ2l0ZXJhdG9yJyk7XG52YXIgQlVHR1lfU0FGQVJJX0lURVJBVE9SUyQxID0gZmFsc2U7XG5cbi8vIGAlSXRlcmF0b3JQcm90b3R5cGUlYCBvYmplY3Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJWl0ZXJhdG9ycHJvdG90eXBlJS1vYmplY3RcbnZhciBJdGVyYXRvclByb3RvdHlwZSQyLCBQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUsIGFycmF5SXRlcmF0b3I7XG5cbi8qIGVzbGludC1kaXNhYmxlIGVzLXgvbm8tYXJyYXktcHJvdG90eXBlLWtleXMgLS0gc2FmZSAqL1xuaWYgKFtdLmtleXMpIHtcbiAgYXJyYXlJdGVyYXRvciA9IFtdLmtleXMoKTtcbiAgLy8gU2FmYXJpIDggaGFzIGJ1Z2d5IGl0ZXJhdG9ycyB3L28gYG5leHRgXG4gIGlmICghKCduZXh0JyBpbiBhcnJheUl0ZXJhdG9yKSkgQlVHR1lfU0FGQVJJX0lURVJBVE9SUyQxID0gdHJ1ZTtcbiAgZWxzZSB7XG4gICAgUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YkMyhnZXRQcm90b3R5cGVPZiQzKGFycmF5SXRlcmF0b3IpKTtcbiAgICBpZiAoUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlKSBJdGVyYXRvclByb3RvdHlwZSQyID0gUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG59XG5cbnZhciBORVdfSVRFUkFUT1JfUFJPVE9UWVBFID0gSXRlcmF0b3JQcm90b3R5cGUkMiA9PSB1bmRlZmluZWQgfHwgZmFpbHMkZyhmdW5jdGlvbiAoKSB7XG4gIHZhciB0ZXN0ID0ge307XG4gIC8vIEZGNDQtIGxlZ2FjeSBpdGVyYXRvcnMgY2FzZVxuICByZXR1cm4gSXRlcmF0b3JQcm90b3R5cGUkMltJVEVSQVRPUiQyXS5jYWxsKHRlc3QpICE9PSB0ZXN0O1xufSk7XG5cbmlmIChORVdfSVRFUkFUT1JfUFJPVE9UWVBFKSBJdGVyYXRvclByb3RvdHlwZSQyID0ge307XG5cbi8vIGAlSXRlcmF0b3JQcm90b3R5cGUlW0BAaXRlcmF0b3JdKClgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0laXRlcmF0b3Jwcm90b3R5cGUlLUBAaXRlcmF0b3JcbmlmICghaXNDYWxsYWJsZSQ0KEl0ZXJhdG9yUHJvdG90eXBlJDJbSVRFUkFUT1IkMl0pKSB7XG4gIGRlZmluZUJ1aWx0SW4kNChJdGVyYXRvclByb3RvdHlwZSQyLCBJVEVSQVRPUiQyLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pO1xufVxuXG52YXIgaXRlcmF0b3JzQ29yZSA9IHtcbiAgSXRlcmF0b3JQcm90b3R5cGU6IEl0ZXJhdG9yUHJvdG90eXBlJDIsXG4gIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlM6IEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMkMVxufTtcblxudmFyIEl0ZXJhdG9yUHJvdG90eXBlJDEgPSBpdGVyYXRvcnNDb3JlLkl0ZXJhdG9yUHJvdG90eXBlO1xudmFyIGNyZWF0ZSQyID0gb2JqZWN0Q3JlYXRlO1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQyID0gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDU7XG52YXIgc2V0VG9TdHJpbmdUYWckMiA9IHNldFRvU3RyaW5nVGFnJDQ7XG52YXIgSXRlcmF0b3JzJDIgPSBpdGVyYXRvcnM7XG5cbnZhciByZXR1cm5UaGlzJDEgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuXG52YXIgY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvciQxID0gZnVuY3Rpb24gKEl0ZXJhdG9yQ29uc3RydWN0b3IsIE5BTUUsIG5leHQsIEVOVU1FUkFCTEVfTkVYVCkge1xuICB2YXIgVE9fU1RSSU5HX1RBRyA9IE5BTUUgKyAnIEl0ZXJhdG9yJztcbiAgSXRlcmF0b3JDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUkMihJdGVyYXRvclByb3RvdHlwZSQxLCB7IG5leHQ6IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQyKCshRU5VTUVSQUJMRV9ORVhULCBuZXh0KSB9KTtcbiAgc2V0VG9TdHJpbmdUYWckMihJdGVyYXRvckNvbnN0cnVjdG9yLCBUT19TVFJJTkdfVEFHLCBmYWxzZSk7XG4gIEl0ZXJhdG9ycyQyW1RPX1NUUklOR19UQUddID0gcmV0dXJuVGhpcyQxO1xuICByZXR1cm4gSXRlcmF0b3JDb25zdHJ1Y3Rvcjtcbn07XG5cbnZhciAkJDggPSBfZXhwb3J0O1xudmFyIGNhbGwkOCA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBGdW5jdGlvbk5hbWUkMSA9IGZ1bmN0aW9uTmFtZTtcbnZhciBpc0NhbGxhYmxlJDMgPSBpc0NhbGxhYmxlJG47XG52YXIgY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvciA9IGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IkMTtcbnZhciBnZXRQcm90b3R5cGVPZiQyID0gb2JqZWN0R2V0UHJvdG90eXBlT2Y7XG52YXIgc2V0UHJvdG90eXBlT2YkNCA9IG9iamVjdFNldFByb3RvdHlwZU9mO1xudmFyIHNldFRvU3RyaW5nVGFnJDEgPSBzZXRUb1N0cmluZ1RhZyQ0O1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ1ID0gY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDg7XG52YXIgZGVmaW5lQnVpbHRJbiQzID0gZGVmaW5lQnVpbHRJbiQ4O1xudmFyIHdlbGxLbm93blN5bWJvbCQ2ID0gd2VsbEtub3duU3ltYm9sJGo7XG52YXIgSXRlcmF0b3JzJDEgPSBpdGVyYXRvcnM7XG52YXIgSXRlcmF0b3JzQ29yZSA9IGl0ZXJhdG9yc0NvcmU7XG5cbnZhciBQUk9QRVJfRlVOQ1RJT05fTkFNRSQyID0gRnVuY3Rpb25OYW1lJDEuUFJPUEVSO1xudmFyIENPTkZJR1VSQUJMRV9GVU5DVElPTl9OQU1FJDEgPSBGdW5jdGlvbk5hbWUkMS5DT05GSUdVUkFCTEU7XG52YXIgSXRlcmF0b3JQcm90b3R5cGUgPSBJdGVyYXRvcnNDb3JlLkl0ZXJhdG9yUHJvdG90eXBlO1xudmFyIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgPSBJdGVyYXRvcnNDb3JlLkJVR0dZX1NBRkFSSV9JVEVSQVRPUlM7XG52YXIgSVRFUkFUT1IkMSA9IHdlbGxLbm93blN5bWJvbCQ2KCdpdGVyYXRvcicpO1xudmFyIEtFWVMgPSAna2V5cyc7XG52YXIgVkFMVUVTID0gJ3ZhbHVlcyc7XG52YXIgRU5UUklFUyA9ICdlbnRyaWVzJztcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuXG52YXIgZGVmaW5lSXRlcmF0b3IkMSA9IGZ1bmN0aW9uIChJdGVyYWJsZSwgTkFNRSwgSXRlcmF0b3JDb25zdHJ1Y3RvciwgbmV4dCwgREVGQVVMVCwgSVNfU0VULCBGT1JDRUQpIHtcbiAgY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvcihJdGVyYXRvckNvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KTtcblxuICB2YXIgZ2V0SXRlcmF0aW9uTWV0aG9kID0gZnVuY3Rpb24gKEtJTkQpIHtcbiAgICBpZiAoS0lORCA9PT0gREVGQVVMVCAmJiBkZWZhdWx0SXRlcmF0b3IpIHJldHVybiBkZWZhdWx0SXRlcmF0b3I7XG4gICAgaWYgKCFCVUdHWV9TQUZBUklfSVRFUkFUT1JTICYmIEtJTkQgaW4gSXRlcmFibGVQcm90b3R5cGUpIHJldHVybiBJdGVyYWJsZVByb3RvdHlwZVtLSU5EXTtcbiAgICBzd2l0Y2ggKEtJTkQpIHtcbiAgICAgIGNhc2UgS0VZUzogcmV0dXJuIGZ1bmN0aW9uIGtleXMoKSB7IHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzLCBLSU5EKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcywgS0lORCk7IH07XG4gICAgICBjYXNlIEVOVFJJRVM6IHJldHVybiBmdW5jdGlvbiBlbnRyaWVzKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcywgS0lORCk7IH07XG4gICAgfSByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcyk7IH07XG4gIH07XG5cbiAgdmFyIFRPX1NUUklOR19UQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIHZhciBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgPSBmYWxzZTtcbiAgdmFyIEl0ZXJhYmxlUHJvdG90eXBlID0gSXRlcmFibGUucHJvdG90eXBlO1xuICB2YXIgbmF0aXZlSXRlcmF0b3IgPSBJdGVyYWJsZVByb3RvdHlwZVtJVEVSQVRPUiQxXVxuICAgIHx8IEl0ZXJhYmxlUHJvdG90eXBlWydAQGl0ZXJhdG9yJ11cbiAgICB8fCBERUZBVUxUICYmIEl0ZXJhYmxlUHJvdG90eXBlW0RFRkFVTFRdO1xuICB2YXIgZGVmYXVsdEl0ZXJhdG9yID0gIUJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgJiYgbmF0aXZlSXRlcmF0b3IgfHwgZ2V0SXRlcmF0aW9uTWV0aG9kKERFRkFVTFQpO1xuICB2YXIgYW55TmF0aXZlSXRlcmF0b3IgPSBOQU1FID09ICdBcnJheScgPyBJdGVyYWJsZVByb3RvdHlwZS5lbnRyaWVzIHx8IG5hdGl2ZUl0ZXJhdG9yIDogbmF0aXZlSXRlcmF0b3I7XG4gIHZhciBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUsIG1ldGhvZHMsIEtFWTtcblxuICAvLyBmaXggbmF0aXZlXG4gIGlmIChhbnlOYXRpdmVJdGVyYXRvcikge1xuICAgIEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mJDIoYW55TmF0aXZlSXRlcmF0b3IuY2FsbChuZXcgSXRlcmFibGUoKSkpO1xuICAgIGlmIChDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUgJiYgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLm5leHQpIHtcbiAgICAgIGlmIChnZXRQcm90b3R5cGVPZiQyKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSkgIT09IEl0ZXJhdG9yUHJvdG90eXBlKSB7XG4gICAgICAgIGlmIChzZXRQcm90b3R5cGVPZiQ0KSB7XG4gICAgICAgICAgc2V0UHJvdG90eXBlT2YkNChDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUsIEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgICAgICAgfSBlbHNlIGlmICghaXNDYWxsYWJsZSQzKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZVtJVEVSQVRPUiQxXSkpIHtcbiAgICAgICAgICBkZWZpbmVCdWlsdEluJDMoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiQxLCByZXR1cm5UaGlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9yc1xuICAgICAgc2V0VG9TdHJpbmdUYWckMShDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUsIFRPX1NUUklOR19UQUcsIHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGZpeCBBcnJheS5wcm90b3R5cGUueyB2YWx1ZXMsIEBAaXRlcmF0b3IgfS5uYW1lIGluIFY4IC8gRkZcbiAgaWYgKFBST1BFUl9GVU5DVElPTl9OQU1FJDIgJiYgREVGQVVMVCA9PSBWQUxVRVMgJiYgbmF0aXZlSXRlcmF0b3IgJiYgbmF0aXZlSXRlcmF0b3IubmFtZSAhPT0gVkFMVUVTKSB7XG4gICAgaWYgKENPTkZJR1VSQUJMRV9GVU5DVElPTl9OQU1FJDEpIHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ1KEl0ZXJhYmxlUHJvdG90eXBlLCAnbmFtZScsIFZBTFVFUyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIElOQ09SUkVDVF9WQUxVRVNfTkFNRSA9IHRydWU7XG4gICAgICBkZWZhdWx0SXRlcmF0b3IgPSBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiBjYWxsJDgobmF0aXZlSXRlcmF0b3IsIHRoaXMpOyB9O1xuICAgIH1cbiAgfVxuXG4gIC8vIGV4cG9ydCBhZGRpdGlvbmFsIG1ldGhvZHNcbiAgaWYgKERFRkFVTFQpIHtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiBnZXRJdGVyYXRpb25NZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6IElTX1NFVCA/IGRlZmF1bHRJdGVyYXRvciA6IGdldEl0ZXJhdGlvbk1ldGhvZChLRVlTKSxcbiAgICAgIGVudHJpZXM6IGdldEl0ZXJhdGlvbk1ldGhvZChFTlRSSUVTKVxuICAgIH07XG4gICAgaWYgKEZPUkNFRCkgZm9yIChLRVkgaW4gbWV0aG9kcykge1xuICAgICAgaWYgKEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgfHwgSU5DT1JSRUNUX1ZBTFVFU19OQU1FIHx8ICEoS0VZIGluIEl0ZXJhYmxlUHJvdG90eXBlKSkge1xuICAgICAgICBkZWZpbmVCdWlsdEluJDMoSXRlcmFibGVQcm90b3R5cGUsIEtFWSwgbWV0aG9kc1tLRVldKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgJCQ4KHsgdGFyZ2V0OiBOQU1FLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBCVUdHWV9TQUZBUklfSVRFUkFUT1JTIHx8IElOQ09SUkVDVF9WQUxVRVNfTkFNRSB9LCBtZXRob2RzKTtcbiAgfVxuXG4gIC8vIGRlZmluZSBpdGVyYXRvclxuICBpZiAoSXRlcmFibGVQcm90b3R5cGVbSVRFUkFUT1IkMV0gIT09IGRlZmF1bHRJdGVyYXRvcikge1xuICAgIGRlZmluZUJ1aWx0SW4kMyhJdGVyYWJsZVByb3RvdHlwZSwgSVRFUkFUT1IkMSwgZGVmYXVsdEl0ZXJhdG9yLCB7IG5hbWU6IERFRkFVTFQgfSk7XG4gIH1cbiAgSXRlcmF0b3JzJDFbTkFNRV0gPSBkZWZhdWx0SXRlcmF0b3I7XG5cbiAgcmV0dXJuIG1ldGhvZHM7XG59O1xuXG52YXIgdG9JbmRleGVkT2JqZWN0JDEgPSB0b0luZGV4ZWRPYmplY3QkNjtcbnZhciBhZGRUb1Vuc2NvcGFibGVzJDEgPSBhZGRUb1Vuc2NvcGFibGVzJDI7XG52YXIgSXRlcmF0b3JzID0gaXRlcmF0b3JzO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUkMyA9IGludGVybmFsU3RhdGU7XG52YXIgZGVmaW5lUHJvcGVydHkkMyA9IG9iamVjdERlZmluZVByb3BlcnR5LmY7XG52YXIgZGVmaW5lSXRlcmF0b3IgPSBkZWZpbmVJdGVyYXRvciQxO1xudmFyIERFU0NSSVBUT1JTJDQgPSBkZXNjcmlwdG9ycztcblxudmFyIEFSUkFZX0lURVJBVE9SID0gJ0FycmF5IEl0ZXJhdG9yJztcbnZhciBzZXRJbnRlcm5hbFN0YXRlJDIgPSBJbnRlcm5hbFN0YXRlTW9kdWxlJDMuc2V0O1xudmFyIGdldEludGVybmFsU3RhdGUkNCA9IEludGVybmFsU3RhdGVNb2R1bGUkMy5nZXR0ZXJGb3IoQVJSQVlfSVRFUkFUT1IpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmVudHJpZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZW50cmllc1xuLy8gYEFycmF5LnByb3RvdHlwZS5rZXlzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmtleXNcbi8vIGBBcnJheS5wcm90b3R5cGUudmFsdWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnZhbHVlc1xuLy8gYEFycmF5LnByb3RvdHlwZVtAQGl0ZXJhdG9yXWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQGl0ZXJhdG9yXG4vLyBgQ3JlYXRlQXJyYXlJdGVyYXRvcmAgaW50ZXJuYWwgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWNyZWF0ZWFycmF5aXRlcmF0b3JcbnZhciBlc19hcnJheV9pdGVyYXRvciA9IGRlZmluZUl0ZXJhdG9yKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbiAoaXRlcmF0ZWQsIGtpbmQpIHtcbiAgc2V0SW50ZXJuYWxTdGF0ZSQyKHRoaXMsIHtcbiAgICB0eXBlOiBBUlJBWV9JVEVSQVRPUixcbiAgICB0YXJnZXQ6IHRvSW5kZXhlZE9iamVjdCQxKGl0ZXJhdGVkKSwgLy8gdGFyZ2V0XG4gICAgaW5kZXg6IDAsICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4gICAga2luZDoga2luZCAgICAgICAgICAgICAgICAgICAgICAgICAvLyBraW5kXG4gIH0pO1xuLy8gYCVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJWFycmF5aXRlcmF0b3Jwcm90b3R5cGUlLm5leHRcbn0sIGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSQ0KHRoaXMpO1xuICB2YXIgdGFyZ2V0ID0gc3RhdGUudGFyZ2V0O1xuICB2YXIga2luZCA9IHN0YXRlLmtpbmQ7XG4gIHZhciBpbmRleCA9IHN0YXRlLmluZGV4Kys7XG4gIGlmICghdGFyZ2V0IHx8IGluZGV4ID49IHRhcmdldC5sZW5ndGgpIHtcbiAgICBzdGF0ZS50YXJnZXQgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG4gIGlmIChraW5kID09ICdrZXlzJykgcmV0dXJuIHsgdmFsdWU6IGluZGV4LCBkb25lOiBmYWxzZSB9O1xuICBpZiAoa2luZCA9PSAndmFsdWVzJykgcmV0dXJuIHsgdmFsdWU6IHRhcmdldFtpbmRleF0sIGRvbmU6IGZhbHNlIH07XG4gIHJldHVybiB7IHZhbHVlOiBbaW5kZXgsIHRhcmdldFtpbmRleF1dLCBkb25lOiBmYWxzZSB9O1xufSwgJ3ZhbHVlcycpO1xuXG4vLyBhcmd1bWVudHNMaXN0W0BAaXRlcmF0b3JdIGlzICVBcnJheVByb3RvX3ZhbHVlcyVcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtY3JlYXRldW5tYXBwZWRhcmd1bWVudHNvYmplY3Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtY3JlYXRlbWFwcGVkYXJndW1lbnRzb2JqZWN0XG52YXIgdmFsdWVzID0gSXRlcmF0b3JzLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycy5BcnJheTtcblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUtQEB1bnNjb3BhYmxlc1xuYWRkVG9VbnNjb3BhYmxlcyQxKCdrZXlzJyk7XG5hZGRUb1Vuc2NvcGFibGVzJDEoJ3ZhbHVlcycpO1xuYWRkVG9VbnNjb3BhYmxlcyQxKCdlbnRyaWVzJyk7XG5cbi8vIFY4IH4gQ2hyb21lIDQ1LSBidWdcbmlmIChERVNDUklQVE9SUyQ0ICYmIHZhbHVlcy5uYW1lICE9PSAndmFsdWVzJykgdHJ5IHtcbiAgZGVmaW5lUHJvcGVydHkkMyh2YWx1ZXMsICduYW1lJywgeyB2YWx1ZTogJ3ZhbHVlcycgfSk7XG59IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG5cbi8vIGl0ZXJhYmxlIERPTSBjb2xsZWN0aW9uc1xuLy8gZmxhZyAtIGBpdGVyYWJsZWAgaW50ZXJmYWNlIC0gJ2VudHJpZXMnLCAna2V5cycsICd2YWx1ZXMnLCAnZm9yRWFjaCcgbWV0aG9kc1xudmFyIGRvbUl0ZXJhYmxlcyA9IHtcbiAgQ1NTUnVsZUxpc3Q6IDAsXG4gIENTU1N0eWxlRGVjbGFyYXRpb246IDAsXG4gIENTU1ZhbHVlTGlzdDogMCxcbiAgQ2xpZW50UmVjdExpc3Q6IDAsXG4gIERPTVJlY3RMaXN0OiAwLFxuICBET01TdHJpbmdMaXN0OiAwLFxuICBET01Ub2tlbkxpc3Q6IDEsXG4gIERhdGFUcmFuc2Zlckl0ZW1MaXN0OiAwLFxuICBGaWxlTGlzdDogMCxcbiAgSFRNTEFsbENvbGxlY3Rpb246IDAsXG4gIEhUTUxDb2xsZWN0aW9uOiAwLFxuICBIVE1MRm9ybUVsZW1lbnQ6IDAsXG4gIEhUTUxTZWxlY3RFbGVtZW50OiAwLFxuICBNZWRpYUxpc3Q6IDAsXG4gIE1pbWVUeXBlQXJyYXk6IDAsXG4gIE5hbWVkTm9kZU1hcDogMCxcbiAgTm9kZUxpc3Q6IDEsXG4gIFBhaW50UmVxdWVzdExpc3Q6IDAsXG4gIFBsdWdpbjogMCxcbiAgUGx1Z2luQXJyYXk6IDAsXG4gIFNWR0xlbmd0aExpc3Q6IDAsXG4gIFNWR051bWJlckxpc3Q6IDAsXG4gIFNWR1BhdGhTZWdMaXN0OiAwLFxuICBTVkdQb2ludExpc3Q6IDAsXG4gIFNWR1N0cmluZ0xpc3Q6IDAsXG4gIFNWR1RyYW5zZm9ybUxpc3Q6IDAsXG4gIFNvdXJjZUJ1ZmZlckxpc3Q6IDAsXG4gIFN0eWxlU2hlZXRMaXN0OiAwLFxuICBUZXh0VHJhY2tDdWVMaXN0OiAwLFxuICBUZXh0VHJhY2tMaXN0OiAwLFxuICBUb3VjaExpc3Q6IDBcbn07XG5cbi8vIGluIG9sZCBXZWJLaXQgdmVyc2lvbnMsIGBlbGVtZW50LmNsYXNzTGlzdGAgaXMgbm90IGFuIGluc3RhbmNlIG9mIGdsb2JhbCBgRE9NVG9rZW5MaXN0YFxudmFyIGRvY3VtZW50Q3JlYXRlRWxlbWVudCA9IGRvY3VtZW50Q3JlYXRlRWxlbWVudCQyO1xuXG52YXIgY2xhc3NMaXN0ID0gZG9jdW1lbnRDcmVhdGVFbGVtZW50KCdzcGFuJykuY2xhc3NMaXN0O1xudmFyIERPTVRva2VuTGlzdFByb3RvdHlwZSQxID0gY2xhc3NMaXN0ICYmIGNsYXNzTGlzdC5jb25zdHJ1Y3RvciAmJiBjbGFzc0xpc3QuY29uc3RydWN0b3IucHJvdG90eXBlO1xuXG52YXIgZG9tVG9rZW5MaXN0UHJvdG90eXBlID0gRE9NVG9rZW5MaXN0UHJvdG90eXBlJDEgPT09IE9iamVjdC5wcm90b3R5cGUgPyB1bmRlZmluZWQgOiBET01Ub2tlbkxpc3RQcm90b3R5cGUkMTtcblxudmFyIGdsb2JhbCRiID0gZ2xvYmFsJHQ7XG52YXIgRE9NSXRlcmFibGVzID0gZG9tSXRlcmFibGVzO1xudmFyIERPTVRva2VuTGlzdFByb3RvdHlwZSA9IGRvbVRva2VuTGlzdFByb3RvdHlwZTtcbnZhciBBcnJheUl0ZXJhdG9yTWV0aG9kcyA9IGVzX2FycmF5X2l0ZXJhdG9yO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ0ID0gY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDg7XG52YXIgd2VsbEtub3duU3ltYm9sJDUgPSB3ZWxsS25vd25TeW1ib2wkajtcblxudmFyIElURVJBVE9SID0gd2VsbEtub3duU3ltYm9sJDUoJ2l0ZXJhdG9yJyk7XG52YXIgVE9fU1RSSU5HX1RBRyQxID0gd2VsbEtub3duU3ltYm9sJDUoJ3RvU3RyaW5nVGFnJyk7XG52YXIgQXJyYXlWYWx1ZXMgPSBBcnJheUl0ZXJhdG9yTWV0aG9kcy52YWx1ZXM7XG5cbnZhciBoYW5kbGVQcm90b3R5cGUgPSBmdW5jdGlvbiAoQ29sbGVjdGlvblByb3RvdHlwZSwgQ09MTEVDVElPTl9OQU1FKSB7XG4gIGlmIChDb2xsZWN0aW9uUHJvdG90eXBlKSB7XG4gICAgLy8gc29tZSBDaHJvbWUgdmVyc2lvbnMgaGF2ZSBub24tY29uZmlndXJhYmxlIG1ldGhvZHMgb24gRE9NVG9rZW5MaXN0XG4gICAgaWYgKENvbGxlY3Rpb25Qcm90b3R5cGVbSVRFUkFUT1JdICE9PSBBcnJheVZhbHVlcykgdHJ5IHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ0KENvbGxlY3Rpb25Qcm90b3R5cGUsIElURVJBVE9SLCBBcnJheVZhbHVlcyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIENvbGxlY3Rpb25Qcm90b3R5cGVbSVRFUkFUT1JdID0gQXJyYXlWYWx1ZXM7XG4gICAgfVxuICAgIGlmICghQ29sbGVjdGlvblByb3RvdHlwZVtUT19TVFJJTkdfVEFHJDFdKSB7XG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNChDb2xsZWN0aW9uUHJvdG90eXBlLCBUT19TVFJJTkdfVEFHJDEsIENPTExFQ1RJT05fTkFNRSk7XG4gICAgfVxuICAgIGlmIChET01JdGVyYWJsZXNbQ09MTEVDVElPTl9OQU1FXSkgZm9yICh2YXIgTUVUSE9EX05BTUUgaW4gQXJyYXlJdGVyYXRvck1ldGhvZHMpIHtcbiAgICAgIC8vIHNvbWUgQ2hyb21lIHZlcnNpb25zIGhhdmUgbm9uLWNvbmZpZ3VyYWJsZSBtZXRob2RzIG9uIERPTVRva2VuTGlzdFxuICAgICAgaWYgKENvbGxlY3Rpb25Qcm90b3R5cGVbTUVUSE9EX05BTUVdICE9PSBBcnJheUl0ZXJhdG9yTWV0aG9kc1tNRVRIT0RfTkFNRV0pIHRyeSB7XG4gICAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ0KENvbGxlY3Rpb25Qcm90b3R5cGUsIE1FVEhPRF9OQU1FLCBBcnJheUl0ZXJhdG9yTWV0aG9kc1tNRVRIT0RfTkFNRV0pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgQ29sbGVjdGlvblByb3RvdHlwZVtNRVRIT0RfTkFNRV0gPSBBcnJheUl0ZXJhdG9yTWV0aG9kc1tNRVRIT0RfTkFNRV07XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mb3IgKHZhciBDT0xMRUNUSU9OX05BTUUgaW4gRE9NSXRlcmFibGVzKSB7XG4gIGhhbmRsZVByb3RvdHlwZShnbG9iYWwkYltDT0xMRUNUSU9OX05BTUVdICYmIGdsb2JhbCRiW0NPTExFQ1RJT05fTkFNRV0ucHJvdG90eXBlLCBDT0xMRUNUSU9OX05BTUUpO1xufVxuXG5oYW5kbGVQcm90b3R5cGUoRE9NVG9rZW5MaXN0UHJvdG90eXBlLCAnRE9NVG9rZW5MaXN0Jyk7XG5cbmNsYXNzIExvZ2dlciB7XG4gIGNvbnN0cnVjdG9yKG5hbWVzcGFjZSkge1xuICAgIHRoaXMubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuICB9XG4gIGVtaXQobWV0aG9kLCAuLi5wYXJhbXMpIHtcbiAgICBpZiAoIUxvZ2dlci5kZWJ1Zykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5uYW1lc3BhY2UgJiYgbWV0aG9kICE9PSBcImVycm9yXCIpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlW21ldGhvZF0odGhpcy5uYW1lc3BhY2UsIC4uLnBhcmFtcyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgY29uc29sZVttZXRob2RdKC4uLnBhcmFtcyk7XG4gIH1cbiAgbG9nKC4uLnBhcmFtcykge1xuICAgIHRoaXMuZW1pdChcImxvZ1wiLCAuLi5wYXJhbXMpO1xuICB9XG4gIGluZm8oLi4ucGFyYW1zKSB7XG4gICAgdGhpcy5lbWl0KFwiaW5mb1wiLCAuLi5wYXJhbXMpO1xuICB9XG4gIHdhcm4oLi4ucGFyYW1zKSB7XG4gICAgdGhpcy5lbWl0KFwid2FyblwiLCAuLi5wYXJhbXMpO1xuICB9XG4gIGVycm9yKC4uLnBhcmFtcykge1xuICAgIHRoaXMuZW1pdChcImVycm9yXCIsIC4uLnBhcmFtcyk7XG4gIH1cbn1cbkxvZ2dlci5kZWJ1ZyA9IGZhbHNlO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcigpO1xuXG52YXIgJCQ3ID0gX2V4cG9ydDtcbnZhciAkaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzLmluY2x1ZGVzO1xudmFyIGZhaWxzJGYgPSBmYWlscyRzO1xudmFyIGFkZFRvVW5zY29wYWJsZXMgPSBhZGRUb1Vuc2NvcGFibGVzJDI7XG5cbi8vIEZGOTkrIGJ1Z1xudmFyIEJST0tFTl9PTl9TUEFSU0UgPSBmYWlscyRmKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICFBcnJheSgxKS5pbmNsdWRlcygpO1xufSk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuaW5jbHVkZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuaW5jbHVkZXNcbiQkNyh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogQlJPS0VOX09OX1NQQVJTRSB9LCB7XG4gIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhlbCAvKiAsIGZyb21JbmRleCA9IDAgKi8pIHtcbiAgICByZXR1cm4gJGluY2x1ZGVzKHRoaXMsIGVsLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQHVuc2NvcGFibGVzXG5hZGRUb1Vuc2NvcGFibGVzKCdpbmNsdWRlcycpO1xuXG52YXIgaXNPYmplY3QkNSA9IGlzT2JqZWN0JGQ7XG52YXIgY2xhc3NvZiQ2ID0gY2xhc3NvZlJhdyQxO1xudmFyIHdlbGxLbm93blN5bWJvbCQ0ID0gd2VsbEtub3duU3ltYm9sJGo7XG5cbnZhciBNQVRDSCQxID0gd2VsbEtub3duU3ltYm9sJDQoJ21hdGNoJyk7XG5cbi8vIGBJc1JlZ0V4cGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWlzcmVnZXhwXG52YXIgaXNSZWdleHAgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIGlzUmVnRXhwO1xuICByZXR1cm4gaXNPYmplY3QkNShpdCkgJiYgKChpc1JlZ0V4cCA9IGl0W01BVENIJDFdKSAhPT0gdW5kZWZpbmVkID8gISFpc1JlZ0V4cCA6IGNsYXNzb2YkNihpdCkgPT0gJ1JlZ0V4cCcpO1xufTtcblxudmFyIGlzUmVnRXhwJDEgPSBpc1JlZ2V4cDtcblxudmFyICRUeXBlRXJyb3IkMyA9IFR5cGVFcnJvcjtcblxudmFyIG5vdEFSZWdleHAgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGlzUmVnRXhwJDEoaXQpKSB7XG4gICAgdGhyb3cgJFR5cGVFcnJvciQzKFwiVGhlIG1ldGhvZCBkb2Vzbid0IGFjY2VwdCByZWd1bGFyIGV4cHJlc3Npb25zXCIpO1xuICB9IHJldHVybiBpdDtcbn07XG5cbnZhciBjbGFzc29mJDUgPSBjbGFzc29mJDk7XG5cbnZhciAkU3RyaW5nID0gU3RyaW5nO1xuXG52YXIgdG9TdHJpbmckNSA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAoY2xhc3NvZiQ1KGFyZ3VtZW50KSA9PT0gJ1N5bWJvbCcpIHRocm93IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgYSBTeW1ib2wgdmFsdWUgdG8gYSBzdHJpbmcnKTtcbiAgcmV0dXJuICRTdHJpbmcoYXJndW1lbnQpO1xufTtcblxudmFyIHdlbGxLbm93blN5bWJvbCQzID0gd2VsbEtub3duU3ltYm9sJGo7XG5cbnZhciBNQVRDSCA9IHdlbGxLbm93blN5bWJvbCQzKCdtYXRjaCcpO1xuXG52YXIgY29ycmVjdElzUmVnZXhwTG9naWMgPSBmdW5jdGlvbiAoTUVUSE9EX05BTUUpIHtcbiAgdmFyIHJlZ2V4cCA9IC8uLztcbiAgdHJ5IHtcbiAgICAnLy4vJ1tNRVRIT0RfTkFNRV0ocmVnZXhwKTtcbiAgfSBjYXRjaCAoZXJyb3IxKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJlZ2V4cFtNQVRDSF0gPSBmYWxzZTtcbiAgICAgIHJldHVybiAnLy4vJ1tNRVRIT0RfTkFNRV0ocmVnZXhwKTtcbiAgICB9IGNhdGNoIChlcnJvcjIpIHsgLyogZW1wdHkgKi8gfVxuICB9IHJldHVybiBmYWxzZTtcbn07XG5cbnZhciAkJDYgPSBfZXhwb3J0O1xudmFyIHVuY3VycnlUaGlzJGIgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIG5vdEFSZWdFeHAgPSBub3RBUmVnZXhwO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUkMyA9IHJlcXVpcmVPYmplY3RDb2VyY2libGUkNjtcbnZhciB0b1N0cmluZyQ0ID0gdG9TdHJpbmckNTtcbnZhciBjb3JyZWN0SXNSZWdFeHBMb2dpYyA9IGNvcnJlY3RJc1JlZ2V4cExvZ2ljO1xuXG52YXIgc3RyaW5nSW5kZXhPZiA9IHVuY3VycnlUaGlzJGIoJycuaW5kZXhPZik7XG5cbi8vIGBTdHJpbmcucHJvdG90eXBlLmluY2x1ZGVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5pbmNsdWRlc1xuJCQ2KHsgdGFyZ2V0OiAnU3RyaW5nJywgcHJvdG86IHRydWUsIGZvcmNlZDogIWNvcnJlY3RJc1JlZ0V4cExvZ2ljKCdpbmNsdWRlcycpIH0sIHtcbiAgaW5jbHVkZXM6IGZ1bmN0aW9uIGluY2x1ZGVzKHNlYXJjaFN0cmluZyAvKiAsIHBvc2l0aW9uID0gMCAqLykge1xuICAgIHJldHVybiAhIX5zdHJpbmdJbmRleE9mKFxuICAgICAgdG9TdHJpbmckNChyZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDModGhpcykpLFxuICAgICAgdG9TdHJpbmckNChub3RBUmVnRXhwKHNlYXJjaFN0cmluZykpLFxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWRcbiAgICApO1xuICB9XG59KTtcblxuLy8gYSBzdHJpbmcgb2YgYWxsIHZhbGlkIHVuaWNvZGUgd2hpdGVzcGFjZXNcbnZhciB3aGl0ZXNwYWNlcyQyID0gJ1xcdTAwMDlcXHUwMDBBXFx1MDAwQlxcdTAwMENcXHUwMDBEXFx1MDAyMFxcdTAwQTBcXHUxNjgwXFx1MjAwMFxcdTIwMDFcXHUyMDAyJyArXG4gICdcXHUyMDAzXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MzAwMFxcdTIwMjhcXHUyMDI5XFx1RkVGRic7XG5cbnZhciB1bmN1cnJ5VGhpcyRhID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDIgPSByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDY7XG52YXIgdG9TdHJpbmckMyA9IHRvU3RyaW5nJDU7XG52YXIgd2hpdGVzcGFjZXMkMSA9IHdoaXRlc3BhY2VzJDI7XG5cbnZhciByZXBsYWNlJDEgPSB1bmN1cnJ5VGhpcyRhKCcnLnJlcGxhY2UpO1xudmFyIHdoaXRlc3BhY2UgPSAnWycgKyB3aGl0ZXNwYWNlcyQxICsgJ10nO1xudmFyIGx0cmltID0gUmVnRXhwKCdeJyArIHdoaXRlc3BhY2UgKyB3aGl0ZXNwYWNlICsgJyonKTtcbnZhciBydHJpbSA9IFJlZ0V4cCh3aGl0ZXNwYWNlICsgd2hpdGVzcGFjZSArICcqJCcpO1xuXG4vLyBgU3RyaW5nLnByb3RvdHlwZS57IHRyaW0sIHRyaW1TdGFydCwgdHJpbUVuZCwgdHJpbUxlZnQsIHRyaW1SaWdodCB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG52YXIgY3JlYXRlTWV0aG9kJDMgPSBmdW5jdGlvbiAoVFlQRSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzKSB7XG4gICAgdmFyIHN0cmluZyA9IHRvU3RyaW5nJDMocmVxdWlyZU9iamVjdENvZXJjaWJsZSQyKCR0aGlzKSk7XG4gICAgaWYgKFRZUEUgJiAxKSBzdHJpbmcgPSByZXBsYWNlJDEoc3RyaW5nLCBsdHJpbSwgJycpO1xuICAgIGlmIChUWVBFICYgMikgc3RyaW5nID0gcmVwbGFjZSQxKHN0cmluZywgcnRyaW0sICcnKTtcbiAgICByZXR1cm4gc3RyaW5nO1xuICB9O1xufTtcblxudmFyIHN0cmluZ1RyaW0gPSB7XG4gIC8vIGBTdHJpbmcucHJvdG90eXBlLnsgdHJpbUxlZnQsIHRyaW1TdGFydCB9YCBtZXRob2RzXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS50cmltc3RhcnRcbiAgc3RhcnQ6IGNyZWF0ZU1ldGhvZCQzKDEpLFxuICAvLyBgU3RyaW5nLnByb3RvdHlwZS57IHRyaW1SaWdodCwgdHJpbUVuZCB9YCBtZXRob2RzXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS50cmltZW5kXG4gIGVuZDogY3JlYXRlTWV0aG9kJDMoMiksXG4gIC8vIGBTdHJpbmcucHJvdG90eXBlLnRyaW1gIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUudHJpbVxuICB0cmltOiBjcmVhdGVNZXRob2QkMygzKVxufTtcblxudmFyIFBST1BFUl9GVU5DVElPTl9OQU1FJDEgPSBmdW5jdGlvbk5hbWUuUFJPUEVSO1xudmFyIGZhaWxzJGUgPSBmYWlscyRzO1xudmFyIHdoaXRlc3BhY2VzID0gd2hpdGVzcGFjZXMkMjtcblxudmFyIG5vbiA9ICdcXHUyMDBCXFx1MDA4NVxcdTE4MEUnO1xuXG4vLyBjaGVjayB0aGF0IGEgbWV0aG9kIHdvcmtzIHdpdGggdGhlIGNvcnJlY3QgbGlzdFxuLy8gb2Ygd2hpdGVzcGFjZXMgYW5kIGhhcyBhIGNvcnJlY3QgbmFtZVxudmFyIHN0cmluZ1RyaW1Gb3JjZWQgPSBmdW5jdGlvbiAoTUVUSE9EX05BTUUpIHtcbiAgcmV0dXJuIGZhaWxzJGUoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhIXdoaXRlc3BhY2VzW01FVEhPRF9OQU1FXSgpXG4gICAgICB8fCBub25bTUVUSE9EX05BTUVdKCkgIT09IG5vblxuICAgICAgfHwgKFBST1BFUl9GVU5DVElPTl9OQU1FJDEgJiYgd2hpdGVzcGFjZXNbTUVUSE9EX05BTUVdLm5hbWUgIT09IE1FVEhPRF9OQU1FKTtcbiAgfSk7XG59O1xuXG52YXIgJCQ1ID0gX2V4cG9ydDtcbnZhciAkdHJpbSA9IHN0cmluZ1RyaW0udHJpbTtcbnZhciBmb3JjZWRTdHJpbmdUcmltTWV0aG9kID0gc3RyaW5nVHJpbUZvcmNlZDtcblxuLy8gYFN0cmluZy5wcm90b3R5cGUudHJpbWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUudHJpbVxuJCQ1KHsgdGFyZ2V0OiAnU3RyaW5nJywgcHJvdG86IHRydWUsIGZvcmNlZDogZm9yY2VkU3RyaW5nVHJpbU1ldGhvZCgndHJpbScpIH0sIHtcbiAgdHJpbTogZnVuY3Rpb24gdHJpbSgpIHtcbiAgICByZXR1cm4gJHRyaW0odGhpcyk7XG4gIH1cbn0pO1xuXG52YXIgREVTQ1JJUFRPUlMkMyA9IGRlc2NyaXB0b3JzO1xudmFyIHVuY3VycnlUaGlzJDkgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGNhbGwkNyA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBmYWlscyRkID0gZmFpbHMkcztcbnZhciBvYmplY3RLZXlzID0gb2JqZWN0S2V5cyQyO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSA9IG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSA9IG9iamVjdFByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIHRvT2JqZWN0JDQgPSB0b09iamVjdCQ3O1xudmFyIEluZGV4ZWRPYmplY3QkMiA9IGluZGV4ZWRPYmplY3Q7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1hc3NpZ24gLS0gc2FmZVxudmFyICRhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG52YXIgZGVmaW5lUHJvcGVydHkkMiA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBjb25jYXQgPSB1bmN1cnJ5VGhpcyQ5KFtdLmNvbmNhdCk7XG5cbi8vIGBPYmplY3QuYXNzaWduYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmFzc2lnblxudmFyIG9iamVjdEFzc2lnbiA9ICEkYXNzaWduIHx8IGZhaWxzJGQoZnVuY3Rpb24gKCkge1xuICAvLyBzaG91bGQgaGF2ZSBjb3JyZWN0IG9yZGVyIG9mIG9wZXJhdGlvbnMgKEVkZ2UgYnVnKVxuICBpZiAoREVTQ1JJUFRPUlMkMyAmJiAkYXNzaWduKHsgYjogMSB9LCAkYXNzaWduKGRlZmluZVByb3BlcnR5JDIoe30sICdhJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICBkZWZpbmVQcm9wZXJ0eSQyKHRoaXMsICdiJywge1xuICAgICAgICB2YWx1ZTogMyxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfSksIHsgYjogMiB9KSkuYiAhPT0gMSkgcmV0dXJuIHRydWU7XG4gIC8vIHNob3VsZCB3b3JrIHdpdGggc3ltYm9scyBhbmQgc2hvdWxkIGhhdmUgZGV0ZXJtaW5pc3RpYyBwcm9wZXJ0eSBvcmRlciAoVjggYnVnKVxuICB2YXIgQSA9IHt9O1xuICB2YXIgQiA9IHt9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1zeW1ib2wgLS0gc2FmZVxuICB2YXIgc3ltYm9sID0gU3ltYm9sKCk7XG4gIHZhciBhbHBoYWJldCA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdCc7XG4gIEFbc3ltYm9sXSA9IDc7XG4gIGFscGhhYmV0LnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChjaHIpIHsgQltjaHJdID0gY2hyOyB9KTtcbiAgcmV0dXJuICRhc3NpZ24oe30sIEEpW3N5bWJvbF0gIT0gNyB8fCBvYmplY3RLZXlzKCRhc3NpZ24oe30sIEIpKS5qb2luKCcnKSAhPSBhbHBoYWJldDtcbn0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnMgLS0gcmVxdWlyZWQgZm9yIGAubGVuZ3RoYFxuICB2YXIgVCA9IHRvT2JqZWN0JDQodGFyZ2V0KTtcbiAgdmFyIGFyZ3VtZW50c0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBpbmRleCA9IDE7XG4gIHZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUuZjtcbiAgdmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUuZjtcbiAgd2hpbGUgKGFyZ3VtZW50c0xlbmd0aCA+IGluZGV4KSB7XG4gICAgdmFyIFMgPSBJbmRleGVkT2JqZWN0JDIoYXJndW1lbnRzW2luZGV4KytdKTtcbiAgICB2YXIga2V5cyA9IGdldE93blByb3BlcnR5U3ltYm9scyA/IGNvbmNhdChvYmplY3RLZXlzKFMpLCBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoUykpIDogb2JqZWN0S2V5cyhTKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIGogPSAwO1xuICAgIHZhciBrZXk7XG4gICAgd2hpbGUgKGxlbmd0aCA+IGopIHtcbiAgICAgIGtleSA9IGtleXNbaisrXTtcbiAgICAgIGlmICghREVTQ1JJUFRPUlMkMyB8fCBjYWxsJDcocHJvcGVydHlJc0VudW1lcmFibGUsIFMsIGtleSkpIFRba2V5XSA9IFNba2V5XTtcbiAgICB9XG4gIH0gcmV0dXJuIFQ7XG59IDogJGFzc2lnbjtcblxudmFyICQkNCA9IF9leHBvcnQ7XG52YXIgYXNzaWduID0gb2JqZWN0QXNzaWduO1xuXG4vLyBgT2JqZWN0LmFzc2lnbmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5hc3NpZ25cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1hc3NpZ24gLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiQkNCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIGFyaXR5OiAyLCBmb3JjZWQ6IE9iamVjdC5hc3NpZ24gIT09IGFzc2lnbiB9LCB7XG4gIGFzc2lnbjogYXNzaWduXG59KTtcblxuY2xhc3MgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5lbWl0dGVyID0gbmV3IGV2ZW50cy5FdmVudEVtaXR0ZXIoKTtcbiAgfVxuICBvbihldmVudE5hbWUsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5lbWl0dGVyLm9uKGV2ZW50TmFtZSwgY2FsbGJhY2spO1xuICAgIHJldHVybiB7XG4gICAgICByZW1vdmU6ICgpID0+IHRoaXMuZW1pdHRlci5vZmYoZXZlbnROYW1lLCBjYWxsYmFjaylcbiAgICB9O1xuICB9XG4gIG9mZihldmVudE5hbWUsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5lbWl0dGVyLm9mZihldmVudE5hbWUsIGNhbGxiYWNrKTtcbiAgfVxuICBlbWl0KGV2ZW50TmFtZSwgZXZlbnQpIHtcbiAgICB0aGlzLmVtaXR0ZXIuZW1pdChldmVudE5hbWUsIGV2ZW50KTtcbiAgfVxufVxuXG5jb25zdCBQQUNLQUdFX05BTUUgPSBcIm5lYXItd2FsbGV0LXNlbGVjdG9yXCI7XG5jb25zdCBSRUNFTlRMWV9TSUdORURfSU5fV0FMTEVUUyA9IFwicmVjZW50bHlTaWduZWRJbldhbGxldHNcIjtcbmNvbnN0IENPTlRSQUNUID0gXCJjb250cmFjdFwiO1xuY29uc3QgUEVORElOR19DT05UUkFDVCA9IFwiY29udHJhY3Q6cGVuZGluZ1wiO1xuY29uc3QgU0VMRUNURURfV0FMTEVUX0lEID0gYHNlbGVjdGVkV2FsbGV0SWRgO1xuY29uc3QgUEVORElOR19TRUxFQ1RFRF9XQUxMRVRfSUQgPSBgc2VsZWN0ZWRXYWxsZXRJZDpwZW5kaW5nYDtcblxuY2xhc3MgV2FsbGV0TW9kdWxlcyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBmYWN0b3JpZXMsXG4gICAgc3RvcmFnZSxcbiAgICBvcHRpb25zLFxuICAgIHN0b3JlLFxuICAgIGVtaXR0ZXIsXG4gICAgcHJvdmlkZXJcbiAgfSkge1xuICAgIHRoaXMuZmFjdG9yaWVzID0gZmFjdG9yaWVzO1xuICAgIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnN0b3JlID0gc3RvcmU7XG4gICAgdGhpcy5lbWl0dGVyID0gZW1pdHRlcjtcbiAgICB0aGlzLnByb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgdGhpcy5tb2R1bGVzID0gW107XG4gICAgdGhpcy5pbnN0YW5jZXMgPSB7fTtcbiAgfVxuICB2YWxpZGF0ZVdhbGxldChpZCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBsZXQgYWNjb3VudHMgPSBbXTtcbiAgICAgIGNvbnN0IHdhbGxldCA9IHlpZWxkIHRoaXMuZ2V0V2FsbGV0KGlkKTtcbiAgICAgIGlmICh3YWxsZXQpIHtcbiAgICAgICAgLy8gRW5zdXJlIG91ciBwZXJzaXN0ZW50IHN0YXRlIGFsaWducyB3aXRoIHRoZSBzZWxlY3RlZCB3YWxsZXQuXG4gICAgICAgIC8vIEZvciBleGFtcGxlIGEgd2FsbGV0IGlzIHNlbGVjdGVkLCBidXQgaXQgcmV0dXJucyBubyBhY2NvdW50cyAobm90IHNpZ25lZCBpbikuXG4gICAgICAgIGFjY291bnRzID0geWllbGQgd2FsbGV0LmdldEFjY291bnRzKCkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICBsb2dnZXIubG9nKGBGYWlsZWQgdG8gdmFsaWRhdGUgJHt3YWxsZXQuaWR9IGR1cmluZyBzZXR1cGApO1xuICAgICAgICAgIGxvZ2dlci5lcnJvcihlcnIpO1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjb3VudHM7XG4gICAgfSk7XG4gIH1cbiAgcmVzb2x2ZVN0b3JhZ2VTdGF0ZSgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QganNvblN0b3JhZ2UgPSBuZXcgSnNvblN0b3JhZ2UodGhpcy5zdG9yYWdlLCBQQUNLQUdFX05BTUUpO1xuICAgICAgY29uc3QgcGVuZGluZ1NlbGVjdGVkV2FsbGV0SWQgPSB5aWVsZCBqc29uU3RvcmFnZS5nZXRJdGVtKFBFTkRJTkdfU0VMRUNURURfV0FMTEVUX0lEKTtcbiAgICAgIGNvbnN0IHBlbmRpbmdDb250cmFjdCA9IHlpZWxkIGpzb25TdG9yYWdlLmdldEl0ZW0oUEVORElOR19DT05UUkFDVCk7XG4gICAgICBpZiAocGVuZGluZ1NlbGVjdGVkV2FsbGV0SWQgJiYgcGVuZGluZ0NvbnRyYWN0KSB7XG4gICAgICAgIGNvbnN0IF9hY2NvdW50cyA9IHlpZWxkIHRoaXMudmFsaWRhdGVXYWxsZXQocGVuZGluZ1NlbGVjdGVkV2FsbGV0SWQpO1xuICAgICAgICB5aWVsZCBqc29uU3RvcmFnZS5yZW1vdmVJdGVtKFBFTkRJTkdfU0VMRUNURURfV0FMTEVUX0lEKTtcbiAgICAgICAgeWllbGQganNvblN0b3JhZ2UucmVtb3ZlSXRlbShQRU5ESU5HX0NPTlRSQUNUKTtcbiAgICAgICAgaWYgKF9hY2NvdW50cy5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBzZWxlY3RlZFdhbGxldElkOiBfc2VsZWN0ZWRXYWxsZXRJZFxuICAgICAgICAgIH0gPSB0aGlzLnN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgY29uc3Qgc2VsZWN0ZWRXYWxsZXQgPSB5aWVsZCB0aGlzLmdldFdhbGxldChfc2VsZWN0ZWRXYWxsZXRJZCk7XG4gICAgICAgICAgaWYgKHNlbGVjdGVkV2FsbGV0ICYmIHBlbmRpbmdTZWxlY3RlZFdhbGxldElkICE9PSBfc2VsZWN0ZWRXYWxsZXRJZCkge1xuICAgICAgICAgICAgeWllbGQgc2VsZWN0ZWRXYWxsZXQuc2lnbk91dCgpLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICAgIGxvZ2dlci5sb2coXCJGYWlsZWQgdG8gc2lnbiBvdXQgZXhpc3Rpbmcgd2FsbGV0XCIpO1xuICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCByZWNlbnRseVNpZ25lZEluV2FsbGV0c0Zyb21QZW5kaW5nID0geWllbGQgdGhpcy5zZXRXYWxsZXRBc1JlY2VudGx5U2lnbmVkSW4ocGVuZGluZ1NlbGVjdGVkV2FsbGV0SWQpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhY2NvdW50czogX2FjY291bnRzLFxuICAgICAgICAgICAgY29udHJhY3Q6IHBlbmRpbmdDb250cmFjdCxcbiAgICAgICAgICAgIHNlbGVjdGVkV2FsbGV0SWQ6IHBlbmRpbmdTZWxlY3RlZFdhbGxldElkLFxuICAgICAgICAgICAgcmVjZW50bHlTaWduZWRJbldhbGxldHM6IHJlY2VudGx5U2lnbmVkSW5XYWxsZXRzRnJvbVBlbmRpbmdcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNvbnRyYWN0LFxuICAgICAgICBzZWxlY3RlZFdhbGxldElkXG4gICAgICB9ID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgY29uc3QgYWNjb3VudHMgPSB5aWVsZCB0aGlzLnZhbGlkYXRlV2FsbGV0KHNlbGVjdGVkV2FsbGV0SWQpO1xuICAgICAgY29uc3QgcmVjZW50bHlTaWduZWRJbldhbGxldHMgPSB5aWVsZCBqc29uU3RvcmFnZS5nZXRJdGVtKFJFQ0VOVExZX1NJR05FRF9JTl9XQUxMRVRTKTtcbiAgICAgIGlmICghYWNjb3VudHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYWNjb3VudHM6IFtdLFxuICAgICAgICAgIGNvbnRyYWN0OiBudWxsLFxuICAgICAgICAgIHNlbGVjdGVkV2FsbGV0SWQ6IG51bGwsXG4gICAgICAgICAgcmVjZW50bHlTaWduZWRJbldhbGxldHM6IHJlY2VudGx5U2lnbmVkSW5XYWxsZXRzIHx8IFtdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhY2NvdW50cyxcbiAgICAgICAgY29udHJhY3QsXG4gICAgICAgIHNlbGVjdGVkV2FsbGV0SWQsXG4gICAgICAgIHJlY2VudGx5U2lnbmVkSW5XYWxsZXRzOiByZWNlbnRseVNpZ25lZEluV2FsbGV0cyB8fCBbXVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICBzZXRXYWxsZXRBc1JlY2VudGx5U2lnbmVkSW4od2FsbGV0SWQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QganNvblN0b3JhZ2UgPSBuZXcgSnNvblN0b3JhZ2UodGhpcy5zdG9yYWdlLCBQQUNLQUdFX05BTUUpO1xuICAgICAgbGV0IHJlY2VudGx5U2lnbmVkSW5XYWxsZXRzID0geWllbGQganNvblN0b3JhZ2UuZ2V0SXRlbShSRUNFTlRMWV9TSUdORURfSU5fV0FMTEVUUyk7XG4gICAgICBpZiAoIXJlY2VudGx5U2lnbmVkSW5XYWxsZXRzKSB7XG4gICAgICAgIHJlY2VudGx5U2lnbmVkSW5XYWxsZXRzID0gW107XG4gICAgICB9XG4gICAgICBpZiAoIXJlY2VudGx5U2lnbmVkSW5XYWxsZXRzLmluY2x1ZGVzKHdhbGxldElkKSkge1xuICAgICAgICByZWNlbnRseVNpZ25lZEluV2FsbGV0cy51bnNoaWZ0KHdhbGxldElkKTtcbiAgICAgICAgcmVjZW50bHlTaWduZWRJbldhbGxldHMgPSByZWNlbnRseVNpZ25lZEluV2FsbGV0cy5zbGljZSgwLCA1KTtcbiAgICAgICAgeWllbGQganNvblN0b3JhZ2Uuc2V0SXRlbShSRUNFTlRMWV9TSUdORURfSU5fV0FMTEVUUywgcmVjZW50bHlTaWduZWRJbldhbGxldHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlY2VudGx5U2lnbmVkSW5XYWxsZXRzO1xuICAgIH0pO1xuICB9XG4gIHNpZ25PdXRXYWxsZXQod2FsbGV0SWQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3Qgd2FsbGV0ID0geWllbGQgdGhpcy5nZXRXYWxsZXQod2FsbGV0SWQpO1xuICAgICAgeWllbGQgd2FsbGV0LnNpZ25PdXQoKS5jYXRjaChlcnIgPT4ge1xuICAgICAgICBsb2dnZXIubG9nKGBGYWlsZWQgdG8gc2lnbiBvdXQgJHt3YWxsZXQuaWR9YCk7XG4gICAgICAgIGxvZ2dlci5lcnJvcihlcnIpO1xuICAgICAgICAvLyBBdCBsZWFzdCBjbGVhbiB1cCBzdGF0ZSBvbiBvdXIgc2lkZS5cbiAgICAgICAgdGhpcy5vbldhbGxldFNpZ25lZE91dCh3YWxsZXQuaWQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgb25XYWxsZXRTaWduZWRJbih3YWxsZXRJZCwge1xuICAgIGFjY291bnRzLFxuICAgIGNvbnRyYWN0SWQsXG4gICAgbWV0aG9kTmFtZXNcbiAgfSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNlbGVjdGVkV2FsbGV0SWRcbiAgICAgIH0gPSB0aGlzLnN0b3JlLmdldFN0YXRlKCk7XG4gICAgICBjb25zdCBqc29uU3RvcmFnZSA9IG5ldyBKc29uU3RvcmFnZSh0aGlzLnN0b3JhZ2UsIFBBQ0tBR0VfTkFNRSk7XG4gICAgICBjb25zdCBjb250cmFjdCA9IHtcbiAgICAgICAgY29udHJhY3RJZCxcbiAgICAgICAgbWV0aG9kTmFtZXNcbiAgICAgIH07XG4gICAgICBpZiAoIWFjY291bnRzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBtb2R1bGUgPSB0aGlzLmdldE1vZHVsZSh3YWxsZXRJZCk7XG4gICAgICAgIC8vIFdlIGNhbid0IGd1YXJhbnRlZSB0aGUgdXNlciB3aWxsIGFjdHVhbGx5IHNpZ24gaW4gd2l0aCBicm93c2VyIHdhbGxldHMuXG4gICAgICAgIC8vIEJlc3Qgd2UgY2FuIGRvIGlzIHNldCBpbiBzdG9yYWdlIGFuZCB2YWxpZGF0ZSBvbiBpbml0LlxuICAgICAgICBpZiAobW9kdWxlLnR5cGUgPT09IFwiYnJvd3NlclwiKSB7XG4gICAgICAgICAgeWllbGQganNvblN0b3JhZ2Uuc2V0SXRlbShQRU5ESU5HX1NFTEVDVEVEX1dBTExFVF9JRCwgd2FsbGV0SWQpO1xuICAgICAgICAgIHlpZWxkIGpzb25TdG9yYWdlLnNldEl0ZW0oUEVORElOR19DT05UUkFDVCwgY29udHJhY3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChzZWxlY3RlZFdhbGxldElkICYmIHNlbGVjdGVkV2FsbGV0SWQgIT09IHdhbGxldElkKSB7XG4gICAgICAgIHlpZWxkIHRoaXMuc2lnbk91dFdhbGxldChzZWxlY3RlZFdhbGxldElkKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlY2VudGx5U2lnbmVkSW5XYWxsZXRzID0geWllbGQgdGhpcy5zZXRXYWxsZXRBc1JlY2VudGx5U2lnbmVkSW4od2FsbGV0SWQpO1xuICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IFwiV0FMTEVUX0NPTk5FQ1RFRFwiLFxuICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgd2FsbGV0SWQsXG4gICAgICAgICAgY29udHJhY3QsXG4gICAgICAgICAgYWNjb3VudHMsXG4gICAgICAgICAgcmVjZW50bHlTaWduZWRJbldhbGxldHNcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmVtaXR0ZXIuZW1pdChcInNpZ25lZEluXCIsIHtcbiAgICAgICAgd2FsbGV0SWQsXG4gICAgICAgIGNvbnRyYWN0SWQsXG4gICAgICAgIG1ldGhvZE5hbWVzLFxuICAgICAgICBhY2NvdW50c1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgb25XYWxsZXRTaWduZWRPdXQod2FsbGV0SWQpIHtcbiAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgIHR5cGU6IFwiV0FMTEVUX0RJU0NPTk5FQ1RFRFwiLFxuICAgICAgcGF5bG9hZDoge1xuICAgICAgICB3YWxsZXRJZFxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuZW1pdHRlci5lbWl0KFwic2lnbmVkT3V0XCIsIHtcbiAgICAgIHdhbGxldElkXG4gICAgfSk7XG4gIH1cbiAgc2V0dXBXYWxsZXRFbWl0dGVyKG1vZHVsZSkge1xuICAgIGNvbnN0IGVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgZW1pdHRlci5vbihcInNpZ25lZE91dFwiLCAoKSA9PiB7XG4gICAgICB0aGlzLm9uV2FsbGV0U2lnbmVkT3V0KG1vZHVsZS5pZCk7XG4gICAgfSk7XG4gICAgZW1pdHRlci5vbihcInNpZ25lZEluXCIsIGV2ZW50ID0+IHtcbiAgICAgIHRoaXMub25XYWxsZXRTaWduZWRJbihtb2R1bGUuaWQsIGV2ZW50KTtcbiAgICB9KTtcbiAgICBlbWl0dGVyLm9uKFwiYWNjb3VudHNDaGFuZ2VkXCIsICh7XG4gICAgICBhY2NvdW50c1xuICAgIH0pID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHRoaXMuZW1pdHRlci5lbWl0KFwiYWNjb3VudHNDaGFuZ2VkXCIsIHtcbiAgICAgICAgd2FsbGV0SWQ6IG1vZHVsZS5pZCxcbiAgICAgICAgYWNjb3VudHNcbiAgICAgIH0pO1xuICAgICAgaWYgKCFhY2NvdW50cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2lnbk91dFdhbGxldChtb2R1bGUuaWQpO1xuICAgICAgfVxuICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IFwiQUNDT1VOVFNfQ0hBTkdFRFwiLFxuICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgd2FsbGV0SWQ6IG1vZHVsZS5pZCxcbiAgICAgICAgICBhY2NvdW50c1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KSk7XG4gICAgZW1pdHRlci5vbihcIm5ldHdvcmtDaGFuZ2VkXCIsICh7XG4gICAgICBuZXR3b3JrSWRcbiAgICB9KSA9PiB7XG4gICAgICB0aGlzLmVtaXR0ZXIuZW1pdChcIm5ldHdvcmtDaGFuZ2VkXCIsIHtcbiAgICAgICAgd2FsbGV0SWQ6IG1vZHVsZS5pZCxcbiAgICAgICAgbmV0d29ya0lkXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBlbWl0dGVyLm9uKFwidXJpQ2hhbmdlZFwiLCAoe1xuICAgICAgdXJpXG4gICAgfSkgPT4ge1xuICAgICAgdGhpcy5lbWl0dGVyLmVtaXQoXCJ1cmlDaGFuZ2VkXCIsIHtcbiAgICAgICAgd2FsbGV0SWQ6IG1vZHVsZS5pZCxcbiAgICAgICAgdXJpXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gZW1pdHRlcjtcbiAgfVxuICB2YWxpZGF0ZVNpZ25NZXNzYWdlUGFyYW1zKHtcbiAgICBtZXNzYWdlLFxuICAgIG5vbmNlLFxuICAgIHJlY2lwaWVudFxuICB9KSB7XG4gICAgaWYgKCFtZXNzYWdlIHx8IG1lc3NhZ2UudHJpbSgpID09PSBcIlwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG1lc3NhZ2UuIEl0IG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nLlwiKTtcbiAgICB9XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIobm9uY2UpIHx8IG5vbmNlLmxlbmd0aCAhPT0gMzIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbm9uY2UuIEl0IG11c3QgYmUgYSBCdWZmZXIgd2l0aCBhIGxlbmd0aCBvZiAzMiBieXRlcy5cIik7XG4gICAgfVxuICAgIGlmICghcmVjaXBpZW50IHx8IHJlY2lwaWVudC50cmltKCkgPT09IFwiXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcmVjaXBpZW50LiBJdCBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZy5cIik7XG4gICAgfVxuICB9XG4gIGRlY29yYXRlV2FsbGV0KHdhbGxldCkge1xuICAgIGNvbnN0IF9zaWduSW4gPSB3YWxsZXQuc2lnbkluO1xuICAgIGNvbnN0IF9zaWduT3V0ID0gd2FsbGV0LnNpZ25PdXQ7XG4gICAgY29uc3QgX3NpZ25NZXNzYWdlID0gd2FsbGV0LnNpZ25NZXNzYWdlO1xuICAgIHdhbGxldC5zaWduSW4gPSBwYXJhbXMgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgYWNjb3VudHMgPSB5aWVsZCBfc2lnbkluKHBhcmFtcyk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNvbnRyYWN0SWQsXG4gICAgICAgIG1ldGhvZE5hbWVzID0gW11cbiAgICAgIH0gPSBwYXJhbXM7XG4gICAgICB5aWVsZCB0aGlzLm9uV2FsbGV0U2lnbmVkSW4od2FsbGV0LmlkLCB7XG4gICAgICAgIGFjY291bnRzLFxuICAgICAgICBjb250cmFjdElkLFxuICAgICAgICBtZXRob2ROYW1lc1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWNjb3VudHM7XG4gICAgfSk7XG4gICAgd2FsbGV0LnNpZ25PdXQgPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB5aWVsZCBfc2lnbk91dCgpO1xuICAgICAgdGhpcy5vbldhbGxldFNpZ25lZE91dCh3YWxsZXQuaWQpO1xuICAgIH0pO1xuICAgIHdhbGxldC5zaWduTWVzc2FnZSA9IHBhcmFtcyA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoX3NpZ25NZXNzYWdlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYFRoZSBzaWduTWVzc2FnZSBtZXRob2QgaXMgbm90IHN1cHBvcnRlZCBieSAke3dhbGxldC5tZXRhZGF0YS5uYW1lfWApO1xuICAgICAgfVxuICAgICAgdGhpcy52YWxpZGF0ZVNpZ25NZXNzYWdlUGFyYW1zKHBhcmFtcyk7XG4gICAgICByZXR1cm4geWllbGQgX3NpZ25NZXNzYWdlKHBhcmFtcyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHdhbGxldDtcbiAgfVxuICBzZXR1cEluc3RhbmNlKG1vZHVsZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoIW1vZHVsZS5tZXRhZGF0YS5hdmFpbGFibGUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IG1vZHVsZS50eXBlID09PSBcImluamVjdGVkXCIgPyBcIm5vdCBpbnN0YWxsZWRcIiA6IFwibm90IGF2YWlsYWJsZVwiO1xuICAgICAgICB0aHJvdyBFcnJvcihgJHttb2R1bGUubWV0YWRhdGEubmFtZX0gaXMgJHttZXNzYWdlfWApO1xuICAgICAgfVxuICAgICAgY29uc3Qgd2FsbGV0ID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGlkOiBtb2R1bGUuaWQsXG4gICAgICAgIHR5cGU6IG1vZHVsZS50eXBlLFxuICAgICAgICBtZXRhZGF0YTogbW9kdWxlLm1ldGFkYXRhXG4gICAgICB9LCB5aWVsZCBtb2R1bGUuaW5pdCh7XG4gICAgICAgIGlkOiBtb2R1bGUuaWQsXG4gICAgICAgIHR5cGU6IG1vZHVsZS50eXBlLFxuICAgICAgICBtZXRhZGF0YTogbW9kdWxlLm1ldGFkYXRhLFxuICAgICAgICBvcHRpb25zOiB0aGlzLm9wdGlvbnMsXG4gICAgICAgIHN0b3JlOiB0aGlzLnN0b3JlLnRvUmVhZE9ubHkoKSxcbiAgICAgICAgcHJvdmlkZXI6IHRoaXMucHJvdmlkZXIsXG4gICAgICAgIGVtaXR0ZXI6IHRoaXMuc2V0dXBXYWxsZXRFbWl0dGVyKG1vZHVsZSksXG4gICAgICAgIGxvZ2dlcjogbmV3IExvZ2dlcihtb2R1bGUuaWQpLFxuICAgICAgICBzdG9yYWdlOiBuZXcgSnNvblN0b3JhZ2UodGhpcy5zdG9yYWdlLCBbUEFDS0FHRV9OQU1FLCBtb2R1bGUuaWRdKVxuICAgICAgfSkpO1xuICAgICAgcmV0dXJuIHRoaXMuZGVjb3JhdGVXYWxsZXQod2FsbGV0KTtcbiAgICB9KTtcbiAgfVxuICBnZXRNb2R1bGUoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5tb2R1bGVzLmZpbmQoeCA9PiB4LmlkID09PSBpZCk7XG4gIH1cbiAgZ2V0V2FsbGV0KGlkKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IG1vZHVsZSA9IHRoaXMuZ2V0TW9kdWxlKGlkKTtcbiAgICAgIGlmICghbW9kdWxlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3Qge1xuICAgICAgICBzZWxlY3RlZFdhbGxldElkXG4gICAgICB9ID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgLy8gSWYgdXNlciB1bmluc3RhbGxlZC9yZW1vdmVkIGEgd2FsbGV0IHdoaWNoIHdhcyBwcmV2aW91c2x5IHNpZ25lZCBpbiB3aXRoXG4gICAgICAvLyBiZXN0IHdlIGNhbiBkbyBpcyBjbGVhbiB1cCBzdGF0ZSBvbiBvdXIgc2lkZS5cbiAgICAgIGlmICghbW9kdWxlLm1ldGFkYXRhLmF2YWlsYWJsZSAmJiBzZWxlY3RlZFdhbGxldElkKSB7XG4gICAgICAgIHRoaXMub25XYWxsZXRTaWduZWRPdXQoc2VsZWN0ZWRXYWxsZXRJZCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHlpZWxkIG1vZHVsZS53YWxsZXQoKTtcbiAgICB9KTtcbiAgfVxuICBzZXR1cCgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgbW9kdWxlcyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmZhY3Rvcmllcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBtb2R1bGUgPSB5aWVsZCB0aGlzLmZhY3Rvcmllc1tpXSh7XG4gICAgICAgICAgb3B0aW9uczogdGhpcy5vcHRpb25zXG4gICAgICAgIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgbG9nZ2VyLmxvZyhcIkZhaWxlZCB0byBzZXR1cCBtb2R1bGVcIik7XG4gICAgICAgICAgbG9nZ2VyLmVycm9yKGVycik7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBGaWx0ZXIgb3V0IHdhbGxldHMgdGhhdCBhcmVuJ3QgYXZhaWxhYmxlLlxuICAgICAgICBpZiAoIW1vZHVsZSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNraXAgZHVwbGljYXRlZCBtb2R1bGUuXG4gICAgICAgIGlmIChtb2R1bGVzLnNvbWUoeCA9PiB4LmlkID09PSBtb2R1bGUuaWQpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbW9kdWxlcy5wdXNoKHtcbiAgICAgICAgICBpZDogbW9kdWxlLmlkLFxuICAgICAgICAgIHR5cGU6IG1vZHVsZS50eXBlLFxuICAgICAgICAgIG1ldGFkYXRhOiBtb2R1bGUubWV0YWRhdGEsXG4gICAgICAgICAgd2FsbGV0OiAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBsZXQgaW5zdGFuY2UgPSB0aGlzLmluc3RhbmNlc1ttb2R1bGUuaWRdO1xuICAgICAgICAgICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluc3RhbmNlID0geWllbGQgdGhpcy5zZXR1cEluc3RhbmNlKG1vZHVsZSk7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlc1ttb2R1bGUuaWRdID0gaW5zdGFuY2U7XG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLm1vZHVsZXMgPSBtb2R1bGVzO1xuICAgICAgY29uc3Qge1xuICAgICAgICBhY2NvdW50cyxcbiAgICAgICAgY29udHJhY3QsXG4gICAgICAgIHNlbGVjdGVkV2FsbGV0SWQsXG4gICAgICAgIHJlY2VudGx5U2lnbmVkSW5XYWxsZXRzXG4gICAgICB9ID0geWllbGQgdGhpcy5yZXNvbHZlU3RvcmFnZVN0YXRlKCk7XG4gICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogXCJTRVRVUF9XQUxMRVRfTU9EVUxFU1wiLFxuICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgbW9kdWxlcyxcbiAgICAgICAgICBhY2NvdW50cyxcbiAgICAgICAgICBjb250cmFjdCxcbiAgICAgICAgICBzZWxlY3RlZFdhbGxldElkLFxuICAgICAgICAgIHJlY2VudGx5U2lnbmVkSW5XYWxsZXRzXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1vZHVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMubW9kdWxlc1tpXS50eXBlICE9PSBcImluc3RhbnQtbGlua1wiKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd2FsbGV0ID0geWllbGQgdGhpcy5tb2R1bGVzW2ldLndhbGxldCgpO1xuICAgICAgICBpZiAoIXdhbGxldC5tZXRhZGF0YS5ydW5PblN0YXJ0dXApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHlpZWxkIHdhbGxldC5zaWduSW4oe1xuICAgICAgICAgICAgY29udHJhY3RJZDogd2FsbGV0LmdldENvbnRyYWN0SWQoKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJGYWlsZWQgdG8gc2lnbiBpbiB0byB3YWxsZXQuIFwiICsgZXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmNvbnN0IGdldE5ldHdvcmtQcmVzZXQgPSBuZXR3b3JrSWQgPT4ge1xuICBzd2l0Y2ggKG5ldHdvcmtJZCkge1xuICAgIGNhc2UgXCJtYWlubmV0XCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuZXR3b3JrSWQsXG4gICAgICAgIG5vZGVVcmw6IFwiaHR0cHM6Ly9ycGMubWFpbm5ldC5uZWFyLm9yZ1wiLFxuICAgICAgICBoZWxwZXJVcmw6IFwiaHR0cHM6Ly9oZWxwZXIubWFpbm5ldC5uZWFyLm9yZ1wiLFxuICAgICAgICBleHBsb3JlclVybDogXCJodHRwczovL25lYXJibG9ja3MuaW9cIixcbiAgICAgICAgaW5kZXhlclVybDogXCJodHRwczovL2FwaS5raXR3YWxsZXQuYXBwXCJcbiAgICAgIH07XG4gICAgY2FzZSBcInRlc3RuZXRcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5ldHdvcmtJZCxcbiAgICAgICAgbm9kZVVybDogXCJodHRwczovL3JwYy50ZXN0bmV0Lm5lYXIub3JnXCIsXG4gICAgICAgIGhlbHBlclVybDogXCJodHRwczovL2hlbHBlci50ZXN0bmV0Lm5lYXIub3JnXCIsXG4gICAgICAgIGV4cGxvcmVyVXJsOiBcImh0dHBzOi8vdGVzdG5ldC5uZWFyYmxvY2tzLmlvXCIsXG4gICAgICAgIGluZGV4ZXJVcmw6IFwiaHR0cHM6Ly90ZXN0bmV0LWFwaS5raXR3YWxsZXQuYXBwXCJcbiAgICAgIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IEVycm9yKGBGYWlsZWQgdG8gZmluZCBjb25maWcgZm9yOiAnJHtuZXR3b3JrSWR9J2ApO1xuICB9XG59O1xuY29uc3QgcmVzb2x2ZU5ldHdvcmsgPSBuZXR3b3JrID0+IHtcbiAgcmV0dXJuIHR5cGVvZiBuZXR3b3JrID09PSBcInN0cmluZ1wiID8gZ2V0TmV0d29ya1ByZXNldChuZXR3b3JrKSA6IG5ldHdvcms7XG59O1xuY29uc3QgcmVzb2x2ZU9wdGlvbnMgPSBwYXJhbXMgPT4ge1xuICBjb25zdCBvcHRpb25zID0ge1xuICAgIGxhbmd1YWdlQ29kZTogcGFyYW1zLmxhbmd1YWdlQ29kZSB8fCB1bmRlZmluZWQsXG4gICAgbmV0d29yazogcmVzb2x2ZU5ldHdvcmsocGFyYW1zLm5ldHdvcmspLFxuICAgIGRlYnVnOiBwYXJhbXMuZGVidWcgfHwgZmFsc2UsXG4gICAgb3B0aW1pemVXYWxsZXRPcmRlcjogcGFyYW1zLm9wdGltaXplV2FsbGV0T3JkZXIgPT09IGZhbHNlID8gZmFsc2UgOiB0cnVlLFxuICAgIHJhbmRvbWl6ZVdhbGxldE9yZGVyOiBwYXJhbXMucmFuZG9taXplV2FsbGV0T3JkZXIgfHwgZmFsc2UsXG4gICAgcmVsYXllclVybDogcGFyYW1zLnJlbGF5ZXJVcmwgfHwgdW5kZWZpbmVkXG4gIH07XG4gIHJldHVybiB7XG4gICAgb3B0aW9ucyxcbiAgICBzdG9yYWdlOiBwYXJhbXMuc3RvcmFnZSB8fCBuZXcgV2ViU3RvcmFnZVNlcnZpY2UoKVxuICB9O1xufTtcblxuY29uc3QgcmVkdWNlciA9IChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gIGxvZ2dlci5sb2coXCJTdG9yZSBBY3Rpb25cIiwgYWN0aW9uKTtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgXCJTRVRVUF9XQUxMRVRfTU9EVUxFU1wiOlxuICAgICAge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgbW9kdWxlcyxcbiAgICAgICAgICBhY2NvdW50cyxcbiAgICAgICAgICBjb250cmFjdCxcbiAgICAgICAgICBzZWxlY3RlZFdhbGxldElkLFxuICAgICAgICAgIHJlY2VudGx5U2lnbmVkSW5XYWxsZXRzXG4gICAgICAgIH0gPSBhY3Rpb24ucGF5bG9hZDtcbiAgICAgICAgY29uc3QgYWNjb3VudFN0YXRlcyA9IGFjY291bnRzLm1hcCgoYWNjb3VudCwgaSkgPT4ge1xuICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFjY291bnQpLCB7XG4gICAgICAgICAgICBhY3RpdmU6IGkgPT09IDBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0YXRlKSwge1xuICAgICAgICAgIG1vZHVsZXMsXG4gICAgICAgICAgYWNjb3VudHM6IGFjY291bnRTdGF0ZXMsXG4gICAgICAgICAgY29udHJhY3QsXG4gICAgICAgICAgc2VsZWN0ZWRXYWxsZXRJZCxcbiAgICAgICAgICByZWNlbnRseVNpZ25lZEluV2FsbGV0c1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICBjYXNlIFwiV0FMTEVUX0NPTk5FQ1RFRFwiOlxuICAgICAge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgd2FsbGV0SWQsXG4gICAgICAgICAgY29udHJhY3QsXG4gICAgICAgICAgYWNjb3VudHMsXG4gICAgICAgICAgcmVjZW50bHlTaWduZWRJbldhbGxldHNcbiAgICAgICAgfSA9IGFjdGlvbi5wYXlsb2FkO1xuICAgICAgICBpZiAoIWFjY291bnRzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhY3RpdmVBY2NvdW50SW5kZXggPSBzdGF0ZS5hY2NvdW50cy5maW5kSW5kZXgoYWNjb3VudCA9PiBhY2NvdW50LmFjdGl2ZSk7XG4gICAgICAgIGNvbnN0IGFjY291bnRTdGF0ZXMgPSBhY2NvdW50cy5tYXAoKGFjY291bnQsIGkpID0+IHtcbiAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhY2NvdW50KSwge1xuICAgICAgICAgICAgYWN0aXZlOiBpID09PSAoYWN0aXZlQWNjb3VudEluZGV4ID4gLTEgPyBhY3RpdmVBY2NvdW50SW5kZXggOiAwKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUpLCB7XG4gICAgICAgICAgY29udHJhY3QsXG4gICAgICAgICAgYWNjb3VudHM6IGFjY291bnRTdGF0ZXMsXG4gICAgICAgICAgc2VsZWN0ZWRXYWxsZXRJZDogd2FsbGV0SWQsXG4gICAgICAgICAgcmVjZW50bHlTaWduZWRJbldhbGxldHNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgY2FzZSBcIldBTExFVF9ESVNDT05ORUNURURcIjpcbiAgICAgIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHdhbGxldElkXG4gICAgICAgIH0gPSBhY3Rpb24ucGF5bG9hZDtcbiAgICAgICAgaWYgKHdhbGxldElkICE9PSBzdGF0ZS5zZWxlY3RlZFdhbGxldElkKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0YXRlKSwge1xuICAgICAgICAgIGNvbnRyYWN0OiBudWxsLFxuICAgICAgICAgIGFjY291bnRzOiBbXSxcbiAgICAgICAgICBzZWxlY3RlZFdhbGxldElkOiBudWxsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIGNhc2UgXCJBQ0NPVU5UU19DSEFOR0VEXCI6XG4gICAgICB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICB3YWxsZXRJZCxcbiAgICAgICAgICBhY2NvdW50c1xuICAgICAgICB9ID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgICAgIGlmICh3YWxsZXRJZCAhPT0gc3RhdGUuc2VsZWN0ZWRXYWxsZXRJZCkge1xuICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhY3RpdmVBY2NvdW50ID0gc3RhdGUuYWNjb3VudHMuZmluZChhY2NvdW50ID0+IGFjY291bnQuYWN0aXZlKTtcbiAgICAgICAgY29uc3QgaXNBY3RpdmVBY2NvdW50UmVtb3ZlZCA9ICFhY2NvdW50cy5zb21lKGFjY291bnQgPT4gYWNjb3VudC5hY2NvdW50SWQgPT09IChhY3RpdmVBY2NvdW50ID09PSBudWxsIHx8IGFjdGl2ZUFjY291bnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFjdGl2ZUFjY291bnQuYWNjb3VudElkKSk7XG4gICAgICAgIGNvbnN0IGFjY291bnRTdGF0ZXMgPSBhY2NvdW50cy5tYXAoKGFjY291bnQsIGkpID0+IHtcbiAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhY2NvdW50KSwge1xuICAgICAgICAgICAgYWN0aXZlOiBpc0FjdGl2ZUFjY291bnRSZW1vdmVkID8gaSA9PT0gMCA6IGFjY291bnQuYWNjb3VudElkID09PSAoYWN0aXZlQWNjb3VudCA9PT0gbnVsbCB8fCBhY3RpdmVBY2NvdW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhY3RpdmVBY2NvdW50LmFjY291bnRJZClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0YXRlKSwge1xuICAgICAgICAgIGFjY291bnRzOiBhY2NvdW50U3RhdGVzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIGNhc2UgXCJTRVRfQUNUSVZFX0FDQ09VTlRcIjpcbiAgICAgIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGFjY291bnRJZFxuICAgICAgICB9ID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgICAgIGNvbnN0IGFjY291bnRTdGF0ZXMgPSBzdGF0ZS5hY2NvdW50cy5tYXAoYWNjb3VudCA9PiB7XG4gICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYWNjb3VudCksIHtcbiAgICAgICAgICAgIGFjdGl2ZTogYWNjb3VudC5hY2NvdW50SWQgPT09IGFjY291bnRJZFxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUpLCB7XG4gICAgICAgICAgYWNjb3VudHM6IGFjY291bnRTdGF0ZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufTtcbmNvbnN0IGNyZWF0ZVN0b3JlID0gc3RvcmFnZSA9PiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgY29uc3QganNvblN0b3JhZ2UgPSBuZXcgSnNvblN0b3JhZ2Uoc3RvcmFnZSwgUEFDS0FHRV9OQU1FKTtcbiAgY29uc3QgaW5pdGlhbFN0YXRlID0ge1xuICAgIG1vZHVsZXM6IFtdLFxuICAgIGFjY291bnRzOiBbXSxcbiAgICBjb250cmFjdDogeWllbGQganNvblN0b3JhZ2UuZ2V0SXRlbShDT05UUkFDVCksXG4gICAgc2VsZWN0ZWRXYWxsZXRJZDogeWllbGQganNvblN0b3JhZ2UuZ2V0SXRlbShTRUxFQ1RFRF9XQUxMRVRfSUQpLFxuICAgIHJlY2VudGx5U2lnbmVkSW5XYWxsZXRzOiAoeWllbGQganNvblN0b3JhZ2UuZ2V0SXRlbShSRUNFTlRMWV9TSUdORURfSU5fV0FMTEVUUykpIHx8IFtdXG4gIH07XG4gIGNvbnN0IHN0YXRlJCA9IG5ldyByeGpzLkJlaGF2aW9yU3ViamVjdChpbml0aWFsU3RhdGUpO1xuICBjb25zdCBhY3Rpb25zJCA9IG5ldyByeGpzLlN1YmplY3QoKTtcbiAgYWN0aW9ucyQucGlwZShyeGpzLnNjYW4ocmVkdWNlciwgaW5pdGlhbFN0YXRlKSkuc3Vic2NyaWJlKHN0YXRlJCk7XG4gIGNvbnN0IHN5bmNTdG9yYWdlID0gKHByZXZTdGF0ZSwgc3RhdGUsIHN0b3JhZ2VLZXksIHByb3BlcnR5KSA9PiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICBpZiAoc3RhdGVbcHJvcGVydHldID09PSBwcmV2U3RhdGVbcHJvcGVydHldKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzdGF0ZVtwcm9wZXJ0eV0pIHtcbiAgICAgIHlpZWxkIGpzb25TdG9yYWdlLnNldEl0ZW0oc3RvcmFnZUtleSwgc3RhdGVbcHJvcGVydHldKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgeWllbGQganNvblN0b3JhZ2UucmVtb3ZlSXRlbShzdG9yYWdlS2V5KTtcbiAgfSk7XG4gIGxldCBwcmV2U3RhdGUgPSBzdGF0ZSQuZ2V0VmFsdWUoKTtcbiAgc3RhdGUkLnN1YnNjcmliZShzdGF0ZSA9PiB7XG4gICAgc3luY1N0b3JhZ2UocHJldlN0YXRlLCBzdGF0ZSwgU0VMRUNURURfV0FMTEVUX0lELCBcInNlbGVjdGVkV2FsbGV0SWRcIik7XG4gICAgc3luY1N0b3JhZ2UocHJldlN0YXRlLCBzdGF0ZSwgQ09OVFJBQ1QsIFwiY29udHJhY3RcIik7XG4gICAgc3luY1N0b3JhZ2UocHJldlN0YXRlLCBzdGF0ZSwgUkVDRU5UTFlfU0lHTkVEX0lOX1dBTExFVFMsIFwicmVjZW50bHlTaWduZWRJbldhbGxldHNcIik7XG4gICAgcHJldlN0YXRlID0gc3RhdGU7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIG9ic2VydmFibGU6IHN0YXRlJCxcbiAgICBnZXRTdGF0ZTogKCkgPT4gc3RhdGUkLmdldFZhbHVlKCksXG4gICAgZGlzcGF0Y2g6IGFjdGlvbiA9PiBhY3Rpb25zJC5uZXh0KGFjdGlvbiksXG4gICAgdG9SZWFkT25seTogKCkgPT4gKHtcbiAgICAgIGdldFN0YXRlOiAoKSA9PiBzdGF0ZSQuZ2V0VmFsdWUoKSxcbiAgICAgIG9ic2VydmFibGU6IHN0YXRlJC5hc09ic2VydmFibGUoKVxuICAgIH0pXG4gIH07XG59KTtcblxubGV0IHdhbGxldFNlbGVjdG9ySW5zdGFuY2UgPSBudWxsO1xuY29uc3QgY3JlYXRlU2VsZWN0b3IgPSAob3B0aW9ucywgc3RvcmUsIHdhbGxldE1vZHVsZXMsIGVtaXR0ZXIpID0+IHtcbiAgcmV0dXJuIHtcbiAgICBvcHRpb25zLFxuICAgIHN0b3JlOiBzdG9yZS50b1JlYWRPbmx5KCksXG4gICAgd2FsbGV0OiBpZCA9PiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc2VsZWN0ZWRXYWxsZXRJZFxuICAgICAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICBjb25zdCB3YWxsZXQgPSB5aWVsZCB3YWxsZXRNb2R1bGVzLmdldFdhbGxldChpZCB8fCBzZWxlY3RlZFdhbGxldElkKTtcbiAgICAgIGlmICghd2FsbGV0KSB7XG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgd2FsbGV0IGlkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHdhbGxldCBzZWxlY3RlZFwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3YWxsZXQ7XG4gICAgfSksXG4gICAgc2V0QWN0aXZlQWNjb3VudDogYWNjb3VudElkID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYWNjb3VudHNcbiAgICAgIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgaWYgKCFhY2NvdW50cy5zb21lKGFjY291bnQgPT4gYWNjb3VudC5hY2NvdW50SWQgPT09IGFjY291bnRJZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhY2NvdW50IGlkXCIpO1xuICAgICAgfVxuICAgICAgc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiBcIlNFVF9BQ1RJVkVfQUNDT1VOVFwiLFxuICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgYWNjb3VudElkXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgaXNTaWduZWRJbigpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYWNjb3VudHNcbiAgICAgIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgcmV0dXJuIEJvb2xlYW4oYWNjb3VudHMubGVuZ3RoKTtcbiAgICB9LFxuICAgIG9uOiAoZXZlbnROYW1lLCBjYWxsYmFjaykgPT4ge1xuICAgICAgcmV0dXJuIGVtaXR0ZXIub24oZXZlbnROYW1lLCBjYWxsYmFjayk7XG4gICAgfSxcbiAgICBvZmY6IChldmVudE5hbWUsIGNhbGxiYWNrKSA9PiB7XG4gICAgICBlbWl0dGVyLm9mZihldmVudE5hbWUsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH07XG59O1xuLyoqXHJcbiAqIEluaXRpYXRlcyBhIHdhbGxldCBzZWxlY3RvciBpbnN0YW5jZVxyXG4gKiBAcGFyYW0ge1dhbGxldFNlbGVjdG9yUGFyYW1zfSBwYXJhbXMgU2VsZWN0b3IgcGFyYW1ldGVycyAobmV0d29yaywgbW9kdWxlcy4uLilcclxuICogQHJldHVybnMge1Byb21pc2U8V2FsbGV0U2VsZWN0b3I+fSBSZXR1cm5zIGEgV2FsbGV0U2VsZWN0b3Igb2JqZWN0XHJcbiAqL1xuY29uc3Qgc2V0dXBXYWxsZXRTZWxlY3RvciA9IHBhcmFtcyA9PiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgY29uc3Qge1xuICAgIG9wdGlvbnMsXG4gICAgc3RvcmFnZVxuICB9ID0gcmVzb2x2ZU9wdGlvbnMocGFyYW1zKTtcbiAgTG9nZ2VyLmRlYnVnID0gb3B0aW9ucy5kZWJ1ZztcbiAgY29uc3QgZW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgY29uc3Qgc3RvcmUgPSB5aWVsZCBjcmVhdGVTdG9yZShzdG9yYWdlKTtcbiAgY29uc3Qgd2FsbGV0TW9kdWxlcyA9IG5ldyBXYWxsZXRNb2R1bGVzKHtcbiAgICBmYWN0b3JpZXM6IHBhcmFtcy5tb2R1bGVzLFxuICAgIHN0b3JhZ2UsXG4gICAgb3B0aW9ucyxcbiAgICBzdG9yZSxcbiAgICBlbWl0dGVyLFxuICAgIHByb3ZpZGVyOiBuZXcgUHJvdmlkZXIob3B0aW9ucy5uZXR3b3JrLm5vZGVVcmwpXG4gIH0pO1xuICB5aWVsZCB3YWxsZXRNb2R1bGVzLnNldHVwKCk7XG4gIGlmIChwYXJhbXMuYWxsb3dNdWx0aXBsZVNlbGVjdG9ycykge1xuICAgIHJldHVybiBjcmVhdGVTZWxlY3RvcihvcHRpb25zLCBzdG9yZSwgd2FsbGV0TW9kdWxlcywgZW1pdHRlcik7XG4gIH1cbiAgaWYgKCF3YWxsZXRTZWxlY3Rvckluc3RhbmNlKSB7XG4gICAgd2FsbGV0U2VsZWN0b3JJbnN0YW5jZSA9IGNyZWF0ZVNlbGVjdG9yKG9wdGlvbnMsIHN0b3JlLCB3YWxsZXRNb2R1bGVzLCBlbWl0dGVyKTtcbiAgfVxuICByZXR1cm4gd2FsbGV0U2VsZWN0b3JJbnN0YW5jZTtcbn0pO1xuXG5jb25zdCB3YWl0ID0gbXMgPT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7XG59O1xuY29uc3QgcG9sbCA9IChjYiwgaW50ZXJ2YWwsIHJlbWFpbmluZykgPT4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gIGNvbnN0IHJlc3VsdCA9IGNiKCk7XG4gIGlmIChyZXN1bHQpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGlmICghcmVtYWluaW5nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXhjZWVkZWQgdGltZW91dFwiKTtcbiAgfVxuICByZXR1cm4gd2FpdChpbnRlcnZhbCkudGhlbigoKSA9PiBwb2xsKGNiLCBpbnRlcnZhbCwgcmVtYWluaW5nIC0gMSkpO1xufSk7XG5jb25zdCB3YWl0Rm9yID0gKGNiLCBvcHRzID0ge30pID0+IF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICBjb25zdCB7XG4gICAgdGltZW91dCA9IDEwMCxcbiAgICBpbnRlcnZhbCA9IDUwXG4gIH0gPSBvcHRzO1xuICByZXR1cm4gUHJvbWlzZS5yYWNlKFt3YWl0KHRpbWVvdXQpLnRoZW4oKCkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkV4Y2VlZGVkIHRpbWVvdXRcIik7XG4gIH0pLCBwb2xsKGNiLCBpbnRlcnZhbCwgTWF0aC5mbG9vcih0aW1lb3V0IC8gaW50ZXJ2YWwpKV0pO1xufSk7XG5cbmNvbnN0IGdldEFjdGl2ZUFjY291bnQgPSBzdGF0ZSA9PiB7XG4gIHJldHVybiBzdGF0ZS5hY2NvdW50cy5maW5kKGFjY291bnQgPT4gYWNjb3VudC5hY3RpdmUpIHx8IG51bGw7XG59O1xuXG52YXIgYUNhbGxhYmxlJDEgPSBhQ2FsbGFibGUkOTtcbnZhciB0b09iamVjdCQzID0gdG9PYmplY3QkNztcbnZhciBJbmRleGVkT2JqZWN0JDEgPSBpbmRleGVkT2JqZWN0O1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlJDUgPSBsZW5ndGhPZkFycmF5TGlrZSQ4O1xuXG52YXIgJFR5cGVFcnJvciQyID0gVHlwZUVycm9yO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLnsgcmVkdWNlLCByZWR1Y2VSaWdodCB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG52YXIgY3JlYXRlTWV0aG9kJDIgPSBmdW5jdGlvbiAoSVNfUklHSFQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0aGF0LCBjYWxsYmFja2ZuLCBhcmd1bWVudHNMZW5ndGgsIG1lbW8pIHtcbiAgICBhQ2FsbGFibGUkMShjYWxsYmFja2ZuKTtcbiAgICB2YXIgTyA9IHRvT2JqZWN0JDModGhhdCk7XG4gICAgdmFyIHNlbGYgPSBJbmRleGVkT2JqZWN0JDEoTyk7XG4gICAgdmFyIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlJDUoTyk7XG4gICAgdmFyIGluZGV4ID0gSVNfUklHSFQgPyBsZW5ndGggLSAxIDogMDtcbiAgICB2YXIgaSA9IElTX1JJR0hUID8gLTEgOiAxO1xuICAgIGlmIChhcmd1bWVudHNMZW5ndGggPCAyKSB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKGluZGV4IGluIHNlbGYpIHtcbiAgICAgICAgbWVtbyA9IHNlbGZbaW5kZXhdO1xuICAgICAgICBpbmRleCArPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGluZGV4ICs9IGk7XG4gICAgICBpZiAoSVNfUklHSFQgPyBpbmRleCA8IDAgOiBsZW5ndGggPD0gaW5kZXgpIHtcbiAgICAgICAgdGhyb3cgJFR5cGVFcnJvciQyKCdSZWR1Y2Ugb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoO0lTX1JJR0hUID8gaW5kZXggPj0gMCA6IGxlbmd0aCA+IGluZGV4OyBpbmRleCArPSBpKSBpZiAoaW5kZXggaW4gc2VsZikge1xuICAgICAgbWVtbyA9IGNhbGxiYWNrZm4obWVtbywgc2VsZltpbmRleF0sIGluZGV4LCBPKTtcbiAgICB9XG4gICAgcmV0dXJuIG1lbW87XG4gIH07XG59O1xuXG52YXIgYXJyYXlSZWR1Y2UgPSB7XG4gIC8vIGBBcnJheS5wcm90b3R5cGUucmVkdWNlYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUucmVkdWNlXG4gIGxlZnQ6IGNyZWF0ZU1ldGhvZCQyKGZhbHNlKSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5yZWR1Y2VSaWdodGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnJlZHVjZXJpZ2h0XG4gIHJpZ2h0OiBjcmVhdGVNZXRob2QkMih0cnVlKVxufTtcblxudmFyIGZhaWxzJGMgPSBmYWlscyRzO1xuXG52YXIgYXJyYXlNZXRob2RJc1N0cmljdCQxID0gZnVuY3Rpb24gKE1FVEhPRF9OQU1FLCBhcmd1bWVudCkge1xuICB2YXIgbWV0aG9kID0gW11bTUVUSE9EX05BTUVdO1xuICByZXR1cm4gISFtZXRob2QgJiYgZmFpbHMkYyhmdW5jdGlvbiAoKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZWxlc3MtY2FsbCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICAgIG1ldGhvZC5jYWxsKG51bGwsIGFyZ3VtZW50IHx8IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDE7IH0sIDEpO1xuICB9KTtcbn07XG5cbnZhciAkJDMgPSBfZXhwb3J0O1xudmFyICRyZWR1Y2UgPSBhcnJheVJlZHVjZS5sZWZ0O1xudmFyIGFycmF5TWV0aG9kSXNTdHJpY3QgPSBhcnJheU1ldGhvZElzU3RyaWN0JDE7XG52YXIgQ0hST01FX1ZFUlNJT04gPSBlbmdpbmVWOFZlcnNpb247XG52YXIgSVNfTk9ERSA9IGVuZ2luZUlzTm9kZTtcblxudmFyIFNUUklDVF9NRVRIT0QgPSBhcnJheU1ldGhvZElzU3RyaWN0KCdyZWR1Y2UnKTtcbi8vIENocm9tZSA4MC04MiBoYXMgYSBjcml0aWNhbCBidWdcbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTEwNDk5ODJcbnZhciBDSFJPTUVfQlVHID0gIUlTX05PREUgJiYgQ0hST01FX1ZFUlNJT04gPiA3OSAmJiBDSFJPTUVfVkVSU0lPTiA8IDgzO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLnJlZHVjZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5yZWR1Y2VcbiQkMyh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogIVNUUklDVF9NRVRIT0QgfHwgQ0hST01FX0JVRyB9LCB7XG4gIHJlZHVjZTogZnVuY3Rpb24gcmVkdWNlKGNhbGxiYWNrZm4gLyogLCBpbml0aWFsVmFsdWUgKi8pIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICByZXR1cm4gJHJlZHVjZSh0aGlzLCBjYWxsYmFja2ZuLCBsZW5ndGgsIGxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcblxudmFyIGFuT2JqZWN0JDMgPSBhbk9iamVjdCRlO1xuXG4vLyBgUmVnRXhwLnByb3RvdHlwZS5mbGFnc2AgZ2V0dGVyIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWdldC1yZWdleHAucHJvdG90eXBlLmZsYWdzXG52YXIgcmVnZXhwRmxhZ3MkMSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRoYXQgPSBhbk9iamVjdCQzKHRoaXMpO1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGlmICh0aGF0Lmhhc0luZGljZXMpIHJlc3VsdCArPSAnZCc7XG4gIGlmICh0aGF0Lmdsb2JhbCkgcmVzdWx0ICs9ICdnJztcbiAgaWYgKHRoYXQuaWdub3JlQ2FzZSkgcmVzdWx0ICs9ICdpJztcbiAgaWYgKHRoYXQubXVsdGlsaW5lKSByZXN1bHQgKz0gJ20nO1xuICBpZiAodGhhdC5kb3RBbGwpIHJlc3VsdCArPSAncyc7XG4gIGlmICh0aGF0LnVuaWNvZGUpIHJlc3VsdCArPSAndSc7XG4gIGlmICh0aGF0LnVuaWNvZGVTZXRzKSByZXN1bHQgKz0gJ3YnO1xuICBpZiAodGhhdC5zdGlja3kpIHJlc3VsdCArPSAneSc7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgZmFpbHMkYiA9IGZhaWxzJHM7XG52YXIgZ2xvYmFsJGEgPSBnbG9iYWwkdDtcblxuLy8gYmFiZWwtbWluaWZ5IGFuZCBDbG9zdXJlIENvbXBpbGVyIHRyYW5zcGlsZXMgUmVnRXhwKCdhJywgJ3knKSAtPiAvYS95IGFuZCBpdCBjYXVzZXMgU3ludGF4RXJyb3JcbnZhciAkUmVnRXhwJDIgPSBnbG9iYWwkYS5SZWdFeHA7XG5cbnZhciBVTlNVUFBPUlRFRF9ZJDIgPSBmYWlscyRiKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJlID0gJFJlZ0V4cCQyKCdhJywgJ3knKTtcbiAgcmUubGFzdEluZGV4ID0gMjtcbiAgcmV0dXJuIHJlLmV4ZWMoJ2FiY2QnKSAhPSBudWxsO1xufSk7XG5cbi8vIFVDIEJyb3dzZXIgYnVnXG4vLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMTAwOFxudmFyIE1JU1NFRF9TVElDS1kgPSBVTlNVUFBPUlRFRF9ZJDIgfHwgZmFpbHMkYihmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhJFJlZ0V4cCQyKCdhJywgJ3knKS5zdGlja3k7XG59KTtcblxudmFyIEJST0tFTl9DQVJFVCA9IFVOU1VQUE9SVEVEX1kkMiB8fCBmYWlscyRiKGZ1bmN0aW9uICgpIHtcbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NzczNjg3XG4gIHZhciByZSA9ICRSZWdFeHAkMignXnInLCAnZ3knKTtcbiAgcmUubGFzdEluZGV4ID0gMjtcbiAgcmV0dXJuIHJlLmV4ZWMoJ3N0cicpICE9IG51bGw7XG59KTtcblxudmFyIHJlZ2V4cFN0aWNreUhlbHBlcnMgPSB7XG4gIEJST0tFTl9DQVJFVDogQlJPS0VOX0NBUkVULFxuICBNSVNTRURfU1RJQ0tZOiBNSVNTRURfU1RJQ0tZLFxuICBVTlNVUFBPUlRFRF9ZOiBVTlNVUFBPUlRFRF9ZJDJcbn07XG5cbnZhciBmYWlscyRhID0gZmFpbHMkcztcbnZhciBnbG9iYWwkOSA9IGdsb2JhbCR0O1xuXG4vLyBiYWJlbC1taW5pZnkgYW5kIENsb3N1cmUgQ29tcGlsZXIgdHJhbnNwaWxlcyBSZWdFeHAoJy4nLCAncycpIC0+IC8uL3MgYW5kIGl0IGNhdXNlcyBTeW50YXhFcnJvclxudmFyICRSZWdFeHAkMSA9IGdsb2JhbCQ5LlJlZ0V4cDtcblxudmFyIHJlZ2V4cFVuc3VwcG9ydGVkRG90QWxsID0gZmFpbHMkYShmdW5jdGlvbiAoKSB7XG4gIHZhciByZSA9ICRSZWdFeHAkMSgnLicsICdzJyk7XG4gIHJldHVybiAhKHJlLmRvdEFsbCAmJiByZS5leGVjKCdcXG4nKSAmJiByZS5mbGFncyA9PT0gJ3MnKTtcbn0pO1xuXG52YXIgZmFpbHMkOSA9IGZhaWxzJHM7XG52YXIgZ2xvYmFsJDggPSBnbG9iYWwkdDtcblxuLy8gYmFiZWwtbWluaWZ5IGFuZCBDbG9zdXJlIENvbXBpbGVyIHRyYW5zcGlsZXMgUmVnRXhwKCcoPzxhPmIpJywgJ2cnKSAtPiAvKD88YT5iKS9nIGFuZCBpdCBjYXVzZXMgU3ludGF4RXJyb3JcbnZhciAkUmVnRXhwID0gZ2xvYmFsJDguUmVnRXhwO1xuXG52YXIgcmVnZXhwVW5zdXBwb3J0ZWROY2cgPSBmYWlscyQ5KGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJlID0gJFJlZ0V4cCgnKD88YT5iKScsICdnJyk7XG4gIHJldHVybiByZS5leGVjKCdiJykuZ3JvdXBzLmEgIT09ICdiJyB8fFxuICAgICdiJy5yZXBsYWNlKHJlLCAnJDxhPmMnKSAhPT0gJ2JjJztcbn0pO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSByZWdleHAvbm8tZW1wdHktY2FwdHVyaW5nLWdyb3VwLCByZWdleHAvbm8tZW1wdHktZ3JvdXAsIHJlZ2V4cC9uby1sYXp5LWVuZHMgLS0gdGVzdGluZyAqL1xuLyogZXNsaW50LWRpc2FibGUgcmVnZXhwL25vLXVzZWxlc3MtcXVhbnRpZmllciAtLSB0ZXN0aW5nICovXG52YXIgY2FsbCQ2ID0gZnVuY3Rpb25DYWxsO1xudmFyIHVuY3VycnlUaGlzJDggPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIHRvU3RyaW5nJDIgPSB0b1N0cmluZyQ1O1xudmFyIHJlZ2V4cEZsYWdzID0gcmVnZXhwRmxhZ3MkMTtcbnZhciBzdGlja3lIZWxwZXJzJDEgPSByZWdleHBTdGlja3lIZWxwZXJzO1xudmFyIHNoYXJlZCA9IHNoYXJlZCQ0LmV4cG9ydHM7XG52YXIgY3JlYXRlJDEgPSBvYmplY3RDcmVhdGU7XG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSQzID0gaW50ZXJuYWxTdGF0ZS5nZXQ7XG52YXIgVU5TVVBQT1JURURfRE9UX0FMTCA9IHJlZ2V4cFVuc3VwcG9ydGVkRG90QWxsO1xudmFyIFVOU1VQUE9SVEVEX05DRyA9IHJlZ2V4cFVuc3VwcG9ydGVkTmNnO1xuXG52YXIgbmF0aXZlUmVwbGFjZSA9IHNoYXJlZCgnbmF0aXZlLXN0cmluZy1yZXBsYWNlJywgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlKTtcbnZhciBuYXRpdmVFeGVjID0gUmVnRXhwLnByb3RvdHlwZS5leGVjO1xudmFyIHBhdGNoZWRFeGVjID0gbmF0aXZlRXhlYztcbnZhciBjaGFyQXQkMiA9IHVuY3VycnlUaGlzJDgoJycuY2hhckF0KTtcbnZhciBpbmRleE9mID0gdW5jdXJyeVRoaXMkOCgnJy5pbmRleE9mKTtcbnZhciByZXBsYWNlID0gdW5jdXJyeVRoaXMkOCgnJy5yZXBsYWNlKTtcbnZhciBzdHJpbmdTbGljZSQyID0gdW5jdXJyeVRoaXMkOCgnJy5zbGljZSk7XG5cbnZhciBVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgcmUxID0gL2EvO1xuICB2YXIgcmUyID0gL2IqL2c7XG4gIGNhbGwkNihuYXRpdmVFeGVjLCByZTEsICdhJyk7XG4gIGNhbGwkNihuYXRpdmVFeGVjLCByZTIsICdhJyk7XG4gIHJldHVybiByZTEubGFzdEluZGV4ICE9PSAwIHx8IHJlMi5sYXN0SW5kZXggIT09IDA7XG59KSgpO1xuXG52YXIgVU5TVVBQT1JURURfWSQxID0gc3RpY2t5SGVscGVycyQxLkJST0tFTl9DQVJFVDtcblxuLy8gbm9ucGFydGljaXBhdGluZyBjYXB0dXJpbmcgZ3JvdXAsIGNvcGllZCBmcm9tIGVzNS1zaGltJ3MgU3RyaW5nI3NwbGl0IHBhdGNoLlxudmFyIE5QQ0dfSU5DTFVERUQgPSAvKCk/Py8uZXhlYygnJylbMV0gIT09IHVuZGVmaW5lZDtcblxudmFyIFBBVENIID0gVVBEQVRFU19MQVNUX0lOREVYX1dST05HIHx8IE5QQ0dfSU5DTFVERUQgfHwgVU5TVVBQT1JURURfWSQxIHx8IFVOU1VQUE9SVEVEX0RPVF9BTEwgfHwgVU5TVVBQT1JURURfTkNHO1xuXG5pZiAoUEFUQ0gpIHtcbiAgcGF0Y2hlZEV4ZWMgPSBmdW5jdGlvbiBleGVjKHN0cmluZykge1xuICAgIHZhciByZSA9IHRoaXM7XG4gICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSQzKHJlKTtcbiAgICB2YXIgc3RyID0gdG9TdHJpbmckMihzdHJpbmcpO1xuICAgIHZhciByYXcgPSBzdGF0ZS5yYXc7XG4gICAgdmFyIHJlc3VsdCwgcmVDb3B5LCBsYXN0SW5kZXgsIG1hdGNoLCBpLCBvYmplY3QsIGdyb3VwO1xuXG4gICAgaWYgKHJhdykge1xuICAgICAgcmF3Lmxhc3RJbmRleCA9IHJlLmxhc3RJbmRleDtcbiAgICAgIHJlc3VsdCA9IGNhbGwkNihwYXRjaGVkRXhlYywgcmF3LCBzdHIpO1xuICAgICAgcmUubGFzdEluZGV4ID0gcmF3Lmxhc3RJbmRleDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgdmFyIGdyb3VwcyA9IHN0YXRlLmdyb3VwcztcbiAgICB2YXIgc3RpY2t5ID0gVU5TVVBQT1JURURfWSQxICYmIHJlLnN0aWNreTtcbiAgICB2YXIgZmxhZ3MgPSBjYWxsJDYocmVnZXhwRmxhZ3MsIHJlKTtcbiAgICB2YXIgc291cmNlID0gcmUuc291cmNlO1xuICAgIHZhciBjaGFyc0FkZGVkID0gMDtcbiAgICB2YXIgc3RyQ29weSA9IHN0cjtcblxuICAgIGlmIChzdGlja3kpIHtcbiAgICAgIGZsYWdzID0gcmVwbGFjZShmbGFncywgJ3knLCAnJyk7XG4gICAgICBpZiAoaW5kZXhPZihmbGFncywgJ2cnKSA9PT0gLTEpIHtcbiAgICAgICAgZmxhZ3MgKz0gJ2cnO1xuICAgICAgfVxuXG4gICAgICBzdHJDb3B5ID0gc3RyaW5nU2xpY2UkMihzdHIsIHJlLmxhc3RJbmRleCk7XG4gICAgICAvLyBTdXBwb3J0IGFuY2hvcmVkIHN0aWNreSBiZWhhdmlvci5cbiAgICAgIGlmIChyZS5sYXN0SW5kZXggPiAwICYmICghcmUubXVsdGlsaW5lIHx8IHJlLm11bHRpbGluZSAmJiBjaGFyQXQkMihzdHIsIHJlLmxhc3RJbmRleCAtIDEpICE9PSAnXFxuJykpIHtcbiAgICAgICAgc291cmNlID0gJyg/OiAnICsgc291cmNlICsgJyknO1xuICAgICAgICBzdHJDb3B5ID0gJyAnICsgc3RyQ29weTtcbiAgICAgICAgY2hhcnNBZGRlZCsrO1xuICAgICAgfVxuICAgICAgLy8gXig/ICsgcnggKyApIGlzIG5lZWRlZCwgaW4gY29tYmluYXRpb24gd2l0aCBzb21lIHN0ciBzbGljaW5nLCB0b1xuICAgICAgLy8gc2ltdWxhdGUgdGhlICd5JyBmbGFnLlxuICAgICAgcmVDb3B5ID0gbmV3IFJlZ0V4cCgnXig/OicgKyBzb3VyY2UgKyAnKScsIGZsYWdzKTtcbiAgICB9XG5cbiAgICBpZiAoTlBDR19JTkNMVURFRCkge1xuICAgICAgcmVDb3B5ID0gbmV3IFJlZ0V4cCgnXicgKyBzb3VyY2UgKyAnJCg/IVxcXFxzKScsIGZsYWdzKTtcbiAgICB9XG4gICAgaWYgKFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORykgbGFzdEluZGV4ID0gcmUubGFzdEluZGV4O1xuXG4gICAgbWF0Y2ggPSBjYWxsJDYobmF0aXZlRXhlYywgc3RpY2t5ID8gcmVDb3B5IDogcmUsIHN0ckNvcHkpO1xuXG4gICAgaWYgKHN0aWNreSkge1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIG1hdGNoLmlucHV0ID0gc3RyaW5nU2xpY2UkMihtYXRjaC5pbnB1dCwgY2hhcnNBZGRlZCk7XG4gICAgICAgIG1hdGNoWzBdID0gc3RyaW5nU2xpY2UkMihtYXRjaFswXSwgY2hhcnNBZGRlZCk7XG4gICAgICAgIG1hdGNoLmluZGV4ID0gcmUubGFzdEluZGV4O1xuICAgICAgICByZS5sYXN0SW5kZXggKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgfSBlbHNlIHJlLmxhc3RJbmRleCA9IDA7XG4gICAgfSBlbHNlIGlmIChVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcgJiYgbWF0Y2gpIHtcbiAgICAgIHJlLmxhc3RJbmRleCA9IHJlLmdsb2JhbCA/IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoIDogbGFzdEluZGV4O1xuICAgIH1cbiAgICBpZiAoTlBDR19JTkNMVURFRCAmJiBtYXRjaCAmJiBtYXRjaC5sZW5ndGggPiAxKSB7XG4gICAgICAvLyBGaXggYnJvd3NlcnMgd2hvc2UgYGV4ZWNgIG1ldGhvZHMgZG9uJ3QgY29uc2lzdGVudGx5IHJldHVybiBgdW5kZWZpbmVkYFxuICAgICAgLy8gZm9yIE5QQ0csIGxpa2UgSUU4LiBOT1RFOiBUaGlzIGRvZXNuJyB3b3JrIGZvciAvKC4/KT8vXG4gICAgICBjYWxsJDYobmF0aXZlUmVwbGFjZSwgbWF0Y2hbMF0sIHJlQ29weSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aCAtIDI7IGkrKykge1xuICAgICAgICAgIGlmIChhcmd1bWVudHNbaV0gPT09IHVuZGVmaW5lZCkgbWF0Y2hbaV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChtYXRjaCAmJiBncm91cHMpIHtcbiAgICAgIG1hdGNoLmdyb3VwcyA9IG9iamVjdCA9IGNyZWF0ZSQxKG51bGwpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBncm91cCA9IGdyb3Vwc1tpXTtcbiAgICAgICAgb2JqZWN0W2dyb3VwWzBdXSA9IG1hdGNoW2dyb3VwWzFdXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWF0Y2g7XG4gIH07XG59XG5cbnZhciByZWdleHBFeGVjJDMgPSBwYXRjaGVkRXhlYztcblxudmFyICQkMiA9IF9leHBvcnQ7XG52YXIgZXhlYyQxID0gcmVnZXhwRXhlYyQzO1xuXG4vLyBgUmVnRXhwLnByb3RvdHlwZS5leGVjYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcmVnZXhwLnByb3RvdHlwZS5leGVjXG4kJDIoeyB0YXJnZXQ6ICdSZWdFeHAnLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiAvLi8uZXhlYyAhPT0gZXhlYyQxIH0sIHtcbiAgZXhlYzogZXhlYyQxXG59KTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8tdXNlbGVzcy1lc2NhcGUgKi9cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYW1vbk9laGxtYW4vZGV0ZWN0LWJyb3dzZXIvYmxvYi9tYXN0ZXIvc3JjL2luZGV4LnRzXG5jb25zdCBTRUFSQ0hCT1hfVUFfUkVHRVggPSAvYWxleGF8Ym90fGNyYXdsKGVyfGluZyl8ZmFjZWJvb2tleHRlcm5hbGhpdHxmZWVkYnVybmVyfGdvb2dsZSB3ZWIgcHJldmlld3xuYWdpb3N8cG9zdHJhbmt8cGluZ2RvbXxzbHVycHxzcGlkZXJ8eWFob28hfHlhbmRleC87XG5jb25zdCB1c2VyQWdlbnRSdWxlcyA9IFtbXCJhb2xcIiwgL0FPTFNoaWVsZFxcLyhbMC05XFwuX10rKS9dLCBbXCJlZGdlXCIsIC9FZGdlXFwvKFswLTlcXC5fXSspL10sIFtcImVkZ2UtaW9zXCIsIC9FZGdpT1NcXC8oWzAtOVxcLl9dKykvXSwgW1wieWFuZGV4YnJvd3NlclwiLCAvWWFCcm93c2VyXFwvKFswLTlcXC5fXSspL10sIFtcImtha2FvdGFsa1wiLCAvS0FLQU9UQUxLXFxzKFswLTlcXC5dKykvXSwgW1wic2Ftc3VuZ1wiLCAvU2Ftc3VuZ0Jyb3dzZXJcXC8oWzAtOVxcLl0rKS9dLCBbXCJzaWxrXCIsIC9cXGJTaWxrXFwvKFswLTkuXy1dKylcXGIvXSwgW1wibWl1aVwiLCAvTWl1aUJyb3dzZXJcXC8oWzAtOVxcLl0rKSQvXSwgW1wiYmVha2VyXCIsIC9CZWFrZXJCcm93c2VyXFwvKFswLTlcXC5dKykvXSwgW1wiZWRnZS1jaHJvbWl1bVwiLCAvRWRnQT9cXC8oWzAtOVxcLl0rKS9dLCBbXCJjaHJvbWl1bS13ZWJ2aWV3XCIsIC8oPyFDaHJvbS4qT1BSKXd2XFwpLipDaHJvbSg/OmV8aXVtKVxcLyhbMC05XFwuXSspKDo/XFxzfCQpL10sIFtcImNocm9tZVwiLCAvKD8hQ2hyb20uKk9QUilDaHJvbSg/OmV8aXVtKVxcLyhbMC05XFwuXSspKDo/XFxzfCQpL10sIFtcInBoYW50b21qc1wiLCAvUGhhbnRvbUpTXFwvKFswLTlcXC5dKykoOj9cXHN8JCkvXSwgW1wiY3Jpb3NcIiwgL0NyaU9TXFwvKFswLTlcXC5dKykoOj9cXHN8JCkvXSwgW1wiZmlyZWZveFwiLCAvRmlyZWZveFxcLyhbMC05XFwuXSspKD86XFxzfCQpL10sIFtcImZ4aW9zXCIsIC9GeGlPU1xcLyhbMC05XFwuXSspL10sIFtcIm9wZXJhLW1pbmlcIiwgL09wZXJhIE1pbmkuKlZlcnNpb25cXC8oWzAtOVxcLl0rKS9dLCBbXCJvcGVyYVwiLCAvT3BlcmFcXC8oWzAtOVxcLl0rKSg/Olxcc3wkKS9dLCBbXCJvcGVyYVwiLCAvT1BSXFwvKFswLTlcXC5dKykoOj9cXHN8JCkvXSwgW1wicGllXCIsIC9eTWljcm9zb2Z0IFBvY2tldCBJbnRlcm5ldCBFeHBsb3JlclxcLyhcXGQrXFwuXFxkKykkL10sIFtcInBpZVwiLCAvXk1vemlsbGFcXC9cXGRcXC5cXGQrXFxzXFwoY29tcGF0aWJsZTtcXHMoPzpNU1A/SUV8TVNJbnRlcm5ldCBFeHBsb3JlcikgKFxcZCtcXC5cXGQrKTsuKldpbmRvd3MgQ0UuKlxcKSQvXSwgW1wibmV0ZnJvbnRcIiwgL15Nb3ppbGxhXFwvXFxkXFwuXFxkKy4qTmV0RnJvbnRcXC8oXFxkLlxcZCkvXSwgW1wiaWVcIiwgL1RyaWRlbnRcXC83XFwuMC4qcnZcXDooWzAtOVxcLl0rKS4qXFwpLipHZWNrbyQvXSwgW1wiaWVcIiwgL01TSUVcXHMoWzAtOVxcLl0rKTsuKlRyaWRlbnRcXC9bNC03XS4wL10sIFtcImllXCIsIC9NU0lFXFxzKDdcXC4wKS9dLCBbXCJiYjEwXCIsIC9CQjEwO1xcc1RvdWNoLipWZXJzaW9uXFwvKFswLTlcXC5dKykvXSwgW1wiYW5kcm9pZFwiLCAvQW5kcm9pZFxccyhbMC05XFwuXSspL10sIFtcImlvc1wiLCAvVmVyc2lvblxcLyhbMC05XFwuX10rKS4qTW9iaWxlLipTYWZhcmkuKi9dLCBbXCJzYWZhcmlcIiwgL1ZlcnNpb25cXC8oWzAtOVxcLl9dKykuKlNhZmFyaS9dLCBbXCJmYWNlYm9va1wiLCAvRkJbQVNdVlxcLyhbMC05XFwuXSspL10sIFtcImluc3RhZ3JhbVwiLCAvSW5zdGFncmFtXFxzKFswLTlcXC5dKykvXSwgW1wiaW9zLXdlYnZpZXdcIiwgL0FwcGxlV2ViS2l0XFwvKFswLTlcXC5dKykuKk1vYmlsZS9dLCBbXCJpb3Mtd2Vidmlld1wiLCAvQXBwbGVXZWJLaXRcXC8oWzAtOVxcLl0rKS4qR2Vja29cXCkkL10sIFtcImN1cmxcIiwgL15jdXJsXFwvKFswLTlcXC5dKykkL10sIFtcInNlYXJjaGJvdFwiLCBTRUFSQ0hCT1hfVUFfUkVHRVhdXTtcbmNvbnN0IG1hdGNoVXNlckFnZW50ID0gdWEgPT4ge1xuICByZXR1cm4gdWEgIT09IFwiXCIgJiYgdXNlckFnZW50UnVsZXMucmVkdWNlKChtYXRjaGVkLCBbYnJvd3NlciwgcmVnZXhdKSA9PiB7XG4gICAgaWYgKG1hdGNoZWQpIHtcbiAgICAgIHJldHVybiBtYXRjaGVkO1xuICAgIH1cbiAgICBjb25zdCB1YU1hdGNoID0gcmVnZXguZXhlYyh1YSk7XG4gICAgcmV0dXJuICEhdWFNYXRjaCAmJiBbYnJvd3NlciwgdWFNYXRjaF07XG4gIH0sIGZhbHNlKTtcbn07XG5jb25zdCBpc0N1cnJlbnRCcm93c2VyU3VwcG9ydGVkID0gc3VwcG9ydGVkQnJvd3NlciA9PiB7XG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IG1hdGNoZWRSdWxlID0gbWF0Y2hVc2VyQWdlbnQobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIGlmICghbWF0Y2hlZFJ1bGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgW25hbWVdID0gbWF0Y2hlZFJ1bGU7XG4gIGlmIChuYW1lID09PSBcInNlYXJjaGJvdFwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiAhIXN1cHBvcnRlZEJyb3dzZXIuZmluZChpdGVtID0+IGl0ZW0gPT09IG5hbWUpO1xufTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tdHlwZWQtYXJyYXlzIC0tIHNhZmVcbnZhciBhcnJheUJ1ZmZlck5hdGl2ZSA9IHR5cGVvZiBBcnJheUJ1ZmZlciAhPSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgRGF0YVZpZXcgIT0gJ3VuZGVmaW5lZCc7XG5cbnZhciBOQVRJVkVfQVJSQVlfQlVGRkVSJDEgPSBhcnJheUJ1ZmZlck5hdGl2ZTtcbnZhciBERVNDUklQVE9SUyQyID0gZGVzY3JpcHRvcnM7XG52YXIgZ2xvYmFsJDcgPSBnbG9iYWwkdDtcbnZhciBpc0NhbGxhYmxlJDIgPSBpc0NhbGxhYmxlJG47XG52YXIgaXNPYmplY3QkNCA9IGlzT2JqZWN0JGQ7XG52YXIgaGFzT3duJDEgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIGNsYXNzb2YkNCA9IGNsYXNzb2YkOTtcbnZhciB0cnlUb1N0cmluZyA9IHRyeVRvU3RyaW5nJDU7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDMgPSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkODtcbnZhciBkZWZpbmVCdWlsdEluJDIgPSBkZWZpbmVCdWlsdEluJDg7XG52YXIgZGVmaW5lUHJvcGVydHkkMSA9IG9iamVjdERlZmluZVByb3BlcnR5LmY7XG52YXIgaXNQcm90b3R5cGVPZiQxID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbnZhciBnZXRQcm90b3R5cGVPZiQxID0gb2JqZWN0R2V0UHJvdG90eXBlT2Y7XG52YXIgc2V0UHJvdG90eXBlT2YkMyA9IG9iamVjdFNldFByb3RvdHlwZU9mO1xudmFyIHdlbGxLbm93blN5bWJvbCQyID0gd2VsbEtub3duU3ltYm9sJGo7XG52YXIgdWlkID0gdWlkJDM7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSQyID0gaW50ZXJuYWxTdGF0ZTtcblxudmFyIGVuZm9yY2VJbnRlcm5hbFN0YXRlJDEgPSBJbnRlcm5hbFN0YXRlTW9kdWxlJDIuZW5mb3JjZTtcbnZhciBnZXRJbnRlcm5hbFN0YXRlJDIgPSBJbnRlcm5hbFN0YXRlTW9kdWxlJDIuZ2V0O1xudmFyIEludDhBcnJheSQ0ID0gZ2xvYmFsJDcuSW50OEFycmF5O1xudmFyIEludDhBcnJheVByb3RvdHlwZSQxID0gSW50OEFycmF5JDQgJiYgSW50OEFycmF5JDQucHJvdG90eXBlO1xudmFyIFVpbnQ4Q2xhbXBlZEFycmF5JDEgPSBnbG9iYWwkNy5VaW50OENsYW1wZWRBcnJheTtcbnZhciBVaW50OENsYW1wZWRBcnJheVByb3RvdHlwZSA9IFVpbnQ4Q2xhbXBlZEFycmF5JDEgJiYgVWludDhDbGFtcGVkQXJyYXkkMS5wcm90b3R5cGU7XG52YXIgVHlwZWRBcnJheSQxID0gSW50OEFycmF5JDQgJiYgZ2V0UHJvdG90eXBlT2YkMShJbnQ4QXJyYXkkNCk7XG52YXIgVHlwZWRBcnJheVByb3RvdHlwZSQxID0gSW50OEFycmF5UHJvdG90eXBlJDEgJiYgZ2V0UHJvdG90eXBlT2YkMShJbnQ4QXJyYXlQcm90b3R5cGUkMSk7XG52YXIgT2JqZWN0UHJvdG90eXBlJDEgPSBPYmplY3QucHJvdG90eXBlO1xudmFyIFR5cGVFcnJvciQxID0gZ2xvYmFsJDcuVHlwZUVycm9yO1xuXG52YXIgVE9fU1RSSU5HX1RBRyA9IHdlbGxLbm93blN5bWJvbCQyKCd0b1N0cmluZ1RhZycpO1xudmFyIFRZUEVEX0FSUkFZX1RBRyQxID0gdWlkKCdUWVBFRF9BUlJBWV9UQUcnKTtcbnZhciBUWVBFRF9BUlJBWV9DT05TVFJVQ1RPUiA9ICdUeXBlZEFycmF5Q29uc3RydWN0b3InO1xuLy8gRml4aW5nIG5hdGl2ZSB0eXBlZCBhcnJheXMgaW4gT3BlcmEgUHJlc3RvIGNyYXNoZXMgdGhlIGJyb3dzZXIsIHNlZSAjNTk1XG52YXIgTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyQyID0gTkFUSVZFX0FSUkFZX0JVRkZFUiQxICYmICEhc2V0UHJvdG90eXBlT2YkMyAmJiBjbGFzc29mJDQoZ2xvYmFsJDcub3BlcmEpICE9PSAnT3BlcmEnO1xudmFyIFRZUEVEX0FSUkFZX1RBR19SRVFVSVJFRCA9IGZhbHNlO1xudmFyIE5BTUUsIENvbnN0cnVjdG9yLCBQcm90b3R5cGU7XG5cbnZhciBUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCA9IHtcbiAgSW50OEFycmF5OiAxLFxuICBVaW50OEFycmF5OiAxLFxuICBVaW50OENsYW1wZWRBcnJheTogMSxcbiAgSW50MTZBcnJheTogMixcbiAgVWludDE2QXJyYXk6IDIsXG4gIEludDMyQXJyYXk6IDQsXG4gIFVpbnQzMkFycmF5OiA0LFxuICBGbG9hdDMyQXJyYXk6IDQsXG4gIEZsb2F0NjRBcnJheTogOFxufTtcblxudmFyIEJpZ0ludEFycmF5Q29uc3RydWN0b3JzTGlzdCA9IHtcbiAgQmlnSW50NjRBcnJheTogOCxcbiAgQmlnVWludDY0QXJyYXk6IDhcbn07XG5cbnZhciBpc1ZpZXcgPSBmdW5jdGlvbiBpc1ZpZXcoaXQpIHtcbiAgaWYgKCFpc09iamVjdCQ0KGl0KSkgcmV0dXJuIGZhbHNlO1xuICB2YXIga2xhc3MgPSBjbGFzc29mJDQoaXQpO1xuICByZXR1cm4ga2xhc3MgPT09ICdEYXRhVmlldydcbiAgICB8fCBoYXNPd24kMShUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCwga2xhc3MpXG4gICAgfHwgaGFzT3duJDEoQmlnSW50QXJyYXlDb25zdHJ1Y3RvcnNMaXN0LCBrbGFzcyk7XG59O1xuXG52YXIgZ2V0VHlwZWRBcnJheUNvbnN0cnVjdG9yID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBwcm90byA9IGdldFByb3RvdHlwZU9mJDEoaXQpO1xuICBpZiAoIWlzT2JqZWN0JDQocHJvdG8pKSByZXR1cm47XG4gIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUkMihwcm90byk7XG4gIHJldHVybiAoc3RhdGUgJiYgaGFzT3duJDEoc3RhdGUsIFRZUEVEX0FSUkFZX0NPTlNUUlVDVE9SKSkgPyBzdGF0ZVtUWVBFRF9BUlJBWV9DT05TVFJVQ1RPUl0gOiBnZXRUeXBlZEFycmF5Q29uc3RydWN0b3IocHJvdG8pO1xufTtcblxudmFyIGlzVHlwZWRBcnJheSQxID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICghaXNPYmplY3QkNChpdCkpIHJldHVybiBmYWxzZTtcbiAgdmFyIGtsYXNzID0gY2xhc3NvZiQ0KGl0KTtcbiAgcmV0dXJuIGhhc093biQxKFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0LCBrbGFzcylcbiAgICB8fCBoYXNPd24kMShCaWdJbnRBcnJheUNvbnN0cnVjdG9yc0xpc3QsIGtsYXNzKTtcbn07XG5cbnZhciBhVHlwZWRBcnJheSQ0ID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpc1R5cGVkQXJyYXkkMShpdCkpIHJldHVybiBpdDtcbiAgdGhyb3cgVHlwZUVycm9yJDEoJ1RhcmdldCBpcyBub3QgYSB0eXBlZCBhcnJheScpO1xufTtcblxudmFyIGFUeXBlZEFycmF5Q29uc3RydWN0b3IkMiA9IGZ1bmN0aW9uIChDKSB7XG4gIGlmIChpc0NhbGxhYmxlJDIoQykgJiYgKCFzZXRQcm90b3R5cGVPZiQzIHx8IGlzUHJvdG90eXBlT2YkMShUeXBlZEFycmF5JDEsIEMpKSkgcmV0dXJuIEM7XG4gIHRocm93IFR5cGVFcnJvciQxKHRyeVRvU3RyaW5nKEMpICsgJyBpcyBub3QgYSB0eXBlZCBhcnJheSBjb25zdHJ1Y3RvcicpO1xufTtcblxudmFyIGV4cG9ydFR5cGVkQXJyYXlNZXRob2QkNCA9IGZ1bmN0aW9uIChLRVksIHByb3BlcnR5LCBmb3JjZWQsIG9wdGlvbnMpIHtcbiAgaWYgKCFERVNDUklQVE9SUyQyKSByZXR1cm47XG4gIGlmIChmb3JjZWQpIGZvciAodmFyIEFSUkFZIGluIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0KSB7XG4gICAgdmFyIFR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IGdsb2JhbCQ3W0FSUkFZXTtcbiAgICBpZiAoVHlwZWRBcnJheUNvbnN0cnVjdG9yICYmIGhhc093biQxKFR5cGVkQXJyYXlDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIEtFWSkpIHRyeSB7XG4gICAgICBkZWxldGUgVHlwZWRBcnJheUNvbnN0cnVjdG9yLnByb3RvdHlwZVtLRVldO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBvbGQgV2ViS2l0IGJ1ZyAtIHNvbWUgbWV0aG9kcyBhcmUgbm9uLWNvbmZpZ3VyYWJsZVxuICAgICAgdHJ5IHtcbiAgICAgICAgVHlwZWRBcnJheUNvbnN0cnVjdG9yLnByb3RvdHlwZVtLRVldID0gcHJvcGVydHk7XG4gICAgICB9IGNhdGNoIChlcnJvcjIpIHsgLyogZW1wdHkgKi8gfVxuICAgIH1cbiAgfVxuICBpZiAoIVR5cGVkQXJyYXlQcm90b3R5cGUkMVtLRVldIHx8IGZvcmNlZCkge1xuICAgIGRlZmluZUJ1aWx0SW4kMihUeXBlZEFycmF5UHJvdG90eXBlJDEsIEtFWSwgZm9yY2VkID8gcHJvcGVydHlcbiAgICAgIDogTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyQyICYmIEludDhBcnJheVByb3RvdHlwZSQxW0tFWV0gfHwgcHJvcGVydHksIG9wdGlvbnMpO1xuICB9XG59O1xuXG52YXIgZXhwb3J0VHlwZWRBcnJheVN0YXRpY01ldGhvZCQxID0gZnVuY3Rpb24gKEtFWSwgcHJvcGVydHksIGZvcmNlZCkge1xuICB2YXIgQVJSQVksIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcjtcbiAgaWYgKCFERVNDUklQVE9SUyQyKSByZXR1cm47XG4gIGlmIChzZXRQcm90b3R5cGVPZiQzKSB7XG4gICAgaWYgKGZvcmNlZCkgZm9yIChBUlJBWSBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCkge1xuICAgICAgVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gZ2xvYmFsJDdbQVJSQVldO1xuICAgICAgaWYgKFR5cGVkQXJyYXlDb25zdHJ1Y3RvciAmJiBoYXNPd24kMShUeXBlZEFycmF5Q29uc3RydWN0b3IsIEtFWSkpIHRyeSB7XG4gICAgICAgIGRlbGV0ZSBUeXBlZEFycmF5Q29uc3RydWN0b3JbS0VZXTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgICB9XG4gICAgaWYgKCFUeXBlZEFycmF5JDFbS0VZXSB8fCBmb3JjZWQpIHtcbiAgICAgIC8vIFY4IH4gQ2hyb21lIDQ5LTUwIGAlVHlwZWRBcnJheSVgIG1ldGhvZHMgYXJlIG5vbi13cml0YWJsZSBub24tY29uZmlndXJhYmxlXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZGVmaW5lQnVpbHRJbiQyKFR5cGVkQXJyYXkkMSwgS0VZLCBmb3JjZWQgPyBwcm9wZXJ0eSA6IE5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MkMiAmJiBUeXBlZEFycmF5JDFbS0VZXSB8fCBwcm9wZXJ0eSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gICAgfSBlbHNlIHJldHVybjtcbiAgfVxuICBmb3IgKEFSUkFZIGluIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0KSB7XG4gICAgVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gZ2xvYmFsJDdbQVJSQVldO1xuICAgIGlmIChUeXBlZEFycmF5Q29uc3RydWN0b3IgJiYgKCFUeXBlZEFycmF5Q29uc3RydWN0b3JbS0VZXSB8fCBmb3JjZWQpKSB7XG4gICAgICBkZWZpbmVCdWlsdEluJDIoVHlwZWRBcnJheUNvbnN0cnVjdG9yLCBLRVksIHByb3BlcnR5KTtcbiAgICB9XG4gIH1cbn07XG5cbmZvciAoTkFNRSBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCkge1xuICBDb25zdHJ1Y3RvciA9IGdsb2JhbCQ3W05BTUVdO1xuICBQcm90b3R5cGUgPSBDb25zdHJ1Y3RvciAmJiBDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIGlmIChQcm90b3R5cGUpIGVuZm9yY2VJbnRlcm5hbFN0YXRlJDEoUHJvdG90eXBlKVtUWVBFRF9BUlJBWV9DT05TVFJVQ1RPUl0gPSBDb25zdHJ1Y3RvcjtcbiAgZWxzZSBOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTJDIgPSBmYWxzZTtcbn1cblxuZm9yIChOQU1FIGluIEJpZ0ludEFycmF5Q29uc3RydWN0b3JzTGlzdCkge1xuICBDb25zdHJ1Y3RvciA9IGdsb2JhbCQ3W05BTUVdO1xuICBQcm90b3R5cGUgPSBDb25zdHJ1Y3RvciAmJiBDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIGlmIChQcm90b3R5cGUpIGVuZm9yY2VJbnRlcm5hbFN0YXRlJDEoUHJvdG90eXBlKVtUWVBFRF9BUlJBWV9DT05TVFJVQ1RPUl0gPSBDb25zdHJ1Y3Rvcjtcbn1cblxuLy8gV2ViS2l0IGJ1ZyAtIHR5cGVkIGFycmF5cyBjb25zdHJ1Y3RvcnMgcHJvdG90eXBlIGlzIE9iamVjdC5wcm90b3R5cGVcbmlmICghTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyQyIHx8ICFpc0NhbGxhYmxlJDIoVHlwZWRBcnJheSQxKSB8fCBUeXBlZEFycmF5JDEgPT09IEZ1bmN0aW9uLnByb3RvdHlwZSkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2hhZG93IC0tIHNhZmVcbiAgVHlwZWRBcnJheSQxID0gZnVuY3Rpb24gVHlwZWRBcnJheSgpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IkMSgnSW5jb3JyZWN0IGludm9jYXRpb24nKTtcbiAgfTtcbiAgaWYgKE5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MkMikgZm9yIChOQU1FIGluIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0KSB7XG4gICAgaWYgKGdsb2JhbCQ3W05BTUVdKSBzZXRQcm90b3R5cGVPZiQzKGdsb2JhbCQ3W05BTUVdLCBUeXBlZEFycmF5JDEpO1xuICB9XG59XG5cbmlmICghTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyQyIHx8ICFUeXBlZEFycmF5UHJvdG90eXBlJDEgfHwgVHlwZWRBcnJheVByb3RvdHlwZSQxID09PSBPYmplY3RQcm90b3R5cGUkMSkge1xuICBUeXBlZEFycmF5UHJvdG90eXBlJDEgPSBUeXBlZEFycmF5JDEucHJvdG90eXBlO1xuICBpZiAoTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyQyKSBmb3IgKE5BTUUgaW4gVHlwZWRBcnJheUNvbnN0cnVjdG9yc0xpc3QpIHtcbiAgICBpZiAoZ2xvYmFsJDdbTkFNRV0pIHNldFByb3RvdHlwZU9mJDMoZ2xvYmFsJDdbTkFNRV0ucHJvdG90eXBlLCBUeXBlZEFycmF5UHJvdG90eXBlJDEpO1xuICB9XG59XG5cbi8vIFdlYktpdCBidWcgLSBvbmUgbW9yZSBvYmplY3QgaW4gVWludDhDbGFtcGVkQXJyYXkgcHJvdG90eXBlIGNoYWluXG5pZiAoTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyQyICYmIGdldFByb3RvdHlwZU9mJDEoVWludDhDbGFtcGVkQXJyYXlQcm90b3R5cGUpICE9PSBUeXBlZEFycmF5UHJvdG90eXBlJDEpIHtcbiAgc2V0UHJvdG90eXBlT2YkMyhVaW50OENsYW1wZWRBcnJheVByb3RvdHlwZSwgVHlwZWRBcnJheVByb3RvdHlwZSQxKTtcbn1cblxuaWYgKERFU0NSSVBUT1JTJDIgJiYgIWhhc093biQxKFR5cGVkQXJyYXlQcm90b3R5cGUkMSwgVE9fU1RSSU5HX1RBRykpIHtcbiAgVFlQRURfQVJSQVlfVEFHX1JFUVVJUkVEID0gdHJ1ZTtcbiAgZGVmaW5lUHJvcGVydHkkMShUeXBlZEFycmF5UHJvdG90eXBlJDEsIFRPX1NUUklOR19UQUcsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0JDQodGhpcykgPyB0aGlzW1RZUEVEX0FSUkFZX1RBRyQxXSA6IHVuZGVmaW5lZDtcbiAgfSB9KTtcbiAgZm9yIChOQU1FIGluIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0KSBpZiAoZ2xvYmFsJDdbTkFNRV0pIHtcbiAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMyhnbG9iYWwkN1tOQU1FXSwgVFlQRURfQVJSQVlfVEFHJDEsIE5BTUUpO1xuICB9XG59XG5cbnZhciBhcnJheUJ1ZmZlclZpZXdDb3JlID0ge1xuICBOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTOiBOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTJDIsXG4gIFRZUEVEX0FSUkFZX1RBRzogVFlQRURfQVJSQVlfVEFHX1JFUVVJUkVEICYmIFRZUEVEX0FSUkFZX1RBRyQxLFxuICBhVHlwZWRBcnJheTogYVR5cGVkQXJyYXkkNCxcbiAgYVR5cGVkQXJyYXlDb25zdHJ1Y3RvcjogYVR5cGVkQXJyYXlDb25zdHJ1Y3RvciQyLFxuICBleHBvcnRUeXBlZEFycmF5TWV0aG9kOiBleHBvcnRUeXBlZEFycmF5TWV0aG9kJDQsXG4gIGV4cG9ydFR5cGVkQXJyYXlTdGF0aWNNZXRob2Q6IGV4cG9ydFR5cGVkQXJyYXlTdGF0aWNNZXRob2QkMSxcbiAgZ2V0VHlwZWRBcnJheUNvbnN0cnVjdG9yOiBnZXRUeXBlZEFycmF5Q29uc3RydWN0b3IsXG4gIGlzVmlldzogaXNWaWV3LFxuICBpc1R5cGVkQXJyYXk6IGlzVHlwZWRBcnJheSQxLFxuICBUeXBlZEFycmF5OiBUeXBlZEFycmF5JDEsXG4gIFR5cGVkQXJyYXlQcm90b3R5cGU6IFR5cGVkQXJyYXlQcm90b3R5cGUkMVxufTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8tbmV3IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nICovXG5cbnZhciBnbG9iYWwkNiA9IGdsb2JhbCR0O1xudmFyIGZhaWxzJDggPSBmYWlscyRzO1xudmFyIGNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbiA9IGNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbiQyO1xudmFyIE5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MkMSA9IGFycmF5QnVmZmVyVmlld0NvcmUuTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUztcblxudmFyIEFycmF5QnVmZmVyJDMgPSBnbG9iYWwkNi5BcnJheUJ1ZmZlcjtcbnZhciBJbnQ4QXJyYXkkMyA9IGdsb2JhbCQ2LkludDhBcnJheTtcblxudmFyIHR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNSZXF1aXJlV3JhcHBlcnMgPSAhTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyQxIHx8ICFmYWlscyQ4KGZ1bmN0aW9uICgpIHtcbiAgSW50OEFycmF5JDMoMSk7XG59KSB8fCAhZmFpbHMkOChmdW5jdGlvbiAoKSB7XG4gIG5ldyBJbnQ4QXJyYXkkMygtMSk7XG59KSB8fCAhY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uKGZ1bmN0aW9uIChpdGVyYWJsZSkge1xuICBuZXcgSW50OEFycmF5JDMoKTtcbiAgbmV3IEludDhBcnJheSQzKG51bGwpO1xuICBuZXcgSW50OEFycmF5JDMoMS41KTtcbiAgbmV3IEludDhBcnJheSQzKGl0ZXJhYmxlKTtcbn0sIHRydWUpIHx8IGZhaWxzJDgoZnVuY3Rpb24gKCkge1xuICAvLyBTYWZhcmkgKDExKykgYnVnIC0gYSByZWFzb24gd2h5IGV2ZW4gU2FmYXJpIDEzIHNob3VsZCBsb2FkIGEgdHlwZWQgYXJyYXkgcG9seWZpbGxcbiAgcmV0dXJuIG5ldyBJbnQ4QXJyYXkkMyhuZXcgQXJyYXlCdWZmZXIkMygyKSwgMSwgdW5kZWZpbmVkKS5sZW5ndGggIT09IDE7XG59KTtcblxudmFyIGJpbmQkMSA9IGZ1bmN0aW9uQmluZENvbnRleHQ7XG52YXIgY2FsbCQ1ID0gZnVuY3Rpb25DYWxsO1xudmFyIGFDb25zdHJ1Y3RvciA9IGFDb25zdHJ1Y3RvciQyO1xudmFyIHRvT2JqZWN0JDIgPSB0b09iamVjdCQ3O1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlJDQgPSBsZW5ndGhPZkFycmF5TGlrZSQ4O1xudmFyIGdldEl0ZXJhdG9yID0gZ2V0SXRlcmF0b3IkMjtcbnZhciBnZXRJdGVyYXRvck1ldGhvZCA9IGdldEl0ZXJhdG9yTWV0aG9kJDM7XG52YXIgaXNBcnJheUl0ZXJhdG9yTWV0aG9kID0gaXNBcnJheUl0ZXJhdG9yTWV0aG9kJDI7XG52YXIgYVR5cGVkQXJyYXlDb25zdHJ1Y3RvciQxID0gYXJyYXlCdWZmZXJWaWV3Q29yZS5hVHlwZWRBcnJheUNvbnN0cnVjdG9yO1xuXG52YXIgdHlwZWRBcnJheUZyb20kMiA9IGZ1bmN0aW9uIGZyb20oc291cmNlIC8qICwgbWFwZm4sIHRoaXNBcmcgKi8pIHtcbiAgdmFyIEMgPSBhQ29uc3RydWN0b3IodGhpcyk7XG4gIHZhciBPID0gdG9PYmplY3QkMihzb3VyY2UpO1xuICB2YXIgYXJndW1lbnRzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIG1hcGZuID0gYXJndW1lbnRzTGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgdmFyIG1hcHBpbmcgPSBtYXBmbiAhPT0gdW5kZWZpbmVkO1xuICB2YXIgaXRlcmF0b3JNZXRob2QgPSBnZXRJdGVyYXRvck1ldGhvZChPKTtcbiAgdmFyIGksIGxlbmd0aCwgcmVzdWx0LCBzdGVwLCBpdGVyYXRvciwgbmV4dDtcbiAgaWYgKGl0ZXJhdG9yTWV0aG9kICYmICFpc0FycmF5SXRlcmF0b3JNZXRob2QoaXRlcmF0b3JNZXRob2QpKSB7XG4gICAgaXRlcmF0b3IgPSBnZXRJdGVyYXRvcihPLCBpdGVyYXRvck1ldGhvZCk7XG4gICAgbmV4dCA9IGl0ZXJhdG9yLm5leHQ7XG4gICAgTyA9IFtdO1xuICAgIHdoaWxlICghKHN0ZXAgPSBjYWxsJDUobmV4dCwgaXRlcmF0b3IpKS5kb25lKSB7XG4gICAgICBPLnB1c2goc3RlcC52YWx1ZSk7XG4gICAgfVxuICB9XG4gIGlmIChtYXBwaW5nICYmIGFyZ3VtZW50c0xlbmd0aCA+IDIpIHtcbiAgICBtYXBmbiA9IGJpbmQkMShtYXBmbiwgYXJndW1lbnRzWzJdKTtcbiAgfVxuICBsZW5ndGggPSBsZW5ndGhPZkFycmF5TGlrZSQ0KE8pO1xuICByZXN1bHQgPSBuZXcgKGFUeXBlZEFycmF5Q29uc3RydWN0b3IkMShDKSkobGVuZ3RoKTtcbiAgZm9yIChpID0gMDsgbGVuZ3RoID4gaTsgaSsrKSB7XG4gICAgcmVzdWx0W2ldID0gbWFwcGluZyA/IG1hcGZuKE9baV0sIGkpIDogT1tpXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxudmFyIFRZUEVEX0FSUkFZU19DT05TVFJVQ1RPUlNfUkVRVUlSRVNfV1JBUFBFUlMkMSA9IHR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNSZXF1aXJlV3JhcHBlcnM7XG52YXIgZXhwb3J0VHlwZWRBcnJheVN0YXRpY01ldGhvZCA9IGFycmF5QnVmZmVyVmlld0NvcmUuZXhwb3J0VHlwZWRBcnJheVN0YXRpY01ldGhvZDtcbnZhciB0eXBlZEFycmF5RnJvbSQxID0gdHlwZWRBcnJheUZyb20kMjtcblxuLy8gYCVUeXBlZEFycmF5JS5mcm9tYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLmZyb21cbmV4cG9ydFR5cGVkQXJyYXlTdGF0aWNNZXRob2QoJ2Zyb20nLCB0eXBlZEFycmF5RnJvbSQxLCBUWVBFRF9BUlJBWVNfQ09OU1RSVUNUT1JTX1JFUVVJUkVTX1dSQVBQRVJTJDEpO1xuXG52YXIgZGVmaW5lQnVpbHRJbiQxID0gZGVmaW5lQnVpbHRJbiQ4O1xuXG52YXIgZGVmaW5lQnVpbHRJbnMkMSA9IGZ1bmN0aW9uICh0YXJnZXQsIHNyYywgb3B0aW9ucykge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSBkZWZpbmVCdWlsdEluJDEodGFyZ2V0LCBrZXksIHNyY1trZXldLCBvcHRpb25zKTtcbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbnZhciB0b0ludGVnZXJPckluZmluaXR5JDMgPSB0b0ludGVnZXJPckluZmluaXR5JDY7XG52YXIgdG9MZW5ndGgkNCA9IHRvTGVuZ3RoJDY7XG5cbnZhciAkUmFuZ2VFcnJvciQyID0gUmFuZ2VFcnJvcjtcblxuLy8gYFRvSW5kZXhgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b2luZGV4XG52YXIgdG9JbmRleCQyID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gMDtcbiAgdmFyIG51bWJlciA9IHRvSW50ZWdlck9ySW5maW5pdHkkMyhpdCk7XG4gIHZhciBsZW5ndGggPSB0b0xlbmd0aCQ0KG51bWJlcik7XG4gIGlmIChudW1iZXIgIT09IGxlbmd0aCkgdGhyb3cgJFJhbmdlRXJyb3IkMignV3JvbmcgbGVuZ3RoIG9yIGluZGV4Jyk7XG4gIHJldHVybiBsZW5ndGg7XG59O1xuXG4vLyBJRUVFNzU0IGNvbnZlcnNpb25zIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvaWVlZTc1NFxudmFyICRBcnJheSQyID0gQXJyYXk7XG52YXIgYWJzID0gTWF0aC5hYnM7XG52YXIgcG93ID0gTWF0aC5wb3c7XG52YXIgZmxvb3IkMiA9IE1hdGguZmxvb3I7XG52YXIgbG9nID0gTWF0aC5sb2c7XG52YXIgTE4yID0gTWF0aC5MTjI7XG5cbnZhciBwYWNrID0gZnVuY3Rpb24gKG51bWJlciwgbWFudGlzc2FMZW5ndGgsIGJ5dGVzKSB7XG4gIHZhciBidWZmZXIgPSAkQXJyYXkkMihieXRlcyk7XG4gIHZhciBleHBvbmVudExlbmd0aCA9IGJ5dGVzICogOCAtIG1hbnRpc3NhTGVuZ3RoIC0gMTtcbiAgdmFyIGVNYXggPSAoMSA8PCBleHBvbmVudExlbmd0aCkgLSAxO1xuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDE7XG4gIHZhciBydCA9IG1hbnRpc3NhTGVuZ3RoID09PSAyMyA/IHBvdygyLCAtMjQpIC0gcG93KDIsIC03NykgOiAwO1xuICB2YXIgc2lnbiA9IG51bWJlciA8IDAgfHwgbnVtYmVyID09PSAwICYmIDEgLyBudW1iZXIgPCAwID8gMSA6IDA7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBleHBvbmVudCwgbWFudGlzc2EsIGM7XG4gIG51bWJlciA9IGFicyhudW1iZXIpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xuICBpZiAobnVtYmVyICE9IG51bWJlciB8fCBudW1iZXIgPT09IEluZmluaXR5KSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcbiAgICBtYW50aXNzYSA9IG51bWJlciAhPSBudW1iZXIgPyAxIDogMDtcbiAgICBleHBvbmVudCA9IGVNYXg7XG4gIH0gZWxzZSB7XG4gICAgZXhwb25lbnQgPSBmbG9vciQyKGxvZyhudW1iZXIpIC8gTE4yKTtcbiAgICBjID0gcG93KDIsIC1leHBvbmVudCk7XG4gICAgaWYgKG51bWJlciAqIGMgPCAxKSB7XG4gICAgICBleHBvbmVudC0tO1xuICAgICAgYyAqPSAyO1xuICAgIH1cbiAgICBpZiAoZXhwb25lbnQgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBudW1iZXIgKz0gcnQgLyBjO1xuICAgIH0gZWxzZSB7XG4gICAgICBudW1iZXIgKz0gcnQgKiBwb3coMiwgMSAtIGVCaWFzKTtcbiAgICB9XG4gICAgaWYgKG51bWJlciAqIGMgPj0gMikge1xuICAgICAgZXhwb25lbnQrKztcbiAgICAgIGMgLz0gMjtcbiAgICB9XG4gICAgaWYgKGV4cG9uZW50ICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbWFudGlzc2EgPSAwO1xuICAgICAgZXhwb25lbnQgPSBlTWF4O1xuICAgIH0gZWxzZSBpZiAoZXhwb25lbnQgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtYW50aXNzYSA9IChudW1iZXIgKiBjIC0gMSkgKiBwb3coMiwgbWFudGlzc2FMZW5ndGgpO1xuICAgICAgZXhwb25lbnQgPSBleHBvbmVudCArIGVCaWFzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYW50aXNzYSA9IG51bWJlciAqIHBvdygyLCBlQmlhcyAtIDEpICogcG93KDIsIG1hbnRpc3NhTGVuZ3RoKTtcbiAgICAgIGV4cG9uZW50ID0gMDtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKG1hbnRpc3NhTGVuZ3RoID49IDgpIHtcbiAgICBidWZmZXJbaW5kZXgrK10gPSBtYW50aXNzYSAmIDI1NTtcbiAgICBtYW50aXNzYSAvPSAyNTY7XG4gICAgbWFudGlzc2FMZW5ndGggLT0gODtcbiAgfVxuICBleHBvbmVudCA9IGV4cG9uZW50IDw8IG1hbnRpc3NhTGVuZ3RoIHwgbWFudGlzc2E7XG4gIGV4cG9uZW50TGVuZ3RoICs9IG1hbnRpc3NhTGVuZ3RoO1xuICB3aGlsZSAoZXhwb25lbnRMZW5ndGggPiAwKSB7XG4gICAgYnVmZmVyW2luZGV4KytdID0gZXhwb25lbnQgJiAyNTU7XG4gICAgZXhwb25lbnQgLz0gMjU2O1xuICAgIGV4cG9uZW50TGVuZ3RoIC09IDg7XG4gIH1cbiAgYnVmZmVyWy0taW5kZXhdIHw9IHNpZ24gKiAxMjg7XG4gIHJldHVybiBidWZmZXI7XG59O1xuXG52YXIgdW5wYWNrID0gZnVuY3Rpb24gKGJ1ZmZlciwgbWFudGlzc2FMZW5ndGgpIHtcbiAgdmFyIGJ5dGVzID0gYnVmZmVyLmxlbmd0aDtcbiAgdmFyIGV4cG9uZW50TGVuZ3RoID0gYnl0ZXMgKiA4IC0gbWFudGlzc2FMZW5ndGggLSAxO1xuICB2YXIgZU1heCA9ICgxIDw8IGV4cG9uZW50TGVuZ3RoKSAtIDE7XG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMTtcbiAgdmFyIG5CaXRzID0gZXhwb25lbnRMZW5ndGggLSA3O1xuICB2YXIgaW5kZXggPSBieXRlcyAtIDE7XG4gIHZhciBzaWduID0gYnVmZmVyW2luZGV4LS1dO1xuICB2YXIgZXhwb25lbnQgPSBzaWduICYgMTI3O1xuICB2YXIgbWFudGlzc2E7XG4gIHNpZ24gPj49IDc7XG4gIHdoaWxlIChuQml0cyA+IDApIHtcbiAgICBleHBvbmVudCA9IGV4cG9uZW50ICogMjU2ICsgYnVmZmVyW2luZGV4LS1dO1xuICAgIG5CaXRzIC09IDg7XG4gIH1cbiAgbWFudGlzc2EgPSBleHBvbmVudCAmICgxIDw8IC1uQml0cykgLSAxO1xuICBleHBvbmVudCA+Pj0gLW5CaXRzO1xuICBuQml0cyArPSBtYW50aXNzYUxlbmd0aDtcbiAgd2hpbGUgKG5CaXRzID4gMCkge1xuICAgIG1hbnRpc3NhID0gbWFudGlzc2EgKiAyNTYgKyBidWZmZXJbaW5kZXgtLV07XG4gICAgbkJpdHMgLT0gODtcbiAgfVxuICBpZiAoZXhwb25lbnQgPT09IDApIHtcbiAgICBleHBvbmVudCA9IDEgLSBlQmlhcztcbiAgfSBlbHNlIGlmIChleHBvbmVudCA9PT0gZU1heCkge1xuICAgIHJldHVybiBtYW50aXNzYSA/IE5hTiA6IHNpZ24gPyAtSW5maW5pdHkgOiBJbmZpbml0eTtcbiAgfSBlbHNlIHtcbiAgICBtYW50aXNzYSA9IG1hbnRpc3NhICsgcG93KDIsIG1hbnRpc3NhTGVuZ3RoKTtcbiAgICBleHBvbmVudCA9IGV4cG9uZW50IC0gZUJpYXM7XG4gIH0gcmV0dXJuIChzaWduID8gLTEgOiAxKSAqIG1hbnRpc3NhICogcG93KDIsIGV4cG9uZW50IC0gbWFudGlzc2FMZW5ndGgpO1xufTtcblxudmFyIGllZWU3NTQgPSB7XG4gIHBhY2s6IHBhY2ssXG4gIHVucGFjazogdW5wYWNrXG59O1xuXG52YXIgdG9PYmplY3QkMSA9IHRvT2JqZWN0JDc7XG52YXIgdG9BYnNvbHV0ZUluZGV4JDIgPSB0b0Fic29sdXRlSW5kZXgkNDtcbnZhciBsZW5ndGhPZkFycmF5TGlrZSQzID0gbGVuZ3RoT2ZBcnJheUxpa2UkODtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5maWxsYCBtZXRob2QgaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbGxcbnZhciBhcnJheUZpbGwkMSA9IGZ1bmN0aW9uIGZpbGwodmFsdWUgLyogLCBzdGFydCA9IDAsIGVuZCA9IEBsZW5ndGggKi8pIHtcbiAgdmFyIE8gPSB0b09iamVjdCQxKHRoaXMpO1xuICB2YXIgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UkMyhPKTtcbiAgdmFyIGFyZ3VtZW50c0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleCQyKGFyZ3VtZW50c0xlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIGxlbmd0aCk7XG4gIHZhciBlbmQgPSBhcmd1bWVudHNMZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICB2YXIgZW5kUG9zID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiB0b0Fic29sdXRlSW5kZXgkMihlbmQsIGxlbmd0aCk7XG4gIHdoaWxlIChlbmRQb3MgPiBpbmRleCkgT1tpbmRleCsrXSA9IHZhbHVlO1xuICByZXR1cm4gTztcbn07XG5cbnZhciB0b1Byb3BlcnR5S2V5JDEgPSB0b1Byb3BlcnR5S2V5JDQ7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUkMSA9IG9iamVjdERlZmluZVByb3BlcnR5O1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQxID0gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDU7XG5cbnZhciBjcmVhdGVQcm9wZXJ0eSQxID0gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICB2YXIgcHJvcGVydHlLZXkgPSB0b1Byb3BlcnR5S2V5JDEoa2V5KTtcbiAgaWYgKHByb3BlcnR5S2V5IGluIG9iamVjdCkgZGVmaW5lUHJvcGVydHlNb2R1bGUkMS5mKG9iamVjdCwgcHJvcGVydHlLZXksIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQxKDAsIHZhbHVlKSk7XG4gIGVsc2Ugb2JqZWN0W3Byb3BlcnR5S2V5XSA9IHZhbHVlO1xufTtcblxudmFyIHRvQWJzb2x1dGVJbmRleCQxID0gdG9BYnNvbHV0ZUluZGV4JDQ7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UkMiA9IGxlbmd0aE9mQXJyYXlMaWtlJDg7XG52YXIgY3JlYXRlUHJvcGVydHkgPSBjcmVhdGVQcm9wZXJ0eSQxO1xuXG52YXIgJEFycmF5JDEgPSBBcnJheTtcbnZhciBtYXggPSBNYXRoLm1heDtcblxudmFyIGFycmF5U2xpY2VTaW1wbGUgPSBmdW5jdGlvbiAoTywgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UkMihPKTtcbiAgdmFyIGsgPSB0b0Fic29sdXRlSW5kZXgkMShzdGFydCwgbGVuZ3RoKTtcbiAgdmFyIGZpbiA9IHRvQWJzb2x1dGVJbmRleCQxKGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogZW5kLCBsZW5ndGgpO1xuICB2YXIgcmVzdWx0ID0gJEFycmF5JDEobWF4KGZpbiAtIGssIDApKTtcbiAgZm9yICh2YXIgbiA9IDA7IGsgPCBmaW47IGsrKywgbisrKSBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIG4sIE9ba10pO1xuICByZXN1bHQubGVuZ3RoID0gbjtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciBnbG9iYWwkNSA9IGdsb2JhbCR0O1xudmFyIHVuY3VycnlUaGlzJDcgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIERFU0NSSVBUT1JTJDEgPSBkZXNjcmlwdG9ycztcbnZhciBOQVRJVkVfQVJSQVlfQlVGRkVSID0gYXJyYXlCdWZmZXJOYXRpdmU7XG52YXIgRnVuY3Rpb25OYW1lID0gZnVuY3Rpb25OYW1lO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQyID0gY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDg7XG52YXIgZGVmaW5lQnVpbHRJbnMgPSBkZWZpbmVCdWlsdElucyQxO1xudmFyIGZhaWxzJDcgPSBmYWlscyRzO1xudmFyIGFuSW5zdGFuY2UkMSA9IGFuSW5zdGFuY2UkMztcbnZhciB0b0ludGVnZXJPckluZmluaXR5JDIgPSB0b0ludGVnZXJPckluZmluaXR5JDY7XG52YXIgdG9MZW5ndGgkMyA9IHRvTGVuZ3RoJDY7XG52YXIgdG9JbmRleCQxID0gdG9JbmRleCQyO1xudmFyIElFRUU3NTQgPSBpZWVlNzU0O1xudmFyIGdldFByb3RvdHlwZU9mID0gb2JqZWN0R2V0UHJvdG90eXBlT2Y7XG52YXIgc2V0UHJvdG90eXBlT2YkMiA9IG9iamVjdFNldFByb3RvdHlwZU9mO1xudmFyIGdldE93blByb3BlcnR5TmFtZXMkMSA9IG9iamVjdEdldE93blByb3BlcnR5TmFtZXMuZjtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IG9iamVjdERlZmluZVByb3BlcnR5LmY7XG52YXIgYXJyYXlGaWxsID0gYXJyYXlGaWxsJDE7XG52YXIgYXJyYXlTbGljZSQzID0gYXJyYXlTbGljZVNpbXBsZTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHNldFRvU3RyaW5nVGFnJDQ7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSQxID0gaW50ZXJuYWxTdGF0ZTtcblxudmFyIFBST1BFUl9GVU5DVElPTl9OQU1FID0gRnVuY3Rpb25OYW1lLlBST1BFUjtcbnZhciBDT05GSUdVUkFCTEVfRlVOQ1RJT05fTkFNRSA9IEZ1bmN0aW9uTmFtZS5DT05GSUdVUkFCTEU7XG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSQxID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQxLmdldDtcbnZhciBzZXRJbnRlcm5hbFN0YXRlJDEgPSBJbnRlcm5hbFN0YXRlTW9kdWxlJDEuc2V0O1xudmFyIEFSUkFZX0JVRkZFUiA9ICdBcnJheUJ1ZmZlcic7XG52YXIgREFUQV9WSUVXID0gJ0RhdGFWaWV3JztcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcbnZhciBXUk9OR19MRU5HVEgkMSA9ICdXcm9uZyBsZW5ndGgnO1xudmFyIFdST05HX0lOREVYID0gJ1dyb25nIGluZGV4JztcbnZhciBOYXRpdmVBcnJheUJ1ZmZlciA9IGdsb2JhbCQ1W0FSUkFZX0JVRkZFUl07XG52YXIgJEFycmF5QnVmZmVyID0gTmF0aXZlQXJyYXlCdWZmZXI7XG52YXIgQXJyYXlCdWZmZXJQcm90b3R5cGUkMSA9ICRBcnJheUJ1ZmZlciAmJiAkQXJyYXlCdWZmZXJbUFJPVE9UWVBFXTtcbnZhciAkRGF0YVZpZXcgPSBnbG9iYWwkNVtEQVRBX1ZJRVddO1xudmFyIERhdGFWaWV3UHJvdG90eXBlJDEgPSAkRGF0YVZpZXcgJiYgJERhdGFWaWV3W1BST1RPVFlQRV07XG52YXIgT2JqZWN0UHJvdG90eXBlID0gT2JqZWN0LnByb3RvdHlwZTtcbnZhciBBcnJheSQxID0gZ2xvYmFsJDUuQXJyYXk7XG52YXIgUmFuZ2VFcnJvciQzID0gZ2xvYmFsJDUuUmFuZ2VFcnJvcjtcbnZhciBmaWxsID0gdW5jdXJyeVRoaXMkNyhhcnJheUZpbGwpO1xudmFyIHJldmVyc2UgPSB1bmN1cnJ5VGhpcyQ3KFtdLnJldmVyc2UpO1xuXG52YXIgcGFja0lFRUU3NTQgPSBJRUVFNzU0LnBhY2s7XG52YXIgdW5wYWNrSUVFRTc1NCA9IElFRUU3NTQudW5wYWNrO1xuXG52YXIgcGFja0ludDggPSBmdW5jdGlvbiAobnVtYmVyKSB7XG4gIHJldHVybiBbbnVtYmVyICYgMHhGRl07XG59O1xuXG52YXIgcGFja0ludDE2ID0gZnVuY3Rpb24gKG51bWJlcikge1xuICByZXR1cm4gW251bWJlciAmIDB4RkYsIG51bWJlciA+PiA4ICYgMHhGRl07XG59O1xuXG52YXIgcGFja0ludDMyID0gZnVuY3Rpb24gKG51bWJlcikge1xuICByZXR1cm4gW251bWJlciAmIDB4RkYsIG51bWJlciA+PiA4ICYgMHhGRiwgbnVtYmVyID4+IDE2ICYgMHhGRiwgbnVtYmVyID4+IDI0ICYgMHhGRl07XG59O1xuXG52YXIgdW5wYWNrSW50MzIgPSBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gIHJldHVybiBidWZmZXJbM10gPDwgMjQgfCBidWZmZXJbMl0gPDwgMTYgfCBidWZmZXJbMV0gPDwgOCB8IGJ1ZmZlclswXTtcbn07XG5cbnZhciBwYWNrRmxvYXQzMiA9IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgcmV0dXJuIHBhY2tJRUVFNzU0KG51bWJlciwgMjMsIDQpO1xufTtcblxudmFyIHBhY2tGbG9hdDY0ID0gZnVuY3Rpb24gKG51bWJlcikge1xuICByZXR1cm4gcGFja0lFRUU3NTQobnVtYmVyLCA1MiwgOCk7XG59O1xuXG52YXIgYWRkR2V0dGVyJDEgPSBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIGtleSkge1xuICBkZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvcltQUk9UT1RZUEVdLCBrZXksIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBnZXRJbnRlcm5hbFN0YXRlJDEodGhpcylba2V5XTsgfSB9KTtcbn07XG5cbnZhciBnZXQgPSBmdW5jdGlvbiAodmlldywgY291bnQsIGluZGV4LCBpc0xpdHRsZUVuZGlhbikge1xuICB2YXIgaW50SW5kZXggPSB0b0luZGV4JDEoaW5kZXgpO1xuICB2YXIgc3RvcmUgPSBnZXRJbnRlcm5hbFN0YXRlJDEodmlldyk7XG4gIGlmIChpbnRJbmRleCArIGNvdW50ID4gc3RvcmUuYnl0ZUxlbmd0aCkgdGhyb3cgUmFuZ2VFcnJvciQzKFdST05HX0lOREVYKTtcbiAgdmFyIGJ5dGVzID0gZ2V0SW50ZXJuYWxTdGF0ZSQxKHN0b3JlLmJ1ZmZlcikuYnl0ZXM7XG4gIHZhciBzdGFydCA9IGludEluZGV4ICsgc3RvcmUuYnl0ZU9mZnNldDtcbiAgdmFyIHBhY2sgPSBhcnJheVNsaWNlJDMoYnl0ZXMsIHN0YXJ0LCBzdGFydCArIGNvdW50KTtcbiAgcmV0dXJuIGlzTGl0dGxlRW5kaWFuID8gcGFjayA6IHJldmVyc2UocGFjayk7XG59O1xuXG52YXIgc2V0ID0gZnVuY3Rpb24gKHZpZXcsIGNvdW50LCBpbmRleCwgY29udmVyc2lvbiwgdmFsdWUsIGlzTGl0dGxlRW5kaWFuKSB7XG4gIHZhciBpbnRJbmRleCA9IHRvSW5kZXgkMShpbmRleCk7XG4gIHZhciBzdG9yZSA9IGdldEludGVybmFsU3RhdGUkMSh2aWV3KTtcbiAgaWYgKGludEluZGV4ICsgY291bnQgPiBzdG9yZS5ieXRlTGVuZ3RoKSB0aHJvdyBSYW5nZUVycm9yJDMoV1JPTkdfSU5ERVgpO1xuICB2YXIgYnl0ZXMgPSBnZXRJbnRlcm5hbFN0YXRlJDEoc3RvcmUuYnVmZmVyKS5ieXRlcztcbiAgdmFyIHN0YXJ0ID0gaW50SW5kZXggKyBzdG9yZS5ieXRlT2Zmc2V0O1xuICB2YXIgcGFjayA9IGNvbnZlcnNpb24oK3ZhbHVlKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSBieXRlc1tzdGFydCArIGldID0gcGFja1tpc0xpdHRsZUVuZGlhbiA/IGkgOiBjb3VudCAtIGkgLSAxXTtcbn07XG5cbmlmICghTkFUSVZFX0FSUkFZX0JVRkZFUikge1xuICAkQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiBBcnJheUJ1ZmZlcihsZW5ndGgpIHtcbiAgICBhbkluc3RhbmNlJDEodGhpcywgQXJyYXlCdWZmZXJQcm90b3R5cGUkMSk7XG4gICAgdmFyIGJ5dGVMZW5ndGggPSB0b0luZGV4JDEobGVuZ3RoKTtcbiAgICBzZXRJbnRlcm5hbFN0YXRlJDEodGhpcywge1xuICAgICAgYnl0ZXM6IGZpbGwoQXJyYXkkMShieXRlTGVuZ3RoKSwgMCksXG4gICAgICBieXRlTGVuZ3RoOiBieXRlTGVuZ3RoXG4gICAgfSk7XG4gICAgaWYgKCFERVNDUklQVE9SUyQxKSB0aGlzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoO1xuICB9O1xuXG4gIEFycmF5QnVmZmVyUHJvdG90eXBlJDEgPSAkQXJyYXlCdWZmZXJbUFJPVE9UWVBFXTtcblxuICAkRGF0YVZpZXcgPSBmdW5jdGlvbiBEYXRhVmlldyhidWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpIHtcbiAgICBhbkluc3RhbmNlJDEodGhpcywgRGF0YVZpZXdQcm90b3R5cGUkMSk7XG4gICAgYW5JbnN0YW5jZSQxKGJ1ZmZlciwgQXJyYXlCdWZmZXJQcm90b3R5cGUkMSk7XG4gICAgdmFyIGJ1ZmZlckxlbmd0aCA9IGdldEludGVybmFsU3RhdGUkMShidWZmZXIpLmJ5dGVMZW5ndGg7XG4gICAgdmFyIG9mZnNldCA9IHRvSW50ZWdlck9ySW5maW5pdHkkMihieXRlT2Zmc2V0KTtcbiAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgPiBidWZmZXJMZW5ndGgpIHRocm93IFJhbmdlRXJyb3IkMygnV3Jvbmcgb2Zmc2V0Jyk7XG4gICAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPT09IHVuZGVmaW5lZCA/IGJ1ZmZlckxlbmd0aCAtIG9mZnNldCA6IHRvTGVuZ3RoJDMoYnl0ZUxlbmd0aCk7XG4gICAgaWYgKG9mZnNldCArIGJ5dGVMZW5ndGggPiBidWZmZXJMZW5ndGgpIHRocm93IFJhbmdlRXJyb3IkMyhXUk9OR19MRU5HVEgkMSk7XG4gICAgc2V0SW50ZXJuYWxTdGF0ZSQxKHRoaXMsIHtcbiAgICAgIGJ1ZmZlcjogYnVmZmVyLFxuICAgICAgYnl0ZUxlbmd0aDogYnl0ZUxlbmd0aCxcbiAgICAgIGJ5dGVPZmZzZXQ6IG9mZnNldFxuICAgIH0pO1xuICAgIGlmICghREVTQ1JJUFRPUlMkMSkge1xuICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgICB0aGlzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoO1xuICAgICAgdGhpcy5ieXRlT2Zmc2V0ID0gb2Zmc2V0O1xuICAgIH1cbiAgfTtcblxuICBEYXRhVmlld1Byb3RvdHlwZSQxID0gJERhdGFWaWV3W1BST1RPVFlQRV07XG5cbiAgaWYgKERFU0NSSVBUT1JTJDEpIHtcbiAgICBhZGRHZXR0ZXIkMSgkQXJyYXlCdWZmZXIsICdieXRlTGVuZ3RoJyk7XG4gICAgYWRkR2V0dGVyJDEoJERhdGFWaWV3LCAnYnVmZmVyJyk7XG4gICAgYWRkR2V0dGVyJDEoJERhdGFWaWV3LCAnYnl0ZUxlbmd0aCcpO1xuICAgIGFkZEdldHRlciQxKCREYXRhVmlldywgJ2J5dGVPZmZzZXQnKTtcbiAgfVxuXG4gIGRlZmluZUJ1aWx0SW5zKERhdGFWaWV3UHJvdG90eXBlJDEsIHtcbiAgICBnZXRJbnQ4OiBmdW5jdGlvbiBnZXRJbnQ4KGJ5dGVPZmZzZXQpIHtcbiAgICAgIHJldHVybiBnZXQodGhpcywgMSwgYnl0ZU9mZnNldClbMF0gPDwgMjQgPj4gMjQ7XG4gICAgfSxcbiAgICBnZXRVaW50ODogZnVuY3Rpb24gZ2V0VWludDgoYnl0ZU9mZnNldCkge1xuICAgICAgcmV0dXJuIGdldCh0aGlzLCAxLCBieXRlT2Zmc2V0KVswXTtcbiAgICB9LFxuICAgIGdldEludDE2OiBmdW5jdGlvbiBnZXRJbnQxNihieXRlT2Zmc2V0IC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICB2YXIgYnl0ZXMgPSBnZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgICAgcmV0dXJuIChieXRlc1sxXSA8PCA4IHwgYnl0ZXNbMF0pIDw8IDE2ID4+IDE2O1xuICAgIH0sXG4gICAgZ2V0VWludDE2OiBmdW5jdGlvbiBnZXRVaW50MTYoYnl0ZU9mZnNldCAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgdmFyIGJ5dGVzID0gZ2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICAgIHJldHVybiBieXRlc1sxXSA8PCA4IHwgYnl0ZXNbMF07XG4gICAgfSxcbiAgICBnZXRJbnQzMjogZnVuY3Rpb24gZ2V0SW50MzIoYnl0ZU9mZnNldCAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgcmV0dXJuIHVucGFja0ludDMyKGdldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCkpO1xuICAgIH0sXG4gICAgZ2V0VWludDMyOiBmdW5jdGlvbiBnZXRVaW50MzIoYnl0ZU9mZnNldCAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgcmV0dXJuIHVucGFja0ludDMyKGdldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCkpID4+PiAwO1xuICAgIH0sXG4gICAgZ2V0RmxvYXQzMjogZnVuY3Rpb24gZ2V0RmxvYXQzMihieXRlT2Zmc2V0IC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICByZXR1cm4gdW5wYWNrSUVFRTc1NChnZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpLCAyMyk7XG4gICAgfSxcbiAgICBnZXRGbG9hdDY0OiBmdW5jdGlvbiBnZXRGbG9hdDY0KGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHJldHVybiB1bnBhY2tJRUVFNzU0KGdldCh0aGlzLCA4LCBieXRlT2Zmc2V0LCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCksIDUyKTtcbiAgICB9LFxuICAgIHNldEludDg6IGZ1bmN0aW9uIHNldEludDgoYnl0ZU9mZnNldCwgdmFsdWUpIHtcbiAgICAgIHNldCh0aGlzLCAxLCBieXRlT2Zmc2V0LCBwYWNrSW50OCwgdmFsdWUpO1xuICAgIH0sXG4gICAgc2V0VWludDg6IGZ1bmN0aW9uIHNldFVpbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKSB7XG4gICAgICBzZXQodGhpcywgMSwgYnl0ZU9mZnNldCwgcGFja0ludDgsIHZhbHVlKTtcbiAgICB9LFxuICAgIHNldEludDE2OiBmdW5jdGlvbiBzZXRJbnQxNihieXRlT2Zmc2V0LCB2YWx1ZSAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgc2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIHBhY2tJbnQxNiwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIHNldFVpbnQxNjogZnVuY3Rpb24gc2V0VWludDE2KGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICBzZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgcGFja0ludDE2LCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgc2V0SW50MzI6IGZ1bmN0aW9uIHNldEludDMyKGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICBzZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgcGFja0ludDMyLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgc2V0VWludDMyOiBmdW5jdGlvbiBzZXRVaW50MzIoYnl0ZU9mZnNldCwgdmFsdWUgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHNldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBwYWNrSW50MzIsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBzZXRGbG9hdDMyOiBmdW5jdGlvbiBzZXRGbG9hdDMyKGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICBzZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgcGFja0Zsb2F0MzIsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBzZXRGbG9hdDY0OiBmdW5jdGlvbiBzZXRGbG9hdDY0KGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICBzZXQodGhpcywgOCwgYnl0ZU9mZnNldCwgcGFja0Zsb2F0NjQsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCk7XG4gICAgfVxuICB9KTtcbn0gZWxzZSB7XG4gIHZhciBJTkNPUlJFQ1RfQVJSQVlfQlVGRkVSX05BTUUgPSBQUk9QRVJfRlVOQ1RJT05fTkFNRSAmJiBOYXRpdmVBcnJheUJ1ZmZlci5uYW1lICE9PSBBUlJBWV9CVUZGRVI7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLW5ldyAtLSByZXF1aXJlZCBmb3IgdGVzdGluZyAqL1xuICBpZiAoIWZhaWxzJDcoZnVuY3Rpb24gKCkge1xuICAgIE5hdGl2ZUFycmF5QnVmZmVyKDEpO1xuICB9KSB8fCAhZmFpbHMkNyhmdW5jdGlvbiAoKSB7XG4gICAgbmV3IE5hdGl2ZUFycmF5QnVmZmVyKC0xKTtcbiAgfSkgfHwgZmFpbHMkNyhmdW5jdGlvbiAoKSB7XG4gICAgbmV3IE5hdGl2ZUFycmF5QnVmZmVyKCk7XG4gICAgbmV3IE5hdGl2ZUFycmF5QnVmZmVyKDEuNSk7XG4gICAgbmV3IE5hdGl2ZUFycmF5QnVmZmVyKE5hTik7XG4gICAgcmV0dXJuIElOQ09SUkVDVF9BUlJBWV9CVUZGRVJfTkFNRSAmJiAhQ09ORklHVVJBQkxFX0ZVTkNUSU9OX05BTUU7XG4gIH0pKSB7XG4gIC8qIGVzbGludC1lbmFibGUgbm8tbmV3IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nICovXG4gICAgJEFycmF5QnVmZmVyID0gZnVuY3Rpb24gQXJyYXlCdWZmZXIobGVuZ3RoKSB7XG4gICAgICBhbkluc3RhbmNlJDEodGhpcywgQXJyYXlCdWZmZXJQcm90b3R5cGUkMSk7XG4gICAgICByZXR1cm4gbmV3IE5hdGl2ZUFycmF5QnVmZmVyKHRvSW5kZXgkMShsZW5ndGgpKTtcbiAgICB9O1xuXG4gICAgJEFycmF5QnVmZmVyW1BST1RPVFlQRV0gPSBBcnJheUJ1ZmZlclByb3RvdHlwZSQxO1xuXG4gICAgZm9yICh2YXIga2V5cyA9IGdldE93blByb3BlcnR5TmFtZXMkMShOYXRpdmVBcnJheUJ1ZmZlciksIGogPSAwLCBrZXk7IGtleXMubGVuZ3RoID4gajspIHtcbiAgICAgIGlmICghKChrZXkgPSBrZXlzW2orK10pIGluICRBcnJheUJ1ZmZlcikpIHtcbiAgICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDIoJEFycmF5QnVmZmVyLCBrZXksIE5hdGl2ZUFycmF5QnVmZmVyW2tleV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIEFycmF5QnVmZmVyUHJvdG90eXBlJDEuY29uc3RydWN0b3IgPSAkQXJyYXlCdWZmZXI7XG4gIH0gZWxzZSBpZiAoSU5DT1JSRUNUX0FSUkFZX0JVRkZFUl9OQU1FICYmIENPTkZJR1VSQUJMRV9GVU5DVElPTl9OQU1FKSB7XG4gICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDIoTmF0aXZlQXJyYXlCdWZmZXIsICduYW1lJywgQVJSQVlfQlVGRkVSKTtcbiAgfVxuXG4gIC8vIFdlYktpdCBidWcgLSB0aGUgc2FtZSBwYXJlbnQgcHJvdG90eXBlIGZvciB0eXBlZCBhcnJheXMgYW5kIGRhdGEgdmlld1xuICBpZiAoc2V0UHJvdG90eXBlT2YkMiAmJiBnZXRQcm90b3R5cGVPZihEYXRhVmlld1Byb3RvdHlwZSQxKSAhPT0gT2JqZWN0UHJvdG90eXBlKSB7XG4gICAgc2V0UHJvdG90eXBlT2YkMihEYXRhVmlld1Byb3RvdHlwZSQxLCBPYmplY3RQcm90b3R5cGUpO1xuICB9XG5cbiAgLy8gaU9TIFNhZmFyaSA3LnggYnVnXG4gIHZhciB0ZXN0VmlldyA9IG5ldyAkRGF0YVZpZXcobmV3ICRBcnJheUJ1ZmZlcigyKSk7XG4gIHZhciAkc2V0SW50OCA9IHVuY3VycnlUaGlzJDcoRGF0YVZpZXdQcm90b3R5cGUkMS5zZXRJbnQ4KTtcbiAgdGVzdFZpZXcuc2V0SW50OCgwLCAyMTQ3NDgzNjQ4KTtcbiAgdGVzdFZpZXcuc2V0SW50OCgxLCAyMTQ3NDgzNjQ5KTtcbiAgaWYgKHRlc3RWaWV3LmdldEludDgoMCkgfHwgIXRlc3RWaWV3LmdldEludDgoMSkpIGRlZmluZUJ1aWx0SW5zKERhdGFWaWV3UHJvdG90eXBlJDEsIHtcbiAgICBzZXRJbnQ4OiBmdW5jdGlvbiBzZXRJbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKSB7XG4gICAgICAkc2V0SW50OCh0aGlzLCBieXRlT2Zmc2V0LCB2YWx1ZSA8PCAyNCA+PiAyNCk7XG4gICAgfSxcbiAgICBzZXRVaW50ODogZnVuY3Rpb24gc2V0VWludDgoYnl0ZU9mZnNldCwgdmFsdWUpIHtcbiAgICAgICRzZXRJbnQ4KHRoaXMsIGJ5dGVPZmZzZXQsIHZhbHVlIDw8IDI0ID4+IDI0KTtcbiAgICB9XG4gIH0sIHsgdW5zYWZlOiB0cnVlIH0pO1xufVxuXG5zZXRUb1N0cmluZ1RhZygkQXJyYXlCdWZmZXIsIEFSUkFZX0JVRkZFUik7XG5zZXRUb1N0cmluZ1RhZygkRGF0YVZpZXcsIERBVEFfVklFVyk7XG5cbnZhciBhcnJheUJ1ZmZlciA9IHtcbiAgQXJyYXlCdWZmZXI6ICRBcnJheUJ1ZmZlcixcbiAgRGF0YVZpZXc6ICREYXRhVmlld1xufTtcblxudmFyICQkMSA9IF9leHBvcnQ7XG52YXIgdW5jdXJyeVRoaXMkNiA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgZmFpbHMkNiA9IGZhaWxzJHM7XG52YXIgQXJyYXlCdWZmZXJNb2R1bGUkMSA9IGFycmF5QnVmZmVyO1xudmFyIGFuT2JqZWN0JDIgPSBhbk9iamVjdCRlO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHRvQWJzb2x1dGVJbmRleCQ0O1xudmFyIHRvTGVuZ3RoJDIgPSB0b0xlbmd0aCQ2O1xudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciQxID0gc3BlY2llc0NvbnN0cnVjdG9yJDM7XG5cbnZhciBBcnJheUJ1ZmZlciQyID0gQXJyYXlCdWZmZXJNb2R1bGUkMS5BcnJheUJ1ZmZlcjtcbnZhciBEYXRhVmlldyQyID0gQXJyYXlCdWZmZXJNb2R1bGUkMS5EYXRhVmlldztcbnZhciBEYXRhVmlld1Byb3RvdHlwZSA9IERhdGFWaWV3JDIucHJvdG90eXBlO1xudmFyIHVuJEFycmF5QnVmZmVyU2xpY2UgPSB1bmN1cnJ5VGhpcyQ2KEFycmF5QnVmZmVyJDIucHJvdG90eXBlLnNsaWNlKTtcbnZhciBnZXRVaW50OCA9IHVuY3VycnlUaGlzJDYoRGF0YVZpZXdQcm90b3R5cGUuZ2V0VWludDgpO1xudmFyIHNldFVpbnQ4ID0gdW5jdXJyeVRoaXMkNihEYXRhVmlld1Byb3RvdHlwZS5zZXRVaW50OCk7XG5cbnZhciBJTkNPUlJFQ1RfU0xJQ0UgPSBmYWlscyQ2KGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICFuZXcgQXJyYXlCdWZmZXIkMigyKS5zbGljZSgxLCB1bmRlZmluZWQpLmJ5dGVMZW5ndGg7XG59KTtcblxuLy8gYEFycmF5QnVmZmVyLnByb3RvdHlwZS5zbGljZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5YnVmZmVyLnByb3RvdHlwZS5zbGljZVxuJCQxKHsgdGFyZ2V0OiAnQXJyYXlCdWZmZXInLCBwcm90bzogdHJ1ZSwgdW5zYWZlOiB0cnVlLCBmb3JjZWQ6IElOQ09SUkVDVF9TTElDRSB9LCB7XG4gIHNsaWNlOiBmdW5jdGlvbiBzbGljZShzdGFydCwgZW5kKSB7XG4gICAgaWYgKHVuJEFycmF5QnVmZmVyU2xpY2UgJiYgZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB1biRBcnJheUJ1ZmZlclNsaWNlKGFuT2JqZWN0JDIodGhpcyksIHN0YXJ0KTsgLy8gRkYgZml4XG4gICAgfVxuICAgIHZhciBsZW5ndGggPSBhbk9iamVjdCQyKHRoaXMpLmJ5dGVMZW5ndGg7XG4gICAgdmFyIGZpcnN0ID0gdG9BYnNvbHV0ZUluZGV4KHN0YXJ0LCBsZW5ndGgpO1xuICAgIHZhciBmaW4gPSB0b0Fic29sdXRlSW5kZXgoZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiBlbmQsIGxlbmd0aCk7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyAoc3BlY2llc0NvbnN0cnVjdG9yJDEodGhpcywgQXJyYXlCdWZmZXIkMikpKHRvTGVuZ3RoJDIoZmluIC0gZmlyc3QpKTtcbiAgICB2YXIgdmlld1NvdXJjZSA9IG5ldyBEYXRhVmlldyQyKHRoaXMpO1xuICAgIHZhciB2aWV3VGFyZ2V0ID0gbmV3IERhdGFWaWV3JDIocmVzdWx0KTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHdoaWxlIChmaXJzdCA8IGZpbikge1xuICAgICAgc2V0VWludDgodmlld1RhcmdldCwgaW5kZXgrKywgZ2V0VWludDgodmlld1NvdXJjZSwgZmlyc3QrKykpO1xuICAgIH0gcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG5cbnZhciB0eXBlZEFycmF5Q29uc3RydWN0b3IgPSB7ZXhwb3J0czoge319O1xuXG52YXIgaXNPYmplY3QkMyA9IGlzT2JqZWN0JGQ7XG5cbnZhciBmbG9vciQxID0gTWF0aC5mbG9vcjtcblxuLy8gYElzSW50ZWdyYWxOdW1iZXJgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1pc2ludGVncmFsbnVtYmVyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1udW1iZXItaXNpbnRlZ2VyIC0tIHNhZmVcbnZhciBpc0ludGVncmFsTnVtYmVyJDEgPSBOdW1iZXIuaXNJbnRlZ2VyIHx8IGZ1bmN0aW9uIGlzSW50ZWdlcihpdCkge1xuICByZXR1cm4gIWlzT2JqZWN0JDMoaXQpICYmIGlzRmluaXRlKGl0KSAmJiBmbG9vciQxKGl0KSA9PT0gaXQ7XG59O1xuXG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSQxID0gdG9JbnRlZ2VyT3JJbmZpbml0eSQ2O1xuXG52YXIgJFJhbmdlRXJyb3IkMSA9IFJhbmdlRXJyb3I7XG5cbnZhciB0b1Bvc2l0aXZlSW50ZWdlciQxID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciByZXN1bHQgPSB0b0ludGVnZXJPckluZmluaXR5JDEoaXQpO1xuICBpZiAocmVzdWx0IDwgMCkgdGhyb3cgJFJhbmdlRXJyb3IkMShcIlRoZSBhcmd1bWVudCBjYW4ndCBiZSBsZXNzIHRoYW4gMFwiKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciB0b1Bvc2l0aXZlSW50ZWdlciA9IHRvUG9zaXRpdmVJbnRlZ2VyJDE7XG5cbnZhciAkUmFuZ2VFcnJvciA9IFJhbmdlRXJyb3I7XG5cbnZhciB0b09mZnNldCQyID0gZnVuY3Rpb24gKGl0LCBCWVRFUykge1xuICB2YXIgb2Zmc2V0ID0gdG9Qb3NpdGl2ZUludGVnZXIoaXQpO1xuICBpZiAob2Zmc2V0ICUgQllURVMpIHRocm93ICRSYW5nZUVycm9yKCdXcm9uZyBvZmZzZXQnKTtcbiAgcmV0dXJuIG9mZnNldDtcbn07XG5cbnZhciBjbGFzc29mJDMgPSBjbGFzc29mUmF3JDE7XG5cbi8vIGBJc0FycmF5YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaXNhcnJheVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tYXJyYXktaXNhcnJheSAtLSBzYWZlXG52YXIgaXNBcnJheSQxID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5KGFyZ3VtZW50KSB7XG4gIHJldHVybiBjbGFzc29mJDMoYXJndW1lbnQpID09ICdBcnJheSc7XG59O1xuXG52YXIgaXNBcnJheSA9IGlzQXJyYXkkMTtcbnZhciBpc0NvbnN0cnVjdG9yID0gaXNDb25zdHJ1Y3RvciQyO1xudmFyIGlzT2JqZWN0JDIgPSBpc09iamVjdCRkO1xudmFyIHdlbGxLbm93blN5bWJvbCQxID0gd2VsbEtub3duU3ltYm9sJGo7XG5cbnZhciBTUEVDSUVTJDEgPSB3ZWxsS25vd25TeW1ib2wkMSgnc3BlY2llcycpO1xudmFyICRBcnJheSA9IEFycmF5O1xuXG4vLyBhIHBhcnQgb2YgYEFycmF5U3BlY2llc0NyZWF0ZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5c3BlY2llc2NyZWF0ZVxudmFyIGFycmF5U3BlY2llc0NvbnN0cnVjdG9yJDEgPSBmdW5jdGlvbiAob3JpZ2luYWxBcnJheSkge1xuICB2YXIgQztcbiAgaWYgKGlzQXJyYXkob3JpZ2luYWxBcnJheSkpIHtcbiAgICBDID0gb3JpZ2luYWxBcnJheS5jb25zdHJ1Y3RvcjtcbiAgICAvLyBjcm9zcy1yZWFsbSBmYWxsYmFja1xuICAgIGlmIChpc0NvbnN0cnVjdG9yKEMpICYmIChDID09PSAkQXJyYXkgfHwgaXNBcnJheShDLnByb3RvdHlwZSkpKSBDID0gdW5kZWZpbmVkO1xuICAgIGVsc2UgaWYgKGlzT2JqZWN0JDIoQykpIHtcbiAgICAgIEMgPSBDW1NQRUNJRVMkMV07XG4gICAgICBpZiAoQyA9PT0gbnVsbCkgQyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gcmV0dXJuIEMgPT09IHVuZGVmaW5lZCA/ICRBcnJheSA6IEM7XG59O1xuXG52YXIgYXJyYXlTcGVjaWVzQ29uc3RydWN0b3IgPSBhcnJheVNwZWNpZXNDb25zdHJ1Y3RvciQxO1xuXG4vLyBgQXJyYXlTcGVjaWVzQ3JlYXRlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXlzcGVjaWVzY3JlYXRlXG52YXIgYXJyYXlTcGVjaWVzQ3JlYXRlJDEgPSBmdW5jdGlvbiAob3JpZ2luYWxBcnJheSwgbGVuZ3RoKSB7XG4gIHJldHVybiBuZXcgKGFycmF5U3BlY2llc0NvbnN0cnVjdG9yKG9yaWdpbmFsQXJyYXkpKShsZW5ndGggPT09IDAgPyAwIDogbGVuZ3RoKTtcbn07XG5cbnZhciBiaW5kID0gZnVuY3Rpb25CaW5kQ29udGV4dDtcbnZhciB1bmN1cnJ5VGhpcyQ1ID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBJbmRleGVkT2JqZWN0ID0gaW5kZXhlZE9iamVjdDtcbnZhciB0b09iamVjdCA9IHRvT2JqZWN0JDc7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UkMSA9IGxlbmd0aE9mQXJyYXlMaWtlJDg7XG52YXIgYXJyYXlTcGVjaWVzQ3JlYXRlID0gYXJyYXlTcGVjaWVzQ3JlYXRlJDE7XG5cbnZhciBwdXNoJDEgPSB1bmN1cnJ5VGhpcyQ1KFtdLnB1c2gpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLnsgZm9yRWFjaCwgbWFwLCBmaWx0ZXIsIHNvbWUsIGV2ZXJ5LCBmaW5kLCBmaW5kSW5kZXgsIGZpbHRlclJlamVjdCB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG52YXIgY3JlYXRlTWV0aG9kJDEgPSBmdW5jdGlvbiAoVFlQRSkge1xuICB2YXIgSVNfTUFQID0gVFlQRSA9PSAxO1xuICB2YXIgSVNfRklMVEVSID0gVFlQRSA9PSAyO1xuICB2YXIgSVNfU09NRSA9IFRZUEUgPT0gMztcbiAgdmFyIElTX0VWRVJZID0gVFlQRSA9PSA0O1xuICB2YXIgSVNfRklORF9JTkRFWCA9IFRZUEUgPT0gNjtcbiAgdmFyIElTX0ZJTFRFUl9SRUpFQ1QgPSBUWVBFID09IDc7XG4gIHZhciBOT19IT0xFUyA9IFRZUEUgPT0gNSB8fCBJU19GSU5EX0lOREVYO1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBjYWxsYmFja2ZuLCB0aGF0LCBzcGVjaWZpY0NyZWF0ZSkge1xuICAgIHZhciBPID0gdG9PYmplY3QoJHRoaXMpO1xuICAgIHZhciBzZWxmID0gSW5kZXhlZE9iamVjdChPKTtcbiAgICB2YXIgYm91bmRGdW5jdGlvbiA9IGJpbmQoY2FsbGJhY2tmbiwgdGhhdCk7XG4gICAgdmFyIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlJDEoc2VsZik7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgY3JlYXRlID0gc3BlY2lmaWNDcmVhdGUgfHwgYXJyYXlTcGVjaWVzQ3JlYXRlO1xuICAgIHZhciB0YXJnZXQgPSBJU19NQVAgPyBjcmVhdGUoJHRoaXMsIGxlbmd0aCkgOiBJU19GSUxURVIgfHwgSVNfRklMVEVSX1JFSkVDVCA/IGNyZWF0ZSgkdGhpcywgMCkgOiB1bmRlZmluZWQ7XG4gICAgdmFyIHZhbHVlLCByZXN1bHQ7XG4gICAgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIGlmIChOT19IT0xFUyB8fCBpbmRleCBpbiBzZWxmKSB7XG4gICAgICB2YWx1ZSA9IHNlbGZbaW5kZXhdO1xuICAgICAgcmVzdWx0ID0gYm91bmRGdW5jdGlvbih2YWx1ZSwgaW5kZXgsIE8pO1xuICAgICAgaWYgKFRZUEUpIHtcbiAgICAgICAgaWYgKElTX01BUCkgdGFyZ2V0W2luZGV4XSA9IHJlc3VsdDsgLy8gbWFwXG4gICAgICAgIGVsc2UgaWYgKHJlc3VsdCkgc3dpdGNoIChUWVBFKSB7XG4gICAgICAgICAgY2FzZSAzOiByZXR1cm4gdHJ1ZTsgICAgICAgICAgICAgIC8vIHNvbWVcbiAgICAgICAgICBjYXNlIDU6IHJldHVybiB2YWx1ZTsgICAgICAgICAgICAgLy8gZmluZFxuICAgICAgICAgIGNhc2UgNjogcmV0dXJuIGluZGV4OyAgICAgICAgICAgICAvLyBmaW5kSW5kZXhcbiAgICAgICAgICBjYXNlIDI6IHB1c2gkMSh0YXJnZXQsIHZhbHVlKTsgICAgICAvLyBmaWx0ZXJcbiAgICAgICAgfSBlbHNlIHN3aXRjaCAoVFlQRSkge1xuICAgICAgICAgIGNhc2UgNDogcmV0dXJuIGZhbHNlOyAgICAgICAgICAgICAvLyBldmVyeVxuICAgICAgICAgIGNhc2UgNzogcHVzaCQxKHRhcmdldCwgdmFsdWUpOyAgICAgIC8vIGZpbHRlclJlamVjdFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBJU19GSU5EX0lOREVYID8gLTEgOiBJU19TT01FIHx8IElTX0VWRVJZID8gSVNfRVZFUlkgOiB0YXJnZXQ7XG4gIH07XG59O1xuXG52YXIgYXJyYXlJdGVyYXRpb24gPSB7XG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZm9yRWFjaGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZvcmVhY2hcbiAgZm9yRWFjaDogY3JlYXRlTWV0aG9kJDEoMCksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUubWFwYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUubWFwXG4gIG1hcDogY3JlYXRlTWV0aG9kJDEoMSksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZmlsdGVyYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmlsdGVyXG4gIGZpbHRlcjogY3JlYXRlTWV0aG9kJDEoMiksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuc29tZWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnNvbWVcbiAgc29tZTogY3JlYXRlTWV0aG9kJDEoMyksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZXZlcnlgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5ldmVyeVxuICBldmVyeTogY3JlYXRlTWV0aG9kJDEoNCksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZmluZGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbmRcbiAgZmluZDogY3JlYXRlTWV0aG9kJDEoNSksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZmluZEluZGV4YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmluZEluZGV4XG4gIGZpbmRJbmRleDogY3JlYXRlTWV0aG9kJDEoNiksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZmlsdGVyUmVqZWN0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtYXJyYXktZmlsdGVyaW5nXG4gIGZpbHRlclJlamVjdDogY3JlYXRlTWV0aG9kJDEoNylcbn07XG5cbnZhciBpc0NhbGxhYmxlJDEgPSBpc0NhbGxhYmxlJG47XG52YXIgaXNPYmplY3QkMSA9IGlzT2JqZWN0JGQ7XG52YXIgc2V0UHJvdG90eXBlT2YkMSA9IG9iamVjdFNldFByb3RvdHlwZU9mO1xuXG4vLyBtYWtlcyBzdWJjbGFzc2luZyB3b3JrIGNvcnJlY3QgZm9yIHdyYXBwZWQgYnVpbHQtaW5zXG52YXIgaW5oZXJpdElmUmVxdWlyZWQkMSA9IGZ1bmN0aW9uICgkdGhpcywgZHVtbXksIFdyYXBwZXIpIHtcbiAgdmFyIE5ld1RhcmdldCwgTmV3VGFyZ2V0UHJvdG90eXBlO1xuICBpZiAoXG4gICAgLy8gaXQgY2FuIHdvcmsgb25seSB3aXRoIG5hdGl2ZSBgc2V0UHJvdG90eXBlT2ZgXG4gICAgc2V0UHJvdG90eXBlT2YkMSAmJlxuICAgIC8vIHdlIGhhdmVuJ3QgY29tcGxldGVseSBjb3JyZWN0IHByZS1FUzYgd2F5IGZvciBnZXR0aW5nIGBuZXcudGFyZ2V0YCwgc28gdXNlIHRoaXNcbiAgICBpc0NhbGxhYmxlJDEoTmV3VGFyZ2V0ID0gZHVtbXkuY29uc3RydWN0b3IpICYmXG4gICAgTmV3VGFyZ2V0ICE9PSBXcmFwcGVyICYmXG4gICAgaXNPYmplY3QkMShOZXdUYXJnZXRQcm90b3R5cGUgPSBOZXdUYXJnZXQucHJvdG90eXBlKSAmJlxuICAgIE5ld1RhcmdldFByb3RvdHlwZSAhPT0gV3JhcHBlci5wcm90b3R5cGVcbiAgKSBzZXRQcm90b3R5cGVPZiQxKCR0aGlzLCBOZXdUYXJnZXRQcm90b3R5cGUpO1xuICByZXR1cm4gJHRoaXM7XG59O1xuXG52YXIgJCA9IF9leHBvcnQ7XG52YXIgZ2xvYmFsJDQgPSBnbG9iYWwkdDtcbnZhciBjYWxsJDQgPSBmdW5jdGlvbkNhbGw7XG52YXIgREVTQ1JJUFRPUlMgPSBkZXNjcmlwdG9ycztcbnZhciBUWVBFRF9BUlJBWVNfQ09OU1RSVUNUT1JTX1JFUVVJUkVTX1dSQVBQRVJTID0gdHlwZWRBcnJheUNvbnN0cnVjdG9yc1JlcXVpcmVXcmFwcGVycztcbnZhciBBcnJheUJ1ZmZlclZpZXdDb3JlJDQgPSBhcnJheUJ1ZmZlclZpZXdDb3JlO1xudmFyIEFycmF5QnVmZmVyTW9kdWxlID0gYXJyYXlCdWZmZXI7XG52YXIgYW5JbnN0YW5jZSA9IGFuSW5zdGFuY2UkMztcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkNTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMSA9IGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ4O1xudmFyIGlzSW50ZWdyYWxOdW1iZXIgPSBpc0ludGVncmFsTnVtYmVyJDE7XG52YXIgdG9MZW5ndGgkMSA9IHRvTGVuZ3RoJDY7XG52YXIgdG9JbmRleCA9IHRvSW5kZXgkMjtcbnZhciB0b09mZnNldCQxID0gdG9PZmZzZXQkMjtcbnZhciB0b1Byb3BlcnR5S2V5ID0gdG9Qcm9wZXJ0eUtleSQ0O1xudmFyIGhhc093biA9IGhhc093blByb3BlcnR5XzE7XG52YXIgY2xhc3NvZiQyID0gY2xhc3NvZiQ5O1xudmFyIGlzT2JqZWN0ID0gaXNPYmplY3QkZDtcbnZhciBpc1N5bWJvbCA9IGlzU3ltYm9sJDM7XG52YXIgY3JlYXRlID0gb2JqZWN0Q3JlYXRlO1xudmFyIGlzUHJvdG90eXBlT2YgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xudmFyIHNldFByb3RvdHlwZU9mID0gb2JqZWN0U2V0UHJvdG90eXBlT2Y7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lcyA9IG9iamVjdEdldE93blByb3BlcnR5TmFtZXMuZjtcbnZhciB0eXBlZEFycmF5RnJvbSA9IHR5cGVkQXJyYXlGcm9tJDI7XG52YXIgZm9yRWFjaCA9IGFycmF5SXRlcmF0aW9uLmZvckVhY2g7XG52YXIgc2V0U3BlY2llcyA9IHNldFNwZWNpZXMkMjtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IG9iamVjdERlZmluZVByb3BlcnR5O1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZSA9IG9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gaW50ZXJuYWxTdGF0ZTtcbnZhciBpbmhlcml0SWZSZXF1aXJlZCA9IGluaGVyaXRJZlJlcXVpcmVkJDE7XG5cbnZhciBnZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXQ7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuc2V0O1xudmFyIGVuZm9yY2VJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5lbmZvcmNlO1xudmFyIG5hdGl2ZURlZmluZVByb3BlcnR5ID0gZGVmaW5lUHJvcGVydHlNb2R1bGUuZjtcbnZhciBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUuZjtcbnZhciByb3VuZCA9IE1hdGgucm91bmQ7XG52YXIgUmFuZ2VFcnJvciQyID0gZ2xvYmFsJDQuUmFuZ2VFcnJvcjtcbnZhciBBcnJheUJ1ZmZlciQxID0gQXJyYXlCdWZmZXJNb2R1bGUuQXJyYXlCdWZmZXI7XG52YXIgQXJyYXlCdWZmZXJQcm90b3R5cGUgPSBBcnJheUJ1ZmZlciQxLnByb3RvdHlwZTtcbnZhciBEYXRhVmlldyQxID0gQXJyYXlCdWZmZXJNb2R1bGUuRGF0YVZpZXc7XG52YXIgTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyA9IEFycmF5QnVmZmVyVmlld0NvcmUkNC5OQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTO1xudmFyIFRZUEVEX0FSUkFZX1RBRyA9IEFycmF5QnVmZmVyVmlld0NvcmUkNC5UWVBFRF9BUlJBWV9UQUc7XG52YXIgVHlwZWRBcnJheSA9IEFycmF5QnVmZmVyVmlld0NvcmUkNC5UeXBlZEFycmF5O1xudmFyIFR5cGVkQXJyYXlQcm90b3R5cGUgPSBBcnJheUJ1ZmZlclZpZXdDb3JlJDQuVHlwZWRBcnJheVByb3RvdHlwZTtcbnZhciBhVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gQXJyYXlCdWZmZXJWaWV3Q29yZSQ0LmFUeXBlZEFycmF5Q29uc3RydWN0b3I7XG52YXIgaXNUeXBlZEFycmF5ID0gQXJyYXlCdWZmZXJWaWV3Q29yZSQ0LmlzVHlwZWRBcnJheTtcbnZhciBCWVRFU19QRVJfRUxFTUVOVCA9ICdCWVRFU19QRVJfRUxFTUVOVCc7XG52YXIgV1JPTkdfTEVOR1RIID0gJ1dyb25nIGxlbmd0aCc7XG5cbnZhciBmcm9tTGlzdCA9IGZ1bmN0aW9uIChDLCBsaXN0KSB7XG4gIGFUeXBlZEFycmF5Q29uc3RydWN0b3IoQyk7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgdmFyIHJlc3VsdCA9IG5ldyBDKGxlbmd0aCk7XG4gIHdoaWxlIChsZW5ndGggPiBpbmRleCkgcmVzdWx0W2luZGV4XSA9IGxpc3RbaW5kZXgrK107XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgYWRkR2V0dGVyID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgbmF0aXZlRGVmaW5lUHJvcGVydHkoaXQsIGtleSwgeyBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKVtrZXldO1xuICB9IH0pO1xufTtcblxudmFyIGlzQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIGtsYXNzO1xuICByZXR1cm4gaXNQcm90b3R5cGVPZihBcnJheUJ1ZmZlclByb3RvdHlwZSwgaXQpIHx8IChrbGFzcyA9IGNsYXNzb2YkMihpdCkpID09ICdBcnJheUJ1ZmZlcicgfHwga2xhc3MgPT0gJ1NoYXJlZEFycmF5QnVmZmVyJztcbn07XG5cbnZhciBpc1R5cGVkQXJyYXlJbmRleCA9IGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xuICByZXR1cm4gaXNUeXBlZEFycmF5KHRhcmdldClcbiAgICAmJiAhaXNTeW1ib2woa2V5KVxuICAgICYmIGtleSBpbiB0YXJnZXRcbiAgICAmJiBpc0ludGVncmFsTnVtYmVyKCtrZXkpXG4gICAgJiYga2V5ID49IDA7XG59O1xuXG52YXIgd3JhcHBlZEdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkge1xuICBrZXkgPSB0b1Byb3BlcnR5S2V5KGtleSk7XG4gIHJldHVybiBpc1R5cGVkQXJyYXlJbmRleCh0YXJnZXQsIGtleSlcbiAgICA/IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigyLCB0YXJnZXRba2V5XSlcbiAgICA6IG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSk7XG59O1xuXG52YXIgd3JhcHBlZERlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGRlc2NyaXB0b3IpIHtcbiAga2V5ID0gdG9Qcm9wZXJ0eUtleShrZXkpO1xuICBpZiAoaXNUeXBlZEFycmF5SW5kZXgodGFyZ2V0LCBrZXkpXG4gICAgJiYgaXNPYmplY3QoZGVzY3JpcHRvcilcbiAgICAmJiBoYXNPd24oZGVzY3JpcHRvciwgJ3ZhbHVlJylcbiAgICAmJiAhaGFzT3duKGRlc2NyaXB0b3IsICdnZXQnKVxuICAgICYmICFoYXNPd24oZGVzY3JpcHRvciwgJ3NldCcpXG4gICAgLy8gVE9ETzogYWRkIHZhbGlkYXRpb24gZGVzY3JpcHRvciB3L28gY2FsbGluZyBhY2Nlc3NvcnNcbiAgICAmJiAhZGVzY3JpcHRvci5jb25maWd1cmFibGVcbiAgICAmJiAoIWhhc093bihkZXNjcmlwdG9yLCAnd3JpdGFibGUnKSB8fCBkZXNjcmlwdG9yLndyaXRhYmxlKVxuICAgICYmICghaGFzT3duKGRlc2NyaXB0b3IsICdlbnVtZXJhYmxlJykgfHwgZGVzY3JpcHRvci5lbnVtZXJhYmxlKVxuICApIHtcbiAgICB0YXJnZXRba2V5XSA9IGRlc2NyaXB0b3IudmFsdWU7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfSByZXR1cm4gbmF0aXZlRGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGRlc2NyaXB0b3IpO1xufTtcblxuaWYgKERFU0NSSVBUT1JTKSB7XG4gIGlmICghTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUykge1xuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZS5mID0gd3JhcHBlZEdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgICBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mID0gd3JhcHBlZERlZmluZVByb3BlcnR5O1xuICAgIGFkZEdldHRlcihUeXBlZEFycmF5UHJvdG90eXBlLCAnYnVmZmVyJyk7XG4gICAgYWRkR2V0dGVyKFR5cGVkQXJyYXlQcm90b3R5cGUsICdieXRlT2Zmc2V0Jyk7XG4gICAgYWRkR2V0dGVyKFR5cGVkQXJyYXlQcm90b3R5cGUsICdieXRlTGVuZ3RoJyk7XG4gICAgYWRkR2V0dGVyKFR5cGVkQXJyYXlQcm90b3R5cGUsICdsZW5ndGgnKTtcbiAgfVxuXG4gICQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6ICFOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTIH0sIHtcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6IHdyYXBwZWRHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXG4gICAgZGVmaW5lUHJvcGVydHk6IHdyYXBwZWREZWZpbmVQcm9wZXJ0eVxuICB9KTtcblxuICB0eXBlZEFycmF5Q29uc3RydWN0b3IuZXhwb3J0cyA9IGZ1bmN0aW9uIChUWVBFLCB3cmFwcGVyLCBDTEFNUEVEKSB7XG4gICAgdmFyIEJZVEVTID0gVFlQRS5tYXRjaCgvXFxkKyQvKVswXSAvIDg7XG4gICAgdmFyIENPTlNUUlVDVE9SX05BTUUgPSBUWVBFICsgKENMQU1QRUQgPyAnQ2xhbXBlZCcgOiAnJykgKyAnQXJyYXknO1xuICAgIHZhciBHRVRURVIgPSAnZ2V0JyArIFRZUEU7XG4gICAgdmFyIFNFVFRFUiA9ICdzZXQnICsgVFlQRTtcbiAgICB2YXIgTmF0aXZlVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gZ2xvYmFsJDRbQ09OU1RSVUNUT1JfTkFNRV07XG4gICAgdmFyIFR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IE5hdGl2ZVR5cGVkQXJyYXlDb25zdHJ1Y3RvcjtcbiAgICB2YXIgVHlwZWRBcnJheUNvbnN0cnVjdG9yUHJvdG90eXBlID0gVHlwZWRBcnJheUNvbnN0cnVjdG9yICYmIFR5cGVkQXJyYXlDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gICAgdmFyIGV4cG9ydGVkID0ge307XG5cbiAgICB2YXIgZ2V0dGVyID0gZnVuY3Rpb24gKHRoYXQsIGluZGV4KSB7XG4gICAgICB2YXIgZGF0YSA9IGdldEludGVybmFsU3RhdGUodGhhdCk7XG4gICAgICByZXR1cm4gZGF0YS52aWV3W0dFVFRFUl0oaW5kZXggKiBCWVRFUyArIGRhdGEuYnl0ZU9mZnNldCwgdHJ1ZSk7XG4gICAgfTtcblxuICAgIHZhciBzZXR0ZXIgPSBmdW5jdGlvbiAodGhhdCwgaW5kZXgsIHZhbHVlKSB7XG4gICAgICB2YXIgZGF0YSA9IGdldEludGVybmFsU3RhdGUodGhhdCk7XG4gICAgICBpZiAoQ0xBTVBFRCkgdmFsdWUgPSAodmFsdWUgPSByb3VuZCh2YWx1ZSkpIDwgMCA/IDAgOiB2YWx1ZSA+IDB4RkYgPyAweEZGIDogdmFsdWUgJiAweEZGO1xuICAgICAgZGF0YS52aWV3W1NFVFRFUl0oaW5kZXggKiBCWVRFUyArIGRhdGEuYnl0ZU9mZnNldCwgdmFsdWUsIHRydWUpO1xuICAgIH07XG5cbiAgICB2YXIgYWRkRWxlbWVudCA9IGZ1bmN0aW9uICh0aGF0LCBpbmRleCkge1xuICAgICAgbmF0aXZlRGVmaW5lUHJvcGVydHkodGhhdCwgaW5kZXgsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGdldHRlcih0aGlzLCBpbmRleCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHNldHRlcih0aGlzLCBpbmRleCwgdmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgaWYgKCFOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTKSB7XG4gICAgICBUeXBlZEFycmF5Q29uc3RydWN0b3IgPSB3cmFwcGVyKGZ1bmN0aW9uICh0aGF0LCBkYXRhLCBvZmZzZXQsICRsZW5ndGgpIHtcbiAgICAgICAgYW5JbnN0YW5jZSh0aGF0LCBUeXBlZEFycmF5Q29uc3RydWN0b3JQcm90b3R5cGUpO1xuICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICB2YXIgYnl0ZU9mZnNldCA9IDA7XG4gICAgICAgIHZhciBidWZmZXIsIGJ5dGVMZW5ndGgsIGxlbmd0aDtcbiAgICAgICAgaWYgKCFpc09iamVjdChkYXRhKSkge1xuICAgICAgICAgIGxlbmd0aCA9IHRvSW5kZXgoZGF0YSk7XG4gICAgICAgICAgYnl0ZUxlbmd0aCA9IGxlbmd0aCAqIEJZVEVTO1xuICAgICAgICAgIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlciQxKGJ5dGVMZW5ndGgpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXlCdWZmZXIoZGF0YSkpIHtcbiAgICAgICAgICBidWZmZXIgPSBkYXRhO1xuICAgICAgICAgIGJ5dGVPZmZzZXQgPSB0b09mZnNldCQxKG9mZnNldCwgQllURVMpO1xuICAgICAgICAgIHZhciAkbGVuID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgICAgIGlmICgkbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICgkbGVuICUgQllURVMpIHRocm93IFJhbmdlRXJyb3IkMihXUk9OR19MRU5HVEgpO1xuICAgICAgICAgICAgYnl0ZUxlbmd0aCA9ICRsZW4gLSBieXRlT2Zmc2V0O1xuICAgICAgICAgICAgaWYgKGJ5dGVMZW5ndGggPCAwKSB0aHJvdyBSYW5nZUVycm9yJDIoV1JPTkdfTEVOR1RIKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnl0ZUxlbmd0aCA9IHRvTGVuZ3RoJDEoJGxlbmd0aCkgKiBCWVRFUztcbiAgICAgICAgICAgIGlmIChieXRlTGVuZ3RoICsgYnl0ZU9mZnNldCA+ICRsZW4pIHRocm93IFJhbmdlRXJyb3IkMihXUk9OR19MRU5HVEgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZW5ndGggPSBieXRlTGVuZ3RoIC8gQllURVM7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNUeXBlZEFycmF5KGRhdGEpKSB7XG4gICAgICAgICAgcmV0dXJuIGZyb21MaXN0KFR5cGVkQXJyYXlDb25zdHJ1Y3RvciwgZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGwkNCh0eXBlZEFycmF5RnJvbSwgVHlwZWRBcnJheUNvbnN0cnVjdG9yLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRJbnRlcm5hbFN0YXRlKHRoYXQsIHtcbiAgICAgICAgICBidWZmZXI6IGJ1ZmZlcixcbiAgICAgICAgICBieXRlT2Zmc2V0OiBieXRlT2Zmc2V0LFxuICAgICAgICAgIGJ5dGVMZW5ndGg6IGJ5dGVMZW5ndGgsXG4gICAgICAgICAgbGVuZ3RoOiBsZW5ndGgsXG4gICAgICAgICAgdmlldzogbmV3IERhdGFWaWV3JDEoYnVmZmVyKVxuICAgICAgICB9KTtcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSBhZGRFbGVtZW50KHRoYXQsIGluZGV4KyspO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChzZXRQcm90b3R5cGVPZikgc2V0UHJvdG90eXBlT2YoVHlwZWRBcnJheUNvbnN0cnVjdG9yLCBUeXBlZEFycmF5KTtcbiAgICAgIFR5cGVkQXJyYXlDb25zdHJ1Y3RvclByb3RvdHlwZSA9IFR5cGVkQXJyYXlDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUoVHlwZWRBcnJheVByb3RvdHlwZSk7XG4gICAgfSBlbHNlIGlmIChUWVBFRF9BUlJBWVNfQ09OU1RSVUNUT1JTX1JFUVVJUkVTX1dSQVBQRVJTKSB7XG4gICAgICBUeXBlZEFycmF5Q29uc3RydWN0b3IgPSB3cmFwcGVyKGZ1bmN0aW9uIChkdW1teSwgZGF0YSwgdHlwZWRBcnJheU9mZnNldCwgJGxlbmd0aCkge1xuICAgICAgICBhbkluc3RhbmNlKGR1bW15LCBUeXBlZEFycmF5Q29uc3RydWN0b3JQcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gaW5oZXJpdElmUmVxdWlyZWQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICghaXNPYmplY3QoZGF0YSkpIHJldHVybiBuZXcgTmF0aXZlVHlwZWRBcnJheUNvbnN0cnVjdG9yKHRvSW5kZXgoZGF0YSkpO1xuICAgICAgICAgIGlmIChpc0FycmF5QnVmZmVyKGRhdGEpKSByZXR1cm4gJGxlbmd0aCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IG5ldyBOYXRpdmVUeXBlZEFycmF5Q29uc3RydWN0b3IoZGF0YSwgdG9PZmZzZXQkMSh0eXBlZEFycmF5T2Zmc2V0LCBCWVRFUyksICRsZW5ndGgpXG4gICAgICAgICAgICA6IHR5cGVkQXJyYXlPZmZzZXQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICA/IG5ldyBOYXRpdmVUeXBlZEFycmF5Q29uc3RydWN0b3IoZGF0YSwgdG9PZmZzZXQkMSh0eXBlZEFycmF5T2Zmc2V0LCBCWVRFUykpXG4gICAgICAgICAgICAgIDogbmV3IE5hdGl2ZVR5cGVkQXJyYXlDb25zdHJ1Y3RvcihkYXRhKTtcbiAgICAgICAgICBpZiAoaXNUeXBlZEFycmF5KGRhdGEpKSByZXR1cm4gZnJvbUxpc3QoVHlwZWRBcnJheUNvbnN0cnVjdG9yLCBkYXRhKTtcbiAgICAgICAgICByZXR1cm4gY2FsbCQ0KHR5cGVkQXJyYXlGcm9tLCBUeXBlZEFycmF5Q29uc3RydWN0b3IsIGRhdGEpO1xuICAgICAgICB9KCksIGR1bW15LCBUeXBlZEFycmF5Q29uc3RydWN0b3IpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChzZXRQcm90b3R5cGVPZikgc2V0UHJvdG90eXBlT2YoVHlwZWRBcnJheUNvbnN0cnVjdG9yLCBUeXBlZEFycmF5KTtcbiAgICAgIGZvckVhY2goZ2V0T3duUHJvcGVydHlOYW1lcyhOYXRpdmVUeXBlZEFycmF5Q29uc3RydWN0b3IpLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICghKGtleSBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3IpKSB7XG4gICAgICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDEoVHlwZWRBcnJheUNvbnN0cnVjdG9yLCBrZXksIE5hdGl2ZVR5cGVkQXJyYXlDb25zdHJ1Y3RvcltrZXldKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBUeXBlZEFycmF5Q29uc3RydWN0b3IucHJvdG90eXBlID0gVHlwZWRBcnJheUNvbnN0cnVjdG9yUHJvdG90eXBlO1xuICAgIH1cblxuICAgIGlmIChUeXBlZEFycmF5Q29uc3RydWN0b3JQcm90b3R5cGUuY29uc3RydWN0b3IgIT09IFR5cGVkQXJyYXlDb25zdHJ1Y3Rvcikge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDEoVHlwZWRBcnJheUNvbnN0cnVjdG9yUHJvdG90eXBlLCAnY29uc3RydWN0b3InLCBUeXBlZEFycmF5Q29uc3RydWN0b3IpO1xuICAgIH1cblxuICAgIGVuZm9yY2VJbnRlcm5hbFN0YXRlKFR5cGVkQXJyYXlDb25zdHJ1Y3RvclByb3RvdHlwZSkuVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gVHlwZWRBcnJheUNvbnN0cnVjdG9yO1xuXG4gICAgaWYgKFRZUEVEX0FSUkFZX1RBRykge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDEoVHlwZWRBcnJheUNvbnN0cnVjdG9yUHJvdG90eXBlLCBUWVBFRF9BUlJBWV9UQUcsIENPTlNUUlVDVE9SX05BTUUpO1xuICAgIH1cblxuICAgIHZhciBGT1JDRUQgPSBUeXBlZEFycmF5Q29uc3RydWN0b3IgIT0gTmF0aXZlVHlwZWRBcnJheUNvbnN0cnVjdG9yO1xuXG4gICAgZXhwb3J0ZWRbQ09OU1RSVUNUT1JfTkFNRV0gPSBUeXBlZEFycmF5Q29uc3RydWN0b3I7XG5cbiAgICAkKHsgZ2xvYmFsOiB0cnVlLCBjb25zdHJ1Y3RvcjogdHJ1ZSwgZm9yY2VkOiBGT1JDRUQsIHNoYW06ICFOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTIH0sIGV4cG9ydGVkKTtcblxuICAgIGlmICghKEJZVEVTX1BFUl9FTEVNRU5UIGluIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcikpIHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQxKFR5cGVkQXJyYXlDb25zdHJ1Y3RvciwgQllURVNfUEVSX0VMRU1FTlQsIEJZVEVTKTtcbiAgICB9XG5cbiAgICBpZiAoIShCWVRFU19QRVJfRUxFTUVOVCBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3JQcm90b3R5cGUpKSB7XG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMShUeXBlZEFycmF5Q29uc3RydWN0b3JQcm90b3R5cGUsIEJZVEVTX1BFUl9FTEVNRU5ULCBCWVRFUyk7XG4gICAgfVxuXG4gICAgc2V0U3BlY2llcyhDT05TVFJVQ1RPUl9OQU1FKTtcbiAgfTtcbn0gZWxzZSB0eXBlZEFycmF5Q29uc3RydWN0b3IuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcblxudmFyIGNyZWF0ZVR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IHR5cGVkQXJyYXlDb25zdHJ1Y3Rvci5leHBvcnRzO1xuXG4vLyBgVWludDhBcnJheWAgY29uc3RydWN0b3Jcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdHlwZWRhcnJheS1vYmplY3RzXG5jcmVhdGVUeXBlZEFycmF5Q29uc3RydWN0b3IoJ1VpbnQ4JywgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFVpbnQ4QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuXG52YXIgdG9QcmltaXRpdmUgPSB0b1ByaW1pdGl2ZSQyO1xuXG52YXIgJFR5cGVFcnJvciQxID0gVHlwZUVycm9yO1xuXG4vLyBgVG9CaWdJbnRgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b2JpZ2ludFxudmFyIHRvQmlnSW50JDEgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgdmFyIHByaW0gPSB0b1ByaW1pdGl2ZShhcmd1bWVudCwgJ251bWJlcicpO1xuICBpZiAodHlwZW9mIHByaW0gPT0gJ251bWJlcicpIHRocm93ICRUeXBlRXJyb3IkMShcIkNhbid0IGNvbnZlcnQgbnVtYmVyIHRvIGJpZ2ludFwiKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tYmlnaW50IC0tIHNhZmVcbiAgcmV0dXJuIEJpZ0ludChwcmltKTtcbn07XG5cbnZhciBBcnJheUJ1ZmZlclZpZXdDb3JlJDMgPSBhcnJheUJ1ZmZlclZpZXdDb3JlO1xudmFyICRmaWxsID0gYXJyYXlGaWxsJDE7XG52YXIgdG9CaWdJbnQgPSB0b0JpZ0ludCQxO1xudmFyIGNsYXNzb2YkMSA9IGNsYXNzb2YkOTtcbnZhciBjYWxsJDMgPSBmdW5jdGlvbkNhbGw7XG52YXIgdW5jdXJyeVRoaXMkNCA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgZmFpbHMkNSA9IGZhaWxzJHM7XG5cbnZhciBhVHlwZWRBcnJheSQzID0gQXJyYXlCdWZmZXJWaWV3Q29yZSQzLmFUeXBlZEFycmF5O1xudmFyIGV4cG9ydFR5cGVkQXJyYXlNZXRob2QkMyA9IEFycmF5QnVmZmVyVmlld0NvcmUkMy5leHBvcnRUeXBlZEFycmF5TWV0aG9kO1xudmFyIHNsaWNlID0gdW5jdXJyeVRoaXMkNCgnJy5zbGljZSk7XG5cbi8vIFY4IH4gQ2hyb21lIDwgNTksIFNhZmFyaSA8IDE0LjEsIEZGIDwgNTUsIEVkZ2UgPD0xOFxudmFyIENPTlZFUlNJT05fQlVHID0gZmFpbHMkNShmdW5jdGlvbiAoKSB7XG4gIHZhciBjb3VudCA9IDA7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLXR5cGVkLWFycmF5cyAtLSBzYWZlXG4gIG5ldyBJbnQ4QXJyYXkoMikuZmlsbCh7IHZhbHVlT2Y6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvdW50Kys7IH0gfSk7XG4gIHJldHVybiBjb3VudCAhPT0gMTtcbn0pO1xuXG4vLyBgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5maWxsYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS5maWxsXG5leHBvcnRUeXBlZEFycmF5TWV0aG9kJDMoJ2ZpbGwnLCBmdW5jdGlvbiBmaWxsKHZhbHVlIC8qICwgc3RhcnQsIGVuZCAqLykge1xuICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgYVR5cGVkQXJyYXkkMyh0aGlzKTtcbiAgdmFyIGFjdHVhbFZhbHVlID0gc2xpY2UoY2xhc3NvZiQxKHRoaXMpLCAwLCAzKSA9PT0gJ0JpZycgPyB0b0JpZ0ludCh2YWx1ZSkgOiArdmFsdWU7XG4gIHJldHVybiBjYWxsJDMoJGZpbGwsIHRoaXMsIGFjdHVhbFZhbHVlLCBsZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCBsZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkKTtcbn0sIENPTlZFUlNJT05fQlVHKTtcblxudmFyIGdsb2JhbCQzID0gZ2xvYmFsJHQ7XG52YXIgY2FsbCQyID0gZnVuY3Rpb25DYWxsO1xudmFyIEFycmF5QnVmZmVyVmlld0NvcmUkMiA9IGFycmF5QnVmZmVyVmlld0NvcmU7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UgPSBsZW5ndGhPZkFycmF5TGlrZSQ4O1xudmFyIHRvT2Zmc2V0ID0gdG9PZmZzZXQkMjtcbnZhciB0b0luZGV4ZWRPYmplY3QgPSB0b09iamVjdCQ3O1xudmFyIGZhaWxzJDQgPSBmYWlscyRzO1xuXG52YXIgUmFuZ2VFcnJvciQxID0gZ2xvYmFsJDMuUmFuZ2VFcnJvcjtcbnZhciBJbnQ4QXJyYXkkMiA9IGdsb2JhbCQzLkludDhBcnJheTtcbnZhciBJbnQ4QXJyYXlQcm90b3R5cGUgPSBJbnQ4QXJyYXkkMiAmJiBJbnQ4QXJyYXkkMi5wcm90b3R5cGU7XG52YXIgJHNldCA9IEludDhBcnJheVByb3RvdHlwZSAmJiBJbnQ4QXJyYXlQcm90b3R5cGUuc2V0O1xudmFyIGFUeXBlZEFycmF5JDIgPSBBcnJheUJ1ZmZlclZpZXdDb3JlJDIuYVR5cGVkQXJyYXk7XG52YXIgZXhwb3J0VHlwZWRBcnJheU1ldGhvZCQyID0gQXJyYXlCdWZmZXJWaWV3Q29yZSQyLmV4cG9ydFR5cGVkQXJyYXlNZXRob2Q7XG5cbnZhciBXT1JLU19XSVRIX09CSkVDVFNfQU5EX0dFRVJJQ19PTl9UWVBFRF9BUlJBWVMgPSAhZmFpbHMkNChmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLXR5cGVkLWFycmF5cyAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICB2YXIgYXJyYXkgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkoMik7XG4gIGNhbGwkMigkc2V0LCBhcnJheSwgeyBsZW5ndGg6IDEsIDA6IDMgfSwgMSk7XG4gIHJldHVybiBhcnJheVsxXSAhPT0gMztcbn0pO1xuXG4vLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0xMTI5NCBhbmQgb3RoZXJcbnZhciBUT19PQkpFQ1RfQlVHID0gV09SS1NfV0lUSF9PQkpFQ1RTX0FORF9HRUVSSUNfT05fVFlQRURfQVJSQVlTICYmIEFycmF5QnVmZmVyVmlld0NvcmUkMi5OQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTICYmIGZhaWxzJDQoZnVuY3Rpb24gKCkge1xuICB2YXIgYXJyYXkgPSBuZXcgSW50OEFycmF5JDIoMik7XG4gIGFycmF5LnNldCgxKTtcbiAgYXJyYXkuc2V0KCcyJywgMSk7XG4gIHJldHVybiBhcnJheVswXSAhPT0gMCB8fCBhcnJheVsxXSAhPT0gMjtcbn0pO1xuXG4vLyBgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5zZXRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0ldHlwZWRhcnJheSUucHJvdG90eXBlLnNldFxuZXhwb3J0VHlwZWRBcnJheU1ldGhvZCQyKCdzZXQnLCBmdW5jdGlvbiBzZXQoYXJyYXlMaWtlIC8qICwgb2Zmc2V0ICovKSB7XG4gIGFUeXBlZEFycmF5JDIodGhpcyk7XG4gIHZhciBvZmZzZXQgPSB0b09mZnNldChhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgMSk7XG4gIHZhciBzcmMgPSB0b0luZGV4ZWRPYmplY3QoYXJyYXlMaWtlKTtcbiAgaWYgKFdPUktTX1dJVEhfT0JKRUNUU19BTkRfR0VFUklDX09OX1RZUEVEX0FSUkFZUykgcmV0dXJuIGNhbGwkMigkc2V0LCB0aGlzLCBzcmMsIG9mZnNldCk7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgdmFyIGxlbiA9IGxlbmd0aE9mQXJyYXlMaWtlKHNyYyk7XG4gIHZhciBpbmRleCA9IDA7XG4gIGlmIChsZW4gKyBvZmZzZXQgPiBsZW5ndGgpIHRocm93IFJhbmdlRXJyb3IkMSgnV3JvbmcgbGVuZ3RoJyk7XG4gIHdoaWxlIChpbmRleCA8IGxlbikgdGhpc1tvZmZzZXQgKyBpbmRleF0gPSBzcmNbaW5kZXgrK107XG59LCAhV09SS1NfV0lUSF9PQkpFQ1RTX0FORF9HRUVSSUNfT05fVFlQRURfQVJSQVlTIHx8IFRPX09CSkVDVF9CVUcpO1xuXG52YXIgYXJyYXlTbGljZSQyID0gYXJyYXlTbGljZVNpbXBsZTtcblxudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcblxudmFyIG1lcmdlU29ydCA9IGZ1bmN0aW9uIChhcnJheSwgY29tcGFyZWZuKSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHZhciBtaWRkbGUgPSBmbG9vcihsZW5ndGggLyAyKTtcbiAgcmV0dXJuIGxlbmd0aCA8IDggPyBpbnNlcnRpb25Tb3J0KGFycmF5LCBjb21wYXJlZm4pIDogbWVyZ2UoXG4gICAgYXJyYXksXG4gICAgbWVyZ2VTb3J0KGFycmF5U2xpY2UkMihhcnJheSwgMCwgbWlkZGxlKSwgY29tcGFyZWZuKSxcbiAgICBtZXJnZVNvcnQoYXJyYXlTbGljZSQyKGFycmF5LCBtaWRkbGUpLCBjb21wYXJlZm4pLFxuICAgIGNvbXBhcmVmblxuICApO1xufTtcblxudmFyIGluc2VydGlvblNvcnQgPSBmdW5jdGlvbiAoYXJyYXksIGNvbXBhcmVmbikge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB2YXIgaSA9IDE7XG4gIHZhciBlbGVtZW50LCBqO1xuXG4gIHdoaWxlIChpIDwgbGVuZ3RoKSB7XG4gICAgaiA9IGk7XG4gICAgZWxlbWVudCA9IGFycmF5W2ldO1xuICAgIHdoaWxlIChqICYmIGNvbXBhcmVmbihhcnJheVtqIC0gMV0sIGVsZW1lbnQpID4gMCkge1xuICAgICAgYXJyYXlbal0gPSBhcnJheVstLWpdO1xuICAgIH1cbiAgICBpZiAoaiAhPT0gaSsrKSBhcnJheVtqXSA9IGVsZW1lbnQ7XG4gIH0gcmV0dXJuIGFycmF5O1xufTtcblxudmFyIG1lcmdlID0gZnVuY3Rpb24gKGFycmF5LCBsZWZ0LCByaWdodCwgY29tcGFyZWZuKSB7XG4gIHZhciBsbGVuZ3RoID0gbGVmdC5sZW5ndGg7XG4gIHZhciBybGVuZ3RoID0gcmlnaHQubGVuZ3RoO1xuICB2YXIgbGluZGV4ID0gMDtcbiAgdmFyIHJpbmRleCA9IDA7XG5cbiAgd2hpbGUgKGxpbmRleCA8IGxsZW5ndGggfHwgcmluZGV4IDwgcmxlbmd0aCkge1xuICAgIGFycmF5W2xpbmRleCArIHJpbmRleF0gPSAobGluZGV4IDwgbGxlbmd0aCAmJiByaW5kZXggPCBybGVuZ3RoKVxuICAgICAgPyBjb21wYXJlZm4obGVmdFtsaW5kZXhdLCByaWdodFtyaW5kZXhdKSA8PSAwID8gbGVmdFtsaW5kZXgrK10gOiByaWdodFtyaW5kZXgrK11cbiAgICAgIDogbGluZGV4IDwgbGxlbmd0aCA/IGxlZnRbbGluZGV4KytdIDogcmlnaHRbcmluZGV4KytdO1xuICB9IHJldHVybiBhcnJheTtcbn07XG5cbnZhciBhcnJheVNvcnQgPSBtZXJnZVNvcnQ7XG5cbnZhciB1c2VyQWdlbnQkMSA9IGVuZ2luZVVzZXJBZ2VudDtcblxudmFyIGZpcmVmb3ggPSB1c2VyQWdlbnQkMS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS9pKTtcblxudmFyIGVuZ2luZUZmVmVyc2lvbiA9ICEhZmlyZWZveCAmJiArZmlyZWZveFsxXTtcblxudmFyIFVBID0gZW5naW5lVXNlckFnZW50O1xuXG52YXIgZW5naW5lSXNJZU9yRWRnZSA9IC9NU0lFfFRyaWRlbnQvLnRlc3QoVUEpO1xuXG52YXIgdXNlckFnZW50ID0gZW5naW5lVXNlckFnZW50O1xuXG52YXIgd2Via2l0ID0gdXNlckFnZW50Lm1hdGNoKC9BcHBsZVdlYktpdFxcLyhcXGQrKVxcLi8pO1xuXG52YXIgZW5naW5lV2Via2l0VmVyc2lvbiA9ICEhd2Via2l0ICYmICt3ZWJraXRbMV07XG5cbnZhciBnbG9iYWwkMiA9IGdsb2JhbCR0O1xudmFyIHVuY3VycnlUaGlzJDMgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGZhaWxzJDMgPSBmYWlscyRzO1xudmFyIGFDYWxsYWJsZSA9IGFDYWxsYWJsZSQ5O1xudmFyIGludGVybmFsU29ydCA9IGFycmF5U29ydDtcbnZhciBBcnJheUJ1ZmZlclZpZXdDb3JlJDEgPSBhcnJheUJ1ZmZlclZpZXdDb3JlO1xudmFyIEZGID0gZW5naW5lRmZWZXJzaW9uO1xudmFyIElFX09SX0VER0UgPSBlbmdpbmVJc0llT3JFZGdlO1xudmFyIFY4ID0gZW5naW5lVjhWZXJzaW9uO1xudmFyIFdFQktJVCA9IGVuZ2luZVdlYmtpdFZlcnNpb247XG5cbnZhciBhVHlwZWRBcnJheSQxID0gQXJyYXlCdWZmZXJWaWV3Q29yZSQxLmFUeXBlZEFycmF5O1xudmFyIGV4cG9ydFR5cGVkQXJyYXlNZXRob2QkMSA9IEFycmF5QnVmZmVyVmlld0NvcmUkMS5leHBvcnRUeXBlZEFycmF5TWV0aG9kO1xudmFyIFVpbnQxNkFycmF5ID0gZ2xvYmFsJDIuVWludDE2QXJyYXk7XG52YXIgdW4kU29ydCA9IFVpbnQxNkFycmF5ICYmIHVuY3VycnlUaGlzJDMoVWludDE2QXJyYXkucHJvdG90eXBlLnNvcnQpO1xuXG4vLyBXZWJLaXRcbnZhciBBQ0NFUFRfSU5DT1JSRUNUX0FSR1VNRU5UUyA9ICEhdW4kU29ydCAmJiAhKGZhaWxzJDMoZnVuY3Rpb24gKCkge1xuICB1biRTb3J0KG5ldyBVaW50MTZBcnJheSgyKSwgbnVsbCk7XG59KSAmJiBmYWlscyQzKGZ1bmN0aW9uICgpIHtcbiAgdW4kU29ydChuZXcgVWludDE2QXJyYXkoMiksIHt9KTtcbn0pKTtcblxudmFyIFNUQUJMRV9TT1JUID0gISF1biRTb3J0ICYmICFmYWlscyQzKGZ1bmN0aW9uICgpIHtcbiAgLy8gZmVhdHVyZSBkZXRlY3Rpb24gY2FuIGJlIHRvbyBzbG93LCBzbyBjaGVjayBlbmdpbmVzIHZlcnNpb25zXG4gIGlmIChWOCkgcmV0dXJuIFY4IDwgNzQ7XG4gIGlmIChGRikgcmV0dXJuIEZGIDwgNjc7XG4gIGlmIChJRV9PUl9FREdFKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKFdFQktJVCkgcmV0dXJuIFdFQktJVCA8IDYwMjtcblxuICB2YXIgYXJyYXkgPSBuZXcgVWludDE2QXJyYXkoNTE2KTtcbiAgdmFyIGV4cGVjdGVkID0gQXJyYXkoNTE2KTtcbiAgdmFyIGluZGV4LCBtb2Q7XG5cbiAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgNTE2OyBpbmRleCsrKSB7XG4gICAgbW9kID0gaW5kZXggJSA0O1xuICAgIGFycmF5W2luZGV4XSA9IDUxNSAtIGluZGV4O1xuICAgIGV4cGVjdGVkW2luZGV4XSA9IGluZGV4IC0gMiAqIG1vZCArIDM7XG4gIH1cblxuICB1biRTb3J0KGFycmF5LCBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiAoYSAvIDQgfCAwKSAtIChiIC8gNCB8IDApO1xuICB9KTtcblxuICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCA1MTY7IGluZGV4KyspIHtcbiAgICBpZiAoYXJyYXlbaW5kZXhdICE9PSBleHBlY3RlZFtpbmRleF0pIHJldHVybiB0cnVlO1xuICB9XG59KTtcblxudmFyIGdldFNvcnRDb21wYXJlID0gZnVuY3Rpb24gKGNvbXBhcmVmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICBpZiAoY29tcGFyZWZuICE9PSB1bmRlZmluZWQpIHJldHVybiArY29tcGFyZWZuKHgsIHkpIHx8IDA7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcbiAgICBpZiAoeSAhPT0geSkgcmV0dXJuIC0xO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG4gICAgaWYgKHggIT09IHgpIHJldHVybiAxO1xuICAgIGlmICh4ID09PSAwICYmIHkgPT09IDApIHJldHVybiAxIC8geCA+IDAgJiYgMSAvIHkgPCAwID8gMSA6IC0xO1xuICAgIHJldHVybiB4ID4geTtcbiAgfTtcbn07XG5cbi8vIGAlVHlwZWRBcnJheSUucHJvdG90eXBlLnNvcnRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0ldHlwZWRhcnJheSUucHJvdG90eXBlLnNvcnRcbmV4cG9ydFR5cGVkQXJyYXlNZXRob2QkMSgnc29ydCcsIGZ1bmN0aW9uIHNvcnQoY29tcGFyZWZuKSB7XG4gIGlmIChjb21wYXJlZm4gIT09IHVuZGVmaW5lZCkgYUNhbGxhYmxlKGNvbXBhcmVmbik7XG4gIGlmIChTVEFCTEVfU09SVCkgcmV0dXJuIHVuJFNvcnQodGhpcywgY29tcGFyZWZuKTtcblxuICByZXR1cm4gaW50ZXJuYWxTb3J0KGFUeXBlZEFycmF5JDEodGhpcyksIGdldFNvcnRDb21wYXJlKGNvbXBhcmVmbikpO1xufSwgIVNUQUJMRV9TT1JUIHx8IEFDQ0VQVF9JTkNPUlJFQ1RfQVJHVU1FTlRTKTtcblxudmFyIGdsb2JhbCQxID0gZ2xvYmFsJHQ7XG52YXIgYXBwbHkkMSA9IGZ1bmN0aW9uQXBwbHk7XG52YXIgQXJyYXlCdWZmZXJWaWV3Q29yZSA9IGFycmF5QnVmZmVyVmlld0NvcmU7XG52YXIgZmFpbHMkMiA9IGZhaWxzJHM7XG52YXIgYXJyYXlTbGljZSQxID0gYXJyYXlTbGljZSQ1O1xuXG52YXIgSW50OEFycmF5JDEgPSBnbG9iYWwkMS5JbnQ4QXJyYXk7XG52YXIgYVR5cGVkQXJyYXkgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmFUeXBlZEFycmF5O1xudmFyIGV4cG9ydFR5cGVkQXJyYXlNZXRob2QgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmV4cG9ydFR5cGVkQXJyYXlNZXRob2Q7XG52YXIgJHRvTG9jYWxlU3RyaW5nID0gW10udG9Mb2NhbGVTdHJpbmc7XG5cbi8vIGlPUyBTYWZhcmkgNi54IGZhaWxzIGhlcmVcbnZhciBUT19MT0NBTEVfU1RSSU5HX0JVRyA9ICEhSW50OEFycmF5JDEgJiYgZmFpbHMkMihmdW5jdGlvbiAoKSB7XG4gICR0b0xvY2FsZVN0cmluZy5jYWxsKG5ldyBJbnQ4QXJyYXkkMSgxKSk7XG59KTtcblxudmFyIEZPUkNFRCA9IGZhaWxzJDIoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gWzEsIDJdLnRvTG9jYWxlU3RyaW5nKCkgIT0gbmV3IEludDhBcnJheSQxKFsxLCAyXSkudG9Mb2NhbGVTdHJpbmcoKTtcbn0pIHx8ICFmYWlscyQyKGZ1bmN0aW9uICgpIHtcbiAgSW50OEFycmF5JDEucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nLmNhbGwoWzEsIDJdKTtcbn0pO1xuXG4vLyBgJVR5cGVkQXJyYXklLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZ2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSV0eXBlZGFycmF5JS5wcm90b3R5cGUudG9sb2NhbGVzdHJpbmdcbmV4cG9ydFR5cGVkQXJyYXlNZXRob2QoJ3RvTG9jYWxlU3RyaW5nJywgZnVuY3Rpb24gdG9Mb2NhbGVTdHJpbmcoKSB7XG4gIHJldHVybiBhcHBseSQxKFxuICAgICR0b0xvY2FsZVN0cmluZyxcbiAgICBUT19MT0NBTEVfU1RSSU5HX0JVRyA/IGFycmF5U2xpY2UkMShhVHlwZWRBcnJheSh0aGlzKSkgOiBhVHlwZWRBcnJheSh0aGlzKSxcbiAgICBhcnJheVNsaWNlJDEoYXJndW1lbnRzKVxuICApO1xufSwgRk9SQ0VEKTtcblxuY2xhc3MgUGF5bG9hZCB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAvLyBUaGUgdGFnJ3MgdmFsdWUgaXMgYSBoYXJkY29kZWQgdmFsdWUgYXMgcGVyXG4gICAgLy8gZGVmaW5lZCBpbiB0aGUgTkVQIFtORVA0MTNdKGh0dHBzOi8vZ2l0aHViLmNvbS9uZWFyL05FUHMvYmxvYi9tYXN0ZXIvbmVwcy9uZXAtMDQxMy5tZClcbiAgICB0aGlzLnRhZyA9IDIxNDc0ODQwNjE7XG4gICAgdGhpcy5tZXNzYWdlID0gZGF0YS5tZXNzYWdlO1xuICAgIHRoaXMubm9uY2UgPSBkYXRhLm5vbmNlO1xuICAgIHRoaXMucmVjaXBpZW50ID0gZGF0YS5yZWNpcGllbnQ7XG4gICAgaWYgKGRhdGEuY2FsbGJhY2tVcmwpIHtcbiAgICAgIHRoaXMuY2FsbGJhY2tVcmwgPSBkYXRhLmNhbGxiYWNrVXJsO1xuICAgIH1cbiAgfVxufVxuY29uc3QgcGF5bG9hZFNjaGVtYSA9IG5ldyBNYXAoW1tQYXlsb2FkLCB7XG4gIGtpbmQ6IFwic3RydWN0XCIsXG4gIGZpZWxkczogW1tcInRhZ1wiLCBcInUzMlwiXSwgW1wibWVzc2FnZVwiLCBcInN0cmluZ1wiXSwgW1wibm9uY2VcIiwgWzMyXV0sIFtcInJlY2lwaWVudFwiLCBcInN0cmluZ1wiXSwgW1wiY2FsbGJhY2tVcmxcIiwge1xuICAgIGtpbmQ6IFwib3B0aW9uXCIsXG4gICAgdHlwZTogXCJzdHJpbmdcIlxuICB9XV1cbn1dXSk7XG5jb25zdCBzZXJpYWxpemVOZXA0MTMgPSBzaWduTWVzc2FnZVBhcmFtcyA9PiB7XG4gIGNvbnN0IHBheWxvYWQgPSBuZXcgUGF5bG9hZChPYmplY3QuYXNzaWduKHt9LCBzaWduTWVzc2FnZVBhcmFtcykpO1xuICByZXR1cm4gQnVmZmVyLmZyb20oYm9yc2guc2VyaWFsaXplKHBheWxvYWRTY2hlbWEsIHBheWxvYWQpKTtcbn07XG5cbmNvbnN0IHZlcmlmeVNpZ25hdHVyZSA9ICh7XG4gIHB1YmxpY0tleSxcbiAgc2lnbmF0dXJlLFxuICBtZXNzYWdlLFxuICBub25jZSxcbiAgcmVjaXBpZW50LFxuICBjYWxsYmFja1VybFxufSkgPT4ge1xuICAvLyBSZWNvbnN0cnVjdCB0aGUgcGF5bG9hZCB0aGF0IHdhcyAqKmFjdHVhbGx5IHNpZ25lZCoqXG4gIGNvbnN0IHBheWxvYWQgPSBuZXcgUGF5bG9hZCh7XG4gICAgbWVzc2FnZSxcbiAgICBub25jZSxcbiAgICByZWNpcGllbnQsXG4gICAgY2FsbGJhY2tVcmxcbiAgfSk7XG4gIC8vIFNlcmlhbGl6ZSBwYXlsb2FkIGJhc2VkIG9uIHBheWxvYWRTY2hlbWFcbiAgY29uc3QgYm9yc2hQYXlsb2FkID0gYm9yc2guc2VyaWFsaXplKHBheWxvYWRTY2hlbWEsIHBheWxvYWQpO1xuICAvLyBIYXNoIHRoZSBwYXlsb2FkIGFzIGluIHRoZSBORVAwNDEzIHJlZmVyZW5jZWQgZXhhbXBsZVxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbmVhci9ORVBzL2Jsb2IvbWFzdGVyL25lcHMvbmVwLTA0MTMubWQjcmVmZXJlbmNlc1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ2FnZGllei9uZWFyLWxvZ2luL2Jsb2IvbWFpbi9hdXRoZW50aWNhdGUvd2FsbGV0LWF1dGhlbnRpY2F0ZS5qcyNMMjFcbiAgY29uc3QgaGFzaGVkUGF5bG9hZCA9IFVpbnQ4QXJyYXkuZnJvbShqc1NoYTI1Ni5zaGEyNTYuYXJyYXkoYm9yc2hQYXlsb2FkKSk7XG4gIC8vIENvbnZlcnQgcmVhbCBzaWduYXR1cmUgdG8gYnVmZmVyIGJhc2U2NFxuICBjb25zdCByZWFsU2lnbmF0dXJlID0gQnVmZmVyLmZyb20oc2lnbmF0dXJlLCBcImJhc2U2NFwiKTtcbiAgY29uc3QgcGsgPSBuZWFyQVBJLnV0aWxzLlB1YmxpY0tleS5mcm9tKHB1YmxpY0tleSk7XG4gIC8vIFZlcmlmeSB0aGUgc2lnbmF0dXJlXG4gIHJldHVybiBway52ZXJpZnkoaGFzaGVkUGF5bG9hZCwgcmVhbFNpZ25hdHVyZSk7XG59O1xuY29uc3QgZmV0Y2hBbGxVc2VyS2V5cyA9ICh7XG4gIGFjY291bnRJZCxcbiAgbmV0d29yayxcbiAgcHVibGljS2V5XG59KSA9PiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgY29uc3QgcHJvdmlkZXIgPSBuZXcgbmVhckFQSS5wcm92aWRlcnMuSnNvblJwY1Byb3ZpZGVyKHtcbiAgICB1cmw6IG5ldHdvcmsubm9kZVVybFxuICB9KTtcbiAgY29uc3Qga2V5ID0geWllbGQgcHJvdmlkZXIucXVlcnkoe1xuICAgIHJlcXVlc3RfdHlwZTogXCJ2aWV3X2FjY2Vzc19rZXlcIixcbiAgICBhY2NvdW50X2lkOiBhY2NvdW50SWQsXG4gICAgZmluYWxpdHk6IFwiZmluYWxcIixcbiAgICBwdWJsaWNfa2V5OiBwdWJsaWNLZXlcbiAgfSk7XG4gIHJldHVybiBrZXk7XG59KTtcbmNvbnN0IHZlcmlmeUZ1bGxLZXlCZWxvbmdzVG9Vc2VyID0gKHtcbiAgcHVibGljS2V5LFxuICBhY2NvdW50SWQsXG4gIG5ldHdvcmtcbn0pID0+IF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICBjb25zdCB7XG4gICAgcGVybWlzc2lvblxuICB9ID0geWllbGQgZmV0Y2hBbGxVc2VyS2V5cyh7XG4gICAgYWNjb3VudElkLFxuICAgIG5ldHdvcmssXG4gICAgcHVibGljS2V5XG4gIH0pO1xuICByZXR1cm4gcGVybWlzc2lvbiA9PT0gXCJGdWxsQWNjZXNzXCI7XG59KTtcblxuLy8gVE9ETzogUmVtb3ZlIGZyb20gYGNvcmUtanNANGAgc2luY2UgaXQncyBtb3ZlZCB0byBlbnRyeSBwb2ludHNcblxudmFyIHVuY3VycnlUaGlzJDIgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGRlZmluZUJ1aWx0SW4gPSBkZWZpbmVCdWlsdEluJDg7XG52YXIgcmVnZXhwRXhlYyQyID0gcmVnZXhwRXhlYyQzO1xudmFyIGZhaWxzJDEgPSBmYWlscyRzO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHdlbGxLbm93blN5bWJvbCRqO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ4O1xuXG52YXIgU1BFQ0lFUyA9IHdlbGxLbm93blN5bWJvbCgnc3BlY2llcycpO1xudmFyIFJlZ0V4cFByb3RvdHlwZSA9IFJlZ0V4cC5wcm90b3R5cGU7XG5cbnZhciBmaXhSZWdleHBXZWxsS25vd25TeW1ib2xMb2dpYyA9IGZ1bmN0aW9uIChLRVksIGV4ZWMsIEZPUkNFRCwgU0hBTSkge1xuICB2YXIgU1lNQk9MID0gd2VsbEtub3duU3ltYm9sKEtFWSk7XG5cbiAgdmFyIERFTEVHQVRFU19UT19TWU1CT0wgPSAhZmFpbHMkMShmdW5jdGlvbiAoKSB7XG4gICAgLy8gU3RyaW5nIG1ldGhvZHMgY2FsbCBzeW1ib2wtbmFtZWQgUmVnRXAgbWV0aG9kc1xuICAgIHZhciBPID0ge307XG4gICAgT1tTWU1CT0xdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfTtcbiAgICByZXR1cm4gJydbS0VZXShPKSAhPSA3O1xuICB9KTtcblxuICB2YXIgREVMRUdBVEVTX1RPX0VYRUMgPSBERUxFR0FURVNfVE9fU1lNQk9MICYmICFmYWlscyQxKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBTeW1ib2wtbmFtZWQgUmVnRXhwIG1ldGhvZHMgY2FsbCAuZXhlY1xuICAgIHZhciBleGVjQ2FsbGVkID0gZmFsc2U7XG4gICAgdmFyIHJlID0gL2EvO1xuXG4gICAgaWYgKEtFWSA9PT0gJ3NwbGl0Jykge1xuICAgICAgLy8gV2UgY2FuJ3QgdXNlIHJlYWwgcmVnZXggaGVyZSBzaW5jZSBpdCBjYXVzZXMgZGVvcHRpbWl6YXRpb25cbiAgICAgIC8vIGFuZCBzZXJpb3VzIHBlcmZvcm1hbmNlIGRlZ3JhZGF0aW9uIGluIFY4XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMzA2XG4gICAgICByZSA9IHt9O1xuICAgICAgLy8gUmVnRXhwW0BAc3BsaXRdIGRvZXNuJ3QgY2FsbCB0aGUgcmVnZXgncyBleGVjIG1ldGhvZCwgYnV0IGZpcnN0IGNyZWF0ZXNcbiAgICAgIC8vIGEgbmV3IG9uZS4gV2UgbmVlZCB0byByZXR1cm4gdGhlIHBhdGNoZWQgcmVnZXggd2hlbiBjcmVhdGluZyB0aGUgbmV3IG9uZS5cbiAgICAgIHJlLmNvbnN0cnVjdG9yID0ge307XG4gICAgICByZS5jb25zdHJ1Y3RvcltTUEVDSUVTXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlOyB9O1xuICAgICAgcmUuZmxhZ3MgPSAnJztcbiAgICAgIHJlW1NZTUJPTF0gPSAvLi9bU1lNQk9MXTtcbiAgICB9XG5cbiAgICByZS5leGVjID0gZnVuY3Rpb24gKCkgeyBleGVjQ2FsbGVkID0gdHJ1ZTsgcmV0dXJuIG51bGw7IH07XG5cbiAgICByZVtTWU1CT0xdKCcnKTtcbiAgICByZXR1cm4gIWV4ZWNDYWxsZWQ7XG4gIH0pO1xuXG4gIGlmIChcbiAgICAhREVMRUdBVEVTX1RPX1NZTUJPTCB8fFxuICAgICFERUxFR0FURVNfVE9fRVhFQyB8fFxuICAgIEZPUkNFRFxuICApIHtcbiAgICB2YXIgdW5jdXJyaWVkTmF0aXZlUmVnRXhwTWV0aG9kID0gdW5jdXJyeVRoaXMkMigvLi9bU1lNQk9MXSk7XG4gICAgdmFyIG1ldGhvZHMgPSBleGVjKFNZTUJPTCwgJydbS0VZXSwgZnVuY3Rpb24gKG5hdGl2ZU1ldGhvZCwgcmVnZXhwLCBzdHIsIGFyZzIsIGZvcmNlU3RyaW5nTWV0aG9kKSB7XG4gICAgICB2YXIgdW5jdXJyaWVkTmF0aXZlTWV0aG9kID0gdW5jdXJyeVRoaXMkMihuYXRpdmVNZXRob2QpO1xuICAgICAgdmFyICRleGVjID0gcmVnZXhwLmV4ZWM7XG4gICAgICBpZiAoJGV4ZWMgPT09IHJlZ2V4cEV4ZWMkMiB8fCAkZXhlYyA9PT0gUmVnRXhwUHJvdG90eXBlLmV4ZWMpIHtcbiAgICAgICAgaWYgKERFTEVHQVRFU19UT19TWU1CT0wgJiYgIWZvcmNlU3RyaW5nTWV0aG9kKSB7XG4gICAgICAgICAgLy8gVGhlIG5hdGl2ZSBTdHJpbmcgbWV0aG9kIGFscmVhZHkgZGVsZWdhdGVzIHRvIEBAbWV0aG9kICh0aGlzXG4gICAgICAgICAgLy8gcG9seWZpbGxlZCBmdW5jdGlvbiksIGxlYXNpbmcgdG8gaW5maW5pdGUgcmVjdXJzaW9uLlxuICAgICAgICAgIC8vIFdlIGF2b2lkIGl0IGJ5IGRpcmVjdGx5IGNhbGxpbmcgdGhlIG5hdGl2ZSBAQG1ldGhvZCBtZXRob2QuXG4gICAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IHVuY3VycmllZE5hdGl2ZVJlZ0V4cE1ldGhvZChyZWdleHAsIHN0ciwgYXJnMikgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogdW5jdXJyaWVkTmF0aXZlTWV0aG9kKHN0ciwgcmVnZXhwLCBhcmcyKSB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgZG9uZTogZmFsc2UgfTtcbiAgICB9KTtcblxuICAgIGRlZmluZUJ1aWx0SW4oU3RyaW5nLnByb3RvdHlwZSwgS0VZLCBtZXRob2RzWzBdKTtcbiAgICBkZWZpbmVCdWlsdEluKFJlZ0V4cFByb3RvdHlwZSwgU1lNQk9MLCBtZXRob2RzWzFdKTtcbiAgfVxuXG4gIGlmIChTSEFNKSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoUmVnRXhwUHJvdG90eXBlW1NZTUJPTF0sICdzaGFtJywgdHJ1ZSk7XG59O1xuXG52YXIgdW5jdXJyeVRoaXMkMSA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSA9IHRvSW50ZWdlck9ySW5maW5pdHkkNjtcbnZhciB0b1N0cmluZyQxID0gdG9TdHJpbmckNTtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDEgPSByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDY7XG5cbnZhciBjaGFyQXQkMSA9IHVuY3VycnlUaGlzJDEoJycuY2hhckF0KTtcbnZhciBjaGFyQ29kZUF0ID0gdW5jdXJyeVRoaXMkMSgnJy5jaGFyQ29kZUF0KTtcbnZhciBzdHJpbmdTbGljZSQxID0gdW5jdXJyeVRoaXMkMSgnJy5zbGljZSk7XG5cbnZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbiAoQ09OVkVSVF9UT19TVFJJTkcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgcG9zKSB7XG4gICAgdmFyIFMgPSB0b1N0cmluZyQxKHJlcXVpcmVPYmplY3RDb2VyY2libGUkMSgkdGhpcykpO1xuICAgIHZhciBwb3NpdGlvbiA9IHRvSW50ZWdlck9ySW5maW5pdHkocG9zKTtcbiAgICB2YXIgc2l6ZSA9IFMubGVuZ3RoO1xuICAgIHZhciBmaXJzdCwgc2Vjb25kO1xuICAgIGlmIChwb3NpdGlvbiA8IDAgfHwgcG9zaXRpb24gPj0gc2l6ZSkgcmV0dXJuIENPTlZFUlRfVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XG4gICAgZmlyc3QgPSBjaGFyQ29kZUF0KFMsIHBvc2l0aW9uKTtcbiAgICByZXR1cm4gZmlyc3QgPCAweEQ4MDAgfHwgZmlyc3QgPiAweERCRkYgfHwgcG9zaXRpb24gKyAxID09PSBzaXplXG4gICAgICB8fCAoc2Vjb25kID0gY2hhckNvZGVBdChTLCBwb3NpdGlvbiArIDEpKSA8IDB4REMwMCB8fCBzZWNvbmQgPiAweERGRkZcbiAgICAgICAgPyBDT05WRVJUX1RPX1NUUklOR1xuICAgICAgICAgID8gY2hhckF0JDEoUywgcG9zaXRpb24pXG4gICAgICAgICAgOiBmaXJzdFxuICAgICAgICA6IENPTlZFUlRfVE9fU1RSSU5HXG4gICAgICAgICAgPyBzdHJpbmdTbGljZSQxKFMsIHBvc2l0aW9uLCBwb3NpdGlvbiArIDIpXG4gICAgICAgICAgOiAoZmlyc3QgLSAweEQ4MDAgPDwgMTApICsgKHNlY29uZCAtIDB4REMwMCkgKyAweDEwMDAwO1xuICB9O1xufTtcblxudmFyIHN0cmluZ011bHRpYnl0ZSA9IHtcbiAgLy8gYFN0cmluZy5wcm90b3R5cGUuY29kZVBvaW50QXRgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUuY29kZXBvaW50YXRcbiAgY29kZUF0OiBjcmVhdGVNZXRob2QoZmFsc2UpLFxuICAvLyBgU3RyaW5nLnByb3RvdHlwZS5hdGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRoaWFzYnluZW5zL1N0cmluZy5wcm90b3R5cGUuYXRcbiAgY2hhckF0OiBjcmVhdGVNZXRob2QodHJ1ZSlcbn07XG5cbnZhciBjaGFyQXQgPSBzdHJpbmdNdWx0aWJ5dGUuY2hhckF0O1xuXG4vLyBgQWR2YW5jZVN0cmluZ0luZGV4YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYWR2YW5jZXN0cmluZ2luZGV4XG52YXIgYWR2YW5jZVN0cmluZ0luZGV4JDEgPSBmdW5jdGlvbiAoUywgaW5kZXgsIHVuaWNvZGUpIHtcbiAgcmV0dXJuIGluZGV4ICsgKHVuaWNvZGUgPyBjaGFyQXQoUywgaW5kZXgpLmxlbmd0aCA6IDEpO1xufTtcblxudmFyIGNhbGwkMSA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBhbk9iamVjdCQxID0gYW5PYmplY3QkZTtcbnZhciBpc0NhbGxhYmxlID0gaXNDYWxsYWJsZSRuO1xudmFyIGNsYXNzb2YgPSBjbGFzc29mUmF3JDE7XG52YXIgcmVnZXhwRXhlYyQxID0gcmVnZXhwRXhlYyQzO1xuXG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcblxuLy8gYFJlZ0V4cEV4ZWNgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1yZWdleHBleGVjXG52YXIgcmVnZXhwRXhlY0Fic3RyYWN0ID0gZnVuY3Rpb24gKFIsIFMpIHtcbiAgdmFyIGV4ZWMgPSBSLmV4ZWM7XG4gIGlmIChpc0NhbGxhYmxlKGV4ZWMpKSB7XG4gICAgdmFyIHJlc3VsdCA9IGNhbGwkMShleGVjLCBSLCBTKTtcbiAgICBpZiAocmVzdWx0ICE9PSBudWxsKSBhbk9iamVjdCQxKHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAoY2xhc3NvZihSKSA9PT0gJ1JlZ0V4cCcpIHJldHVybiBjYWxsJDEocmVnZXhwRXhlYyQxLCBSLCBTKTtcbiAgdGhyb3cgJFR5cGVFcnJvcignUmVnRXhwI2V4ZWMgY2FsbGVkIG9uIGluY29tcGF0aWJsZSByZWNlaXZlcicpO1xufTtcblxudmFyIGFwcGx5ID0gZnVuY3Rpb25BcHBseTtcbnZhciBjYWxsID0gZnVuY3Rpb25DYWxsO1xudmFyIHVuY3VycnlUaGlzID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBmaXhSZWdFeHBXZWxsS25vd25TeW1ib2xMb2dpYyA9IGZpeFJlZ2V4cFdlbGxLbm93blN5bWJvbExvZ2ljO1xudmFyIGlzUmVnRXhwID0gaXNSZWdleHA7XG52YXIgYW5PYmplY3QgPSBhbk9iamVjdCRlO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDY7XG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gc3BlY2llc0NvbnN0cnVjdG9yJDM7XG52YXIgYWR2YW5jZVN0cmluZ0luZGV4ID0gYWR2YW5jZVN0cmluZ0luZGV4JDE7XG52YXIgdG9MZW5ndGggPSB0b0xlbmd0aCQ2O1xudmFyIHRvU3RyaW5nID0gdG9TdHJpbmckNTtcbnZhciBnZXRNZXRob2QgPSBnZXRNZXRob2QkNDtcbnZhciBhcnJheVNsaWNlID0gYXJyYXlTbGljZVNpbXBsZTtcbnZhciBjYWxsUmVnRXhwRXhlYyA9IHJlZ2V4cEV4ZWNBYnN0cmFjdDtcbnZhciByZWdleHBFeGVjID0gcmVnZXhwRXhlYyQzO1xudmFyIHN0aWNreUhlbHBlcnMgPSByZWdleHBTdGlja3lIZWxwZXJzO1xudmFyIGZhaWxzID0gZmFpbHMkcztcblxudmFyIFVOU1VQUE9SVEVEX1kgPSBzdGlja3lIZWxwZXJzLlVOU1VQUE9SVEVEX1k7XG52YXIgTUFYX1VJTlQzMiA9IDB4RkZGRkZGRkY7XG52YXIgbWluID0gTWF0aC5taW47XG52YXIgJHB1c2ggPSBbXS5wdXNoO1xudmFyIGV4ZWMgPSB1bmN1cnJ5VGhpcygvLi8uZXhlYyk7XG52YXIgcHVzaCA9IHVuY3VycnlUaGlzKCRwdXNoKTtcbnZhciBzdHJpbmdTbGljZSA9IHVuY3VycnlUaGlzKCcnLnNsaWNlKTtcblxuLy8gQ2hyb21lIDUxIGhhcyBhIGJ1Z2d5IFwic3BsaXRcIiBpbXBsZW1lbnRhdGlvbiB3aGVuIFJlZ0V4cCNleGVjICE9PSBuYXRpdmVFeGVjXG4vLyBXZWV4IEpTIGhhcyBmcm96ZW4gYnVpbHQtaW4gcHJvdG90eXBlcywgc28gdXNlIHRyeSAvIGNhdGNoIHdyYXBwZXJcbnZhciBTUExJVF9XT1JLU19XSVRIX09WRVJXUklUVEVOX0VYRUMgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVnZXhwL25vLWVtcHR5LWdyb3VwIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIHZhciByZSA9IC8oPzopLztcbiAgdmFyIG9yaWdpbmFsRXhlYyA9IHJlLmV4ZWM7XG4gIHJlLmV4ZWMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBvcmlnaW5hbEV4ZWMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfTtcbiAgdmFyIHJlc3VsdCA9ICdhYicuc3BsaXQocmUpO1xuICByZXR1cm4gcmVzdWx0Lmxlbmd0aCAhPT0gMiB8fCByZXN1bHRbMF0gIT09ICdhJyB8fCByZXN1bHRbMV0gIT09ICdiJztcbn0pO1xuXG4vLyBAQHNwbGl0IGxvZ2ljXG5maXhSZWdFeHBXZWxsS25vd25TeW1ib2xMb2dpYygnc3BsaXQnLCBmdW5jdGlvbiAoU1BMSVQsIG5hdGl2ZVNwbGl0LCBtYXliZUNhbGxOYXRpdmUpIHtcbiAgdmFyIGludGVybmFsU3BsaXQ7XG4gIGlmIChcbiAgICAnYWJiYycuc3BsaXQoLyhiKSovKVsxXSA9PSAnYycgfHxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVnZXhwL25vLWVtcHR5LWdyb3VwIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gICAgJ3Rlc3QnLnNwbGl0KC8oPzopLywgLTEpLmxlbmd0aCAhPSA0IHx8XG4gICAgJ2FiJy5zcGxpdCgvKD86YWIpKi8pLmxlbmd0aCAhPSAyIHx8XG4gICAgJy4nLnNwbGl0KC8oLj8pKC4/KS8pLmxlbmd0aCAhPSA0IHx8XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlZ2V4cC9uby1lbXB0eS1jYXB0dXJpbmctZ3JvdXAsIHJlZ2V4cC9uby1lbXB0eS1ncm91cCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICAgICcuJy5zcGxpdCgvKCkoKS8pLmxlbmd0aCA+IDEgfHxcbiAgICAnJy5zcGxpdCgvLj8vKS5sZW5ndGhcbiAgKSB7XG4gICAgLy8gYmFzZWQgb24gZXM1LXNoaW0gaW1wbGVtZW50YXRpb24sIG5lZWQgdG8gcmV3b3JrIGl0XG4gICAgaW50ZXJuYWxTcGxpdCA9IGZ1bmN0aW9uIChzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICB2YXIgc3RyaW5nID0gdG9TdHJpbmcocmVxdWlyZU9iamVjdENvZXJjaWJsZSh0aGlzKSk7XG4gICAgICB2YXIgbGltID0gbGltaXQgPT09IHVuZGVmaW5lZCA/IE1BWF9VSU5UMzIgOiBsaW1pdCA+Pj4gMDtcbiAgICAgIGlmIChsaW0gPT09IDApIHJldHVybiBbXTtcbiAgICAgIGlmIChzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCkgcmV0dXJuIFtzdHJpbmddO1xuICAgICAgLy8gSWYgYHNlcGFyYXRvcmAgaXMgbm90IGEgcmVnZXgsIHVzZSBuYXRpdmUgc3BsaXRcbiAgICAgIGlmICghaXNSZWdFeHAoc2VwYXJhdG9yKSkge1xuICAgICAgICByZXR1cm4gY2FsbChuYXRpdmVTcGxpdCwgc3RyaW5nLCBzZXBhcmF0b3IsIGxpbSk7XG4gICAgICB9XG4gICAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgICB2YXIgZmxhZ3MgPSAoc2VwYXJhdG9yLmlnbm9yZUNhc2UgPyAnaScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5tdWx0aWxpbmUgPyAnbScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci51bmljb2RlID8gJ3UnIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3Iuc3RpY2t5ID8gJ3knIDogJycpO1xuICAgICAgdmFyIGxhc3RMYXN0SW5kZXggPSAwO1xuICAgICAgLy8gTWFrZSBgZ2xvYmFsYCBhbmQgYXZvaWQgYGxhc3RJbmRleGAgaXNzdWVzIGJ5IHdvcmtpbmcgd2l0aCBhIGNvcHlcbiAgICAgIHZhciBzZXBhcmF0b3JDb3B5ID0gbmV3IFJlZ0V4cChzZXBhcmF0b3Iuc291cmNlLCBmbGFncyArICdnJyk7XG4gICAgICB2YXIgbWF0Y2gsIGxhc3RJbmRleCwgbGFzdExlbmd0aDtcbiAgICAgIHdoaWxlIChtYXRjaCA9IGNhbGwocmVnZXhwRXhlYywgc2VwYXJhdG9yQ29weSwgc3RyaW5nKSkge1xuICAgICAgICBsYXN0SW5kZXggPSBzZXBhcmF0b3JDb3B5Lmxhc3RJbmRleDtcbiAgICAgICAgaWYgKGxhc3RJbmRleCA+IGxhc3RMYXN0SW5kZXgpIHtcbiAgICAgICAgICBwdXNoKG91dHB1dCwgc3RyaW5nU2xpY2Uoc3RyaW5nLCBsYXN0TGFzdEluZGV4LCBtYXRjaC5pbmRleCkpO1xuICAgICAgICAgIGlmIChtYXRjaC5sZW5ndGggPiAxICYmIG1hdGNoLmluZGV4IDwgc3RyaW5nLmxlbmd0aCkgYXBwbHkoJHB1c2gsIG91dHB1dCwgYXJyYXlTbGljZShtYXRjaCwgMSkpO1xuICAgICAgICAgIGxhc3RMZW5ndGggPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgbGFzdExhc3RJbmRleCA9IGxhc3RJbmRleDtcbiAgICAgICAgICBpZiAob3V0cHV0Lmxlbmd0aCA+PSBsaW0pIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXBhcmF0b3JDb3B5Lmxhc3RJbmRleCA9PT0gbWF0Y2guaW5kZXgpIHNlcGFyYXRvckNvcHkubGFzdEluZGV4Kys7IC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3BcbiAgICAgIH1cbiAgICAgIGlmIChsYXN0TGFzdEluZGV4ID09PSBzdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgIGlmIChsYXN0TGVuZ3RoIHx8ICFleGVjKHNlcGFyYXRvckNvcHksICcnKSkgcHVzaChvdXRwdXQsICcnKTtcbiAgICAgIH0gZWxzZSBwdXNoKG91dHB1dCwgc3RyaW5nU2xpY2Uoc3RyaW5nLCBsYXN0TGFzdEluZGV4KSk7XG4gICAgICByZXR1cm4gb3V0cHV0Lmxlbmd0aCA+IGxpbSA/IGFycmF5U2xpY2Uob3V0cHV0LCAwLCBsaW0pIDogb3V0cHV0O1xuICAgIH07XG4gIC8vIENoYWtyYSwgVjhcbiAgfSBlbHNlIGlmICgnMCcuc3BsaXQodW5kZWZpbmVkLCAwKS5sZW5ndGgpIHtcbiAgICBpbnRlcm5hbFNwbGl0ID0gZnVuY3Rpb24gKHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgIHJldHVybiBzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCAmJiBsaW1pdCA9PT0gMCA/IFtdIDogY2FsbChuYXRpdmVTcGxpdCwgdGhpcywgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgfTtcbiAgfSBlbHNlIGludGVybmFsU3BsaXQgPSBuYXRpdmVTcGxpdDtcblxuICByZXR1cm4gW1xuICAgIC8vIGBTdHJpbmcucHJvdG90eXBlLnNwbGl0YCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUuc3BsaXRcbiAgICBmdW5jdGlvbiBzcGxpdChzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICB2YXIgTyA9IHJlcXVpcmVPYmplY3RDb2VyY2libGUodGhpcyk7XG4gICAgICB2YXIgc3BsaXR0ZXIgPSBzZXBhcmF0b3IgPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogZ2V0TWV0aG9kKHNlcGFyYXRvciwgU1BMSVQpO1xuICAgICAgcmV0dXJuIHNwbGl0dGVyXG4gICAgICAgID8gY2FsbChzcGxpdHRlciwgc2VwYXJhdG9yLCBPLCBsaW1pdClcbiAgICAgICAgOiBjYWxsKGludGVybmFsU3BsaXQsIHRvU3RyaW5nKE8pLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICB9LFxuICAgIC8vIGBSZWdFeHAucHJvdG90eXBlW0BAc3BsaXRdYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXJlZ2V4cC5wcm90b3R5cGUtQEBzcGxpdFxuICAgIC8vXG4gICAgLy8gTk9URTogVGhpcyBjYW5ub3QgYmUgcHJvcGVybHkgcG9seWZpbGxlZCBpbiBlbmdpbmVzIHRoYXQgZG9uJ3Qgc3VwcG9ydFxuICAgIC8vIHRoZSAneScgZmxhZy5cbiAgICBmdW5jdGlvbiAoc3RyaW5nLCBsaW1pdCkge1xuICAgICAgdmFyIHJ4ID0gYW5PYmplY3QodGhpcyk7XG4gICAgICB2YXIgUyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICB2YXIgcmVzID0gbWF5YmVDYWxsTmF0aXZlKGludGVybmFsU3BsaXQsIHJ4LCBTLCBsaW1pdCwgaW50ZXJuYWxTcGxpdCAhPT0gbmF0aXZlU3BsaXQpO1xuXG4gICAgICBpZiAocmVzLmRvbmUpIHJldHVybiByZXMudmFsdWU7XG5cbiAgICAgIHZhciBDID0gc3BlY2llc0NvbnN0cnVjdG9yKHJ4LCBSZWdFeHApO1xuXG4gICAgICB2YXIgdW5pY29kZU1hdGNoaW5nID0gcngudW5pY29kZTtcbiAgICAgIHZhciBmbGFncyA9IChyeC5pZ25vcmVDYXNlID8gJ2knIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChyeC5tdWx0aWxpbmUgPyAnbScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHJ4LnVuaWNvZGUgPyAndScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKFVOU1VQUE9SVEVEX1kgPyAnZycgOiAneScpO1xuXG4gICAgICAvLyBeKD8gKyByeCArICkgaXMgbmVlZGVkLCBpbiBjb21iaW5hdGlvbiB3aXRoIHNvbWUgUyBzbGljaW5nLCB0b1xuICAgICAgLy8gc2ltdWxhdGUgdGhlICd5JyBmbGFnLlxuICAgICAgdmFyIHNwbGl0dGVyID0gbmV3IEMoVU5TVVBQT1JURURfWSA/ICdeKD86JyArIHJ4LnNvdXJjZSArICcpJyA6IHJ4LCBmbGFncyk7XG4gICAgICB2YXIgbGltID0gbGltaXQgPT09IHVuZGVmaW5lZCA/IE1BWF9VSU5UMzIgOiBsaW1pdCA+Pj4gMDtcbiAgICAgIGlmIChsaW0gPT09IDApIHJldHVybiBbXTtcbiAgICAgIGlmIChTLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGNhbGxSZWdFeHBFeGVjKHNwbGl0dGVyLCBTKSA9PT0gbnVsbCA/IFtTXSA6IFtdO1xuICAgICAgdmFyIHAgPSAwO1xuICAgICAgdmFyIHEgPSAwO1xuICAgICAgdmFyIEEgPSBbXTtcbiAgICAgIHdoaWxlIChxIDwgUy5sZW5ndGgpIHtcbiAgICAgICAgc3BsaXR0ZXIubGFzdEluZGV4ID0gVU5TVVBQT1JURURfWSA/IDAgOiBxO1xuICAgICAgICB2YXIgeiA9IGNhbGxSZWdFeHBFeGVjKHNwbGl0dGVyLCBVTlNVUFBPUlRFRF9ZID8gc3RyaW5nU2xpY2UoUywgcSkgOiBTKTtcbiAgICAgICAgdmFyIGU7XG4gICAgICAgIGlmIChcbiAgICAgICAgICB6ID09PSBudWxsIHx8XG4gICAgICAgICAgKGUgPSBtaW4odG9MZW5ndGgoc3BsaXR0ZXIubGFzdEluZGV4ICsgKFVOU1VQUE9SVEVEX1kgPyBxIDogMCkpLCBTLmxlbmd0aCkpID09PSBwXG4gICAgICAgICkge1xuICAgICAgICAgIHEgPSBhZHZhbmNlU3RyaW5nSW5kZXgoUywgcSwgdW5pY29kZU1hdGNoaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwdXNoKEEsIHN0cmluZ1NsaWNlKFMsIHAsIHEpKTtcbiAgICAgICAgICBpZiAoQS5sZW5ndGggPT09IGxpbSkgcmV0dXJuIEE7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gei5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIHB1c2goQSwgeltpXSk7XG4gICAgICAgICAgICBpZiAoQS5sZW5ndGggPT09IGxpbSkgcmV0dXJuIEE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHEgPSBwID0gZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcHVzaChBLCBzdHJpbmdTbGljZShTLCBwKSk7XG4gICAgICByZXR1cm4gQTtcbiAgICB9XG4gIF07XG59LCAhU1BMSVRfV09SS1NfV0lUSF9PVkVSV1JJVFRFTl9FWEVDLCBVTlNVUFBPUlRFRF9ZKTtcblxudmFyIG1vZGFsJGIgPSB7XG5cdHdhbGxldDoge1xuXHRcdGNvbm5lY3RZb3VyV2FsbGV0OiBcIkNvbm5lY3QgWW91ciBXYWxsZXRcIixcblx0XHR3aGF0SXNBV2FsbGV0OiBcIldoYXQgaXMgYSBXYWxsZXQ/XCIsXG5cdFx0c2VjdXJlQW5kTWFuYWdlOiBcIlNlY3VyZSAmIE1hbmFnZSBZb3VyIERpZ2l0YWwgQXNzZXRzXCIsXG5cdFx0c2FmZWx5U3RvcmU6IFwiU2FmZWx5IHN0b3JlIGFuZCB0cmFuc2ZlciB5b3VyIGNyeXB0byBhbmQgTkZUcy5cIixcblx0XHRsb2dJblRvQW55OiBcIkxvZyBJbiB0byBBbnkgTkVBUiBBcHBcIixcblx0XHRub05lZWRUb0NyZWF0ZTogXCJObyBuZWVkIHRvIGNyZWF0ZSBuZXcgYWNjb3VudHMgb3IgY3JlZGVudGlhbHMuIENvbm5lY3QgeW91ciB3YWxsZXQgYW5kIHlvdSBhcmUgZ29vZCB0byBnbyFcIixcblx0XHRnZXRBV2FsbGV0OiBcIkdldCBhIFdhbGxldFwiLFxuXHRcdHVzZUFXYWxsZXQ6IFwiVXNlIGEgd2FsbGV0IHRvIHNlY3VyZSBhbmQgbWFuYWdlIHlvdXIgTkVBUiBhc3NldHMsIGFuZCB0byBsb2cgaW4gdG8gYW55IE5FQVIgYXBwIHdpdGhvdXQgdGhlIG5lZWQgZm9yIHVzZXJuYW1lcyBhbmQgcGFzc3dvcmRzLlwiLFxuXHRcdGNvbm5lY3Rpb25GYWlsZWQ6IFwiQ29ubmVjdGlvbiBGYWlsZWRcIixcblx0XHRjb25uZWN0aW9uU3VjY2Vzc2Z1bDogXCJDb25uZWN0aW9uIFN1Y2Nlc3NmdWxcIixcblx0XHRjb25uZWN0ZWQ6IFwiQ29ubmVjdGVkXCIsXG5cdFx0Y29ubmVjdGluZ1RvOiBcIkNvbm5lY3RpbmcgdG9cIixcblx0XHRjb25uZWN0aW5nTWVzc2FnZToge1xuXHRcdFx0aW5qZWN0ZWQ6IFwiQ29uZmlybSB0aGUgY29ubmVjdGlvbiBpbiB0aGUgZXh0ZW5zaW9uIHdpbmRvd1wiLFxuXHRcdFx0YnJvd3NlcjogXCJDb25maXJtIHRoZSBjb25uZWN0aW9uIGluIHRoZSB3YWxsZXQgYWZ0ZXIgcmVkaXJlY3RcIixcblx0XHRcdGhhcmR3YXJlOiBcIkNvbmZpcm0gdGhlIGNvbm5lY3Rpb24gaW4gdGhlIGxlZGdlciBkZXZpY2VcIixcblx0XHRcdGJyaWRnZTogXCJDb25maXJtIHRoZSBjb25uZWN0aW9uIGluIHRoZSB3YWxsZXRcIlxuXHRcdH1cblx0fSxcblx0bGVkZ2VyOiB7XG5cdFx0Y29ubmVjdFdpdGhMZWRnZXI6IFwiQ29ubmVjdCB3aXRoIExlZGdlclwiLFxuXHRcdG1ha2VTdXJlWW91ckxlZGdlcjogXCJNYWtlIHN1cmUgeW91ciBMZWRnZXIgaXMgY29ubmVjdGVkIHNlY3VyZWx5LCBhbmQgdGhhdCB0aGUgTkVBUiBhcHAgaXMgb3BlbiBvbiB5b3VyIGRldmljZVwiLFxuXHRcdFwiY29udGludWVcIjogXCJDb250aW51ZVwiLFxuXHRcdHNwZWNpZnlIRFBhdGg6IFwiU3BlY2lmeSBIRCBQYXRoXCIsXG5cdFx0ZW50ZXJZb3VyUHJlZmVycmVkSERQYXRoOiBcIkVudGVyIHlvdXIgcHJlZmVycmVkIEhEIHBhdGgsIHRoZW4gc2NhbiBmb3IgYW55IGFjdGl2ZSBhY2NvdW50cy5cIixcblx0XHRzY2FuOiBcIlNjYW5cIixcblx0XHRyZXRyeTogXCJSZXRyeVwiLFxuXHRcdGxlZGdlcklzTm90QXZhaWxhYmxlOiBcIkxlZGdlciBpcyBub3QgYXZhaWxhYmxlXCIsXG5cdFx0YWNjZXNzRGVuaWVkVG9Vc2VMZWRnZXJEZXZpY2U6IFwiQWNjZXNzIGRlbmllZCB0byB1c2UgTGVkZ2VyIGRldmljZVwiLFxuXHRcdG5vQWNjb3VudHNGb3VuZDogXCJObyBBY2NvdW50cyBGb3VuZFwiLFxuXHRcdHNlbGVjdFlvdXJBY2NvdW50czogXCJTZWxlY3QgWW91ciBBY2NvdW50c1wiLFxuXHRcdGNvbm5lY3RpbmcxQWNjb3VudDogXCJDb25uZWN0aW5nIDEgQWNjb3VudFwiLFxuXHRcdGNhbnRGaW5kQW55QWNjb3VudDogXCJDYW4ndCBmaW5kIGFueSBhY2NvdW50IGFzc29jaWF0ZWQgd2l0aCB0aGlzIExlZGdlci4gUGxlYXNlIGNyZWF0ZSBhIG5ldyBORUFSIGFjY291bnQgb25cIixcblx0XHRvckNvbm5lY3RBbkFub3RoZXJMZWRnZXI6IFwib3IgY29ubmVjdCBhbiBhbm90aGVyIExlZGdlci5cIixcblx0XHRjb25uZWN0aW5nOiBcIkNvbm5lY3RpbmdcIixcblx0XHRvZkFjY291bnRzOiBcIm9mIEFjY291bnRzXCIsXG5cdFx0ZmFpbGVkVG9BdXRvbWF0aWNhbGx5OiBcIkZhaWxlZCB0byBhdXRvbWF0aWNhbGx5IGZpbmQgYWNjb3VudCBpZC4gUHJvdmlkZSBpdCBtYW51YWxseTpcIixcblx0XHRvdmVydmlld1RoZUxpc3RPZkF1dGhvcml6ZWQ6IFwiT3ZlcnZpZXcgdGhlIGxpc3Qgb2YgYXV0aG9yaXplZCBhY2NvdW50KHMpLCBjb21wbGV0ZSBzaWduIGluIGJ5IGNsaWNraW5nIHRoZSBidXR0b24gYmVsb3cuXCIsXG5cdFx0ZmluaXNoOiBcIkZpbmlzaFwiXG5cdH0sXG5cdGluc3RhbGw6IHtcblx0XHR5b3VsbE5lZWRUb0luc3RhbGw6IFwiWW91J2xsIG5lZWQgdG8gaW5zdGFsbFwiLFxuXHRcdHRvQ29udGludWVBZnRlckluc3RhbGxpbmc6IFwidG8gY29udGludWUuIEFmdGVyIGluc3RhbGxpbmdcIixcblx0XHRyZWZyZXNoVGhlUGFnZTogXCJyZWZyZXNoIHRoZSBwYWdlLlwiLFxuXHRcdG9wZW46IFwiT3BlblwiXG5cdH0sXG5cdHFyOiB7XG5cdFx0Y29waWVkVG9DbGlwYm9hcmQ6IFwiQ29waWVkIHRvIGNsaXBib2FyZFwiLFxuXHRcdGZhaWxlZFRvQ29weTogXCJGYWlsZWQgdG8gY29weSB0byBjbGlwYm9hcmRcIixcblx0XHRzY2FuV2l0aFlvdXJNb2JpbGU6IFwiU2NhbiB3aXRoIFlvdXIgTW9iaWxlIERldmljZVwiLFxuXHRcdGNvcHlUb0NsaXBib2FyZDogXCIgQ29weSB0byBjbGlwYm9hcmRcIixcblx0XHRwcmVmZXJUaGVPZmZpY2lhbDogXCJQcmVmZXIgdGhlIG9mZmljaWFsIGRpYWxvZ3VlIG9mXCIsXG5cdFx0b3BlbjogXCJPcGVuXCJcblx0fSxcblx0d2FsbGV0VHlwZXM6IHtcblx0XHRoYXJkd2FyZTogXCJIYXJkd2FyZSBXYWxsZXRcIixcblx0XHRicm93c2VyOiBcIkJyb3dzZXIgV2FsbGV0XCIsXG5cdFx0aW5qZWN0ZWQ6IFwiV2FsbGV0IEV4dGVuc2lvblwiLFxuXHRcdGJyaWRnZTogXCJCcmlkZ2UgV2FsbGV0XCIsXG5cdFx0bW9iaWxlOiBcIk1vYmlsZSBXYWxsZXRcIixcblx0XHRcImluc3RhbnQtbGlua1wiOiBcIkluc3RhbnQgV2FsbGV0XCJcblx0fSxcblx0ZXhwb3J0QWNjb3VudHM6IHtcblx0XHRjaG9vc2VBV2FsbGV0OiBcIkNob29zZSBhIFdhbGxldFwiLFxuXHRcdHRyYW5zZmVyWW91ckFjY291bnRzOiBcIlRyYW5zZmVyIFlvdXIgQWNjb3VudHNcIixcblx0XHRzZWxlY3RBV2FsbGV0OiBcIlNlbGVjdCBhIHdhbGxldCB0aGF0IGZpdHMgeW91ciBuZWVkcyBhbmQgc3VwcG9ydHMgeW91ciBjb25uZWN0ZWQgYWNjb3VudHMuXCIsXG5cdFx0c2VsZWN0WW91ckFjY291bnRzOiBcIlNlbGVjdCBZb3VyIEFjY291bnRzXCIsXG5cdFx0YWZ0ZXJEZWNpZGU6IFwiQWZ0ZXIgeW91IGRlY2lkZSBvbiBhIHdhbGxldCwgeW91IGNhbiBzZWxlY3Qgd2hpY2ggYWNjb3VudHMgeW91IHdhbnQgdG8gdHJhbnNmZXIuXCIsXG5cdFx0ZGlzY2xhaW1lcjogXCJZb3Ugd29u4oCZdCBiZSBhYmxlIHRvIHRyYW5zZmVyIGFjY291bnRzIHRoYXQgaGF2ZSBuZXZlciBiZWVuIGZ1bmRlZCBvciB1c2VkIG9uIE5FQVIuXCIsXG5cdFx0d2FybmluZzogXCJkb2VzIG5vdCBzdXBwb3J0IGFjY291bnQgZXhwb3J0IGF0IHRoaXMgdGltZS4gUGxlYXNlIHNlbGVjdCBhbm90aGVyIHdhbGxldC5cIixcblx0XHR3YWxsZXRUeXBlczoge1xuXHRcdFx0aGFyZHdhcmU6IFwiSGFyZHdhcmUgV2FsbGV0XCIsXG5cdFx0XHRicm93c2VyOiBcIkJyb3dzZXIgV2FsbGV0XCIsXG5cdFx0XHRpbmplY3RlZDogXCJXYWxsZXQgRXh0ZW5zaW9uXCIsXG5cdFx0XHRicmlkZ2U6IFwiQnJpZGdlIFdhbGxldFwiLFxuXHRcdFx0bW9iaWxlOiBcIk1vYmlsZSBXYWxsZXRcIlxuXHRcdH0sXG5cdFx0c2VsZWN0QWNjb3VudHM6IHtcblx0XHRcdHRpdGxlOiBcIlNlbGVjdCBBY2NvdW50cyB0byBUcmFuc2ZlclwiLFxuXHRcdFx0YnV0dG9uOiBcIkNvbnRpbnVlXCIsXG5cdFx0XHRkZXNlbGVjdEFsbDogXCJEZXNlbGVjdCBBbGxcIixcblx0XHRcdHNlbGVjdEFsbDogXCJTZWxlY3QgQWxsXCIsXG5cdFx0XHR1bmF2YWlsYWJsZTogXCJUcmFuc2ZlciBVbmF2YWlsYWJsZVwiLFxuXHRcdFx0ZXJyb3I6IFwiQWNjb3VudCBkb2VzIG5vdCBleGlzdFwiLFxuXHRcdFx0d2FybmluZ0xlZGdlcjogXCJMZWRnZXIgc3VwcG9ydCByZXF1aXJlZFwiLFxuXHRcdFx0bm9CYWxhbmNlOiBcIkFjY291bnQgbm90IGZ1bmRlZFwiXG5cdFx0fSxcblx0XHRnZXRQYXNzcGhyYXNlOiB7XG5cdFx0XHR0aXRsZTogXCJDb3B5IFRlbXBvcmFyeSBQYXNzd29yZFwiLFxuXHRcdFx0ZGVzYzogXCJZb3XigJlsbCBuZWVkIHRvIGVudGVyIHRoaXMgcGFzc3dvcmQgd2hlbiB5b3UgYmVnaW4gZXhwb3J0aW5nIHlvdXIgYWNjb3VudHMgdG8gYSBkaWZmZXJlbnQgd2FsbGV0LlwiLFxuXHRcdFx0YnV0dG9uOiBcIkNvbnRpbnVlXCIsXG5cdFx0XHR0cmFuc2ZlckJ1dHRvbjogXCJUcmFuc2ZlciBBY2NvdW50c1wiLFxuXHRcdFx0bGFiZWw6IFwiQ2xpY2sgdG8gQ29weVwiLFxuXHRcdFx0Y2hlY2tMYWJlbDogXCJJIGNvcGllZCBvciB3cm90ZSBkb3duIHRoZSBwYXNzd29yZFwiXG5cdFx0fSxcblx0XHRjb21wbGV0ZToge1xuXHRcdFx0dGl0bGU6IFwiQ29tcGxldGUgdGhlIFRyYW5zZmVyXCIsXG5cdFx0XHRkZXNjT25lOiBcIllvdSB3aWxsIG5vdyBiZSByZWRpcmVjdGVkIHRvIHRoZSB3YWxsZXQgeW91IHNlbGVjdGVkIHRvIGNvbXBsZXRlIHRoZSB0cmFuc2Zlci5cIixcblx0XHRcdGRlc2NUd286IFwiT25jZSBpbXBvcnQgcGFydCBvZiBwcm9jZXNzIGlzIGNvbXBsZXRlZCBmcm9tIHNlbGVjdGVkIHdhbGxldCwgcHJlc3MgYnV0dG9uIHRvIGNvbXBsZXRlIHRoZSB0cmFuc2ZlciBwcm9jZXNzLlwiLFxuXHRcdFx0c3RhcnRPdmVyQnV0dG9uOiBcIlN0YXJ0IE92ZXJcIixcblx0XHRcdGJ1dHRvbjogXCJDb21wbGV0ZVwiXG5cdFx0fVxuXHR9XG59O1xudmFyIGNvbXBvbmVudCQxID0ge1xuXHRjbGlja1RvQ29weToge1xuXHRcdGxhYmVsOiBcIkNvcGllZFwiLFxuXHRcdHRvb2x0aXA6IFwiQ2xpY2sgdG8gY29weVwiXG5cdH1cbn07XG52YXIgZW4gPSB7XG5cdG1vZGFsOiBtb2RhbCRiLFxuXHRjb21wb25lbnQ6IGNvbXBvbmVudCQxXG59O1xuXG52YXIgbW9kYWwkYSA9IHtcblx0d2FsbGV0OiB7XG5cdFx0Y29ubmVjdFlvdXJXYWxsZXQ6IFwiQ29uZWN0YSBUdSBCaWxsZXRlcmFcIixcblx0XHR3aGF0SXNBV2FsbGV0OiBcIsK/UXVlIGVzIHVuYSBCaWxsZXRlcmE/XCIsXG5cdFx0c2VjdXJlQW5kTWFuYWdlOiBcIlJlc2d1YXJkYSB5IEFkbWluaXN0cmFyIFR1cyBBY3Rpdm9zIERpZ2l0YWxlc1wiLFxuXHRcdHNhZmVseVN0b3JlOiBcIkFsbWFjZW5hIGRlIGZvcm1hIHNlZ3VyYSB5IHRyYW5zZmllcmUgdHVzIGNyeXB0b3MgeSBORlQnc1wiLFxuXHRcdGxvZ0luVG9Bbnk6IFwiSW5pY2llIHNlc2nDs24gZW4gQ3VhbHF1aWVyIEFwbGljYWNpb24gTkVBUlwiLFxuXHRcdG5vTmVlZFRvQ3JlYXRlOiBcIk5vIGVzIG5lY2VzYXJpbyBjcmVhciBudWV2YXMgY3VlbnRhcyBvIGNyZWRlbmNpYWxlcywgwqFDb25lY3RhIHR1IGJpbGxldGVyYSB5IGxpc3RvIVwiLFxuXHRcdGdldEFXYWxsZXQ6IFwiT2J0ZW4gdW5hIEJpbGxldGVyYVwiLFxuXHRcdHVzZUFXYWxsZXQ6IFwiVXNhIHR1IEJpbGxldGVyYSBwYXJhIHJlc2d1YXJkYXIgeSBhZG1pbmlzdHJhciB0dXMgYWN0aXZvcyBlbiBORUFSLCBlIEluaWNpYXIgc2VzacOzbiBlbiBjdWFscXVpZXIgYXBsaWNhY2lvbiBORUFSIHNpbiBsYSBuZWNlc2lkYWQgZGUgbm9tYnJlcyBkZSB1c3VhcmlvcyB5IGNvbnRyYXNlw7Fhc1wiLFxuXHRcdGNvbm5lY3Rpb25GYWlsZWQ6IFwiQ29uZXhpw7NuIEZhbGxpZGFcIixcblx0XHRjb25uZWN0aW9uU3VjY2Vzc2Z1bDogXCJDb25leGnDs24gRXhpc3Rvc2FcIixcblx0XHRjb25uZWN0ZWQ6IFwiQ29uZWN0YWRvXCIsXG5cdFx0Y29ubmVjdGluZ1RvOiBcIkNvbmVjdGFuZG8gYSBcIixcblx0XHRjb25uZWN0aW5nTWVzc2FnZToge1xuXHRcdFx0aW5qZWN0ZWQ6IFwiQ29uZmlybWUgbGEgY29uZXhpw7NuIGVuIGxhIHZlbnRhbmEgZGUgZXh0ZW5zacOzblwiLFxuXHRcdFx0YnJvd3NlcjogXCJDb25maXJtZSBsYSBjb25leGnDs24gZW4gbGEgYmlsbGV0ZXJhIGRlc3B1w6lzIGRlIGxhIHJlZGlyZWNjacOzblwiLFxuXHRcdFx0aGFyZHdhcmU6IFwiQ29uZmlybWUgbGEgY29uZXhpw7NuIGVuIGVsIGRpc3Bvc2l0aXZvIGRlIGxpYnJvIG1heW9yXCIsXG5cdFx0XHRicmlkZ2U6IFwiQ29uZmlybWFyIGxhIGNvbmV4acOzbiBlbiBsYSBiaWxsZXRlcmFcIlxuXHRcdH1cblx0fSxcblx0bGVkZ2VyOiB7XG5cdFx0Y29ubmVjdFdpdGhMZWRnZXI6IFwiQ29uZWN0YXIgY29uIExlZGdlclwiLFxuXHRcdG1ha2VTdXJlWW91ckxlZGdlcjogXCJBc2Vnw7pyZXNlIGRlIHF1ZSBzdSBsZWRnZXIgZXN0w6EgY29uZWN0YWRhIGRlIGZvcm1hIHNlZ3VyYSB5IHF1ZSBsYSBhcGxpY2FjaW9uIE5FQVIgZXN0w6kgYWJpZXJ0YSBlbiBzdSBkaXNwb3NpdGl2b1wiLFxuXHRcdFwiY29udGludWVcIjogXCJDb250aW51YXJcIixcblx0XHRzcGVjaWZ5SERQYXRoOiBcIkVzcGVjaWZpcXVlIGxhIHJ1dGEgSERcIixcblx0XHRlbnRlcllvdXJQcmVmZXJyZWRIRFBhdGg6IFwiSW5ncmVzZSBzdSBydXRhIEhEIHByZXJpZGEseSBsdWVnbyBidXNxdWUgY3VhbHF1aWVyIGN1ZW50YSBhY3RpdmEuXCIsXG5cdFx0c2NhbjogXCJFc2NhbmVhclwiLFxuXHRcdHJldHJ5OiBcIlJlaW50ZW50YXJcIixcblx0XHRsZWRnZXJJc05vdEF2YWlsYWJsZTogXCJFbCBMZWRnZXIgbm8gZXN0w6EgZGlzcG9uaWJsZVwiLFxuXHRcdGFjY2Vzc0RlbmllZFRvVXNlTGVkZ2VyRGV2aWNlOiBcIkFjY2VzbyBkZW5lZ2FkbyBwYXJhIHVzYXIgZWwgZGlzcG9zaXRpdm8gbGVkZ2VyXCIsXG5cdFx0bm9BY2NvdW50c0ZvdW5kOiBcIk5vIHNlIGVuY29udHJhcm9uIGN1ZW50YXNcIixcblx0XHRzZWxlY3RZb3VyQWNjb3VudHM6IFwiU2VsZWNjaW9uYSB0dXMgY3VlbnRhc1wiLFxuXHRcdGNvbm5lY3RpbmcxQWNjb3VudDogXCJDb25lY3RhbmRvIGEgMSBjdWVudGFcIixcblx0XHRjYW50RmluZEFueUFjY291bnQ6IFwiTm8gc2UgcHVkbyBlbmNvbnRyYXIgbmluZ3VuYSBjdWVudGEgYXNvY2lhZGEgY29uIGVzdGUgbGVkZ2VyLFBvciBmYXZvciBjcmVhIHVuYSBudWV2YSBjdWVudGEgZW4gTkVBUlwiLFxuXHRcdG9yQ29ubmVjdEFuQW5vdGhlckxlZGdlcjogXCJvIGNvbmVjdGEgb3RybyBsZWRnZXJcIixcblx0XHRjb25uZWN0aW5nOiBcIkNvbmVjdGFuZG9cIixcblx0XHRvZkFjY291bnRzOiBcImRlIEN1ZW50YXNcIixcblx0XHRmYWlsZWRUb0F1dG9tYXRpY2FsbHk6IFwiTm8gc2UgcHVkbyBlbmNvbnRyYXIgYXV0b21hdGljYW1lbnRlIGVsIGlkIGRlIGxhIGN1ZW50YSxJbmdyZXNhbG8gbWFudWFsbWVudGU6XCIsXG5cdFx0b3ZlcnZpZXdUaGVMaXN0T2ZBdXRob3JpemVkOiBcIlJldmlzZSBsYSBsaXN0YSBkZSBsYXMgY3VlbnRhcyBhdXRvcml6YWRhcyxDb21wbGV0ZSBlbCBpbmljaW8gZGUgc2VzacOzbiBoYWNpZWRvIGNsaWNrIGEgY291bnRpbnVhY2lvbi5cIixcblx0XHRmaW5pc2g6IFwiRmluYWxpemFyXCJcblx0fSxcblx0aW5zdGFsbDoge1xuXHRcdHlvdWxsTmVlZFRvSW5zdGFsbDogXCJUZW5kcsOhcyBxdWUgaW5zdGFsYXJcIixcblx0XHR0b0NvbnRpbnVlQWZ0ZXJJbnN0YWxsaW5nOiBcIlBhcmEgY29udGludWFyLCBEZXNwdWVzIGRlIGluc3RhbGFyXCIsXG5cdFx0cmVmcmVzaFRoZVBhZ2U6IFwiUmVjYXJnYSBsYSBwYWdpbmFcIixcblx0XHRvcGVuOiBcIkFicmlyXCJcblx0fSxcblx0cXI6IHtcblx0XHRjb3BpZWRUb0NsaXBib2FyZDogXCJDb3BpYWRvIGFsIFBvcnRhcGFwZWxlc1wiLFxuXHRcdGZhaWxlZFRvQ29weTogXCJGYWxsw7MgbGEgY29waWEgYWwgUG9ydGFwYXBlbGVzXCIsXG5cdFx0c2NhbldpdGhZb3VyTW9iaWxlOiBcIkJ1c2NhIGNvbiB0dSBkaXNwb3NpdGl2byBtb3ZpbFwiLFxuXHRcdGNvcHlUb0NsaXBib2FyZDogXCIgQ29waWFyIGFsIFBvcnRhcGFwZWxlc1wiLFxuXHRcdHByZWZlclRoZU9mZmljaWFsOiBcIsK/UHJlZmlyZXMgZWwgZGnDoWxvZ28gb2ZpY2lhbCBkZVwiLFxuXHRcdG9wZW46IFwiQWJyaXJcIlxuXHR9LFxuXHR3YWxsZXRUeXBlczoge1xuXHRcdGhhcmR3YXJlOiBcIkhhcmR3YXJlIFdhbGxldFwiLFxuXHRcdGJyb3dzZXI6IFwiQnJvd3NlciBXYWxsZXRcIixcblx0XHRpbmplY3RlZDogXCJXYWxsZXQgRXh0ZW5zaW9uXCIsXG5cdFx0YnJpZGdlOiBcIkJyaWRnZSBXYWxsZXRcIixcblx0XHRtb2JpbGU6IFwiTW9iaWxlIFdhbGxldFwiLFxuXHRcdFwiaW5zdGFudC1saW5rXCI6IFwiSW5zdGFudCBXYWxsZXRcIlxuXHR9XG59O1xudmFyIGVzID0ge1xuXHRtb2RhbDogbW9kYWwkYVxufTtcblxudmFyIG1vZGFsJDkgPSB7XG5cdHdhbGxldDoge1xuXHRcdGNvbm5lY3RZb3VyV2FsbGV0OiBcIui/nuaOpeS9oOeahOmSseWMhVwiLFxuXHRcdHdoYXRJc0FXYWxsZXQ6IFwi5LuA5LmI5piv6ZKx5YyF77yfXCIsXG5cdFx0c2VjdXJlQW5kTWFuYWdlOiBcIuS/neaKpOWSjOeuoeeQhuS9oOeahOaVsOWtl+i1hOS6p1wiLFxuXHRcdHNhZmVseVN0b3JlOiBcIuWuieWFqOWtmOWCqOWSjOi9rOenu+S9oOeahOWKoOWvhui0p+W4geWSjE5GVFwiLFxuXHRcdGxvZ0luVG9Bbnk6IFwi55m75b2V5Lu75L2VIE5FQVIg5bqU55SoXCIsXG5cdFx0bm9OZWVkVG9DcmVhdGU6IFwi5LiN6ZyA6KaB5Yib5bu65paw6LSm5oi35oiW5a+G56CB44CC6L+e5o6l5L2g55qE6ZKx5YyF77yM5Y2z5Y+v5byA5aeL5L2/55So77yBXCIsXG5cdFx0Z2V0QVdhbGxldDogXCLojrflj5bmlrDotKbmiLdcIixcblx0XHR1c2VBV2FsbGV0OiBcIuS9v+eUqOmSseWMheadpeS/neaKpOWSjOeuoeeQhuS9oOeahCBORUFSIOi1hOS6p++8jOaXoOmcgOeUqOaIt+WQjeWSjOWvhueggeWNs+WPr+eZu+W9leS7u+S9lSBORUFSIOW6lOeUqFwiLFxuXHRcdGNvbm5lY3Rpb25GYWlsZWQ6IFwi6L+e5o6l5aSx6LSlXCIsXG5cdFx0Y29ubmVjdGlvblN1Y2Nlc3NmdWw6IFwi6L+e5o6l5oiQ5YqfXCIsXG5cdFx0Y29ubmVjdGVkOiBcIuW3sui/nuaOpVwiLFxuXHRcdGNvbm5lY3RpbmdUbzogXCLmraPlnKjov57mjqVcIlxuXHR9LFxuXHRsZWRnZXI6IHtcblx0XHRjb25uZWN0V2l0aExlZGdlcjogXCLov57mjqUgTGVkZ2VyXCIsXG5cdFx0bWFrZVN1cmVZb3VyTGVkZ2VyOiBcIuehruS/neS9oOeahCBMZWRnZXIg5bey57uP5a6J5YWo6L+e5o6l77yM5bm25LiUIE5FQVIg5bqU55So5bey57uP5Zyo5L2g6K6+5aSH5LiK5omT5byAXCIsXG5cdFx0XCJjb250aW51ZVwiOiBcIue7p+e7rVwiLFxuXHRcdHNwZWNpZnlIRFBhdGg6IFwi5oyH5a6aIEhEIOi3r+W+hFwiLFxuXHRcdGVudGVyWW91clByZWZlcnJlZEhEUGF0aDogXCLovpPlhaXkvaDlgY/lpb3nmoQgSEQg6Lev5b6E77yM54S25ZCO5Li65Lu75oSP5rS76LeD6LSm5oi35omr56CBXCIsXG5cdFx0c2NhbjogXCLmiavnoIFcIixcblx0XHRyZXRyeTogXCLph43or5VcIixcblx0XHRsZWRnZXJJc05vdEF2YWlsYWJsZTogXCJMZWRnZXIg5LiN5Y+v55SoXCIsXG5cdFx0YWNjZXNzRGVuaWVkVG9Vc2VMZWRnZXJEZXZpY2U6IFwi6K6/6ZeuIExlZGdlciDorr7lpIfooqvmi5Lnu51cIixcblx0XHRub0FjY291bnRzRm91bmQ6IFwi5rKh5pyJ5om+5Yiw6LSm5oi3XCIsXG5cdFx0c2VsZWN0WW91ckFjY291bnRzOiBcIumAieaLqeS9oOeahOi0puaIt1wiLFxuXHRcdGNvbm5lY3RpbmcxQWNjb3VudDogXCLmraPlnKjov57mjqUx5Liq6LSm5oi3XCIsXG5cdFx0Y2FudEZpbmRBbnlBY2NvdW50OiBcIuayoeacieaJvuWIsOS7u+S9leS4jui/meS4qiBMZWRnZXIg55u45YWz6IGU55qE6LSm5oi344CC6K+35Yib5bu65paw6LSm5oi35LqOXCIsXG5cdFx0XCJvckNvbm5lY3RBbkFub3RoZXJMZWRnZXIuXCI6IFwi5oiW6L+e5o6l5Y+m5LiA5LiqIExlZGdlclwiLFxuXHRcdGNvbm5lY3Rpbmc6IFwi5q2j5Zyo6L+e5o6lXCIsXG5cdFx0b2ZBY2NvdW50czogXCLkuKrotKbmiLdcIixcblx0XHRmYWlsZWRUb0F1dG9tYXRpY2FsbHk6IFwi5peg5rOV6Ieq5Yqo5om+5Yiw6LSm5oi3SUTvvIzor7fkuLvliqjmj5DkvpvvvJpcIixcblx0XHRvdmVydmlld1RoZUxpc3RPZkF1dGhvcml6ZWQ6IFwi6K+35p+l55yL5bey5o6I5p2D55qE6LSm5oi35YiX6KGo77yM54K55Ye75Lul5LiL5oyJ6ZKu5a6M5oiQ55m75b2VXCIsXG5cdFx0ZmluaXNoOiBcIuWujOaIkFwiXG5cdH0sXG5cdGluc3RhbGw6IHtcblx0XHR5b3VsbE5lZWRUb0luc3RhbGw6IFwi5L2g5bCG6ZyA6KaB5a6J6KOFXCIsXG5cdFx0dG9Db250aW51ZUFmdGVySW5zdGFsbGluZzogXCLku6Xnu6fnu63jgILlronoo4XlroxcIixcblx0XHRyZWZyZXNoVGhlUGFnZTogXCLor7fliLfmlrDpobXpnaJcIixcblx0XHRvcGVuOiBcIuaJk+W8gFwiXG5cdH0sXG5cdHFyOiB7XG5cdFx0Y29waWVkVG9DbGlwYm9hcmQ6IFwi5aSN5Yi25Yiw5LqG5Ymq6LS05p2/XCIsXG5cdFx0ZmFpbGVkVG9Db3B5OiBcIuWkjeWItuWIsOWJqui0tOadv+Wksei0pVwiLFxuXHRcdHNjYW5XaXRoWW91ck1vYmlsZTogXCLnlKjkvaDnmoTnp7vliqjorr7lpIfmiavnoIFcIixcblx0XHRjb3B5VG9DbGlwYm9hcmQ6IFwiIOWkjeWItuWIsOWJqui0tOadv1wiLFxuXHRcdHByZWZlclRoZU9mZmljaWFsOiBcIuW4jOacm+S9v+eUqOWumOaWueWvueivneahhuS6jlwiLFxuXHRcdG9wZW46IFwi5omT5byAXCJcblx0fSxcblx0d2FsbGV0VHlwZXM6IHtcblx0XHRoYXJkd2FyZTogXCJIYXJkd2FyZSBXYWxsZXRcIixcblx0XHRicm93c2VyOiBcIkJyb3dzZXIgV2FsbGV0XCIsXG5cdFx0aW5qZWN0ZWQ6IFwiV2FsbGV0IEV4dGVuc2lvblwiLFxuXHRcdGJyaWRnZTogXCJCcmlkZ2UgV2FsbGV0XCIsXG5cdFx0bW9iaWxlOiBcIk1vYmlsZSBXYWxsZXRcIixcblx0XHRcImluc3RhbnQtbGlua1wiOiBcIkluc3RhbnQgV2FsbGV0XCJcblx0fVxufTtcbnZhciB6aCA9IHtcblx0bW9kYWw6IG1vZGFsJDlcbn07XG5cbnZhciBtb2RhbCQ4ID0ge1xuXHR3YWxsZXQ6IHtcblx0XHRjb25uZWN0WW91cldhbGxldDogXCLQodCy0YrRgNC20LXRgtC1INCy0LDRiNC40Y8g0J/QvtGA0YLRhNC10LnQu1wiLFxuXHRcdHdoYXRJc0FXYWxsZXQ6IFwi0JrQsNC60LLQviDQtSDQn9C+0YDRgtGE0LXQudC7P1wiLFxuXHRcdHNlY3VyZUFuZE1hbmFnZTogXCLQl9Cw0YnQuNGC0LXRgtC1INC4INGD0L/RgNCw0LLQu9GP0LLQsNC50YLQtSDQtNC40LPQuNGC0LDQu9C90LjRgtC1INGB0Lgg0LDQutGC0LjQstC4XCIsXG5cdFx0c2FmZWx5U3RvcmU6IFwi0KHRitGF0YDQsNC90Y/QstCw0LnRgtC1INC4INC/0YDQtdGF0LLRitGA0LvRj9C50YLQtSDQsdC10LfQvtC/0LDRgdC90L4g0LLQsNGI0LjRgtC1INC60YDQuNC/0YLQviDQuCBORlQuXCIsXG5cdFx0bG9nSW5Ub0FueTogXCLQmNC30L/QvtC70LfQstCw0LnRgtC1INCy0YHRj9C60L4g0L/RgNC40LvQvtC20LXQvdC40LUg0L3QsCBORUFSXCIsXG5cdFx0bm9OZWVkVG9DcmVhdGU6IFwi0J3Rj9C80LAg0L3Rg9C20LTQsCDQtNCwINGB0YrQt9C00LDQstCw0YLQtSDQvdC+0LLQuCDQv9GA0L7RhNC40LvQuC4g0KHQstGK0YDQttC10YLQtSDQv9C+0YDRgtGE0LXQudC70LAg0YHQuCDQuCDRgdGC0LUg0LPQvtGC0L7QstC4IVwiLFxuXHRcdGdldEFXYWxsZXQ6IFwi0KHRitC30LTQsNC50YLQtSDQn9C+0YDRgtGE0LXQudC7XCIsXG5cdFx0dXNlQVdhbGxldDogXCLQmNC30L/QvtC70LfQstCw0LnRgtC1INC/0L7RgNGC0YTQtdC50LvQsCwg0LfQsCDQtNCwINC30LDRidC40YLQuNGC0LUg0Lgg0YPQv9GA0LDQstC70Y/QstCw0YLQtSDQsNC60YLQuNCy0LjRgtC1INGB0Lgg0L3QsCBORUFSINC60LDQutGC0L4g0Lgg0LTQsCDQuNC30L/QvtC70LfQstCw0YLQtSDQstGB0Y/QutC+INC/0YDQuNC70L7QttC10L3QuNC1INC90LAgTkVBUiDQsdC10Lcg0L3Rg9C20LTQsCDQvtGCINC/0L7RgtGA0LXQsdC40YLQtdC70YHQutC4INC40LzQtdC90LAg0Lgg0L/QsNGA0L7Qu9C4LlwiLFxuXHRcdGNvbm5lY3Rpb25GYWlsZWQ6IFwi0KHQstGK0YDQt9Cy0LDQvdC10YLQviDQvdC10YPRgdC/0LXRiNC90L5cIixcblx0XHRjb25uZWN0aW9uU3VjY2Vzc2Z1bDogXCLQodCy0YrRgNC30LLQsNC90LXRgtC+INGD0YHQv9C10YjQvdC+XCIsXG5cdFx0Y29ubmVjdGVkOiBcItCh0LLRitGA0LfQsNC9XCIsXG5cdFx0Y29ubmVjdGluZ1RvOiBcItCh0LLRitGA0LfQstCw0L3QtSDQutGK0LxcIixcblx0XHRjb25uZWN0aW5nTWVzc2FnZToge1xuXHRcdFx0aW5qZWN0ZWQ6IFwi0J/QvtGC0LLRitGA0LTQtdGC0LUg0YHQstGK0YDQt9Cy0LDQvdC10YLQviDQsiDQv9GA0L7Qt9C+0YDQtdGG0LAg0L3QsCDRgNCw0LfRiNC40YDQtdC90LjQtdGC0L5cIixcblx0XHRcdGJyb3dzZXI6IFwi0J/QvtGC0LLRitGA0LTQtdGC0LUg0YHQstGK0YDQt9Cy0LDQvdC10YLQviDQsiDQv9C+0YDRgtGE0LXQudC70LAg0YHQu9C10LQg0L/RgNC10L3QsNGB0L7Rh9Cy0LDQvdC10YLQvlwiLFxuXHRcdFx0aGFyZHdhcmU6IFwi0J/QvtGC0LLRitGA0LTQtdGC0LUg0YHQstGK0YDQt9Cy0LDQvdC10YLQviDQsiDRhdCw0YDQtNGD0LXRgNC90LjRjyDQv9C+0YDRgtGE0LXQudC7XCIsXG5cdFx0XHRicmlkZ2U6IFwi0J/QvtGC0LLRitGA0LTQtdGC0LUg0LLRgNGK0LfQutCw0YLQsCDQsiDQv9C+0YDRgtGE0LXQudC70LBcIlxuXHRcdH1cblx0fSxcblx0bGVkZ2VyOiB7XG5cdFx0Y29ubmVjdFdpdGhMZWRnZXI6IFwi0KHQstGK0YDQttC10YLQtSDRgdC1INGBIExlZGdlclwiLFxuXHRcdG1ha2VTdXJlWW91ckxlZGdlcjogXCLQo9Cy0LXRgNC10YLQtSDRgdC1LCDRh9C1INCy0LDRiNC40Y/RgiBMZWRnZXIg0LUg0YHQstGK0YDQt9Cw0L0g0Lgg0YfQtSDQv9GA0LjQu9C+0LbQtdC90LjQtdGC0L4gTkVBUiDQtSDQvtGC0LLQvtGA0LXQvdC+INC9YSDQvdC10LPQvi5cIixcblx0XHRcImNvbnRpbnVlXCI6IFwi0J/RgNC+0LTRitC70LbQtdGC0LVcIixcblx0XHRzcGVjaWZ5SERQYXRoOiBcItCf0L7RgdC+0YfQtdGC0LUgSEQg0L/RitGCXCIsXG5cdFx0ZW50ZXJZb3VyUHJlZmVycmVkSERQYXRoOiBcItCS0YrQstC10LTQtdGC0LUg0L/RgNC10LTQv9C+0YfQuNGC0LDQvdC40Y8gSEQg0L/RitGCLCDRgdC70LXQtCDQutC+0LXRgtC+INGB0LrQsNC90LjRgNCw0LnRgtC1INC30LAg0LDQutGC0LjQstC90Lgg0LDQutCw0YPQvdGC0LguXCIsXG5cdFx0c2NhbjogXCLQodC60LDQvdC40YDQsNC50YLQtVwiLFxuXHRcdHJldHJ5OiBcItCe0L/QuNGC0LDQudGC0LUg0L7RgtC90L7QstC+XCIsXG5cdFx0bGVkZ2VySXNOb3RBdmFpbGFibGU6IFwiTGVkZ2VyINGD0YHRgtGA0L7QudGB0YLQstC+0YLQviDQvdC1INC1INC00L7RgdGC0YrQv9C90L5cIixcblx0XHRhY2Nlc3NEZW5pZWRUb1VzZUxlZGdlckRldmljZTogXCLQlNC+0YHRgtGK0L/RitGCINC30LAg0LjQt9C/0L7Qu9C30LLQsNC90LUg0L3QsCBMZWRnZXIg0LUg0L7RgtC60LDQt9Cw0L1cIixcblx0XHRub0FjY291bnRzRm91bmQ6IFwi0J3Rj9C80LAg0L3QsNC80LXRgNC10L3QuCDQv9GA0L7RhNC40LvQuFwiLFxuXHRcdHNlbGVjdFlvdXJBY2NvdW50czogXCLQmNC30LHQtdGA0LXRgtC1INCy0LDRiNC40YLQtSDQv9GA0L7RhNC40LvQuFwiLFxuXHRcdGNvbm5lY3RpbmcxQWNjb3VudDogXCLQodCy0YrRgNC30LLQsNC90LUg0L3QsCAxINC/0YDQvtGE0LjQu1wiLFxuXHRcdGNhbnRGaW5kQW55QWNjb3VudDogXCLQndGP0LzQsCDQvdCw0LzQtdGA0LXQvdC4INC/0YDQvtGE0LjQu9C4LCDRgdGK0LLRgNC30LDQvdC4INGBINGC0L7Qt9C4IExlZGdlci4g0JzQvtC70Y8sINGB0YrQt9C00LDQudGC0LUg0L3QvtCyIE5FQVIg0L/RgNC+0YTQuNC7INC90LBcIixcblx0XHRvckNvbm5lY3RBbkFub3RoZXJMZWRnZXI6IFwi0LjQu9C4INGB0LLRitGA0LbQtdGC0LUg0LTRgNGD0LMgTGVkZ2VyLlwiLFxuXHRcdGNvbm5lY3Rpbmc6IFwi0KHQstGK0YDQt9Cy0LDQvdC1XCIsXG5cdFx0b2ZBY2NvdW50czogXCLQvtGCINC/0YDQvtGE0LjQu9C4XCIsXG5cdFx0ZmFpbGVkVG9BdXRvbWF0aWNhbGx5OiBcItCQ0LLRgtC+0LzQsNGC0LjRh9C90L7RgtC+INC90LDQvNC40YDQsNC90LUg0L3QsCDQv9GA0L7RhNC40LvQsCDQvdC1INCx0LUg0YPRgdC/0LXRiNC90L4uINCS0YrQstC10LTQtdGC0LUg0LPQviDRgNGK0YfQvdC+OlwiLFxuXHRcdG92ZXJ2aWV3VGhlTGlzdE9mQXV0aG9yaXplZDogXCLQn9GA0LXQs9C70LXQtNCw0LnRgtC1INGB0L/QuNGB0YrQutCwINGBINGD0L/RitC70L3QvtC80L7RidC10L3QuCDQv9GA0L7RhNC40LvQuCwg0LfQsNCy0YrRgNGI0LXRgtC1INCy0LvQuNC30LDQvdC10YLQviwg0LrQsNGC0L4g0YnRgNCw0LrQvdC10YLQtSDQstGK0YDRhdGDINCx0YPRgtC+0L3QsCDQv9C+LdC00L7Qu9GDLi5cIixcblx0XHRmaW5pc2g6IFwi0JfQsNCy0YrRgNGI0LXRgtC1XCJcblx0fSxcblx0aW5zdGFsbDoge1xuXHRcdHlvdWxsTmVlZFRvSW5zdGFsbDogXCLQqdC1INGC0YDRj9Cx0LLQsCDQtNCwINC40L3RgdGC0LDQu9C40YDQsNGC0LVcIixcblx0XHR0b0NvbnRpbnVlQWZ0ZXJJbnN0YWxsaW5nOiBcItC30LAg0LTQsCDQv9GA0L7QtNGK0LvQttC40YLQtS4g0KHQu9C10LQg0LjQvdGB0YLQsNC70LjRgNCw0L3QtVwiLFxuXHRcdHJlZnJlc2hUaGVQYWdlOiBcItC/0YDQtdC30LDRgNC10LTQtdGC0LUg0YHRgtGA0LDQvdC40YbQsNGC0LAuXCIsXG5cdFx0b3BlbjogXCLQntGC0LLQvtGA0LXRgtC1XCJcblx0fSxcblx0cXI6IHtcblx0XHRjb3BpZWRUb0NsaXBib2FyZDogXCLQmtC+0L/QuNGA0LDQvdC+INCyINC60LvQuNC/0LHQvtGA0LTQsFwiLFxuXHRcdGZhaWxlZFRvQ29weTogXCLQndC10YPRgdC/0LXRiNC90L4g0LrQvtC/0LjRgNCw0L3QtSDQsiDQutC70LjQv9Cx0L7RgNC00LBcIixcblx0XHRzY2FuV2l0aFlvdXJNb2JpbGU6IFwiINCh0LrQsNC90LjRgNCw0LnRgtC1INGBINC80L7QsdC40LvQvdC+0YLQviDRgdC4INGD0YHRgtGA0L7QudGB0YLQstC+XCIsXG5cdFx0Y29weVRvQ2xpcGJvYXJkOiBcIiDQmtC+0L/QuNGA0LDQudGC0LUg0LIg0LrQu9C40L/QsdC+0YDQtNCwXCIsXG5cdFx0cHJlZmVyVGhlT2ZmaWNpYWw6IFwi0J/RgNC10LTQv9C+0YfQuNGC0LDQvSDQtdC30LjQuiDQt9CwINC60L7RgNC10YHQv9C+0L3QtNC10L3RhtC40Y9cIixcblx0XHRvcGVuOiBcItCe0YLQstC+0YDQtdGC0LVcIlxuXHR9LFxuXHR3YWxsZXRUeXBlczoge1xuXHRcdGhhcmR3YXJlOiBcIkhhcmR3YXJlIFdhbGxldFwiLFxuXHRcdGJyb3dzZXI6IFwiQnJvd3NlciBXYWxsZXRcIixcblx0XHRpbmplY3RlZDogXCJXYWxsZXQgRXh0ZW5zaW9uXCIsXG5cdFx0YnJpZGdlOiBcIkJyaWRnZSBXYWxsZXRcIixcblx0XHRtb2JpbGU6IFwiTW9iaWxlIFdhbGxldFwiLFxuXHRcdFwiaW5zdGFudC1saW5rXCI6IFwiSW5zdGFudCBXYWxsZXRcIlxuXHR9XG59O1xudmFyIGJnID0ge1xuXHRtb2RhbDogbW9kYWwkOFxufTtcblxudmFyIG1vZGFsJDcgPSB7XG5cdHdhbGxldDoge1xuXHRcdGNvbm5lY3RZb3VyV2FsbGV0OiBcIuyngOqwkSDsl7DqsrDtlZjquLBcIixcblx0XHR3aGF0SXNBV2FsbGV0OiBcIuyngOqwkeydgCDrrLTsiqgg7Jet7ZWg7J2EIO2VmOuCmOyalD9cIixcblx0XHRzZWN1cmVBbmRNYW5hZ2U6IFwi64u57Iug7J2YIOuUlOyngO2EuCDsnpDsgrDsnYQg67O07Zi47ZWY6rOgIOq0gOumrO2VqeuLiOuLpC5cIixcblx0XHRzYWZlbHlTdG9yZTogXCLslZTtmLjtmZTtj5DsmYAgTkZU66W8IOyViOyghO2VmOqyjCDsoIDsnqXtlZjqs6Ag7KCE7Iah7ZWgIOyImCDsnojsirXri4jri6QuXCIsXG5cdFx0bG9nSW5Ub0FueTogXCJORUFSIEFwcOyXkCDroZzqt7jsnbjtlanri4jri6QuXCIsXG5cdFx0bm9OZWVkVG9DcmVhdGU6IFwi7IOI66Gc7Jq0IOqzhOygleydtOuCmCDruYTrsIDrsojtmLjrpbwg66eM65OkIO2VhOyalCDsl4bsnbQg7KeA6rCR7J2EIOyXsOqysO2VnCDtm4Qg67CU66GcIOyCrOyaqe2VoCDsiJgg7J6I7Iq164uI64ukLlwiLFxuXHRcdGdldEFXYWxsZXQ6IFwi7KeA6rCRIOqwgOyguOyYpOq4sFwiLFxuXHRcdHVzZUFXYWxsZXQ6IFwi7KeA6rCR7J2EIOyCrOyaqe2VmOyXrCBORUFSIOyekOyCsOydhCDrs7TtmLjCt+q0gOumrO2VmOqzoCwg7JWE7J2065SU7JmAIOu5hOuwgOuyiO2YuCDsl4bsnbQgTkVBUiDslbHsl5Ag66Gc6re47J247ZWgIOyImCDsnojsirXri4jri6QuXCIsXG5cdFx0Y29ubmVjdGlvbkZhaWxlZDogXCLsl7DqsrAg7Iuk7YyoXCIsXG5cdFx0Y29ubmVjdGlvblN1Y2Nlc3NmdWw6IFwi7Jew6rKwIOyEseqztVwiLFxuXHRcdGNvbm5lY3RlZDogXCJDb25uZWN0ZWRcIixcblx0XHRjb25uZWN0aW5nVG86IFwi7Jew6rKwIOykkTogXCIsXG5cdFx0Y29ubmVjdGluZ01lc3NhZ2U6IHtcblx0XHRcdGluamVjdGVkOiBcIuydteyKpO2FkOyFmCDssL3sl5DshJwg7Jew6rKw7J2EIO2ZleyduO2VmOyEuOyalFwiLFxuXHRcdFx0YnJvd3NlcjogXCLrpqzri6TsnbTroIntirgg65CcIOyngOqwkeyXkOyEnCDsl7DqsrDsnYQg7ZmV7J247ZWY7IS47JqUXCIsXG5cdFx0XHRoYXJkd2FyZTogXCJMZWRnZXIg6riw6riw7JeQ7IScIOyXsOqysOydhCDtmZXsnbjtlZjshLjsmpRcIixcblx0XHRcdGJyaWRnZTogXCLsp4DqsJHsl5DshJwg7Jew6rKwIO2ZleyduFwiXG5cdFx0fVxuXHR9LFxuXHRsZWRnZXI6IHtcblx0XHRjb25uZWN0V2l0aExlZGdlcjogXCJMZWRnZXIg7Jew6rKw7ZWY6riwXCIsXG5cdFx0bWFrZVN1cmVZb3VyTGVkZ2VyOiBcIkxlZGdlcuqwgCDslYjsoITtlZjqsowg7Jew6rKw65CY7Ja0IOyeiOqzoCwgTkVBUiDslbHsnbQg7Je066CkIOyeiOuKlCDsp4Ag7ZmV7J247ZWY7IS47JqUXCIsXG5cdFx0XCJjb250aW51ZVwiOiBcIuqzhOyGje2VmOq4sFwiLFxuXHRcdHNwZWNpZnlIRFBhdGg6IFwiSEQgUGF0aCDsp4DsoJXtlZjquLBcIixcblx0XHRlbnRlcllvdXJQcmVmZXJyZWRIRFBhdGg6IFwi7JuQ7ZWY64qUIEhEIFBhdGjrpbwg7ISg7YOd7ZWY6rOgLCDtmZzshLHtmZTrkJwg6rOE7KCV7J20IOyeiOuKlCDsp4Ag6rKA7IOJ7ZWY7IS47JqUXCIsXG5cdFx0c2NhbjogXCLqsoDsg4lcIixcblx0XHRyZXRyeTogXCLri6Tsi5wg7Iuc64+EXCIsXG5cdFx0bGVkZ2VySXNOb3RBdmFpbGFibGU6IFwiTGVkZ2Vy66W8IOyCrOyaqe2VoCDsiJgg7JeG7Iq164uI64ukXCIsXG5cdFx0YWNjZXNzRGVuaWVkVG9Vc2VMZWRnZXJEZXZpY2U6IFwiTGVkZ2VyIOq4sOq4sCDsoJHqt7wg6raM7ZWc7J20IOqxsOu2gOuQmOyXiOyKteuLiOuLpFwiLFxuXHRcdG5vQWNjb3VudHNGb3VuZDogXCLqs4TsoJXsnYQg7LC+7J2EIOyImCDsl4bsirXri4jri6RcIixcblx0XHRzZWxlY3RZb3VyQWNjb3VudHM6IFwi6rOE7KCVIOyEoO2Dne2VmOq4sFwiLFxuXHRcdGNvbm5lY3RpbmcxQWNjb3VudDogXCLtlZjrgpjsnZgg6rOE7KCV7JeQIOyXsOqysFwiLFxuXHRcdGNhbnRGaW5kQW55QWNjb3VudDogXCJMZWRnZXLsmYAg7Jew6rKw65CcIOqzhOygleydhCDssL7snYQg7IiYIOyXhuyKteuLiOuLpC4g7IOI66Gc7Jq0IOqzhOygleydhCDsg53shLHtlZjqsbDrgpggXCIsXG5cdFx0b3JDb25uZWN0QW5Bbm90aGVyTGVkZ2VyOiBcIuuLpOuluCBMZWRnZXLrpbwg7Jew6rKw7ZWY7IS47JqUXCIsXG5cdFx0Y29ubmVjdGluZzogXCLqs4TsoJUg7Jew6rKw7ZWY6riwOiBcIixcblx0XHRvZkFjY291bnRzOiBcIuqwnCDqs4TsoJXsnYQg7LC+7JWY7Iq164uI64ukXCIsXG5cdFx0ZmFpbGVkVG9BdXRvbWF0aWNhbGx5OiBcIuqzhOyglSBJROulvCDssL7sp4Ag66q77ZaI7Iq164uI64ukLiDsiJjrj5nsnLzroZwg7J6F66Cl7ZW07KO87IS47JqULlwiLFxuXHRcdG92ZXJ2aWV3VGhlTGlzdE9mQXV0aG9yaXplZDogXCLsnbjspp3rkJwg6rOE7KCVIOuqqeuhneydhCDtmZXsnbjtlZwg7ZuEIOyVhOuemCDrsoTtirzsnYQg7YG066at7ZWY7JesIOuhnOq3uOyduOydhCDsmYTro4ztlZjshLjsmpRcIixcblx0XHRmaW5pc2g6IFwi7JmE66OMXCJcblx0fSxcblx0d2FsbGV0VHlwZXM6IHtcblx0XHRoYXJkd2FyZTogXCLtlZjrk5zsm6jslrQg7KeA6rCRXCIsXG5cdFx0YnJvd3NlcjogXCLruIzrnbzsmrDsoIAg7KeA6rCRXCIsXG5cdFx0aW5qZWN0ZWQ6IFwi7KeA6rCRIO2ZleyepVwiLFxuXHRcdGJyaWRnZTogXCLruIzrpqzsp4Ag7KeA6rCRXCIsXG5cdFx0bW9iaWxlOiBcIuuqqOuwlOydvCDsp4DqsJFcIixcblx0XHRcImluc3RhbnQtbGlua1wiOiBcIuyduOyKpO2EtO2KuCDsp4DqsJFcIlxuXHR9LFxuXHRpbnN0YWxsOiB7XG5cdFx0eW91bGxOZWVkVG9JbnN0YWxsOiBcIuuLpOydjCDtmZXsnqUg7ZSE66Gc6re4656o7J2EIOyEpOy5mO2VtOyjvOyEuOyalDpcIixcblx0XHR0b0NvbnRpbnVlQWZ0ZXJJbnN0YWxsaW5nOiBcIi4g7ISk7LmYIOyZhOujjCDtm4Qg7Y6Y7J207KeAIOyDiOuhnCDqs6DsuajsnbQg7ZWE7JqU7ZWp64uI64ukLiBcIixcblx0XHRyZWZyZXNoVGhlUGFnZTogXCLsg4jroZwg6rOg7LmoXCIsXG5cdFx0b3BlbjogXCJPcGVuXCJcblx0fSxcblx0cXI6IHtcblx0XHRjb3BpZWRUb0NsaXBib2FyZDogXCLtgbTrpr3rs7Trk5zsl5Ag67O17IKsIOyZhOujjFwiLFxuXHRcdGZhaWxlZFRvQ29weTogXCLtgbTrpr3rs7Trk5zsl5Ag67O17IKsIOyLpO2MqFwiLFxuXHRcdHNjYW5XaXRoWW91ck1vYmlsZTogXCLrqqjrsJTsnbwg7J6l7LmY66W8IOyCrOyaqe2VmOyXrCDsiqTsupTtlbTso7zshLjsmpRcIixcblx0XHRjb3B5VG9DbGlwYm9hcmQ6IFwiIO2BtOumveuztOuTnOyXkCDrs7XsgqztlZjquLBcIixcblx0XHRwcmVmZXJUaGVPZmZpY2lhbDogXCLri6TsnYwg7ZSE66Gc6re4656o7JeQ7IScIOygnOqzte2VmOuKlCDqs7Xsi50g7ZSE66Gc7IS47Iqk66W8IOyEoO2YuO2VmOyLreuLiOq5jDogXCIsXG5cdFx0b3BlbjogXCJPcGVuXCJcblx0fVxufTtcbnZhciBrbyA9IHtcblx0bW9kYWw6IG1vZGFsJDdcbn07XG5cbnZhciBtb2RhbCQ2ID0ge1xuXHR3YWxsZXQ6IHtcblx0XHRjb25uZWN0WW91cldhbGxldDogXCJL4bq/dCBu4buRaSB2w60gY+G7p2EgYuG6oW5cIixcblx0XHR3aGF0SXNBV2FsbGV0OiBcIlbDrSBsw6AgZ8OsP1wiLFxuXHRcdHNlY3VyZUFuZE1hbmFnZTogXCJC4bqjbyBt4bqtdCAmIFF14bqjbiBsw70gdMOgaSBz4bqjbiBz4buRIGPhu6dhIGLhuqFuXCIsXG5cdFx0c2FmZWx5U3RvcmU6IFwiTMawdSB0cuG7ryB2w6AgY2h1eeG7g24gdGnhu4FuIMSRaeG7h24gdOG7rSB2w6AgTkZUIGPhu6dhIGLhuqFuIG3hu5l0IGPDoWNoIGFuIHRvw6BuLlwiLFxuXHRcdGxvZ0luVG9Bbnk6IFwixJDEg25nIG5o4bqtcCB2w6BvIGLhuqV0IGvhu7Mg4bupbmcgZOG7pW5nIHRyw6puIE5FQVJcIixcblx0XHRub05lZWRUb0NyZWF0ZTogXCJLaMO0bmcgY+G6p24gdOG6oW8gdMOgaSBraG/huqNuIGhv4bq3YyB0aMO0bmcgdGluIMSRxINuZyBuaOG6rXAgbeG7m2kuIEvhur90IG7hu5FpIHbDrSBj4bunYSBi4bqhbiB2w6AgYuG6r3QgxJHhuqd1IVwiLFxuXHRcdGdldEFXYWxsZXQ6IFwiVOG6oW8gVsOtXCIsXG5cdFx0dXNlQVdhbGxldDogXCJT4butIGThu6VuZyB2w60gxJHhu4MgYuG6o28gbeG6rXQgdsOgIHF14bqjbiBsw70gdMOgaSBz4bqjbiB0csOqbiBORUFSIGPhu6dhIGLhuqFuIHbDoCDEkcSDbmcgbmjhuq1wIHbDoG8gYuG6pXQga+G7syDhu6luZyBk4bulbmcgTkVBUiBuw6BvLCBraMO0bmcgY+G6p24gdMOqbiBuZ8aw4budaSBkw7luZyB2w6AgbeG6rXQga2jhuql1LlwiLFxuXHRcdGNvbm5lY3Rpb25GYWlsZWQ6IFwiS+G6v3QgbuG7kWkgdGjhuqV0IGLhuqFpXCIsXG5cdFx0Y29ubmVjdGlvblN1Y2Nlc3NmdWw6IFwiS+G6v3QgbuG7kWkgdGjDoG5oIGPDtG5nXCIsXG5cdFx0Y29ubmVjdGVkOiBcIsSQw6Mga+G6v3QgbuG7kWlcIixcblx0XHRjb25uZWN0aW5nVG86IFwixJBhbmcga+G6v3QgbuG7kWkgdOG7m2lcIixcblx0XHRjb25uZWN0aW5nTWVzc2FnZToge1xuXHRcdFx0aW5qZWN0ZWQ6IFwiWMOhYyBuaOG6rW4ga+G6v3QgbuG7kWkgdHJvbmcgY+G7rWEgc+G7lSB0aeG7h24gw61jaCBt4bufIHLhu5luZ1wiLFxuXHRcdFx0YnJvd3NlcjogXCJYw6FjIG5o4bqtbiBr4bq/dCBu4buRaSB0cm9uZyB2w60gc2F1IGtoaSDEkcaw4bujYyBjaHV54buDbiBoxrDhu5tuZ1wiLFxuXHRcdFx0aGFyZHdhcmU6IFwiWMOhYyBuaOG6rW4ga+G6v3QgbuG7kWkgduG7m2kgdsOtIGzhuqFuaFwiLFxuXHRcdFx0YnJpZGdlOiBcIljDoWMgbmjhuq1uIGvhur90IG7hu5FpIHRyb25nIHbDrVwiXG5cdFx0fVxuXHR9LFxuXHRsZWRnZXI6IHtcblx0XHRjb25uZWN0V2l0aExlZGdlcjogXCJL4bq/dCBu4buRaSB2w60gTGVkZ2VyXCIsXG5cdFx0bWFrZVN1cmVZb3VyTGVkZ2VyOiBcIsSQ4bqjbSBi4bqjbyBMZWRnZXIgY+G7p2EgYuG6oW4gxJHGsOG7o2Mga+G6v3QgbuG7kWkgYW4gdG/DoG4gdsOgIOG7qW5nIGThu6VuZyBORUFSIMSRYW5nIG3hu58gc+G6tW4gdHLDqm4gdGhp4bq/dCBi4buLXCIsXG5cdFx0XCJjb250aW51ZVwiOiBcIlRp4bq/cCB04bulY1wiLFxuXHRcdHNwZWNpZnlIRFBhdGg6IFwiQ2jhu4kgxJHhu4tuaCBIRCBQYXRoXCIsXG5cdFx0ZW50ZXJZb3VyUHJlZmVycmVkSERQYXRoOiBcIk5o4bqtcCBIRCBQYXRoIGPhu6dhIGLhuqFuLCBzYXUgxJHDsyBxdcOpdCB0w6xtIGPDoWMgdMOgaSBraG/huqNuIGhv4bqhdCDEkeG7mW5nXCIsXG5cdFx0c2NhbjogXCJRdcOpdFwiLFxuXHRcdHJldHJ5OiBcIlRo4butIGzhuqFpXCIsXG5cdFx0bGVkZ2VySXNOb3RBdmFpbGFibGU6IFwiTGVkZ2VyIGtow7RuZyBraOG6oyBk4bulbmdcIixcblx0XHRhY2Nlc3NEZW5pZWRUb1VzZUxlZGdlckRldmljZTogXCJUcnV5IGPhuq1wIExlZGdlciBi4buLIHThu6sgY2jhu5FpXCIsXG5cdFx0bm9BY2NvdW50c0ZvdW5kOiBcIktow7RuZyB0w6xtIHRo4bqleSB0w6BpIGtob+G6o25cIixcblx0XHRzZWxlY3RZb3VyQWNjb3VudHM6IFwiQ2jhu41uIHTDoGkga2hv4bqjbiBj4bunYSBi4bqhblwiLFxuXHRcdGNvbm5lY3RpbmcxQWNjb3VudDogXCLEkGFuZyBr4bq/dCBu4buRaSAxIHTDoGkga2hv4bqjblwiLFxuXHRcdGNhbnRGaW5kQW55QWNjb3VudDogXCJLaMO0bmcgdGjhu4MgdMOsbSB0aOG6pXkgYuG6pXQga+G7syB0w6BpIGtob+G6o24gbsOgbyDEkcaw4bujYyBsacOqbiBr4bq/dCB24bubaSBMZWRnZXIgbsOgeS4gVnVpIGzDsm5nIHThuqFvIG3hu5l0IHTDoGkga2hv4bqjbiBORUFSIG3hu5tpXCIsXG5cdFx0b3JDb25uZWN0QW5Bbm90aGVyTGVkZ2VyOiBcImhv4bq3YyBr4bq/dCBu4buRaSB24bubaSB2w60gTGVkZ2VyIGtow6FjLlwiLFxuXHRcdGNvbm5lY3Rpbmc6IFwixJBhbmcga+G6v3QgbuG7kWlcIixcblx0XHRvZkFjY291bnRzOiBcImPhu6dhIHTDoGkga2hv4bqjblwiLFxuXHRcdGZhaWxlZFRvQXV0b21hdGljYWxseTogXCJLaMO0bmcgdGjhu4MgdOG7sSDEkeG7mW5nIHTDrG0gaWQgdMOgaSBraG/huqNuLiBOaOG6rXAgdGjhu6cgY8O0bmc6XCIsXG5cdFx0b3ZlcnZpZXdUaGVMaXN0T2ZBdXRob3JpemVkOiBcIlThu5VuZyBxdWFuIGRhbmggc8OhY2ggY8OhYyB0w6BpIGtob+G6o24gxJHGsOG7o2Mg4buneSBxdXnhu4FuLCBob8OgbiB04bqldCDEkcSDbmcgbmjhuq1wIGLhurFuZyBjw6FjaCBi4bqlbSB2w6BvIG7DunQgYsOqbiBkxrDhu5tpLlwiLFxuXHRcdGZpbmlzaDogXCJIb8OgbiB0aMOgbmhcIlxuXHR9LFxuXHRpbnN0YWxsOiB7XG5cdFx0eW91bGxOZWVkVG9JbnN0YWxsOiBcIkLhuqFuIHPhur0gY+G6p24gY8OgaSDEkeG6t3RcIixcblx0XHR0b0NvbnRpbnVlQWZ0ZXJJbnN0YWxsaW5nOiBcIsSR4buDIGLhuq90IMSR4bqndS4gU2F1IGtoaSBjw6BpIMSR4bq3dCB4b25nXCIsXG5cdFx0cmVmcmVzaFRoZVBhZ2U6IFwiVOG6o2kgbOG6oWkgdHJhbmcuXCIsXG5cdFx0b3BlbjogXCJN4bufXCJcblx0fSxcblx0cXI6IHtcblx0XHRjb3BpZWRUb0NsaXBib2FyZDogXCLEkMOjIHNhbyBjaMOpcCB2w6BvIGLhuqNuZyBnaGkgdOG6oW1cIixcblx0XHRmYWlsZWRUb0NvcHk6IFwiU2FvIGNow6lwIHbDoG8gYuG6o25nIGdoaSB04bqhbSB0aOG6pXQgYuG6oWlcIixcblx0XHRzY2FuV2l0aFlvdXJNb2JpbGU6IFwiUXXDqXQgduG7m2kgxJFp4buHbiB0aG/huqFpIGPhu6dhIGLhuqFuXCIsXG5cdFx0Y29weVRvQ2xpcGJvYXJkOiBcIiBTYW8gY2jDqXAgdsOgbyBi4bqjbmcgZ2hpIHThuqFtXCIsXG5cdFx0cHJlZmVyVGhlT2ZmaWNpYWw6IFwiRGlhbG9ndWUgY2jDrW5oIHRo4bupYyBj4bunYVwiLFxuXHRcdG9wZW46IFwiTeG7n1wiXG5cdH0sXG5cdHdhbGxldFR5cGVzOiB7XG5cdFx0aGFyZHdhcmU6IFwiVsOtIGzhuqFuaFwiLFxuXHRcdGJyb3dzZXI6IFwiVsOtIHRyw6xuaCBkdXnhu4d0XCIsXG5cdFx0aW5qZWN0ZWQ6IFwiVsOtIHRp4buHbiDDrWNoIG3hu58gcuG7mW5nXCIsXG5cdFx0YnJpZGdlOiBcIlbDrSBD4bqndVwiLFxuXHRcdG1vYmlsZTogXCJWw60gTW9iaWxlXCIsXG5cdFx0XCJpbnN0YW50LWxpbmtcIjogXCJWw60gdOG7qWMgdGjDrFwiXG5cdH0sXG5cdGV4cG9ydEFjY291bnRzOiB7XG5cdFx0Y2hvb3NlQVdhbGxldDogXCJDaOG7jW4gdsOtXCIsXG5cdFx0dHJhbnNmZXJZb3VyQWNjb3VudHM6IFwiQ2h1eeG7g24gdMOgaSBraG/huqNuXCIsXG5cdFx0c2VsZWN0QVdhbGxldDogXCJDaOG7jW4gdsOtIHBow7kgaOG7o3AgduG7m2kgbmh1IGPhuqd1IGPhu6dhIGLhuqFuLCB2w60gxJHGsOG7o2MgY2jhu41uIGPhuqduIGjhu5cgdHLhu6MgY8OhYyB0w6BpIGtob+G6o24gxJFhbmcgc+G7rSBk4bulbmcuXCIsXG5cdFx0c2VsZWN0WW91ckFjY291bnRzOiBcIkNo4buNbiB0w6BpIGtob+G6o25cIixcblx0XHRhZnRlckRlY2lkZTogXCJTYXUga2hpIGNo4buNbiDEkcaw4bujYyB0w6BpIGtob+G6o24gYuG6oW4gY8OzIGNodXnhu4NuLlwiLFxuXHRcdGRpc2NsYWltZXI6IFwiQuG6oW4ga2jDtG5nIHRo4buDIGNodXnhu4NuIHTDoGkga2hv4bqjbiBu4bq/dSB0w6BpIGtob+G6o24gxJHDsyBjaMawYSDEkcaw4bujYyBuaOG6rW4gdGnhu4FuIGhv4bq3YyBjaMawYSBwaMOhdCBzaW5oIGdpYW8gZOG7i2NoIHRyw6puIE5FQVIuXCIsXG5cdFx0d2FybmluZzogXCJraMO0bmcgaOG7lyB0cuG7oyB4deG6pXQgdMOgaSBraG/huqNuLiBWdWkgbMOybmcgY2jhu41uIHbDrSBraMOhYy5cIixcblx0XHR3YWxsZXRUeXBlczoge1xuXHRcdFx0aGFyZHdhcmU6IFwiVsOtIGzhuqFuaFwiLFxuXHRcdFx0YnJvd3NlcjogXCJWw60gdHLDrG5oIGR1eeG7h3RcIixcblx0XHRcdGluamVjdGVkOiBcIlbDrSB0aeG7h24gw61jaCBt4bufIHLhu5luZ1wiLFxuXHRcdFx0YnJpZGdlOiBcIlbDrSBD4bqndVwiLFxuXHRcdFx0bW9iaWxlOiBcIlbDrSBNb2JpbGVcIlxuXHRcdH0sXG5cdFx0c2VsZWN0QWNjb3VudHM6IHtcblx0XHRcdHRpdGxlOiBcIkNo4buNbiB0w6BpIGtob+G6o24gxJHhu4MgY2h1eeG7g25cIixcblx0XHRcdGJ1dHRvbjogXCJM4bqleSBj4bulbSBt4bqtdCBraOG6qXVcIixcblx0XHRcdGRlc2VsZWN0QWxsOiBcIkLhu48gY2jhu41uIHThuqV0IGPhuqNcIixcblx0XHRcdHNlbGVjdEFsbDogXCJDaOG7jW4gdOG6pXQgY+G6o1wiLFxuXHRcdFx0dW5hdmFpbGFibGU6IFwiQ2h1eeG7g24ga2jDtG5nIGto4bqjIGThu6VuZ1wiLFxuXHRcdFx0ZXJyb3I6IFwiVMOgaSBraG/huqNuIGtow7RuZyB04buTbiB04bqhaVwiLFxuXHRcdFx0d2FybmluZ0xlZGdlcjogXCJZw6p1IGPhuqd1IGjhu5cgdHLhu6MgTGVkZ2VyXCIsXG5cdFx0XHRub0JhbGFuY2U6IFwiVMOgaSBraG/huqNuIHRy4buRbmdcIlxuXHRcdH0sXG5cdFx0Z2V0UGFzc3BocmFzZToge1xuXHRcdFx0dGl0bGU6IFwiU2FvIGNow6lwIG3huq10IGto4bqpdSB04bqhbSB0aOG7nWlcIixcblx0XHRcdGRlc2M6IFwiQuG6oW4gc+G6vSBj4bqnbiBuaOG6rXAgbeG6rXQga2jhuql1IGtoaSBi4bqvdCDEkeG6p3UgeHXhuqV0IGPDoWMga2hv4bqjbiB04bubaSB2w60ga2jDoWMuXCIsXG5cdFx0XHRidXR0b246IFwiVGnhur9wIHThu6VjXCIsXG5cdFx0XHRsYWJlbDogXCJC4bqlbSDEkeG7gyBzYW8gY2jDqXBcIixcblx0XHRcdGNoZWNrTGFiZWw6IFwiVMO0aSDEkcOjIGNow6lwIGhv4bq3YyBnaGkgbOG6oWkgbeG6rXQga2jhuql1XCJcblx0XHR9LFxuXHRcdGNvbXBsZXRlOiB7XG5cdFx0XHR0aXRsZTogXCJIb8OgbiB0aMOgbmggY2h1eeG7g25cIixcblx0XHRcdGRlc2NPbmU6IFwiQuG6oW4gc+G6vSDEkcaw4bujYyBjaHV54buDbiBoxrDhu5tuZyB04bubaSB0w6BpIGtob+G6o24gxJHDoyBjaOG7jW4gxJHhu4MgaG/DoG4gdOG6pXQgcXXDoSB0csOsbmguXCIsXG5cdFx0XHRkZXNjVHdvOiBcIlNhdSBraGkgbmjhuq1wLCBuaOG6pW4gbsO6dCDEkeG7gyBob8OgbiB04bqldCBxdXkgdHLDrG5oIGNodXnhu4NuLlwiLFxuXHRcdFx0YnV0dG9uOiBcIkhvw6BuIHRow6BuaFwiXG5cdFx0fVxuXHR9XG59O1xudmFyIGNvbXBvbmVudCA9IHtcblx0Y2xpY2tUb0NvcHk6IHtcblx0XHRsYWJlbDogXCLEkMOjIHNhbyBjaMOpcFwiLFxuXHRcdHRvb2x0aXA6IFwiQuG6pW0gxJHhu4Mgc2FvIGNow6lwXCJcblx0fVxufTtcbnZhciB2aSA9IHtcblx0bW9kYWw6IG1vZGFsJDYsXG5cdGNvbXBvbmVudDogY29tcG9uZW50XG59O1xuXG52YXIgbW9kYWwkNSA9IHtcblx0d2FsbGV0OiB7XG5cdFx0Y29ubmVjdFlvdXJXYWxsZXQ6IFwi4KSF4KSq4KSo4KS+IOCkteClieCksuClh+CknyAoV2FsbGV0KSDgpJXgpKjgpYfgpJXgpY3gpJ8g4KSV4KSw4KWH4KSC4KWkXCIsXG5cdFx0d2hhdElzQVdhbGxldDogXCLgpLXgpYngpLLgpYfgpJ8g4KSV4KWN4KSv4KS+IOCkueCliD9cIixcblx0XHRzZWN1cmVBbmRNYW5hZ2U6IFwi4KS44KWB4KSw4KSV4KWN4KS34KS/4KSkIOCklOCksCDgpKrgpY3gpLDgpKzgpILgpKfgpL/gpKQg4KSV4KSw4KWH4KSC4KWkXCIsXG5cdFx0c2FmZWx5U3RvcmU6IFwi4KSF4KSq4KSo4KWAIOCkleCljeCksOCkv+CkquCljeCkn+Cli+CkleCksOClh+CkguCkuOClgCDgpJTgpLAg4KSP4KSo4KSP4KSr4KSf4KWAIOCkleCliyDgpLjgpYHgpLDgpJXgpY3gpLfgpL/gpKQg4KSw4KWC4KSqIOCkuOClhyDgpLjgpY3gpJ/gpYvgpLAg4KSU4KSwIOCkn+CljeCksOCkvuCkguCkuOCkq+CksCDgpJXgpLDgpYfgpILgpaRcIixcblx0XHRsb2dJblRvQW55OiBcIk5FQVIg4KSq4KSwIOCkleCkv+CkuOClgCDgpK3gpYAg4KSQ4KSqIOCkruClh+CkgiDgpLjgpL7gpIfgpKgg4KSH4KSoIOCkleCksOClh+CkguClpFwiLFxuXHRcdG5vTmVlZFRvQ3JlYXRlOiBcIuCkqOCkjyDgpJbgpL7gpKTgpYcg4KSv4KS+IOCksuClieCkl+Ckv+CkqCDgpKzgpKjgpL7gpKjgpYcg4KSV4KWAIOCkhuCkteCktuCljeCkr+CkleCkpOCkviDgpKjgpLngpYDgpIIg4KS54KWI4KWkIOCkheCkquCkqOCkviDgpLXgpYngpLLgpYfgpJ8oTkVBUiBXYWxsZXQp4KSV4KSo4KWH4KSV4KWN4KSfIOCkleCksOClh+CkgiDgpJTgpLAg4KSG4KSw4KSC4KStIOCkleCksOClh+CkguClpFwiLFxuXHRcdGdldEFXYWxsZXQ6IFwi4KSP4KSVIOCkteClieCksuClh+CknyDgpKzgpKjgpL7gpI/gpIHgpaRcIixcblx0XHR1c2VBV2FsbGV0OiBcIuCkheCkquCkqOClgCBORUFSIOCkuOCkguCkquCkpOCljeCkpOCkv+Ckr+Cli+CkgiDgpJXgpYsg4KS44KWB4KSw4KSV4KWN4KS34KS/4KSkIOCklOCksCDgpKrgpY3gpLDgpKzgpILgpKfgpL/gpKQg4KSV4KSw4KSo4KWHIOCkleClhyDgpLLgpL/gpI8g4KS14KWJ4KSy4KWH4KSfIOCkleCkviDgpIngpKrgpK/gpYvgpJcg4KSV4KSw4KWH4KSCIOCklOCksCDgpJXgpL/gpLjgpYAg4KSt4KWAIE5FQVIg4KSQ4KSqIChhcHApIOCkruClh+CkgiDgpLLgpYngpJcg4KSH4KSoIOCkleCksOClh+Ckgiwg4KSV4KS/4KS44KWAIOCkieCkquCkr+Cli+Ckl+CkleCksOCljeCkpOCkviAodXNlcikg4KSo4KS+4KSuIOCklOCksCDgpKrgpL7gpLjgpLXgpLDgpY3gpKEg4KSV4KWAIOCkhuCkteCktuCljeCkr+CkleCkpOCkviDgpKjgpLngpYDgpIIg4KS54KWI4KWkXCIsXG5cdFx0Y29ubmVjdGlvbkZhaWxlZDogXCLgpJXgpKjgpYfgpJXgpY3gpLbgpKgg4KS14KS/4KSr4KSyfFwiLFxuXHRcdGNvbm5lY3Rpb25TdWNjZXNzZnVsOiBcIuCkleCkqOClh+CkleCljeCktuCkqCDgpLjgpKvgpLJ8XCIsXG5cdFx0Y29ubmVjdGVkOiBcIuCkteClieCksuClh+CknyDgpJzgpYHgpZwg4KSX4KSv4KS+fFwiLFxuXHRcdGNvbm5lY3RpbmdUbzogXCLgpLXgpYngpLLgpYfgpJ8g4KSc4KWB4KWcIOCksOCkueCkviDgpLngpYd8XCIsXG5cdFx0Y29ubmVjdGluZ01lc3NhZ2U6IHtcblx0XHRcdGluamVjdGVkOiBcIuCkj+CkleCljeCkuOCkn+Clh+CkguCktuCkqCDgpLXgpL/gpILgpKHgpYsg4KSu4KWH4KSCIOCkleCkqOClh+CkleCljeCktuCkqCDgpJXgpYAg4KSq4KWB4KS34KWN4KSf4KS/IOCkleCksOClh+CkgnxcIixcblx0XHRcdGJyb3dzZXI6IFwi4KSw4KWA4KSh4KS+4KSv4KSw4KWH4KSV4KWN4KSfIOCkueCli+CkqOClhyDgpJXgpYcg4KSs4KS+4KSmIOCkteClieCksuClh+CknyDgpK7gpYfgpIIg4KSV4KSo4KWH4KSV4KWN4KS24KSoIOCkleClgCDgpKrgpYHgpLfgpY3gpJ/gpL8g4KSV4KSw4KWH4KSCfFwiLFxuXHRcdFx0aGFyZHdhcmU6IFwi4KSV4KWL4KSy4KWN4KShIOCkteClieCksuClh+CknyDgpJXgpYcg4KS44KS+4KSlIOCkleCkqOClh+CkleCljeCktuCkqCDgpJXgpYAg4KSq4KWB4KS34KWN4KSf4KS/IOCkleCksOClh+CkgnxcIlxuXHRcdH1cblx0fSxcblx0bGVkZ2VyOiB7XG5cdFx0Y29ubmVjdFdpdGhMZWRnZXI6IFwi4KSy4KWH4KSc4KSwKExlZGdlcingpLXgpYngpLLgpYfgpJ8g4KSV4KSo4KWH4KSV4KWN4KSfIOCkleCksOClh+CkgnxcIixcblx0XHRtYWtlU3VyZVlvdXJMZWRnZXI6IFwi4KS44KWB4KSo4KS/4KS24KWN4KSa4KS/4KSkIOCkleCksOClh+CkgiDgpJXgpL8g4KSG4KSq4KSV4KS+IOCksuClh+CknOCksCDgpLjgpYHgpLDgpJXgpY3gpLfgpL/gpKQg4KSw4KWC4KSqIOCkuOClhyDgpJzgpYHgpKHgpLzgpL4g4KS54KWB4KSGIOCkueCliCDgpJTgpLAgTkVBUiDgpJDgpKog4KSG4KSq4KSV4KWHIOCkoeCkv+CkteCkvuCkh+CkuCAoRGV2aWNlKeCkquCksCDgpKrgpLngpLLgpYcg4KS44KWHIOCkueClgCDgpJbgpYHgpLLgpL4g4KS54KWIfFwiLFxuXHRcdFwiY29udGludWVcIjogXCLgpJzgpL7gpLDgpYAg4KSw4KSW4KWHfFwiLFxuXHRcdHNwZWNpZnlIRFBhdGg6IFwi4KS54KS+4KSw4KWN4KShIOCkoeCkv+CkuOCljeCklShIYXJkIERpc2sp4KSq4KSlKFBhdGgp4KSo4KS/4KSw4KWN4KSn4KS+4KSw4KS/4KSkIOCkleCksOClh3xcIixcblx0XHRlbnRlcllvdXJQcmVmZXJyZWRIRFBhdGg6IFwi4KSF4KSq4KSo4KS+IOCkj+CkmuCkoeClgCDgpKrgpKUg4KSm4KSw4KWN4KScIOCkleCksOClh+Ckgiwg4KSr4KS/4KSwIOCkuOCkleCljeCksOCkv+CkryDgpJbgpL7gpKTgpYvgpIIg4KSV4KWHIOCksuCkv+CkjyDgpLjgpY3gpJXgpYjgpKgg4KSV4KSw4KWH4KSCfFwiLFxuXHRcdHNjYW46IFwi4KS44KWN4KSV4KWI4KSoIOCkleCksOClh3xcIixcblx0XHRyZXRyeTogXCLgpKbgpYvgpKzgpL7gpLDgpL4g4KSq4KWN4KSw4KSv4KS+4KS4IOCkleCksOClh3xcIixcblx0XHRsZWRnZXJJc05vdEF2YWlsYWJsZTogXCLgpLLgpYfgpJzgpLAg4KSJ4KSq4KSy4KSs4KWN4KSnIOCkqOCkueClgOCkgiDgpLngpYh8XCIsXG5cdFx0YWNjZXNzRGVuaWVkVG9Vc2VMZWRnZXJEZXZpY2U6IFwi4KSy4KWH4KSc4KSwIOCkoeCkv+CkteCkvuCkh+CkuCDgpJXgpL4g4KSJ4KSq4KSv4KWL4KSXIOCkleCksOCkqOClhyDgpJXgpYcg4KSy4KS/4KSPIOCkquCljeCksOCkteClh+CktiDgpKjgpL/gpLfgpYfgpKd8XCIsXG5cdFx0bm9BY2NvdW50c0ZvdW5kOiBcIuCkluCkvuCkpOCkviDgpKjgpLngpYDgpIIg4KSu4KS/4KSy4KS+fFwiLFxuXHRcdHNlbGVjdFlvdXJBY2NvdW50czogXCLgpIXgpKrgpKjgpYcg4KSW4KS+4KSk4KWHIOCkmuClgeCkqOClh+CkgnxcIixcblx0XHRjb25uZWN0aW5nMUFjY291bnQ6IFwi4KSP4KSVIOCkluCkvuCkpOCkviDgpJXgpKjgpYfgpJXgpY3gpJ8g4KS54KWLIOCksOCkueCkviDgpLngpYh8XCIsXG5cdFx0Y2FudEZpbmRBbnlBY2NvdW50OiBcIuCkh+CkuCDgpLLgpYfgpJzgpLAg4KS44KWHIOCknOClgeCkoeCkvOCkviDgpJXgpYvgpIgg4KSW4KS+4KSk4KS+IOCkqOCkueClgOCkgiDgpK7gpL/gpLLgpL7gpaQg4KSV4KWD4KSq4KSv4KS+IOCkj+CklSDgpKjgpK/gpL4gTkVBUiDgpJbgpL7gpKTgpL4g4KSs4KSo4KS+4KSP4KSBfFwiLFxuXHRcdG9yQ29ubmVjdEFuQW5vdGhlckxlZGdlcjogXCLgpIXgpKXgpLXgpL4g4KSm4KWC4KS44KSw4KWHIOCksuClh+CknOCksCDgpLXgpYngpLLgpYfgpJ8g4KS44KWHIOCkleCkqOClh+CkleCljeCknyDgpJXgpLDgpYfgpILgpaRcIixcblx0XHRjb25uZWN0aW5nOiBcIuCknOClgeClnCDgpLDgpLngpL4g4KS54KWHfFwiLFxuXHRcdG9mQWNjb3VudHM6IFwi4KSW4KS+4KSk4KS+IOCkheCkrCDgpJzgpYHgpZzgpL4g4KSo4KS54KWA4KSCIOCkueClh3xcIixcblx0XHRmYWlsZWRUb0F1dG9tYXRpY2FsbHk6IFwi4KSW4KS+4KSk4KS+IOCkhuCkiOCkoeClgCDgpLjgpY3gpLXgpJrgpL7gpLLgpL/gpKQg4KSw4KWC4KSqIOCkuOClhyDgpJbgpYvgpJzgpKjgpYcg4KSu4KWH4KSCIOCkheCkuOCkruCksOCljeCkpeClpCDgpK7gpYjgpKjgpY3gpK/gpYHgpIXgpLIgKE1hbnVhbGwpIOCksOClguCkqiDgpLjgpYcg4KSV4KWL4KS24KS/4KS2IOCkleCksOClh+CkgnxcIixcblx0XHRvdmVydmlld1RoZUxpc3RPZkF1dGhvcml6ZWQ6IFwi4KSF4KS14KSy4KWL4KSV4KSoIOCkheCkp+Ckv+CkleClg+CkpCDgpJXgpYAg4KS44KWC4KSa4KWALCDgpKjgpYDgpJrgpYcg4KSm4KS/4KSPIOCkl+CkjyDgpKzgpJ/gpKgg4KSq4KSwIOCkleCljeCksuCkv+CklSDgpJXgpLDgpJXgpYcg4KSy4KWJ4KSX4KS/4KSoIOCkquClguCksOCkviDgpJXgpLDgpYfgpILgpaRcIixcblx0XHRmaW5pc2g6IFwi4KS44KSu4KS+4KSq4KWN4KSkfFwiXG5cdH0sXG5cdGluc3RhbGw6IHtcblx0XHR5b3VsbE5lZWRUb0luc3RhbGw6IFwi4KSG4KSq4KSV4KWLIOCkh+CkguCkuOCljeCkn+ClieCksiDgpJXgpLDgpKjgpL4g4KS54KWL4KSX4KS+fFwiLFxuXHRcdHRvQ29udGludWVBZnRlckluc3RhbGxpbmc6IFwi4KSH4KSC4KS44KWN4KSf4KWJ4KSyIOCkleCksOCkqOClhyDgpJXgpYcg4KSs4KS+4KSmIOCknOCkvuCksOClgCDgpLDgpJbgpYd8XCIsXG5cdFx0cmVmcmVzaFRoZVBhZ2U6IFwi4KSq4KWB4KSoOiDgpLLgpYvgpKEg4KSV4KSw4KWH4KSC4KWkXCIsXG5cdFx0b3BlbjogXCLgpJbgpYvgpLLgpYd8XCJcblx0fSxcblx0cXI6IHtcblx0XHRjb3BpZWRUb0NsaXBib2FyZDogXCLgpJXgpY3gpLLgpL/gpKrgpKzgpYvgpLDgpY3gpKEoQ2xpcGJvYXJkKeCkquCksCDgpJXgpYngpKrgpYAg4KSV4KS/4KSv4KS+IOCkl+Ckr+CkvnxcIixcblx0XHRmYWlsZWRUb0NvcHk6IFwi4KSV4KWN4KSy4KS/4KSq4KSs4KWL4KSw4KWN4KShIOCkquCksCDgpJXgpYngpKrgpYAg4KSV4KSw4KSo4KS+IOCkteCkv+Ckq+CksiDgpLDgpLngpL58XCIsXG5cdFx0c2NhbldpdGhZb3VyTW9iaWxlOiBcIuCkheCkquCkqOClhyDgpKvgpYvgpKggKE1vYmlsZSngpLjgpYcg4KS44KWN4KSV4KWI4KSoIOCkleCksOClh+CkgnxcIixcblx0XHRjb3B5VG9DbGlwYm9hcmQ6IFwiIOCkleCljeCksuCkv+CkquCkrOCli+CksOCljeCkoSDgpKrgpLAg4KSV4KWJ4KSq4KWAIOCkleCksOClh+CkgnxcIixcblx0XHRwcmVmZXJUaGVPZmZpY2lhbDogXCLgpIbgpKfgpL/gpJXgpL7gpLDgpL/gpJUg4KS44KSC4KS14KS+4KSmIOCkleCliyDgpKrgpY3gpLDgpL7gpKXgpK7gpL/gpJXgpKTgpL4g4KSm4KWH4KSCfFwiLFxuXHRcdG9wZW46IFwi4KSW4KWL4KSy4KWHfFwiXG5cdH0sXG5cdHdhbGxldFR5cGVzOiB7XG5cdFx0aGFyZHdhcmU6IFwiSGFyZHdhcmUgV2FsbGV0XCIsXG5cdFx0YnJvd3NlcjogXCJCcm93c2VyIFdhbGxldFwiLFxuXHRcdGluamVjdGVkOiBcIldhbGxldCBFeHRlbnNpb25cIixcblx0XHRicmlkZ2U6IFwiQnJpZGdlIFdhbGxldFwiLFxuXHRcdG1vYmlsZTogXCJNb2JpbGUgV2FsbGV0XCIsXG5cdFx0XCJpbnN0YW50LWxpbmtcIjogXCJJbnN0YW50IFdhbGxldFwiXG5cdH1cbn07XG52YXIgaGkgPSB7XG5cdG1vZGFsOiBtb2RhbCQ1XG59O1xuXG52YXIgbW9kYWwkNCA9IHtcblx0d2FsbGV0OiB7XG5cdFx0Y29ubmVjdFlvdXJXYWxsZXQ6IFwi2LXZhCDZhdit2YHYuNiq2YNcIixcblx0XHR3aGF0SXNBV2FsbGV0OiBcItmF2Kcg2YfZiiDYp9mE2YXYrdmB2LjYqdifXCIsXG5cdFx0c2VjdXJlQW5kTWFuYWdlOiBcItiq2KPZhdmK2YYg2YjYpdiv2KfYsdipINin2YTZhdmF2KrZhNmD2KfYqiDYp9mE2LHZgtmF2YrYqSDYp9mE2K7Yp9i12Kkg2KjZg1wiLFxuXHRcdHNhZmVseVN0b3JlOiBcItmC2YUg2KjYqtiu2LLZitmGINmIINin2LHYs9in2YQg2LnZhdmE2KfYqtmDINmIINij2LXZiNmE2YMg2KfZhNix2YLZhdmK2Kkg2KjYo9mF2KfZhlwiLFxuXHRcdGxvZ0luVG9Bbnk6IFwi2LPYrNmEINin2YTYr9iu2YjZhCDYpdmE2Ykg2KPZiiDYqti32KjZitmCINmK2LPYqtiu2K/ZhSDZhtmK2LFcIixcblx0XHRub05lZWRUb0NyZWF0ZTogXCIu2YTYpyDYr9in2LnZiiDZhNil2YbYtNin2KEg2K3Ys9in2Kgg2KzYr9mK2K8uINmB2YLYtyDZgtmFINio2KrZiNi12YrZhCDZhdit2YHYuNiq2YMg2YjYp9mG2LfZhNmCXCIsXG5cdFx0Z2V0QVdhbGxldDogXCLYp9it2LXZhCDYudmE2Ykg2YXYrdmB2LjYqVwiLFxuXHRcdHVzZUFXYWxsZXQ6IFwi2KfYs9iq2K7Yr9mFINmF2K3Zgdi42Kkg2YTYqtij2YXZitmGINmI2KXYr9in2LHYqSDYo9i12YjZhCDZhtmK2LEg2KfZhNiu2KfYtdipINio2YPYjCDZiNin2K/YrtmEINmE2KPZiiDYqti32KjZitmCINmK2LPYqtiu2K/ZhSDZhtmK2LEg2K/ZiNmGINin2YTYrdin2KzYqSDYpdmE2Ykg2KfYs9mFINin2YTZhdiz2KrYrtiv2YUg2YjZg9mE2YXYqdin2YTZhdix2YjYsVwiLFxuXHRcdGNvbm5lY3Rpb25GYWlsZWQ6IFwi2KfYqti12KfZhCDZgdin2LTZhFwiLFxuXHRcdGNvbm5lY3Rpb25TdWNjZXNzZnVsOiBcItin2KrYtdin2YQg2YbYp9is2K1cIixcblx0XHRjb25uZWN0ZWQ6IFwi2YXYqti12YRcIixcblx0XHRjb25uZWN0aW5nVG86IFwi2KzYp9ix2Yog2KfZhNin2KrYtdin2YQg2KhcIixcblx0XHRjb25uZWN0aW5nTWVzc2FnZToge1xuXHRcdFx0aW5qZWN0ZWQ6IFwi2YjYp9mB2YIg2LnZhNmJINin2YTYp9iq2LXYp9mEINmB2Yog2YbYp9mB2LDYqSDYp9mE2KXYttin2YHYqVwiLFxuXHRcdFx0YnJvd3NlcjogXCLZiNin2YHZgiDYudmE2Ykg2KfZhNin2KrYtdin2YQg2YHZiiDYp9mE2YXYrdmB2LjYqSDYqNi52K8g2KXYudin2K/YqSDYqtmI2KzZitmHXCIsXG5cdFx0XHRoYXJkd2FyZTogXCLZiNin2YHZgiDYudmE2Ykg2KfZhNin2KrYtdin2YQg2YHZiiDYrNmH2KfYsiDZhNmK2K/YrNixXCIsXG5cdFx0XHRicmlkZ2U6IFwi2YjYp9mB2YIg2LnZhNmJINin2YTYp9iq2LXYp9mEINmB2Yog2KfZhNmF2K3Zgdi42KlcIlxuXHRcdH1cblx0fSxcblx0bGVkZ2VyOiB7XG5cdFx0Y29ubmVjdFdpdGhMZWRnZXI6IFwi2KfYqti12YQg2YXYuSDZhNmK2K/YrNixXCIsXG5cdFx0bWFrZVN1cmVZb3VyTGVkZ2VyOiBcItiq2KPZg9ivINij2YYg2YTZitiv2KzYsSDZhdiq2LXZhCDYqNij2YXYp9mGLCDZiCDYo9mGINiq2LfYqNmK2YIg2YbZitixINmF2YHYqtmI2K0g2YHZiiDYrNmH2KfYstmDXCIsXG5cdFx0XCJjb250aW51ZVwiOiBcItiq2KfYqNi5XCIsXG5cdFx0c3BlY2lmeUhEUGF0aDogXCLYrdiv2K8g2YXYs9in2LEg2KfZhNit2LPYp9ioXCIsXG5cdFx0ZW50ZXJZb3VyUHJlZmVycmVkSERQYXRoOiBcItij2K/YrtmEINmF2LPYp9ixINin2YTYrdiz2KfYqCDYp9mE2YXZgdi22YTYjCDYq9mFINin2KjYrdirINi52YYg2YPZhCDYp9mE2K3Ys9in2KjYp9iqINin2YTZhti02LfYqVwiLFxuXHRcdHNjYW46IFwi2YXYs9itXCIsXG5cdFx0cmV0cnk6IFwi2KPYudivINin2YTZhdit2KfZiNmE2KlcIixcblx0XHRsZWRnZXJJc05vdEF2YWlsYWJsZTogXCLZhNmK2K/YrNixINi62YrYsSDZhdiq2YjZgdixXCIsXG5cdFx0YWNjZXNzRGVuaWVkVG9Vc2VMZWRnZXJEZXZpY2U6IFwi2KrZhSDYsdmB2LYg2KfZhNin2KrYtdin2YQg2KjZhNmK2K/YrNixXCIsXG5cdFx0bm9BY2NvdW50c0ZvdW5kOiBcItmE2YUg2YrYqtmFINin2YTYudir2YjYsSDYudmE2Ykg2KPZiiDYrdiz2KfYqNin2KpcIixcblx0XHRzZWxlY3RZb3VyQWNjb3VudHM6IFwi2K3Yr9ivINit2LPYp9io2KfYqtmDXCIsXG5cdFx0Y29ubmVjdGluZzFBY2NvdW50OiBcItis2KfYsdmKINin2YTYp9iq2LXYp9mEINio2K3Ys9in2Kgg2YjYp9it2K9cIixcblx0XHRjYW50RmluZEFueUFjY291bnQ6IFwi2YTYpyDZitmF2YPZhiDYp9mE2LnYq9mI2LEg2LnZhNmJINij2Yog2K3Ys9in2Kgg2YXYsdiq2KjYtyDYqNmH2LDYpyDZhNmK2K/YrNixINin2YTYsdis2KfYoSDYpdmG2LTYp9ihINit2LPYp9ioINmG2YrYsSDYrNiv2YrYryDYudmE2YlcIixcblx0XHRvckNvbm5lY3RBbkFub3RoZXJMZWRnZXI6IFwi2KfZiCDYp9ix2KjYtyDYrNmH2KfYsiDZhNmK2K/YrNixINii2K7YsVwiLFxuXHRcdGNvbm5lY3Rpbmc6IFwi2KzYp9ix2Yog2KfZhNin2KrYtdin2YRcIixcblx0XHRvZkFjY291bnRzOiBcItmF2YYg2KfZhNit2LPYp9io2KfYqlwiLFxuXHRcdGZhaWxlZFRvQXV0b21hdGljYWxseTogXCLZgdi02YQg2YHZiiDYp9mE2KfYqti12KfZhCDYqNin2YTYrdiz2KfYqCDYqtmE2YLYp9im2YrYpy4g2YrYsdis2Ykg2KfZhNin2KrYtdin2YQg2KjYp9mE2K3Ys9in2Kgg2YrYr9mI2YrYp1wiLFxuXHRcdG92ZXJ2aWV3VGhlTGlzdE9mQXV0aG9yaXplZDogXCLZhNin2KbYrdipINin2YTYrdiz2KfYqNin2Kog2KfZhNmF2LXYsditINio2YfYpywg2KPZg9mF2YQg2KrYs9is2YrZhCDYp9mE2K/YrtmI2YQg2KjYp9mE2YbZgtixINi52YTZiSDYp9mE2LLYsSDYo9iv2YbYp9mHXCIsXG5cdFx0ZmluaXNoOiBcItil2YbZh9in2KFcIlxuXHR9LFxuXHRpbnN0YWxsOiB7XG5cdFx0eW91bGxOZWVkVG9JbnN0YWxsOiBcItiz2KrYrdiq2KfYrCDZhNiq2KvYqNmK2KpcIixcblx0XHR0b0NvbnRpbnVlQWZ0ZXJJbnN0YWxsaW5nOiBcItmE2YTYp9iz2KrZg9mF2KfZhC4g2KjYudivINin2YTYqtir2KjZitiqXCIsXG5cdFx0cmVmcmVzaFRoZVBhZ2U6IFwi2YLZhSDYqNiq2K3Yr9mK2Ksg2KfZhNi12YHYrdipXCIsXG5cdFx0b3BlbjogXCLYp9mB2KrYrVwiXG5cdH0sXG5cdHFyOiB7XG5cdFx0Y29waWVkVG9DbGlwYm9hcmQ6IFwi2KrZhSDYp9mE2YbYs9iuXCIsXG5cdFx0ZmFpbGVkVG9Db3B5OiBcItmB2LTZhCDYp9mE2YbYs9iuXCIsXG5cdFx0c2NhbldpdGhZb3VyTW9iaWxlOiBcItin2YXYs9itINio2KzZh9in2LLZgyDYp9mE2YXYrdmF2YjZhFwiLFxuXHRcdGNvcHlUb0NsaXBib2FyZDogXCLZhtiz2K5cIixcblx0XHRwcmVmZXJUaGVPZmZpY2lhbDogXCLYqtmB2LbZhCDYp9mE2K3ZiNin2LEg2KfZhNix2LPZhdmKINmEXCIsXG5cdFx0b3BlbjogXCLZgdiq2K1cIlxuXHR9LFxuXHR3YWxsZXRUeXBlczoge1xuXHRcdGhhcmR3YXJlOiBcIkhhcmR3YXJlIFdhbGxldFwiLFxuXHRcdGJyb3dzZXI6IFwiQnJvd3NlciBXYWxsZXRcIixcblx0XHRpbmplY3RlZDogXCJXYWxsZXQgRXh0ZW5zaW9uXCIsXG5cdFx0YnJpZGdlOiBcIkJyaWRnZSBXYWxsZXRcIixcblx0XHRtb2JpbGU6IFwiTW9iaWxlIFdhbGxldFwiLFxuXHRcdFwiaW5zdGFudC1saW5rXCI6IFwiSW5zdGFudCBXYWxsZXRcIlxuXHR9XG59O1xudmFyIGFyID0ge1xuXHRtb2RhbDogbW9kYWwkNFxufTtcblxudmFyIG1vZGFsJDMgPSB7XG5cdHdhbGxldDoge1xuXHRcdGNvbm5lY3RZb3VyV2FsbGV0OiBcIlNwb2ppdGUgY3J5cHRvIG5vdsSNYW5payFcIixcblx0XHR3aGF0SXNBV2FsbGV0OiBcIsWgdG8gamUgdG8gY3J5cHRvIG5vdsSNYW5paz9cIixcblx0XHRzZWN1cmVBbmRNYW5hZ2U6IFwiT3NpZ3VyYWp0ZSBpIHVwcmF2bGphanRlIHN2b2pvbSBkaWdpdGFsbm9tIGltb3Zpbm9tLlwiLFxuXHRcdHNhZmVseVN0b3JlOiBcIlNpZ3Vybm8gcG9ocmFuaXRlIGkgcHJlYmFjaXRlIHN2b2ogY3J5cHRvIGkgTkZULWV2ZS5cIixcblx0XHRsb2dJblRvQW55OiBcIiBQcmlqYXZpdGUgc2UgdSBiaWxvIGtvanUgTkVBUiBhcGxpa2FjaWp1XCIsXG5cdFx0bm9OZWVkVG9DcmVhdGU6IFwiTmVtYSBwb3RyZWJlIHphIHN0dmFyYW5qZW0gbm92aWggbmFsb2dhIGlsaSBrb3Jpc25pxI1raWggcG9kYXRha2EuIFNwb2ppdGUgc3ZvaiBjcnlwdG8gbm92xI1hbmlrIGkgc3ByZW1uaSBzdGUhXCIsXG5cdFx0Z2V0QVdhbGxldDogXCJPdHZvcml0ZSBjcnlwdG8gbm92xI1hbmlrXCIsXG5cdFx0dXNlQVdhbGxldDogXCJLb3Jpc3RpdGUgY3J5cHRvIG5vdsSNYW5payBkYSBiaXN0ZSBvc2lndXJhbGkgaSB1cHJhdmxqYWxpIHN2b2pvbSBORUFSIGltb3Zpbm9tLCB0ZSBzZSBwcmlqYXZpdGUgdSBiaWxvIGtvanUgTkVBUiBhcGxpa2FjaWp1IGJleiBrb3Jpc25pxI1rb2cgaW1lbmEgaSBsb3ppbmtlLlwiLFxuXHRcdGNvbm5lY3Rpb25GYWlsZWQ6IFwiTmV1c3BqZcWhbm8gcG92ZXppdmFuamUuXCIsXG5cdFx0Y29ubmVjdGlvblN1Y2Nlc3NmdWw6IFwiVXNwamXFoW5vIHBvdmV6aXZhbmplLlwiLFxuXHRcdGNvbm5lY3RlZDogXCJQb3ZlemFuby5cIixcblx0XHRjb25uZWN0aW5nVG86IFwiUG92ZXppdmFuamUgdSB0aWpla3VcIixcblx0XHRjb25uZWN0aW5nTWVzc2FnZToge1xuXHRcdFx0aW5qZWN0ZWQ6IFwiUG90dnJkaXRlIHZlenUgdSBla3N0ZXJub20gcHJvem9ydVwiLFxuXHRcdFx0YnJvd3NlcjogXCJOYWtvbiByZWRpcmVrY2lqZSwgcG90dnJkaXRlIHZlenUgdSBub3bEjWFuaWt1XCIsXG5cdFx0XHRoYXJkd2FyZTogXCJQb3R2cmRpdGUgdmV6dSBzYSBub3bEjWFuaWtvbVwiLFxuXHRcdFx0YnJpZGdlOiBcIlBvdHZyZGl0ZSB2ZXp1IHUgbm92xI1hbmlrdVwiXG5cdFx0fVxuXHR9LFxuXHRsZWRnZXI6IHtcblx0XHRjb25uZWN0V2l0aExlZGdlcjogXCJQb3Zlxb5pdGUgc2UgaGFyZHZlcnNraW0gbm92xI1hbmlrb21cIixcblx0XHRtYWtlU3VyZVlvdXJMZWRnZXI6IFwiT3NpZ3VyYWp0ZSBzaWd1cm51IHZlenUgcyBoYXJkdmVyc2tpbSBub3bEjWFuaWtvbSwgdGUgZGEgamUgTkVBUiBhcGxpa2FjaWphIG90dm9yZW5hIG5hIHZhxaFlbSB1cmXEkWFqdVwiLFxuXHRcdFwiY29udGludWVcIjogXCJOYXN0YXZpdGVcIixcblx0XHRzcGVjaWZ5SERQYXRoOiBcIlNwZWNpZmljaXJhanRlIEhEIHB1dGFuanVcIixcblx0XHRlbnRlcllvdXJQcmVmZXJyZWRIRFBhdGg6IFwiVXBpxaFpdGUgcHJlZmVyaXJhbnUgSEQgcHV0YW5qdSwgemF0aW0gc2tlbmlyYWp0ZSBha3Rpdm5lIG5hbG9nZVwiLFxuXHRcdHNjYW46IFwiU2tlbmlyYWp0ZVwiLFxuXHRcdHJldHJ5OiBcIlBva3XFoWFqdGUgcG9ub3Zub1wiLFxuXHRcdGxlZGdlcklzTm90QXZhaWxhYmxlOiBcIkhhcmR2ZXJza2kgbm92xI1hbmlrIG5pamUgZG9zdHVwYW4uXCIsXG5cdFx0YWNjZXNzRGVuaWVkVG9Vc2VMZWRnZXJEZXZpY2U6IFwiT2RiaWplbiBwcmlzdHVwIHphIGtvcmnFoXRlbmplbSBoYXJkdmVyc2tvZyBub3bEjWFuaWthXCIsXG5cdFx0bm9BY2NvdW50c0ZvdW5kOiBcIk5hbG96aSBuaXN1IHByb25hxJFlbmlcIixcblx0XHRzZWxlY3RZb3VyQWNjb3VudHM6IFwiT2RhYmVyaXRlIHN2b2plIG5hbG9nZVwiLFxuXHRcdGNvbm5lY3RpbmcxQWNjb3VudDogXCJQb3Zleml2YW5qZSAxIG5hbG9nYVwiLFxuXHRcdGNhbnRGaW5kQW55QWNjb3VudDogXCJOaWplIG1vZ3XEh2UgcHJvbmHEh2kgbml0aSBqZWRhbiBuYWxvZyBwb3ZlemFuIHMgb3ZpbSBoYXJkdmVyc2tpbSBub3bEjWFuaWtvbS4gTW9saW1vIHZhcywga3JlaXJhanRlIG5vdmkgTkVBUiBuYWxvZ1wiLFxuXHRcdG9yQ29ubmVjdEFuQW5vdGhlckxlZGdlcjogXCJJbGkgcG92ZcW+aXRlIGRydWdpIGhhcmR2ZXJza2kgbm92xI1hbmlrLlwiLFxuXHRcdGNvbm5lY3Rpbmc6IFwiUG92ZXppdmFuamVcIixcblx0XHRvZkFjY291bnRzOiBcIm5hbG9nYVwiLFxuXHRcdGZhaWxlZFRvQXV0b21hdGljYWxseTogXCJOZXVzcGplxaFubyBhdXRvbWF0c2tvIHByb25hbGHFvmVuamUgSUQgbmFsb2dhLiBVbmVzaXRlIHJ1xI1ubzpcIixcblx0XHRvdmVydmlld1RoZUxpc3RPZkF1dGhvcml6ZWQ6IFwiUHJlZ2xlZGFqdGUgcG9waXMgb2RvYnJlbmloIG5hbG9nYSwgemF2csWhaXRlIHByaWphdnUgcHJpdGlza29tIG5hIG5pxb5lIHByaWthemFuaSBndW1iLlwiLFxuXHRcdGZpbmlzaDogXCJaYXZyxaFpdGVcIlxuXHR9LFxuXHRpbnN0YWxsOiB7XG5cdFx0eW91bGxOZWVkVG9JbnN0YWxsOiBcIiBQb3RyZWJubyBqZSBpbnN0YWxpcmF0aSBtb2RhbFwiLFxuXHRcdHRvQ29udGludWVBZnRlckluc3RhbGxpbmc6IFwiemEgbmFzdGF2YWsuIE5ha29uIGluc3RhbGFjaWplXCIsXG5cdFx0cmVmcmVzaFRoZVBhZ2U6IFwib3N2amXFvml0ZSBzdHJhbmljdS5cIixcblx0XHRvcGVuOiBcIk90dm9yaXRlIFFSIG1vZGFsXCJcblx0fSxcblx0cXI6IHtcblx0XHRjb3BpZWRUb0NsaXBib2FyZDogXCJLb3BpcmFubyB1IG1lxJF1c3ByZW1uaWtcIixcblx0XHRmYWlsZWRUb0NvcHk6IFwiTmV1cHNqZcWhbm8ga29waXJhbmplIHUgbWXEkXVzcHJlbW5pa1wiLFxuXHRcdHNjYW5XaXRoWW91ck1vYmlsZTogXCJTa2VuaXJhanRlIHN2b2ppbSBtb2JpbG5pbSB1cmXEkWFqZW1cIixcblx0XHRjb3B5VG9DbGlwYm9hcmQ6IFwiIEtvcGlyYWp0ZSB1IG1lxJF1c3ByZW1uaWtcIixcblx0XHRwcmVmZXJUaGVPZmZpY2lhbDogXCJPZGFiZXJpdGUgc2x1xb5iZW5pIGRpamFsb2dcIixcblx0XHRvcGVuOiBcIk90dm9yaXRlXCJcblx0fSxcblx0d2FsbGV0VHlwZXM6IHtcblx0XHRoYXJkd2FyZTogXCJIYXJkd2FyZSBXYWxsZXRcIixcblx0XHRicm93c2VyOiBcIkJyb3dzZXIgV2FsbGV0XCIsXG5cdFx0aW5qZWN0ZWQ6IFwiV2FsbGV0IEV4dGVuc2lvblwiLFxuXHRcdGJyaWRnZTogXCJCcmlkZ2UgV2FsbGV0XCIsXG5cdFx0bW9iaWxlOiBcIk1vYmlsZSBXYWxsZXRcIixcblx0XHRcImluc3RhbnQtbGlua1wiOiBcIkluc3RhbnQgV2FsbGV0XCJcblx0fSxcblx0ZXhwb3J0QWNjb3VudHM6IHtcblx0XHRjaG9vc2VBV2FsbGV0OiBcIk9kYWJlcmkgV2FsbGV0XCIsXG5cdFx0dHJhbnNmZXJZb3VyQWNjb3VudHM6IFwiUHJlbmVzaSBzdm9qZSBuYWxvZ2VcIixcblx0XHRzZWxlY3RBV2FsbGV0OiBcIk9kYWJlcml0ZSB3YWxsZXQga29qaSBvZGdvdmFyYSB2YcWhaW0gcG90cmViYW1hIGkgcG9kcsW+YXZhIHZhxaFlIHBvdmV6YW5lIG5hbG9nZS5cIixcblx0XHRzZWxlY3RZb3VyQWNjb3VudHM6IFwiT2RhYmVyaSBzdm9qZSBuYWxvZ2VcIixcblx0XHRhZnRlckRlY2lkZTogXCJOYWtvbiDFoXRvIG9kbHXEjWl0ZSBrb2ppIHdhbGxldCBrb3Jpc3RpdGUsIG1vxb5ldGUgb2RhYnJhdGkga29qZSByYcSNdW5lIMW+ZWxpdGUgcHJlYmFjaXRpLlwiLFxuXHRcdGRpc2NsYWltZXI6IFwiTmXEh2V0ZSBtb8SHaSBwcmViYWNpdGkgbmFsb2dlIGtvamkgbmlzdSBuaWthZGEgYmlsaSBrb3JpxaF0ZW5pIG5hIE5FQVItdS5cIixcblx0XHR3YXJuaW5nOiBcIm5lIHBvZHLFvmF2YSBpenZveiBuYWxvZ2EgdSBvdm9tIHRyZW51dGt1LiBNb2xpbW8gb2RhYmVyaXRlIGRydWdpIHdhbGxldC5cIixcblx0XHR3YWxsZXRUeXBlczoge1xuXHRcdFx0aGFyZHdhcmU6IFwiSGFyZHdhcmUgV2FsbGV0XCIsXG5cdFx0XHRicm93c2VyOiBcIkJyb3dzZXIgV2FsbGV0XCIsXG5cdFx0XHRpbmplY3RlZDogXCJXYWxsZXQgRXh0ZW5zaW9uXCIsXG5cdFx0XHRicmlkZ2U6IFwiQnJpZGdlIFdhbGxldFwiLFxuXHRcdFx0bW9iaWxlOiBcIk1vYmlsZSBXYWxsZXRcIlxuXHRcdH0sXG5cdFx0c2VsZWN0QWNjb3VudHM6IHtcblx0XHRcdHRpdGxlOiBcIk9kYWJlcmkgbmFsb2dlIHphIHByaWplbm9zXCIsXG5cdFx0XHRidXR0b246IFwiR2VuZXJpcmFqIGxvemlua3VcIixcblx0XHRcdGRlc2VsZWN0QWxsOiBcIk1ha25pIG9kYWJpciBzYSBzdmloXCIsXG5cdFx0XHRzZWxlY3RBbGw6IFwiT2RhYmVyaSBzdmVcIixcblx0XHRcdHVuYXZhaWxhYmxlOiBcIlByaWplbm9zIG5pamUgZG9zdHVwYW5cIixcblx0XHRcdGVycm9yOiBcIk5hbG9nIG5lIHBvc3RvamlcIixcblx0XHRcdHdhcm5pbmdMZWRnZXI6IFwiUG90cmVibmEgbGVkZ2VyIHBvZHLFoWthXCIsXG5cdFx0XHRub0JhbGFuY2U6IFwiTmFsb2cgbmVtYSBzcmVkc3RhdmFcIlxuXHRcdH0sXG5cdFx0Z2V0UGFzc3BocmFzZToge1xuXHRcdFx0dGl0bGU6IFwiS29waXJhaiBwcml2cmVtZW51IGxvemlua3VcIixcblx0XHRcdGRlc2M6IFwiQml0IMSHZSBwb3RyZWJubyB1bmlqZXRpIG92dSBsb3ppbmt1IG5hIHBvxI1ldGt1IGl6dm96YSBuYWxvZ2EgbmEgZHJ1Z2kgd2FsbGV0LlwiLFxuXHRcdFx0YnV0dG9uOiBcIk5hc3RhdmlcIixcblx0XHRcdGxhYmVsOiBcIktsaWtuaSB6YSBrb3BpanVcIixcblx0XHRcdGNoZWNrTGFiZWw6IFwiS29waXJhbyBzYW0gaWxpIHphcGlzYW8gbG96aW5rdVwiXG5cdFx0fSxcblx0XHRjb21wbGV0ZToge1xuXHRcdFx0dGl0bGU6IFwiWmF2csWhaSBwcmlqZW5vc1wiLFxuXHRcdFx0ZGVzY09uZTogXCJZb3Ugd2lsbCBub3cgYmUgcmVkaXJlY3RlZCB0byB0aGUgd2FsbGV0IHlvdSBzZWxlY3RlZCB0byBjb21wbGV0ZSB0aGUgdHJhbnNmZXIuXCIsXG5cdFx0XHRkZXNjVHdvOiBcIkthZGEgamUgdW5vcyBzIG9kYWJyYW5vZyB3YWxsZXRhIHphdnLFoWVuLCBwcml0aXNuaXRlIGd1bWIgZGEgYmlzdGUgemF2csWhaWxpIHByaWplbm9zLlwiLFxuXHRcdFx0YnV0dG9uOiBcIlphdnLFoWlcIlxuXHRcdH1cblx0fVxufTtcbnZhciBociA9IHtcblx0bW9kYWw6IG1vZGFsJDNcbn07XG5cbnZhciBtb2RhbCQyID0ge1xuXHR3YWxsZXQ6IHtcblx0XHRjb25uZWN0WW91cldhbGxldDogXCLQn9C+0LLRgNC30LXRgtC1INCz0L4g0LLQsNGI0LjQvtGCINC90L7QstGH0LDQvdC40LohXCIsXG5cdFx0d2hhdElzQVdhbGxldDogXCLQqNGC0L4g0LUg0L3QvtCy0YfQsNC90LjQuj9cIixcblx0XHRzZWN1cmVBbmRNYW5hZ2U6IFwi0JfQsNGI0YLQuNGC0LXRgtC1INCz0Lgg0Lgg0YPQv9GA0LDQstGD0LLQsNGY0YLQtSDRgdC+INCy0LDRiNC40YLQtSDQtNC40LPQuNGC0LDQu9C90Lgg0YHRgNC10LTRgdGC0LLQsC5cIixcblx0XHRzYWZlbHlTdG9yZTogXCLQkdC10LfQsdC10LTQvdC+INGB0LrQu9Cw0LTQuNGA0LDRmNGC0LUg0Lgg0LjQt9Cy0YDRiNGD0LLQsNGY0YLQtSDRgtGA0LDQvdGB0LDQutGG0LjQuCDRgdC+INCy0LDRiNC40YLQtSDQutGA0LjQv9GC0L4g0LggTkZULlwiLFxuXHRcdGxvZ0luVG9Bbnk6IFwi0J3QsNGY0LDQstC10YLQtSDRgdC1INC90LAg0LrQvtGY0LAg0LHQuNC70L4gTkVBUiDQsNC/0LvQuNC60LDRhtC40ZjQsFwiLFxuXHRcdG5vTmVlZFRvQ3JlYXRlOiBcItCd0LXQvNCwINC/0L7RgtGA0LXQsdCwINC00LAg0LrRgNC10LjRgNCw0YLQtSDQvdC+0LLQuCDRgdC80LXRgtC60Lgg0LjQu9C4INC40L3Qs9C10YDQtdC90YbQuNC4LiDQn9C+0LLRgNC30LXRgtC1INCz0L4g0LLQsNGI0LjQvtGCINC/0LDRgNC40YfQvdC40Log0Lgg0YHRgtC1INC/0L7QtNCz0L7RgtCy0LXQvdC4IVwiLFxuXHRcdGdldEFXYWxsZXQ6IFwi0J3QsNC/0YDQsNCy0LXRgtC1INC90L7QstGH0LDQvdC40LpcIixcblx0XHR1c2VBV2FsbGV0OiBcItCa0L7RgNC40YHRgtC10YLQtSDQv9Cw0YDQuNGH0L3QuNC6INC30LAg0LTQsCDQs9C4INC30LDRiNGC0LjRgtC40YLQtSDQuCDRg9C/0YDQsNCy0YPQstCw0YLQtSDQstCw0YjQuNGC0LUgTkVBUiDRgdGA0LXQtNGB0YLQstCwINC4INC00LAg0YHQtSDQvdCw0ZjQsNCy0LjRgtC1INC90LAg0LrQvtGY0LAg0LHQuNC70L4gTkVBUiDQsNC/0LvQuNC60LDRhtC40ZjQsCDQsdC10Lcg0L/QvtGC0YDQtdCx0LAg0L7QtCDQutC+0YDQuNGB0L3QuNGH0LrQuCDQuNC80LjRmtCwINC4INC70L7Qt9C40L3QutC4LlwiLFxuXHRcdGNvbm5lY3Rpb25GYWlsZWQ6IFwi0J/QvtCy0YDQt9GD0LLQsNGa0LXRgtC+INC90LUg0LHQtdGI0LUg0YPRgdC/0LXRiNC90L4uXCIsXG5cdFx0Y29ubmVjdGlvblN1Y2Nlc3NmdWw6IFwi0KPRgdC/0LXRiNC90L4g0L/QvtCy0YDQt9GD0LLQsNGa0LUuXCIsXG5cdFx0Y29ubmVjdGVkOiBcItCf0L7QstGA0LfQsNC90L4uXCIsXG5cdFx0Y29ubmVjdGluZ1RvOiBcItCf0L7QstGA0LfRg9Cy0LDRmtC1INGB0L5cIixcblx0XHRjb25uZWN0aW5nTWVzc2FnZToge1xuXHRcdFx0aW5qZWN0ZWQ6IFwi0J/QvtGC0LLRgNC00LXRgtC1INCz0L4g0L/QvtCy0YDQt9GD0LLQsNGa0LXRgtC+INCy0L4g0LXQutGB0YLQtdGA0L3QuNC+0YIg0L/RgNC+0LfQvtGA0LXRhlwiLFxuXHRcdFx0YnJvd3NlcjogXCLQn9C+INC/0YDQtdGD0YHQvNC10YDRg9Cy0LDRmtC10YLQviwg0L/QvtGC0LLRgNC00LXRgtC1INCz0L4g0L/QvtCy0YDQt9GD0LLQsNGa0LXRgtC+INC+0LQg0L3QvtCy0YfQsNC90LjQvtC60YJcIixcblx0XHRcdGhhcmR3YXJlOiBcItCf0L7RgtCy0YDQtNC10YLQtSDQs9C+INC/0L7QstGA0LfRg9Cy0LDRmtC10YLQviDRgdC+INC70LDQtNC10L0g0L3QvtCy0YfQsNC90LjQulwiLFxuXHRcdFx0YnJpZGdlOiBcItCf0L7RgtCy0YDQtNC10YLQtSDRmNCwINCy0YDRgdC60LDRgtCwINCy0L4g0L3QvtCy0YfQsNC90LjQutC+0YJcIlxuXHRcdH1cblx0fSxcblx0bGVkZ2VyOiB7XG5cdFx0Y29ubmVjdFdpdGhMZWRnZXI6IFwi0J/QvtCy0YDQt9C10YLQtSDRgdC1INGB0L4g0JvQtdGf0LXRgFwiLFxuXHRcdG1ha2VTdXJlWW91ckxlZGdlcjogXCLQntGB0LjQs9GD0YDQsNGY0YLQtSDRgdC1INC00LXQutCwINCy0LDRiNC40L7RgiDQm9C10Z/QtdGAINC1INC/0L7QstGA0LfQsNC9INCx0LXQt9Cx0LXQtNC90L4sINC4INC00LXQutCwIE5FQVIg0LDQv9C70LjQutCw0YbQuNGY0LDRgtCwINC1INC+0YLQstC+0YDQtdC90LAg0L3QsCDQstCw0YjQuNC+0YIg0YPRgNC10LRcIixcblx0XHRcImNvbnRpbnVlXCI6IFwi0J/RgNC+0LTQvtC70LbQtdGC0LVcIixcblx0XHRzcGVjaWZ5SERQYXRoOiBcItCd0LDQstC10LTQtdGC0LUg0KXQlCDQu9C+0LrQsNGG0LjRmNCwXCIsXG5cdFx0ZW50ZXJZb3VyUHJlZmVycmVkSERQYXRoOiBcItCS0L3QtdGB0LXRgtC1INGY0LAg0LLQsNGI0LDRgtCwINC/0YDQtdGE0LXRgNC40YDQsNC90LAg0KXQlCDQu9C+0LrQsNGG0LjRmNCwLCDQsCDQv9C+0YLQvtCwINGB0LrQtdC90LjRgNCw0ZjRgtC1INC00LAg0LPQuCDQvdCw0ZjQtNC10YLQtSDQsNC60YLQuNCy0L3QuNGC0LUg0YHQvNC10YLQutC4LlwiLFxuXHRcdHNjYW46IFwi0KHQutC10L3QuNGA0LDRmNGC0LVcIixcblx0XHRyZXRyeTogXCLQntCx0LjQtNC10YLQtSDRgdC1INC/0L7QstGC0L7RgNC90L5cIixcblx0XHRsZWRnZXJJc05vdEF2YWlsYWJsZTogXCLQm9C10Z/QtdGA0L7RgiDQvdC1INC1INC00L7RgdGC0LDQv9C10L0uXCIsXG5cdFx0YWNjZXNzRGVuaWVkVG9Vc2VMZWRnZXJEZXZpY2U6IFwi0J/RgNC40YHRgtCw0L/QvtGCINC30LAg0LrQvtGA0LjRgdGC0LXRmtC1INC90LAg0JvQtdGf0LXRgCDRg9GA0LXQtCDQtSDQvtC00LHQuNC10L1cIixcblx0XHRub0FjY291bnRzRm91bmQ6IFwi0J3QtdC80LAg0L3QsNGY0LTQtdC90Lgg0YHQvNC10YLQutC4XCIsXG5cdFx0c2VsZWN0WW91ckFjY291bnRzOiBcItCY0LfQsdC10YDQtdGC0LUg0LPQuCDQstCw0YjQuNGC0LUg0YHQvNC10YLQutC4XCIsXG5cdFx0Y29ubmVjdGluZzFBY2NvdW50OiBcItCf0L7QstGA0LfRg9Cy0LDRmtC1INC90LAg0LXQtNC90LAg0YHQvNC10YLQutCwXCIsXG5cdFx0Y2FudEZpbmRBbnlBY2NvdW50OiBcItCd0LUg0YHQtSDQvdCw0ZjQtNC10L3QuCDRgdC80LXRgtC60Lgg0L/QvtCy0YDQt9Cw0L3QuCDRgdC+INC+0LLQvtGYINCb0LXRn9C10YAuINCS0LUg0LzQvtC70LjQvNC1INC60YDQtdC40YDQsNGY0YLQtSDQvdC+0LLQsCBORUFSINGB0LzQtdGC0LrQsCBcIixcblx0XHRvckNvbm5lY3RBbkFub3RoZXJMZWRnZXI6IFwi0LjQu9C4INC/0L7QstGA0LfQtdGC0LUg0LTRgNGD0LMg0JvQtdGf0LXRgC5cIixcblx0XHRjb25uZWN0aW5nOiBcItCf0L7QstGA0LfRg9Cy0LDRmtC1XCIsXG5cdFx0b2ZBY2NvdW50czogXCLQvdCwINGB0LzQtdGC0LrQuFwiLFxuXHRcdGZhaWxlZFRvQXV0b21hdGljYWxseTogXCLQndC10YPRgdC/0LXRiNC90L4g0LDQstGC0L7QvNCw0YLRgdC60L4g0LHQsNGA0LDRmtC1INC90LAg0JjQlCDQvdCwINGB0LzQtdGC0LrQsNGC0LAuINCS0L3QtdGB0LXRgtC1INCz0L4g0YDQsNGH0L3QvjpcIixcblx0XHRvdmVydmlld1RoZUxpc3RPZkF1dGhvcml6ZWQ6IFwi0J/RgNC10LPQu9C10LQg0L3QsCDQu9C40YHRgtCw0YLQsCDQvdCwINC+0LLQu9Cw0YHRgtC10L3QuCDRgdC80LXRgtC60LgsINC30LDQstGA0YjQtdGC0LUg0YHQtSDQvdCw0ZjQsNCy0LDRgtCwINGB0L4g0LrQu9C40LrQvdGD0LLQsNGa0LUg0L3QsCDQutC+0L/Rh9C10YLQviDQv9C+0LTQvtC70YMuXCIsXG5cdFx0ZmluaXNoOiBcItCX0LDQstGA0YjQtdGC0LVcIlxuXHR9LFxuXHRpbnN0YWxsOiB7XG5cdFx0eW91bGxOZWVkVG9JbnN0YWxsOiBcItCi0YDQtdCx0LAg0LTQsCDQuNC90YHRgtCw0LvQuNGA0LDRgtC1XCIsXG5cdFx0dG9Db250aW51ZUFmdGVySW5zdGFsbGluZzogXCLQt9CwINC00LAg0L/RgNC+0LTQvtC70LbQuNGC0LUuINCf0L4g0LjQvdGB0YLQsNC70LjRgNCw0ZrQtdGC0L5cIixcblx0XHRyZWZyZXNoVGhlUGFnZTogXCLQntGB0LLQtdC20LXRgtC1INGY0LAg0YHRgtGA0LDQvdCw0YLQsC5cIixcblx0XHRvcGVuOiBcItCe0YLQstC+0YDQtdGC0LVcIlxuXHR9LFxuXHRxcjoge1xuXHRcdGNvcGllZFRvQ2xpcGJvYXJkOiBcItCa0L7Qv9C40YDQsNC90L4g0L3QsCDQutC70LjQv9Cx0L7RgNC00L7RglwiLFxuXHRcdGZhaWxlZFRvQ29weTogXCLQndC10YPRgdC/0LXRiNC90L4g0LrQvtC/0LjRgNCw0ZrQtSDQvdCwINC60LvQuNC/0LHQvtGA0LRcIixcblx0XHRzY2FuV2l0aFlvdXJNb2JpbGU6IFwi0KHQutC10L3QuNGA0LDRmNGC0LUg0YHQviDQstCw0YjQuNC+0YIg0YLQtdC70LXRhNC+0L3RgdC60Lgg0YPRgNC10LRcIixcblx0XHRjb3B5VG9DbGlwYm9hcmQ6IFwi0JrQvtC/0LjRgNCw0ZjRgtC1INC90LAg0LrQu9C40L/QsdC+0YDQtFwiLFxuXHRcdHByZWZlclRoZU9mZmljaWFsOiBcItCf0YDQtdGE0LXRgNC40YDQsNGY0YLQtSDQvtGE0LjRhtC40ZjQsNC70LXQvSDQtNC40LDQu9C+0LMg0L3QsFwiLFxuXHRcdG9wZW46IFwi0J7RgtCy0L7RgNC10YLQtVwiXG5cdH0sXG5cdHdhbGxldFR5cGVzOiB7XG5cdFx0aGFyZHdhcmU6IFwi0KXQsNGA0LTQstC10YDRgdC60Lgg0L3QvtCy0YfQsNC90LjQulwiLFxuXHRcdGJyb3dzZXI6IFwi0J3QvtCy0YfQsNC90LjQuiDQvdCwINC40L3RgtC10YDQvdC10YIg0L/RgNC10LvQuNGB0YLRg9Cy0LDRh1wiLFxuXHRcdGluamVjdGVkOiBcItCV0LrRgdGC0LXQvdC30LjRmNCwINC30LAg0L3QvtCy0YfQsNC90LjQulwiLFxuXHRcdGJyaWRnZTogXCJCcmlkZ2Ug0L3QvtCy0YfQsNC90LjQulwiLFxuXHRcdG1vYmlsZTogXCLQnNC+0LHQuNC70LXQvSDQvdC+0LLRh9Cw0L3QuNC6XCIsXG5cdFx0XCJpbnN0YW50LWxpbmtcIjogXCLQmNC90YHRgtCw0L3RgiDQv9Cw0YDQuNGH0L3QuNC6XCJcblx0fSxcblx0ZXhwb3J0QWNjb3VudHM6IHtcblx0XHRjaG9vc2VBV2FsbGV0OiBcItCe0LTQsdC10YDQtdGC0LUg0L/QsNGA0LjRh9C90LjQulwiLFxuXHRcdHRyYW5zZmVyWW91ckFjY291bnRzOiBcItCf0YDQtdGE0YDQu9C10YLQtSDQs9C4INCy0LDRiNC40YLQtSDQutC+0YDQuNGB0L3QuNGH0LrQuCDRgdC80LXRgtC60LhcIixcblx0XHRzZWxlY3RBV2FsbGV0OiBcItCY0LfQsdC10YDQtdGC0LXQvSDQvdC+0LLRh9Cw0L3QuNC6INC60L7RmCDQs9C4INC30LDQtNC+0LLQvtC70YPQstCwINCy0LDRiNC40YLQtSDQsdCw0YDQsNC90ZrQsCDQuCDQs9C4INC/0L7QtNC00YDQttGD0LLQsCDQstCw0YjQuNGC0LUg0L/QvtCy0YDQt9Cw0L3QuCDQutC+0YDQuNGB0L3QuNGH0LrQuCDRgdC80LXRgtC60LguXCIsXG5cdFx0c2VsZWN0WW91ckFjY291bnRzOiBcItCY0LfQsdC10YDQtdGC0LUg0LPQuCDQstCw0YjQuNGC0LUg0LrQvtGA0LjRgdC90LjRh9C60Lgg0YHQvNC10YLQutC4XCIsXG5cdFx0YWZ0ZXJEZWNpZGU6IFwi0J7QtNC60LDQutC+INGc0LUg0LjQt9Cx0LXRgNC10YLQtSDQvdC+0LLRh9Cw0L3QuNC6LCDQvNC+0LbQtdGC0LUg0LTQsCDQuNC30LHQtdGA0LXRgtC1INC60L7QuCDQutC+0YDQuNGB0L3QuNGH0LrQuCDRgdC80LXRgtC60Lgg0YHQsNC60LDRgtC1INC00LAg0LPQuCDQv9GA0LXRhNGA0LvQuNGC0LUuXCIsXG5cdFx0ZGlzY2xhaW1lcjogXCLQndC1INC80L7QttC10YLQtSDQtNCwINC/0YDRhNGA0LvQsNGC0LUg0LrQvtGA0LjRgdC90LjRh9C60Lgg0YHQvNC10YLQutC4INC60L7QuCDQvdC40LrQvtCz0LDRiCDQvdC1INCx0LjQu9C1INC90LDQtNC+0L/QvtC70L3QsNGC0Lgg0LjQu9C4INC60L7RgNC40YHRgtC10L3QuCDQvdCwIE5FQVIuXCIsXG5cdFx0d2FybmluZzogXCLQvdC1INC/0L7QtNC00YDQttGD0LLQsCDQuNC30LLQtdC30YPQstCw0ZrQtSDQvdCwINC60L7RgNC40YHQvdC40YfQutC4INGB0LzQtdGC0LrQuCDQstC+INC+0LLQvtGYINC80L7QvNC10L3Rgi4g0JLQtSDQvNC+0LvQuNC80LUg0LjQt9Cx0LXRgNC10YLQtSDQtNGA0YPQsyDQvdC+0LLRh9Cw0L3QuNC6LlwiLFxuXHRcdHdhbGxldFR5cGVzOiB7XG5cdFx0XHRoYXJkd2FyZTogXCLQpdCw0YDQtNCy0LXRgNGB0LrQuCDQvdC+0LLRh9Cw0L3QuNC6XCIsXG5cdFx0XHRicm93c2VyOiBcItCd0L7QstGH0LDQvdC40Log0L3QsCDQuNC90YLQtdGA0L3QtdGCINC/0YDQtdC70LjRgdGC0YPQstCw0YdcIixcblx0XHRcdGluamVjdGVkOiBcItCV0LrRgdGC0LXQvdC30LjRmNCwINC30LAg0L3QvtCy0YfQsNC90LjQulwiLFxuXHRcdFx0YnJpZGdlOiBcIkJyaWRnZSDQvdC+0LLRh9Cw0L3QuNC6XCIsXG5cdFx0XHRtb2JpbGU6IFwi0JzQvtCx0LjQu9C10L0g0L3QvtCy0YfQsNC90LjQulwiXG5cdFx0fSxcblx0XHRzZWxlY3RBY2NvdW50czoge1xuXHRcdFx0dGl0bGU6IFwi0JjQt9Cx0LXRgNC10YLQtSDQs9C4INC60L7RgNC40YHQvdC40YfQutC40YLQtSDRgdC80LXRgtC60Lgg0LfQsCDQtNCwINCz0Lgg0L/RgNC10YTRgNC70LjRgtC1LlwiLFxuXHRcdFx0YnV0dG9uOiBcItCU0L7QsdC40ZjRgtC1INC70L7Qt9C40L3QutCwXCIsXG5cdFx0XHRkZXNlbGVjdEFsbDogXCLQntGC0YHQtdC70LXQutGC0LjRgNCw0ZjRgtC1INGB0LVcIixcblx0XHRcdHNlbGVjdEFsbDogXCLQmNC30LHQtdGA0LXRgtC1INGB0LVcIixcblx0XHRcdHVuYXZhaWxhYmxlOiBcItCi0YDQsNC90YHRhNC10YDQvtGCINC1INC90LXQtNC+0YHRgtCw0L/QtdC9XCIsXG5cdFx0XHRlcnJvcjogXCLQmtC+0YDQuNGB0L3QuNGH0LrQsNGC0LAg0YHQvNC10YLQutCwINC90LUg0L/QvtGB0YLQvtC4XCIsXG5cdFx0XHR3YXJuaW5nTGVkZ2VyOiBcItCf0L7RgtGA0LXQsdC90LAg0LUg0L/QvtC00LTRgNGI0LrQsCDQvtC0INCb0LXRn9C10YBcIixcblx0XHRcdG5vQmFsYW5jZTogXCLQodC80LXRgtC60LDRgtCwINC90LUg0LUg0YTQuNC90LDQvdGB0LjRgNCw0L3QsFwiXG5cdFx0fSxcblx0XHRnZXRQYXNzcGhyYXNlOiB7XG5cdFx0XHR0aXRsZTogXCLQmtC+0L/QuNGA0LDRmNGC0LUg0ZjQsCDQv9GA0LjQstGA0LXQvNC10L3QsNGC0LAg0LvQvtC30LjQvdC60LBcIixcblx0XHRcdGRlc2M6IFwi0IzQtSDRgtGA0LXQsdCwINC00LAg0ZjQsCDQstC90LXRgdC10YLQtSDQvtCy0LDQsCDQu9C+0LfQuNC90LrQsCDQutC+0LPQsCDRnNC1INC30LDQv9C+0YfQvdC10YLQtSDQtNCwINCz0Lgg0LjQt9Cy0LXQt9GD0LLQsNGC0LUg0LLQsNGI0LjRgtC1INGB0LzQtdGC0LrQuCDQvdCwINC00YDRg9CzINC90L7QstGH0LDQvdC40LouXCIsXG5cdFx0XHRidXR0b246IFwi0J/RgNC+0LTQvtC70LbQtdGC0LVcIixcblx0XHRcdGxhYmVsOiBcItCa0LvQuNC60L3QtdGC0LUg0LfQsCDQtNCwINC60L7Qv9C40YDQsNGC0LVcIixcblx0XHRcdGNoZWNrTGFiZWw6IFwi0IjQsCDQutC+0L/QuNGA0LDQsiDQuNC70Lgg0LfQsNC/0LjRiNCw0LIg0LvQvtC30LjQvdC60LDRgtCwXCJcblx0XHR9LFxuXHRcdGNvbXBsZXRlOiB7XG5cdFx0XHR0aXRsZTogXCLQl9Cw0LLRgNGI0LXRgtC1INCz0L4g0L/RgNC10L3QvtGB0L7RglwiLFxuXHRcdFx0ZGVzY09uZTogXCLQodC10LPQsCDRnNC1INCx0LjQtNC10YLQtSDQv9GA0LXQvdCw0YHQvtGH0LXQvdC4INC90LAg0LjQt9Cx0YDQsNC90LjQvtGCINC90L7QstGH0LDQvdC40Log0LfQsCDQt9Cw0LLRgNGI0YPQstCw0ZrQtSDQvdCwINC/0YDQtdC90L7RgdC+0YIuXCIsXG5cdFx0XHRkZXNjVHdvOiBcItCe0YLQutCw0LrQviDRnNC1INC30LDQstGA0YjQuCDRg9Cy0L7Qt9C+0YIg0L7QtCDQuNC30LHRgNCw0L3QuNC+0YIg0L3QvtCy0YfQsNC90LjQuiwg0L/RgNC40YLQuNGB0L3QtdGC0LUg0LPQviDQutC+0L/Rh9C10YLQviDQt9CwINC00LAg0LPQviDQt9Cw0LLRgNGI0LjRgtC1INC/0YDQtdC90L7RgdC+0YIuXCIsXG5cdFx0XHRidXR0b246IFwi0JfQsNCy0YDRiNC10YLQtVwiXG5cdFx0fVxuXHR9XG59O1xudmFyIG1rID0ge1xuXHRtb2RhbDogbW9kYWwkMlxufTtcblxudmFyIG1vZGFsJDEgPSB7XG5cdHdhbGxldDoge1xuXHRcdGNvbm5lY3RZb3VyV2FsbGV0OiBcIlBvdmXFvml0ZSBzdm9qbyBkZW5hcm5pY28hXCIsXG5cdFx0d2hhdElzQVdhbGxldDogXCJLYWogamUgZGVuYXJuaWNhP1wiLFxuXHRcdHNlY3VyZUFuZE1hbmFnZTogXCJaYXZhcnVqdGUgaW4gdXByYXZsamFqdGUgc3ZvamEgZGlnaXRhbG5hIHNyZWRzdHZhLlwiLFxuXHRcdHNhZmVseVN0b3JlOiBcIlZhcm5vIHNocmFuanVqdGUgaW4gcHJlbmHFoWFqdGUgc3ZvamUga3JpcHRvdmFsdXRlIGluIE5GVGplLlwiLFxuXHRcdGxvZ0luVG9Bbnk6IFwiUHJpamF2aXRlIHNlIHYga2F0ZXJvIGtvbGkgYXBsaWthY2lqbyBuYSBORUFSXCIsXG5cdFx0bm9OZWVkVG9DcmVhdGU6IFwiTmkgdmFtIHRyZWJhIHVzdHZhcmphdGkgbm92aWggcmHEjXVub3YuIFBvdmXFvml0ZSBzdm9qbyBkZW5hcm5pY28gaW4gemHEjW5pdGUhXCIsXG5cdFx0Z2V0QVdhbGxldDogXCJVc3R2YXJpdGUgZGVuYXJuaWNvXCIsXG5cdFx0dXNlQVdhbGxldDogXCJVcG9yYWJpdGUgZGVuYXJuaWNvLCBkYSBiaSB6YXZhcm92YWxpIGluIHVwcmF2bGphbGkgcyBzdm9qYSBORUFSIGRpZ2l0YWxuYSBzcmVkc3R2YSwgaW4gc2UgcHJpamF2aXRlIHYga2F0ZXJvIGtvbGkgYXBsaWthY2lqbyBla29zaXN0ZW1hIE5FQVJcIixcblx0XHRjb25uZWN0aW9uRmFpbGVkOiBcIlBvdmV6YXZhIG5pIGJpbGEgdXNwZcWhbmEuXCIsXG5cdFx0Y29ubmVjdGlvblN1Y2Nlc3NmdWw6IFwiUG92ZXphdmEgamUgYmlsYSB1c3BlxaFuYS5cIixcblx0XHRjb25uZWN0ZWQ6IFwiVmHFoWEgZGVuYXJuaWNhIGplIHBvdmV6YW5hLlwiLFxuXHRcdGNvbm5lY3RpbmdUbzogXCJQb3Zlem92YW5qZSB6XCIsXG5cdFx0Y29ubmVjdGluZ01lc3NhZ2U6IHtcblx0XHRcdGluamVjdGVkOiBcIlBvdHJkaXRlIHBvdmV6YXZvIHYgb2tudSByYXrFoWlyaXR2ZVwiLFxuXHRcdFx0YnJvd3NlcjogXCJQbyBwcmV1c21lcml0dmkgcG90cmRpdGUgcG92ZXphdm8gdiBkZW5hcm5pY2lcIixcblx0XHRcdGhhcmR3YXJlOiBcIlBvdHJkaXRlIHBvdmV6YXZvIHMgaGxhZG5vIGRlbmFybmljb1wiLFxuXHRcdFx0YnJpZGdlOiBcIlBvdHJkaXRlIHBvdmV6YXZvIHYgZGVuYXJuaWNpXCJcblx0XHR9XG5cdH0sXG5cdGxlZGdlcjoge1xuXHRcdGNvbm5lY3RXaXRoTGVkZ2VyOiBcIlBvdmXFvml0ZSBzZSB6IExlZGdlclwiLFxuXHRcdG1ha2VTdXJlWW91ckxlZGdlcjogXCJQcmVwcmnEjWFqdGUgc2UsIGRhIGplIHZhxaEgTGVkZ2VyIHZhcm5vIHBvdmV6YW4gaW4gZGEgamUgYXBsaWthY2lqYSBORUFSIG9kcHJ0YSB2IHZhxaFpIG5hcHJhdmlcIixcblx0XHRcImNvbnRpbnVlXCI6IFwiTmFkYWxqdWpcIixcblx0XHRzcGVjaWZ5SERQYXRoOiBcIkRvbG/EjWl0ZSBIRCBwb3RcIixcblx0XHRlbnRlcllvdXJQcmVmZXJyZWRIRFBhdGg6IFwiVm5lc2l0ZSDFvmVsZW5vIEhEIHBvdCwgbmF0byBwb2nFocSNaXRlIHZzZSBha3Rpdm5lIHJhxI11bmUuXCIsXG5cdFx0c2NhbjogXCJTa2VuaXJhanRlXCIsXG5cdFx0cmV0cnk6IFwiUG9za3VzaXRlIHpub3ZhXCIsXG5cdFx0bGVkZ2VySXNOb3RBdmFpbGFibGU6IFwiTGVkZ2VyIG5pIG5hIHZvbGpvXCIsXG5cdFx0YWNjZXNzRGVuaWVkVG9Vc2VMZWRnZXJEZXZpY2U6IFwiRG9zdG9wIHphIHVwb3JhYm8gbmFwcmF2ZSBMZWRnZXIgemF2cm5qZW5cIixcblx0XHRub0FjY291bnRzRm91bmQ6IFwiTmkgbmFqZGVuaWggcmHEjXVub3ZcIixcblx0XHRzZWxlY3RZb3VyQWNjb3VudHM6IFwiSXpiZXJpdGUgVmHFoWkgcmHEjXVuaVwiLFxuXHRcdGNvbm5lY3RpbmcxQWNjb3VudDogXCJQb3Zlem92YW5qZSBlbmVnYSByYcSNdW5hXCIsXG5cdFx0Y2FudEZpbmRBbnlBY2NvdW50OiBcIk5pIG1vZ2/EjWUgbmFqdGkgbm9iZW5lZ2EgcmHEjXVuYSwgcG92ZXphbmVnYSBzIHRlbSBMZWRnZXJqZW0uIFVzdHZhcml0ZSBub3YgTkVBUiByYcSNdW4gXCIsXG5cdFx0b3JDb25uZWN0QW5Bbm90aGVyTGVkZ2VyOiBcImFsaSBwb3Zlxb5pdGUgZHJ1ZyBMZWRnZXIuLlwiLFxuXHRcdGNvbm5lY3Rpbmc6IFwiUG92ZXpvdmFuamVcIixcblx0XHRvZkFjY291bnRzOiBcInJhxI11bm92XCIsXG5cdFx0ZmFpbGVkVG9BdXRvbWF0aWNhbGx5OiBcIklELWphIHJhxI11bmEgbmkgYmlsbyBtb2dvxI1lIHNhbW9kZWpubyBuYWp0aS4gWmFnb3Rvdml0ZSBnYSByb8SNbm86XCIsXG5cdFx0b3ZlcnZpZXdUaGVMaXN0T2ZBdXRob3JpemVkOiBcIk9nbGVqdGUgc2kgc2V6bmFtIHBvb2JsYcWhxI1lbmloIHJhxI11bm92LCBkb2tvbsSNYWp0ZSBwcmlqYXZvIHMga2xpa29tIG5hIHNwb2RuamkgZ3VtYi5cIixcblx0XHRmaW5pc2g6IFwiS29uxI1hanRlXCJcblx0fSxcblx0aW5zdGFsbDoge1xuXHRcdHlvdWxsTmVlZFRvSW5zdGFsbDogXCJNb3JhbGkgZ2EgYm9zdGUgbmFtZXN0aXRpXCIsXG5cdFx0dG9Db250aW51ZUFmdGVySW5zdGFsbGluZzogXCJuYWRhbGpldmF0aS4gUG8gbmFtZXN0aXR2aVwiLFxuXHRcdHJlZnJlc2hUaGVQYWdlOiBcIk9zdmXFvml0ZSBzdHJhbi5cIixcblx0XHRvcGVuOiBcIk9kcHJpdGVcIlxuXHR9LFxuXHRxcjoge1xuXHRcdGNvcGllZFRvQ2xpcGJvYXJkOiBcIktvcGlyYW5vIHYgcG9kbG/Fvm5pIG1hcGlcIixcblx0XHRmYWlsZWRUb0NvcHk6IFwiS29waXJhbmplIHYgcG9kbG/Fvm5pIG1hcGkgbmkgdXNwZWxvXCIsXG5cdFx0c2NhbldpdGhZb3VyTW9iaWxlOiBcIlNrZW5pcmFqdGUgcyBzdm9qbyBtb2JpbG5vIG5hcHJhdm9cIixcblx0XHRjb3B5VG9DbGlwYm9hcmQ6IFwiIEtvcGlyYWp0ZSB2IHBvZGxvxb5uaSBtYXBpXCIsXG5cdFx0cHJlZmVyVGhlT2ZmaWNpYWw6IFwiUHJlZmVyaXJhanRlIHVyYWRubyBwb2dvdm9ybm8gb2tub1wiLFxuXHRcdG9wZW46IFwiT2Rwcml0ZVwiXG5cdH0sXG5cdHdhbGxldFR5cGVzOiB7XG5cdFx0aGFyZHdhcmU6IFwiSGxhZG5hIGRlbmFybmljYVwiLFxuXHRcdGJyb3dzZXI6IFwiRGVuYXJuaWNhIGJyc2thbG5pa2FcIixcblx0XHRpbmplY3RlZDogXCJSYXrFoWlyaXRldiB6YSBkZW5hcm5pY29cIixcblx0XHRicmlkZ2U6IFwiQnJpZGdlIGRlbmFybmljYVwiLFxuXHRcdG1vYmlsZTogXCJNb2JpbG5hIGRlbmFybmljYVwiLFxuXHRcdFwiaW5zdGFudC1saW5rXCI6IFwiVGFrb2rFoW5qYSBkZW5hcm5pY2FcIlxuXHR9LFxuXHRleHBvcnRBY2NvdW50czoge1xuXHRcdGNob29zZUFXYWxsZXQ6IFwiSXpiZXJpdGUgZGVuYXJuaWNvXCIsXG5cdFx0dHJhbnNmZXJZb3VyQWNjb3VudHM6IFwiUHJlbmVzaXRlIHN2b2plIHJhxI11bmVcIixcblx0XHRzZWxlY3RBV2FsbGV0OiBcIkl6YmVyaXRlIGRlbmFybmljbywga2kgdXN0cmV6YSB2YcWhaW0gcG90cmViYW0gaW4gcG9kcGlyYSB2YcWhZSBwb3ZlemFuZSByYcSNdW5lLlwiLFxuXHRcdHNlbGVjdFlvdXJBY2NvdW50czogXCJJemJlcml0ZSB2YcWhaSByYcSNdW5pXCIsXG5cdFx0YWZ0ZXJEZWNpZGU6IFwiS28gc2Ugb2Rsb8SNaXRlIHphIGRlbmFybmljbywgbGFoa28gaXpiZXJldGUsIGthdGVyZSByYcSNdW5lIMW+ZWxpdGUgcHJlbmVzdGkuXCIsXG5cdFx0ZGlzY2xhaW1lcjogXCJOZSBib3N0ZSBtb2dsaSBwcmVuZXN0aSBSYcSNdW5vdiwga2kgbmlrb2xpIG5pc28gYmlsaSBmaW5hbmNpcmFuaSBhbGkgdXBvcmFibGplbmkgbmEgTkVBUi5cIixcblx0XHR3YXJuaW5nOiBcInRyZW51dG5vIG5lIHBvZHBpcmEgaXp2b3phIHJhxI11bmEuIEl6YmVyaXRlIGRydWdvIGRlbmFybmljb1wiLFxuXHRcdHdhbGxldFR5cGVzOiB7XG5cdFx0XHRoYXJkd2FyZTogXCJIbGFkbmEgZGVuYXJuaWNhXCIsXG5cdFx0XHRicm93c2VyOiBcIkRlbmFybmljYSBicnNrYWxuaWthXCIsXG5cdFx0XHRpbmplY3RlZDogXCJSYXrFoWlyaXRldiB6YSBkZW5hcm5pY29cIixcblx0XHRcdGJyaWRnZTogXCJCcmlkZ2UgZGVuYXJuaWNhXCIsXG5cdFx0XHRtb2JpbGU6IFwiTW9iaWxuYSBkZW5hcm5pY2FcIlxuXHRcdH0sXG5cdFx0c2VsZWN0QWNjb3VudHM6IHtcblx0XHRcdHRpdGxlOiBcIkl6YmVyaXRlIHJhxI11bmkgemEgcHJlbm9zLlwiLFxuXHRcdFx0YnV0dG9uOiBcIlByaWRvYml0ZSBnZXNsb1wiLFxuXHRcdFx0ZGVzZWxlY3RBbGw6IFwiUHJla2xpxI1pIGl6YmlybyB2c2VoXCIsXG5cdFx0XHRzZWxlY3RBbGw6IFwiSXpiZXJpIHZzZVwiLFxuXHRcdFx0dW5hdmFpbGFibGU6IFwiUHJlbm9zIG5pIG5hIHZvbGpvXCIsXG5cdFx0XHRlcnJvcjogXCJSYcSNdW4gbmUgb2JzdGFqYVwiLFxuXHRcdFx0d2FybmluZ0xlZGdlcjogXCJQb3RyZWJuYSBqZSBwb2Rwb3JhIHphIExlZGdlclwiLFxuXHRcdFx0bm9CYWxhbmNlOiBcIlJhxI11biBuaSBmaW5hbmNpcmFuXCJcblx0XHR9LFxuXHRcdGdldFBhc3NwaHJhc2U6IHtcblx0XHRcdHRpdGxlOiBcIktvcGlyYWogemHEjWFzbm8gZ2VzbG9cIixcblx0XHRcdGRlc2M6IFwiVG8gZ2VzbG8gYm9zdGUgbW9yYWxpIHZuZXN0aSwga28gYm9zdGUgemHEjWVsaSBpenZhxb5hdGkgc3ZvamUgcmHEjXVuZSB2IGRydWdvIGRlbmFybmljby5cIixcblx0XHRcdGJ1dHRvbjogXCJOYWRhbGp1anRlXCIsXG5cdFx0XHRsYWJlbDogXCJLbGlrbml0ZSB6YSBrb3BpcmFuamVcIixcblx0XHRcdGNoZWNrTGFiZWw6IFwiR2VzbG8gc2VtIGtvcGlyYWwgYWxpIHphcGlzYWxcIlxuXHRcdH0sXG5cdFx0Y29tcGxldGU6IHtcblx0XHRcdHRpdGxlOiBcIkRva29uxI1hanRlIHByZW5vc1wiLFxuXHRcdFx0ZGVzY09uZTogXCJaZGFqIGJvc3RlIHByZXVzbWVyamVuaSB2IGRlbmFybmljbywga2kgc3RlIGpvIGl6YnJhbGkgemEgZG9rb27EjWFuamUgcHJlbm9zYS5cIixcblx0XHRcdGRlc2NUd286IFwiS28gamUgdXZvem5pIGRlbCBwb3N0b3BrYSBrb27EjWFuIGl6IGl6YnJhbmUgZGVuYXJuaWNlLCBwcml0aXNuaXRlIGd1bWIgemEgZG9rb27EjWFuamUgcG9zdG9wa2EgcHJlbm9zYS5cIixcblx0XHRcdGJ1dHRvbjogXCJLb27EjWFqdGVcIlxuXHRcdH1cblx0fVxufTtcbnZhciBzbCA9IHtcblx0bW9kYWw6IG1vZGFsJDFcbn07XG5cbnZhciBtb2RhbCA9IHtcblx0d2FsbGV0OiB7XG5cdFx0Y29ubmVjdFlvdXJXYWxsZXQ6IFwi0J/QvtCy0LXQttC40YLQtSDRgdCy0L7RmCDQvdC+0LLRh9Cw0L3QuNC6IVwiLFxuXHRcdHdoYXRJc0FXYWxsZXQ6IFwi0KjRgtCwINGY0LUg0L3QvtCy0YfQsNC90LjQuj9cIixcblx0XHRzZWN1cmVBbmRNYW5hZ2U6IFwi0J7QsdC10LfQsdC10LTQuNGC0LUg0Lgg0YPQv9GA0LDQstGZ0LDRmNGC0LUg0YHQstC+0ZjQvtC8INC00LjQs9C40YLQsNC70L3QvtC8INC40LzQvtCy0LjQvdC+0LwuXCIsXG5cdFx0c2FmZWx5U3RvcmU6IFwi0JHQtdC30LHQtdC00L3QviDRh9GD0LLQsNGY0YLQtSDQuCDQv9GA0LXQvdC+0YHQuNGC0LUg0YHQstC+0ZjQtSDQutGA0LjQv9GC0L7QstCw0LvRg9GC0LUg0LggTkZULlwiLFxuXHRcdGxvZ0luVG9Bbnk6IFwi0J/RgNC40ZjQsNCy0LjRgtC1INGB0LUg0L3QsCDQsdC40LvQviDQutC+0ZjRgyDQsNC/0LvQuNC60LDRhtC40ZjRgyBORUFSXCIsXG5cdFx0bm9OZWVkVG9DcmVhdGU6IFwi0J3QtdC80LAg0L/QvtGC0YDQtdCx0LUg0LTQsCDQutGA0LXQuNGA0LDRgtC1INC90L7QstC1INC90LDQu9C+0LPQtSDQuNC70Lgg0LDQutGA0LXQtNC40YLQuNCy0LUuINCf0L7QstC10LbQuNGC0LUg0L3QvtCy0YfQsNC90LjQuiDQuCDRgdC/0YDQtdC80L3QuCDRgdGCZSFcIixcblx0XHRnZXRBV2FsbGV0OiBcItCd0LDQsdCw0LLQuNGC0LUg0L3QvtCy0YfQsNC90LjQulwiLFxuXHRcdHVzZUFXYWxsZXQ6IFwi0JrQvtGA0LjRgdGC0LjRgtC1INC90L7QstGH0LDQvdC40Log0LTQsCDQvtCx0LXQt9Cx0LXQtNC40YLQtSDQuCDRg9C/0YDQsNCy0ZnQsNGC0LUg0YHQstC+0ZjQuNC8IE5FQVIg0YHRgNC10LTRgdGC0LLQuNC80LAg0Lgg0LTQsCDRgdC1INC/0YDQuNGY0LDQstC40YLQtSDRgyDQsdC40LvQviDQutC+0ZjRgyDQsNC/0LvQuNC60LDRhtC40ZjRgyBORUFSINCx0LXQtyDQv9C+0YLRgNC10LHQtSDQt9CwINC60L7RgNC40YHQvdC40YfQutC40Lwg0LjQvNC10L3QuNC80LAg0Lgg0LvQvtC30LjQvdC60LDQvNCwLlwiLFxuXHRcdGNvbm5lY3Rpb25GYWlsZWQ6IFwi0JLQtdC30LAg0L3QuNGY0LUg0YPRgdC/0L7RgdGC0LDQstGZ0LXQvdCwLlwiLFxuXHRcdGNvbm5lY3Rpb25TdWNjZXNzZnVsOiBcItCS0LXQt9CwINGY0LUg0YPRgdC/0LXQu9CwLlwiLFxuXHRcdGNvbm5lY3RlZDogXCLQn9C+0LLQtdC30LDQvS5cIixcblx0XHRjb25uZWN0aW5nVG86IFwi0J/QvtCy0LXQt9C40LLQsNGa0LUg0L3QsFwiLFxuXHRcdGNvbm5lY3RpbmdNZXNzYWdlOiB7XG5cdFx0XHRpbmplY3RlZDogXCLQn9C+0YLQstGA0LTQuNGC0LUg0LLQtdC30YMg0YMg0YHQv9C+0ZnQvdC+0Lwg0L/RgNC+0LfQvtGA0YNcIixcblx0XHRcdGJyb3dzZXI6IFwi0J3QsNC60L7QvSDQv9GA0LXRg9GB0LzQtdGA0LDQstCw0ZrQsCwg0L/QvtGC0LLRgNC00LjRgtC1INCy0LXQt9GDINGDINC90L7QstGH0LDQvdC40LrRg1wiLFxuXHRcdFx0aGFyZHdhcmU6IFwi0J/QvtGC0LLRgNC00LjRgtC1INCy0LXQt9GDINGB0LAg0YXQu9Cw0LTQvdC40Lwg0L3QvtCy0YfQsNC90LjQutC+0LxcIixcblx0XHRcdGJyaWRnZTogXCLQn9C+0YLQstGA0LTQuNGC0LUg0LLQtdC30YMg0YHQsCDQvdC+0LLRh9Cw0L3QuNC60L7QvFwiXG5cdFx0fVxuXHR9LFxuXHRsZWRnZXI6IHtcblx0XHRjb25uZWN0V2l0aExlZGdlcjogXCLQn9C+0LLQtdC20LjRgtC1INGB0LUg0YHQsCBMZWRnZXJcIixcblx0XHRtYWtlU3VyZVlvdXJMZWRnZXI6IFwi0KPQstC10YDQuNGC0LUg0YHQtSDQtNCwINGY0LUg0LLQsNGIIExlZGdlciDQsdC10LfQsdC10LTQvdC+INC/0L7QstC10LfQsNC9INC4INC00LAg0ZjQtSDQsNC/0LvQuNC60LDRhtC40ZjQsCBORUFSINC+0YLQstC+0YDQtdC90LAg0L3QsCDQstCw0YjQtdC8INGD0YDQtdGS0LDRmNGDXCIsXG5cdFx0XCJjb250aW51ZVwiOiBcItCd0LDRgdGC0LDQstC4XCIsXG5cdFx0c3BlY2lmeUhEUGF0aDogXCLQndCw0LLQtdC00LjRgtC1INCl0JQg0L/Rg9GC0LDRmtGDXCIsXG5cdFx0ZW50ZXJZb3VyUHJlZmVycmVkSERQYXRoOiBcItCj0L3QtdGB0LjRgtC1INC20LXRmdC10L3RgyDQttC10ZnQtdC90YMg0KXQlCDQv9GD0YLQsNGa0YMsINCwINC30LDRgtC40Lwg0YHQutC10L3QuNGA0LDRmNGC0LUg0YHQstC1INCw0LrRgtC40LLQvdC1INC90LDQu9C+0LPQtS5cIixcblx0XHRzY2FuOiBcItCh0LrQtdC90LjRgNCw0ZjRgtC1XCIsXG5cdFx0cmV0cnk6IFwi0J/QvtC60YPRiNCw0Zgg0L/QvtC90L7QstC+XCIsXG5cdFx0bGVkZ2VySXNOb3RBdmFpbGFibGU6IFwiTGVkZ2VyINC90LjRmNC1INC00L7RgdGC0YPQv9Cw0L0uXCIsXG5cdFx0YWNjZXNzRGVuaWVkVG9Vc2VMZWRnZXJEZXZpY2U6IFwi0J/RgNC40YHRgtGD0L8g0ZjQtSDQvtC00LHQuNGY0LXQvSDQt9CwINC60L7RgNC40YjRm9C10ZrQtSBMZWRnZXIg0YPRgNC10ZLQsNGY0LBcIixcblx0XHRub0FjY291bnRzRm91bmQ6IFwi0J3QsGzQvtC30Lgg0L3QuNGB0YMg0L/RgNC+0L3QsNGS0LXQvdC4XCIsXG5cdFx0c2VsZWN0WW91ckFjY291bnRzOiBcItCY0LfQsNCx0LXRgNC40YLQtSDQktCw0Ygg0L3QsGzQvtCzXCIsXG5cdFx0Y29ubmVjdGluZzFBY2NvdW50OiBcItCf0L7QstC10LfQsNGC0LggMSDQvdCwbNC+0LNcIixcblx0XHRjYW50RmluZEFueUFjY291bnQ6IFwi0J3QuNGY0LUg0LzQvtCz0YPRm9C1INC/0YDQvtC90LDRm9C4INC90LjRmNC10LTQsNC9INC90LBs0L7QsyDQv9C+0LLQtdC30LDQvSDRgdCwINC+0LLQuNC8IExlZGdlci3QvtC8LiDQndCw0L/RgNCw0LLQuNGC0LUg0L3QvtCy0LggTkVBUiDQvdCwbNC+0LNcIixcblx0XHRvckNvbm5lY3RBbkFub3RoZXJMZWRnZXI6IFwi0LjQu9C4INC/0L7QstC10LbQuNGC0LUg0LTRgNGD0LPQuCBMZWRnZXIuXCIsXG5cdFx0Y29ubmVjdGluZzogXCLQn9C+0LLQtdC30LjQstCw0ZrQtVwiLFxuXHRcdG9mQWNjb3VudHM6IFwi0L3QsGzQvtCz0LBcIixcblx0XHRmYWlsZWRUb0F1dG9tYXRpY2FsbHk6IFwi0JDRg9GC0L7QvNCw0YLRgdC60L4g0L/RgNC+0L3QsNC70LDQttC10ZrQtSBJRC1hINC90LBs0L7Qs9CwINC90LjRmNC1INGD0YHQv9C10LvQvi4g0J3QsNCy0LXQtNC40YLQtSDQs9CwINGA0YPRh9C90L46XCIsXG5cdFx0b3ZlcnZpZXdUaGVMaXN0T2ZBdXRob3JpemVkOiBcItCf0YDQtdCz0LvQtdC00LDRmNGC0LUg0LvQuNGB0YLRgyDQvtCy0LvQsNGI0ZvQtdC90LjRhSDRgNCw0YfRg9C90LAsINC30LDQstGA0YjQuNGC0LUg0L/RgNC40ZjQsNCy0YMg0LrQu9C40LrQvtC8INC90LAg0LTRg9Cz0LzQtSDQuNGB0L/QvtC0LlwiLFxuXHRcdGZpbmlzaDogXCLQl9Cw0LLRgNGI0LhcIlxuXHR9LFxuXHRpbnN0YWxsOiB7XG5cdFx0eW91bGxOZWVkVG9JbnN0YWxsOiBcItCc0L7RgNCw0ZvQtdGC0LUg0LTQsCDQuNC90YHRgtCw0LvQuNGA0LDRgtC1XCIsXG5cdFx0dG9Db250aW51ZUFmdGVySW5zdGFsbGluZzogXCLQt9CwINC90LDRgdGC0LDQstCw0LouINCd0LDQutC+0L0g0LjQvdGB0YLQsNC70LjRgNCw0ZrQsFwiLFxuXHRcdHJlZnJlc2hUaGVQYWdlOiBcItC/0L7QvdC+0LLQviDRg9GH0LjRgtCw0YLQuCDRgdGC0YDQsNC90LjRhtGDLlwiLFxuXHRcdG9wZW46IFwi0J7RgtCy0L7RgNC4XCJcblx0fSxcblx0cXI6IHtcblx0XHRjb3BpZWRUb0NsaXBib2FyZDogXCLQmtC+0L/QuNGA0LDQvdC+INGDINC80LXRktGD0YHQv9GA0LXQvNC90LjQulwiLFxuXHRcdGZhaWxlZFRvQ29weTogXCLQmtC+0L/QuNGA0LDRmtC1INGDINC80LXRktGD0YHQv9GA0LXQvNC90LjQuiDQvdC40ZjQtSDRg9GB0L/QtdC70L5cIixcblx0XHRzY2FuV2l0aFlvdXJNb2JpbGU6IFwi0KHQutC10L3QuNGA0LDRmNGC0LUg0L/QvtC80L7Rm9GDINC80L7QsdC40LvQvdC+0LMg0YPRgNC10ZLQsNGY0LBcIixcblx0XHRjb3B5VG9DbGlwYm9hcmQ6IFwiINCa0L7Qv9C40YDQsNGYINGDINC80LXRktGD0YHQv9GA0LXQvNC90LjQulwiLFxuXHRcdHByZWZlclRoZU9mZmljaWFsOiBcItCf0YDQtdGE0LXRgNC40YDQsNGC0LUg0LfQstCw0L3QuNGH0L3QuCDQtNC40ZjQsNC70L7QsyDQvtC0XCIsXG5cdFx0b3BlbjogXCLQntGC0LLQvtGA0LhcIlxuXHR9LFxuXHR3YWxsZXRUeXBlczoge1xuXHRcdGhhcmR3YXJlOiBcItCl0LDRgNC00LLQtdGA0YHQutC4INC90L7QstGH0LDQvdC40LpcIixcblx0XHRicm93c2VyOiBcItCd0L7QstGH0LDQvdC40Log0L/RgNC10YLRgNCw0LbQuNCy0LDRh9CwLFwiLFxuXHRcdGluamVjdGVkOiBcItCU0L7QtNCw0YLQsNC6INC30LAg0L3QvtCy0YfQsNC90LjQuixcIixcblx0XHRicmlkZ2U6IFwiQnJpZGdlINC90L7QstGH0LDQvdC40LpcIixcblx0XHRtb2JpbGU6IFwi0JzQvtCx0LjQu9C90Lgg0L3QvtCy0YfQsNC90LjQulwiLFxuXHRcdFwiaW5zdGFudC1saW5rXCI6IFwi0JjQvdGB0YLQsNC90YIg0L3QvtCy0YfQsNC90LjQulwiXG5cdH0sXG5cdGV4cG9ydEFjY291bnRzOiB7XG5cdFx0Y2hvb3NlQVdhbGxldDogXCLQmNC30LDQsdC10YDQuNGC0LUg0L3QvtCy0YfQsNC90LjQulwiLFxuXHRcdHRyYW5zZmVyWW91ckFjY291bnRzOiBcItCf0YDQtdC90LXRgdC40YLQtSDRgdCy0L7RmNC1INC90LDQu9C+0LPQtVwiLFxuXHRcdHNlbGVjdEFXYWxsZXQ6IFwi0JjQt9Cw0LHQtdGA0LjRgtC1INC90L7QstGH0LDQvdC40Log0LrQvtGY0Lgg0L7QtNCz0L7QstCw0YDQsCDQstCw0YjQuNC8INC/0L7RgtGA0LXQsdCw0LzQsCDQuCDQutC+0ZjQuCDQv9C+0LTRgNC20LDQstCwINCy0LDRiNC1INC/0L7QstC10LfQsNC90LUg0L3QsNC70L7Qs9C1LlwiLFxuXHRcdHNlbGVjdFlvdXJBY2NvdW50czogXCLQmNC30LDQsdC10YDQuNGC0LUg0LLQsNGI0LUg0L3QsNC70L7Qs9C1XCIsXG5cdFx0YWZ0ZXJEZWNpZGU6IFwi0J3QsNC60L7QvSDRiNGC0L4g0YHQtSDQvtC00LvRg9GH0LjRgtC1INC30LAg0L3QvtCy0YfQsNC90LjQuiwg0LzQvtC20LXRgtC1INC40LfQsNCx0YDQsNGC0Lgg0LrQvtGY0LUg0L3QsNC70L7Qs9C1INC20LXQu9C40YLQtSDQtNCwINC/0YDQtdC90LXRgdC10YLQtS5cIixcblx0XHRkaXNjbGFpbWVyOiBcItCd0LXRm9C10YLQtSDQvNC+0ZvQuCDQtNCwINC/0YDQtdC90LXRgdC10YLQtSDQvdCw0LvQvtCz0LUg0LrQvtGY0Lgg0L3QuNC60LDQtNCwINC90LjRgdGDINCx0LjQu9C4INGE0LjQvdCw0L3RgdC40YDQsNC90Lgg0LjQu9C4INC60L7RgNC40YjRm9C10L3QuCDQvdCwICBORUFSLlwiLFxuXHRcdHdhcm5pbmc6IFwi0YLRgNC10L3Rg9GC0L3QviDQvdC1INC/0L7QtNGA0LbQsNCy0LAg0LjQt9Cy0L7QtyDQvdCw0LvQvtCz0LAuINCY0LfQsNCx0LXRgNC40YLQtSDQtNGA0YPQs9C4INC90L7QstGH0LDQvdC40LouXCIsXG5cdFx0d2FsbGV0VHlwZXM6IHtcblx0XHRcdGhhcmR3YXJlOiBcItCl0LDRgNC00LLQtdGA0YHQutC4INC90L7QstGH0LDQvdC40LpcIixcblx0XHRcdGJyb3dzZXI6IFwi0J3QvtCy0YfQsNC90LjQuiDQv9GA0LXRgtGA0LDQttC40LLQsNGH0LAsXCIsXG5cdFx0XHRpbmplY3RlZDogXCLQlNC+0LTQsNGC0LDQuiDQt9CwINC90L7QstGH0LDQvdC40LosXCIsXG5cdFx0XHRicmlkZ2U6IFwiQnJpZGdlINC90L7QstGH0LDQvdC40LpcIixcblx0XHRcdG1vYmlsZTogXCLQnNC+0LHQuNC70L3QuCDQvdC+0LLRh9Cw0L3QuNC6XCJcblx0XHR9LFxuXHRcdHNlbGVjdEFjY291bnRzOiB7XG5cdFx0XHR0aXRsZTogXCLQmNC30LDQsdC10YDQuNGC0LUg0L3QsNC70L7Qs9C1INC30LAg0L/RgNC10L3QvtGBLlwiLFxuXHRcdFx0YnV0dG9uOiBcItCU0L7QsdC40ZjRgtC1INC/0YDQuNGB0YLRg9C/0L3RgyDRhNGA0LDQt9GDXCIsXG5cdFx0XHRkZXNlbGVjdEFsbDogXCLQn9C+0L3QuNGI0YLQuNGC0LUg0LjQt9Cx0L7RgFwiLFxuXHRcdFx0c2VsZWN0QWxsOiBcItCY0LfQsNCx0LXRgNC40YLQtSDRgdCy0LVcIixcblx0XHRcdHVuYXZhaWxhYmxlOiBcItCi0YDQsNC90YHRhNC10YAg0L3QuNGY0LUg0LTQvtGB0YLRg9C/0LDQvVwiLFxuXHRcdFx0ZXJyb3I6IFwi0J3QsNC70L7QsyDQvdC1INC/0L7RgdGC0L7RmNC4XCIsXG5cdFx0XHR3YXJuaW5nTGVkZ2VyOiBcItCf0L7RgtGA0LXQsdC90LAg0L/QvtC00YDRiNC60LAg0LfQsCBMZWRnZXJcIixcblx0XHRcdG5vQmFsYW5jZTogXCLQndCw0LvQvtCzINC90LjRmNC1INGE0LjQvdCw0L3RgdC40YDQsNC9XCJcblx0XHR9LFxuXHRcdGdldFBhc3NwaHJhc2U6IHtcblx0XHRcdHRpdGxlOiBcItCa0L7Qv9C40YDQsNGYINC/0YDQuNCy0YDQtdC80LXQvdGDINC70L7Qt9C40L3QutGDXCIsXG5cdFx0XHRkZXNjOiBcItCc0L7RgNCw0ZvQtdGC0LUg0LTQsCDRg9C90LXRgdC10YLQtSDQvtCy0YMg0LvQvtC30LjQvdC60YMg0LrQsNC00LAg0L/QvtGH0L3QtdGC0LUg0LTQsCDQuNC30LLQvtC30LjRgtC1INGB0LLQvtGY0LUg0L3QsNC70L7Qs9C1INGDINC00YDRg9Cz0Lgg0L3QvtCy0YfQsNC90LjQui5cIixcblx0XHRcdGJ1dHRvbjogXCLQndCw0YHRgtCw0LLQuNGC0LVcIixcblx0XHRcdGxhYmVsOiBcItCa0LvQuNC60L3QuNGC0LUg0LTQsCDQsdC40YHRgtC1INC60L7Qv9C40YDQsNC70LhcIixcblx0XHRcdGNoZWNrTGFiZWw6IFwi0JrQvtC/0LjRgNCw0L4g0YHQsNC8INC40LvQuCDQt9Cw0L/QuNGB0LDQviDQu9C+0LfQuNC90LrRg1wiXG5cdFx0fSxcblx0XHRjb21wbGV0ZToge1xuXHRcdFx0dGl0bGU6IFwi0JTQvtCy0YDRiNC40YLQtSDRgtGA0LDQvdGB0YTQtdGAXCIsXG5cdFx0XHRkZXNjT25lOiBcItCh0LDQtNCwINGb0LXRgtC1INCx0LjRgtC4INC/0YDQtdGD0YHQvNC10YDQtdC90Lgg0L3QsCDQvdC+0LLRh9Cw0L3QuNC6INC60L7RmNC4INGB0YLQtSDQuNC30LDQsdGA0LDQu9C4INC00LAg0LfQsNCy0YDRiNC40YLQtSDRgtGA0LDQvdGB0YTQtdGALlwiLFxuXHRcdFx0ZGVzY1R3bzogXCLQmtCw0LTQsCDRgdC1INC00LXQviDQv9GA0L7RhtC10YHQsCDRg9Cy0L7Qt9CwINC30LDQstGA0YjQuCDQuNC3INC40LfQsNCx0YDQsNC90L7QsyDQvdC+0LLRh9Cw0L3QuNC60LAsINC/0YDQuNGC0LjRgdC90LjRgtC1INC00YPQs9C80LUg0LTQsCDQt9Cw0LLRgNGI0LjRgtC1INC/0YDQvtGG0LXRgSDQv9GA0LXQvdC+0YHQsC5cIixcblx0XHRcdGJ1dHRvbjogXCLQl9Cw0LLRgNGI0LjRgtC1XCJcblx0XHR9XG5cdH1cbn07XG52YXIgc3IgPSB7XG5cdG1vZGFsOiBtb2RhbFxufTtcblxuY29uc3QgZ2V0TGFuZ3VhZ2UgPSBsYW5ndWFnZUNvZGUgPT4ge1xuICBzd2l0Y2ggKGxhbmd1YWdlQ29kZSkge1xuICAgIGNhc2UgXCJlblwiOlxuICAgICAgcmV0dXJuIGVuO1xuICAgIGNhc2UgXCJlc1wiOlxuICAgICAgcmV0dXJuIGVzO1xuICAgIGNhc2UgXCJ6aFwiOlxuICAgICAgcmV0dXJuIHpoO1xuICAgIGNhc2UgXCJiZ1wiOlxuICAgICAgcmV0dXJuIGJnO1xuICAgIGNhc2UgXCJrb1wiOlxuICAgICAgcmV0dXJuIGtvO1xuICAgIGNhc2UgXCJ2aVwiOlxuICAgICAgcmV0dXJuIHZpO1xuICAgIGNhc2UgXCJoaVwiOlxuICAgICAgcmV0dXJuIGhpO1xuICAgIGNhc2UgXCJhclwiOlxuICAgICAgcmV0dXJuIGFyO1xuICAgIGNhc2UgXCJoclwiOlxuICAgICAgcmV0dXJuIGhyO1xuICAgIGNhc2UgXCJta1wiOlxuICAgICAgcmV0dXJuIG1rO1xuICAgIGNhc2UgXCJzbFwiOlxuICAgICAgcmV0dXJuIHNsO1xuICAgIGNhc2UgXCJzclwiOlxuICAgICAgcmV0dXJuIHNyO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZW47XG4gIH1cbn07XG5sZXQgY2hvc2VuTGFuZztcbmNvbnN0IGFsbG93T25seUxhbmd1YWdlID0gbGFuZ0NvZGUgPT4ge1xuICBjaG9zZW5MYW5nID0gbGFuZ0NvZGU7XG59O1xuLy8gKGkuZSBlbi1DQSByZXR1cm5zIGp1c3QgZW4pXG5jb25zdCBzaG9ydGVuTGFuZ3VhZ2VDb2RlID0gbGFuZyA9PiB7XG4gIHJldHVybiBsYW5nLmluZGV4T2YoXCItXCIpICE9PSAtMSA/IGxhbmcuc3BsaXQoXCItXCIpWzBdIDogbGFuZy5zcGxpdChcIl9cIilbMF07XG59O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmNvbnN0IGZpbmRPYmplY3RQcm9wQnlTdHJpbmdQYXRoID0gKG9iaiwgcHJvcCkgPT4ge1xuICBpZiAoIW9iaikge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG4gIGNvbnN0IF9pbmRleCA9IHByb3AuaW5kZXhPZihcIi5cIik7XG4gIGlmIChfaW5kZXggPiAtMSkge1xuICAgIGNvbnN0IGN1cnJlbnRQcm9wID0gcHJvcC5zdWJzdHJpbmcoMCwgX2luZGV4KTtcbiAgICBjb25zdCBuZXh0UHJvcCA9IHByb3Auc3Vic3RyaW5nKF9pbmRleCArIDEpO1xuICAgIHJldHVybiBmaW5kT2JqZWN0UHJvcEJ5U3RyaW5nUGF0aChvYmpbY3VycmVudFByb3BdLCBuZXh0UHJvcCk7XG4gIH1cbiAgcmV0dXJuIG9ialtwcm9wXTtcbn07XG5jb25zdCB0cmFuc2xhdGUgPSBwYXRoID0+IHtcbiAgbGV0IGJyb3dzZXJMYW5nID0gd2luZG93Lm5hdmlnYXRvci5sYW5ndWFnZXMgPyB3aW5kb3cubmF2aWdhdG9yLmxhbmd1YWdlc1swXSA6IG51bGw7XG4gIGJyb3dzZXJMYW5nID0gYnJvd3NlckxhbmcgfHwgd2luZG93Lm5hdmlnYXRvci5sYW5ndWFnZTtcbiAgY29uc3QgbGFuZ3VhZ2VDb2RlID0gc2hvcnRlbkxhbmd1YWdlQ29kZShjaG9zZW5MYW5nIHx8IGJyb3dzZXJMYW5nKTtcbiAgY29uc3Qgc2VsZWN0ZWRMYW5ndWFnZSA9IGdldExhbmd1YWdlKGxhbmd1YWdlQ29kZSk7XG4gIGNvbnN0IHRleHQgPSBmaW5kT2JqZWN0UHJvcEJ5U3RyaW5nUGF0aChzZWxlY3RlZExhbmd1YWdlLCBwYXRoKTtcbiAgcmV0dXJuIHRleHQgJiYgdHlwZW9mIHRleHQgPT09IFwic3RyaW5nXCIgPyB0ZXh0IDogcGF0aDtcbn07XG5cbmV4cG9ydHMuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuZXhwb3J0cy5hbGxvd09ubHlMYW5ndWFnZSA9IGFsbG93T25seUxhbmd1YWdlO1xuZXhwb3J0cy5nZXRBY3RpdmVBY2NvdW50ID0gZ2V0QWN0aXZlQWNjb3VudDtcbmV4cG9ydHMuaXNDdXJyZW50QnJvd3NlclN1cHBvcnRlZCA9IGlzQ3VycmVudEJyb3dzZXJTdXBwb3J0ZWQ7XG5leHBvcnRzLnNlcmlhbGl6ZU5lcDQxMyA9IHNlcmlhbGl6ZU5lcDQxMztcbmV4cG9ydHMuc2V0dXBXYWxsZXRTZWxlY3RvciA9IHNldHVwV2FsbGV0U2VsZWN0b3I7XG5leHBvcnRzLnRyYW5zbGF0ZSA9IHRyYW5zbGF0ZTtcbmV4cG9ydHMudmVyaWZ5RnVsbEtleUJlbG9uZ3NUb1VzZXIgPSB2ZXJpZnlGdWxsS2V5QmVsb25nc1RvVXNlcjtcbmV4cG9ydHMudmVyaWZ5U2lnbmF0dXJlID0gdmVyaWZ5U2lnbmF0dXJlO1xuZXhwb3J0cy53YWl0Rm9yID0gd2FpdEZvcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@near-wallet-selector/core/index.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@near-wallet-selector/wallet-utils/index.cjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@near-wallet-selector/wallet-utils/index.cjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar bn_js = __webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/bn.js/lib/bn.js\");\nvar nearAPI = __webpack_require__(/*! near-api-js */ \"(ssr)/./node_modules/near-api-js/lib/index.js\");\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () { return e[k]; }\n        });\n      }\n    });\n  }\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\n\nvar nearAPI__namespace = /*#__PURE__*/_interopNamespace(nearAPI);\n\nconst {\n  transactions,\n  utils\n} = nearAPI__namespace;\nconst getAccessKey = permission => {\n  if (permission === \"FullAccess\") {\n    return transactions.fullAccessKey();\n  }\n  const {\n    receiverId,\n    methodNames = []\n  } = permission;\n  const allowance = permission.allowance ? new bn_js.BN(permission.allowance) : undefined;\n  return transactions.functionCallAccessKey(receiverId, methodNames, allowance);\n};\nconst createAction = action => {\n  switch (action.type) {\n    case \"CreateAccount\":\n      return transactions.createAccount();\n    case \"DeployContract\":\n      {\n        const {\n          code\n        } = action.params;\n        return transactions.deployContract(code);\n      }\n    case \"FunctionCall\":\n      {\n        const {\n          methodName,\n          args,\n          gas,\n          deposit\n        } = action.params;\n        return transactions.functionCall(methodName, args, new bn_js.BN(gas), new bn_js.BN(deposit));\n      }\n    case \"Transfer\":\n      {\n        const {\n          deposit\n        } = action.params;\n        return transactions.transfer(new bn_js.BN(deposit));\n      }\n    case \"Stake\":\n      {\n        const {\n          stake,\n          publicKey\n        } = action.params;\n        return transactions.stake(new bn_js.BN(stake), utils.PublicKey.from(publicKey));\n      }\n    case \"AddKey\":\n      {\n        const {\n          publicKey,\n          accessKey\n        } = action.params;\n        return transactions.addKey(utils.PublicKey.from(publicKey),\n        // TODO: Use accessKey.nonce? near-api-js seems to think 0 is fine?\n        getAccessKey(accessKey.permission));\n      }\n    case \"DeleteKey\":\n      {\n        const {\n          publicKey\n        } = action.params;\n        return transactions.deleteKey(utils.PublicKey.from(publicKey));\n      }\n    case \"DeleteAccount\":\n      {\n        const {\n          beneficiaryId\n        } = action.params;\n        return transactions.deleteAccount(beneficiaryId);\n      }\n    default:\n      throw new Error(\"Invalid action type\");\n  }\n};\n\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nvar fails$d = function (exec) {\n  try {\n    return !!exec();\n  } catch (error) {\n    return true;\n  }\n};\n\nvar fails$c = fails$d;\n\nvar functionBindNative = !fails$c(function () {\n  // eslint-disable-next-line es-x/no-function-prototype-bind -- safe\n  var test = (function () { /* empty */ }).bind();\n  // eslint-disable-next-line no-prototype-builtins -- safe\n  return typeof test != 'function' || test.hasOwnProperty('prototype');\n});\n\nvar NATIVE_BIND$3 = functionBindNative;\n\nvar FunctionPrototype$2 = Function.prototype;\nvar bind$5 = FunctionPrototype$2.bind;\nvar call$e = FunctionPrototype$2.call;\nvar uncurryThis$d = NATIVE_BIND$3 && bind$5.bind(call$e, call$e);\n\nvar functionUncurryThis = NATIVE_BIND$3 ? function (fn) {\n  return fn && uncurryThis$d(fn);\n} : function (fn) {\n  return fn && function () {\n    return call$e.apply(fn, arguments);\n  };\n};\n\nvar uncurryThis$c = functionUncurryThis;\n\nvar toString$2 = uncurryThis$c({}.toString);\nvar stringSlice = uncurryThis$c(''.slice);\n\nvar classofRaw$1 = function (it) {\n  return stringSlice(toString$2(it), 8, -1);\n};\n\nvar uncurryThis$b = functionUncurryThis;\nvar fails$b = fails$d;\nvar classof$5 = classofRaw$1;\n\nvar $Object$4 = Object;\nvar split = uncurryThis$b(''.split);\n\n// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar indexedObject = fails$b(function () {\n  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n  // eslint-disable-next-line no-prototype-builtins -- safe\n  return !$Object$4('z').propertyIsEnumerable(0);\n}) ? function (it) {\n  return classof$5(it) == 'String' ? split(it, '') : $Object$4(it);\n} : $Object$4;\n\nvar $TypeError$b = TypeError;\n\n// `RequireObjectCoercible` abstract operation\n// https://tc39.es/ecma262/#sec-requireobjectcoercible\nvar requireObjectCoercible$2 = function (it) {\n  if (it == undefined) throw $TypeError$b(\"Can't call method on \" + it);\n  return it;\n};\n\n// toObject with fallback for non-array-like ES3 strings\nvar IndexedObject = indexedObject;\nvar requireObjectCoercible$1 = requireObjectCoercible$2;\n\nvar toIndexedObject$5 = function (it) {\n  return IndexedObject(requireObjectCoercible$1(it));\n};\n\nvar check = function (it) {\n  return it && it.Math == Math && it;\n};\n\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global$j =\n  // eslint-disable-next-line es-x/no-global-this -- safe\n  check(typeof globalThis == 'object' && globalThis) ||\n  check(typeof window == 'object' && window) ||\n  // eslint-disable-next-line no-restricted-globals -- safe\n  check(typeof self == 'object' && self) ||\n  check(typeof commonjsGlobal == 'object' && commonjsGlobal) ||\n  // eslint-disable-next-line no-new-func -- fallback\n  (function () { return this; })() || Function('return this')();\n\nvar shared$3 = {exports: {}};\n\nvar global$i = global$j;\n\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar defineProperty$4 = Object.defineProperty;\n\nvar defineGlobalProperty$3 = function (key, value) {\n  try {\n    defineProperty$4(global$i, key, { value: value, configurable: true, writable: true });\n  } catch (error) {\n    global$i[key] = value;\n  } return value;\n};\n\nvar global$h = global$j;\nvar defineGlobalProperty$2 = defineGlobalProperty$3;\n\nvar SHARED = '__core-js_shared__';\nvar store$3 = global$h[SHARED] || defineGlobalProperty$2(SHARED, {});\n\nvar sharedStore = store$3;\n\nvar store$2 = sharedStore;\n\n(shared$3.exports = function (key, value) {\n  return store$2[key] || (store$2[key] = value !== undefined ? value : {});\n})('versions', []).push({\n  version: '3.23.3',\n  mode: 'global',\n  copyright: '© 2014-2022 Denis Pushkarev (zloirock.ru)',\n  license: 'https://github.com/zloirock/core-js/blob/v3.23.3/LICENSE',\n  source: 'https://github.com/zloirock/core-js'\n});\n\nvar requireObjectCoercible = requireObjectCoercible$2;\n\nvar $Object$3 = Object;\n\n// `ToObject` abstract operation\n// https://tc39.es/ecma262/#sec-toobject\nvar toObject$2 = function (argument) {\n  return $Object$3(requireObjectCoercible(argument));\n};\n\nvar uncurryThis$a = functionUncurryThis;\nvar toObject$1 = toObject$2;\n\nvar hasOwnProperty = uncurryThis$a({}.hasOwnProperty);\n\n// `HasOwnProperty` abstract operation\n// https://tc39.es/ecma262/#sec-hasownproperty\n// eslint-disable-next-line es-x/no-object-hasown -- safe\nvar hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {\n  return hasOwnProperty(toObject$1(it), key);\n};\n\nvar uncurryThis$9 = functionUncurryThis;\n\nvar id = 0;\nvar postfix = Math.random();\nvar toString$1 = uncurryThis$9(1.0.toString);\n\nvar uid$2 = function (key) {\n  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString$1(++id + postfix, 36);\n};\n\n// `IsCallable` abstract operation\n// https://tc39.es/ecma262/#sec-iscallable\nvar isCallable$k = function (argument) {\n  return typeof argument == 'function';\n};\n\nvar global$g = global$j;\nvar isCallable$j = isCallable$k;\n\nvar aFunction = function (argument) {\n  return isCallable$j(argument) ? argument : undefined;\n};\n\nvar getBuiltIn$8 = function (namespace, method) {\n  return arguments.length < 2 ? aFunction(global$g[namespace]) : global$g[namespace] && global$g[namespace][method];\n};\n\nvar getBuiltIn$7 = getBuiltIn$8;\n\nvar engineUserAgent = getBuiltIn$7('navigator', 'userAgent') || '';\n\nvar global$f = global$j;\nvar userAgent$3 = engineUserAgent;\n\nvar process$3 = global$f.process;\nvar Deno$1 = global$f.Deno;\nvar versions = process$3 && process$3.versions || Deno$1 && Deno$1.version;\nvar v8 = versions && versions.v8;\nvar match, version;\n\nif (v8) {\n  match = v8.split('.');\n  // in old Chrome, versions of V8 isn't V8 = Chrome / 10\n  // but their correct versions are not interesting for us\n  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);\n}\n\n// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`\n// so check `userAgent` even if `.v8` exists, but 0\nif (!version && userAgent$3) {\n  match = userAgent$3.match(/Edge\\/(\\d+)/);\n  if (!match || match[1] >= 74) {\n    match = userAgent$3.match(/Chrome\\/(\\d+)/);\n    if (match) version = +match[1];\n  }\n}\n\nvar engineV8Version = version;\n\n/* eslint-disable es-x/no-symbol -- required for testing */\n\nvar V8_VERSION$1 = engineV8Version;\nvar fails$a = fails$d;\n\n// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- required for testing\nvar nativeSymbol = !!Object.getOwnPropertySymbols && !fails$a(function () {\n  var symbol = Symbol();\n  // Chrome 38 Symbol has incorrect toString conversion\n  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances\n  return !String(symbol) || !(Object(symbol) instanceof Symbol) ||\n    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances\n    !Symbol.sham && V8_VERSION$1 && V8_VERSION$1 < 41;\n});\n\n/* eslint-disable es-x/no-symbol -- required for testing */\n\nvar NATIVE_SYMBOL$1 = nativeSymbol;\n\nvar useSymbolAsUid = NATIVE_SYMBOL$1\n  && !Symbol.sham\n  && typeof Symbol.iterator == 'symbol';\n\nvar global$e = global$j;\nvar shared$2 = shared$3.exports;\nvar hasOwn$a = hasOwnProperty_1;\nvar uid$1 = uid$2;\nvar NATIVE_SYMBOL = nativeSymbol;\nvar USE_SYMBOL_AS_UID$1 = useSymbolAsUid;\n\nvar WellKnownSymbolsStore = shared$2('wks');\nvar Symbol$1 = global$e.Symbol;\nvar symbolFor = Symbol$1 && Symbol$1['for'];\nvar createWellKnownSymbol = USE_SYMBOL_AS_UID$1 ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid$1;\n\nvar wellKnownSymbol$e = function (name) {\n  if (!hasOwn$a(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == 'string')) {\n    var description = 'Symbol.' + name;\n    if (NATIVE_SYMBOL && hasOwn$a(Symbol$1, name)) {\n      WellKnownSymbolsStore[name] = Symbol$1[name];\n    } else if (USE_SYMBOL_AS_UID$1 && symbolFor) {\n      WellKnownSymbolsStore[name] = symbolFor(description);\n    } else {\n      WellKnownSymbolsStore[name] = createWellKnownSymbol(description);\n    }\n  } return WellKnownSymbolsStore[name];\n};\n\nvar isCallable$i = isCallable$k;\n\nvar isObject$7 = function (it) {\n  return typeof it == 'object' ? it !== null : isCallable$i(it);\n};\n\nvar isObject$6 = isObject$7;\n\nvar $String$3 = String;\nvar $TypeError$a = TypeError;\n\n// `Assert: Type(argument) is Object`\nvar anObject$c = function (argument) {\n  if (isObject$6(argument)) return argument;\n  throw $TypeError$a($String$3(argument) + ' is not an object');\n};\n\nvar objectDefineProperties = {};\n\nvar fails$9 = fails$d;\n\n// Detect IE8's incomplete defineProperty implementation\nvar descriptors = !fails$9(function () {\n  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;\n});\n\nvar DESCRIPTORS$9 = descriptors;\nvar fails$8 = fails$d;\n\n// V8 ~ Chrome 36-\n// https://bugs.chromium.org/p/v8/issues/detail?id=3334\nvar v8PrototypeDefineBug = DESCRIPTORS$9 && fails$8(function () {\n  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n  return Object.defineProperty(function () { /* empty */ }, 'prototype', {\n    value: 42,\n    writable: false\n  }).prototype != 42;\n});\n\nvar objectDefineProperty = {};\n\nvar global$d = global$j;\nvar isObject$5 = isObject$7;\n\nvar document$3 = global$d.document;\n// typeof document.createElement is 'object' in old IE\nvar EXISTS$1 = isObject$5(document$3) && isObject$5(document$3.createElement);\n\nvar documentCreateElement$2 = function (it) {\n  return EXISTS$1 ? document$3.createElement(it) : {};\n};\n\nvar DESCRIPTORS$8 = descriptors;\nvar fails$7 = fails$d;\nvar createElement$1 = documentCreateElement$2;\n\n// Thanks to IE8 for its funny defineProperty\nvar ie8DomDefine = !DESCRIPTORS$8 && !fails$7(function () {\n  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n  return Object.defineProperty(createElement$1('div'), 'a', {\n    get: function () { return 7; }\n  }).a != 7;\n});\n\nvar NATIVE_BIND$2 = functionBindNative;\n\nvar call$d = Function.prototype.call;\n\nvar functionCall = NATIVE_BIND$2 ? call$d.bind(call$d) : function () {\n  return call$d.apply(call$d, arguments);\n};\n\nvar uncurryThis$8 = functionUncurryThis;\n\nvar objectIsPrototypeOf = uncurryThis$8({}.isPrototypeOf);\n\nvar getBuiltIn$6 = getBuiltIn$8;\nvar isCallable$h = isCallable$k;\nvar isPrototypeOf$3 = objectIsPrototypeOf;\nvar USE_SYMBOL_AS_UID = useSymbolAsUid;\n\nvar $Object$2 = Object;\n\nvar isSymbol$2 = USE_SYMBOL_AS_UID ? function (it) {\n  return typeof it == 'symbol';\n} : function (it) {\n  var $Symbol = getBuiltIn$6('Symbol');\n  return isCallable$h($Symbol) && isPrototypeOf$3($Symbol.prototype, $Object$2(it));\n};\n\nvar $String$2 = String;\n\nvar tryToString$4 = function (argument) {\n  try {\n    return $String$2(argument);\n  } catch (error) {\n    return 'Object';\n  }\n};\n\nvar isCallable$g = isCallable$k;\nvar tryToString$3 = tryToString$4;\n\nvar $TypeError$9 = TypeError;\n\n// `Assert: IsCallable(argument) is true`\nvar aCallable$7 = function (argument) {\n  if (isCallable$g(argument)) return argument;\n  throw $TypeError$9(tryToString$3(argument) + ' is not a function');\n};\n\nvar aCallable$6 = aCallable$7;\n\n// `GetMethod` abstract operation\n// https://tc39.es/ecma262/#sec-getmethod\nvar getMethod$3 = function (V, P) {\n  var func = V[P];\n  return func == null ? undefined : aCallable$6(func);\n};\n\nvar call$c = functionCall;\nvar isCallable$f = isCallable$k;\nvar isObject$4 = isObject$7;\n\nvar $TypeError$8 = TypeError;\n\n// `OrdinaryToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-ordinarytoprimitive\nvar ordinaryToPrimitive$1 = function (input, pref) {\n  var fn, val;\n  if (pref === 'string' && isCallable$f(fn = input.toString) && !isObject$4(val = call$c(fn, input))) return val;\n  if (isCallable$f(fn = input.valueOf) && !isObject$4(val = call$c(fn, input))) return val;\n  if (pref !== 'string' && isCallable$f(fn = input.toString) && !isObject$4(val = call$c(fn, input))) return val;\n  throw $TypeError$8(\"Can't convert object to primitive value\");\n};\n\nvar call$b = functionCall;\nvar isObject$3 = isObject$7;\nvar isSymbol$1 = isSymbol$2;\nvar getMethod$2 = getMethod$3;\nvar ordinaryToPrimitive = ordinaryToPrimitive$1;\nvar wellKnownSymbol$d = wellKnownSymbol$e;\n\nvar $TypeError$7 = TypeError;\nvar TO_PRIMITIVE = wellKnownSymbol$d('toPrimitive');\n\n// `ToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-toprimitive\nvar toPrimitive$1 = function (input, pref) {\n  if (!isObject$3(input) || isSymbol$1(input)) return input;\n  var exoticToPrim = getMethod$2(input, TO_PRIMITIVE);\n  var result;\n  if (exoticToPrim) {\n    if (pref === undefined) pref = 'default';\n    result = call$b(exoticToPrim, input, pref);\n    if (!isObject$3(result) || isSymbol$1(result)) return result;\n    throw $TypeError$7(\"Can't convert object to primitive value\");\n  }\n  if (pref === undefined) pref = 'number';\n  return ordinaryToPrimitive(input, pref);\n};\n\nvar toPrimitive = toPrimitive$1;\nvar isSymbol = isSymbol$2;\n\n// `ToPropertyKey` abstract operation\n// https://tc39.es/ecma262/#sec-topropertykey\nvar toPropertyKey$2 = function (argument) {\n  var key = toPrimitive(argument, 'string');\n  return isSymbol(key) ? key : key + '';\n};\n\nvar DESCRIPTORS$7 = descriptors;\nvar IE8_DOM_DEFINE$1 = ie8DomDefine;\nvar V8_PROTOTYPE_DEFINE_BUG$1 = v8PrototypeDefineBug;\nvar anObject$b = anObject$c;\nvar toPropertyKey$1 = toPropertyKey$2;\n\nvar $TypeError$6 = TypeError;\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar $defineProperty = Object.defineProperty;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;\nvar ENUMERABLE = 'enumerable';\nvar CONFIGURABLE$1 = 'configurable';\nvar WRITABLE = 'writable';\n\n// `Object.defineProperty` method\n// https://tc39.es/ecma262/#sec-object.defineproperty\nobjectDefineProperty.f = DESCRIPTORS$7 ? V8_PROTOTYPE_DEFINE_BUG$1 ? function defineProperty(O, P, Attributes) {\n  anObject$b(O);\n  P = toPropertyKey$1(P);\n  anObject$b(Attributes);\n  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {\n    var current = $getOwnPropertyDescriptor$1(O, P);\n    if (current && current[WRITABLE]) {\n      O[P] = Attributes.value;\n      Attributes = {\n        configurable: CONFIGURABLE$1 in Attributes ? Attributes[CONFIGURABLE$1] : current[CONFIGURABLE$1],\n        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],\n        writable: false\n      };\n    }\n  } return $defineProperty(O, P, Attributes);\n} : $defineProperty : function defineProperty(O, P, Attributes) {\n  anObject$b(O);\n  P = toPropertyKey$1(P);\n  anObject$b(Attributes);\n  if (IE8_DOM_DEFINE$1) try {\n    return $defineProperty(O, P, Attributes);\n  } catch (error) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw $TypeError$6('Accessors not supported');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n\nvar ceil = Math.ceil;\nvar floor = Math.floor;\n\n// `Math.trunc` method\n// https://tc39.es/ecma262/#sec-math.trunc\n// eslint-disable-next-line es-x/no-math-trunc -- safe\nvar mathTrunc = Math.trunc || function trunc(x) {\n  var n = +x;\n  return (n > 0 ? floor : ceil)(n);\n};\n\nvar trunc = mathTrunc;\n\n// `ToIntegerOrInfinity` abstract operation\n// https://tc39.es/ecma262/#sec-tointegerorinfinity\nvar toIntegerOrInfinity$2 = function (argument) {\n  var number = +argument;\n  // eslint-disable-next-line no-self-compare -- NaN check\n  return number !== number || number === 0 ? 0 : trunc(number);\n};\n\nvar toIntegerOrInfinity$1 = toIntegerOrInfinity$2;\n\nvar max = Math.max;\nvar min$1 = Math.min;\n\n// Helper for a popular repeating case of the spec:\n// Let integer be ? ToInteger(index).\n// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).\nvar toAbsoluteIndex$1 = function (index, length) {\n  var integer = toIntegerOrInfinity$1(index);\n  return integer < 0 ? max(integer + length, 0) : min$1(integer, length);\n};\n\nvar toIntegerOrInfinity = toIntegerOrInfinity$2;\n\nvar min = Math.min;\n\n// `ToLength` abstract operation\n// https://tc39.es/ecma262/#sec-tolength\nvar toLength$1 = function (argument) {\n  return argument > 0 ? min(toIntegerOrInfinity(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n};\n\nvar toLength = toLength$1;\n\n// `LengthOfArrayLike` abstract operation\n// https://tc39.es/ecma262/#sec-lengthofarraylike\nvar lengthOfArrayLike$2 = function (obj) {\n  return toLength(obj.length);\n};\n\nvar toIndexedObject$4 = toIndexedObject$5;\nvar toAbsoluteIndex = toAbsoluteIndex$1;\nvar lengthOfArrayLike$1 = lengthOfArrayLike$2;\n\n// `Array.prototype.{ indexOf, includes }` methods implementation\nvar createMethod = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIndexedObject$4($this);\n    var length = lengthOfArrayLike$1(O);\n    var index = toAbsoluteIndex(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare -- NaN check\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare -- NaN check\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) {\n      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\nvar arrayIncludes = {\n  // `Array.prototype.includes` method\n  // https://tc39.es/ecma262/#sec-array.prototype.includes\n  includes: createMethod(true),\n  // `Array.prototype.indexOf` method\n  // https://tc39.es/ecma262/#sec-array.prototype.indexof\n  indexOf: createMethod(false)\n};\n\nvar hiddenKeys$4 = {};\n\nvar uncurryThis$7 = functionUncurryThis;\nvar hasOwn$9 = hasOwnProperty_1;\nvar toIndexedObject$3 = toIndexedObject$5;\nvar indexOf = arrayIncludes.indexOf;\nvar hiddenKeys$3 = hiddenKeys$4;\n\nvar push = uncurryThis$7([].push);\n\nvar objectKeysInternal = function (object, names) {\n  var O = toIndexedObject$3(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) !hasOwn$9(hiddenKeys$3, key) && hasOwn$9(O, key) && push(result, key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (hasOwn$9(O, key = names[i++])) {\n    ~indexOf(result, key) || push(result, key);\n  }\n  return result;\n};\n\n// IE8- don't enum bug keys\nvar enumBugKeys$3 = [\n  'constructor',\n  'hasOwnProperty',\n  'isPrototypeOf',\n  'propertyIsEnumerable',\n  'toLocaleString',\n  'toString',\n  'valueOf'\n];\n\nvar internalObjectKeys$1 = objectKeysInternal;\nvar enumBugKeys$2 = enumBugKeys$3;\n\n// `Object.keys` method\n// https://tc39.es/ecma262/#sec-object.keys\n// eslint-disable-next-line es-x/no-object-keys -- safe\nvar objectKeys$1 = Object.keys || function keys(O) {\n  return internalObjectKeys$1(O, enumBugKeys$2);\n};\n\nvar DESCRIPTORS$6 = descriptors;\nvar V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;\nvar definePropertyModule$4 = objectDefineProperty;\nvar anObject$a = anObject$c;\nvar toIndexedObject$2 = toIndexedObject$5;\nvar objectKeys = objectKeys$1;\n\n// `Object.defineProperties` method\n// https://tc39.es/ecma262/#sec-object.defineproperties\n// eslint-disable-next-line es-x/no-object-defineproperties -- safe\nobjectDefineProperties.f = DESCRIPTORS$6 && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {\n  anObject$a(O);\n  var props = toIndexedObject$2(Properties);\n  var keys = objectKeys(Properties);\n  var length = keys.length;\n  var index = 0;\n  var key;\n  while (length > index) definePropertyModule$4.f(O, key = keys[index++], props[key]);\n  return O;\n};\n\nvar getBuiltIn$5 = getBuiltIn$8;\n\nvar html$2 = getBuiltIn$5('document', 'documentElement');\n\nvar shared$1 = shared$3.exports;\nvar uid = uid$2;\n\nvar keys = shared$1('keys');\n\nvar sharedKey$3 = function (key) {\n  return keys[key] || (keys[key] = uid(key));\n};\n\n/* global ActiveXObject -- old IE, WSH */\n\nvar anObject$9 = anObject$c;\nvar definePropertiesModule = objectDefineProperties;\nvar enumBugKeys$1 = enumBugKeys$3;\nvar hiddenKeys$2 = hiddenKeys$4;\nvar html$1 = html$2;\nvar documentCreateElement$1 = documentCreateElement$2;\nvar sharedKey$2 = sharedKey$3;\n\nvar GT = '>';\nvar LT = '<';\nvar PROTOTYPE = 'prototype';\nvar SCRIPT = 'script';\nvar IE_PROTO$1 = sharedKey$2('IE_PROTO');\n\nvar EmptyConstructor = function () { /* empty */ };\n\nvar scriptTag = function (content) {\n  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;\n};\n\n// Create object with fake `null` prototype: use ActiveX Object with cleared prototype\nvar NullProtoObjectViaActiveX = function (activeXDocument) {\n  activeXDocument.write(scriptTag(''));\n  activeXDocument.close();\n  var temp = activeXDocument.parentWindow.Object;\n  activeXDocument = null; // avoid memory leak\n  return temp;\n};\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar NullProtoObjectViaIFrame = function () {\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = documentCreateElement$1('iframe');\n  var JS = 'java' + SCRIPT + ':';\n  var iframeDocument;\n  iframe.style.display = 'none';\n  html$1.appendChild(iframe);\n  // https://github.com/zloirock/core-js/issues/475\n  iframe.src = String(JS);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(scriptTag('document.F=Object'));\n  iframeDocument.close();\n  return iframeDocument.F;\n};\n\n// Check for document.domain and active x support\n// No need to use active x approach when document.domain is not set\n// see https://github.com/es-shims/es5-shim/issues/150\n// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346\n// avoid IE GC bug\nvar activeXDocument;\nvar NullProtoObject = function () {\n  try {\n    activeXDocument = new ActiveXObject('htmlfile');\n  } catch (error) { /* ignore */ }\n  NullProtoObject = typeof document != 'undefined'\n    ? document.domain && activeXDocument\n      ? NullProtoObjectViaActiveX(activeXDocument) // old IE\n      : NullProtoObjectViaIFrame()\n    : NullProtoObjectViaActiveX(activeXDocument); // WSH\n  var length = enumBugKeys$1.length;\n  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys$1[length]];\n  return NullProtoObject();\n};\n\nhiddenKeys$2[IE_PROTO$1] = true;\n\n// `Object.create` method\n// https://tc39.es/ecma262/#sec-object.create\n// eslint-disable-next-line es-x/no-object-create -- safe\nvar objectCreate = Object.create || function create(O, Properties) {\n  var result;\n  if (O !== null) {\n    EmptyConstructor[PROTOTYPE] = anObject$9(O);\n    result = new EmptyConstructor();\n    EmptyConstructor[PROTOTYPE] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO$1] = O;\n  } else result = NullProtoObject();\n  return Properties === undefined ? result : definePropertiesModule.f(result, Properties);\n};\n\nvar wellKnownSymbol$c = wellKnownSymbol$e;\nvar create$1 = objectCreate;\nvar defineProperty$3 = objectDefineProperty.f;\n\nvar UNSCOPABLES = wellKnownSymbol$c('unscopables');\nvar ArrayPrototype$1 = Array.prototype;\n\n// Array.prototype[@@unscopables]\n// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\nif (ArrayPrototype$1[UNSCOPABLES] == undefined) {\n  defineProperty$3(ArrayPrototype$1, UNSCOPABLES, {\n    configurable: true,\n    value: create$1(null)\n  });\n}\n\n// add a key to Array.prototype[@@unscopables]\nvar addToUnscopables$1 = function (key) {\n  ArrayPrototype$1[UNSCOPABLES][key] = true;\n};\n\nvar iterators = {};\n\nvar uncurryThis$6 = functionUncurryThis;\nvar isCallable$e = isCallable$k;\nvar store$1 = sharedStore;\n\nvar functionToString = uncurryThis$6(Function.toString);\n\n// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper\nif (!isCallable$e(store$1.inspectSource)) {\n  store$1.inspectSource = function (it) {\n    return functionToString(it);\n  };\n}\n\nvar inspectSource$4 = store$1.inspectSource;\n\nvar global$c = global$j;\nvar isCallable$d = isCallable$k;\nvar inspectSource$3 = inspectSource$4;\n\nvar WeakMap$1 = global$c.WeakMap;\n\nvar nativeWeakMap = isCallable$d(WeakMap$1) && /native code/.test(inspectSource$3(WeakMap$1));\n\nvar createPropertyDescriptor$3 = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n\nvar DESCRIPTORS$5 = descriptors;\nvar definePropertyModule$3 = objectDefineProperty;\nvar createPropertyDescriptor$2 = createPropertyDescriptor$3;\n\nvar createNonEnumerableProperty$4 = DESCRIPTORS$5 ? function (object, key, value) {\n  return definePropertyModule$3.f(object, key, createPropertyDescriptor$2(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n\nvar NATIVE_WEAK_MAP = nativeWeakMap;\nvar global$b = global$j;\nvar uncurryThis$5 = functionUncurryThis;\nvar isObject$2 = isObject$7;\nvar createNonEnumerableProperty$3 = createNonEnumerableProperty$4;\nvar hasOwn$8 = hasOwnProperty_1;\nvar shared = sharedStore;\nvar sharedKey$1 = sharedKey$3;\nvar hiddenKeys$1 = hiddenKeys$4;\n\nvar OBJECT_ALREADY_INITIALIZED = 'Object already initialized';\nvar TypeError$2 = global$b.TypeError;\nvar WeakMap = global$b.WeakMap;\nvar set$1, get, has;\n\nvar enforce = function (it) {\n  return has(it) ? get(it) : set$1(it, {});\n};\n\nvar getterFor = function (TYPE) {\n  return function (it) {\n    var state;\n    if (!isObject$2(it) || (state = get(it)).type !== TYPE) {\n      throw TypeError$2('Incompatible receiver, ' + TYPE + ' required');\n    } return state;\n  };\n};\n\nif (NATIVE_WEAK_MAP || shared.state) {\n  var store = shared.state || (shared.state = new WeakMap());\n  var wmget = uncurryThis$5(store.get);\n  var wmhas = uncurryThis$5(store.has);\n  var wmset = uncurryThis$5(store.set);\n  set$1 = function (it, metadata) {\n    if (wmhas(store, it)) throw new TypeError$2(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    wmset(store, it, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return wmget(store, it) || {};\n  };\n  has = function (it) {\n    return wmhas(store, it);\n  };\n} else {\n  var STATE = sharedKey$1('state');\n  hiddenKeys$1[STATE] = true;\n  set$1 = function (it, metadata) {\n    if (hasOwn$8(it, STATE)) throw new TypeError$2(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    createNonEnumerableProperty$3(it, STATE, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return hasOwn$8(it, STATE) ? it[STATE] : {};\n  };\n  has = function (it) {\n    return hasOwn$8(it, STATE);\n  };\n}\n\nvar internalState = {\n  set: set$1,\n  get: get,\n  has: has,\n  enforce: enforce,\n  getterFor: getterFor\n};\n\nvar objectGetOwnPropertyDescriptor = {};\n\nvar objectPropertyIsEnumerable = {};\n\nvar $propertyIsEnumerable = {}.propertyIsEnumerable;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar getOwnPropertyDescriptor$2 = Object.getOwnPropertyDescriptor;\n\n// Nashorn ~ JDK8 bug\nvar NASHORN_BUG = getOwnPropertyDescriptor$2 && !$propertyIsEnumerable.call({ 1: 2 }, 1);\n\n// `Object.prototype.propertyIsEnumerable` method implementation\n// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable\nobjectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n  var descriptor = getOwnPropertyDescriptor$2(this, V);\n  return !!descriptor && descriptor.enumerable;\n} : $propertyIsEnumerable;\n\nvar DESCRIPTORS$4 = descriptors;\nvar call$a = functionCall;\nvar propertyIsEnumerableModule = objectPropertyIsEnumerable;\nvar createPropertyDescriptor$1 = createPropertyDescriptor$3;\nvar toIndexedObject$1 = toIndexedObject$5;\nvar toPropertyKey = toPropertyKey$2;\nvar hasOwn$7 = hasOwnProperty_1;\nvar IE8_DOM_DEFINE = ie8DomDefine;\n\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n// `Object.getOwnPropertyDescriptor` method\n// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor\nobjectGetOwnPropertyDescriptor.f = DESCRIPTORS$4 ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {\n  O = toIndexedObject$1(O);\n  P = toPropertyKey(P);\n  if (IE8_DOM_DEFINE) try {\n    return $getOwnPropertyDescriptor(O, P);\n  } catch (error) { /* empty */ }\n  if (hasOwn$7(O, P)) return createPropertyDescriptor$1(!call$a(propertyIsEnumerableModule.f, O, P), O[P]);\n};\n\nvar makeBuiltIn$2 = {exports: {}};\n\nvar DESCRIPTORS$3 = descriptors;\nvar hasOwn$6 = hasOwnProperty_1;\n\nvar FunctionPrototype$1 = Function.prototype;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar getDescriptor = DESCRIPTORS$3 && Object.getOwnPropertyDescriptor;\n\nvar EXISTS = hasOwn$6(FunctionPrototype$1, 'name');\n// additional protection from minified / mangled / dropped function names\nvar PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';\nvar CONFIGURABLE = EXISTS && (!DESCRIPTORS$3 || (DESCRIPTORS$3 && getDescriptor(FunctionPrototype$1, 'name').configurable));\n\nvar functionName = {\n  EXISTS: EXISTS,\n  PROPER: PROPER,\n  CONFIGURABLE: CONFIGURABLE\n};\n\nvar fails$6 = fails$d;\nvar isCallable$c = isCallable$k;\nvar hasOwn$5 = hasOwnProperty_1;\nvar DESCRIPTORS$2 = descriptors;\nvar CONFIGURABLE_FUNCTION_NAME$1 = functionName.CONFIGURABLE;\nvar inspectSource$2 = inspectSource$4;\nvar InternalStateModule$2 = internalState;\n\nvar enforceInternalState = InternalStateModule$2.enforce;\nvar getInternalState$1 = InternalStateModule$2.get;\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar defineProperty$2 = Object.defineProperty;\n\nvar CONFIGURABLE_LENGTH = DESCRIPTORS$2 && !fails$6(function () {\n  return defineProperty$2(function () { /* empty */ }, 'length', { value: 8 }).length !== 8;\n});\n\nvar TEMPLATE = String(String).split('String');\n\nvar makeBuiltIn$1 = makeBuiltIn$2.exports = function (value, name, options) {\n  if (String(name).slice(0, 7) === 'Symbol(') {\n    name = '[' + String(name).replace(/^Symbol\\(([^)]*)\\)/, '$1') + ']';\n  }\n  if (options && options.getter) name = 'get ' + name;\n  if (options && options.setter) name = 'set ' + name;\n  if (!hasOwn$5(value, 'name') || (CONFIGURABLE_FUNCTION_NAME$1 && value.name !== name)) {\n    if (DESCRIPTORS$2) defineProperty$2(value, 'name', { value: name, configurable: true });\n    else value.name = name;\n  }\n  if (CONFIGURABLE_LENGTH && options && hasOwn$5(options, 'arity') && value.length !== options.arity) {\n    defineProperty$2(value, 'length', { value: options.arity });\n  }\n  try {\n    if (options && hasOwn$5(options, 'constructor') && options.constructor) {\n      if (DESCRIPTORS$2) defineProperty$2(value, 'prototype', { writable: false });\n    // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable\n    } else if (value.prototype) value.prototype = undefined;\n  } catch (error) { /* empty */ }\n  var state = enforceInternalState(value);\n  if (!hasOwn$5(state, 'source')) {\n    state.source = TEMPLATE.join(typeof name == 'string' ? name : '');\n  } return value;\n};\n\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n// eslint-disable-next-line no-extend-native -- required\nFunction.prototype.toString = makeBuiltIn$1(function toString() {\n  return isCallable$c(this) && getInternalState$1(this).source || inspectSource$2(this);\n}, 'toString');\n\nvar isCallable$b = isCallable$k;\nvar definePropertyModule$2 = objectDefineProperty;\nvar makeBuiltIn = makeBuiltIn$2.exports;\nvar defineGlobalProperty$1 = defineGlobalProperty$3;\n\nvar defineBuiltIn$6 = function (O, key, value, options) {\n  if (!options) options = {};\n  var simple = options.enumerable;\n  var name = options.name !== undefined ? options.name : key;\n  if (isCallable$b(value)) makeBuiltIn(value, name, options);\n  if (options.global) {\n    if (simple) O[key] = value;\n    else defineGlobalProperty$1(key, value);\n  } else {\n    try {\n      if (!options.unsafe) delete O[key];\n      else if (O[key]) simple = true;\n    } catch (error) { /* empty */ }\n    if (simple) O[key] = value;\n    else definePropertyModule$2.f(O, key, {\n      value: value,\n      enumerable: false,\n      configurable: !options.nonConfigurable,\n      writable: !options.nonWritable\n    });\n  } return O;\n};\n\nvar objectGetOwnPropertyNames = {};\n\nvar internalObjectKeys = objectKeysInternal;\nvar enumBugKeys = enumBugKeys$3;\n\nvar hiddenKeys = enumBugKeys.concat('length', 'prototype');\n\n// `Object.getOwnPropertyNames` method\n// https://tc39.es/ecma262/#sec-object.getownpropertynames\n// eslint-disable-next-line es-x/no-object-getownpropertynames -- safe\nobjectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return internalObjectKeys(O, hiddenKeys);\n};\n\nvar objectGetOwnPropertySymbols = {};\n\n// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- safe\nobjectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;\n\nvar getBuiltIn$4 = getBuiltIn$8;\nvar uncurryThis$4 = functionUncurryThis;\nvar getOwnPropertyNamesModule = objectGetOwnPropertyNames;\nvar getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;\nvar anObject$8 = anObject$c;\n\nvar concat = uncurryThis$4([].concat);\n\n// all object keys, includes non-enumerable and symbols\nvar ownKeys$1 = getBuiltIn$4('Reflect', 'ownKeys') || function ownKeys(it) {\n  var keys = getOwnPropertyNamesModule.f(anObject$8(it));\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n  return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;\n};\n\nvar hasOwn$4 = hasOwnProperty_1;\nvar ownKeys = ownKeys$1;\nvar getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;\nvar definePropertyModule$1 = objectDefineProperty;\n\nvar copyConstructorProperties$1 = function (target, source, exceptions) {\n  var keys = ownKeys(source);\n  var defineProperty = definePropertyModule$1.f;\n  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    if (!hasOwn$4(target, key) && !(exceptions && hasOwn$4(exceptions, key))) {\n      defineProperty(target, key, getOwnPropertyDescriptor(source, key));\n    }\n  }\n};\n\nvar fails$5 = fails$d;\nvar isCallable$a = isCallable$k;\n\nvar replacement = /#|\\.prototype\\./;\n\nvar isForced$2 = function (feature, detection) {\n  var value = data[normalize(feature)];\n  return value == POLYFILL ? true\n    : value == NATIVE ? false\n    : isCallable$a(detection) ? fails$5(detection)\n    : !!detection;\n};\n\nvar normalize = isForced$2.normalize = function (string) {\n  return String(string).replace(replacement, '.').toLowerCase();\n};\n\nvar data = isForced$2.data = {};\nvar NATIVE = isForced$2.NATIVE = 'N';\nvar POLYFILL = isForced$2.POLYFILL = 'P';\n\nvar isForced_1 = isForced$2;\n\nvar global$a = global$j;\nvar getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;\nvar createNonEnumerableProperty$2 = createNonEnumerableProperty$4;\nvar defineBuiltIn$5 = defineBuiltIn$6;\nvar defineGlobalProperty = defineGlobalProperty$3;\nvar copyConstructorProperties = copyConstructorProperties$1;\nvar isForced$1 = isForced_1;\n\n/*\n  options.target         - name of the target object\n  options.global         - target is the global object\n  options.stat           - export as static methods of target\n  options.proto          - export as prototype methods of target\n  options.real           - real prototype method for the `pure` version\n  options.forced         - export even if the native feature is available\n  options.bind           - bind methods to the target, required for the `pure` version\n  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version\n  options.unsafe         - use the simple assignment of property instead of delete + defineProperty\n  options.sham           - add a flag to not completely full polyfills\n  options.enumerable     - export as enumerable property\n  options.dontCallGetSet - prevent calling a getter on target\n  options.name           - the .name of the function if it does not match the key\n*/\nvar _export = function (options, source) {\n  var TARGET = options.target;\n  var GLOBAL = options.global;\n  var STATIC = options.stat;\n  var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n  if (GLOBAL) {\n    target = global$a;\n  } else if (STATIC) {\n    target = global$a[TARGET] || defineGlobalProperty(TARGET, {});\n  } else {\n    target = (global$a[TARGET] || {}).prototype;\n  }\n  if (target) for (key in source) {\n    sourceProperty = source[key];\n    if (options.dontCallGetSet) {\n      descriptor = getOwnPropertyDescriptor$1(target, key);\n      targetProperty = descriptor && descriptor.value;\n    } else targetProperty = target[key];\n    FORCED = isForced$1(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);\n    // contained in target\n    if (!FORCED && targetProperty !== undefined) {\n      if (typeof sourceProperty == typeof targetProperty) continue;\n      copyConstructorProperties(sourceProperty, targetProperty);\n    }\n    // add a flag to not completely full polyfills\n    if (options.sham || (targetProperty && targetProperty.sham)) {\n      createNonEnumerableProperty$2(sourceProperty, 'sham', true);\n    }\n    defineBuiltIn$5(target, key, sourceProperty, options);\n  }\n};\n\nvar fails$4 = fails$d;\n\nvar correctPrototypeGetter = !fails$4(function () {\n  function F() { /* empty */ }\n  F.prototype.constructor = null;\n  // eslint-disable-next-line es-x/no-object-getprototypeof -- required for testing\n  return Object.getPrototypeOf(new F()) !== F.prototype;\n});\n\nvar hasOwn$3 = hasOwnProperty_1;\nvar isCallable$9 = isCallable$k;\nvar toObject = toObject$2;\nvar sharedKey = sharedKey$3;\nvar CORRECT_PROTOTYPE_GETTER = correctPrototypeGetter;\n\nvar IE_PROTO = sharedKey('IE_PROTO');\nvar $Object$1 = Object;\nvar ObjectPrototype = $Object$1.prototype;\n\n// `Object.getPrototypeOf` method\n// https://tc39.es/ecma262/#sec-object.getprototypeof\n// eslint-disable-next-line es-x/no-object-getprototypeof -- safe\nvar objectGetPrototypeOf = CORRECT_PROTOTYPE_GETTER ? $Object$1.getPrototypeOf : function (O) {\n  var object = toObject(O);\n  if (hasOwn$3(object, IE_PROTO)) return object[IE_PROTO];\n  var constructor = object.constructor;\n  if (isCallable$9(constructor) && object instanceof constructor) {\n    return constructor.prototype;\n  } return object instanceof $Object$1 ? ObjectPrototype : null;\n};\n\nvar fails$3 = fails$d;\nvar isCallable$8 = isCallable$k;\nvar getPrototypeOf$1 = objectGetPrototypeOf;\nvar defineBuiltIn$4 = defineBuiltIn$6;\nvar wellKnownSymbol$b = wellKnownSymbol$e;\n\nvar ITERATOR$5 = wellKnownSymbol$b('iterator');\nvar BUGGY_SAFARI_ITERATORS$1 = false;\n\n// `%IteratorPrototype%` object\n// https://tc39.es/ecma262/#sec-%iteratorprototype%-object\nvar IteratorPrototype$2, PrototypeOfArrayIteratorPrototype, arrayIterator;\n\n/* eslint-disable es-x/no-array-prototype-keys -- safe */\nif ([].keys) {\n  arrayIterator = [].keys();\n  // Safari 8 has buggy iterators w/o `next`\n  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS$1 = true;\n  else {\n    PrototypeOfArrayIteratorPrototype = getPrototypeOf$1(getPrototypeOf$1(arrayIterator));\n    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype$2 = PrototypeOfArrayIteratorPrototype;\n  }\n}\n\nvar NEW_ITERATOR_PROTOTYPE = IteratorPrototype$2 == undefined || fails$3(function () {\n  var test = {};\n  // FF44- legacy iterators case\n  return IteratorPrototype$2[ITERATOR$5].call(test) !== test;\n});\n\nif (NEW_ITERATOR_PROTOTYPE) IteratorPrototype$2 = {};\n\n// `%IteratorPrototype%[@@iterator]()` method\n// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator\nif (!isCallable$8(IteratorPrototype$2[ITERATOR$5])) {\n  defineBuiltIn$4(IteratorPrototype$2, ITERATOR$5, function () {\n    return this;\n  });\n}\n\nvar iteratorsCore = {\n  IteratorPrototype: IteratorPrototype$2,\n  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1\n};\n\nvar defineProperty$1 = objectDefineProperty.f;\nvar hasOwn$2 = hasOwnProperty_1;\nvar wellKnownSymbol$a = wellKnownSymbol$e;\n\nvar TO_STRING_TAG$3 = wellKnownSymbol$a('toStringTag');\n\nvar setToStringTag$3 = function (target, TAG, STATIC) {\n  if (target && !STATIC) target = target.prototype;\n  if (target && !hasOwn$2(target, TO_STRING_TAG$3)) {\n    defineProperty$1(target, TO_STRING_TAG$3, { configurable: true, value: TAG });\n  }\n};\n\nvar IteratorPrototype$1 = iteratorsCore.IteratorPrototype;\nvar create = objectCreate;\nvar createPropertyDescriptor = createPropertyDescriptor$3;\nvar setToStringTag$2 = setToStringTag$3;\nvar Iterators$4 = iterators;\n\nvar returnThis$1 = function () { return this; };\n\nvar createIteratorConstructor$1 = function (IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {\n  var TO_STRING_TAG = NAME + ' Iterator';\n  IteratorConstructor.prototype = create(IteratorPrototype$1, { next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next) });\n  setToStringTag$2(IteratorConstructor, TO_STRING_TAG, false);\n  Iterators$4[TO_STRING_TAG] = returnThis$1;\n  return IteratorConstructor;\n};\n\nvar isCallable$7 = isCallable$k;\n\nvar $String$1 = String;\nvar $TypeError$5 = TypeError;\n\nvar aPossiblePrototype$1 = function (argument) {\n  if (typeof argument == 'object' || isCallable$7(argument)) return argument;\n  throw $TypeError$5(\"Can't set \" + $String$1(argument) + ' as a prototype');\n};\n\n/* eslint-disable no-proto -- safe */\n\nvar uncurryThis$3 = functionUncurryThis;\nvar anObject$7 = anObject$c;\nvar aPossiblePrototype = aPossiblePrototype$1;\n\n// `Object.setPrototypeOf` method\n// https://tc39.es/ecma262/#sec-object.setprototypeof\n// Works with __proto__ only. Old v8 can't work with null proto objects.\n// eslint-disable-next-line es-x/no-object-setprototypeof -- safe\nvar objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {\n  var CORRECT_SETTER = false;\n  var test = {};\n  var setter;\n  try {\n    // eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\n    setter = uncurryThis$3(Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set);\n    setter(test, []);\n    CORRECT_SETTER = test instanceof Array;\n  } catch (error) { /* empty */ }\n  return function setPrototypeOf(O, proto) {\n    anObject$7(O);\n    aPossiblePrototype(proto);\n    if (CORRECT_SETTER) setter(O, proto);\n    else O.__proto__ = proto;\n    return O;\n  };\n}() : undefined);\n\nvar $$6 = _export;\nvar call$9 = functionCall;\nvar FunctionName = functionName;\nvar isCallable$6 = isCallable$k;\nvar createIteratorConstructor = createIteratorConstructor$1;\nvar getPrototypeOf = objectGetPrototypeOf;\nvar setPrototypeOf$1 = objectSetPrototypeOf;\nvar setToStringTag$1 = setToStringTag$3;\nvar createNonEnumerableProperty$1 = createNonEnumerableProperty$4;\nvar defineBuiltIn$3 = defineBuiltIn$6;\nvar wellKnownSymbol$9 = wellKnownSymbol$e;\nvar Iterators$3 = iterators;\nvar IteratorsCore = iteratorsCore;\n\nvar PROPER_FUNCTION_NAME$1 = FunctionName.PROPER;\nvar CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;\nvar IteratorPrototype = IteratorsCore.IteratorPrototype;\nvar BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;\nvar ITERATOR$4 = wellKnownSymbol$9('iterator');\nvar KEYS = 'keys';\nvar VALUES = 'values';\nvar ENTRIES = 'entries';\n\nvar returnThis = function () { return this; };\n\nvar defineIterator$1 = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {\n  createIteratorConstructor(IteratorConstructor, NAME, next);\n\n  var getIterationMethod = function (KIND) {\n    if (KIND === DEFAULT && defaultIterator) return defaultIterator;\n    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];\n    switch (KIND) {\n      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };\n      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };\n      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };\n    } return function () { return new IteratorConstructor(this); };\n  };\n\n  var TO_STRING_TAG = NAME + ' Iterator';\n  var INCORRECT_VALUES_NAME = false;\n  var IterablePrototype = Iterable.prototype;\n  var nativeIterator = IterablePrototype[ITERATOR$4]\n    || IterablePrototype['@@iterator']\n    || DEFAULT && IterablePrototype[DEFAULT];\n  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);\n  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;\n  var CurrentIteratorPrototype, methods, KEY;\n\n  // fix native\n  if (anyNativeIterator) {\n    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));\n    if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {\n      if (getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {\n        if (setPrototypeOf$1) {\n          setPrototypeOf$1(CurrentIteratorPrototype, IteratorPrototype);\n        } else if (!isCallable$6(CurrentIteratorPrototype[ITERATOR$4])) {\n          defineBuiltIn$3(CurrentIteratorPrototype, ITERATOR$4, returnThis);\n        }\n      }\n      // Set @@toStringTag to native iterators\n      setToStringTag$1(CurrentIteratorPrototype, TO_STRING_TAG, true);\n    }\n  }\n\n  // fix Array.prototype.{ values, @@iterator }.name in V8 / FF\n  if (PROPER_FUNCTION_NAME$1 && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {\n    if (CONFIGURABLE_FUNCTION_NAME) {\n      createNonEnumerableProperty$1(IterablePrototype, 'name', VALUES);\n    } else {\n      INCORRECT_VALUES_NAME = true;\n      defaultIterator = function values() { return call$9(nativeIterator, this); };\n    }\n  }\n\n  // export additional methods\n  if (DEFAULT) {\n    methods = {\n      values: getIterationMethod(VALUES),\n      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),\n      entries: getIterationMethod(ENTRIES)\n    };\n    if (FORCED) for (KEY in methods) {\n      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {\n        defineBuiltIn$3(IterablePrototype, KEY, methods[KEY]);\n      }\n    } else $$6({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);\n  }\n\n  // define iterator\n  if (IterablePrototype[ITERATOR$4] !== defaultIterator) {\n    defineBuiltIn$3(IterablePrototype, ITERATOR$4, defaultIterator, { name: DEFAULT });\n  }\n  Iterators$3[NAME] = defaultIterator;\n\n  return methods;\n};\n\nvar toIndexedObject = toIndexedObject$5;\nvar addToUnscopables = addToUnscopables$1;\nvar Iterators$2 = iterators;\nvar InternalStateModule$1 = internalState;\nvar defineProperty = objectDefineProperty.f;\nvar defineIterator = defineIterator$1;\nvar DESCRIPTORS$1 = descriptors;\n\nvar ARRAY_ITERATOR = 'Array Iterator';\nvar setInternalState$1 = InternalStateModule$1.set;\nvar getInternalState = InternalStateModule$1.getterFor(ARRAY_ITERATOR);\n\n// `Array.prototype.entries` method\n// https://tc39.es/ecma262/#sec-array.prototype.entries\n// `Array.prototype.keys` method\n// https://tc39.es/ecma262/#sec-array.prototype.keys\n// `Array.prototype.values` method\n// https://tc39.es/ecma262/#sec-array.prototype.values\n// `Array.prototype[@@iterator]` method\n// https://tc39.es/ecma262/#sec-array.prototype-@@iterator\n// `CreateArrayIterator` internal method\n// https://tc39.es/ecma262/#sec-createarrayiterator\nvar es_array_iterator = defineIterator(Array, 'Array', function (iterated, kind) {\n  setInternalState$1(this, {\n    type: ARRAY_ITERATOR,\n    target: toIndexedObject(iterated), // target\n    index: 0,                          // next index\n    kind: kind                         // kind\n  });\n// `%ArrayIteratorPrototype%.next` method\n// https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next\n}, function () {\n  var state = getInternalState(this);\n  var target = state.target;\n  var kind = state.kind;\n  var index = state.index++;\n  if (!target || index >= target.length) {\n    state.target = undefined;\n    return { value: undefined, done: true };\n  }\n  if (kind == 'keys') return { value: index, done: false };\n  if (kind == 'values') return { value: target[index], done: false };\n  return { value: [index, target[index]], done: false };\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values%\n// https://tc39.es/ecma262/#sec-createunmappedargumentsobject\n// https://tc39.es/ecma262/#sec-createmappedargumentsobject\nvar values = Iterators$2.Arguments = Iterators$2.Array;\n\n// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\naddToUnscopables('keys');\naddToUnscopables('values');\naddToUnscopables('entries');\n\n// V8 ~ Chrome 45- bug\nif (DESCRIPTORS$1 && values.name !== 'values') try {\n  defineProperty(values, 'name', { value: 'values' });\n} catch (error) { /* empty */ }\n\n// iterable DOM collections\n// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods\nvar domIterables = {\n  CSSRuleList: 0,\n  CSSStyleDeclaration: 0,\n  CSSValueList: 0,\n  ClientRectList: 0,\n  DOMRectList: 0,\n  DOMStringList: 0,\n  DOMTokenList: 1,\n  DataTransferItemList: 0,\n  FileList: 0,\n  HTMLAllCollection: 0,\n  HTMLCollection: 0,\n  HTMLFormElement: 0,\n  HTMLSelectElement: 0,\n  MediaList: 0,\n  MimeTypeArray: 0,\n  NamedNodeMap: 0,\n  NodeList: 1,\n  PaintRequestList: 0,\n  Plugin: 0,\n  PluginArray: 0,\n  SVGLengthList: 0,\n  SVGNumberList: 0,\n  SVGPathSegList: 0,\n  SVGPointList: 0,\n  SVGStringList: 0,\n  SVGTransformList: 0,\n  SourceBufferList: 0,\n  StyleSheetList: 0,\n  TextTrackCueList: 0,\n  TextTrackList: 0,\n  TouchList: 0\n};\n\n// in old WebKit versions, `element.classList` is not an instance of global `DOMTokenList`\nvar documentCreateElement = documentCreateElement$2;\n\nvar classList = documentCreateElement('span').classList;\nvar DOMTokenListPrototype$1 = classList && classList.constructor && classList.constructor.prototype;\n\nvar domTokenListPrototype = DOMTokenListPrototype$1 === Object.prototype ? undefined : DOMTokenListPrototype$1;\n\nvar global$9 = global$j;\nvar DOMIterables = domIterables;\nvar DOMTokenListPrototype = domTokenListPrototype;\nvar ArrayIteratorMethods = es_array_iterator;\nvar createNonEnumerableProperty = createNonEnumerableProperty$4;\nvar wellKnownSymbol$8 = wellKnownSymbol$e;\n\nvar ITERATOR$3 = wellKnownSymbol$8('iterator');\nvar TO_STRING_TAG$2 = wellKnownSymbol$8('toStringTag');\nvar ArrayValues = ArrayIteratorMethods.values;\n\nvar handlePrototype = function (CollectionPrototype, COLLECTION_NAME) {\n  if (CollectionPrototype) {\n    // some Chrome versions have non-configurable methods on DOMTokenList\n    if (CollectionPrototype[ITERATOR$3] !== ArrayValues) try {\n      createNonEnumerableProperty(CollectionPrototype, ITERATOR$3, ArrayValues);\n    } catch (error) {\n      CollectionPrototype[ITERATOR$3] = ArrayValues;\n    }\n    if (!CollectionPrototype[TO_STRING_TAG$2]) {\n      createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG$2, COLLECTION_NAME);\n    }\n    if (DOMIterables[COLLECTION_NAME]) for (var METHOD_NAME in ArrayIteratorMethods) {\n      // some Chrome versions have non-configurable methods on DOMTokenList\n      if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {\n        createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);\n      } catch (error) {\n        CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];\n      }\n    }\n  }\n};\n\nfor (var COLLECTION_NAME in DOMIterables) {\n  handlePrototype(global$9[COLLECTION_NAME] && global$9[COLLECTION_NAME].prototype, COLLECTION_NAME);\n}\n\nhandlePrototype(DOMTokenListPrototype, 'DOMTokenList');\n\nvar classof$4 = classofRaw$1;\nvar global$8 = global$j;\n\nvar engineIsNode = classof$4(global$8.process) == 'process';\n\nvar getBuiltIn$3 = getBuiltIn$8;\nvar definePropertyModule = objectDefineProperty;\nvar wellKnownSymbol$7 = wellKnownSymbol$e;\nvar DESCRIPTORS = descriptors;\n\nvar SPECIES$2 = wellKnownSymbol$7('species');\n\nvar setSpecies$1 = function (CONSTRUCTOR_NAME) {\n  var Constructor = getBuiltIn$3(CONSTRUCTOR_NAME);\n  var defineProperty = definePropertyModule.f;\n\n  if (DESCRIPTORS && Constructor && !Constructor[SPECIES$2]) {\n    defineProperty(Constructor, SPECIES$2, {\n      configurable: true,\n      get: function () { return this; }\n    });\n  }\n};\n\nvar isPrototypeOf$2 = objectIsPrototypeOf;\n\nvar $TypeError$4 = TypeError;\n\nvar anInstance$1 = function (it, Prototype) {\n  if (isPrototypeOf$2(Prototype, it)) return it;\n  throw $TypeError$4('Incorrect invocation');\n};\n\nvar wellKnownSymbol$6 = wellKnownSymbol$e;\n\nvar TO_STRING_TAG$1 = wellKnownSymbol$6('toStringTag');\nvar test = {};\n\ntest[TO_STRING_TAG$1] = 'z';\n\nvar toStringTagSupport = String(test) === '[object z]';\n\nvar TO_STRING_TAG_SUPPORT = toStringTagSupport;\nvar isCallable$5 = isCallable$k;\nvar classofRaw = classofRaw$1;\nvar wellKnownSymbol$5 = wellKnownSymbol$e;\n\nvar TO_STRING_TAG = wellKnownSymbol$5('toStringTag');\nvar $Object = Object;\n\n// ES3 wrong here\nvar CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function (it, key) {\n  try {\n    return it[key];\n  } catch (error) { /* empty */ }\n};\n\n// getting tag from ES6+ `Object.prototype.toString`\nvar classof$3 = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {\n  var O, tag, result;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == 'string' ? tag\n    // builtinTag case\n    : CORRECT_ARGUMENTS ? classofRaw(O)\n    // ES3 arguments fallback\n    : (result = classofRaw(O)) == 'Object' && isCallable$5(O.callee) ? 'Arguments' : result;\n};\n\nvar uncurryThis$2 = functionUncurryThis;\nvar fails$2 = fails$d;\nvar isCallable$4 = isCallable$k;\nvar classof$2 = classof$3;\nvar getBuiltIn$2 = getBuiltIn$8;\nvar inspectSource$1 = inspectSource$4;\n\nvar noop = function () { /* empty */ };\nvar empty = [];\nvar construct = getBuiltIn$2('Reflect', 'construct');\nvar constructorRegExp = /^\\s*(?:class|function)\\b/;\nvar exec = uncurryThis$2(constructorRegExp.exec);\nvar INCORRECT_TO_STRING = !constructorRegExp.exec(noop);\n\nvar isConstructorModern = function isConstructor(argument) {\n  if (!isCallable$4(argument)) return false;\n  try {\n    construct(noop, empty, argument);\n    return true;\n  } catch (error) {\n    return false;\n  }\n};\n\nvar isConstructorLegacy = function isConstructor(argument) {\n  if (!isCallable$4(argument)) return false;\n  switch (classof$2(argument)) {\n    case 'AsyncFunction':\n    case 'GeneratorFunction':\n    case 'AsyncGeneratorFunction': return false;\n  }\n  try {\n    // we can't check .prototype since constructors produced by .bind haven't it\n    // `Function#toString` throws on some built-it function in some legacy engines\n    // (for example, `DOMQuad` and similar in FF41-)\n    return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource$1(argument));\n  } catch (error) {\n    return true;\n  }\n};\n\nisConstructorLegacy.sham = true;\n\n// `IsConstructor` abstract operation\n// https://tc39.es/ecma262/#sec-isconstructor\nvar isConstructor$1 = !construct || fails$2(function () {\n  var called;\n  return isConstructorModern(isConstructorModern.call)\n    || !isConstructorModern(Object)\n    || !isConstructorModern(function () { called = true; })\n    || called;\n}) ? isConstructorLegacy : isConstructorModern;\n\nvar isConstructor = isConstructor$1;\nvar tryToString$2 = tryToString$4;\n\nvar $TypeError$3 = TypeError;\n\n// `Assert: IsConstructor(argument) is true`\nvar aConstructor$1 = function (argument) {\n  if (isConstructor(argument)) return argument;\n  throw $TypeError$3(tryToString$2(argument) + ' is not a constructor');\n};\n\nvar anObject$6 = anObject$c;\nvar aConstructor = aConstructor$1;\nvar wellKnownSymbol$4 = wellKnownSymbol$e;\n\nvar SPECIES$1 = wellKnownSymbol$4('species');\n\n// `SpeciesConstructor` abstract operation\n// https://tc39.es/ecma262/#sec-speciesconstructor\nvar speciesConstructor$1 = function (O, defaultConstructor) {\n  var C = anObject$6(O).constructor;\n  var S;\n  return C === undefined || (S = anObject$6(C)[SPECIES$1]) == undefined ? defaultConstructor : aConstructor(S);\n};\n\nvar NATIVE_BIND$1 = functionBindNative;\n\nvar FunctionPrototype = Function.prototype;\nvar apply$1 = FunctionPrototype.apply;\nvar call$8 = FunctionPrototype.call;\n\n// eslint-disable-next-line es-x/no-reflect -- safe\nvar functionApply = typeof Reflect == 'object' && Reflect.apply || (NATIVE_BIND$1 ? call$8.bind(apply$1) : function () {\n  return call$8.apply(apply$1, arguments);\n});\n\nvar uncurryThis$1 = functionUncurryThis;\nvar aCallable$5 = aCallable$7;\nvar NATIVE_BIND = functionBindNative;\n\nvar bind$4 = uncurryThis$1(uncurryThis$1.bind);\n\n// optional / simple context binding\nvar functionBindContext = function (fn, that) {\n  aCallable$5(fn);\n  return that === undefined ? fn : NATIVE_BIND ? bind$4(fn, that) : function (/* ...args */) {\n    return fn.apply(that, arguments);\n  };\n};\n\nvar uncurryThis = functionUncurryThis;\n\nvar arraySlice$1 = uncurryThis([].slice);\n\nvar $TypeError$2 = TypeError;\n\nvar validateArgumentsLength$1 = function (passed, required) {\n  if (passed < required) throw $TypeError$2('Not enough arguments');\n  return passed;\n};\n\nvar userAgent$2 = engineUserAgent;\n\nvar engineIsIos = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent$2);\n\nvar global$7 = global$j;\nvar apply = functionApply;\nvar bind$3 = functionBindContext;\nvar isCallable$3 = isCallable$k;\nvar hasOwn$1 = hasOwnProperty_1;\nvar fails$1 = fails$d;\nvar html = html$2;\nvar arraySlice = arraySlice$1;\nvar createElement = documentCreateElement$2;\nvar validateArgumentsLength = validateArgumentsLength$1;\nvar IS_IOS$1 = engineIsIos;\nvar IS_NODE$2 = engineIsNode;\n\nvar set = global$7.setImmediate;\nvar clear = global$7.clearImmediate;\nvar process$2 = global$7.process;\nvar Dispatch = global$7.Dispatch;\nvar Function$1 = global$7.Function;\nvar MessageChannel = global$7.MessageChannel;\nvar String$1 = global$7.String;\nvar counter = 0;\nvar queue$1 = {};\nvar ONREADYSTATECHANGE = 'onreadystatechange';\nvar location, defer, channel, port;\n\ntry {\n  // Deno throws a ReferenceError on `location` access without `--location` flag\n  location = global$7.location;\n} catch (error) { /* empty */ }\n\nvar run = function (id) {\n  if (hasOwn$1(queue$1, id)) {\n    var fn = queue$1[id];\n    delete queue$1[id];\n    fn();\n  }\n};\n\nvar runner = function (id) {\n  return function () {\n    run(id);\n  };\n};\n\nvar listener = function (event) {\n  run(event.data);\n};\n\nvar post = function (id) {\n  // old engines have not location.origin\n  global$7.postMessage(String$1(id), location.protocol + '//' + location.host);\n};\n\n// Node.js 0.9+ & IE10+ has setImmediate, otherwise:\nif (!set || !clear) {\n  set = function setImmediate(handler) {\n    validateArgumentsLength(arguments.length, 1);\n    var fn = isCallable$3(handler) ? handler : Function$1(handler);\n    var args = arraySlice(arguments, 1);\n    queue$1[++counter] = function () {\n      apply(fn, undefined, args);\n    };\n    defer(counter);\n    return counter;\n  };\n  clear = function clearImmediate(id) {\n    delete queue$1[id];\n  };\n  // Node.js 0.8-\n  if (IS_NODE$2) {\n    defer = function (id) {\n      process$2.nextTick(runner(id));\n    };\n  // Sphere (JS game engine) Dispatch API\n  } else if (Dispatch && Dispatch.now) {\n    defer = function (id) {\n      Dispatch.now(runner(id));\n    };\n  // Browsers with MessageChannel, includes WebWorkers\n  // except iOS - https://github.com/zloirock/core-js/issues/624\n  } else if (MessageChannel && !IS_IOS$1) {\n    channel = new MessageChannel();\n    port = channel.port2;\n    channel.port1.onmessage = listener;\n    defer = bind$3(port.postMessage, port);\n  // Browsers with postMessage, skip WebWorkers\n  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'\n  } else if (\n    global$7.addEventListener &&\n    isCallable$3(global$7.postMessage) &&\n    !global$7.importScripts &&\n    location && location.protocol !== 'file:' &&\n    !fails$1(post)\n  ) {\n    defer = post;\n    global$7.addEventListener('message', listener, false);\n  // IE8-\n  } else if (ONREADYSTATECHANGE in createElement('script')) {\n    defer = function (id) {\n      html.appendChild(createElement('script'))[ONREADYSTATECHANGE] = function () {\n        html.removeChild(this);\n        run(id);\n      };\n    };\n  // Rest old browsers\n  } else {\n    defer = function (id) {\n      setTimeout(runner(id), 0);\n    };\n  }\n}\n\nvar task$1 = {\n  set: set,\n  clear: clear\n};\n\nvar userAgent$1 = engineUserAgent;\nvar global$6 = global$j;\n\nvar engineIsIosPebble = /ipad|iphone|ipod/i.test(userAgent$1) && global$6.Pebble !== undefined;\n\nvar userAgent = engineUserAgent;\n\nvar engineIsWebosWebkit = /web0s(?!.*chrome)/i.test(userAgent);\n\nvar global$5 = global$j;\nvar bind$2 = functionBindContext;\nvar getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;\nvar macrotask = task$1.set;\nvar IS_IOS = engineIsIos;\nvar IS_IOS_PEBBLE = engineIsIosPebble;\nvar IS_WEBOS_WEBKIT = engineIsWebosWebkit;\nvar IS_NODE$1 = engineIsNode;\n\nvar MutationObserver = global$5.MutationObserver || global$5.WebKitMutationObserver;\nvar document$2 = global$5.document;\nvar process$1 = global$5.process;\nvar Promise$1 = global$5.Promise;\n// Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`\nvar queueMicrotaskDescriptor = getOwnPropertyDescriptor(global$5, 'queueMicrotask');\nvar queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;\n\nvar flush, head, last, notify$1, toggle, node, promise, then;\n\n// modern engines have queueMicrotask method\nif (!queueMicrotask) {\n  flush = function () {\n    var parent, fn;\n    if (IS_NODE$1 && (parent = process$1.domain)) parent.exit();\n    while (head) {\n      fn = head.fn;\n      head = head.next;\n      try {\n        fn();\n      } catch (error) {\n        if (head) notify$1();\n        else last = undefined;\n        throw error;\n      }\n    } last = undefined;\n    if (parent) parent.enter();\n  };\n\n  // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339\n  // also except WebOS Webkit https://github.com/zloirock/core-js/issues/898\n  if (!IS_IOS && !IS_NODE$1 && !IS_WEBOS_WEBKIT && MutationObserver && document$2) {\n    toggle = true;\n    node = document$2.createTextNode('');\n    new MutationObserver(flush).observe(node, { characterData: true });\n    notify$1 = function () {\n      node.data = toggle = !toggle;\n    };\n  // environments with maybe non-completely correct, but existent Promise\n  } else if (!IS_IOS_PEBBLE && Promise$1 && Promise$1.resolve) {\n    // Promise.resolve without an argument throws an error in LG WebOS 2\n    promise = Promise$1.resolve(undefined);\n    // workaround of WebKit ~ iOS Safari 10.1 bug\n    promise.constructor = Promise$1;\n    then = bind$2(promise.then, promise);\n    notify$1 = function () {\n      then(flush);\n    };\n  // Node.js without promises\n  } else if (IS_NODE$1) {\n    notify$1 = function () {\n      process$1.nextTick(flush);\n    };\n  // for other environments - macrotask based on:\n  // - setImmediate\n  // - MessageChannel\n  // - window.postMessage\n  // - onreadystatechange\n  // - setTimeout\n  } else {\n    // strange IE + webpack dev server bug - use .bind(global)\n    macrotask = bind$2(macrotask, global$5);\n    notify$1 = function () {\n      macrotask(flush);\n    };\n  }\n}\n\nvar microtask$1 = queueMicrotask || function (fn) {\n  var task = { fn: fn, next: undefined };\n  if (last) last.next = task;\n  if (!head) {\n    head = task;\n    notify$1();\n  } last = task;\n};\n\nvar global$4 = global$j;\n\nvar hostReportErrors$1 = function (a, b) {\n  var console = global$4.console;\n  if (console && console.error) {\n    arguments.length == 1 ? console.error(a) : console.error(a, b);\n  }\n};\n\nvar perform$3 = function (exec) {\n  try {\n    return { error: false, value: exec() };\n  } catch (error) {\n    return { error: true, value: error };\n  }\n};\n\nvar Queue$1 = function () {\n  this.head = null;\n  this.tail = null;\n};\n\nQueue$1.prototype = {\n  add: function (item) {\n    var entry = { item: item, next: null };\n    if (this.head) this.tail.next = entry;\n    else this.head = entry;\n    this.tail = entry;\n  },\n  get: function () {\n    var entry = this.head;\n    if (entry) {\n      this.head = entry.next;\n      if (this.tail === entry) this.tail = null;\n      return entry.item;\n    }\n  }\n};\n\nvar queue = Queue$1;\n\nvar global$3 = global$j;\n\nvar promiseNativeConstructor = global$3.Promise;\n\nvar engineIsBrowser = typeof window == 'object' && typeof Deno != 'object';\n\nvar global$2 = global$j;\nvar NativePromiseConstructor$3 = promiseNativeConstructor;\nvar isCallable$2 = isCallable$k;\nvar isForced = isForced_1;\nvar inspectSource = inspectSource$4;\nvar wellKnownSymbol$3 = wellKnownSymbol$e;\nvar IS_BROWSER = engineIsBrowser;\nvar V8_VERSION = engineV8Version;\n\nNativePromiseConstructor$3 && NativePromiseConstructor$3.prototype;\nvar SPECIES = wellKnownSymbol$3('species');\nvar SUBCLASSING = false;\nvar NATIVE_PROMISE_REJECTION_EVENT$1 = isCallable$2(global$2.PromiseRejectionEvent);\n\nvar FORCED_PROMISE_CONSTRUCTOR$5 = isForced('Promise', function () {\n  var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(NativePromiseConstructor$3);\n  var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(NativePromiseConstructor$3);\n  // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=830565\n  // We can't detect it synchronously, so just check versions\n  if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66) return true;\n  // We can't use @@species feature detection in V8 since it causes\n  // deoptimization and performance degradation\n  // https://github.com/zloirock/core-js/issues/679\n  if (V8_VERSION >= 51 && /native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) return false;\n  // Detect correctness of subclassing with @@species support\n  var promise = new NativePromiseConstructor$3(function (resolve) { resolve(1); });\n  var FakePromise = function (exec) {\n    exec(function () { /* empty */ }, function () { /* empty */ });\n  };\n  var constructor = promise.constructor = {};\n  constructor[SPECIES] = FakePromise;\n  SUBCLASSING = promise.then(function () { /* empty */ }) instanceof FakePromise;\n  if (!SUBCLASSING) return true;\n  // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test\n  return !GLOBAL_CORE_JS_PROMISE && IS_BROWSER && !NATIVE_PROMISE_REJECTION_EVENT$1;\n});\n\nvar promiseConstructorDetection = {\n  CONSTRUCTOR: FORCED_PROMISE_CONSTRUCTOR$5,\n  REJECTION_EVENT: NATIVE_PROMISE_REJECTION_EVENT$1,\n  SUBCLASSING: SUBCLASSING\n};\n\nvar newPromiseCapability$2 = {};\n\nvar aCallable$4 = aCallable$7;\n\nvar PromiseCapability = function (C) {\n  var resolve, reject;\n  this.promise = new C(function ($$resolve, $$reject) {\n    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');\n    resolve = $$resolve;\n    reject = $$reject;\n  });\n  this.resolve = aCallable$4(resolve);\n  this.reject = aCallable$4(reject);\n};\n\n// `NewPromiseCapability` abstract operation\n// https://tc39.es/ecma262/#sec-newpromisecapability\nnewPromiseCapability$2.f = function (C) {\n  return new PromiseCapability(C);\n};\n\nvar $$5 = _export;\nvar IS_NODE = engineIsNode;\nvar global$1 = global$j;\nvar call$7 = functionCall;\nvar defineBuiltIn$2 = defineBuiltIn$6;\nvar setPrototypeOf = objectSetPrototypeOf;\nvar setToStringTag = setToStringTag$3;\nvar setSpecies = setSpecies$1;\nvar aCallable$3 = aCallable$7;\nvar isCallable$1 = isCallable$k;\nvar isObject$1 = isObject$7;\nvar anInstance = anInstance$1;\nvar speciesConstructor = speciesConstructor$1;\nvar task = task$1.set;\nvar microtask = microtask$1;\nvar hostReportErrors = hostReportErrors$1;\nvar perform$2 = perform$3;\nvar Queue = queue;\nvar InternalStateModule = internalState;\nvar NativePromiseConstructor$2 = promiseNativeConstructor;\nvar PromiseConstructorDetection = promiseConstructorDetection;\nvar newPromiseCapabilityModule$3 = newPromiseCapability$2;\n\nvar PROMISE = 'Promise';\nvar FORCED_PROMISE_CONSTRUCTOR$4 = PromiseConstructorDetection.CONSTRUCTOR;\nvar NATIVE_PROMISE_REJECTION_EVENT = PromiseConstructorDetection.REJECTION_EVENT;\nvar NATIVE_PROMISE_SUBCLASSING = PromiseConstructorDetection.SUBCLASSING;\nvar getInternalPromiseState = InternalStateModule.getterFor(PROMISE);\nvar setInternalState = InternalStateModule.set;\nvar NativePromisePrototype$1 = NativePromiseConstructor$2 && NativePromiseConstructor$2.prototype;\nvar PromiseConstructor = NativePromiseConstructor$2;\nvar PromisePrototype = NativePromisePrototype$1;\nvar TypeError$1 = global$1.TypeError;\nvar document$1 = global$1.document;\nvar process = global$1.process;\nvar newPromiseCapability$1 = newPromiseCapabilityModule$3.f;\nvar newGenericPromiseCapability = newPromiseCapability$1;\n\nvar DISPATCH_EVENT = !!(document$1 && document$1.createEvent && global$1.dispatchEvent);\nvar UNHANDLED_REJECTION = 'unhandledrejection';\nvar REJECTION_HANDLED = 'rejectionhandled';\nvar PENDING = 0;\nvar FULFILLED = 1;\nvar REJECTED = 2;\nvar HANDLED = 1;\nvar UNHANDLED = 2;\n\nvar Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;\n\n// helpers\nvar isThenable = function (it) {\n  var then;\n  return isObject$1(it) && isCallable$1(then = it.then) ? then : false;\n};\n\nvar callReaction = function (reaction, state) {\n  var value = state.value;\n  var ok = state.state == FULFILLED;\n  var handler = ok ? reaction.ok : reaction.fail;\n  var resolve = reaction.resolve;\n  var reject = reaction.reject;\n  var domain = reaction.domain;\n  var result, then, exited;\n  try {\n    if (handler) {\n      if (!ok) {\n        if (state.rejection === UNHANDLED) onHandleUnhandled(state);\n        state.rejection = HANDLED;\n      }\n      if (handler === true) result = value;\n      else {\n        if (domain) domain.enter();\n        result = handler(value); // can throw\n        if (domain) {\n          domain.exit();\n          exited = true;\n        }\n      }\n      if (result === reaction.promise) {\n        reject(TypeError$1('Promise-chain cycle'));\n      } else if (then = isThenable(result)) {\n        call$7(then, result, resolve, reject);\n      } else resolve(result);\n    } else reject(value);\n  } catch (error) {\n    if (domain && !exited) domain.exit();\n    reject(error);\n  }\n};\n\nvar notify = function (state, isReject) {\n  if (state.notified) return;\n  state.notified = true;\n  microtask(function () {\n    var reactions = state.reactions;\n    var reaction;\n    while (reaction = reactions.get()) {\n      callReaction(reaction, state);\n    }\n    state.notified = false;\n    if (isReject && !state.rejection) onUnhandled(state);\n  });\n};\n\nvar dispatchEvent = function (name, promise, reason) {\n  var event, handler;\n  if (DISPATCH_EVENT) {\n    event = document$1.createEvent('Event');\n    event.promise = promise;\n    event.reason = reason;\n    event.initEvent(name, false, true);\n    global$1.dispatchEvent(event);\n  } else event = { promise: promise, reason: reason };\n  if (!NATIVE_PROMISE_REJECTION_EVENT && (handler = global$1['on' + name])) handler(event);\n  else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);\n};\n\nvar onUnhandled = function (state) {\n  call$7(task, global$1, function () {\n    var promise = state.facade;\n    var value = state.value;\n    var IS_UNHANDLED = isUnhandled(state);\n    var result;\n    if (IS_UNHANDLED) {\n      result = perform$2(function () {\n        if (IS_NODE) {\n          process.emit('unhandledRejection', value, promise);\n        } else dispatchEvent(UNHANDLED_REJECTION, promise, value);\n      });\n      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should\n      state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;\n      if (result.error) throw result.value;\n    }\n  });\n};\n\nvar isUnhandled = function (state) {\n  return state.rejection !== HANDLED && !state.parent;\n};\n\nvar onHandleUnhandled = function (state) {\n  call$7(task, global$1, function () {\n    var promise = state.facade;\n    if (IS_NODE) {\n      process.emit('rejectionHandled', promise);\n    } else dispatchEvent(REJECTION_HANDLED, promise, state.value);\n  });\n};\n\nvar bind$1 = function (fn, state, unwrap) {\n  return function (value) {\n    fn(state, value, unwrap);\n  };\n};\n\nvar internalReject = function (state, value, unwrap) {\n  if (state.done) return;\n  state.done = true;\n  if (unwrap) state = unwrap;\n  state.value = value;\n  state.state = REJECTED;\n  notify(state, true);\n};\n\nvar internalResolve = function (state, value, unwrap) {\n  if (state.done) return;\n  state.done = true;\n  if (unwrap) state = unwrap;\n  try {\n    if (state.facade === value) throw TypeError$1(\"Promise can't be resolved itself\");\n    var then = isThenable(value);\n    if (then) {\n      microtask(function () {\n        var wrapper = { done: false };\n        try {\n          call$7(then, value,\n            bind$1(internalResolve, wrapper, state),\n            bind$1(internalReject, wrapper, state)\n          );\n        } catch (error) {\n          internalReject(wrapper, error, state);\n        }\n      });\n    } else {\n      state.value = value;\n      state.state = FULFILLED;\n      notify(state, false);\n    }\n  } catch (error) {\n    internalReject({ done: false }, error, state);\n  }\n};\n\n// constructor polyfill\nif (FORCED_PROMISE_CONSTRUCTOR$4) {\n  // 25.4.3.1 Promise(executor)\n  PromiseConstructor = function Promise(executor) {\n    anInstance(this, PromisePrototype);\n    aCallable$3(executor);\n    call$7(Internal, this);\n    var state = getInternalPromiseState(this);\n    try {\n      executor(bind$1(internalResolve, state), bind$1(internalReject, state));\n    } catch (error) {\n      internalReject(state, error);\n    }\n  };\n\n  PromisePrototype = PromiseConstructor.prototype;\n\n  // eslint-disable-next-line no-unused-vars -- required for `.length`\n  Internal = function Promise(executor) {\n    setInternalState(this, {\n      type: PROMISE,\n      done: false,\n      notified: false,\n      parent: false,\n      reactions: new Queue(),\n      rejection: false,\n      state: PENDING,\n      value: undefined\n    });\n  };\n\n  // `Promise.prototype.then` method\n  // https://tc39.es/ecma262/#sec-promise.prototype.then\n  Internal.prototype = defineBuiltIn$2(PromisePrototype, 'then', function then(onFulfilled, onRejected) {\n    var state = getInternalPromiseState(this);\n    var reaction = newPromiseCapability$1(speciesConstructor(this, PromiseConstructor));\n    state.parent = true;\n    reaction.ok = isCallable$1(onFulfilled) ? onFulfilled : true;\n    reaction.fail = isCallable$1(onRejected) && onRejected;\n    reaction.domain = IS_NODE ? process.domain : undefined;\n    if (state.state == PENDING) state.reactions.add(reaction);\n    else microtask(function () {\n      callReaction(reaction, state);\n    });\n    return reaction.promise;\n  });\n\n  OwnPromiseCapability = function () {\n    var promise = new Internal();\n    var state = getInternalPromiseState(promise);\n    this.promise = promise;\n    this.resolve = bind$1(internalResolve, state);\n    this.reject = bind$1(internalReject, state);\n  };\n\n  newPromiseCapabilityModule$3.f = newPromiseCapability$1 = function (C) {\n    return C === PromiseConstructor || C === PromiseWrapper\n      ? new OwnPromiseCapability(C)\n      : newGenericPromiseCapability(C);\n  };\n\n  if (isCallable$1(NativePromiseConstructor$2) && NativePromisePrototype$1 !== Object.prototype) {\n    nativeThen = NativePromisePrototype$1.then;\n\n    if (!NATIVE_PROMISE_SUBCLASSING) {\n      // make `Promise#then` return a polyfilled `Promise` for native promise-based APIs\n      defineBuiltIn$2(NativePromisePrototype$1, 'then', function then(onFulfilled, onRejected) {\n        var that = this;\n        return new PromiseConstructor(function (resolve, reject) {\n          call$7(nativeThen, that, resolve, reject);\n        }).then(onFulfilled, onRejected);\n      // https://github.com/zloirock/core-js/issues/640\n      }, { unsafe: true });\n    }\n\n    // make `.constructor === Promise` work for native promise-based APIs\n    try {\n      delete NativePromisePrototype$1.constructor;\n    } catch (error) { /* empty */ }\n\n    // make `instanceof Promise` work for native promise-based APIs\n    if (setPrototypeOf) {\n      setPrototypeOf(NativePromisePrototype$1, PromisePrototype);\n    }\n  }\n}\n\n$$5({ global: true, constructor: true, wrap: true, forced: FORCED_PROMISE_CONSTRUCTOR$4 }, {\n  Promise: PromiseConstructor\n});\n\nsetToStringTag(PromiseConstructor, PROMISE, false);\nsetSpecies(PROMISE);\n\nvar wellKnownSymbol$2 = wellKnownSymbol$e;\nvar Iterators$1 = iterators;\n\nvar ITERATOR$2 = wellKnownSymbol$2('iterator');\nvar ArrayPrototype = Array.prototype;\n\n// check on default Array iterator\nvar isArrayIteratorMethod$1 = function (it) {\n  return it !== undefined && (Iterators$1.Array === it || ArrayPrototype[ITERATOR$2] === it);\n};\n\nvar classof$1 = classof$3;\nvar getMethod$1 = getMethod$3;\nvar Iterators = iterators;\nvar wellKnownSymbol$1 = wellKnownSymbol$e;\n\nvar ITERATOR$1 = wellKnownSymbol$1('iterator');\n\nvar getIteratorMethod$2 = function (it) {\n  if (it != undefined) return getMethod$1(it, ITERATOR$1)\n    || getMethod$1(it, '@@iterator')\n    || Iterators[classof$1(it)];\n};\n\nvar call$6 = functionCall;\nvar aCallable$2 = aCallable$7;\nvar anObject$5 = anObject$c;\nvar tryToString$1 = tryToString$4;\nvar getIteratorMethod$1 = getIteratorMethod$2;\n\nvar $TypeError$1 = TypeError;\n\nvar getIterator$1 = function (argument, usingIterator) {\n  var iteratorMethod = arguments.length < 2 ? getIteratorMethod$1(argument) : usingIterator;\n  if (aCallable$2(iteratorMethod)) return anObject$5(call$6(iteratorMethod, argument));\n  throw $TypeError$1(tryToString$1(argument) + ' is not iterable');\n};\n\nvar call$5 = functionCall;\nvar anObject$4 = anObject$c;\nvar getMethod = getMethod$3;\n\nvar iteratorClose$1 = function (iterator, kind, value) {\n  var innerResult, innerError;\n  anObject$4(iterator);\n  try {\n    innerResult = getMethod(iterator, 'return');\n    if (!innerResult) {\n      if (kind === 'throw') throw value;\n      return value;\n    }\n    innerResult = call$5(innerResult, iterator);\n  } catch (error) {\n    innerError = true;\n    innerResult = error;\n  }\n  if (kind === 'throw') throw value;\n  if (innerError) throw innerResult;\n  anObject$4(innerResult);\n  return value;\n};\n\nvar bind = functionBindContext;\nvar call$4 = functionCall;\nvar anObject$3 = anObject$c;\nvar tryToString = tryToString$4;\nvar isArrayIteratorMethod = isArrayIteratorMethod$1;\nvar lengthOfArrayLike = lengthOfArrayLike$2;\nvar isPrototypeOf$1 = objectIsPrototypeOf;\nvar getIterator = getIterator$1;\nvar getIteratorMethod = getIteratorMethod$2;\nvar iteratorClose = iteratorClose$1;\n\nvar $TypeError = TypeError;\n\nvar Result = function (stopped, result) {\n  this.stopped = stopped;\n  this.result = result;\n};\n\nvar ResultPrototype = Result.prototype;\n\nvar iterate$2 = function (iterable, unboundFunction, options) {\n  var that = options && options.that;\n  var AS_ENTRIES = !!(options && options.AS_ENTRIES);\n  var IS_ITERATOR = !!(options && options.IS_ITERATOR);\n  var INTERRUPTED = !!(options && options.INTERRUPTED);\n  var fn = bind(unboundFunction, that);\n  var iterator, iterFn, index, length, result, next, step;\n\n  var stop = function (condition) {\n    if (iterator) iteratorClose(iterator, 'normal', condition);\n    return new Result(true, condition);\n  };\n\n  var callFn = function (value) {\n    if (AS_ENTRIES) {\n      anObject$3(value);\n      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);\n    } return INTERRUPTED ? fn(value, stop) : fn(value);\n  };\n\n  if (IS_ITERATOR) {\n    iterator = iterable;\n  } else {\n    iterFn = getIteratorMethod(iterable);\n    if (!iterFn) throw $TypeError(tryToString(iterable) + ' is not iterable');\n    // optimisation for array iterators\n    if (isArrayIteratorMethod(iterFn)) {\n      for (index = 0, length = lengthOfArrayLike(iterable); length > index; index++) {\n        result = callFn(iterable[index]);\n        if (result && isPrototypeOf$1(ResultPrototype, result)) return result;\n      } return new Result(false);\n    }\n    iterator = getIterator(iterable, iterFn);\n  }\n\n  next = iterator.next;\n  while (!(step = call$4(next, iterator)).done) {\n    try {\n      result = callFn(step.value);\n    } catch (error) {\n      iteratorClose(iterator, 'throw', error);\n    }\n    if (typeof result == 'object' && result && isPrototypeOf$1(ResultPrototype, result)) return result;\n  } return new Result(false);\n};\n\nvar wellKnownSymbol = wellKnownSymbol$e;\n\nvar ITERATOR = wellKnownSymbol('iterator');\nvar SAFE_CLOSING = false;\n\ntry {\n  var called = 0;\n  var iteratorWithReturn = {\n    next: function () {\n      return { done: !!called++ };\n    },\n    'return': function () {\n      SAFE_CLOSING = true;\n    }\n  };\n  iteratorWithReturn[ITERATOR] = function () {\n    return this;\n  };\n  // eslint-disable-next-line es-x/no-array-from, no-throw-literal -- required for testing\n  Array.from(iteratorWithReturn, function () { throw 2; });\n} catch (error) { /* empty */ }\n\nvar checkCorrectnessOfIteration$1 = function (exec, SKIP_CLOSING) {\n  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;\n  var ITERATION_SUPPORT = false;\n  try {\n    var object = {};\n    object[ITERATOR] = function () {\n      return {\n        next: function () {\n          return { done: ITERATION_SUPPORT = true };\n        }\n      };\n    };\n    exec(object);\n  } catch (error) { /* empty */ }\n  return ITERATION_SUPPORT;\n};\n\nvar NativePromiseConstructor$1 = promiseNativeConstructor;\nvar checkCorrectnessOfIteration = checkCorrectnessOfIteration$1;\nvar FORCED_PROMISE_CONSTRUCTOR$3 = promiseConstructorDetection.CONSTRUCTOR;\n\nvar promiseStaticsIncorrectIteration = FORCED_PROMISE_CONSTRUCTOR$3 || !checkCorrectnessOfIteration(function (iterable) {\n  NativePromiseConstructor$1.all(iterable).then(undefined, function () { /* empty */ });\n});\n\nvar $$4 = _export;\nvar call$3 = functionCall;\nvar aCallable$1 = aCallable$7;\nvar newPromiseCapabilityModule$2 = newPromiseCapability$2;\nvar perform$1 = perform$3;\nvar iterate$1 = iterate$2;\nvar PROMISE_STATICS_INCORRECT_ITERATION$1 = promiseStaticsIncorrectIteration;\n\n// `Promise.all` method\n// https://tc39.es/ecma262/#sec-promise.all\n$$4({ target: 'Promise', stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION$1 }, {\n  all: function all(iterable) {\n    var C = this;\n    var capability = newPromiseCapabilityModule$2.f(C);\n    var resolve = capability.resolve;\n    var reject = capability.reject;\n    var result = perform$1(function () {\n      var $promiseResolve = aCallable$1(C.resolve);\n      var values = [];\n      var counter = 0;\n      var remaining = 1;\n      iterate$1(iterable, function (promise) {\n        var index = counter++;\n        var alreadyCalled = false;\n        remaining++;\n        call$3($promiseResolve, C, promise).then(function (value) {\n          if (alreadyCalled) return;\n          alreadyCalled = true;\n          values[index] = value;\n          --remaining || resolve(values);\n        }, reject);\n      });\n      --remaining || resolve(values);\n    });\n    if (result.error) reject(result.value);\n    return capability.promise;\n  }\n});\n\nvar $$3 = _export;\nvar FORCED_PROMISE_CONSTRUCTOR$2 = promiseConstructorDetection.CONSTRUCTOR;\nvar NativePromiseConstructor = promiseNativeConstructor;\nvar getBuiltIn$1 = getBuiltIn$8;\nvar isCallable = isCallable$k;\nvar defineBuiltIn$1 = defineBuiltIn$6;\n\nvar NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;\n\n// `Promise.prototype.catch` method\n// https://tc39.es/ecma262/#sec-promise.prototype.catch\n$$3({ target: 'Promise', proto: true, forced: FORCED_PROMISE_CONSTRUCTOR$2, real: true }, {\n  'catch': function (onRejected) {\n    return this.then(undefined, onRejected);\n  }\n});\n\n// makes sure that native promise-based APIs `Promise#catch` properly works with patched `Promise#then`\nif (isCallable(NativePromiseConstructor)) {\n  var method = getBuiltIn$1('Promise').prototype['catch'];\n  if (NativePromisePrototype['catch'] !== method) {\n    defineBuiltIn$1(NativePromisePrototype, 'catch', method, { unsafe: true });\n  }\n}\n\nvar $$2 = _export;\nvar call$2 = functionCall;\nvar aCallable = aCallable$7;\nvar newPromiseCapabilityModule$1 = newPromiseCapability$2;\nvar perform = perform$3;\nvar iterate = iterate$2;\nvar PROMISE_STATICS_INCORRECT_ITERATION = promiseStaticsIncorrectIteration;\n\n// `Promise.race` method\n// https://tc39.es/ecma262/#sec-promise.race\n$$2({ target: 'Promise', stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {\n  race: function race(iterable) {\n    var C = this;\n    var capability = newPromiseCapabilityModule$1.f(C);\n    var reject = capability.reject;\n    var result = perform(function () {\n      var $promiseResolve = aCallable(C.resolve);\n      iterate(iterable, function (promise) {\n        call$2($promiseResolve, C, promise).then(capability.resolve, reject);\n      });\n    });\n    if (result.error) reject(result.value);\n    return capability.promise;\n  }\n});\n\nvar $$1 = _export;\nvar call$1 = functionCall;\nvar newPromiseCapabilityModule = newPromiseCapability$2;\nvar FORCED_PROMISE_CONSTRUCTOR$1 = promiseConstructorDetection.CONSTRUCTOR;\n\n// `Promise.reject` method\n// https://tc39.es/ecma262/#sec-promise.reject\n$$1({ target: 'Promise', stat: true, forced: FORCED_PROMISE_CONSTRUCTOR$1 }, {\n  reject: function reject(r) {\n    var capability = newPromiseCapabilityModule.f(this);\n    call$1(capability.reject, undefined, r);\n    return capability.promise;\n  }\n});\n\nvar anObject$2 = anObject$c;\nvar isObject = isObject$7;\nvar newPromiseCapability = newPromiseCapability$2;\n\nvar promiseResolve$1 = function (C, x) {\n  anObject$2(C);\n  if (isObject(x) && x.constructor === C) return x;\n  var promiseCapability = newPromiseCapability.f(C);\n  var resolve = promiseCapability.resolve;\n  resolve(x);\n  return promiseCapability.promise;\n};\n\nvar $ = _export;\nvar getBuiltIn = getBuiltIn$8;\nvar FORCED_PROMISE_CONSTRUCTOR = promiseConstructorDetection.CONSTRUCTOR;\nvar promiseResolve = promiseResolve$1;\n\ngetBuiltIn('Promise');\n\n// `Promise.resolve` method\n// https://tc39.es/ecma262/#sec-promise.resolve\n$({ target: 'Promise', stat: true, forced: FORCED_PROMISE_CONSTRUCTOR }, {\n  resolve: function resolve(x) {\n    return promiseResolve(this, x);\n  }\n});\n\nvar classof = classof$3;\n\nvar $String = String;\n\nvar toString = function (argument) {\n  if (classof(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');\n  return $String(argument);\n};\n\nvar anObject$1 = anObject$c;\n\n// `RegExp.prototype.flags` getter implementation\n// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags\nvar regexpFlags = function () {\n  var that = anObject$1(this);\n  var result = '';\n  if (that.hasIndices) result += 'd';\n  if (that.global) result += 'g';\n  if (that.ignoreCase) result += 'i';\n  if (that.multiline) result += 'm';\n  if (that.dotAll) result += 's';\n  if (that.unicode) result += 'u';\n  if (that.unicodeSets) result += 'v';\n  if (that.sticky) result += 'y';\n  return result;\n};\n\nvar call = functionCall;\nvar hasOwn = hasOwnProperty_1;\nvar isPrototypeOf = objectIsPrototypeOf;\nvar regExpFlags = regexpFlags;\n\nvar RegExpPrototype$1 = RegExp.prototype;\n\nvar regexpGetFlags = function (R) {\n  var flags = R.flags;\n  return flags === undefined && !('flags' in RegExpPrototype$1) && !hasOwn(R, 'flags') && isPrototypeOf(RegExpPrototype$1, R)\n    ? call(regExpFlags, R) : flags;\n};\n\nvar PROPER_FUNCTION_NAME = functionName.PROPER;\nvar defineBuiltIn = defineBuiltIn$6;\nvar anObject = anObject$c;\nvar $toString = toString;\nvar fails = fails$d;\nvar getRegExpFlags = regexpGetFlags;\n\nvar TO_STRING = 'toString';\nvar RegExpPrototype = RegExp.prototype;\nvar n$ToString = RegExpPrototype[TO_STRING];\n\nvar NOT_GENERIC = fails(function () { return n$ToString.call({ source: 'a', flags: 'b' }) != '/a/b'; });\n// FF44- RegExp#toString has a wrong name\nvar INCORRECT_NAME = PROPER_FUNCTION_NAME && n$ToString.name != TO_STRING;\n\n// `RegExp.prototype.toString` method\n// https://tc39.es/ecma262/#sec-regexp.prototype.tostring\nif (NOT_GENERIC || INCORRECT_NAME) {\n  defineBuiltIn(RegExp.prototype, TO_STRING, function toString() {\n    var R = anObject(this);\n    var pattern = $toString(R.source);\n    var flags = $toString(getRegExpFlags(R));\n    return '/' + pattern + '/' + flags;\n  }, { unsafe: true });\n}\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\n\nconst signTransactions = (transactions, signer, network) => __awaiter(void 0, void 0, void 0, function* () {\n  const provider = new nearAPI__namespace.providers.JsonRpcProvider({\n    url: network.nodeUrl\n  });\n  const signedTransactions = [];\n  for (let i = 0; i < transactions.length; i++) {\n    const publicKey = yield signer.getPublicKey(transactions[i].signerId, network.networkId);\n    const [block, accessKey] = yield Promise.all([provider.block({\n      finality: \"final\"\n    }), provider.query({\n      request_type: \"view_access_key\",\n      finality: \"final\",\n      account_id: transactions[i].signerId,\n      public_key: publicKey.toString()\n    })]);\n    const actions = transactions[i].actions.map(action => createAction(action));\n    const transaction = nearAPI__namespace.transactions.createTransaction(transactions[i].signerId, nearAPI__namespace.utils.PublicKey.from(publicKey.toString()), transactions[i].receiverId, accessKey.nonce + i + 1, actions, nearAPI__namespace.utils.serialize.base_decode(block.header.hash));\n    const response = yield nearAPI__namespace.transactions.signTransaction(transaction, signer, transactions[i].signerId, network.networkId);\n    signedTransactions.push(response[1]);\n  }\n  return signedTransactions;\n});\n\nexports.createAction = createAction;\nexports.signTransactions = signTransactions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5lYXItd2FsbGV0LXNlbGVjdG9yL3dhbGxldC11dGlscy9pbmRleC5janMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDLEVBQUUsYUFBYSxFQUFDOztBQUU3RCxZQUFZLG1CQUFPLENBQUMsbURBQU87QUFDM0IsY0FBYyxtQkFBTyxDQUFDLGtFQUFhOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixhQUFhO0FBQ3pDO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsaUNBQWlDO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGNBQWM7O0FBRS9CLGdCQUFnQjs7QUFFaEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDLGtEQUFrRDtBQUN4RixJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1FQUFtRTs7QUFFbkU7O0FBRUE7O0FBRUE7QUFDQSx5RUFBeUU7QUFDekUsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsT0FBTyxtQkFBbUIsYUFBYTtBQUN4RSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsYUFBYTtBQUMxRDtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0gsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMENBQTBDOztBQUUxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnQkFBZ0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGO0FBQ2xGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFdBQVcsZ0JBQWdCO0FBQ2pDO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnQkFBZ0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFD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O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRSxnQkFBZ0I7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELHFCQUFxQjtBQUNyRTtBQUNB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QTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esa0JBQWtCLHlCQUF5QjtBQUMzQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxvQkFBb0I7QUFDcEIsd0JBQXdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbnVyc2VibG9jLy4vbm9kZV9tb2R1bGVzL0BuZWFyLXdhbGxldC1zZWxlY3Rvci93YWxsZXQtdXRpbHMvaW5kZXguY2pzPzFhNWQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgYm5fanMgPSByZXF1aXJlKCdibi5qcycpO1xudmFyIG5lYXJBUEkgPSByZXF1aXJlKCduZWFyLWFwaS1qcycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcE5hbWVzcGFjZShlKSB7XG4gIGlmIChlICYmIGUuX19lc01vZHVsZSkgcmV0dXJuIGU7XG4gIHZhciBuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaWYgKGUpIHtcbiAgICBPYmplY3Qua2V5cyhlKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICBpZiAoayAhPT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgIHZhciBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBrKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIGssIGQuZ2V0ID8gZCA6IHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZVtrXTsgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBuW1wiZGVmYXVsdFwiXSA9IGU7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKG4pO1xufVxuXG52YXIgbmVhckFQSV9fbmFtZXNwYWNlID0gLyojX19QVVJFX18qL19pbnRlcm9wTmFtZXNwYWNlKG5lYXJBUEkpO1xuXG5jb25zdCB7XG4gIHRyYW5zYWN0aW9ucyxcbiAgdXRpbHNcbn0gPSBuZWFyQVBJX19uYW1lc3BhY2U7XG5jb25zdCBnZXRBY2Nlc3NLZXkgPSBwZXJtaXNzaW9uID0+IHtcbiAgaWYgKHBlcm1pc3Npb24gPT09IFwiRnVsbEFjY2Vzc1wiKSB7XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9ucy5mdWxsQWNjZXNzS2V5KCk7XG4gIH1cbiAgY29uc3Qge1xuICAgIHJlY2VpdmVySWQsXG4gICAgbWV0aG9kTmFtZXMgPSBbXVxuICB9ID0gcGVybWlzc2lvbjtcbiAgY29uc3QgYWxsb3dhbmNlID0gcGVybWlzc2lvbi5hbGxvd2FuY2UgPyBuZXcgYm5fanMuQk4ocGVybWlzc2lvbi5hbGxvd2FuY2UpIDogdW5kZWZpbmVkO1xuICByZXR1cm4gdHJhbnNhY3Rpb25zLmZ1bmN0aW9uQ2FsbEFjY2Vzc0tleShyZWNlaXZlcklkLCBtZXRob2ROYW1lcywgYWxsb3dhbmNlKTtcbn07XG5jb25zdCBjcmVhdGVBY3Rpb24gPSBhY3Rpb24gPT4ge1xuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSBcIkNyZWF0ZUFjY291bnRcIjpcbiAgICAgIHJldHVybiB0cmFuc2FjdGlvbnMuY3JlYXRlQWNjb3VudCgpO1xuICAgIGNhc2UgXCJEZXBsb3lDb250cmFjdFwiOlxuICAgICAge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgY29kZVxuICAgICAgICB9ID0gYWN0aW9uLnBhcmFtcztcbiAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9ucy5kZXBsb3lDb250cmFjdChjb2RlKTtcbiAgICAgIH1cbiAgICBjYXNlIFwiRnVuY3Rpb25DYWxsXCI6XG4gICAgICB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBtZXRob2ROYW1lLFxuICAgICAgICAgIGFyZ3MsXG4gICAgICAgICAgZ2FzLFxuICAgICAgICAgIGRlcG9zaXRcbiAgICAgICAgfSA9IGFjdGlvbi5wYXJhbXM7XG4gICAgICAgIHJldHVybiB0cmFuc2FjdGlvbnMuZnVuY3Rpb25DYWxsKG1ldGhvZE5hbWUsIGFyZ3MsIG5ldyBibl9qcy5CTihnYXMpLCBuZXcgYm5fanMuQk4oZGVwb3NpdCkpO1xuICAgICAgfVxuICAgIGNhc2UgXCJUcmFuc2ZlclwiOlxuICAgICAge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZGVwb3NpdFxuICAgICAgICB9ID0gYWN0aW9uLnBhcmFtcztcbiAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9ucy50cmFuc2ZlcihuZXcgYm5fanMuQk4oZGVwb3NpdCkpO1xuICAgICAgfVxuICAgIGNhc2UgXCJTdGFrZVwiOlxuICAgICAge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgc3Rha2UsXG4gICAgICAgICAgcHVibGljS2V5XG4gICAgICAgIH0gPSBhY3Rpb24ucGFyYW1zO1xuICAgICAgICByZXR1cm4gdHJhbnNhY3Rpb25zLnN0YWtlKG5ldyBibl9qcy5CTihzdGFrZSksIHV0aWxzLlB1YmxpY0tleS5mcm9tKHB1YmxpY0tleSkpO1xuICAgICAgfVxuICAgIGNhc2UgXCJBZGRLZXlcIjpcbiAgICAgIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHB1YmxpY0tleSxcbiAgICAgICAgICBhY2Nlc3NLZXlcbiAgICAgICAgfSA9IGFjdGlvbi5wYXJhbXM7XG4gICAgICAgIHJldHVybiB0cmFuc2FjdGlvbnMuYWRkS2V5KHV0aWxzLlB1YmxpY0tleS5mcm9tKHB1YmxpY0tleSksXG4gICAgICAgIC8vIFRPRE86IFVzZSBhY2Nlc3NLZXkubm9uY2U/IG5lYXItYXBpLWpzIHNlZW1zIHRvIHRoaW5rIDAgaXMgZmluZT9cbiAgICAgICAgZ2V0QWNjZXNzS2V5KGFjY2Vzc0tleS5wZXJtaXNzaW9uKSk7XG4gICAgICB9XG4gICAgY2FzZSBcIkRlbGV0ZUtleVwiOlxuICAgICAge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgcHVibGljS2V5XG4gICAgICAgIH0gPSBhY3Rpb24ucGFyYW1zO1xuICAgICAgICByZXR1cm4gdHJhbnNhY3Rpb25zLmRlbGV0ZUtleSh1dGlscy5QdWJsaWNLZXkuZnJvbShwdWJsaWNLZXkpKTtcbiAgICAgIH1cbiAgICBjYXNlIFwiRGVsZXRlQWNjb3VudFwiOlxuICAgICAge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgYmVuZWZpY2lhcnlJZFxuICAgICAgICB9ID0gYWN0aW9uLnBhcmFtcztcbiAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9ucy5kZWxldGVBY2NvdW50KGJlbmVmaWNpYXJ5SWQpO1xuICAgICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGFjdGlvbiB0eXBlXCIpO1xuICB9XG59O1xuXG52YXIgY29tbW9uanNHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fTtcblxudmFyIGZhaWxzJGQgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxudmFyIGZhaWxzJGMgPSBmYWlscyRkO1xuXG52YXIgZnVuY3Rpb25CaW5kTmF0aXZlID0gIWZhaWxzJGMoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1mdW5jdGlvbi1wcm90b3R5cGUtYmluZCAtLSBzYWZlXG4gIHZhciB0ZXN0ID0gKGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSkuYmluZCgpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zIC0tIHNhZmVcbiAgcmV0dXJuIHR5cGVvZiB0ZXN0ICE9ICdmdW5jdGlvbicgfHwgdGVzdC5oYXNPd25Qcm9wZXJ0eSgncHJvdG90eXBlJyk7XG59KTtcblxudmFyIE5BVElWRV9CSU5EJDMgPSBmdW5jdGlvbkJpbmROYXRpdmU7XG5cbnZhciBGdW5jdGlvblByb3RvdHlwZSQyID0gRnVuY3Rpb24ucHJvdG90eXBlO1xudmFyIGJpbmQkNSA9IEZ1bmN0aW9uUHJvdG90eXBlJDIuYmluZDtcbnZhciBjYWxsJGUgPSBGdW5jdGlvblByb3RvdHlwZSQyLmNhbGw7XG52YXIgdW5jdXJyeVRoaXMkZCA9IE5BVElWRV9CSU5EJDMgJiYgYmluZCQ1LmJpbmQoY2FsbCRlLCBjYWxsJGUpO1xuXG52YXIgZnVuY3Rpb25VbmN1cnJ5VGhpcyA9IE5BVElWRV9CSU5EJDMgPyBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIGZuICYmIHVuY3VycnlUaGlzJGQoZm4pO1xufSA6IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gZm4gJiYgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjYWxsJGUuYXBwbHkoZm4sIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuXG52YXIgdW5jdXJyeVRoaXMkYyA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG5cbnZhciB0b1N0cmluZyQyID0gdW5jdXJyeVRoaXMkYyh7fS50b1N0cmluZyk7XG52YXIgc3RyaW5nU2xpY2UgPSB1bmN1cnJ5VGhpcyRjKCcnLnNsaWNlKTtcblxudmFyIGNsYXNzb2ZSYXckMSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gc3RyaW5nU2xpY2UodG9TdHJpbmckMihpdCksIDgsIC0xKTtcbn07XG5cbnZhciB1bmN1cnJ5VGhpcyRiID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBmYWlscyRiID0gZmFpbHMkZDtcbnZhciBjbGFzc29mJDUgPSBjbGFzc29mUmF3JDE7XG5cbnZhciAkT2JqZWN0JDQgPSBPYmplY3Q7XG52YXIgc3BsaXQgPSB1bmN1cnJ5VGhpcyRiKCcnLnNwbGl0KTtcblxuLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcbnZhciBpbmRleGVkT2JqZWN0ID0gZmFpbHMkYihmdW5jdGlvbiAoKSB7XG4gIC8vIHRocm93cyBhbiBlcnJvciBpbiByaGlubywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3JoaW5vL2lzc3Vlcy8zNDZcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGlucyAtLSBzYWZlXG4gIHJldHVybiAhJE9iamVjdCQ0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCk7XG59KSA/IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gY2xhc3NvZiQ1KGl0KSA9PSAnU3RyaW5nJyA/IHNwbGl0KGl0LCAnJykgOiAkT2JqZWN0JDQoaXQpO1xufSA6ICRPYmplY3QkNDtcblxudmFyICRUeXBlRXJyb3IkYiA9IFR5cGVFcnJvcjtcblxuLy8gYFJlcXVpcmVPYmplY3RDb2VyY2libGVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1yZXF1aXJlb2JqZWN0Y29lcmNpYmxlXG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSQyID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCA9PSB1bmRlZmluZWQpIHRocm93ICRUeXBlRXJyb3IkYihcIkNhbid0IGNhbGwgbWV0aG9kIG9uIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuXG4vLyB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIEluZGV4ZWRPYmplY3QgPSBpbmRleGVkT2JqZWN0O1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUkMSA9IHJlcXVpcmVPYmplY3RDb2VyY2libGUkMjtcblxudmFyIHRvSW5kZXhlZE9iamVjdCQ1ID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBJbmRleGVkT2JqZWN0KHJlcXVpcmVPYmplY3RDb2VyY2libGUkMShpdCkpO1xufTtcblxudmFyIGNoZWNrID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCAmJiBpdC5NYXRoID09IE1hdGggJiYgaXQ7XG59O1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxudmFyIGdsb2JhbCRqID1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tZ2xvYmFsLXRoaXMgLS0gc2FmZVxuICBjaGVjayh0eXBlb2YgZ2xvYmFsVGhpcyA9PSAnb2JqZWN0JyAmJiBnbG9iYWxUaGlzKSB8fFxuICBjaGVjayh0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIHdpbmRvdykgfHxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtZ2xvYmFscyAtLSBzYWZlXG4gIGNoZWNrKHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYpIHx8XG4gIGNoZWNrKHR5cGVvZiBjb21tb25qc0dsb2JhbCA9PSAnb2JqZWN0JyAmJiBjb21tb25qc0dsb2JhbCkgfHxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jIC0tIGZhbGxiYWNrXG4gIChmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KSgpIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbnZhciBzaGFyZWQkMyA9IHtleHBvcnRzOiB7fX07XG5cbnZhciBnbG9iYWwkaSA9IGdsb2JhbCRqO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gc2FmZVxudmFyIGRlZmluZVByb3BlcnR5JDQgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbnZhciBkZWZpbmVHbG9iYWxQcm9wZXJ0eSQzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgdHJ5IHtcbiAgICBkZWZpbmVQcm9wZXJ0eSQ0KGdsb2JhbCRpLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGdsb2JhbCRpW2tleV0gPSB2YWx1ZTtcbiAgfSByZXR1cm4gdmFsdWU7XG59O1xuXG52YXIgZ2xvYmFsJGggPSBnbG9iYWwkajtcbnZhciBkZWZpbmVHbG9iYWxQcm9wZXJ0eSQyID0gZGVmaW5lR2xvYmFsUHJvcGVydHkkMztcblxudmFyIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nO1xudmFyIHN0b3JlJDMgPSBnbG9iYWwkaFtTSEFSRURdIHx8IGRlZmluZUdsb2JhbFByb3BlcnR5JDIoU0hBUkVELCB7fSk7XG5cbnZhciBzaGFyZWRTdG9yZSA9IHN0b3JlJDM7XG5cbnZhciBzdG9yZSQyID0gc2hhcmVkU3RvcmU7XG5cbihzaGFyZWQkMy5leHBvcnRzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIHN0b3JlJDJba2V5XSB8fCAoc3RvcmUkMltrZXldID0gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoge30pO1xufSkoJ3ZlcnNpb25zJywgW10pLnB1c2goe1xuICB2ZXJzaW9uOiAnMy4yMy4zJyxcbiAgbW9kZTogJ2dsb2JhbCcsXG4gIGNvcHlyaWdodDogJ8KpIDIwMTQtMjAyMiBEZW5pcyBQdXNoa2FyZXYgKHpsb2lyb2NrLnJ1KScsXG4gIGxpY2Vuc2U6ICdodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9ibG9iL3YzLjIzLjMvTElDRU5TRScsXG4gIHNvdXJjZTogJ2h0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzJ1xufSk7XG5cbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZU9iamVjdENvZXJjaWJsZSQyO1xuXG52YXIgJE9iamVjdCQzID0gT2JqZWN0O1xuXG4vLyBgVG9PYmplY3RgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b29iamVjdFxudmFyIHRvT2JqZWN0JDIgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuICRPYmplY3QkMyhyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KSk7XG59O1xuXG52YXIgdW5jdXJyeVRoaXMkYSA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgdG9PYmplY3QkMSA9IHRvT2JqZWN0JDI7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IHVuY3VycnlUaGlzJGEoe30uaGFzT3duUHJvcGVydHkpO1xuXG4vLyBgSGFzT3duUHJvcGVydHlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1oYXNvd25wcm9wZXJ0eVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWhhc293biAtLSBzYWZlXG52YXIgaGFzT3duUHJvcGVydHlfMSA9IE9iamVjdC5oYXNPd24gfHwgZnVuY3Rpb24gaGFzT3duKGl0LCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5KHRvT2JqZWN0JDEoaXQpLCBrZXkpO1xufTtcblxudmFyIHVuY3VycnlUaGlzJDkgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xuXG52YXIgaWQgPSAwO1xudmFyIHBvc3RmaXggPSBNYXRoLnJhbmRvbSgpO1xudmFyIHRvU3RyaW5nJDEgPSB1bmN1cnJ5VGhpcyQ5KDEuMC50b1N0cmluZyk7XG5cbnZhciB1aWQkMiA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuICdTeW1ib2woJyArIChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5KSArICcpXycgKyB0b1N0cmluZyQxKCsraWQgKyBwb3N0Zml4LCAzNik7XG59O1xuXG4vLyBgSXNDYWxsYWJsZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWlzY2FsbGFibGVcbnZhciBpc0NhbGxhYmxlJGsgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmd1bWVudCA9PSAnZnVuY3Rpb24nO1xufTtcblxudmFyIGdsb2JhbCRnID0gZ2xvYmFsJGo7XG52YXIgaXNDYWxsYWJsZSRqID0gaXNDYWxsYWJsZSRrO1xuXG52YXIgYUZ1bmN0aW9uID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiBpc0NhbGxhYmxlJGooYXJndW1lbnQpID8gYXJndW1lbnQgOiB1bmRlZmluZWQ7XG59O1xuXG52YXIgZ2V0QnVpbHRJbiQ4ID0gZnVuY3Rpb24gKG5hbWVzcGFjZSwgbWV0aG9kKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGFGdW5jdGlvbihnbG9iYWwkZ1tuYW1lc3BhY2VdKSA6IGdsb2JhbCRnW25hbWVzcGFjZV0gJiYgZ2xvYmFsJGdbbmFtZXNwYWNlXVttZXRob2RdO1xufTtcblxudmFyIGdldEJ1aWx0SW4kNyA9IGdldEJ1aWx0SW4kODtcblxudmFyIGVuZ2luZVVzZXJBZ2VudCA9IGdldEJ1aWx0SW4kNygnbmF2aWdhdG9yJywgJ3VzZXJBZ2VudCcpIHx8ICcnO1xuXG52YXIgZ2xvYmFsJGYgPSBnbG9iYWwkajtcbnZhciB1c2VyQWdlbnQkMyA9IGVuZ2luZVVzZXJBZ2VudDtcblxudmFyIHByb2Nlc3MkMyA9IGdsb2JhbCRmLnByb2Nlc3M7XG52YXIgRGVubyQxID0gZ2xvYmFsJGYuRGVubztcbnZhciB2ZXJzaW9ucyA9IHByb2Nlc3MkMyAmJiBwcm9jZXNzJDMudmVyc2lvbnMgfHwgRGVubyQxICYmIERlbm8kMS52ZXJzaW9uO1xudmFyIHY4ID0gdmVyc2lvbnMgJiYgdmVyc2lvbnMudjg7XG52YXIgbWF0Y2gsIHZlcnNpb247XG5cbmlmICh2OCkge1xuICBtYXRjaCA9IHY4LnNwbGl0KCcuJyk7XG4gIC8vIGluIG9sZCBDaHJvbWUsIHZlcnNpb25zIG9mIFY4IGlzbid0IFY4ID0gQ2hyb21lIC8gMTBcbiAgLy8gYnV0IHRoZWlyIGNvcnJlY3QgdmVyc2lvbnMgYXJlIG5vdCBpbnRlcmVzdGluZyBmb3IgdXNcbiAgdmVyc2lvbiA9IG1hdGNoWzBdID4gMCAmJiBtYXRjaFswXSA8IDQgPyAxIDogKyhtYXRjaFswXSArIG1hdGNoWzFdKTtcbn1cblxuLy8gQnJvd3NlckZTIE5vZGVKUyBgcHJvY2Vzc2AgcG9seWZpbGwgaW5jb3JyZWN0bHkgc2V0IGAudjhgIHRvIGAwLjBgXG4vLyBzbyBjaGVjayBgdXNlckFnZW50YCBldmVuIGlmIGAudjhgIGV4aXN0cywgYnV0IDBcbmlmICghdmVyc2lvbiAmJiB1c2VyQWdlbnQkMykge1xuICBtYXRjaCA9IHVzZXJBZ2VudCQzLm1hdGNoKC9FZGdlXFwvKFxcZCspLyk7XG4gIGlmICghbWF0Y2ggfHwgbWF0Y2hbMV0gPj0gNzQpIHtcbiAgICBtYXRjaCA9IHVzZXJBZ2VudCQzLm1hdGNoKC9DaHJvbWVcXC8oXFxkKykvKTtcbiAgICBpZiAobWF0Y2gpIHZlcnNpb24gPSArbWF0Y2hbMV07XG4gIH1cbn1cblxudmFyIGVuZ2luZVY4VmVyc2lvbiA9IHZlcnNpb247XG5cbi8qIGVzbGludC1kaXNhYmxlIGVzLXgvbm8tc3ltYm9sIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nICovXG5cbnZhciBWOF9WRVJTSU9OJDEgPSBlbmdpbmVWOFZlcnNpb247XG52YXIgZmFpbHMkYSA9IGZhaWxzJGQ7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eXN5bWJvbHMgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbnZhciBuYXRpdmVTeW1ib2wgPSAhIU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgJiYgIWZhaWxzJGEoZnVuY3Rpb24gKCkge1xuICB2YXIgc3ltYm9sID0gU3ltYm9sKCk7XG4gIC8vIENocm9tZSAzOCBTeW1ib2wgaGFzIGluY29ycmVjdCB0b1N0cmluZyBjb252ZXJzaW9uXG4gIC8vIGBnZXQtb3duLXByb3BlcnR5LXN5bWJvbHNgIHBvbHlmaWxsIHN5bWJvbHMgY29udmVydGVkIHRvIG9iamVjdCBhcmUgbm90IFN5bWJvbCBpbnN0YW5jZXNcbiAgcmV0dXJuICFTdHJpbmcoc3ltYm9sKSB8fCAhKE9iamVjdChzeW1ib2wpIGluc3RhbmNlb2YgU3ltYm9sKSB8fFxuICAgIC8vIENocm9tZSAzOC00MCBzeW1ib2xzIGFyZSBub3QgaW5oZXJpdGVkIGZyb20gRE9NIGNvbGxlY3Rpb25zIHByb3RvdHlwZXMgdG8gaW5zdGFuY2VzXG4gICAgIVN5bWJvbC5zaGFtICYmIFY4X1ZFUlNJT04kMSAmJiBWOF9WRVJTSU9OJDEgPCA0MTtcbn0pO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBlcy14L25vLXN5bWJvbCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZyAqL1xuXG52YXIgTkFUSVZFX1NZTUJPTCQxID0gbmF0aXZlU3ltYm9sO1xuXG52YXIgdXNlU3ltYm9sQXNVaWQgPSBOQVRJVkVfU1lNQk9MJDFcbiAgJiYgIVN5bWJvbC5zaGFtXG4gICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT0gJ3N5bWJvbCc7XG5cbnZhciBnbG9iYWwkZSA9IGdsb2JhbCRqO1xudmFyIHNoYXJlZCQyID0gc2hhcmVkJDMuZXhwb3J0cztcbnZhciBoYXNPd24kYSA9IGhhc093blByb3BlcnR5XzE7XG52YXIgdWlkJDEgPSB1aWQkMjtcbnZhciBOQVRJVkVfU1lNQk9MID0gbmF0aXZlU3ltYm9sO1xudmFyIFVTRV9TWU1CT0xfQVNfVUlEJDEgPSB1c2VTeW1ib2xBc1VpZDtcblxudmFyIFdlbGxLbm93blN5bWJvbHNTdG9yZSA9IHNoYXJlZCQyKCd3a3MnKTtcbnZhciBTeW1ib2wkMSA9IGdsb2JhbCRlLlN5bWJvbDtcbnZhciBzeW1ib2xGb3IgPSBTeW1ib2wkMSAmJiBTeW1ib2wkMVsnZm9yJ107XG52YXIgY3JlYXRlV2VsbEtub3duU3ltYm9sID0gVVNFX1NZTUJPTF9BU19VSUQkMSA/IFN5bWJvbCQxIDogU3ltYm9sJDEgJiYgU3ltYm9sJDEud2l0aG91dFNldHRlciB8fCB1aWQkMTtcblxudmFyIHdlbGxLbm93blN5bWJvbCRlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgaWYgKCFoYXNPd24kYShXZWxsS25vd25TeW1ib2xzU3RvcmUsIG5hbWUpIHx8ICEoTkFUSVZFX1NZTUJPTCB8fCB0eXBlb2YgV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdID09ICdzdHJpbmcnKSkge1xuICAgIHZhciBkZXNjcmlwdGlvbiA9ICdTeW1ib2wuJyArIG5hbWU7XG4gICAgaWYgKE5BVElWRV9TWU1CT0wgJiYgaGFzT3duJGEoU3ltYm9sJDEsIG5hbWUpKSB7XG4gICAgICBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV0gPSBTeW1ib2wkMVtuYW1lXTtcbiAgICB9IGVsc2UgaWYgKFVTRV9TWU1CT0xfQVNfVUlEJDEgJiYgc3ltYm9sRm9yKSB7XG4gICAgICBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV0gPSBzeW1ib2xGb3IoZGVzY3JpcHRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV0gPSBjcmVhdGVXZWxsS25vd25TeW1ib2woZGVzY3JpcHRpb24pO1xuICAgIH1cbiAgfSByZXR1cm4gV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdO1xufTtcblxudmFyIGlzQ2FsbGFibGUkaSA9IGlzQ2FsbGFibGUkaztcblxudmFyIGlzT2JqZWN0JDcgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogaXNDYWxsYWJsZSRpKGl0KTtcbn07XG5cbnZhciBpc09iamVjdCQ2ID0gaXNPYmplY3QkNztcblxudmFyICRTdHJpbmckMyA9IFN0cmluZztcbnZhciAkVHlwZUVycm9yJGEgPSBUeXBlRXJyb3I7XG5cbi8vIGBBc3NlcnQ6IFR5cGUoYXJndW1lbnQpIGlzIE9iamVjdGBcbnZhciBhbk9iamVjdCRjID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmIChpc09iamVjdCQ2KGFyZ3VtZW50KSkgcmV0dXJuIGFyZ3VtZW50O1xuICB0aHJvdyAkVHlwZUVycm9yJGEoJFN0cmluZyQzKGFyZ3VtZW50KSArICcgaXMgbm90IGFuIG9iamVjdCcpO1xufTtcblxudmFyIG9iamVjdERlZmluZVByb3BlcnRpZXMgPSB7fTtcblxudmFyIGZhaWxzJDkgPSBmYWlscyRkO1xuXG4vLyBEZXRlY3QgSUU4J3MgaW5jb21wbGV0ZSBkZWZpbmVQcm9wZXJ0eSBpbXBsZW1lbnRhdGlvblxudmFyIGRlc2NyaXB0b3JzID0gIWZhaWxzJDkoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgMSwgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSlbMV0gIT0gNztcbn0pO1xuXG52YXIgREVTQ1JJUFRPUlMkOSA9IGRlc2NyaXB0b3JzO1xudmFyIGZhaWxzJDggPSBmYWlscyRkO1xuXG4vLyBWOCB+IENocm9tZSAzNi1cbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMzMzRcbnZhciB2OFByb3RvdHlwZURlZmluZUJ1ZyA9IERFU0NSSVBUT1JTJDkgJiYgZmFpbHMkOChmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSwgJ3Byb3RvdHlwZScsIHtcbiAgICB2YWx1ZTogNDIsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pLnByb3RvdHlwZSAhPSA0Mjtcbn0pO1xuXG52YXIgb2JqZWN0RGVmaW5lUHJvcGVydHkgPSB7fTtcblxudmFyIGdsb2JhbCRkID0gZ2xvYmFsJGo7XG52YXIgaXNPYmplY3QkNSA9IGlzT2JqZWN0JDc7XG5cbnZhciBkb2N1bWVudCQzID0gZ2xvYmFsJGQuZG9jdW1lbnQ7XG4vLyB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0JyBpbiBvbGQgSUVcbnZhciBFWElTVFMkMSA9IGlzT2JqZWN0JDUoZG9jdW1lbnQkMykgJiYgaXNPYmplY3QkNShkb2N1bWVudCQzLmNyZWF0ZUVsZW1lbnQpO1xuXG52YXIgZG9jdW1lbnRDcmVhdGVFbGVtZW50JDIgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIEVYSVNUUyQxID8gZG9jdW1lbnQkMy5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTtcblxudmFyIERFU0NSSVBUT1JTJDggPSBkZXNjcmlwdG9ycztcbnZhciBmYWlscyQ3ID0gZmFpbHMkZDtcbnZhciBjcmVhdGVFbGVtZW50JDEgPSBkb2N1bWVudENyZWF0ZUVsZW1lbnQkMjtcblxuLy8gVGhhbmtzIHRvIElFOCBmb3IgaXRzIGZ1bm55IGRlZmluZVByb3BlcnR5XG52YXIgaWU4RG9tRGVmaW5lID0gIURFU0NSSVBUT1JTJDggJiYgIWZhaWxzJDcoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjcmVhdGVFbGVtZW50JDEoJ2RpdicpLCAnYScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH1cbiAgfSkuYSAhPSA3O1xufSk7XG5cbnZhciBOQVRJVkVfQklORCQyID0gZnVuY3Rpb25CaW5kTmF0aXZlO1xuXG52YXIgY2FsbCRkID0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGw7XG5cbnZhciBmdW5jdGlvbkNhbGwgPSBOQVRJVkVfQklORCQyID8gY2FsbCRkLmJpbmQoY2FsbCRkKSA6IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGNhbGwkZC5hcHBseShjYWxsJGQsIGFyZ3VtZW50cyk7XG59O1xuXG52YXIgdW5jdXJyeVRoaXMkOCA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG5cbnZhciBvYmplY3RJc1Byb3RvdHlwZU9mID0gdW5jdXJyeVRoaXMkOCh7fS5pc1Byb3RvdHlwZU9mKTtcblxudmFyIGdldEJ1aWx0SW4kNiA9IGdldEJ1aWx0SW4kODtcbnZhciBpc0NhbGxhYmxlJGggPSBpc0NhbGxhYmxlJGs7XG52YXIgaXNQcm90b3R5cGVPZiQzID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbnZhciBVU0VfU1lNQk9MX0FTX1VJRCA9IHVzZVN5bWJvbEFzVWlkO1xuXG52YXIgJE9iamVjdCQyID0gT2JqZWN0O1xuXG52YXIgaXNTeW1ib2wkMiA9IFVTRV9TWU1CT0xfQVNfVUlEID8gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCc7XG59IDogZnVuY3Rpb24gKGl0KSB7XG4gIHZhciAkU3ltYm9sID0gZ2V0QnVpbHRJbiQ2KCdTeW1ib2wnKTtcbiAgcmV0dXJuIGlzQ2FsbGFibGUkaCgkU3ltYm9sKSAmJiBpc1Byb3RvdHlwZU9mJDMoJFN5bWJvbC5wcm90b3R5cGUsICRPYmplY3QkMihpdCkpO1xufTtcblxudmFyICRTdHJpbmckMiA9IFN0cmluZztcblxudmFyIHRyeVRvU3RyaW5nJDQgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gJFN0cmluZyQyKGFyZ3VtZW50KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gJ09iamVjdCc7XG4gIH1cbn07XG5cbnZhciBpc0NhbGxhYmxlJGcgPSBpc0NhbGxhYmxlJGs7XG52YXIgdHJ5VG9TdHJpbmckMyA9IHRyeVRvU3RyaW5nJDQ7XG5cbnZhciAkVHlwZUVycm9yJDkgPSBUeXBlRXJyb3I7XG5cbi8vIGBBc3NlcnQ6IElzQ2FsbGFibGUoYXJndW1lbnQpIGlzIHRydWVgXG52YXIgYUNhbGxhYmxlJDcgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgaWYgKGlzQ2FsbGFibGUkZyhhcmd1bWVudCkpIHJldHVybiBhcmd1bWVudDtcbiAgdGhyb3cgJFR5cGVFcnJvciQ5KHRyeVRvU3RyaW5nJDMoYXJndW1lbnQpICsgJyBpcyBub3QgYSBmdW5jdGlvbicpO1xufTtcblxudmFyIGFDYWxsYWJsZSQ2ID0gYUNhbGxhYmxlJDc7XG5cbi8vIGBHZXRNZXRob2RgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1nZXRtZXRob2RcbnZhciBnZXRNZXRob2QkMyA9IGZ1bmN0aW9uIChWLCBQKSB7XG4gIHZhciBmdW5jID0gVltQXTtcbiAgcmV0dXJuIGZ1bmMgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGFDYWxsYWJsZSQ2KGZ1bmMpO1xufTtcblxudmFyIGNhbGwkYyA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBpc0NhbGxhYmxlJGYgPSBpc0NhbGxhYmxlJGs7XG52YXIgaXNPYmplY3QkNCA9IGlzT2JqZWN0JDc7XG5cbnZhciAkVHlwZUVycm9yJDggPSBUeXBlRXJyb3I7XG5cbi8vIGBPcmRpbmFyeVRvUHJpbWl0aXZlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb3JkaW5hcnl0b3ByaW1pdGl2ZVxudmFyIG9yZGluYXJ5VG9QcmltaXRpdmUkMSA9IGZ1bmN0aW9uIChpbnB1dCwgcHJlZikge1xuICB2YXIgZm4sIHZhbDtcbiAgaWYgKHByZWYgPT09ICdzdHJpbmcnICYmIGlzQ2FsbGFibGUkZihmbiA9IGlucHV0LnRvU3RyaW5nKSAmJiAhaXNPYmplY3QkNCh2YWwgPSBjYWxsJGMoZm4sIGlucHV0KSkpIHJldHVybiB2YWw7XG4gIGlmIChpc0NhbGxhYmxlJGYoZm4gPSBpbnB1dC52YWx1ZU9mKSAmJiAhaXNPYmplY3QkNCh2YWwgPSBjYWxsJGMoZm4sIGlucHV0KSkpIHJldHVybiB2YWw7XG4gIGlmIChwcmVmICE9PSAnc3RyaW5nJyAmJiBpc0NhbGxhYmxlJGYoZm4gPSBpbnB1dC50b1N0cmluZykgJiYgIWlzT2JqZWN0JDQodmFsID0gY2FsbCRjKGZuLCBpbnB1dCkpKSByZXR1cm4gdmFsO1xuICB0aHJvdyAkVHlwZUVycm9yJDgoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuXG52YXIgY2FsbCRiID0gZnVuY3Rpb25DYWxsO1xudmFyIGlzT2JqZWN0JDMgPSBpc09iamVjdCQ3O1xudmFyIGlzU3ltYm9sJDEgPSBpc1N5bWJvbCQyO1xudmFyIGdldE1ldGhvZCQyID0gZ2V0TWV0aG9kJDM7XG52YXIgb3JkaW5hcnlUb1ByaW1pdGl2ZSA9IG9yZGluYXJ5VG9QcmltaXRpdmUkMTtcbnZhciB3ZWxsS25vd25TeW1ib2wkZCA9IHdlbGxLbm93blN5bWJvbCRlO1xuXG52YXIgJFR5cGVFcnJvciQ3ID0gVHlwZUVycm9yO1xudmFyIFRPX1BSSU1JVElWRSA9IHdlbGxLbm93blN5bWJvbCRkKCd0b1ByaW1pdGl2ZScpO1xuXG4vLyBgVG9QcmltaXRpdmVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b3ByaW1pdGl2ZVxudmFyIHRvUHJpbWl0aXZlJDEgPSBmdW5jdGlvbiAoaW5wdXQsIHByZWYpIHtcbiAgaWYgKCFpc09iamVjdCQzKGlucHV0KSB8fCBpc1N5bWJvbCQxKGlucHV0KSkgcmV0dXJuIGlucHV0O1xuICB2YXIgZXhvdGljVG9QcmltID0gZ2V0TWV0aG9kJDIoaW5wdXQsIFRPX1BSSU1JVElWRSk7XG4gIHZhciByZXN1bHQ7XG4gIGlmIChleG90aWNUb1ByaW0pIHtcbiAgICBpZiAocHJlZiA9PT0gdW5kZWZpbmVkKSBwcmVmID0gJ2RlZmF1bHQnO1xuICAgIHJlc3VsdCA9IGNhbGwkYihleG90aWNUb1ByaW0sIGlucHV0LCBwcmVmKTtcbiAgICBpZiAoIWlzT2JqZWN0JDMocmVzdWx0KSB8fCBpc1N5bWJvbCQxKHJlc3VsdCkpIHJldHVybiByZXN1bHQ7XG4gICAgdGhyb3cgJFR5cGVFcnJvciQ3KFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xuICB9XG4gIGlmIChwcmVmID09PSB1bmRlZmluZWQpIHByZWYgPSAnbnVtYmVyJztcbiAgcmV0dXJuIG9yZGluYXJ5VG9QcmltaXRpdmUoaW5wdXQsIHByZWYpO1xufTtcblxudmFyIHRvUHJpbWl0aXZlID0gdG9QcmltaXRpdmUkMTtcbnZhciBpc1N5bWJvbCA9IGlzU3ltYm9sJDI7XG5cbi8vIGBUb1Byb3BlcnR5S2V5YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9wcm9wZXJ0eWtleVxudmFyIHRvUHJvcGVydHlLZXkkMiA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICB2YXIga2V5ID0gdG9QcmltaXRpdmUoYXJndW1lbnQsICdzdHJpbmcnKTtcbiAgcmV0dXJuIGlzU3ltYm9sKGtleSkgPyBrZXkgOiBrZXkgKyAnJztcbn07XG5cbnZhciBERVNDUklQVE9SUyQ3ID0gZGVzY3JpcHRvcnM7XG52YXIgSUU4X0RPTV9ERUZJTkUkMSA9IGllOERvbURlZmluZTtcbnZhciBWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyQxID0gdjhQcm90b3R5cGVEZWZpbmVCdWc7XG52YXIgYW5PYmplY3QkYiA9IGFuT2JqZWN0JGM7XG52YXIgdG9Qcm9wZXJ0eUtleSQxID0gdG9Qcm9wZXJ0eUtleSQyO1xuXG52YXIgJFR5cGVFcnJvciQ2ID0gVHlwZUVycm9yO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcbnZhciAkZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIEVOVU1FUkFCTEUgPSAnZW51bWVyYWJsZSc7XG52YXIgQ09ORklHVVJBQkxFJDEgPSAnY29uZmlndXJhYmxlJztcbnZhciBXUklUQUJMRSA9ICd3cml0YWJsZSc7XG5cbi8vIGBPYmplY3QuZGVmaW5lUHJvcGVydHlgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydHlcbm9iamVjdERlZmluZVByb3BlcnR5LmYgPSBERVNDUklQVE9SUyQ3ID8gVjhfUFJPVE9UWVBFX0RFRklORV9CVUckMSA/IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgYW5PYmplY3QkYihPKTtcbiAgUCA9IHRvUHJvcGVydHlLZXkkMShQKTtcbiAgYW5PYmplY3QkYihBdHRyaWJ1dGVzKTtcbiAgaWYgKHR5cGVvZiBPID09PSAnZnVuY3Rpb24nICYmIFAgPT09ICdwcm90b3R5cGUnICYmICd2YWx1ZScgaW4gQXR0cmlidXRlcyAmJiBXUklUQUJMRSBpbiBBdHRyaWJ1dGVzICYmICFBdHRyaWJ1dGVzW1dSSVRBQkxFXSkge1xuICAgIHZhciBjdXJyZW50ID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvciQxKE8sIFApO1xuICAgIGlmIChjdXJyZW50ICYmIGN1cnJlbnRbV1JJVEFCTEVdKSB7XG4gICAgICBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgICAgIEF0dHJpYnV0ZXMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogQ09ORklHVVJBQkxFJDEgaW4gQXR0cmlidXRlcyA/IEF0dHJpYnV0ZXNbQ09ORklHVVJBQkxFJDFdIDogY3VycmVudFtDT05GSUdVUkFCTEUkMV0sXG4gICAgICAgIGVudW1lcmFibGU6IEVOVU1FUkFCTEUgaW4gQXR0cmlidXRlcyA/IEF0dHJpYnV0ZXNbRU5VTUVSQUJMRV0gOiBjdXJyZW50W0VOVU1FUkFCTEVdLFxuICAgICAgICB3cml0YWJsZTogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICB9IHJldHVybiAkZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyk7XG59IDogJGRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICBhbk9iamVjdCRiKE8pO1xuICBQID0gdG9Qcm9wZXJ0eUtleSQxKFApO1xuICBhbk9iamVjdCRiKEF0dHJpYnV0ZXMpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUkMSkgdHJ5IHtcbiAgICByZXR1cm4gJGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIGlmICgnZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpIHRocm93ICRUeXBlRXJyb3IkNignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgaWYgKCd2YWx1ZScgaW4gQXR0cmlidXRlcykgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTtcblxudmFyIGNlaWwgPSBNYXRoLmNlaWw7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuXG4vLyBgTWF0aC50cnVuY2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW1hdGgudHJ1bmNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW1hdGgtdHJ1bmMgLS0gc2FmZVxudmFyIG1hdGhUcnVuYyA9IE1hdGgudHJ1bmMgfHwgZnVuY3Rpb24gdHJ1bmMoeCkge1xuICB2YXIgbiA9ICt4O1xuICByZXR1cm4gKG4gPiAwID8gZmxvb3IgOiBjZWlsKShuKTtcbn07XG5cbnZhciB0cnVuYyA9IG1hdGhUcnVuYztcblxuLy8gYFRvSW50ZWdlck9ySW5maW5pdHlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b2ludGVnZXJvcmluZmluaXR5XG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSQyID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHZhciBudW1iZXIgPSArYXJndW1lbnQ7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG4gIHJldHVybiBudW1iZXIgIT09IG51bWJlciB8fCBudW1iZXIgPT09IDAgPyAwIDogdHJ1bmMobnVtYmVyKTtcbn07XG5cbnZhciB0b0ludGVnZXJPckluZmluaXR5JDEgPSB0b0ludGVnZXJPckluZmluaXR5JDI7XG5cbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4kMSA9IE1hdGgubWluO1xuXG4vLyBIZWxwZXIgZm9yIGEgcG9wdWxhciByZXBlYXRpbmcgY2FzZSBvZiB0aGUgc3BlYzpcbi8vIExldCBpbnRlZ2VyIGJlID8gVG9JbnRlZ2VyKGluZGV4KS5cbi8vIElmIGludGVnZXIgPCAwLCBsZXQgcmVzdWx0IGJlIG1heCgobGVuZ3RoICsgaW50ZWdlciksIDApOyBlbHNlIGxldCByZXN1bHQgYmUgbWluKGludGVnZXIsIGxlbmd0aCkuXG52YXIgdG9BYnNvbHV0ZUluZGV4JDEgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICB2YXIgaW50ZWdlciA9IHRvSW50ZWdlck9ySW5maW5pdHkkMShpbmRleCk7XG4gIHJldHVybiBpbnRlZ2VyIDwgMCA/IG1heChpbnRlZ2VyICsgbGVuZ3RoLCAwKSA6IG1pbiQxKGludGVnZXIsIGxlbmd0aCk7XG59O1xuXG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSA9IHRvSW50ZWdlck9ySW5maW5pdHkkMjtcblxudmFyIG1pbiA9IE1hdGgubWluO1xuXG4vLyBgVG9MZW5ndGhgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b2xlbmd0aFxudmFyIHRvTGVuZ3RoJDEgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIGFyZ3VtZW50ID4gMCA/IG1pbih0b0ludGVnZXJPckluZmluaXR5KGFyZ3VtZW50KSwgMHgxRkZGRkZGRkZGRkZGRikgOiAwOyAvLyAyICoqIDUzIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59O1xuXG52YXIgdG9MZW5ndGggPSB0b0xlbmd0aCQxO1xuXG4vLyBgTGVuZ3RoT2ZBcnJheUxpa2VgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1sZW5ndGhvZmFycmF5bGlrZVxudmFyIGxlbmd0aE9mQXJyYXlMaWtlJDIgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0b0xlbmd0aChvYmoubGVuZ3RoKTtcbn07XG5cbnZhciB0b0luZGV4ZWRPYmplY3QkNCA9IHRvSW5kZXhlZE9iamVjdCQ1O1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHRvQWJzb2x1dGVJbmRleCQxO1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlJDEgPSBsZW5ndGhPZkFycmF5TGlrZSQyO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLnsgaW5kZXhPZiwgaW5jbHVkZXMgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxudmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uIChJU19JTkNMVURFUykge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBlbCwgZnJvbUluZGV4KSB7XG4gICAgdmFyIE8gPSB0b0luZGV4ZWRPYmplY3QkNCgkdGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlJDEoTyk7XG4gICAgdmFyIGluZGV4ID0gdG9BYnNvbHV0ZUluZGV4KGZyb21JbmRleCwgbGVuZ3RoKTtcbiAgICB2YXIgdmFsdWU7XG4gICAgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG4gICAgaWYgKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKSB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG4gICAgICBpZiAodmFsdWUgIT0gdmFsdWUpIHJldHVybiB0cnVlO1xuICAgIC8vIEFycmF5I2luZGV4T2YgaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcbiAgICB9IGVsc2UgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICAgIGlmICgoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTykgJiYgT1tpbmRleF0gPT09IGVsKSByZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcbiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59O1xuXG52YXIgYXJyYXlJbmNsdWRlcyA9IHtcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5pbmNsdWRlc2AgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmluY2x1ZGVzXG4gIGluY2x1ZGVzOiBjcmVhdGVNZXRob2QodHJ1ZSksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuaW5kZXhPZmAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmluZGV4b2ZcbiAgaW5kZXhPZjogY3JlYXRlTWV0aG9kKGZhbHNlKVxufTtcblxudmFyIGhpZGRlbktleXMkNCA9IHt9O1xuXG52YXIgdW5jdXJyeVRoaXMkNyA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgaGFzT3duJDkgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIHRvSW5kZXhlZE9iamVjdCQzID0gdG9JbmRleGVkT2JqZWN0JDU7XG52YXIgaW5kZXhPZiA9IGFycmF5SW5jbHVkZXMuaW5kZXhPZjtcbnZhciBoaWRkZW5LZXlzJDMgPSBoaWRkZW5LZXlzJDQ7XG5cbnZhciBwdXNoID0gdW5jdXJyeVRoaXMkNyhbXS5wdXNoKTtcblxudmFyIG9iamVjdEtleXNJbnRlcm5hbCA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWVzKSB7XG4gIHZhciBPID0gdG9JbmRleGVkT2JqZWN0JDMob2JqZWN0KTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIE8pICFoYXNPd24kOShoaWRkZW5LZXlzJDMsIGtleSkgJiYgaGFzT3duJDkoTywga2V5KSAmJiBwdXNoKHJlc3VsdCwga2V5KTtcbiAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkgaWYgKGhhc093biQ5KE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICAgfmluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHB1c2gocmVzdWx0LCBrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyBJRTgtIGRvbid0IGVudW0gYnVnIGtleXNcbnZhciBlbnVtQnVnS2V5cyQzID0gW1xuICAnY29uc3RydWN0b3InLFxuICAnaGFzT3duUHJvcGVydHknLFxuICAnaXNQcm90b3R5cGVPZicsXG4gICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsXG4gICd0b0xvY2FsZVN0cmluZycsXG4gICd0b1N0cmluZycsXG4gICd2YWx1ZU9mJ1xuXTtcblxudmFyIGludGVybmFsT2JqZWN0S2V5cyQxID0gb2JqZWN0S2V5c0ludGVybmFsO1xudmFyIGVudW1CdWdLZXlzJDIgPSBlbnVtQnVnS2V5cyQzO1xuXG4vLyBgT2JqZWN0LmtleXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3Qua2V5c1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWtleXMgLS0gc2FmZVxudmFyIG9iamVjdEtleXMkMSA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTykge1xuICByZXR1cm4gaW50ZXJuYWxPYmplY3RLZXlzJDEoTywgZW51bUJ1Z0tleXMkMik7XG59O1xuXG52YXIgREVTQ1JJUFRPUlMkNiA9IGRlc2NyaXB0b3JzO1xudmFyIFY4X1BST1RPVFlQRV9ERUZJTkVfQlVHID0gdjhQcm90b3R5cGVEZWZpbmVCdWc7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUkNCA9IG9iamVjdERlZmluZVByb3BlcnR5O1xudmFyIGFuT2JqZWN0JGEgPSBhbk9iamVjdCRjO1xudmFyIHRvSW5kZXhlZE9iamVjdCQyID0gdG9JbmRleGVkT2JqZWN0JDU7XG52YXIgb2JqZWN0S2V5cyA9IG9iamVjdEtleXMkMTtcblxuLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnRpZXNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0aWVzIC0tIHNhZmVcbm9iamVjdERlZmluZVByb3BlcnRpZXMuZiA9IERFU0NSSVBUT1JTJDYgJiYgIVY4X1BST1RPVFlQRV9ERUZJTkVfQlVHID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpIHtcbiAgYW5PYmplY3QkYShPKTtcbiAgdmFyIHByb3BzID0gdG9JbmRleGVkT2JqZWN0JDIoUHJvcGVydGllcyk7XG4gIHZhciBrZXlzID0gb2JqZWN0S2V5cyhQcm9wZXJ0aWVzKTtcbiAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIga2V5O1xuICB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIGRlZmluZVByb3BlcnR5TW9kdWxlJDQuZihPLCBrZXkgPSBrZXlzW2luZGV4KytdLCBwcm9wc1trZXldKTtcbiAgcmV0dXJuIE87XG59O1xuXG52YXIgZ2V0QnVpbHRJbiQ1ID0gZ2V0QnVpbHRJbiQ4O1xuXG52YXIgaHRtbCQyID0gZ2V0QnVpbHRJbiQ1KCdkb2N1bWVudCcsICdkb2N1bWVudEVsZW1lbnQnKTtcblxudmFyIHNoYXJlZCQxID0gc2hhcmVkJDMuZXhwb3J0cztcbnZhciB1aWQgPSB1aWQkMjtcblxudmFyIGtleXMgPSBzaGFyZWQkMSgna2V5cycpO1xuXG52YXIgc2hhcmVkS2V5JDMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBrZXlzW2tleV0gfHwgKGtleXNba2V5XSA9IHVpZChrZXkpKTtcbn07XG5cbi8qIGdsb2JhbCBBY3RpdmVYT2JqZWN0IC0tIG9sZCBJRSwgV1NIICovXG5cbnZhciBhbk9iamVjdCQ5ID0gYW5PYmplY3QkYztcbnZhciBkZWZpbmVQcm9wZXJ0aWVzTW9kdWxlID0gb2JqZWN0RGVmaW5lUHJvcGVydGllcztcbnZhciBlbnVtQnVnS2V5cyQxID0gZW51bUJ1Z0tleXMkMztcbnZhciBoaWRkZW5LZXlzJDIgPSBoaWRkZW5LZXlzJDQ7XG52YXIgaHRtbCQxID0gaHRtbCQyO1xudmFyIGRvY3VtZW50Q3JlYXRlRWxlbWVudCQxID0gZG9jdW1lbnRDcmVhdGVFbGVtZW50JDI7XG52YXIgc2hhcmVkS2V5JDIgPSBzaGFyZWRLZXkkMztcblxudmFyIEdUID0gJz4nO1xudmFyIExUID0gJzwnO1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xudmFyIFNDUklQVCA9ICdzY3JpcHQnO1xudmFyIElFX1BST1RPJDEgPSBzaGFyZWRLZXkkMignSUVfUFJPVE8nKTtcblxudmFyIEVtcHR5Q29uc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG5cbnZhciBzY3JpcHRUYWcgPSBmdW5jdGlvbiAoY29udGVudCkge1xuICByZXR1cm4gTFQgKyBTQ1JJUFQgKyBHVCArIGNvbnRlbnQgKyBMVCArICcvJyArIFNDUklQVCArIEdUO1xufTtcblxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIEFjdGl2ZVggT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBOdWxsUHJvdG9PYmplY3RWaWFBY3RpdmVYID0gZnVuY3Rpb24gKGFjdGl2ZVhEb2N1bWVudCkge1xuICBhY3RpdmVYRG9jdW1lbnQud3JpdGUoc2NyaXB0VGFnKCcnKSk7XG4gIGFjdGl2ZVhEb2N1bWVudC5jbG9zZSgpO1xuICB2YXIgdGVtcCA9IGFjdGl2ZVhEb2N1bWVudC5wYXJlbnRXaW5kb3cuT2JqZWN0O1xuICBhY3RpdmVYRG9jdW1lbnQgPSBudWxsOyAvLyBhdm9pZCBtZW1vcnkgbGVha1xuICByZXR1cm4gdGVtcDtcbn07XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBOdWxsUHJvdG9PYmplY3RWaWFJRnJhbWUgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSBkb2N1bWVudENyZWF0ZUVsZW1lbnQkMSgnaWZyYW1lJyk7XG4gIHZhciBKUyA9ICdqYXZhJyArIFNDUklQVCArICc6JztcbiAgdmFyIGlmcmFtZURvY3VtZW50O1xuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgaHRtbCQxLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy80NzVcbiAgaWZyYW1lLnNyYyA9IFN0cmluZyhKUyk7XG4gIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcbiAgaWZyYW1lRG9jdW1lbnQud3JpdGUoc2NyaXB0VGFnKCdkb2N1bWVudC5GPU9iamVjdCcpKTtcbiAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcbiAgcmV0dXJuIGlmcmFtZURvY3VtZW50LkY7XG59O1xuXG4vLyBDaGVjayBmb3IgZG9jdW1lbnQuZG9tYWluIGFuZCBhY3RpdmUgeCBzdXBwb3J0XG4vLyBObyBuZWVkIHRvIHVzZSBhY3RpdmUgeCBhcHByb2FjaCB3aGVuIGRvY3VtZW50LmRvbWFpbiBpcyBub3Qgc2V0XG4vLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltL2lzc3Vlcy8xNTBcbi8vIHZhcmlhdGlvbiBvZiBodHRwczovL2dpdGh1Yi5jb20va2l0Y2FtYnJpZGdlL2VzNS1zaGltL2NvbW1pdC80ZjczOGFjMDY2MzQ2XG4vLyBhdm9pZCBJRSBHQyBidWdcbnZhciBhY3RpdmVYRG9jdW1lbnQ7XG52YXIgTnVsbFByb3RvT2JqZWN0ID0gZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIGFjdGl2ZVhEb2N1bWVudCA9IG5ldyBBY3RpdmVYT2JqZWN0KCdodG1sZmlsZScpO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBpZ25vcmUgKi8gfVxuICBOdWxsUHJvdG9PYmplY3QgPSB0eXBlb2YgZG9jdW1lbnQgIT0gJ3VuZGVmaW5lZCdcbiAgICA/IGRvY3VtZW50LmRvbWFpbiAmJiBhY3RpdmVYRG9jdW1lbnRcbiAgICAgID8gTnVsbFByb3RvT2JqZWN0VmlhQWN0aXZlWChhY3RpdmVYRG9jdW1lbnQpIC8vIG9sZCBJRVxuICAgICAgOiBOdWxsUHJvdG9PYmplY3RWaWFJRnJhbWUoKVxuICAgIDogTnVsbFByb3RvT2JqZWN0VmlhQWN0aXZlWChhY3RpdmVYRG9jdW1lbnQpOyAvLyBXU0hcbiAgdmFyIGxlbmd0aCA9IGVudW1CdWdLZXlzJDEubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIGRlbGV0ZSBOdWxsUHJvdG9PYmplY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5cyQxW2xlbmd0aF1dO1xuICByZXR1cm4gTnVsbFByb3RvT2JqZWN0KCk7XG59O1xuXG5oaWRkZW5LZXlzJDJbSUVfUFJPVE8kMV0gPSB0cnVlO1xuXG4vLyBgT2JqZWN0LmNyZWF0ZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5jcmVhdGVcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1jcmVhdGUgLS0gc2FmZVxudmFyIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKE8gIT09IG51bGwpIHtcbiAgICBFbXB0eUNvbnN0cnVjdG9yW1BST1RPVFlQRV0gPSBhbk9iamVjdCQ5KE8pO1xuICAgIHJlc3VsdCA9IG5ldyBFbXB0eUNvbnN0cnVjdG9yKCk7XG4gICAgRW1wdHlDb25zdHJ1Y3RvcltQUk9UT1RZUEVdID0gbnVsbDtcbiAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXG4gICAgcmVzdWx0W0lFX1BST1RPJDFdID0gTztcbiAgfSBlbHNlIHJlc3VsdCA9IE51bGxQcm90b09iamVjdCgpO1xuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZGVmaW5lUHJvcGVydGllc01vZHVsZS5mKHJlc3VsdCwgUHJvcGVydGllcyk7XG59O1xuXG52YXIgd2VsbEtub3duU3ltYm9sJGMgPSB3ZWxsS25vd25TeW1ib2wkZTtcbnZhciBjcmVhdGUkMSA9IG9iamVjdENyZWF0ZTtcbnZhciBkZWZpbmVQcm9wZXJ0eSQzID0gb2JqZWN0RGVmaW5lUHJvcGVydHkuZjtcblxudmFyIFVOU0NPUEFCTEVTID0gd2VsbEtub3duU3ltYm9sJGMoJ3Vuc2NvcGFibGVzJyk7XG52YXIgQXJyYXlQcm90b3R5cGUkMSA9IEFycmF5LnByb3RvdHlwZTtcblxuLy8gQXJyYXkucHJvdG90eXBlW0BAdW5zY29wYWJsZXNdXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQHVuc2NvcGFibGVzXG5pZiAoQXJyYXlQcm90b3R5cGUkMVtVTlNDT1BBQkxFU10gPT0gdW5kZWZpbmVkKSB7XG4gIGRlZmluZVByb3BlcnR5JDMoQXJyYXlQcm90b3R5cGUkMSwgVU5TQ09QQUJMRVMsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgdmFsdWU6IGNyZWF0ZSQxKG51bGwpXG4gIH0pO1xufVxuXG4vLyBhZGQgYSBrZXkgdG8gQXJyYXkucHJvdG90eXBlW0BAdW5zY29wYWJsZXNdXG52YXIgYWRkVG9VbnNjb3BhYmxlcyQxID0gZnVuY3Rpb24gKGtleSkge1xuICBBcnJheVByb3RvdHlwZSQxW1VOU0NPUEFCTEVTXVtrZXldID0gdHJ1ZTtcbn07XG5cbnZhciBpdGVyYXRvcnMgPSB7fTtcblxudmFyIHVuY3VycnlUaGlzJDYgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGlzQ2FsbGFibGUkZSA9IGlzQ2FsbGFibGUkaztcbnZhciBzdG9yZSQxID0gc2hhcmVkU3RvcmU7XG5cbnZhciBmdW5jdGlvblRvU3RyaW5nID0gdW5jdXJyeVRoaXMkNihGdW5jdGlvbi50b1N0cmluZyk7XG5cbi8vIHRoaXMgaGVscGVyIGJyb2tlbiBpbiBgY29yZS1qc0AzLjQuMS0zLjQuNGAsIHNvIHdlIGNhbid0IHVzZSBgc2hhcmVkYCBoZWxwZXJcbmlmICghaXNDYWxsYWJsZSRlKHN0b3JlJDEuaW5zcGVjdFNvdXJjZSkpIHtcbiAgc3RvcmUkMS5pbnNwZWN0U291cmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uVG9TdHJpbmcoaXQpO1xuICB9O1xufVxuXG52YXIgaW5zcGVjdFNvdXJjZSQ0ID0gc3RvcmUkMS5pbnNwZWN0U291cmNlO1xuXG52YXIgZ2xvYmFsJGMgPSBnbG9iYWwkajtcbnZhciBpc0NhbGxhYmxlJGQgPSBpc0NhbGxhYmxlJGs7XG52YXIgaW5zcGVjdFNvdXJjZSQzID0gaW5zcGVjdFNvdXJjZSQ0O1xuXG52YXIgV2Vha01hcCQxID0gZ2xvYmFsJGMuV2Vha01hcDtcblxudmFyIG5hdGl2ZVdlYWtNYXAgPSBpc0NhbGxhYmxlJGQoV2Vha01hcCQxKSAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoaW5zcGVjdFNvdXJjZSQzKFdlYWtNYXAkMSkpO1xuXG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDMgPSBmdW5jdGlvbiAoYml0bWFwLCB2YWx1ZSkge1xuICByZXR1cm4ge1xuICAgIGVudW1lcmFibGU6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlOiAhKGJpdG1hcCAmIDQpLFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9O1xufTtcblxudmFyIERFU0NSSVBUT1JTJDUgPSBkZXNjcmlwdG9ycztcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQzID0gb2JqZWN0RGVmaW5lUHJvcGVydHk7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDIgPSBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkMztcblxudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ0ID0gREVTQ1JJUFRPUlMkNSA/IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5TW9kdWxlJDMuZihvYmplY3QsIGtleSwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDIoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59O1xuXG52YXIgTkFUSVZFX1dFQUtfTUFQID0gbmF0aXZlV2Vha01hcDtcbnZhciBnbG9iYWwkYiA9IGdsb2JhbCRqO1xudmFyIHVuY3VycnlUaGlzJDUgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGlzT2JqZWN0JDIgPSBpc09iamVjdCQ3O1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQzID0gY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDQ7XG52YXIgaGFzT3duJDggPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIHNoYXJlZCA9IHNoYXJlZFN0b3JlO1xudmFyIHNoYXJlZEtleSQxID0gc2hhcmVkS2V5JDM7XG52YXIgaGlkZGVuS2V5cyQxID0gaGlkZGVuS2V5cyQ0O1xuXG52YXIgT0JKRUNUX0FMUkVBRFlfSU5JVElBTElaRUQgPSAnT2JqZWN0IGFscmVhZHkgaW5pdGlhbGl6ZWQnO1xudmFyIFR5cGVFcnJvciQyID0gZ2xvYmFsJGIuVHlwZUVycm9yO1xudmFyIFdlYWtNYXAgPSBnbG9iYWwkYi5XZWFrTWFwO1xudmFyIHNldCQxLCBnZXQsIGhhcztcblxudmFyIGVuZm9yY2UgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGhhcyhpdCkgPyBnZXQoaXQpIDogc2V0JDEoaXQsIHt9KTtcbn07XG5cbnZhciBnZXR0ZXJGb3IgPSBmdW5jdGlvbiAoVFlQRSkge1xuICByZXR1cm4gZnVuY3Rpb24gKGl0KSB7XG4gICAgdmFyIHN0YXRlO1xuICAgIGlmICghaXNPYmplY3QkMihpdCkgfHwgKHN0YXRlID0gZ2V0KGl0KSkudHlwZSAhPT0gVFlQRSkge1xuICAgICAgdGhyb3cgVHlwZUVycm9yJDIoJ0luY29tcGF0aWJsZSByZWNlaXZlciwgJyArIFRZUEUgKyAnIHJlcXVpcmVkJyk7XG4gICAgfSByZXR1cm4gc3RhdGU7XG4gIH07XG59O1xuXG5pZiAoTkFUSVZFX1dFQUtfTUFQIHx8IHNoYXJlZC5zdGF0ZSkge1xuICB2YXIgc3RvcmUgPSBzaGFyZWQuc3RhdGUgfHwgKHNoYXJlZC5zdGF0ZSA9IG5ldyBXZWFrTWFwKCkpO1xuICB2YXIgd21nZXQgPSB1bmN1cnJ5VGhpcyQ1KHN0b3JlLmdldCk7XG4gIHZhciB3bWhhcyA9IHVuY3VycnlUaGlzJDUoc3RvcmUuaGFzKTtcbiAgdmFyIHdtc2V0ID0gdW5jdXJyeVRoaXMkNShzdG9yZS5zZXQpO1xuICBzZXQkMSA9IGZ1bmN0aW9uIChpdCwgbWV0YWRhdGEpIHtcbiAgICBpZiAod21oYXMoc3RvcmUsIGl0KSkgdGhyb3cgbmV3IFR5cGVFcnJvciQyKE9CSkVDVF9BTFJFQURZX0lOSVRJQUxJWkVEKTtcbiAgICBtZXRhZGF0YS5mYWNhZGUgPSBpdDtcbiAgICB3bXNldChzdG9yZSwgaXQsIG1ldGFkYXRhKTtcbiAgICByZXR1cm4gbWV0YWRhdGE7XG4gIH07XG4gIGdldCA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiB3bWdldChzdG9yZSwgaXQpIHx8IHt9O1xuICB9O1xuICBoYXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gd21oYXMoc3RvcmUsIGl0KTtcbiAgfTtcbn0gZWxzZSB7XG4gIHZhciBTVEFURSA9IHNoYXJlZEtleSQxKCdzdGF0ZScpO1xuICBoaWRkZW5LZXlzJDFbU1RBVEVdID0gdHJ1ZTtcbiAgc2V0JDEgPSBmdW5jdGlvbiAoaXQsIG1ldGFkYXRhKSB7XG4gICAgaWYgKGhhc093biQ4KGl0LCBTVEFURSkpIHRocm93IG5ldyBUeXBlRXJyb3IkMihPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCk7XG4gICAgbWV0YWRhdGEuZmFjYWRlID0gaXQ7XG4gICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDMoaXQsIFNUQVRFLCBtZXRhZGF0YSk7XG4gICAgcmV0dXJuIG1ldGFkYXRhO1xuICB9O1xuICBnZXQgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gaGFzT3duJDgoaXQsIFNUQVRFKSA/IGl0W1NUQVRFXSA6IHt9O1xuICB9O1xuICBoYXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gaGFzT3duJDgoaXQsIFNUQVRFKTtcbiAgfTtcbn1cblxudmFyIGludGVybmFsU3RhdGUgPSB7XG4gIHNldDogc2V0JDEsXG4gIGdldDogZ2V0LFxuICBoYXM6IGhhcyxcbiAgZW5mb3JjZTogZW5mb3JjZSxcbiAgZ2V0dGVyRm9yOiBnZXR0ZXJGb3Jcbn07XG5cbnZhciBvYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSB7fTtcblxudmFyIG9iamVjdFByb3BlcnR5SXNFbnVtZXJhYmxlID0ge307XG5cbnZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciQyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuLy8gTmFzaG9ybiB+IEpESzggYnVnXG52YXIgTkFTSE9STl9CVUcgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMiAmJiAhJHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoeyAxOiAyIH0sIDEpO1xuXG4vLyBgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZWAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5wcm90b3R5cGUucHJvcGVydHlpc2VudW1lcmFibGVcbm9iamVjdFByb3BlcnR5SXNFbnVtZXJhYmxlLmYgPSBOQVNIT1JOX0JVRyA/IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKFYpIHtcbiAgdmFyIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMih0aGlzLCBWKTtcbiAgcmV0dXJuICEhZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLmVudW1lcmFibGU7XG59IDogJHByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG52YXIgREVTQ1JJUFRPUlMkNCA9IGRlc2NyaXB0b3JzO1xudmFyIGNhbGwkYSA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSA9IG9iamVjdFByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQxID0gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDM7XG52YXIgdG9JbmRleGVkT2JqZWN0JDEgPSB0b0luZGV4ZWRPYmplY3QkNTtcbnZhciB0b1Byb3BlcnR5S2V5ID0gdG9Qcm9wZXJ0eUtleSQyO1xudmFyIGhhc093biQ3ID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBJRThfRE9NX0RFRklORSA9IGllOERvbURlZmluZTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbi8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5ZGVzY3JpcHRvclxub2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLmYgPSBERVNDUklQVE9SUyQ0ID8gJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKSB7XG4gIE8gPSB0b0luZGV4ZWRPYmplY3QkMShPKTtcbiAgUCA9IHRvUHJvcGVydHlLZXkoUCk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoaGFzT3duJDcoTywgUCkpIHJldHVybiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkMSghY2FsbCRhKHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlLmYsIE8sIFApLCBPW1BdKTtcbn07XG5cbnZhciBtYWtlQnVpbHRJbiQyID0ge2V4cG9ydHM6IHt9fTtcblxudmFyIERFU0NSSVBUT1JTJDMgPSBkZXNjcmlwdG9ycztcbnZhciBoYXNPd24kNiA9IGhhc093blByb3BlcnR5XzE7XG5cbnZhciBGdW5jdGlvblByb3RvdHlwZSQxID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG52YXIgZ2V0RGVzY3JpcHRvciA9IERFU0NSSVBUT1JTJDMgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxudmFyIEVYSVNUUyA9IGhhc093biQ2KEZ1bmN0aW9uUHJvdG90eXBlJDEsICduYW1lJyk7XG4vLyBhZGRpdGlvbmFsIHByb3RlY3Rpb24gZnJvbSBtaW5pZmllZCAvIG1hbmdsZWQgLyBkcm9wcGVkIGZ1bmN0aW9uIG5hbWVzXG52YXIgUFJPUEVSID0gRVhJU1RTICYmIChmdW5jdGlvbiBzb21ldGhpbmcoKSB7IC8qIGVtcHR5ICovIH0pLm5hbWUgPT09ICdzb21ldGhpbmcnO1xudmFyIENPTkZJR1VSQUJMRSA9IEVYSVNUUyAmJiAoIURFU0NSSVBUT1JTJDMgfHwgKERFU0NSSVBUT1JTJDMgJiYgZ2V0RGVzY3JpcHRvcihGdW5jdGlvblByb3RvdHlwZSQxLCAnbmFtZScpLmNvbmZpZ3VyYWJsZSkpO1xuXG52YXIgZnVuY3Rpb25OYW1lID0ge1xuICBFWElTVFM6IEVYSVNUUyxcbiAgUFJPUEVSOiBQUk9QRVIsXG4gIENPTkZJR1VSQUJMRTogQ09ORklHVVJBQkxFXG59O1xuXG52YXIgZmFpbHMkNiA9IGZhaWxzJGQ7XG52YXIgaXNDYWxsYWJsZSRjID0gaXNDYWxsYWJsZSRrO1xudmFyIGhhc093biQ1ID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBERVNDUklQVE9SUyQyID0gZGVzY3JpcHRvcnM7XG52YXIgQ09ORklHVVJBQkxFX0ZVTkNUSU9OX05BTUUkMSA9IGZ1bmN0aW9uTmFtZS5DT05GSUdVUkFCTEU7XG52YXIgaW5zcGVjdFNvdXJjZSQyID0gaW5zcGVjdFNvdXJjZSQ0O1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUkMiA9IGludGVybmFsU3RhdGU7XG5cbnZhciBlbmZvcmNlSW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUkMi5lbmZvcmNlO1xudmFyIGdldEludGVybmFsU3RhdGUkMSA9IEludGVybmFsU3RhdGVNb2R1bGUkMi5nZXQ7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gc2FmZVxudmFyIGRlZmluZVByb3BlcnR5JDIgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbnZhciBDT05GSUdVUkFCTEVfTEVOR1RIID0gREVTQ1JJUFRPUlMkMiAmJiAhZmFpbHMkNihmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eSQyKGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSwgJ2xlbmd0aCcsIHsgdmFsdWU6IDggfSkubGVuZ3RoICE9PSA4O1xufSk7XG5cbnZhciBURU1QTEFURSA9IFN0cmluZyhTdHJpbmcpLnNwbGl0KCdTdHJpbmcnKTtcblxudmFyIG1ha2VCdWlsdEluJDEgPSBtYWtlQnVpbHRJbiQyLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUsIG5hbWUsIG9wdGlvbnMpIHtcbiAgaWYgKFN0cmluZyhuYW1lKS5zbGljZSgwLCA3KSA9PT0gJ1N5bWJvbCgnKSB7XG4gICAgbmFtZSA9ICdbJyArIFN0cmluZyhuYW1lKS5yZXBsYWNlKC9eU3ltYm9sXFwoKFteKV0qKVxcKS8sICckMScpICsgJ10nO1xuICB9XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZ2V0dGVyKSBuYW1lID0gJ2dldCAnICsgbmFtZTtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5zZXR0ZXIpIG5hbWUgPSAnc2V0ICcgKyBuYW1lO1xuICBpZiAoIWhhc093biQ1KHZhbHVlLCAnbmFtZScpIHx8IChDT05GSUdVUkFCTEVfRlVOQ1RJT05fTkFNRSQxICYmIHZhbHVlLm5hbWUgIT09IG5hbWUpKSB7XG4gICAgaWYgKERFU0NSSVBUT1JTJDIpIGRlZmluZVByb3BlcnR5JDIodmFsdWUsICduYW1lJywgeyB2YWx1ZTogbmFtZSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xuICAgIGVsc2UgdmFsdWUubmFtZSA9IG5hbWU7XG4gIH1cbiAgaWYgKENPTkZJR1VSQUJMRV9MRU5HVEggJiYgb3B0aW9ucyAmJiBoYXNPd24kNShvcHRpb25zLCAnYXJpdHknKSAmJiB2YWx1ZS5sZW5ndGggIT09IG9wdGlvbnMuYXJpdHkpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eSQyKHZhbHVlLCAnbGVuZ3RoJywgeyB2YWx1ZTogb3B0aW9ucy5hcml0eSB9KTtcbiAgfVxuICB0cnkge1xuICAgIGlmIChvcHRpb25zICYmIGhhc093biQ1KG9wdGlvbnMsICdjb25zdHJ1Y3RvcicpICYmIG9wdGlvbnMuY29uc3RydWN0b3IpIHtcbiAgICAgIGlmIChERVNDUklQVE9SUyQyKSBkZWZpbmVQcm9wZXJ0eSQyKHZhbHVlLCAncHJvdG90eXBlJywgeyB3cml0YWJsZTogZmFsc2UgfSk7XG4gICAgLy8gaW4gVjggfiBDaHJvbWUgNTMsIHByb3RvdHlwZXMgb2Ygc29tZSBtZXRob2RzLCBsaWtlIGBBcnJheS5wcm90b3R5cGUudmFsdWVzYCwgYXJlIG5vbi13cml0YWJsZVxuICAgIH0gZWxzZSBpZiAodmFsdWUucHJvdG90eXBlKSB2YWx1ZS5wcm90b3R5cGUgPSB1bmRlZmluZWQ7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgdmFyIHN0YXRlID0gZW5mb3JjZUludGVybmFsU3RhdGUodmFsdWUpO1xuICBpZiAoIWhhc093biQ1KHN0YXRlLCAnc291cmNlJykpIHtcbiAgICBzdGF0ZS5zb3VyY2UgPSBURU1QTEFURS5qb2luKHR5cGVvZiBuYW1lID09ICdzdHJpbmcnID8gbmFtZSA6ICcnKTtcbiAgfSByZXR1cm4gdmFsdWU7XG59O1xuXG4vLyBhZGQgZmFrZSBGdW5jdGlvbiN0b1N0cmluZyBmb3IgY29ycmVjdCB3b3JrIHdyYXBwZWQgbWV0aG9kcyAvIGNvbnN0cnVjdG9ycyB3aXRoIG1ldGhvZHMgbGlrZSBMb0Rhc2ggaXNOYXRpdmVcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1leHRlbmQtbmF0aXZlIC0tIHJlcXVpcmVkXG5GdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBtYWtlQnVpbHRJbiQxKGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gaXNDYWxsYWJsZSRjKHRoaXMpICYmIGdldEludGVybmFsU3RhdGUkMSh0aGlzKS5zb3VyY2UgfHwgaW5zcGVjdFNvdXJjZSQyKHRoaXMpO1xufSwgJ3RvU3RyaW5nJyk7XG5cbnZhciBpc0NhbGxhYmxlJGIgPSBpc0NhbGxhYmxlJGs7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUkMiA9IG9iamVjdERlZmluZVByb3BlcnR5O1xudmFyIG1ha2VCdWlsdEluID0gbWFrZUJ1aWx0SW4kMi5leHBvcnRzO1xudmFyIGRlZmluZUdsb2JhbFByb3BlcnR5JDEgPSBkZWZpbmVHbG9iYWxQcm9wZXJ0eSQzO1xuXG52YXIgZGVmaW5lQnVpbHRJbiQ2ID0gZnVuY3Rpb24gKE8sIGtleSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG4gIHZhciBzaW1wbGUgPSBvcHRpb25zLmVudW1lcmFibGU7XG4gIHZhciBuYW1lID0gb3B0aW9ucy5uYW1lICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm5hbWUgOiBrZXk7XG4gIGlmIChpc0NhbGxhYmxlJGIodmFsdWUpKSBtYWtlQnVpbHRJbih2YWx1ZSwgbmFtZSwgb3B0aW9ucyk7XG4gIGlmIChvcHRpb25zLmdsb2JhbCkge1xuICAgIGlmIChzaW1wbGUpIE9ba2V5XSA9IHZhbHVlO1xuICAgIGVsc2UgZGVmaW5lR2xvYmFsUHJvcGVydHkkMShrZXksIHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFvcHRpb25zLnVuc2FmZSkgZGVsZXRlIE9ba2V5XTtcbiAgICAgIGVsc2UgaWYgKE9ba2V5XSkgc2ltcGxlID0gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gICAgaWYgKHNpbXBsZSkgT1trZXldID0gdmFsdWU7XG4gICAgZWxzZSBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQyLmYoTywga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogIW9wdGlvbnMubm9uQ29uZmlndXJhYmxlLFxuICAgICAgd3JpdGFibGU6ICFvcHRpb25zLm5vbldyaXRhYmxlXG4gICAgfSk7XG4gIH0gcmV0dXJuIE87XG59O1xuXG52YXIgb2JqZWN0R2V0T3duUHJvcGVydHlOYW1lcyA9IHt9O1xuXG52YXIgaW50ZXJuYWxPYmplY3RLZXlzID0gb2JqZWN0S2V5c0ludGVybmFsO1xudmFyIGVudW1CdWdLZXlzID0gZW51bUJ1Z0tleXMkMztcblxudmFyIGhpZGRlbktleXMgPSBlbnVtQnVnS2V5cy5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTtcblxuLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5bmFtZXNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eW5hbWVzIC0tIHNhZmVcbm9iamVjdEdldE93blByb3BlcnR5TmFtZXMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTykge1xuICByZXR1cm4gaW50ZXJuYWxPYmplY3RLZXlzKE8sIGhpZGRlbktleXMpO1xufTtcblxudmFyIG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyA9IHt9O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlzeW1ib2xzIC0tIHNhZmVcbm9iamVjdEdldE93blByb3BlcnR5U3ltYm9scy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxudmFyIGdldEJ1aWx0SW4kNCA9IGdldEJ1aWx0SW4kODtcbnZhciB1bmN1cnJ5VGhpcyQ0ID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlID0gb2JqZWN0R2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgYW5PYmplY3QkOCA9IGFuT2JqZWN0JGM7XG5cbnZhciBjb25jYXQgPSB1bmN1cnJ5VGhpcyQ0KFtdLmNvbmNhdCk7XG5cbi8vIGFsbCBvYmplY3Qga2V5cywgaW5jbHVkZXMgbm9uLWVudW1lcmFibGUgYW5kIHN5bWJvbHNcbnZhciBvd25LZXlzJDEgPSBnZXRCdWlsdEluJDQoJ1JlZmxlY3QnLCAnb3duS2V5cycpIHx8IGZ1bmN0aW9uIG93bktleXMoaXQpIHtcbiAgdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlLmYoYW5PYmplY3QkOChpdCkpO1xuICB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlLmY7XG4gIHJldHVybiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBjb25jYXQoa2V5cywgZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KSkgOiBrZXlzO1xufTtcblxudmFyIGhhc093biQ0ID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBvd25LZXlzID0gb3duS2V5cyQxO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZSA9IG9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQxID0gb2JqZWN0RGVmaW5lUHJvcGVydHk7XG5cbnZhciBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzJDEgPSBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UsIGV4Y2VwdGlvbnMpIHtcbiAgdmFyIGtleXMgPSBvd25LZXlzKHNvdXJjZSk7XG4gIHZhciBkZWZpbmVQcm9wZXJ0eSA9IGRlZmluZVByb3BlcnR5TW9kdWxlJDEuZjtcbiAgdmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZS5mO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBpZiAoIWhhc093biQ0KHRhcmdldCwga2V5KSAmJiAhKGV4Y2VwdGlvbnMgJiYgaGFzT3duJDQoZXhjZXB0aW9ucywga2V5KSkpIHtcbiAgICAgIGRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBmYWlscyQ1ID0gZmFpbHMkZDtcbnZhciBpc0NhbGxhYmxlJGEgPSBpc0NhbGxhYmxlJGs7XG5cbnZhciByZXBsYWNlbWVudCA9IC8jfFxcLnByb3RvdHlwZVxcLi87XG5cbnZhciBpc0ZvcmNlZCQyID0gZnVuY3Rpb24gKGZlYXR1cmUsIGRldGVjdGlvbikge1xuICB2YXIgdmFsdWUgPSBkYXRhW25vcm1hbGl6ZShmZWF0dXJlKV07XG4gIHJldHVybiB2YWx1ZSA9PSBQT0xZRklMTCA/IHRydWVcbiAgICA6IHZhbHVlID09IE5BVElWRSA/IGZhbHNlXG4gICAgOiBpc0NhbGxhYmxlJGEoZGV0ZWN0aW9uKSA/IGZhaWxzJDUoZGV0ZWN0aW9uKVxuICAgIDogISFkZXRlY3Rpb247XG59O1xuXG52YXIgbm9ybWFsaXplID0gaXNGb3JjZWQkMi5ub3JtYWxpemUgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gIHJldHVybiBTdHJpbmcoc3RyaW5nKS5yZXBsYWNlKHJlcGxhY2VtZW50LCAnLicpLnRvTG93ZXJDYXNlKCk7XG59O1xuXG52YXIgZGF0YSA9IGlzRm9yY2VkJDIuZGF0YSA9IHt9O1xudmFyIE5BVElWRSA9IGlzRm9yY2VkJDIuTkFUSVZFID0gJ04nO1xudmFyIFBPTFlGSUxMID0gaXNGb3JjZWQkMi5QT0xZRklMTCA9ICdQJztcblxudmFyIGlzRm9yY2VkXzEgPSBpc0ZvcmNlZCQyO1xuXG52YXIgZ2xvYmFsJGEgPSBnbG9iYWwkajtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMSA9IG9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvci5mO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQyID0gY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDQ7XG52YXIgZGVmaW5lQnVpbHRJbiQ1ID0gZGVmaW5lQnVpbHRJbiQ2O1xudmFyIGRlZmluZUdsb2JhbFByb3BlcnR5ID0gZGVmaW5lR2xvYmFsUHJvcGVydHkkMztcbnZhciBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzID0gY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyQxO1xudmFyIGlzRm9yY2VkJDEgPSBpc0ZvcmNlZF8xO1xuXG4vKlxuICBvcHRpb25zLnRhcmdldCAgICAgICAgIC0gbmFtZSBvZiB0aGUgdGFyZ2V0IG9iamVjdFxuICBvcHRpb25zLmdsb2JhbCAgICAgICAgIC0gdGFyZ2V0IGlzIHRoZSBnbG9iYWwgb2JqZWN0XG4gIG9wdGlvbnMuc3RhdCAgICAgICAgICAgLSBleHBvcnQgYXMgc3RhdGljIG1ldGhvZHMgb2YgdGFyZ2V0XG4gIG9wdGlvbnMucHJvdG8gICAgICAgICAgLSBleHBvcnQgYXMgcHJvdG90eXBlIG1ldGhvZHMgb2YgdGFyZ2V0XG4gIG9wdGlvbnMucmVhbCAgICAgICAgICAgLSByZWFsIHByb3RvdHlwZSBtZXRob2QgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuICBvcHRpb25zLmZvcmNlZCAgICAgICAgIC0gZXhwb3J0IGV2ZW4gaWYgdGhlIG5hdGl2ZSBmZWF0dXJlIGlzIGF2YWlsYWJsZVxuICBvcHRpb25zLmJpbmQgICAgICAgICAgIC0gYmluZCBtZXRob2RzIHRvIHRoZSB0YXJnZXQsIHJlcXVpcmVkIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cbiAgb3B0aW9ucy53cmFwICAgICAgICAgICAtIHdyYXAgY29uc3RydWN0b3JzIHRvIHByZXZlbnRpbmcgZ2xvYmFsIHBvbGx1dGlvbiwgcmVxdWlyZWQgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuICBvcHRpb25zLnVuc2FmZSAgICAgICAgIC0gdXNlIHRoZSBzaW1wbGUgYXNzaWdubWVudCBvZiBwcm9wZXJ0eSBpbnN0ZWFkIG9mIGRlbGV0ZSArIGRlZmluZVByb3BlcnR5XG4gIG9wdGlvbnMuc2hhbSAgICAgICAgICAgLSBhZGQgYSBmbGFnIHRvIG5vdCBjb21wbGV0ZWx5IGZ1bGwgcG9seWZpbGxzXG4gIG9wdGlvbnMuZW51bWVyYWJsZSAgICAgLSBleHBvcnQgYXMgZW51bWVyYWJsZSBwcm9wZXJ0eVxuICBvcHRpb25zLmRvbnRDYWxsR2V0U2V0IC0gcHJldmVudCBjYWxsaW5nIGEgZ2V0dGVyIG9uIHRhcmdldFxuICBvcHRpb25zLm5hbWUgICAgICAgICAgIC0gdGhlIC5uYW1lIG9mIHRoZSBmdW5jdGlvbiBpZiBpdCBkb2VzIG5vdCBtYXRjaCB0aGUga2V5XG4qL1xudmFyIF9leHBvcnQgPSBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XG4gIHZhciBUQVJHRVQgPSBvcHRpb25zLnRhcmdldDtcbiAgdmFyIEdMT0JBTCA9IG9wdGlvbnMuZ2xvYmFsO1xuICB2YXIgU1RBVElDID0gb3B0aW9ucy5zdGF0O1xuICB2YXIgRk9SQ0VELCB0YXJnZXQsIGtleSwgdGFyZ2V0UHJvcGVydHksIHNvdXJjZVByb3BlcnR5LCBkZXNjcmlwdG9yO1xuICBpZiAoR0xPQkFMKSB7XG4gICAgdGFyZ2V0ID0gZ2xvYmFsJGE7XG4gIH0gZWxzZSBpZiAoU1RBVElDKSB7XG4gICAgdGFyZ2V0ID0gZ2xvYmFsJGFbVEFSR0VUXSB8fCBkZWZpbmVHbG9iYWxQcm9wZXJ0eShUQVJHRVQsIHt9KTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQgPSAoZ2xvYmFsJGFbVEFSR0VUXSB8fCB7fSkucHJvdG90eXBlO1xuICB9XG4gIGlmICh0YXJnZXQpIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgIHNvdXJjZVByb3BlcnR5ID0gc291cmNlW2tleV07XG4gICAgaWYgKG9wdGlvbnMuZG9udENhbGxHZXRTZXQpIHtcbiAgICAgIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMSh0YXJnZXQsIGtleSk7XG4gICAgICB0YXJnZXRQcm9wZXJ0eSA9IGRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci52YWx1ZTtcbiAgICB9IGVsc2UgdGFyZ2V0UHJvcGVydHkgPSB0YXJnZXRba2V5XTtcbiAgICBGT1JDRUQgPSBpc0ZvcmNlZCQxKEdMT0JBTCA/IGtleSA6IFRBUkdFVCArIChTVEFUSUMgPyAnLicgOiAnIycpICsga2V5LCBvcHRpb25zLmZvcmNlZCk7XG4gICAgLy8gY29udGFpbmVkIGluIHRhcmdldFxuICAgIGlmICghRk9SQ0VEICYmIHRhcmdldFByb3BlcnR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0eXBlb2Ygc291cmNlUHJvcGVydHkgPT0gdHlwZW9mIHRhcmdldFByb3BlcnR5KSBjb250aW51ZTtcbiAgICAgIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMoc291cmNlUHJvcGVydHksIHRhcmdldFByb3BlcnR5KTtcbiAgICB9XG4gICAgLy8gYWRkIGEgZmxhZyB0byBub3QgY29tcGxldGVseSBmdWxsIHBvbHlmaWxsc1xuICAgIGlmIChvcHRpb25zLnNoYW0gfHwgKHRhcmdldFByb3BlcnR5ICYmIHRhcmdldFByb3BlcnR5LnNoYW0pKSB7XG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMihzb3VyY2VQcm9wZXJ0eSwgJ3NoYW0nLCB0cnVlKTtcbiAgICB9XG4gICAgZGVmaW5lQnVpbHRJbiQ1KHRhcmdldCwga2V5LCBzb3VyY2VQcm9wZXJ0eSwgb3B0aW9ucyk7XG4gIH1cbn07XG5cbnZhciBmYWlscyQ0ID0gZmFpbHMkZDtcblxudmFyIGNvcnJlY3RQcm90b3R5cGVHZXR0ZXIgPSAhZmFpbHMkNChmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEYoKSB7IC8qIGVtcHR5ICovIH1cbiAgRi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBudWxsO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0cHJvdG90eXBlb2YgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZihuZXcgRigpKSAhPT0gRi5wcm90b3R5cGU7XG59KTtcblxudmFyIGhhc093biQzID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBpc0NhbGxhYmxlJDkgPSBpc0NhbGxhYmxlJGs7XG52YXIgdG9PYmplY3QgPSB0b09iamVjdCQyO1xudmFyIHNoYXJlZEtleSA9IHNoYXJlZEtleSQzO1xudmFyIENPUlJFQ1RfUFJPVE9UWVBFX0dFVFRFUiA9IGNvcnJlY3RQcm90b3R5cGVHZXR0ZXI7XG5cbnZhciBJRV9QUk9UTyA9IHNoYXJlZEtleSgnSUVfUFJPVE8nKTtcbnZhciAkT2JqZWN0JDEgPSBPYmplY3Q7XG52YXIgT2JqZWN0UHJvdG90eXBlID0gJE9iamVjdCQxLnByb3RvdHlwZTtcblxuLy8gYE9iamVjdC5nZXRQcm90b3R5cGVPZmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRwcm90b3R5cGVvZlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldHByb3RvdHlwZW9mIC0tIHNhZmVcbnZhciBvYmplY3RHZXRQcm90b3R5cGVPZiA9IENPUlJFQ1RfUFJPVE9UWVBFX0dFVFRFUiA/ICRPYmplY3QkMS5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIChPKSB7XG4gIHZhciBvYmplY3QgPSB0b09iamVjdChPKTtcbiAgaWYgKGhhc093biQzKG9iamVjdCwgSUVfUFJPVE8pKSByZXR1cm4gb2JqZWN0W0lFX1BST1RPXTtcbiAgdmFyIGNvbnN0cnVjdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuICBpZiAoaXNDYWxsYWJsZSQ5KGNvbnN0cnVjdG9yKSAmJiBvYmplY3QgaW5zdGFuY2VvZiBjb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBjb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIH0gcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mICRPYmplY3QkMSA/IE9iamVjdFByb3RvdHlwZSA6IG51bGw7XG59O1xuXG52YXIgZmFpbHMkMyA9IGZhaWxzJGQ7XG52YXIgaXNDYWxsYWJsZSQ4ID0gaXNDYWxsYWJsZSRrO1xudmFyIGdldFByb3RvdHlwZU9mJDEgPSBvYmplY3RHZXRQcm90b3R5cGVPZjtcbnZhciBkZWZpbmVCdWlsdEluJDQgPSBkZWZpbmVCdWlsdEluJDY7XG52YXIgd2VsbEtub3duU3ltYm9sJGIgPSB3ZWxsS25vd25TeW1ib2wkZTtcblxudmFyIElURVJBVE9SJDUgPSB3ZWxsS25vd25TeW1ib2wkYignaXRlcmF0b3InKTtcbnZhciBCVUdHWV9TQUZBUklfSVRFUkFUT1JTJDEgPSBmYWxzZTtcblxuLy8gYCVJdGVyYXRvclByb3RvdHlwZSVgIG9iamVjdFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0laXRlcmF0b3Jwcm90b3R5cGUlLW9iamVjdFxudmFyIEl0ZXJhdG9yUHJvdG90eXBlJDIsIFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZSwgYXJyYXlJdGVyYXRvcjtcblxuLyogZXNsaW50LWRpc2FibGUgZXMteC9uby1hcnJheS1wcm90b3R5cGUta2V5cyAtLSBzYWZlICovXG5pZiAoW10ua2V5cykge1xuICBhcnJheUl0ZXJhdG9yID0gW10ua2V5cygpO1xuICAvLyBTYWZhcmkgOCBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbiAgaWYgKCEoJ25leHQnIGluIGFycmF5SXRlcmF0b3IpKSBCVUdHWV9TQUZBUklfSVRFUkFUT1JTJDEgPSB0cnVlO1xuICBlbHNlIHtcbiAgICBQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZiQxKGdldFByb3RvdHlwZU9mJDEoYXJyYXlJdGVyYXRvcikpO1xuICAgIGlmIChQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUpIEl0ZXJhdG9yUHJvdG90eXBlJDIgPSBQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cbn1cblxudmFyIE5FV19JVEVSQVRPUl9QUk9UT1RZUEUgPSBJdGVyYXRvclByb3RvdHlwZSQyID09IHVuZGVmaW5lZCB8fCBmYWlscyQzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRlc3QgPSB7fTtcbiAgLy8gRkY0NC0gbGVnYWN5IGl0ZXJhdG9ycyBjYXNlXG4gIHJldHVybiBJdGVyYXRvclByb3RvdHlwZSQyW0lURVJBVE9SJDVdLmNhbGwodGVzdCkgIT09IHRlc3Q7XG59KTtcblxuaWYgKE5FV19JVEVSQVRPUl9QUk9UT1RZUEUpIEl0ZXJhdG9yUHJvdG90eXBlJDIgPSB7fTtcblxuLy8gYCVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSVpdGVyYXRvcnByb3RvdHlwZSUtQEBpdGVyYXRvclxuaWYgKCFpc0NhbGxhYmxlJDgoSXRlcmF0b3JQcm90b3R5cGUkMltJVEVSQVRPUiQ1XSkpIHtcbiAgZGVmaW5lQnVpbHRJbiQ0KEl0ZXJhdG9yUHJvdG90eXBlJDIsIElURVJBVE9SJDUsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG59XG5cbnZhciBpdGVyYXRvcnNDb3JlID0ge1xuICBJdGVyYXRvclByb3RvdHlwZTogSXRlcmF0b3JQcm90b3R5cGUkMixcbiAgQlVHR1lfU0FGQVJJX0lURVJBVE9SUzogQlVHR1lfU0FGQVJJX0lURVJBVE9SUyQxXG59O1xuXG52YXIgZGVmaW5lUHJvcGVydHkkMSA9IG9iamVjdERlZmluZVByb3BlcnR5LmY7XG52YXIgaGFzT3duJDIgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIHdlbGxLbm93blN5bWJvbCRhID0gd2VsbEtub3duU3ltYm9sJGU7XG5cbnZhciBUT19TVFJJTkdfVEFHJDMgPSB3ZWxsS25vd25TeW1ib2wkYSgndG9TdHJpbmdUYWcnKTtcblxudmFyIHNldFRvU3RyaW5nVGFnJDMgPSBmdW5jdGlvbiAodGFyZ2V0LCBUQUcsIFNUQVRJQykge1xuICBpZiAodGFyZ2V0ICYmICFTVEFUSUMpIHRhcmdldCA9IHRhcmdldC5wcm90b3R5cGU7XG4gIGlmICh0YXJnZXQgJiYgIWhhc093biQyKHRhcmdldCwgVE9fU1RSSU5HX1RBRyQzKSkge1xuICAgIGRlZmluZVByb3BlcnR5JDEodGFyZ2V0LCBUT19TVFJJTkdfVEFHJDMsIHsgY29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogVEFHIH0pO1xuICB9XG59O1xuXG52YXIgSXRlcmF0b3JQcm90b3R5cGUkMSA9IGl0ZXJhdG9yc0NvcmUuSXRlcmF0b3JQcm90b3R5cGU7XG52YXIgY3JlYXRlID0gb2JqZWN0Q3JlYXRlO1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQzO1xudmFyIHNldFRvU3RyaW5nVGFnJDIgPSBzZXRUb1N0cmluZ1RhZyQzO1xudmFyIEl0ZXJhdG9ycyQ0ID0gaXRlcmF0b3JzO1xuXG52YXIgcmV0dXJuVGhpcyQxID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxudmFyIGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IkMSA9IGZ1bmN0aW9uIChJdGVyYXRvckNvbnN0cnVjdG9yLCBOQU1FLCBuZXh0LCBFTlVNRVJBQkxFX05FWFQpIHtcbiAgdmFyIFRPX1NUUklOR19UQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIEl0ZXJhdG9yQ29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlJDEsIHsgbmV4dDogY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKCshRU5VTUVSQUJMRV9ORVhULCBuZXh0KSB9KTtcbiAgc2V0VG9TdHJpbmdUYWckMihJdGVyYXRvckNvbnN0cnVjdG9yLCBUT19TVFJJTkdfVEFHLCBmYWxzZSk7XG4gIEl0ZXJhdG9ycyQ0W1RPX1NUUklOR19UQUddID0gcmV0dXJuVGhpcyQxO1xuICByZXR1cm4gSXRlcmF0b3JDb25zdHJ1Y3Rvcjtcbn07XG5cbnZhciBpc0NhbGxhYmxlJDcgPSBpc0NhbGxhYmxlJGs7XG5cbnZhciAkU3RyaW5nJDEgPSBTdHJpbmc7XG52YXIgJFR5cGVFcnJvciQ1ID0gVHlwZUVycm9yO1xuXG52YXIgYVBvc3NpYmxlUHJvdG90eXBlJDEgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgaWYgKHR5cGVvZiBhcmd1bWVudCA9PSAnb2JqZWN0JyB8fCBpc0NhbGxhYmxlJDcoYXJndW1lbnQpKSByZXR1cm4gYXJndW1lbnQ7XG4gIHRocm93ICRUeXBlRXJyb3IkNShcIkNhbid0IHNldCBcIiArICRTdHJpbmckMShhcmd1bWVudCkgKyAnIGFzIGEgcHJvdG90eXBlJyk7XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAtLSBzYWZlICovXG5cbnZhciB1bmN1cnJ5VGhpcyQzID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBhbk9iamVjdCQ3ID0gYW5PYmplY3QkYztcbnZhciBhUG9zc2libGVQcm90b3R5cGUgPSBhUG9zc2libGVQcm90b3R5cGUkMTtcblxuLy8gYE9iamVjdC5zZXRQcm90b3R5cGVPZmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5zZXRwcm90b3R5cGVvZlxuLy8gV29ya3Mgd2l0aCBfX3Byb3RvX18gb25seS4gT2xkIHY4IGNhbid0IHdvcmsgd2l0aCBudWxsIHByb3RvIG9iamVjdHMuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3Qtc2V0cHJvdG90eXBlb2YgLS0gc2FmZVxudmFyIG9iamVjdFNldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8ICgnX19wcm90b19fJyBpbiB7fSA/IGZ1bmN0aW9uICgpIHtcbiAgdmFyIENPUlJFQ1RfU0VUVEVSID0gZmFsc2U7XG4gIHZhciB0ZXN0ID0ge307XG4gIHZhciBzZXR0ZXI7XG4gIHRyeSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG4gICAgc2V0dGVyID0gdW5jdXJyeVRoaXMkMyhPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE9iamVjdC5wcm90b3R5cGUsICdfX3Byb3RvX18nKS5zZXQpO1xuICAgIHNldHRlcih0ZXN0LCBbXSk7XG4gICAgQ09SUkVDVF9TRVRURVIgPSB0ZXN0IGluc3RhbmNlb2YgQXJyYXk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKE8sIHByb3RvKSB7XG4gICAgYW5PYmplY3QkNyhPKTtcbiAgICBhUG9zc2libGVQcm90b3R5cGUocHJvdG8pO1xuICAgIGlmIChDT1JSRUNUX1NFVFRFUikgc2V0dGVyKE8sIHByb3RvKTtcbiAgICBlbHNlIE8uX19wcm90b19fID0gcHJvdG87XG4gICAgcmV0dXJuIE87XG4gIH07XG59KCkgOiB1bmRlZmluZWQpO1xuXG52YXIgJCQ2ID0gX2V4cG9ydDtcbnZhciBjYWxsJDkgPSBmdW5jdGlvbkNhbGw7XG52YXIgRnVuY3Rpb25OYW1lID0gZnVuY3Rpb25OYW1lO1xudmFyIGlzQ2FsbGFibGUkNiA9IGlzQ2FsbGFibGUkaztcbnZhciBjcmVhdGVJdGVyYXRvckNvbnN0cnVjdG9yID0gY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvciQxO1xudmFyIGdldFByb3RvdHlwZU9mID0gb2JqZWN0R2V0UHJvdG90eXBlT2Y7XG52YXIgc2V0UHJvdG90eXBlT2YkMSA9IG9iamVjdFNldFByb3RvdHlwZU9mO1xudmFyIHNldFRvU3RyaW5nVGFnJDEgPSBzZXRUb1N0cmluZ1RhZyQzO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQxID0gY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDQ7XG52YXIgZGVmaW5lQnVpbHRJbiQzID0gZGVmaW5lQnVpbHRJbiQ2O1xudmFyIHdlbGxLbm93blN5bWJvbCQ5ID0gd2VsbEtub3duU3ltYm9sJGU7XG52YXIgSXRlcmF0b3JzJDMgPSBpdGVyYXRvcnM7XG52YXIgSXRlcmF0b3JzQ29yZSA9IGl0ZXJhdG9yc0NvcmU7XG5cbnZhciBQUk9QRVJfRlVOQ1RJT05fTkFNRSQxID0gRnVuY3Rpb25OYW1lLlBST1BFUjtcbnZhciBDT05GSUdVUkFCTEVfRlVOQ1RJT05fTkFNRSA9IEZ1bmN0aW9uTmFtZS5DT05GSUdVUkFCTEU7XG52YXIgSXRlcmF0b3JQcm90b3R5cGUgPSBJdGVyYXRvcnNDb3JlLkl0ZXJhdG9yUHJvdG90eXBlO1xudmFyIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgPSBJdGVyYXRvcnNDb3JlLkJVR0dZX1NBRkFSSV9JVEVSQVRPUlM7XG52YXIgSVRFUkFUT1IkNCA9IHdlbGxLbm93blN5bWJvbCQ5KCdpdGVyYXRvcicpO1xudmFyIEtFWVMgPSAna2V5cyc7XG52YXIgVkFMVUVTID0gJ3ZhbHVlcyc7XG52YXIgRU5UUklFUyA9ICdlbnRyaWVzJztcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuXG52YXIgZGVmaW5lSXRlcmF0b3IkMSA9IGZ1bmN0aW9uIChJdGVyYWJsZSwgTkFNRSwgSXRlcmF0b3JDb25zdHJ1Y3RvciwgbmV4dCwgREVGQVVMVCwgSVNfU0VULCBGT1JDRUQpIHtcbiAgY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvcihJdGVyYXRvckNvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KTtcblxuICB2YXIgZ2V0SXRlcmF0aW9uTWV0aG9kID0gZnVuY3Rpb24gKEtJTkQpIHtcbiAgICBpZiAoS0lORCA9PT0gREVGQVVMVCAmJiBkZWZhdWx0SXRlcmF0b3IpIHJldHVybiBkZWZhdWx0SXRlcmF0b3I7XG4gICAgaWYgKCFCVUdHWV9TQUZBUklfSVRFUkFUT1JTICYmIEtJTkQgaW4gSXRlcmFibGVQcm90b3R5cGUpIHJldHVybiBJdGVyYWJsZVByb3RvdHlwZVtLSU5EXTtcbiAgICBzd2l0Y2ggKEtJTkQpIHtcbiAgICAgIGNhc2UgS0VZUzogcmV0dXJuIGZ1bmN0aW9uIGtleXMoKSB7IHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzLCBLSU5EKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcywgS0lORCk7IH07XG4gICAgICBjYXNlIEVOVFJJRVM6IHJldHVybiBmdW5jdGlvbiBlbnRyaWVzKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcywgS0lORCk7IH07XG4gICAgfSByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcyk7IH07XG4gIH07XG5cbiAgdmFyIFRPX1NUUklOR19UQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIHZhciBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgPSBmYWxzZTtcbiAgdmFyIEl0ZXJhYmxlUHJvdG90eXBlID0gSXRlcmFibGUucHJvdG90eXBlO1xuICB2YXIgbmF0aXZlSXRlcmF0b3IgPSBJdGVyYWJsZVByb3RvdHlwZVtJVEVSQVRPUiQ0XVxuICAgIHx8IEl0ZXJhYmxlUHJvdG90eXBlWydAQGl0ZXJhdG9yJ11cbiAgICB8fCBERUZBVUxUICYmIEl0ZXJhYmxlUHJvdG90eXBlW0RFRkFVTFRdO1xuICB2YXIgZGVmYXVsdEl0ZXJhdG9yID0gIUJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgJiYgbmF0aXZlSXRlcmF0b3IgfHwgZ2V0SXRlcmF0aW9uTWV0aG9kKERFRkFVTFQpO1xuICB2YXIgYW55TmF0aXZlSXRlcmF0b3IgPSBOQU1FID09ICdBcnJheScgPyBJdGVyYWJsZVByb3RvdHlwZS5lbnRyaWVzIHx8IG5hdGl2ZUl0ZXJhdG9yIDogbmF0aXZlSXRlcmF0b3I7XG4gIHZhciBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUsIG1ldGhvZHMsIEtFWTtcblxuICAvLyBmaXggbmF0aXZlXG4gIGlmIChhbnlOYXRpdmVJdGVyYXRvcikge1xuICAgIEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKGFueU5hdGl2ZUl0ZXJhdG9yLmNhbGwobmV3IEl0ZXJhYmxlKCkpKTtcbiAgICBpZiAoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlICYmIEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZS5uZXh0KSB7XG4gICAgICBpZiAoZ2V0UHJvdG90eXBlT2YoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlKSAhPT0gSXRlcmF0b3JQcm90b3R5cGUpIHtcbiAgICAgICAgaWYgKHNldFByb3RvdHlwZU9mJDEpIHtcbiAgICAgICAgICBzZXRQcm90b3R5cGVPZiQxKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgSXRlcmF0b3JQcm90b3R5cGUpO1xuICAgICAgICB9IGVsc2UgaWYgKCFpc0NhbGxhYmxlJDYoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlW0lURVJBVE9SJDRdKSkge1xuICAgICAgICAgIGRlZmluZUJ1aWx0SW4kMyhDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SJDQsIHJldHVyblRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBTZXQgQEB0b1N0cmluZ1RhZyB0byBuYXRpdmUgaXRlcmF0b3JzXG4gICAgICBzZXRUb1N0cmluZ1RhZyQxKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgVE9fU1RSSU5HX1RBRywgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gZml4IEFycmF5LnByb3RvdHlwZS57IHZhbHVlcywgQEBpdGVyYXRvciB9Lm5hbWUgaW4gVjggLyBGRlxuICBpZiAoUFJPUEVSX0ZVTkNUSU9OX05BTUUkMSAmJiBERUZBVUxUID09IFZBTFVFUyAmJiBuYXRpdmVJdGVyYXRvciAmJiBuYXRpdmVJdGVyYXRvci5uYW1lICE9PSBWQUxVRVMpIHtcbiAgICBpZiAoQ09ORklHVVJBQkxFX0ZVTkNUSU9OX05BTUUpIHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQxKEl0ZXJhYmxlUHJvdG90eXBlLCAnbmFtZScsIFZBTFVFUyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIElOQ09SUkVDVF9WQUxVRVNfTkFNRSA9IHRydWU7XG4gICAgICBkZWZhdWx0SXRlcmF0b3IgPSBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiBjYWxsJDkobmF0aXZlSXRlcmF0b3IsIHRoaXMpOyB9O1xuICAgIH1cbiAgfVxuXG4gIC8vIGV4cG9ydCBhZGRpdGlvbmFsIG1ldGhvZHNcbiAgaWYgKERFRkFVTFQpIHtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiBnZXRJdGVyYXRpb25NZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6IElTX1NFVCA/IGRlZmF1bHRJdGVyYXRvciA6IGdldEl0ZXJhdGlvbk1ldGhvZChLRVlTKSxcbiAgICAgIGVudHJpZXM6IGdldEl0ZXJhdGlvbk1ldGhvZChFTlRSSUVTKVxuICAgIH07XG4gICAgaWYgKEZPUkNFRCkgZm9yIChLRVkgaW4gbWV0aG9kcykge1xuICAgICAgaWYgKEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgfHwgSU5DT1JSRUNUX1ZBTFVFU19OQU1FIHx8ICEoS0VZIGluIEl0ZXJhYmxlUHJvdG90eXBlKSkge1xuICAgICAgICBkZWZpbmVCdWlsdEluJDMoSXRlcmFibGVQcm90b3R5cGUsIEtFWSwgbWV0aG9kc1tLRVldKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgJCQ2KHsgdGFyZ2V0OiBOQU1FLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBCVUdHWV9TQUZBUklfSVRFUkFUT1JTIHx8IElOQ09SUkVDVF9WQUxVRVNfTkFNRSB9LCBtZXRob2RzKTtcbiAgfVxuXG4gIC8vIGRlZmluZSBpdGVyYXRvclxuICBpZiAoSXRlcmFibGVQcm90b3R5cGVbSVRFUkFUT1IkNF0gIT09IGRlZmF1bHRJdGVyYXRvcikge1xuICAgIGRlZmluZUJ1aWx0SW4kMyhJdGVyYWJsZVByb3RvdHlwZSwgSVRFUkFUT1IkNCwgZGVmYXVsdEl0ZXJhdG9yLCB7IG5hbWU6IERFRkFVTFQgfSk7XG4gIH1cbiAgSXRlcmF0b3JzJDNbTkFNRV0gPSBkZWZhdWx0SXRlcmF0b3I7XG5cbiAgcmV0dXJuIG1ldGhvZHM7XG59O1xuXG52YXIgdG9JbmRleGVkT2JqZWN0ID0gdG9JbmRleGVkT2JqZWN0JDU7XG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IGFkZFRvVW5zY29wYWJsZXMkMTtcbnZhciBJdGVyYXRvcnMkMiA9IGl0ZXJhdG9ycztcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlJDEgPSBpbnRlcm5hbFN0YXRlO1xudmFyIGRlZmluZVByb3BlcnR5ID0gb2JqZWN0RGVmaW5lUHJvcGVydHkuZjtcbnZhciBkZWZpbmVJdGVyYXRvciA9IGRlZmluZUl0ZXJhdG9yJDE7XG52YXIgREVTQ1JJUFRPUlMkMSA9IGRlc2NyaXB0b3JzO1xuXG52YXIgQVJSQVlfSVRFUkFUT1IgPSAnQXJyYXkgSXRlcmF0b3InO1xudmFyIHNldEludGVybmFsU3RhdGUkMSA9IEludGVybmFsU3RhdGVNb2R1bGUkMS5zZXQ7XG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUkMS5nZXR0ZXJGb3IoQVJSQVlfSVRFUkFUT1IpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmVudHJpZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZW50cmllc1xuLy8gYEFycmF5LnByb3RvdHlwZS5rZXlzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmtleXNcbi8vIGBBcnJheS5wcm90b3R5cGUudmFsdWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnZhbHVlc1xuLy8gYEFycmF5LnByb3RvdHlwZVtAQGl0ZXJhdG9yXWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQGl0ZXJhdG9yXG4vLyBgQ3JlYXRlQXJyYXlJdGVyYXRvcmAgaW50ZXJuYWwgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWNyZWF0ZWFycmF5aXRlcmF0b3JcbnZhciBlc19hcnJheV9pdGVyYXRvciA9IGRlZmluZUl0ZXJhdG9yKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbiAoaXRlcmF0ZWQsIGtpbmQpIHtcbiAgc2V0SW50ZXJuYWxTdGF0ZSQxKHRoaXMsIHtcbiAgICB0eXBlOiBBUlJBWV9JVEVSQVRPUixcbiAgICB0YXJnZXQ6IHRvSW5kZXhlZE9iamVjdChpdGVyYXRlZCksIC8vIHRhcmdldFxuICAgIGluZGV4OiAwLCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICAgIGtpbmQ6IGtpbmQgICAgICAgICAgICAgICAgICAgICAgICAgLy8ga2luZFxuICB9KTtcbi8vIGAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSVhcnJheWl0ZXJhdG9ycHJvdG90eXBlJS5uZXh0XG59LCBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhpcyk7XG4gIHZhciB0YXJnZXQgPSBzdGF0ZS50YXJnZXQ7XG4gIHZhciBraW5kID0gc3RhdGUua2luZDtcbiAgdmFyIGluZGV4ID0gc3RhdGUuaW5kZXgrKztcbiAgaWYgKCF0YXJnZXQgfHwgaW5kZXggPj0gdGFyZ2V0Lmxlbmd0aCkge1xuICAgIHN0YXRlLnRhcmdldCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cbiAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4geyB2YWx1ZTogaW5kZXgsIGRvbmU6IGZhbHNlIH07XG4gIGlmIChraW5kID09ICd2YWx1ZXMnKSByZXR1cm4geyB2YWx1ZTogdGFyZ2V0W2luZGV4XSwgZG9uZTogZmFsc2UgfTtcbiAgcmV0dXJuIHsgdmFsdWU6IFtpbmRleCwgdGFyZ2V0W2luZGV4XV0sIGRvbmU6IGZhbHNlIH07XG59LCAndmFsdWVzJyk7XG5cbi8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJVxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1jcmVhdGV1bm1hcHBlZGFyZ3VtZW50c29iamVjdFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1jcmVhdGVtYXBwZWRhcmd1bWVudHNvYmplY3RcbnZhciB2YWx1ZXMgPSBJdGVyYXRvcnMkMi5Bcmd1bWVudHMgPSBJdGVyYXRvcnMkMi5BcnJheTtcblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUtQEB1bnNjb3BhYmxlc1xuYWRkVG9VbnNjb3BhYmxlcygna2V5cycpO1xuYWRkVG9VbnNjb3BhYmxlcygndmFsdWVzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCdlbnRyaWVzJyk7XG5cbi8vIFY4IH4gQ2hyb21lIDQ1LSBidWdcbmlmIChERVNDUklQVE9SUyQxICYmIHZhbHVlcy5uYW1lICE9PSAndmFsdWVzJykgdHJ5IHtcbiAgZGVmaW5lUHJvcGVydHkodmFsdWVzLCAnbmFtZScsIHsgdmFsdWU6ICd2YWx1ZXMnIH0pO1xufSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuXG4vLyBpdGVyYWJsZSBET00gY29sbGVjdGlvbnNcbi8vIGZsYWcgLSBgaXRlcmFibGVgIGludGVyZmFjZSAtICdlbnRyaWVzJywgJ2tleXMnLCAndmFsdWVzJywgJ2ZvckVhY2gnIG1ldGhvZHNcbnZhciBkb21JdGVyYWJsZXMgPSB7XG4gIENTU1J1bGVMaXN0OiAwLFxuICBDU1NTdHlsZURlY2xhcmF0aW9uOiAwLFxuICBDU1NWYWx1ZUxpc3Q6IDAsXG4gIENsaWVudFJlY3RMaXN0OiAwLFxuICBET01SZWN0TGlzdDogMCxcbiAgRE9NU3RyaW5nTGlzdDogMCxcbiAgRE9NVG9rZW5MaXN0OiAxLFxuICBEYXRhVHJhbnNmZXJJdGVtTGlzdDogMCxcbiAgRmlsZUxpc3Q6IDAsXG4gIEhUTUxBbGxDb2xsZWN0aW9uOiAwLFxuICBIVE1MQ29sbGVjdGlvbjogMCxcbiAgSFRNTEZvcm1FbGVtZW50OiAwLFxuICBIVE1MU2VsZWN0RWxlbWVudDogMCxcbiAgTWVkaWFMaXN0OiAwLFxuICBNaW1lVHlwZUFycmF5OiAwLFxuICBOYW1lZE5vZGVNYXA6IDAsXG4gIE5vZGVMaXN0OiAxLFxuICBQYWludFJlcXVlc3RMaXN0OiAwLFxuICBQbHVnaW46IDAsXG4gIFBsdWdpbkFycmF5OiAwLFxuICBTVkdMZW5ndGhMaXN0OiAwLFxuICBTVkdOdW1iZXJMaXN0OiAwLFxuICBTVkdQYXRoU2VnTGlzdDogMCxcbiAgU1ZHUG9pbnRMaXN0OiAwLFxuICBTVkdTdHJpbmdMaXN0OiAwLFxuICBTVkdUcmFuc2Zvcm1MaXN0OiAwLFxuICBTb3VyY2VCdWZmZXJMaXN0OiAwLFxuICBTdHlsZVNoZWV0TGlzdDogMCxcbiAgVGV4dFRyYWNrQ3VlTGlzdDogMCxcbiAgVGV4dFRyYWNrTGlzdDogMCxcbiAgVG91Y2hMaXN0OiAwXG59O1xuXG4vLyBpbiBvbGQgV2ViS2l0IHZlcnNpb25zLCBgZWxlbWVudC5jbGFzc0xpc3RgIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBnbG9iYWwgYERPTVRva2VuTGlzdGBcbnZhciBkb2N1bWVudENyZWF0ZUVsZW1lbnQgPSBkb2N1bWVudENyZWF0ZUVsZW1lbnQkMjtcblxudmFyIGNsYXNzTGlzdCA9IGRvY3VtZW50Q3JlYXRlRWxlbWVudCgnc3BhbicpLmNsYXNzTGlzdDtcbnZhciBET01Ub2tlbkxpc3RQcm90b3R5cGUkMSA9IGNsYXNzTGlzdCAmJiBjbGFzc0xpc3QuY29uc3RydWN0b3IgJiYgY2xhc3NMaXN0LmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcblxudmFyIGRvbVRva2VuTGlzdFByb3RvdHlwZSA9IERPTVRva2VuTGlzdFByb3RvdHlwZSQxID09PSBPYmplY3QucHJvdG90eXBlID8gdW5kZWZpbmVkIDogRE9NVG9rZW5MaXN0UHJvdG90eXBlJDE7XG5cbnZhciBnbG9iYWwkOSA9IGdsb2JhbCRqO1xudmFyIERPTUl0ZXJhYmxlcyA9IGRvbUl0ZXJhYmxlcztcbnZhciBET01Ub2tlbkxpc3RQcm90b3R5cGUgPSBkb21Ub2tlbkxpc3RQcm90b3R5cGU7XG52YXIgQXJyYXlJdGVyYXRvck1ldGhvZHMgPSBlc19hcnJheV9pdGVyYXRvcjtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNDtcbnZhciB3ZWxsS25vd25TeW1ib2wkOCA9IHdlbGxLbm93blN5bWJvbCRlO1xuXG52YXIgSVRFUkFUT1IkMyA9IHdlbGxLbm93blN5bWJvbCQ4KCdpdGVyYXRvcicpO1xudmFyIFRPX1NUUklOR19UQUckMiA9IHdlbGxLbm93blN5bWJvbCQ4KCd0b1N0cmluZ1RhZycpO1xudmFyIEFycmF5VmFsdWVzID0gQXJyYXlJdGVyYXRvck1ldGhvZHMudmFsdWVzO1xuXG52YXIgaGFuZGxlUHJvdG90eXBlID0gZnVuY3Rpb24gKENvbGxlY3Rpb25Qcm90b3R5cGUsIENPTExFQ1RJT05fTkFNRSkge1xuICBpZiAoQ29sbGVjdGlvblByb3RvdHlwZSkge1xuICAgIC8vIHNvbWUgQ2hyb21lIHZlcnNpb25zIGhhdmUgbm9uLWNvbmZpZ3VyYWJsZSBtZXRob2RzIG9uIERPTVRva2VuTGlzdFxuICAgIGlmIChDb2xsZWN0aW9uUHJvdG90eXBlW0lURVJBVE9SJDNdICE9PSBBcnJheVZhbHVlcykgdHJ5IHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShDb2xsZWN0aW9uUHJvdG90eXBlLCBJVEVSQVRPUiQzLCBBcnJheVZhbHVlcyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIENvbGxlY3Rpb25Qcm90b3R5cGVbSVRFUkFUT1IkM10gPSBBcnJheVZhbHVlcztcbiAgICB9XG4gICAgaWYgKCFDb2xsZWN0aW9uUHJvdG90eXBlW1RPX1NUUklOR19UQUckMl0pIHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShDb2xsZWN0aW9uUHJvdG90eXBlLCBUT19TVFJJTkdfVEFHJDIsIENPTExFQ1RJT05fTkFNRSk7XG4gICAgfVxuICAgIGlmIChET01JdGVyYWJsZXNbQ09MTEVDVElPTl9OQU1FXSkgZm9yICh2YXIgTUVUSE9EX05BTUUgaW4gQXJyYXlJdGVyYXRvck1ldGhvZHMpIHtcbiAgICAgIC8vIHNvbWUgQ2hyb21lIHZlcnNpb25zIGhhdmUgbm9uLWNvbmZpZ3VyYWJsZSBtZXRob2RzIG9uIERPTVRva2VuTGlzdFxuICAgICAgaWYgKENvbGxlY3Rpb25Qcm90b3R5cGVbTUVUSE9EX05BTUVdICE9PSBBcnJheUl0ZXJhdG9yTWV0aG9kc1tNRVRIT0RfTkFNRV0pIHRyeSB7XG4gICAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShDb2xsZWN0aW9uUHJvdG90eXBlLCBNRVRIT0RfTkFNRSwgQXJyYXlJdGVyYXRvck1ldGhvZHNbTUVUSE9EX05BTUVdKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIENvbGxlY3Rpb25Qcm90b3R5cGVbTUVUSE9EX05BTUVdID0gQXJyYXlJdGVyYXRvck1ldGhvZHNbTUVUSE9EX05BTUVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZm9yICh2YXIgQ09MTEVDVElPTl9OQU1FIGluIERPTUl0ZXJhYmxlcykge1xuICBoYW5kbGVQcm90b3R5cGUoZ2xvYmFsJDlbQ09MTEVDVElPTl9OQU1FXSAmJiBnbG9iYWwkOVtDT0xMRUNUSU9OX05BTUVdLnByb3RvdHlwZSwgQ09MTEVDVElPTl9OQU1FKTtcbn1cblxuaGFuZGxlUHJvdG90eXBlKERPTVRva2VuTGlzdFByb3RvdHlwZSwgJ0RPTVRva2VuTGlzdCcpO1xuXG52YXIgY2xhc3NvZiQ0ID0gY2xhc3NvZlJhdyQxO1xudmFyIGdsb2JhbCQ4ID0gZ2xvYmFsJGo7XG5cbnZhciBlbmdpbmVJc05vZGUgPSBjbGFzc29mJDQoZ2xvYmFsJDgucHJvY2VzcykgPT0gJ3Byb2Nlc3MnO1xuXG52YXIgZ2V0QnVpbHRJbiQzID0gZ2V0QnVpbHRJbiQ4O1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gb2JqZWN0RGVmaW5lUHJvcGVydHk7XG52YXIgd2VsbEtub3duU3ltYm9sJDcgPSB3ZWxsS25vd25TeW1ib2wkZTtcbnZhciBERVNDUklQVE9SUyA9IGRlc2NyaXB0b3JzO1xuXG52YXIgU1BFQ0lFUyQyID0gd2VsbEtub3duU3ltYm9sJDcoJ3NwZWNpZXMnKTtcblxudmFyIHNldFNwZWNpZXMkMSA9IGZ1bmN0aW9uIChDT05TVFJVQ1RPUl9OQU1FKSB7XG4gIHZhciBDb25zdHJ1Y3RvciA9IGdldEJ1aWx0SW4kMyhDT05TVFJVQ1RPUl9OQU1FKTtcbiAgdmFyIGRlZmluZVByb3BlcnR5ID0gZGVmaW5lUHJvcGVydHlNb2R1bGUuZjtcblxuICBpZiAoREVTQ1JJUFRPUlMgJiYgQ29uc3RydWN0b3IgJiYgIUNvbnN0cnVjdG9yW1NQRUNJRVMkMl0pIHtcbiAgICBkZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgU1BFQ0lFUyQyLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH1cbiAgICB9KTtcbiAgfVxufTtcblxudmFyIGlzUHJvdG90eXBlT2YkMiA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG5cbnZhciAkVHlwZUVycm9yJDQgPSBUeXBlRXJyb3I7XG5cbnZhciBhbkluc3RhbmNlJDEgPSBmdW5jdGlvbiAoaXQsIFByb3RvdHlwZSkge1xuICBpZiAoaXNQcm90b3R5cGVPZiQyKFByb3RvdHlwZSwgaXQpKSByZXR1cm4gaXQ7XG4gIHRocm93ICRUeXBlRXJyb3IkNCgnSW5jb3JyZWN0IGludm9jYXRpb24nKTtcbn07XG5cbnZhciB3ZWxsS25vd25TeW1ib2wkNiA9IHdlbGxLbm93blN5bWJvbCRlO1xuXG52YXIgVE9fU1RSSU5HX1RBRyQxID0gd2VsbEtub3duU3ltYm9sJDYoJ3RvU3RyaW5nVGFnJyk7XG52YXIgdGVzdCA9IHt9O1xuXG50ZXN0W1RPX1NUUklOR19UQUckMV0gPSAneic7XG5cbnZhciB0b1N0cmluZ1RhZ1N1cHBvcnQgPSBTdHJpbmcodGVzdCkgPT09ICdbb2JqZWN0IHpdJztcblxudmFyIFRPX1NUUklOR19UQUdfU1VQUE9SVCA9IHRvU3RyaW5nVGFnU3VwcG9ydDtcbnZhciBpc0NhbGxhYmxlJDUgPSBpc0NhbGxhYmxlJGs7XG52YXIgY2xhc3NvZlJhdyA9IGNsYXNzb2ZSYXckMTtcbnZhciB3ZWxsS25vd25TeW1ib2wkNSA9IHdlbGxLbm93blN5bWJvbCRlO1xuXG52YXIgVE9fU1RSSU5HX1RBRyA9IHdlbGxLbm93blN5bWJvbCQ1KCd0b1N0cmluZ1RhZycpO1xudmFyICRPYmplY3QgPSBPYmplY3Q7XG5cbi8vIEVTMyB3cm9uZyBoZXJlXG52YXIgQ09SUkVDVF9BUkdVTUVOVFMgPSBjbGFzc29mUmF3KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PSAnQXJndW1lbnRzJztcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcbnZhciB0cnlHZXQgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICB0cnkge1xuICAgIHJldHVybiBpdFtrZXldO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG59O1xuXG4vLyBnZXR0aW5nIHRhZyBmcm9tIEVTNisgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgXG52YXIgY2xhc3NvZiQzID0gVE9fU1RSSU5HX1RBR19TVVBQT1JUID8gY2xhc3NvZlJhdyA6IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgTywgdGFnLCByZXN1bHQ7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBpdCA9PT0gbnVsbCA/ICdOdWxsJ1xuICAgIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxuICAgIDogdHlwZW9mICh0YWcgPSB0cnlHZXQoTyA9ICRPYmplY3QoaXQpLCBUT19TVFJJTkdfVEFHKSkgPT0gJ3N0cmluZycgPyB0YWdcbiAgICAvLyBidWlsdGluVGFnIGNhc2VcbiAgICA6IENPUlJFQ1RfQVJHVU1FTlRTID8gY2xhc3NvZlJhdyhPKVxuICAgIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcbiAgICA6IChyZXN1bHQgPSBjbGFzc29mUmF3KE8pKSA9PSAnT2JqZWN0JyAmJiBpc0NhbGxhYmxlJDUoTy5jYWxsZWUpID8gJ0FyZ3VtZW50cycgOiByZXN1bHQ7XG59O1xuXG52YXIgdW5jdXJyeVRoaXMkMiA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgZmFpbHMkMiA9IGZhaWxzJGQ7XG52YXIgaXNDYWxsYWJsZSQ0ID0gaXNDYWxsYWJsZSRrO1xudmFyIGNsYXNzb2YkMiA9IGNsYXNzb2YkMztcbnZhciBnZXRCdWlsdEluJDIgPSBnZXRCdWlsdEluJDg7XG52YXIgaW5zcGVjdFNvdXJjZSQxID0gaW5zcGVjdFNvdXJjZSQ0O1xuXG52YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbnZhciBlbXB0eSA9IFtdO1xudmFyIGNvbnN0cnVjdCA9IGdldEJ1aWx0SW4kMignUmVmbGVjdCcsICdjb25zdHJ1Y3QnKTtcbnZhciBjb25zdHJ1Y3RvclJlZ0V4cCA9IC9eXFxzKig/OmNsYXNzfGZ1bmN0aW9uKVxcYi87XG52YXIgZXhlYyA9IHVuY3VycnlUaGlzJDIoY29uc3RydWN0b3JSZWdFeHAuZXhlYyk7XG52YXIgSU5DT1JSRUNUX1RPX1NUUklORyA9ICFjb25zdHJ1Y3RvclJlZ0V4cC5leGVjKG5vb3ApO1xuXG52YXIgaXNDb25zdHJ1Y3Rvck1vZGVybiA9IGZ1bmN0aW9uIGlzQ29uc3RydWN0b3IoYXJndW1lbnQpIHtcbiAgaWYgKCFpc0NhbGxhYmxlJDQoYXJndW1lbnQpKSByZXR1cm4gZmFsc2U7XG4gIHRyeSB7XG4gICAgY29uc3RydWN0KG5vb3AsIGVtcHR5LCBhcmd1bWVudCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG52YXIgaXNDb25zdHJ1Y3RvckxlZ2FjeSA9IGZ1bmN0aW9uIGlzQ29uc3RydWN0b3IoYXJndW1lbnQpIHtcbiAgaWYgKCFpc0NhbGxhYmxlJDQoYXJndW1lbnQpKSByZXR1cm4gZmFsc2U7XG4gIHN3aXRjaCAoY2xhc3NvZiQyKGFyZ3VtZW50KSkge1xuICAgIGNhc2UgJ0FzeW5jRnVuY3Rpb24nOlxuICAgIGNhc2UgJ0dlbmVyYXRvckZ1bmN0aW9uJzpcbiAgICBjYXNlICdBc3luY0dlbmVyYXRvckZ1bmN0aW9uJzogcmV0dXJuIGZhbHNlO1xuICB9XG4gIHRyeSB7XG4gICAgLy8gd2UgY2FuJ3QgY2hlY2sgLnByb3RvdHlwZSBzaW5jZSBjb25zdHJ1Y3RvcnMgcHJvZHVjZWQgYnkgLmJpbmQgaGF2ZW4ndCBpdFxuICAgIC8vIGBGdW5jdGlvbiN0b1N0cmluZ2AgdGhyb3dzIG9uIHNvbWUgYnVpbHQtaXQgZnVuY3Rpb24gaW4gc29tZSBsZWdhY3kgZW5naW5lc1xuICAgIC8vIChmb3IgZXhhbXBsZSwgYERPTVF1YWRgIGFuZCBzaW1pbGFyIGluIEZGNDEtKVxuICAgIHJldHVybiBJTkNPUlJFQ1RfVE9fU1RSSU5HIHx8ICEhZXhlYyhjb25zdHJ1Y3RvclJlZ0V4cCwgaW5zcGVjdFNvdXJjZSQxKGFyZ3VtZW50KSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cbmlzQ29uc3RydWN0b3JMZWdhY3kuc2hhbSA9IHRydWU7XG5cbi8vIGBJc0NvbnN0cnVjdG9yYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaXNjb25zdHJ1Y3RvclxudmFyIGlzQ29uc3RydWN0b3IkMSA9ICFjb25zdHJ1Y3QgfHwgZmFpbHMkMihmdW5jdGlvbiAoKSB7XG4gIHZhciBjYWxsZWQ7XG4gIHJldHVybiBpc0NvbnN0cnVjdG9yTW9kZXJuKGlzQ29uc3RydWN0b3JNb2Rlcm4uY2FsbClcbiAgICB8fCAhaXNDb25zdHJ1Y3Rvck1vZGVybihPYmplY3QpXG4gICAgfHwgIWlzQ29uc3RydWN0b3JNb2Rlcm4oZnVuY3Rpb24gKCkgeyBjYWxsZWQgPSB0cnVlOyB9KVxuICAgIHx8IGNhbGxlZDtcbn0pID8gaXNDb25zdHJ1Y3RvckxlZ2FjeSA6IGlzQ29uc3RydWN0b3JNb2Rlcm47XG5cbnZhciBpc0NvbnN0cnVjdG9yID0gaXNDb25zdHJ1Y3RvciQxO1xudmFyIHRyeVRvU3RyaW5nJDIgPSB0cnlUb1N0cmluZyQ0O1xuXG52YXIgJFR5cGVFcnJvciQzID0gVHlwZUVycm9yO1xuXG4vLyBgQXNzZXJ0OiBJc0NvbnN0cnVjdG9yKGFyZ3VtZW50KSBpcyB0cnVlYFxudmFyIGFDb25zdHJ1Y3RvciQxID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmIChpc0NvbnN0cnVjdG9yKGFyZ3VtZW50KSkgcmV0dXJuIGFyZ3VtZW50O1xuICB0aHJvdyAkVHlwZUVycm9yJDModHJ5VG9TdHJpbmckMihhcmd1bWVudCkgKyAnIGlzIG5vdCBhIGNvbnN0cnVjdG9yJyk7XG59O1xuXG52YXIgYW5PYmplY3QkNiA9IGFuT2JqZWN0JGM7XG52YXIgYUNvbnN0cnVjdG9yID0gYUNvbnN0cnVjdG9yJDE7XG52YXIgd2VsbEtub3duU3ltYm9sJDQgPSB3ZWxsS25vd25TeW1ib2wkZTtcblxudmFyIFNQRUNJRVMkMSA9IHdlbGxLbm93blN5bWJvbCQ0KCdzcGVjaWVzJyk7XG5cbi8vIGBTcGVjaWVzQ29uc3RydWN0b3JgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zcGVjaWVzY29uc3RydWN0b3JcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IkMSA9IGZ1bmN0aW9uIChPLCBkZWZhdWx0Q29uc3RydWN0b3IpIHtcbiAgdmFyIEMgPSBhbk9iamVjdCQ2KE8pLmNvbnN0cnVjdG9yO1xuICB2YXIgUztcbiAgcmV0dXJuIEMgPT09IHVuZGVmaW5lZCB8fCAoUyA9IGFuT2JqZWN0JDYoQylbU1BFQ0lFUyQxXSkgPT0gdW5kZWZpbmVkID8gZGVmYXVsdENvbnN0cnVjdG9yIDogYUNvbnN0cnVjdG9yKFMpO1xufTtcblxudmFyIE5BVElWRV9CSU5EJDEgPSBmdW5jdGlvbkJpbmROYXRpdmU7XG5cbnZhciBGdW5jdGlvblByb3RvdHlwZSA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbnZhciBhcHBseSQxID0gRnVuY3Rpb25Qcm90b3R5cGUuYXBwbHk7XG52YXIgY2FsbCQ4ID0gRnVuY3Rpb25Qcm90b3R5cGUuY2FsbDtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tcmVmbGVjdCAtLSBzYWZlXG52YXIgZnVuY3Rpb25BcHBseSA9IHR5cGVvZiBSZWZsZWN0ID09ICdvYmplY3QnICYmIFJlZmxlY3QuYXBwbHkgfHwgKE5BVElWRV9CSU5EJDEgPyBjYWxsJDguYmluZChhcHBseSQxKSA6IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGNhbGwkOC5hcHBseShhcHBseSQxLCBhcmd1bWVudHMpO1xufSk7XG5cbnZhciB1bmN1cnJ5VGhpcyQxID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBhQ2FsbGFibGUkNSA9IGFDYWxsYWJsZSQ3O1xudmFyIE5BVElWRV9CSU5EID0gZnVuY3Rpb25CaW5kTmF0aXZlO1xuXG52YXIgYmluZCQ0ID0gdW5jdXJyeVRoaXMkMSh1bmN1cnJ5VGhpcyQxLmJpbmQpO1xuXG4vLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBmdW5jdGlvbkJpbmRDb250ZXh0ID0gZnVuY3Rpb24gKGZuLCB0aGF0KSB7XG4gIGFDYWxsYWJsZSQ1KGZuKTtcbiAgcmV0dXJuIHRoYXQgPT09IHVuZGVmaW5lZCA/IGZuIDogTkFUSVZFX0JJTkQgPyBiaW5kJDQoZm4sIHRoYXQpIDogZnVuY3Rpb24gKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG5cbnZhciB1bmN1cnJ5VGhpcyA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG5cbnZhciBhcnJheVNsaWNlJDEgPSB1bmN1cnJ5VGhpcyhbXS5zbGljZSk7XG5cbnZhciAkVHlwZUVycm9yJDIgPSBUeXBlRXJyb3I7XG5cbnZhciB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aCQxID0gZnVuY3Rpb24gKHBhc3NlZCwgcmVxdWlyZWQpIHtcbiAgaWYgKHBhc3NlZCA8IHJlcXVpcmVkKSB0aHJvdyAkVHlwZUVycm9yJDIoJ05vdCBlbm91Z2ggYXJndW1lbnRzJyk7XG4gIHJldHVybiBwYXNzZWQ7XG59O1xuXG52YXIgdXNlckFnZW50JDIgPSBlbmdpbmVVc2VyQWdlbnQ7XG5cbnZhciBlbmdpbmVJc0lvcyA9IC8oPzppcGFkfGlwaG9uZXxpcG9kKS4qYXBwbGV3ZWJraXQvaS50ZXN0KHVzZXJBZ2VudCQyKTtcblxudmFyIGdsb2JhbCQ3ID0gZ2xvYmFsJGo7XG52YXIgYXBwbHkgPSBmdW5jdGlvbkFwcGx5O1xudmFyIGJpbmQkMyA9IGZ1bmN0aW9uQmluZENvbnRleHQ7XG52YXIgaXNDYWxsYWJsZSQzID0gaXNDYWxsYWJsZSRrO1xudmFyIGhhc093biQxID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBmYWlscyQxID0gZmFpbHMkZDtcbnZhciBodG1sID0gaHRtbCQyO1xudmFyIGFycmF5U2xpY2UgPSBhcnJheVNsaWNlJDE7XG52YXIgY3JlYXRlRWxlbWVudCA9IGRvY3VtZW50Q3JlYXRlRWxlbWVudCQyO1xudmFyIHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoID0gdmFsaWRhdGVBcmd1bWVudHNMZW5ndGgkMTtcbnZhciBJU19JT1MkMSA9IGVuZ2luZUlzSW9zO1xudmFyIElTX05PREUkMiA9IGVuZ2luZUlzTm9kZTtcblxudmFyIHNldCA9IGdsb2JhbCQ3LnNldEltbWVkaWF0ZTtcbnZhciBjbGVhciA9IGdsb2JhbCQ3LmNsZWFySW1tZWRpYXRlO1xudmFyIHByb2Nlc3MkMiA9IGdsb2JhbCQ3LnByb2Nlc3M7XG52YXIgRGlzcGF0Y2ggPSBnbG9iYWwkNy5EaXNwYXRjaDtcbnZhciBGdW5jdGlvbiQxID0gZ2xvYmFsJDcuRnVuY3Rpb247XG52YXIgTWVzc2FnZUNoYW5uZWwgPSBnbG9iYWwkNy5NZXNzYWdlQ2hhbm5lbDtcbnZhciBTdHJpbmckMSA9IGdsb2JhbCQ3LlN0cmluZztcbnZhciBjb3VudGVyID0gMDtcbnZhciBxdWV1ZSQxID0ge307XG52YXIgT05SRUFEWVNUQVRFQ0hBTkdFID0gJ29ucmVhZHlzdGF0ZWNoYW5nZSc7XG52YXIgbG9jYXRpb24sIGRlZmVyLCBjaGFubmVsLCBwb3J0O1xuXG50cnkge1xuICAvLyBEZW5vIHRocm93cyBhIFJlZmVyZW5jZUVycm9yIG9uIGBsb2NhdGlvbmAgYWNjZXNzIHdpdGhvdXQgYC0tbG9jYXRpb25gIGZsYWdcbiAgbG9jYXRpb24gPSBnbG9iYWwkNy5sb2NhdGlvbjtcbn0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cblxudmFyIHJ1biA9IGZ1bmN0aW9uIChpZCkge1xuICBpZiAoaGFzT3duJDEocXVldWUkMSwgaWQpKSB7XG4gICAgdmFyIGZuID0gcXVldWUkMVtpZF07XG4gICAgZGVsZXRlIHF1ZXVlJDFbaWRdO1xuICAgIGZuKCk7XG4gIH1cbn07XG5cbnZhciBydW5uZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBydW4oaWQpO1xuICB9O1xufTtcblxudmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHJ1bihldmVudC5kYXRhKTtcbn07XG5cbnZhciBwb3N0ID0gZnVuY3Rpb24gKGlkKSB7XG4gIC8vIG9sZCBlbmdpbmVzIGhhdmUgbm90IGxvY2F0aW9uLm9yaWdpblxuICBnbG9iYWwkNy5wb3N0TWVzc2FnZShTdHJpbmckMShpZCksIGxvY2F0aW9uLnByb3RvY29sICsgJy8vJyArIGxvY2F0aW9uLmhvc3QpO1xufTtcblxuLy8gTm9kZS5qcyAwLjkrICYgSUUxMCsgaGFzIHNldEltbWVkaWF0ZSwgb3RoZXJ3aXNlOlxuaWYgKCFzZXQgfHwgIWNsZWFyKSB7XG4gIHNldCA9IGZ1bmN0aW9uIHNldEltbWVkaWF0ZShoYW5kbGVyKSB7XG4gICAgdmFsaWRhdGVBcmd1bWVudHNMZW5ndGgoYXJndW1lbnRzLmxlbmd0aCwgMSk7XG4gICAgdmFyIGZuID0gaXNDYWxsYWJsZSQzKGhhbmRsZXIpID8gaGFuZGxlciA6IEZ1bmN0aW9uJDEoaGFuZGxlcik7XG4gICAgdmFyIGFyZ3MgPSBhcnJheVNsaWNlKGFyZ3VtZW50cywgMSk7XG4gICAgcXVldWUkMVsrK2NvdW50ZXJdID0gZnVuY3Rpb24gKCkge1xuICAgICAgYXBwbHkoZm4sIHVuZGVmaW5lZCwgYXJncyk7XG4gICAgfTtcbiAgICBkZWZlcihjb3VudGVyKTtcbiAgICByZXR1cm4gY291bnRlcjtcbiAgfTtcbiAgY2xlYXIgPSBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShpZCkge1xuICAgIGRlbGV0ZSBxdWV1ZSQxW2lkXTtcbiAgfTtcbiAgLy8gTm9kZS5qcyAwLjgtXG4gIGlmIChJU19OT0RFJDIpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgcHJvY2VzcyQyLm5leHRUaWNrKHJ1bm5lcihpZCkpO1xuICAgIH07XG4gIC8vIFNwaGVyZSAoSlMgZ2FtZSBlbmdpbmUpIERpc3BhdGNoIEFQSVxuICB9IGVsc2UgaWYgKERpc3BhdGNoICYmIERpc3BhdGNoLm5vdykge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBEaXNwYXRjaC5ub3cocnVubmVyKGlkKSk7XG4gICAgfTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBNZXNzYWdlQ2hhbm5lbCwgaW5jbHVkZXMgV2ViV29ya2Vyc1xuICAvLyBleGNlcHQgaU9TIC0gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzYyNFxuICB9IGVsc2UgaWYgKE1lc3NhZ2VDaGFubmVsICYmICFJU19JT1MkMSkge1xuICAgIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICBwb3J0ID0gY2hhbm5lbC5wb3J0MjtcbiAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGxpc3RlbmVyO1xuICAgIGRlZmVyID0gYmluZCQzKHBvcnQucG9zdE1lc3NhZ2UsIHBvcnQpO1xuICAvLyBCcm93c2VycyB3aXRoIHBvc3RNZXNzYWdlLCBza2lwIFdlYldvcmtlcnNcbiAgLy8gSUU4IGhhcyBwb3N0TWVzc2FnZSwgYnV0IGl0J3Mgc3luYyAmIHR5cGVvZiBpdHMgcG9zdE1lc3NhZ2UgaXMgJ29iamVjdCdcbiAgfSBlbHNlIGlmIChcbiAgICBnbG9iYWwkNy5hZGRFdmVudExpc3RlbmVyICYmXG4gICAgaXNDYWxsYWJsZSQzKGdsb2JhbCQ3LnBvc3RNZXNzYWdlKSAmJlxuICAgICFnbG9iYWwkNy5pbXBvcnRTY3JpcHRzICYmXG4gICAgbG9jYXRpb24gJiYgbG9jYXRpb24ucHJvdG9jb2wgIT09ICdmaWxlOicgJiZcbiAgICAhZmFpbHMkMShwb3N0KVxuICApIHtcbiAgICBkZWZlciA9IHBvc3Q7XG4gICAgZ2xvYmFsJDcuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGxpc3RlbmVyLCBmYWxzZSk7XG4gIC8vIElFOC1cbiAgfSBlbHNlIGlmIChPTlJFQURZU1RBVEVDSEFOR0UgaW4gY3JlYXRlRWxlbWVudCgnc2NyaXB0JykpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgaHRtbC5hcHBlbmRDaGlsZChjcmVhdGVFbGVtZW50KCdzY3JpcHQnKSlbT05SRUFEWVNUQVRFQ0hBTkdFXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaHRtbC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICAgICAgcnVuKGlkKTtcbiAgICAgIH07XG4gICAgfTtcbiAgLy8gUmVzdCBvbGQgYnJvd3NlcnNcbiAgfSBlbHNlIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgc2V0VGltZW91dChydW5uZXIoaWQpLCAwKTtcbiAgICB9O1xuICB9XG59XG5cbnZhciB0YXNrJDEgPSB7XG4gIHNldDogc2V0LFxuICBjbGVhcjogY2xlYXJcbn07XG5cbnZhciB1c2VyQWdlbnQkMSA9IGVuZ2luZVVzZXJBZ2VudDtcbnZhciBnbG9iYWwkNiA9IGdsb2JhbCRqO1xuXG52YXIgZW5naW5lSXNJb3NQZWJibGUgPSAvaXBhZHxpcGhvbmV8aXBvZC9pLnRlc3QodXNlckFnZW50JDEpICYmIGdsb2JhbCQ2LlBlYmJsZSAhPT0gdW5kZWZpbmVkO1xuXG52YXIgdXNlckFnZW50ID0gZW5naW5lVXNlckFnZW50O1xuXG52YXIgZW5naW5lSXNXZWJvc1dlYmtpdCA9IC93ZWIwcyg/IS4qY2hyb21lKS9pLnRlc3QodXNlckFnZW50KTtcblxudmFyIGdsb2JhbCQ1ID0gZ2xvYmFsJGo7XG52YXIgYmluZCQyID0gZnVuY3Rpb25CaW5kQ29udGV4dDtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IuZjtcbnZhciBtYWNyb3Rhc2sgPSB0YXNrJDEuc2V0O1xudmFyIElTX0lPUyA9IGVuZ2luZUlzSW9zO1xudmFyIElTX0lPU19QRUJCTEUgPSBlbmdpbmVJc0lvc1BlYmJsZTtcbnZhciBJU19XRUJPU19XRUJLSVQgPSBlbmdpbmVJc1dlYm9zV2Via2l0O1xudmFyIElTX05PREUkMSA9IGVuZ2luZUlzTm9kZTtcblxudmFyIE11dGF0aW9uT2JzZXJ2ZXIgPSBnbG9iYWwkNS5NdXRhdGlvbk9ic2VydmVyIHx8IGdsb2JhbCQ1LldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XG52YXIgZG9jdW1lbnQkMiA9IGdsb2JhbCQ1LmRvY3VtZW50O1xudmFyIHByb2Nlc3MkMSA9IGdsb2JhbCQ1LnByb2Nlc3M7XG52YXIgUHJvbWlzZSQxID0gZ2xvYmFsJDUuUHJvbWlzZTtcbi8vIE5vZGUuanMgMTEgc2hvd3MgRXhwZXJpbWVudGFsV2FybmluZyBvbiBnZXR0aW5nIGBxdWV1ZU1pY3JvdGFza2BcbnZhciBxdWV1ZU1pY3JvdGFza0Rlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZ2xvYmFsJDUsICdxdWV1ZU1pY3JvdGFzaycpO1xudmFyIHF1ZXVlTWljcm90YXNrID0gcXVldWVNaWNyb3Rhc2tEZXNjcmlwdG9yICYmIHF1ZXVlTWljcm90YXNrRGVzY3JpcHRvci52YWx1ZTtcblxudmFyIGZsdXNoLCBoZWFkLCBsYXN0LCBub3RpZnkkMSwgdG9nZ2xlLCBub2RlLCBwcm9taXNlLCB0aGVuO1xuXG4vLyBtb2Rlcm4gZW5naW5lcyBoYXZlIHF1ZXVlTWljcm90YXNrIG1ldGhvZFxuaWYgKCFxdWV1ZU1pY3JvdGFzaykge1xuICBmbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGFyZW50LCBmbjtcbiAgICBpZiAoSVNfTk9ERSQxICYmIChwYXJlbnQgPSBwcm9jZXNzJDEuZG9tYWluKSkgcGFyZW50LmV4aXQoKTtcbiAgICB3aGlsZSAoaGVhZCkge1xuICAgICAgZm4gPSBoZWFkLmZuO1xuICAgICAgaGVhZCA9IGhlYWQubmV4dDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZuKCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoaGVhZCkgbm90aWZ5JDEoKTtcbiAgICAgICAgZWxzZSBsYXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9IGxhc3QgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHBhcmVudCkgcGFyZW50LmVudGVyKCk7XG4gIH07XG5cbiAgLy8gYnJvd3NlcnMgd2l0aCBNdXRhdGlvbk9ic2VydmVyLCBleGNlcHQgaU9TIC0gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzMzOVxuICAvLyBhbHNvIGV4Y2VwdCBXZWJPUyBXZWJraXQgaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg5OFxuICBpZiAoIUlTX0lPUyAmJiAhSVNfTk9ERSQxICYmICFJU19XRUJPU19XRUJLSVQgJiYgTXV0YXRpb25PYnNlcnZlciAmJiBkb2N1bWVudCQyKSB7XG4gICAgdG9nZ2xlID0gdHJ1ZTtcbiAgICBub2RlID0gZG9jdW1lbnQkMi5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZmx1c2gpLm9ic2VydmUobm9kZSwgeyBjaGFyYWN0ZXJEYXRhOiB0cnVlIH0pO1xuICAgIG5vdGlmeSQxID0gZnVuY3Rpb24gKCkge1xuICAgICAgbm9kZS5kYXRhID0gdG9nZ2xlID0gIXRvZ2dsZTtcbiAgICB9O1xuICAvLyBlbnZpcm9ubWVudHMgd2l0aCBtYXliZSBub24tY29tcGxldGVseSBjb3JyZWN0LCBidXQgZXhpc3RlbnQgUHJvbWlzZVxuICB9IGVsc2UgaWYgKCFJU19JT1NfUEVCQkxFICYmIFByb21pc2UkMSAmJiBQcm9taXNlJDEucmVzb2x2ZSkge1xuICAgIC8vIFByb21pc2UucmVzb2x2ZSB3aXRob3V0IGFuIGFyZ3VtZW50IHRocm93cyBhbiBlcnJvciBpbiBMRyBXZWJPUyAyXG4gICAgcHJvbWlzZSA9IFByb21pc2UkMS5yZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgLy8gd29ya2Fyb3VuZCBvZiBXZWJLaXQgfiBpT1MgU2FmYXJpIDEwLjEgYnVnXG4gICAgcHJvbWlzZS5jb25zdHJ1Y3RvciA9IFByb21pc2UkMTtcbiAgICB0aGVuID0gYmluZCQyKHByb21pc2UudGhlbiwgcHJvbWlzZSk7XG4gICAgbm90aWZ5JDEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGVuKGZsdXNoKTtcbiAgICB9O1xuICAvLyBOb2RlLmpzIHdpdGhvdXQgcHJvbWlzZXNcbiAgfSBlbHNlIGlmIChJU19OT0RFJDEpIHtcbiAgICBub3RpZnkkMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHByb2Nlc3MkMS5uZXh0VGljayhmbHVzaCk7XG4gICAgfTtcbiAgLy8gZm9yIG90aGVyIGVudmlyb25tZW50cyAtIG1hY3JvdGFzayBiYXNlZCBvbjpcbiAgLy8gLSBzZXRJbW1lZGlhdGVcbiAgLy8gLSBNZXNzYWdlQ2hhbm5lbFxuICAvLyAtIHdpbmRvdy5wb3N0TWVzc2FnZVxuICAvLyAtIG9ucmVhZHlzdGF0ZWNoYW5nZVxuICAvLyAtIHNldFRpbWVvdXRcbiAgfSBlbHNlIHtcbiAgICAvLyBzdHJhbmdlIElFICsgd2VicGFjayBkZXYgc2VydmVyIGJ1ZyAtIHVzZSAuYmluZChnbG9iYWwpXG4gICAgbWFjcm90YXNrID0gYmluZCQyKG1hY3JvdGFzaywgZ2xvYmFsJDUpO1xuICAgIG5vdGlmeSQxID0gZnVuY3Rpb24gKCkge1xuICAgICAgbWFjcm90YXNrKGZsdXNoKTtcbiAgICB9O1xuICB9XG59XG5cbnZhciBtaWNyb3Rhc2skMSA9IHF1ZXVlTWljcm90YXNrIHx8IGZ1bmN0aW9uIChmbikge1xuICB2YXIgdGFzayA9IHsgZm46IGZuLCBuZXh0OiB1bmRlZmluZWQgfTtcbiAgaWYgKGxhc3QpIGxhc3QubmV4dCA9IHRhc2s7XG4gIGlmICghaGVhZCkge1xuICAgIGhlYWQgPSB0YXNrO1xuICAgIG5vdGlmeSQxKCk7XG4gIH0gbGFzdCA9IHRhc2s7XG59O1xuXG52YXIgZ2xvYmFsJDQgPSBnbG9iYWwkajtcblxudmFyIGhvc3RSZXBvcnRFcnJvcnMkMSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gIHZhciBjb25zb2xlID0gZ2xvYmFsJDQuY29uc29sZTtcbiAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS5lcnJvcikge1xuICAgIGFyZ3VtZW50cy5sZW5ndGggPT0gMSA/IGNvbnNvbGUuZXJyb3IoYSkgOiBjb25zb2xlLmVycm9yKGEsIGIpO1xuICB9XG59O1xuXG52YXIgcGVyZm9ybSQzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4geyBlcnJvcjogZmFsc2UsIHZhbHVlOiBleGVjKCkgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4geyBlcnJvcjogdHJ1ZSwgdmFsdWU6IGVycm9yIH07XG4gIH1cbn07XG5cbnZhciBRdWV1ZSQxID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmhlYWQgPSBudWxsO1xuICB0aGlzLnRhaWwgPSBudWxsO1xufTtcblxuUXVldWUkMS5wcm90b3R5cGUgPSB7XG4gIGFkZDogZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICB2YXIgZW50cnkgPSB7IGl0ZW06IGl0ZW0sIG5leHQ6IG51bGwgfTtcbiAgICBpZiAodGhpcy5oZWFkKSB0aGlzLnRhaWwubmV4dCA9IGVudHJ5O1xuICAgIGVsc2UgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgdGhpcy50YWlsID0gZW50cnk7XG4gIH0sXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbnRyeSA9IHRoaXMuaGVhZDtcbiAgICBpZiAoZW50cnkpIHtcbiAgICAgIHRoaXMuaGVhZCA9IGVudHJ5Lm5leHQ7XG4gICAgICBpZiAodGhpcy50YWlsID09PSBlbnRyeSkgdGhpcy50YWlsID0gbnVsbDtcbiAgICAgIHJldHVybiBlbnRyeS5pdGVtO1xuICAgIH1cbiAgfVxufTtcblxudmFyIHF1ZXVlID0gUXVldWUkMTtcblxudmFyIGdsb2JhbCQzID0gZ2xvYmFsJGo7XG5cbnZhciBwcm9taXNlTmF0aXZlQ29uc3RydWN0b3IgPSBnbG9iYWwkMy5Qcm9taXNlO1xuXG52YXIgZW5naW5lSXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgRGVubyAhPSAnb2JqZWN0JztcblxudmFyIGdsb2JhbCQyID0gZ2xvYmFsJGo7XG52YXIgTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yJDMgPSBwcm9taXNlTmF0aXZlQ29uc3RydWN0b3I7XG52YXIgaXNDYWxsYWJsZSQyID0gaXNDYWxsYWJsZSRrO1xudmFyIGlzRm9yY2VkID0gaXNGb3JjZWRfMTtcbnZhciBpbnNwZWN0U291cmNlID0gaW5zcGVjdFNvdXJjZSQ0O1xudmFyIHdlbGxLbm93blN5bWJvbCQzID0gd2VsbEtub3duU3ltYm9sJGU7XG52YXIgSVNfQlJPV1NFUiA9IGVuZ2luZUlzQnJvd3NlcjtcbnZhciBWOF9WRVJTSU9OID0gZW5naW5lVjhWZXJzaW9uO1xuXG5OYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMyAmJiBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMy5wcm90b3R5cGU7XG52YXIgU1BFQ0lFUyA9IHdlbGxLbm93blN5bWJvbCQzKCdzcGVjaWVzJyk7XG52YXIgU1VCQ0xBU1NJTkcgPSBmYWxzZTtcbnZhciBOQVRJVkVfUFJPTUlTRV9SRUpFQ1RJT05fRVZFTlQkMSA9IGlzQ2FsbGFibGUkMihnbG9iYWwkMi5Qcm9taXNlUmVqZWN0aW9uRXZlbnQpO1xuXG52YXIgRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkNSA9IGlzRm9yY2VkKCdQcm9taXNlJywgZnVuY3Rpb24gKCkge1xuICB2YXIgUFJPTUlTRV9DT05TVFJVQ1RPUl9TT1VSQ0UgPSBpbnNwZWN0U291cmNlKE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQzKTtcbiAgdmFyIEdMT0JBTF9DT1JFX0pTX1BST01JU0UgPSBQUk9NSVNFX0NPTlNUUlVDVE9SX1NPVVJDRSAhPT0gU3RyaW5nKE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQzKTtcbiAgLy8gVjggNi42IChOb2RlIDEwIGFuZCBDaHJvbWUgNjYpIGhhdmUgYSBidWcgd2l0aCByZXNvbHZpbmcgY3VzdG9tIHRoZW5hYmxlc1xuICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD04MzA1NjVcbiAgLy8gV2UgY2FuJ3QgZGV0ZWN0IGl0IHN5bmNocm9ub3VzbHksIHNvIGp1c3QgY2hlY2sgdmVyc2lvbnNcbiAgaWYgKCFHTE9CQUxfQ09SRV9KU19QUk9NSVNFICYmIFY4X1ZFUlNJT04gPT09IDY2KSByZXR1cm4gdHJ1ZTtcbiAgLy8gV2UgY2FuJ3QgdXNlIEBAc3BlY2llcyBmZWF0dXJlIGRldGVjdGlvbiBpbiBWOCBzaW5jZSBpdCBjYXVzZXNcbiAgLy8gZGVvcHRpbWl6YXRpb24gYW5kIHBlcmZvcm1hbmNlIGRlZ3JhZGF0aW9uXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy82NzlcbiAgaWYgKFY4X1ZFUlNJT04gPj0gNTEgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KFBST01JU0VfQ09OU1RSVUNUT1JfU09VUkNFKSkgcmV0dXJuIGZhbHNlO1xuICAvLyBEZXRlY3QgY29ycmVjdG5lc3Mgb2Ygc3ViY2xhc3Npbmcgd2l0aCBAQHNwZWNpZXMgc3VwcG9ydFxuICB2YXIgcHJvbWlzZSA9IG5ldyBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMyhmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKDEpOyB9KTtcbiAgdmFyIEZha2VQcm9taXNlID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgICBleGVjKGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSwgZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9KTtcbiAgfTtcbiAgdmFyIGNvbnN0cnVjdG9yID0gcHJvbWlzZS5jb25zdHJ1Y3RvciA9IHt9O1xuICBjb25zdHJ1Y3RvcltTUEVDSUVTXSA9IEZha2VQcm9taXNlO1xuICBTVUJDTEFTU0lORyA9IHByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0pIGluc3RhbmNlb2YgRmFrZVByb21pc2U7XG4gIGlmICghU1VCQ0xBU1NJTkcpIHJldHVybiB0cnVlO1xuICAvLyBVbmhhbmRsZWQgcmVqZWN0aW9ucyB0cmFja2luZyBzdXBwb3J0LCBOb2RlSlMgUHJvbWlzZSB3aXRob3V0IGl0IGZhaWxzIEBAc3BlY2llcyB0ZXN0XG4gIHJldHVybiAhR0xPQkFMX0NPUkVfSlNfUFJPTUlTRSAmJiBJU19CUk9XU0VSICYmICFOQVRJVkVfUFJPTUlTRV9SRUpFQ1RJT05fRVZFTlQkMTtcbn0pO1xuXG52YXIgcHJvbWlzZUNvbnN0cnVjdG9yRGV0ZWN0aW9uID0ge1xuICBDT05TVFJVQ1RPUjogRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkNSxcbiAgUkVKRUNUSU9OX0VWRU5UOiBOQVRJVkVfUFJPTUlTRV9SRUpFQ1RJT05fRVZFTlQkMSxcbiAgU1VCQ0xBU1NJTkc6IFNVQkNMQVNTSU5HXG59O1xuXG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkkMiA9IHt9O1xuXG52YXIgYUNhbGxhYmxlJDQgPSBhQ2FsbGFibGUkNztcblxudmFyIFByb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24gKEMpIHtcbiAgdmFyIHJlc29sdmUsIHJlamVjdDtcbiAgdGhpcy5wcm9taXNlID0gbmV3IEMoZnVuY3Rpb24gKCQkcmVzb2x2ZSwgJCRyZWplY3QpIHtcbiAgICBpZiAocmVzb2x2ZSAhPT0gdW5kZWZpbmVkIHx8IHJlamVjdCAhPT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoJ0JhZCBQcm9taXNlIGNvbnN0cnVjdG9yJyk7XG4gICAgcmVzb2x2ZSA9ICQkcmVzb2x2ZTtcbiAgICByZWplY3QgPSAkJHJlamVjdDtcbiAgfSk7XG4gIHRoaXMucmVzb2x2ZSA9IGFDYWxsYWJsZSQ0KHJlc29sdmUpO1xuICB0aGlzLnJlamVjdCA9IGFDYWxsYWJsZSQ0KHJlamVjdCk7XG59O1xuXG4vLyBgTmV3UHJvbWlzZUNhcGFiaWxpdHlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1uZXdwcm9taXNlY2FwYWJpbGl0eVxubmV3UHJvbWlzZUNhcGFiaWxpdHkkMi5mID0gZnVuY3Rpb24gKEMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlQ2FwYWJpbGl0eShDKTtcbn07XG5cbnZhciAkJDUgPSBfZXhwb3J0O1xudmFyIElTX05PREUgPSBlbmdpbmVJc05vZGU7XG52YXIgZ2xvYmFsJDEgPSBnbG9iYWwkajtcbnZhciBjYWxsJDcgPSBmdW5jdGlvbkNhbGw7XG52YXIgZGVmaW5lQnVpbHRJbiQyID0gZGVmaW5lQnVpbHRJbiQ2O1xudmFyIHNldFByb3RvdHlwZU9mID0gb2JqZWN0U2V0UHJvdG90eXBlT2Y7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSBzZXRUb1N0cmluZ1RhZyQzO1xudmFyIHNldFNwZWNpZXMgPSBzZXRTcGVjaWVzJDE7XG52YXIgYUNhbGxhYmxlJDMgPSBhQ2FsbGFibGUkNztcbnZhciBpc0NhbGxhYmxlJDEgPSBpc0NhbGxhYmxlJGs7XG52YXIgaXNPYmplY3QkMSA9IGlzT2JqZWN0JDc7XG52YXIgYW5JbnN0YW5jZSA9IGFuSW5zdGFuY2UkMTtcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSBzcGVjaWVzQ29uc3RydWN0b3IkMTtcbnZhciB0YXNrID0gdGFzayQxLnNldDtcbnZhciBtaWNyb3Rhc2sgPSBtaWNyb3Rhc2skMTtcbnZhciBob3N0UmVwb3J0RXJyb3JzID0gaG9zdFJlcG9ydEVycm9ycyQxO1xudmFyIHBlcmZvcm0kMiA9IHBlcmZvcm0kMztcbnZhciBRdWV1ZSA9IHF1ZXVlO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSBpbnRlcm5hbFN0YXRlO1xudmFyIE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQyID0gcHJvbWlzZU5hdGl2ZUNvbnN0cnVjdG9yO1xudmFyIFByb21pc2VDb25zdHJ1Y3RvckRldGVjdGlvbiA9IHByb21pc2VDb25zdHJ1Y3RvckRldGVjdGlvbjtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSQzID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkkMjtcblxudmFyIFBST01JU0UgPSAnUHJvbWlzZSc7XG52YXIgRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkNCA9IFByb21pc2VDb25zdHJ1Y3RvckRldGVjdGlvbi5DT05TVFJVQ1RPUjtcbnZhciBOQVRJVkVfUFJPTUlTRV9SRUpFQ1RJT05fRVZFTlQgPSBQcm9taXNlQ29uc3RydWN0b3JEZXRlY3Rpb24uUkVKRUNUSU9OX0VWRU5UO1xudmFyIE5BVElWRV9QUk9NSVNFX1NVQkNMQVNTSU5HID0gUHJvbWlzZUNvbnN0cnVjdG9yRGV0ZWN0aW9uLlNVQkNMQVNTSU5HO1xudmFyIGdldEludGVybmFsUHJvbWlzZVN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXR0ZXJGb3IoUFJPTUlTRSk7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuc2V0O1xudmFyIE5hdGl2ZVByb21pc2VQcm90b3R5cGUkMSA9IE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQyICYmIE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQyLnByb3RvdHlwZTtcbnZhciBQcm9taXNlQ29uc3RydWN0b3IgPSBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMjtcbnZhciBQcm9taXNlUHJvdG90eXBlID0gTmF0aXZlUHJvbWlzZVByb3RvdHlwZSQxO1xudmFyIFR5cGVFcnJvciQxID0gZ2xvYmFsJDEuVHlwZUVycm9yO1xudmFyIGRvY3VtZW50JDEgPSBnbG9iYWwkMS5kb2N1bWVudDtcbnZhciBwcm9jZXNzID0gZ2xvYmFsJDEucHJvY2VzcztcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSQxID0gbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUkMy5mO1xudmFyIG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5JDE7XG5cbnZhciBESVNQQVRDSF9FVkVOVCA9ICEhKGRvY3VtZW50JDEgJiYgZG9jdW1lbnQkMS5jcmVhdGVFdmVudCAmJiBnbG9iYWwkMS5kaXNwYXRjaEV2ZW50KTtcbnZhciBVTkhBTkRMRURfUkVKRUNUSU9OID0gJ3VuaGFuZGxlZHJlamVjdGlvbic7XG52YXIgUkVKRUNUSU9OX0hBTkRMRUQgPSAncmVqZWN0aW9uaGFuZGxlZCc7XG52YXIgUEVORElORyA9IDA7XG52YXIgRlVMRklMTEVEID0gMTtcbnZhciBSRUpFQ1RFRCA9IDI7XG52YXIgSEFORExFRCA9IDE7XG52YXIgVU5IQU5ETEVEID0gMjtcblxudmFyIEludGVybmFsLCBPd25Qcm9taXNlQ2FwYWJpbGl0eSwgUHJvbWlzZVdyYXBwZXIsIG5hdGl2ZVRoZW47XG5cbi8vIGhlbHBlcnNcbnZhciBpc1RoZW5hYmxlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciB0aGVuO1xuICByZXR1cm4gaXNPYmplY3QkMShpdCkgJiYgaXNDYWxsYWJsZSQxKHRoZW4gPSBpdC50aGVuKSA/IHRoZW4gOiBmYWxzZTtcbn07XG5cbnZhciBjYWxsUmVhY3Rpb24gPSBmdW5jdGlvbiAocmVhY3Rpb24sIHN0YXRlKSB7XG4gIHZhciB2YWx1ZSA9IHN0YXRlLnZhbHVlO1xuICB2YXIgb2sgPSBzdGF0ZS5zdGF0ZSA9PSBGVUxGSUxMRUQ7XG4gIHZhciBoYW5kbGVyID0gb2sgPyByZWFjdGlvbi5vayA6IHJlYWN0aW9uLmZhaWw7XG4gIHZhciByZXNvbHZlID0gcmVhY3Rpb24ucmVzb2x2ZTtcbiAgdmFyIHJlamVjdCA9IHJlYWN0aW9uLnJlamVjdDtcbiAgdmFyIGRvbWFpbiA9IHJlYWN0aW9uLmRvbWFpbjtcbiAgdmFyIHJlc3VsdCwgdGhlbiwgZXhpdGVkO1xuICB0cnkge1xuICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICBpZiAoIW9rKSB7XG4gICAgICAgIGlmIChzdGF0ZS5yZWplY3Rpb24gPT09IFVOSEFORExFRCkgb25IYW5kbGVVbmhhbmRsZWQoc3RhdGUpO1xuICAgICAgICBzdGF0ZS5yZWplY3Rpb24gPSBIQU5ETEVEO1xuICAgICAgfVxuICAgICAgaWYgKGhhbmRsZXIgPT09IHRydWUpIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChkb21haW4pIGRvbWFpbi5lbnRlcigpO1xuICAgICAgICByZXN1bHQgPSBoYW5kbGVyKHZhbHVlKTsgLy8gY2FuIHRocm93XG4gICAgICAgIGlmIChkb21haW4pIHtcbiAgICAgICAgICBkb21haW4uZXhpdCgpO1xuICAgICAgICAgIGV4aXRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQgPT09IHJlYWN0aW9uLnByb21pc2UpIHtcbiAgICAgICAgcmVqZWN0KFR5cGVFcnJvciQxKCdQcm9taXNlLWNoYWluIGN5Y2xlJykpO1xuICAgICAgfSBlbHNlIGlmICh0aGVuID0gaXNUaGVuYWJsZShyZXN1bHQpKSB7XG4gICAgICAgIGNhbGwkNyh0aGVuLCByZXN1bHQsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9IGVsc2UgcmVzb2x2ZShyZXN1bHQpO1xuICAgIH0gZWxzZSByZWplY3QodmFsdWUpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChkb21haW4gJiYgIWV4aXRlZCkgZG9tYWluLmV4aXQoKTtcbiAgICByZWplY3QoZXJyb3IpO1xuICB9XG59O1xuXG52YXIgbm90aWZ5ID0gZnVuY3Rpb24gKHN0YXRlLCBpc1JlamVjdCkge1xuICBpZiAoc3RhdGUubm90aWZpZWQpIHJldHVybjtcbiAgc3RhdGUubm90aWZpZWQgPSB0cnVlO1xuICBtaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgIHZhciByZWFjdGlvbnMgPSBzdGF0ZS5yZWFjdGlvbnM7XG4gICAgdmFyIHJlYWN0aW9uO1xuICAgIHdoaWxlIChyZWFjdGlvbiA9IHJlYWN0aW9ucy5nZXQoKSkge1xuICAgICAgY2FsbFJlYWN0aW9uKHJlYWN0aW9uLCBzdGF0ZSk7XG4gICAgfVxuICAgIHN0YXRlLm5vdGlmaWVkID0gZmFsc2U7XG4gICAgaWYgKGlzUmVqZWN0ICYmICFzdGF0ZS5yZWplY3Rpb24pIG9uVW5oYW5kbGVkKHN0YXRlKTtcbiAgfSk7XG59O1xuXG52YXIgZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uIChuYW1lLCBwcm9taXNlLCByZWFzb24pIHtcbiAgdmFyIGV2ZW50LCBoYW5kbGVyO1xuICBpZiAoRElTUEFUQ0hfRVZFTlQpIHtcbiAgICBldmVudCA9IGRvY3VtZW50JDEuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgZXZlbnQucHJvbWlzZSA9IHByb21pc2U7XG4gICAgZXZlbnQucmVhc29uID0gcmVhc29uO1xuICAgIGV2ZW50LmluaXRFdmVudChuYW1lLCBmYWxzZSwgdHJ1ZSk7XG4gICAgZ2xvYmFsJDEuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gIH0gZWxzZSBldmVudCA9IHsgcHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiByZWFzb24gfTtcbiAgaWYgKCFOQVRJVkVfUFJPTUlTRV9SRUpFQ1RJT05fRVZFTlQgJiYgKGhhbmRsZXIgPSBnbG9iYWwkMVsnb24nICsgbmFtZV0pKSBoYW5kbGVyKGV2ZW50KTtcbiAgZWxzZSBpZiAobmFtZSA9PT0gVU5IQU5ETEVEX1JFSkVDVElPTikgaG9zdFJlcG9ydEVycm9ycygnVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uJywgcmVhc29uKTtcbn07XG5cbnZhciBvblVuaGFuZGxlZCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICBjYWxsJDcodGFzaywgZ2xvYmFsJDEsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvbWlzZSA9IHN0YXRlLmZhY2FkZTtcbiAgICB2YXIgdmFsdWUgPSBzdGF0ZS52YWx1ZTtcbiAgICB2YXIgSVNfVU5IQU5ETEVEID0gaXNVbmhhbmRsZWQoc3RhdGUpO1xuICAgIHZhciByZXN1bHQ7XG4gICAgaWYgKElTX1VOSEFORExFRCkge1xuICAgICAgcmVzdWx0ID0gcGVyZm9ybSQyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKElTX05PREUpIHtcbiAgICAgICAgICBwcm9jZXNzLmVtaXQoJ3VuaGFuZGxlZFJlamVjdGlvbicsIHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgfSBlbHNlIGRpc3BhdGNoRXZlbnQoVU5IQU5ETEVEX1JFSkVDVElPTiwgcHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgICAvLyBCcm93c2VycyBzaG91bGQgbm90IHRyaWdnZXIgYHJlamVjdGlvbkhhbmRsZWRgIGV2ZW50IGlmIGl0IHdhcyBoYW5kbGVkIGhlcmUsIE5vZGVKUyAtIHNob3VsZFxuICAgICAgc3RhdGUucmVqZWN0aW9uID0gSVNfTk9ERSB8fCBpc1VuaGFuZGxlZChzdGF0ZSkgPyBVTkhBTkRMRUQgOiBIQU5ETEVEO1xuICAgICAgaWYgKHJlc3VsdC5lcnJvcikgdGhyb3cgcmVzdWx0LnZhbHVlO1xuICAgIH1cbiAgfSk7XG59O1xuXG52YXIgaXNVbmhhbmRsZWQgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLnJlamVjdGlvbiAhPT0gSEFORExFRCAmJiAhc3RhdGUucGFyZW50O1xufTtcblxudmFyIG9uSGFuZGxlVW5oYW5kbGVkID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gIGNhbGwkNyh0YXNrLCBnbG9iYWwkMSwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9taXNlID0gc3RhdGUuZmFjYWRlO1xuICAgIGlmIChJU19OT0RFKSB7XG4gICAgICBwcm9jZXNzLmVtaXQoJ3JlamVjdGlvbkhhbmRsZWQnLCBwcm9taXNlKTtcbiAgICB9IGVsc2UgZGlzcGF0Y2hFdmVudChSRUpFQ1RJT05fSEFORExFRCwgcHJvbWlzZSwgc3RhdGUudmFsdWUpO1xuICB9KTtcbn07XG5cbnZhciBiaW5kJDEgPSBmdW5jdGlvbiAoZm4sIHN0YXRlLCB1bndyYXApIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGZuKHN0YXRlLCB2YWx1ZSwgdW53cmFwKTtcbiAgfTtcbn07XG5cbnZhciBpbnRlcm5hbFJlamVjdCA9IGZ1bmN0aW9uIChzdGF0ZSwgdmFsdWUsIHVud3JhcCkge1xuICBpZiAoc3RhdGUuZG9uZSkgcmV0dXJuO1xuICBzdGF0ZS5kb25lID0gdHJ1ZTtcbiAgaWYgKHVud3JhcCkgc3RhdGUgPSB1bndyYXA7XG4gIHN0YXRlLnZhbHVlID0gdmFsdWU7XG4gIHN0YXRlLnN0YXRlID0gUkVKRUNURUQ7XG4gIG5vdGlmeShzdGF0ZSwgdHJ1ZSk7XG59O1xuXG52YXIgaW50ZXJuYWxSZXNvbHZlID0gZnVuY3Rpb24gKHN0YXRlLCB2YWx1ZSwgdW53cmFwKSB7XG4gIGlmIChzdGF0ZS5kb25lKSByZXR1cm47XG4gIHN0YXRlLmRvbmUgPSB0cnVlO1xuICBpZiAodW53cmFwKSBzdGF0ZSA9IHVud3JhcDtcbiAgdHJ5IHtcbiAgICBpZiAoc3RhdGUuZmFjYWRlID09PSB2YWx1ZSkgdGhyb3cgVHlwZUVycm9yJDEoXCJQcm9taXNlIGNhbid0IGJlIHJlc29sdmVkIGl0c2VsZlwiKTtcbiAgICB2YXIgdGhlbiA9IGlzVGhlbmFibGUodmFsdWUpO1xuICAgIGlmICh0aGVuKSB7XG4gICAgICBtaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgd3JhcHBlciA9IHsgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjYWxsJDcodGhlbiwgdmFsdWUsXG4gICAgICAgICAgICBiaW5kJDEoaW50ZXJuYWxSZXNvbHZlLCB3cmFwcGVyLCBzdGF0ZSksXG4gICAgICAgICAgICBiaW5kJDEoaW50ZXJuYWxSZWplY3QsIHdyYXBwZXIsIHN0YXRlKVxuICAgICAgICAgICk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgaW50ZXJuYWxSZWplY3Qod3JhcHBlciwgZXJyb3IsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnZhbHVlID0gdmFsdWU7XG4gICAgICBzdGF0ZS5zdGF0ZSA9IEZVTEZJTExFRDtcbiAgICAgIG5vdGlmeShzdGF0ZSwgZmFsc2UpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpbnRlcm5hbFJlamVjdCh7IGRvbmU6IGZhbHNlIH0sIGVycm9yLCBzdGF0ZSk7XG4gIH1cbn07XG5cbi8vIGNvbnN0cnVjdG9yIHBvbHlmaWxsXG5pZiAoRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkNCkge1xuICAvLyAyNS40LjMuMSBQcm9taXNlKGV4ZWN1dG9yKVxuICBQcm9taXNlQ29uc3RydWN0b3IgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XG4gICAgYW5JbnN0YW5jZSh0aGlzLCBQcm9taXNlUHJvdG90eXBlKTtcbiAgICBhQ2FsbGFibGUkMyhleGVjdXRvcik7XG4gICAgY2FsbCQ3KEludGVybmFsLCB0aGlzKTtcbiAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFByb21pc2VTdGF0ZSh0aGlzKTtcbiAgICB0cnkge1xuICAgICAgZXhlY3V0b3IoYmluZCQxKGludGVybmFsUmVzb2x2ZSwgc3RhdGUpLCBiaW5kJDEoaW50ZXJuYWxSZWplY3QsIHN0YXRlKSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGludGVybmFsUmVqZWN0KHN0YXRlLCBlcnJvcik7XG4gICAgfVxuICB9O1xuXG4gIFByb21pc2VQcm90b3R5cGUgPSBQcm9taXNlQ29uc3RydWN0b3IucHJvdG90eXBlO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFycyAtLSByZXF1aXJlZCBmb3IgYC5sZW5ndGhgXG4gIEludGVybmFsID0gZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcikge1xuICAgIHNldEludGVybmFsU3RhdGUodGhpcywge1xuICAgICAgdHlwZTogUFJPTUlTRSxcbiAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgbm90aWZpZWQ6IGZhbHNlLFxuICAgICAgcGFyZW50OiBmYWxzZSxcbiAgICAgIHJlYWN0aW9uczogbmV3IFF1ZXVlKCksXG4gICAgICByZWplY3Rpb246IGZhbHNlLFxuICAgICAgc3RhdGU6IFBFTkRJTkcsXG4gICAgICB2YWx1ZTogdW5kZWZpbmVkXG4gICAgfSk7XG4gIH07XG5cbiAgLy8gYFByb21pc2UucHJvdG90eXBlLnRoZW5gIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXByb21pc2UucHJvdG90eXBlLnRoZW5cbiAgSW50ZXJuYWwucHJvdG90eXBlID0gZGVmaW5lQnVpbHRJbiQyKFByb21pc2VQcm90b3R5cGUsICd0aGVuJywgZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsUHJvbWlzZVN0YXRlKHRoaXMpO1xuICAgIHZhciByZWFjdGlvbiA9IG5ld1Byb21pc2VDYXBhYmlsaXR5JDEoc3BlY2llc0NvbnN0cnVjdG9yKHRoaXMsIFByb21pc2VDb25zdHJ1Y3RvcikpO1xuICAgIHN0YXRlLnBhcmVudCA9IHRydWU7XG4gICAgcmVhY3Rpb24ub2sgPSBpc0NhbGxhYmxlJDEob25GdWxmaWxsZWQpID8gb25GdWxmaWxsZWQgOiB0cnVlO1xuICAgIHJlYWN0aW9uLmZhaWwgPSBpc0NhbGxhYmxlJDEob25SZWplY3RlZCkgJiYgb25SZWplY3RlZDtcbiAgICByZWFjdGlvbi5kb21haW4gPSBJU19OT0RFID8gcHJvY2Vzcy5kb21haW4gOiB1bmRlZmluZWQ7XG4gICAgaWYgKHN0YXRlLnN0YXRlID09IFBFTkRJTkcpIHN0YXRlLnJlYWN0aW9ucy5hZGQocmVhY3Rpb24pO1xuICAgIGVsc2UgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxSZWFjdGlvbihyZWFjdGlvbiwgc3RhdGUpO1xuICAgIH0pO1xuICAgIHJldHVybiByZWFjdGlvbi5wcm9taXNlO1xuICB9KTtcblxuICBPd25Qcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBJbnRlcm5hbCgpO1xuICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsUHJvbWlzZVN0YXRlKHByb21pc2UpO1xuICAgIHRoaXMucHJvbWlzZSA9IHByb21pc2U7XG4gICAgdGhpcy5yZXNvbHZlID0gYmluZCQxKGludGVybmFsUmVzb2x2ZSwgc3RhdGUpO1xuICAgIHRoaXMucmVqZWN0ID0gYmluZCQxKGludGVybmFsUmVqZWN0LCBzdGF0ZSk7XG4gIH07XG5cbiAgbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUkMy5mID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkkMSA9IGZ1bmN0aW9uIChDKSB7XG4gICAgcmV0dXJuIEMgPT09IFByb21pc2VDb25zdHJ1Y3RvciB8fCBDID09PSBQcm9taXNlV3JhcHBlclxuICAgICAgPyBuZXcgT3duUHJvbWlzZUNhcGFiaWxpdHkoQylcbiAgICAgIDogbmV3R2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5KEMpO1xuICB9O1xuXG4gIGlmIChpc0NhbGxhYmxlJDEoTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yJDIpICYmIE5hdGl2ZVByb21pc2VQcm90b3R5cGUkMSAhPT0gT2JqZWN0LnByb3RvdHlwZSkge1xuICAgIG5hdGl2ZVRoZW4gPSBOYXRpdmVQcm9taXNlUHJvdG90eXBlJDEudGhlbjtcblxuICAgIGlmICghTkFUSVZFX1BST01JU0VfU1VCQ0xBU1NJTkcpIHtcbiAgICAgIC8vIG1ha2UgYFByb21pc2UjdGhlbmAgcmV0dXJuIGEgcG9seWZpbGxlZCBgUHJvbWlzZWAgZm9yIG5hdGl2ZSBwcm9taXNlLWJhc2VkIEFQSXNcbiAgICAgIGRlZmluZUJ1aWx0SW4kMihOYXRpdmVQcm9taXNlUHJvdG90eXBlJDEsICd0aGVuJywgZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZUNvbnN0cnVjdG9yKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBjYWxsJDcobmF0aXZlVGhlbiwgdGhhdCwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSkudGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCk7XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNjQwXG4gICAgICB9LCB7IHVuc2FmZTogdHJ1ZSB9KTtcbiAgICB9XG5cbiAgICAvLyBtYWtlIGAuY29uc3RydWN0b3IgPT09IFByb21pc2VgIHdvcmsgZm9yIG5hdGl2ZSBwcm9taXNlLWJhc2VkIEFQSXNcbiAgICB0cnkge1xuICAgICAgZGVsZXRlIE5hdGl2ZVByb21pc2VQcm90b3R5cGUkMS5jb25zdHJ1Y3RvcjtcbiAgICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG5cbiAgICAvLyBtYWtlIGBpbnN0YW5jZW9mIFByb21pc2VgIHdvcmsgZm9yIG5hdGl2ZSBwcm9taXNlLWJhc2VkIEFQSXNcbiAgICBpZiAoc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIHNldFByb3RvdHlwZU9mKE5hdGl2ZVByb21pc2VQcm90b3R5cGUkMSwgUHJvbWlzZVByb3RvdHlwZSk7XG4gICAgfVxuICB9XG59XG5cbiQkNSh7IGdsb2JhbDogdHJ1ZSwgY29uc3RydWN0b3I6IHRydWUsIHdyYXA6IHRydWUsIGZvcmNlZDogRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkNCB9LCB7XG4gIFByb21pc2U6IFByb21pc2VDb25zdHJ1Y3RvclxufSk7XG5cbnNldFRvU3RyaW5nVGFnKFByb21pc2VDb25zdHJ1Y3RvciwgUFJPTUlTRSwgZmFsc2UpO1xuc2V0U3BlY2llcyhQUk9NSVNFKTtcblxudmFyIHdlbGxLbm93blN5bWJvbCQyID0gd2VsbEtub3duU3ltYm9sJGU7XG52YXIgSXRlcmF0b3JzJDEgPSBpdGVyYXRvcnM7XG5cbnZhciBJVEVSQVRPUiQyID0gd2VsbEtub3duU3ltYm9sJDIoJ2l0ZXJhdG9yJyk7XG52YXIgQXJyYXlQcm90b3R5cGUgPSBBcnJheS5wcm90b3R5cGU7XG5cbi8vIGNoZWNrIG9uIGRlZmF1bHQgQXJyYXkgaXRlcmF0b3JcbnZhciBpc0FycmF5SXRlcmF0b3JNZXRob2QkMSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJiAoSXRlcmF0b3JzJDEuQXJyYXkgPT09IGl0IHx8IEFycmF5UHJvdG90eXBlW0lURVJBVE9SJDJdID09PSBpdCk7XG59O1xuXG52YXIgY2xhc3NvZiQxID0gY2xhc3NvZiQzO1xudmFyIGdldE1ldGhvZCQxID0gZ2V0TWV0aG9kJDM7XG52YXIgSXRlcmF0b3JzID0gaXRlcmF0b3JzO1xudmFyIHdlbGxLbm93blN5bWJvbCQxID0gd2VsbEtub3duU3ltYm9sJGU7XG5cbnZhciBJVEVSQVRPUiQxID0gd2VsbEtub3duU3ltYm9sJDEoJ2l0ZXJhdG9yJyk7XG5cbnZhciBnZXRJdGVyYXRvck1ldGhvZCQyID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCAhPSB1bmRlZmluZWQpIHJldHVybiBnZXRNZXRob2QkMShpdCwgSVRFUkFUT1IkMSlcbiAgICB8fCBnZXRNZXRob2QkMShpdCwgJ0BAaXRlcmF0b3InKVxuICAgIHx8IEl0ZXJhdG9yc1tjbGFzc29mJDEoaXQpXTtcbn07XG5cbnZhciBjYWxsJDYgPSBmdW5jdGlvbkNhbGw7XG52YXIgYUNhbGxhYmxlJDIgPSBhQ2FsbGFibGUkNztcbnZhciBhbk9iamVjdCQ1ID0gYW5PYmplY3QkYztcbnZhciB0cnlUb1N0cmluZyQxID0gdHJ5VG9TdHJpbmckNDtcbnZhciBnZXRJdGVyYXRvck1ldGhvZCQxID0gZ2V0SXRlcmF0b3JNZXRob2QkMjtcblxudmFyICRUeXBlRXJyb3IkMSA9IFR5cGVFcnJvcjtcblxudmFyIGdldEl0ZXJhdG9yJDEgPSBmdW5jdGlvbiAoYXJndW1lbnQsIHVzaW5nSXRlcmF0b3IpIHtcbiAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBnZXRJdGVyYXRvck1ldGhvZCQxKGFyZ3VtZW50KSA6IHVzaW5nSXRlcmF0b3I7XG4gIGlmIChhQ2FsbGFibGUkMihpdGVyYXRvck1ldGhvZCkpIHJldHVybiBhbk9iamVjdCQ1KGNhbGwkNihpdGVyYXRvck1ldGhvZCwgYXJndW1lbnQpKTtcbiAgdGhyb3cgJFR5cGVFcnJvciQxKHRyeVRvU3RyaW5nJDEoYXJndW1lbnQpICsgJyBpcyBub3QgaXRlcmFibGUnKTtcbn07XG5cbnZhciBjYWxsJDUgPSBmdW5jdGlvbkNhbGw7XG52YXIgYW5PYmplY3QkNCA9IGFuT2JqZWN0JGM7XG52YXIgZ2V0TWV0aG9kID0gZ2V0TWV0aG9kJDM7XG5cbnZhciBpdGVyYXRvckNsb3NlJDEgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIGtpbmQsIHZhbHVlKSB7XG4gIHZhciBpbm5lclJlc3VsdCwgaW5uZXJFcnJvcjtcbiAgYW5PYmplY3QkNChpdGVyYXRvcik7XG4gIHRyeSB7XG4gICAgaW5uZXJSZXN1bHQgPSBnZXRNZXRob2QoaXRlcmF0b3IsICdyZXR1cm4nKTtcbiAgICBpZiAoIWlubmVyUmVzdWx0KSB7XG4gICAgICBpZiAoa2luZCA9PT0gJ3Rocm93JykgdGhyb3cgdmFsdWU7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlubmVyUmVzdWx0ID0gY2FsbCQ1KGlubmVyUmVzdWx0LCBpdGVyYXRvcik7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaW5uZXJFcnJvciA9IHRydWU7XG4gICAgaW5uZXJSZXN1bHQgPSBlcnJvcjtcbiAgfVxuICBpZiAoa2luZCA9PT0gJ3Rocm93JykgdGhyb3cgdmFsdWU7XG4gIGlmIChpbm5lckVycm9yKSB0aHJvdyBpbm5lclJlc3VsdDtcbiAgYW5PYmplY3QkNChpbm5lclJlc3VsdCk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbnZhciBiaW5kID0gZnVuY3Rpb25CaW5kQ29udGV4dDtcbnZhciBjYWxsJDQgPSBmdW5jdGlvbkNhbGw7XG52YXIgYW5PYmplY3QkMyA9IGFuT2JqZWN0JGM7XG52YXIgdHJ5VG9TdHJpbmcgPSB0cnlUb1N0cmluZyQ0O1xudmFyIGlzQXJyYXlJdGVyYXRvck1ldGhvZCA9IGlzQXJyYXlJdGVyYXRvck1ldGhvZCQxO1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlID0gbGVuZ3RoT2ZBcnJheUxpa2UkMjtcbnZhciBpc1Byb3RvdHlwZU9mJDEgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xudmFyIGdldEl0ZXJhdG9yID0gZ2V0SXRlcmF0b3IkMTtcbnZhciBnZXRJdGVyYXRvck1ldGhvZCA9IGdldEl0ZXJhdG9yTWV0aG9kJDI7XG52YXIgaXRlcmF0b3JDbG9zZSA9IGl0ZXJhdG9yQ2xvc2UkMTtcblxudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG5cbnZhciBSZXN1bHQgPSBmdW5jdGlvbiAoc3RvcHBlZCwgcmVzdWx0KSB7XG4gIHRoaXMuc3RvcHBlZCA9IHN0b3BwZWQ7XG4gIHRoaXMucmVzdWx0ID0gcmVzdWx0O1xufTtcblxudmFyIFJlc3VsdFByb3RvdHlwZSA9IFJlc3VsdC5wcm90b3R5cGU7XG5cbnZhciBpdGVyYXRlJDIgPSBmdW5jdGlvbiAoaXRlcmFibGUsIHVuYm91bmRGdW5jdGlvbiwgb3B0aW9ucykge1xuICB2YXIgdGhhdCA9IG9wdGlvbnMgJiYgb3B0aW9ucy50aGF0O1xuICB2YXIgQVNfRU5UUklFUyA9ICEhKG9wdGlvbnMgJiYgb3B0aW9ucy5BU19FTlRSSUVTKTtcbiAgdmFyIElTX0lURVJBVE9SID0gISEob3B0aW9ucyAmJiBvcHRpb25zLklTX0lURVJBVE9SKTtcbiAgdmFyIElOVEVSUlVQVEVEID0gISEob3B0aW9ucyAmJiBvcHRpb25zLklOVEVSUlVQVEVEKTtcbiAgdmFyIGZuID0gYmluZCh1bmJvdW5kRnVuY3Rpb24sIHRoYXQpO1xuICB2YXIgaXRlcmF0b3IsIGl0ZXJGbiwgaW5kZXgsIGxlbmd0aCwgcmVzdWx0LCBuZXh0LCBzdGVwO1xuXG4gIHZhciBzdG9wID0gZnVuY3Rpb24gKGNvbmRpdGlvbikge1xuICAgIGlmIChpdGVyYXRvcikgaXRlcmF0b3JDbG9zZShpdGVyYXRvciwgJ25vcm1hbCcsIGNvbmRpdGlvbik7XG4gICAgcmV0dXJuIG5ldyBSZXN1bHQodHJ1ZSwgY29uZGl0aW9uKTtcbiAgfTtcblxuICB2YXIgY2FsbEZuID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKEFTX0VOVFJJRVMpIHtcbiAgICAgIGFuT2JqZWN0JDModmFsdWUpO1xuICAgICAgcmV0dXJuIElOVEVSUlVQVEVEID8gZm4odmFsdWVbMF0sIHZhbHVlWzFdLCBzdG9wKSA6IGZuKHZhbHVlWzBdLCB2YWx1ZVsxXSk7XG4gICAgfSByZXR1cm4gSU5URVJSVVBURUQgPyBmbih2YWx1ZSwgc3RvcCkgOiBmbih2YWx1ZSk7XG4gIH07XG5cbiAgaWYgKElTX0lURVJBVE9SKSB7XG4gICAgaXRlcmF0b3IgPSBpdGVyYWJsZTtcbiAgfSBlbHNlIHtcbiAgICBpdGVyRm4gPSBnZXRJdGVyYXRvck1ldGhvZChpdGVyYWJsZSk7XG4gICAgaWYgKCFpdGVyRm4pIHRocm93ICRUeXBlRXJyb3IodHJ5VG9TdHJpbmcoaXRlcmFibGUpICsgJyBpcyBub3QgaXRlcmFibGUnKTtcbiAgICAvLyBvcHRpbWlzYXRpb24gZm9yIGFycmF5IGl0ZXJhdG9yc1xuICAgIGlmIChpc0FycmF5SXRlcmF0b3JNZXRob2QoaXRlckZuKSkge1xuICAgICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlKGl0ZXJhYmxlKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICAgICAgcmVzdWx0ID0gY2FsbEZuKGl0ZXJhYmxlW2luZGV4XSk7XG4gICAgICAgIGlmIChyZXN1bHQgJiYgaXNQcm90b3R5cGVPZiQxKFJlc3VsdFByb3RvdHlwZSwgcmVzdWx0KSkgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0gcmV0dXJuIG5ldyBSZXN1bHQoZmFsc2UpO1xuICAgIH1cbiAgICBpdGVyYXRvciA9IGdldEl0ZXJhdG9yKGl0ZXJhYmxlLCBpdGVyRm4pO1xuICB9XG5cbiAgbmV4dCA9IGl0ZXJhdG9yLm5leHQ7XG4gIHdoaWxlICghKHN0ZXAgPSBjYWxsJDQobmV4dCwgaXRlcmF0b3IpKS5kb25lKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9IGNhbGxGbihzdGVwLnZhbHVlKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaXRlcmF0b3JDbG9zZShpdGVyYXRvciwgJ3Rocm93JywgZXJyb3IpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHJlc3VsdCA9PSAnb2JqZWN0JyAmJiByZXN1bHQgJiYgaXNQcm90b3R5cGVPZiQxKFJlc3VsdFByb3RvdHlwZSwgcmVzdWx0KSkgcmV0dXJuIHJlc3VsdDtcbiAgfSByZXR1cm4gbmV3IFJlc3VsdChmYWxzZSk7XG59O1xuXG52YXIgd2VsbEtub3duU3ltYm9sID0gd2VsbEtub3duU3ltYm9sJGU7XG5cbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcbnZhciBTQUZFX0NMT1NJTkcgPSBmYWxzZTtcblxudHJ5IHtcbiAgdmFyIGNhbGxlZCA9IDA7XG4gIHZhciBpdGVyYXRvcldpdGhSZXR1cm4gPSB7XG4gICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHsgZG9uZTogISFjYWxsZWQrKyB9O1xuICAgIH0sXG4gICAgJ3JldHVybic6IGZ1bmN0aW9uICgpIHtcbiAgICAgIFNBRkVfQ0xPU0lORyA9IHRydWU7XG4gICAgfVxuICB9O1xuICBpdGVyYXRvcldpdGhSZXR1cm5bSVRFUkFUT1JdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1hcnJheS1mcm9tLCBuby10aHJvdy1saXRlcmFsIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIEFycmF5LmZyb20oaXRlcmF0b3JXaXRoUmV0dXJuLCBmdW5jdGlvbiAoKSB7IHRocm93IDI7IH0pO1xufSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuXG52YXIgY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uJDEgPSBmdW5jdGlvbiAoZXhlYywgU0tJUF9DTE9TSU5HKSB7XG4gIGlmICghU0tJUF9DTE9TSU5HICYmICFTQUZFX0NMT1NJTkcpIHJldHVybiBmYWxzZTtcbiAgdmFyIElURVJBVElPTl9TVVBQT1JUID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgdmFyIG9iamVjdCA9IHt9O1xuICAgIG9iamVjdFtJVEVSQVRPUl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHsgZG9uZTogSVRFUkFUSU9OX1NVUFBPUlQgPSB0cnVlIH07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcbiAgICBleGVjKG9iamVjdCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIElURVJBVElPTl9TVVBQT1JUO1xufTtcblxudmFyIE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQxID0gcHJvbWlzZU5hdGl2ZUNvbnN0cnVjdG9yO1xudmFyIGNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbiA9IGNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbiQxO1xudmFyIEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SJDMgPSBwcm9taXNlQ29uc3RydWN0b3JEZXRlY3Rpb24uQ09OU1RSVUNUT1I7XG5cbnZhciBwcm9taXNlU3RhdGljc0luY29ycmVjdEl0ZXJhdGlvbiA9IEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SJDMgfHwgIWNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbihmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiAgTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yJDEuYWxsKGl0ZXJhYmxlKS50aGVuKHVuZGVmaW5lZCwgZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9KTtcbn0pO1xuXG52YXIgJCQ0ID0gX2V4cG9ydDtcbnZhciBjYWxsJDMgPSBmdW5jdGlvbkNhbGw7XG52YXIgYUNhbGxhYmxlJDEgPSBhQ2FsbGFibGUkNztcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSQyID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkkMjtcbnZhciBwZXJmb3JtJDEgPSBwZXJmb3JtJDM7XG52YXIgaXRlcmF0ZSQxID0gaXRlcmF0ZSQyO1xudmFyIFBST01JU0VfU1RBVElDU19JTkNPUlJFQ1RfSVRFUkFUSU9OJDEgPSBwcm9taXNlU3RhdGljc0luY29ycmVjdEl0ZXJhdGlvbjtcblxuLy8gYFByb21pc2UuYWxsYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcHJvbWlzZS5hbGxcbiQkNCh7IHRhcmdldDogJ1Byb21pc2UnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IFBST01JU0VfU1RBVElDU19JTkNPUlJFQ1RfSVRFUkFUSU9OJDEgfSwge1xuICBhbGw6IGZ1bmN0aW9uIGFsbChpdGVyYWJsZSkge1xuICAgIHZhciBDID0gdGhpcztcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlJDIuZihDKTtcbiAgICB2YXIgcmVzb2x2ZSA9IGNhcGFiaWxpdHkucmVzb2x2ZTtcbiAgICB2YXIgcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgdmFyIHJlc3VsdCA9IHBlcmZvcm0kMShmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHByb21pc2VSZXNvbHZlID0gYUNhbGxhYmxlJDEoQy5yZXNvbHZlKTtcbiAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgIHZhciBjb3VudGVyID0gMDtcbiAgICAgIHZhciByZW1haW5pbmcgPSAxO1xuICAgICAgaXRlcmF0ZSQxKGl0ZXJhYmxlLCBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICB2YXIgaW5kZXggPSBjb3VudGVyKys7XG4gICAgICAgIHZhciBhbHJlYWR5Q2FsbGVkID0gZmFsc2U7XG4gICAgICAgIHJlbWFpbmluZysrO1xuICAgICAgICBjYWxsJDMoJHByb21pc2VSZXNvbHZlLCBDLCBwcm9taXNlKS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIGlmIChhbHJlYWR5Q2FsbGVkKSByZXR1cm47XG4gICAgICAgICAgYWxyZWFkeUNhbGxlZCA9IHRydWU7XG4gICAgICAgICAgdmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgIH0pO1xuICAgIGlmIChyZXN1bHQuZXJyb3IpIHJlamVjdChyZXN1bHQudmFsdWUpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuXG52YXIgJCQzID0gX2V4cG9ydDtcbnZhciBGT1JDRURfUFJPTUlTRV9DT05TVFJVQ1RPUiQyID0gcHJvbWlzZUNvbnN0cnVjdG9yRGV0ZWN0aW9uLkNPTlNUUlVDVE9SO1xudmFyIE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciA9IHByb21pc2VOYXRpdmVDb25zdHJ1Y3RvcjtcbnZhciBnZXRCdWlsdEluJDEgPSBnZXRCdWlsdEluJDg7XG52YXIgaXNDYWxsYWJsZSA9IGlzQ2FsbGFibGUkaztcbnZhciBkZWZpbmVCdWlsdEluJDEgPSBkZWZpbmVCdWlsdEluJDY7XG5cbnZhciBOYXRpdmVQcm9taXNlUHJvdG90eXBlID0gTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yICYmIE5hdGl2ZVByb21pc2VDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG5cbi8vIGBQcm9taXNlLnByb3RvdHlwZS5jYXRjaGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXByb21pc2UucHJvdG90eXBlLmNhdGNoXG4kJDMoeyB0YXJnZXQ6ICdQcm9taXNlJywgcHJvdG86IHRydWUsIGZvcmNlZDogRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkMiwgcmVhbDogdHJ1ZSB9LCB7XG4gICdjYXRjaCc6IGZ1bmN0aW9uIChvblJlamVjdGVkKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIG9uUmVqZWN0ZWQpO1xuICB9XG59KTtcblxuLy8gbWFrZXMgc3VyZSB0aGF0IG5hdGl2ZSBwcm9taXNlLWJhc2VkIEFQSXMgYFByb21pc2UjY2F0Y2hgIHByb3Blcmx5IHdvcmtzIHdpdGggcGF0Y2hlZCBgUHJvbWlzZSN0aGVuYFxuaWYgKGlzQ2FsbGFibGUoTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yKSkge1xuICB2YXIgbWV0aG9kID0gZ2V0QnVpbHRJbiQxKCdQcm9taXNlJykucHJvdG90eXBlWydjYXRjaCddO1xuICBpZiAoTmF0aXZlUHJvbWlzZVByb3RvdHlwZVsnY2F0Y2gnXSAhPT0gbWV0aG9kKSB7XG4gICAgZGVmaW5lQnVpbHRJbiQxKE5hdGl2ZVByb21pc2VQcm90b3R5cGUsICdjYXRjaCcsIG1ldGhvZCwgeyB1bnNhZmU6IHRydWUgfSk7XG4gIH1cbn1cblxudmFyICQkMiA9IF9leHBvcnQ7XG52YXIgY2FsbCQyID0gZnVuY3Rpb25DYWxsO1xudmFyIGFDYWxsYWJsZSA9IGFDYWxsYWJsZSQ3O1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlJDEgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSQyO1xudmFyIHBlcmZvcm0gPSBwZXJmb3JtJDM7XG52YXIgaXRlcmF0ZSA9IGl0ZXJhdGUkMjtcbnZhciBQUk9NSVNFX1NUQVRJQ1NfSU5DT1JSRUNUX0lURVJBVElPTiA9IHByb21pc2VTdGF0aWNzSW5jb3JyZWN0SXRlcmF0aW9uO1xuXG4vLyBgUHJvbWlzZS5yYWNlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcHJvbWlzZS5yYWNlXG4kJDIoeyB0YXJnZXQ6ICdQcm9taXNlJywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBQUk9NSVNFX1NUQVRJQ1NfSU5DT1JSRUNUX0lURVJBVElPTiB9LCB7XG4gIHJhY2U6IGZ1bmN0aW9uIHJhY2UoaXRlcmFibGUpIHtcbiAgICB2YXIgQyA9IHRoaXM7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSQxLmYoQyk7XG4gICAgdmFyIHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciByZXN1bHQgPSBwZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkcHJvbWlzZVJlc29sdmUgPSBhQ2FsbGFibGUoQy5yZXNvbHZlKTtcbiAgICAgIGl0ZXJhdGUoaXRlcmFibGUsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgIGNhbGwkMigkcHJvbWlzZVJlc29sdmUsIEMsIHByb21pc2UpLnRoZW4oY2FwYWJpbGl0eS5yZXNvbHZlLCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYgKHJlc3VsdC5lcnJvcikgcmVqZWN0KHJlc3VsdC52YWx1ZSk7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG5cbnZhciAkJDEgPSBfZXhwb3J0O1xudmFyIGNhbGwkMSA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5JDI7XG52YXIgRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkMSA9IHByb21pc2VDb25zdHJ1Y3RvckRldGVjdGlvbi5DT05TVFJVQ1RPUjtcblxuLy8gYFByb21pc2UucmVqZWN0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcHJvbWlzZS5yZWplY3RcbiQkMSh7IHRhcmdldDogJ1Byb21pc2UnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SJDEgfSwge1xuICByZWplY3Q6IGZ1bmN0aW9uIHJlamVjdChyKSB7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZS5mKHRoaXMpO1xuICAgIGNhbGwkMShjYXBhYmlsaXR5LnJlamVjdCwgdW5kZWZpbmVkLCByKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcblxudmFyIGFuT2JqZWN0JDIgPSBhbk9iamVjdCRjO1xudmFyIGlzT2JqZWN0ID0gaXNPYmplY3QkNztcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5JDI7XG5cbnZhciBwcm9taXNlUmVzb2x2ZSQxID0gZnVuY3Rpb24gKEMsIHgpIHtcbiAgYW5PYmplY3QkMihDKTtcbiAgaWYgKGlzT2JqZWN0KHgpICYmIHguY29uc3RydWN0b3IgPT09IEMpIHJldHVybiB4O1xuICB2YXIgcHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eS5mKEMpO1xuICB2YXIgcmVzb2x2ZSA9IHByb21pc2VDYXBhYmlsaXR5LnJlc29sdmU7XG4gIHJlc29sdmUoeCk7XG4gIHJldHVybiBwcm9taXNlQ2FwYWJpbGl0eS5wcm9taXNlO1xufTtcblxudmFyICQgPSBfZXhwb3J0O1xudmFyIGdldEJ1aWx0SW4gPSBnZXRCdWlsdEluJDg7XG52YXIgRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IgPSBwcm9taXNlQ29uc3RydWN0b3JEZXRlY3Rpb24uQ09OU1RSVUNUT1I7XG52YXIgcHJvbWlzZVJlc29sdmUgPSBwcm9taXNlUmVzb2x2ZSQxO1xuXG5nZXRCdWlsdEluKCdQcm9taXNlJyk7XG5cbi8vIGBQcm9taXNlLnJlc29sdmVgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1wcm9taXNlLnJlc29sdmVcbiQoeyB0YXJnZXQ6ICdQcm9taXNlJywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBGT1JDRURfUFJPTUlTRV9DT05TVFJVQ1RPUiB9LCB7XG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoeCkge1xuICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZSh0aGlzLCB4KTtcbiAgfVxufSk7XG5cbnZhciBjbGFzc29mID0gY2xhc3NvZiQzO1xuXG52YXIgJFN0cmluZyA9IFN0cmluZztcblxudmFyIHRvU3RyaW5nID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmIChjbGFzc29mKGFyZ3VtZW50KSA9PT0gJ1N5bWJvbCcpIHRocm93IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgYSBTeW1ib2wgdmFsdWUgdG8gYSBzdHJpbmcnKTtcbiAgcmV0dXJuICRTdHJpbmcoYXJndW1lbnQpO1xufTtcblxudmFyIGFuT2JqZWN0JDEgPSBhbk9iamVjdCRjO1xuXG4vLyBgUmVnRXhwLnByb3RvdHlwZS5mbGFnc2AgZ2V0dGVyIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWdldC1yZWdleHAucHJvdG90eXBlLmZsYWdzXG52YXIgcmVnZXhwRmxhZ3MgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0aGF0ID0gYW5PYmplY3QkMSh0aGlzKTtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuICBpZiAodGhhdC5oYXNJbmRpY2VzKSByZXN1bHQgKz0gJ2QnO1xuICBpZiAodGhhdC5nbG9iYWwpIHJlc3VsdCArPSAnZyc7XG4gIGlmICh0aGF0Lmlnbm9yZUNhc2UpIHJlc3VsdCArPSAnaSc7XG4gIGlmICh0aGF0Lm11bHRpbGluZSkgcmVzdWx0ICs9ICdtJztcbiAgaWYgKHRoYXQuZG90QWxsKSByZXN1bHQgKz0gJ3MnO1xuICBpZiAodGhhdC51bmljb2RlKSByZXN1bHQgKz0gJ3UnO1xuICBpZiAodGhhdC51bmljb2RlU2V0cykgcmVzdWx0ICs9ICd2JztcbiAgaWYgKHRoYXQuc3RpY2t5KSByZXN1bHQgKz0gJ3knO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxudmFyIGNhbGwgPSBmdW5jdGlvbkNhbGw7XG52YXIgaGFzT3duID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBpc1Byb3RvdHlwZU9mID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbnZhciByZWdFeHBGbGFncyA9IHJlZ2V4cEZsYWdzO1xuXG52YXIgUmVnRXhwUHJvdG90eXBlJDEgPSBSZWdFeHAucHJvdG90eXBlO1xuXG52YXIgcmVnZXhwR2V0RmxhZ3MgPSBmdW5jdGlvbiAoUikge1xuICB2YXIgZmxhZ3MgPSBSLmZsYWdzO1xuICByZXR1cm4gZmxhZ3MgPT09IHVuZGVmaW5lZCAmJiAhKCdmbGFncycgaW4gUmVnRXhwUHJvdG90eXBlJDEpICYmICFoYXNPd24oUiwgJ2ZsYWdzJykgJiYgaXNQcm90b3R5cGVPZihSZWdFeHBQcm90b3R5cGUkMSwgUilcbiAgICA/IGNhbGwocmVnRXhwRmxhZ3MsIFIpIDogZmxhZ3M7XG59O1xuXG52YXIgUFJPUEVSX0ZVTkNUSU9OX05BTUUgPSBmdW5jdGlvbk5hbWUuUFJPUEVSO1xudmFyIGRlZmluZUJ1aWx0SW4gPSBkZWZpbmVCdWlsdEluJDY7XG52YXIgYW5PYmplY3QgPSBhbk9iamVjdCRjO1xudmFyICR0b1N0cmluZyA9IHRvU3RyaW5nO1xudmFyIGZhaWxzID0gZmFpbHMkZDtcbnZhciBnZXRSZWdFeHBGbGFncyA9IHJlZ2V4cEdldEZsYWdzO1xuXG52YXIgVE9fU1RSSU5HID0gJ3RvU3RyaW5nJztcbnZhciBSZWdFeHBQcm90b3R5cGUgPSBSZWdFeHAucHJvdG90eXBlO1xudmFyIG4kVG9TdHJpbmcgPSBSZWdFeHBQcm90b3R5cGVbVE9fU1RSSU5HXTtcblxudmFyIE5PVF9HRU5FUklDID0gZmFpbHMoZnVuY3Rpb24gKCkgeyByZXR1cm4gbiRUb1N0cmluZy5jYWxsKHsgc291cmNlOiAnYScsIGZsYWdzOiAnYicgfSkgIT0gJy9hL2InOyB9KTtcbi8vIEZGNDQtIFJlZ0V4cCN0b1N0cmluZyBoYXMgYSB3cm9uZyBuYW1lXG52YXIgSU5DT1JSRUNUX05BTUUgPSBQUk9QRVJfRlVOQ1RJT05fTkFNRSAmJiBuJFRvU3RyaW5nLm5hbWUgIT0gVE9fU1RSSU5HO1xuXG4vLyBgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZ2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXJlZ2V4cC5wcm90b3R5cGUudG9zdHJpbmdcbmlmIChOT1RfR0VORVJJQyB8fCBJTkNPUlJFQ1RfTkFNRSkge1xuICBkZWZpbmVCdWlsdEluKFJlZ0V4cC5wcm90b3R5cGUsIFRPX1NUUklORywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgdmFyIFIgPSBhbk9iamVjdCh0aGlzKTtcbiAgICB2YXIgcGF0dGVybiA9ICR0b1N0cmluZyhSLnNvdXJjZSk7XG4gICAgdmFyIGZsYWdzID0gJHRvU3RyaW5nKGdldFJlZ0V4cEZsYWdzKFIpKTtcbiAgICByZXR1cm4gJy8nICsgcGF0dGVybiArICcvJyArIGZsYWdzO1xuICB9LCB7IHVuc2FmZTogdHJ1ZSB9KTtcbn1cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblxyXG5mdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG50eXBlb2YgU3VwcHJlc3NlZEVycm9yID09PSBcImZ1bmN0aW9uXCIgPyBTdXBwcmVzc2VkRXJyb3IgOiBmdW5jdGlvbiAoZXJyb3IsIHN1cHByZXNzZWQsIG1lc3NhZ2UpIHtcclxuICAgIHZhciBlID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG4gICAgcmV0dXJuIGUubmFtZSA9IFwiU3VwcHJlc3NlZEVycm9yXCIsIGUuZXJyb3IgPSBlcnJvciwgZS5zdXBwcmVzc2VkID0gc3VwcHJlc3NlZCwgZTtcclxufTtcblxuY29uc3Qgc2lnblRyYW5zYWN0aW9ucyA9ICh0cmFuc2FjdGlvbnMsIHNpZ25lciwgbmV0d29yaykgPT4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gIGNvbnN0IHByb3ZpZGVyID0gbmV3IG5lYXJBUElfX25hbWVzcGFjZS5wcm92aWRlcnMuSnNvblJwY1Byb3ZpZGVyKHtcbiAgICB1cmw6IG5ldHdvcmsubm9kZVVybFxuICB9KTtcbiAgY29uc3Qgc2lnbmVkVHJhbnNhY3Rpb25zID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdHJhbnNhY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcHVibGljS2V5ID0geWllbGQgc2lnbmVyLmdldFB1YmxpY0tleSh0cmFuc2FjdGlvbnNbaV0uc2lnbmVySWQsIG5ldHdvcmsubmV0d29ya0lkKTtcbiAgICBjb25zdCBbYmxvY2ssIGFjY2Vzc0tleV0gPSB5aWVsZCBQcm9taXNlLmFsbChbcHJvdmlkZXIuYmxvY2soe1xuICAgICAgZmluYWxpdHk6IFwiZmluYWxcIlxuICAgIH0pLCBwcm92aWRlci5xdWVyeSh7XG4gICAgICByZXF1ZXN0X3R5cGU6IFwidmlld19hY2Nlc3Nfa2V5XCIsXG4gICAgICBmaW5hbGl0eTogXCJmaW5hbFwiLFxuICAgICAgYWNjb3VudF9pZDogdHJhbnNhY3Rpb25zW2ldLnNpZ25lcklkLFxuICAgICAgcHVibGljX2tleTogcHVibGljS2V5LnRvU3RyaW5nKClcbiAgICB9KV0pO1xuICAgIGNvbnN0IGFjdGlvbnMgPSB0cmFuc2FjdGlvbnNbaV0uYWN0aW9ucy5tYXAoYWN0aW9uID0+IGNyZWF0ZUFjdGlvbihhY3Rpb24pKTtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IG5lYXJBUElfX25hbWVzcGFjZS50cmFuc2FjdGlvbnMuY3JlYXRlVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25zW2ldLnNpZ25lcklkLCBuZWFyQVBJX19uYW1lc3BhY2UudXRpbHMuUHVibGljS2V5LmZyb20ocHVibGljS2V5LnRvU3RyaW5nKCkpLCB0cmFuc2FjdGlvbnNbaV0ucmVjZWl2ZXJJZCwgYWNjZXNzS2V5Lm5vbmNlICsgaSArIDEsIGFjdGlvbnMsIG5lYXJBUElfX25hbWVzcGFjZS51dGlscy5zZXJpYWxpemUuYmFzZV9kZWNvZGUoYmxvY2suaGVhZGVyLmhhc2gpKTtcbiAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIG5lYXJBUElfX25hbWVzcGFjZS50cmFuc2FjdGlvbnMuc2lnblRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBzaWduZXIsIHRyYW5zYWN0aW9uc1tpXS5zaWduZXJJZCwgbmV0d29yay5uZXR3b3JrSWQpO1xuICAgIHNpZ25lZFRyYW5zYWN0aW9ucy5wdXNoKHJlc3BvbnNlWzFdKTtcbiAgfVxuICByZXR1cm4gc2lnbmVkVHJhbnNhY3Rpb25zO1xufSk7XG5cbmV4cG9ydHMuY3JlYXRlQWN0aW9uID0gY3JlYXRlQWN0aW9uO1xuZXhwb3J0cy5zaWduVHJhbnNhY3Rpb25zID0gc2lnblRyYW5zYWN0aW9ucztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@near-wallet-selector/wallet-utils/index.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@near-wallet-selector/core/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@near-wallet-selector/core/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EventEmitter: () => (/* binding */ EventEmitter),\n/* harmony export */   allowOnlyLanguage: () => (/* binding */ allowOnlyLanguage),\n/* harmony export */   getActiveAccount: () => (/* binding */ getActiveAccount),\n/* harmony export */   isCurrentBrowserSupported: () => (/* binding */ isCurrentBrowserSupported),\n/* harmony export */   serializeNep413: () => (/* binding */ serializeNep413),\n/* harmony export */   setupWalletSelector: () => (/* binding */ setupWalletSelector),\n/* harmony export */   translate: () => (/* binding */ translate),\n/* harmony export */   verifyFullKeyBelongsToUser: () => (/* binding */ verifyFullKeyBelongsToUser),\n/* harmony export */   verifySignature: () => (/* binding */ verifySignature),\n/* harmony export */   waitFor: () => (/* binding */ waitFor)\n/* harmony export */ });\n/* harmony import */ var near_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! near-api-js */ \"(ssr)/./node_modules/near-api-js/lib/index.js\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/BehaviorSubject.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/Subject.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/operators/scan.js\");\n/* harmony import */ var borsh__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! borsh */ \"(ssr)/./node_modules/borsh/lib/index.js\");\n/* harmony import */ var js_sha256__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! js-sha256 */ \"(ssr)/./node_modules/js-sha256/src/sha256.js\");\n\n\n\n\n\n\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\n\nclass Provider {\n  constructor(url) {\n    this.provider = new near_api_js__WEBPACK_IMPORTED_MODULE_0__.providers.JsonRpcProvider({\n      url\n    });\n  }\n  query(params) {\n    return this.provider.query(params);\n  }\n  viewAccessKey({\n    accountId,\n    publicKey\n  }) {\n    return this.query({\n      request_type: \"view_access_key\",\n      finality: \"final\",\n      account_id: accountId,\n      public_key: publicKey\n    });\n  }\n  block(reference) {\n    return this.provider.block(reference);\n  }\n  sendTransaction(signedTransaction) {\n    return this.provider.sendTransaction(signedTransaction);\n  }\n}\n\nconst KEY_DELIMITER = \":\";\nclass JsonStorage {\n  constructor(storage, namespace) {\n    this.storage = storage;\n    this.namespace = Array.isArray(namespace) ? namespace.join(KEY_DELIMITER) : namespace;\n  }\n  resolveKey(key) {\n    return [this.namespace, key].join(KEY_DELIMITER);\n  }\n  getItem(key) {\n    return this.storage.getItem(this.resolveKey(key)).then(item => {\n      return typeof item === \"string\" ? JSON.parse(item) : null;\n    });\n  }\n  setItem(key, value) {\n    return this.storage.setItem(this.resolveKey(key), JSON.stringify(value));\n  }\n  removeItem(key) {\n    return this.storage.removeItem(this.resolveKey(key));\n  }\n}\n\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nvar check = function (it) {\n  return it && it.Math == Math && it;\n};\n\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global$t =\n  // eslint-disable-next-line es-x/no-global-this -- safe\n  check(typeof globalThis == 'object' && globalThis) ||\n  check(typeof window == 'object' && window) ||\n  // eslint-disable-next-line no-restricted-globals -- safe\n  check(typeof self == 'object' && self) ||\n  check(typeof commonjsGlobal == 'object' && commonjsGlobal) ||\n  // eslint-disable-next-line no-new-func -- fallback\n  (function () { return this; })() || Function('return this')();\n\nvar objectGetOwnPropertyDescriptor = {};\n\nvar fails$s = function (exec) {\n  try {\n    return !!exec();\n  } catch (error) {\n    return true;\n  }\n};\n\nvar fails$r = fails$s;\n\n// Detect IE8's incomplete defineProperty implementation\nvar descriptors = !fails$r(function () {\n  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;\n});\n\nvar fails$q = fails$s;\n\nvar functionBindNative = !fails$q(function () {\n  // eslint-disable-next-line es-x/no-function-prototype-bind -- safe\n  var test = (function () { /* empty */ }).bind();\n  // eslint-disable-next-line no-prototype-builtins -- safe\n  return typeof test != 'function' || test.hasOwnProperty('prototype');\n});\n\nvar NATIVE_BIND$3 = functionBindNative;\n\nvar call$l = Function.prototype.call;\n\nvar functionCall = NATIVE_BIND$3 ? call$l.bind(call$l) : function () {\n  return call$l.apply(call$l, arguments);\n};\n\nvar objectPropertyIsEnumerable = {};\n\nvar $propertyIsEnumerable = {}.propertyIsEnumerable;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar getOwnPropertyDescriptor$2 = Object.getOwnPropertyDescriptor;\n\n// Nashorn ~ JDK8 bug\nvar NASHORN_BUG = getOwnPropertyDescriptor$2 && !$propertyIsEnumerable.call({ 1: 2 }, 1);\n\n// `Object.prototype.propertyIsEnumerable` method implementation\n// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable\nobjectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n  var descriptor = getOwnPropertyDescriptor$2(this, V);\n  return !!descriptor && descriptor.enumerable;\n} : $propertyIsEnumerable;\n\nvar createPropertyDescriptor$5 = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n\nvar NATIVE_BIND$2 = functionBindNative;\n\nvar FunctionPrototype$2 = Function.prototype;\nvar bind$7 = FunctionPrototype$2.bind;\nvar call$k = FunctionPrototype$2.call;\nvar uncurryThis$p = NATIVE_BIND$2 && bind$7.bind(call$k, call$k);\n\nvar functionUncurryThis = NATIVE_BIND$2 ? function (fn) {\n  return fn && uncurryThis$p(fn);\n} : function (fn) {\n  return fn && function () {\n    return call$k.apply(fn, arguments);\n  };\n};\n\nvar uncurryThis$o = functionUncurryThis;\n\nvar toString$7 = uncurryThis$o({}.toString);\nvar stringSlice$3 = uncurryThis$o(''.slice);\n\nvar classofRaw$1 = function (it) {\n  return stringSlice$3(toString$7(it), 8, -1);\n};\n\nvar uncurryThis$n = functionUncurryThis;\nvar fails$p = fails$s;\nvar classof$b = classofRaw$1;\n\nvar $Object$4 = Object;\nvar split = uncurryThis$n(''.split);\n\n// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar indexedObject = fails$p(function () {\n  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n  // eslint-disable-next-line no-prototype-builtins -- safe\n  return !$Object$4('z').propertyIsEnumerable(0);\n}) ? function (it) {\n  return classof$b(it) == 'String' ? split(it, '') : $Object$4(it);\n} : $Object$4;\n\nvar $TypeError$f = TypeError;\n\n// `RequireObjectCoercible` abstract operation\n// https://tc39.es/ecma262/#sec-requireobjectcoercible\nvar requireObjectCoercible$6 = function (it) {\n  if (it == undefined) throw $TypeError$f(\"Can't call method on \" + it);\n  return it;\n};\n\n// toObject with fallback for non-array-like ES3 strings\nvar IndexedObject$3 = indexedObject;\nvar requireObjectCoercible$5 = requireObjectCoercible$6;\n\nvar toIndexedObject$6 = function (it) {\n  return IndexedObject$3(requireObjectCoercible$5(it));\n};\n\n// `IsCallable` abstract operation\n// https://tc39.es/ecma262/#sec-iscallable\nvar isCallable$n = function (argument) {\n  return typeof argument == 'function';\n};\n\nvar isCallable$m = isCallable$n;\n\nvar isObject$d = function (it) {\n  return typeof it == 'object' ? it !== null : isCallable$m(it);\n};\n\nvar global$s = global$t;\nvar isCallable$l = isCallable$n;\n\nvar aFunction = function (argument) {\n  return isCallable$l(argument) ? argument : undefined;\n};\n\nvar getBuiltIn$8 = function (namespace, method) {\n  return arguments.length < 2 ? aFunction(global$s[namespace]) : global$s[namespace] && global$s[namespace][method];\n};\n\nvar uncurryThis$m = functionUncurryThis;\n\nvar objectIsPrototypeOf = uncurryThis$m({}.isPrototypeOf);\n\nvar getBuiltIn$7 = getBuiltIn$8;\n\nvar engineUserAgent = getBuiltIn$7('navigator', 'userAgent') || '';\n\nvar global$r = global$t;\nvar userAgent$5 = engineUserAgent;\n\nvar process$3 = global$r.process;\nvar Deno$1 = global$r.Deno;\nvar versions = process$3 && process$3.versions || Deno$1 && Deno$1.version;\nvar v8 = versions && versions.v8;\nvar match, version;\n\nif (v8) {\n  match = v8.split('.');\n  // in old Chrome, versions of V8 isn't V8 = Chrome / 10\n  // but their correct versions are not interesting for us\n  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);\n}\n\n// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`\n// so check `userAgent` even if `.v8` exists, but 0\nif (!version && userAgent$5) {\n  match = userAgent$5.match(/Edge\\/(\\d+)/);\n  if (!match || match[1] >= 74) {\n    match = userAgent$5.match(/Chrome\\/(\\d+)/);\n    if (match) version = +match[1];\n  }\n}\n\nvar engineV8Version = version;\n\n/* eslint-disable es-x/no-symbol -- required for testing */\n\nvar V8_VERSION$1 = engineV8Version;\nvar fails$o = fails$s;\n\n// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- required for testing\nvar nativeSymbol = !!Object.getOwnPropertySymbols && !fails$o(function () {\n  var symbol = Symbol();\n  // Chrome 38 Symbol has incorrect toString conversion\n  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances\n  return !String(symbol) || !(Object(symbol) instanceof Symbol) ||\n    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances\n    !Symbol.sham && V8_VERSION$1 && V8_VERSION$1 < 41;\n});\n\n/* eslint-disable es-x/no-symbol -- required for testing */\n\nvar NATIVE_SYMBOL$1 = nativeSymbol;\n\nvar useSymbolAsUid = NATIVE_SYMBOL$1\n  && !Symbol.sham\n  && typeof Symbol.iterator == 'symbol';\n\nvar getBuiltIn$6 = getBuiltIn$8;\nvar isCallable$k = isCallable$n;\nvar isPrototypeOf$4 = objectIsPrototypeOf;\nvar USE_SYMBOL_AS_UID$1 = useSymbolAsUid;\n\nvar $Object$3 = Object;\n\nvar isSymbol$3 = USE_SYMBOL_AS_UID$1 ? function (it) {\n  return typeof it == 'symbol';\n} : function (it) {\n  var $Symbol = getBuiltIn$6('Symbol');\n  return isCallable$k($Symbol) && isPrototypeOf$4($Symbol.prototype, $Object$3(it));\n};\n\nvar $String$3 = String;\n\nvar tryToString$5 = function (argument) {\n  try {\n    return $String$3(argument);\n  } catch (error) {\n    return 'Object';\n  }\n};\n\nvar isCallable$j = isCallable$n;\nvar tryToString$4 = tryToString$5;\n\nvar $TypeError$e = TypeError;\n\n// `Assert: IsCallable(argument) is true`\nvar aCallable$9 = function (argument) {\n  if (isCallable$j(argument)) return argument;\n  throw $TypeError$e(tryToString$4(argument) + ' is not a function');\n};\n\nvar aCallable$8 = aCallable$9;\n\n// `GetMethod` abstract operation\n// https://tc39.es/ecma262/#sec-getmethod\nvar getMethod$4 = function (V, P) {\n  var func = V[P];\n  return func == null ? undefined : aCallable$8(func);\n};\n\nvar call$j = functionCall;\nvar isCallable$i = isCallable$n;\nvar isObject$c = isObject$d;\n\nvar $TypeError$d = TypeError;\n\n// `OrdinaryToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-ordinarytoprimitive\nvar ordinaryToPrimitive$1 = function (input, pref) {\n  var fn, val;\n  if (pref === 'string' && isCallable$i(fn = input.toString) && !isObject$c(val = call$j(fn, input))) return val;\n  if (isCallable$i(fn = input.valueOf) && !isObject$c(val = call$j(fn, input))) return val;\n  if (pref !== 'string' && isCallable$i(fn = input.toString) && !isObject$c(val = call$j(fn, input))) return val;\n  throw $TypeError$d(\"Can't convert object to primitive value\");\n};\n\nvar shared$4 = {exports: {}};\n\nvar global$q = global$t;\n\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar defineProperty$7 = Object.defineProperty;\n\nvar defineGlobalProperty$3 = function (key, value) {\n  try {\n    defineProperty$7(global$q, key, { value: value, configurable: true, writable: true });\n  } catch (error) {\n    global$q[key] = value;\n  } return value;\n};\n\nvar global$p = global$t;\nvar defineGlobalProperty$2 = defineGlobalProperty$3;\n\nvar SHARED = '__core-js_shared__';\nvar store$3 = global$p[SHARED] || defineGlobalProperty$2(SHARED, {});\n\nvar sharedStore = store$3;\n\nvar store$2 = sharedStore;\n\n(shared$4.exports = function (key, value) {\n  return store$2[key] || (store$2[key] = value !== undefined ? value : {});\n})('versions', []).push({\n  version: '3.23.3',\n  mode: 'global',\n  copyright: '© 2014-2022 Denis Pushkarev (zloirock.ru)',\n  license: 'https://github.com/zloirock/core-js/blob/v3.23.3/LICENSE',\n  source: 'https://github.com/zloirock/core-js'\n});\n\nvar requireObjectCoercible$4 = requireObjectCoercible$6;\n\nvar $Object$2 = Object;\n\n// `ToObject` abstract operation\n// https://tc39.es/ecma262/#sec-toobject\nvar toObject$7 = function (argument) {\n  return $Object$2(requireObjectCoercible$4(argument));\n};\n\nvar uncurryThis$l = functionUncurryThis;\nvar toObject$6 = toObject$7;\n\nvar hasOwnProperty = uncurryThis$l({}.hasOwnProperty);\n\n// `HasOwnProperty` abstract operation\n// https://tc39.es/ecma262/#sec-hasownproperty\n// eslint-disable-next-line es-x/no-object-hasown -- safe\nvar hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {\n  return hasOwnProperty(toObject$6(it), key);\n};\n\nvar uncurryThis$k = functionUncurryThis;\n\nvar id = 0;\nvar postfix = Math.random();\nvar toString$6 = uncurryThis$k(1.0.toString);\n\nvar uid$3 = function (key) {\n  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString$6(++id + postfix, 36);\n};\n\nvar global$o = global$t;\nvar shared$3 = shared$4.exports;\nvar hasOwn$b = hasOwnProperty_1;\nvar uid$2 = uid$3;\nvar NATIVE_SYMBOL = nativeSymbol;\nvar USE_SYMBOL_AS_UID = useSymbolAsUid;\n\nvar WellKnownSymbolsStore = shared$3('wks');\nvar Symbol$1 = global$o.Symbol;\nvar symbolFor = Symbol$1 && Symbol$1['for'];\nvar createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid$2;\n\nvar wellKnownSymbol$j = function (name) {\n  if (!hasOwn$b(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == 'string')) {\n    var description = 'Symbol.' + name;\n    if (NATIVE_SYMBOL && hasOwn$b(Symbol$1, name)) {\n      WellKnownSymbolsStore[name] = Symbol$1[name];\n    } else if (USE_SYMBOL_AS_UID && symbolFor) {\n      WellKnownSymbolsStore[name] = symbolFor(description);\n    } else {\n      WellKnownSymbolsStore[name] = createWellKnownSymbol(description);\n    }\n  } return WellKnownSymbolsStore[name];\n};\n\nvar call$i = functionCall;\nvar isObject$b = isObject$d;\nvar isSymbol$2 = isSymbol$3;\nvar getMethod$3 = getMethod$4;\nvar ordinaryToPrimitive = ordinaryToPrimitive$1;\nvar wellKnownSymbol$i = wellKnownSymbol$j;\n\nvar $TypeError$c = TypeError;\nvar TO_PRIMITIVE = wellKnownSymbol$i('toPrimitive');\n\n// `ToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-toprimitive\nvar toPrimitive$2 = function (input, pref) {\n  if (!isObject$b(input) || isSymbol$2(input)) return input;\n  var exoticToPrim = getMethod$3(input, TO_PRIMITIVE);\n  var result;\n  if (exoticToPrim) {\n    if (pref === undefined) pref = 'default';\n    result = call$i(exoticToPrim, input, pref);\n    if (!isObject$b(result) || isSymbol$2(result)) return result;\n    throw $TypeError$c(\"Can't convert object to primitive value\");\n  }\n  if (pref === undefined) pref = 'number';\n  return ordinaryToPrimitive(input, pref);\n};\n\nvar toPrimitive$1 = toPrimitive$2;\nvar isSymbol$1 = isSymbol$3;\n\n// `ToPropertyKey` abstract operation\n// https://tc39.es/ecma262/#sec-topropertykey\nvar toPropertyKey$4 = function (argument) {\n  var key = toPrimitive$1(argument, 'string');\n  return isSymbol$1(key) ? key : key + '';\n};\n\nvar global$n = global$t;\nvar isObject$a = isObject$d;\n\nvar document$3 = global$n.document;\n// typeof document.createElement is 'object' in old IE\nvar EXISTS$1 = isObject$a(document$3) && isObject$a(document$3.createElement);\n\nvar documentCreateElement$2 = function (it) {\n  return EXISTS$1 ? document$3.createElement(it) : {};\n};\n\nvar DESCRIPTORS$d = descriptors;\nvar fails$n = fails$s;\nvar createElement$1 = documentCreateElement$2;\n\n// Thanks to IE8 for its funny defineProperty\nvar ie8DomDefine = !DESCRIPTORS$d && !fails$n(function () {\n  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n  return Object.defineProperty(createElement$1('div'), 'a', {\n    get: function () { return 7; }\n  }).a != 7;\n});\n\nvar DESCRIPTORS$c = descriptors;\nvar call$h = functionCall;\nvar propertyIsEnumerableModule$1 = objectPropertyIsEnumerable;\nvar createPropertyDescriptor$4 = createPropertyDescriptor$5;\nvar toIndexedObject$5 = toIndexedObject$6;\nvar toPropertyKey$3 = toPropertyKey$4;\nvar hasOwn$a = hasOwnProperty_1;\nvar IE8_DOM_DEFINE$1 = ie8DomDefine;\n\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;\n\n// `Object.getOwnPropertyDescriptor` method\n// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor\nobjectGetOwnPropertyDescriptor.f = DESCRIPTORS$c ? $getOwnPropertyDescriptor$1 : function getOwnPropertyDescriptor(O, P) {\n  O = toIndexedObject$5(O);\n  P = toPropertyKey$3(P);\n  if (IE8_DOM_DEFINE$1) try {\n    return $getOwnPropertyDescriptor$1(O, P);\n  } catch (error) { /* empty */ }\n  if (hasOwn$a(O, P)) return createPropertyDescriptor$4(!call$h(propertyIsEnumerableModule$1.f, O, P), O[P]);\n};\n\nvar objectDefineProperty = {};\n\nvar DESCRIPTORS$b = descriptors;\nvar fails$m = fails$s;\n\n// V8 ~ Chrome 36-\n// https://bugs.chromium.org/p/v8/issues/detail?id=3334\nvar v8PrototypeDefineBug = DESCRIPTORS$b && fails$m(function () {\n  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n  return Object.defineProperty(function () { /* empty */ }, 'prototype', {\n    value: 42,\n    writable: false\n  }).prototype != 42;\n});\n\nvar isObject$9 = isObject$d;\n\nvar $String$2 = String;\nvar $TypeError$b = TypeError;\n\n// `Assert: Type(argument) is Object`\nvar anObject$e = function (argument) {\n  if (isObject$9(argument)) return argument;\n  throw $TypeError$b($String$2(argument) + ' is not an object');\n};\n\nvar DESCRIPTORS$a = descriptors;\nvar IE8_DOM_DEFINE = ie8DomDefine;\nvar V8_PROTOTYPE_DEFINE_BUG$1 = v8PrototypeDefineBug;\nvar anObject$d = anObject$e;\nvar toPropertyKey$2 = toPropertyKey$4;\n\nvar $TypeError$a = TypeError;\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar $defineProperty = Object.defineProperty;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar ENUMERABLE = 'enumerable';\nvar CONFIGURABLE$1 = 'configurable';\nvar WRITABLE = 'writable';\n\n// `Object.defineProperty` method\n// https://tc39.es/ecma262/#sec-object.defineproperty\nobjectDefineProperty.f = DESCRIPTORS$a ? V8_PROTOTYPE_DEFINE_BUG$1 ? function defineProperty(O, P, Attributes) {\n  anObject$d(O);\n  P = toPropertyKey$2(P);\n  anObject$d(Attributes);\n  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {\n    var current = $getOwnPropertyDescriptor(O, P);\n    if (current && current[WRITABLE]) {\n      O[P] = Attributes.value;\n      Attributes = {\n        configurable: CONFIGURABLE$1 in Attributes ? Attributes[CONFIGURABLE$1] : current[CONFIGURABLE$1],\n        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],\n        writable: false\n      };\n    }\n  } return $defineProperty(O, P, Attributes);\n} : $defineProperty : function defineProperty(O, P, Attributes) {\n  anObject$d(O);\n  P = toPropertyKey$2(P);\n  anObject$d(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return $defineProperty(O, P, Attributes);\n  } catch (error) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw $TypeError$a('Accessors not supported');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n\nvar DESCRIPTORS$9 = descriptors;\nvar definePropertyModule$6 = objectDefineProperty;\nvar createPropertyDescriptor$3 = createPropertyDescriptor$5;\n\nvar createNonEnumerableProperty$8 = DESCRIPTORS$9 ? function (object, key, value) {\n  return definePropertyModule$6.f(object, key, createPropertyDescriptor$3(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n\nvar makeBuiltIn$2 = {exports: {}};\n\nvar DESCRIPTORS$8 = descriptors;\nvar hasOwn$9 = hasOwnProperty_1;\n\nvar FunctionPrototype$1 = Function.prototype;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar getDescriptor = DESCRIPTORS$8 && Object.getOwnPropertyDescriptor;\n\nvar EXISTS = hasOwn$9(FunctionPrototype$1, 'name');\n// additional protection from minified / mangled / dropped function names\nvar PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';\nvar CONFIGURABLE = EXISTS && (!DESCRIPTORS$8 || (DESCRIPTORS$8 && getDescriptor(FunctionPrototype$1, 'name').configurable));\n\nvar functionName = {\n  EXISTS: EXISTS,\n  PROPER: PROPER,\n  CONFIGURABLE: CONFIGURABLE\n};\n\nvar uncurryThis$j = functionUncurryThis;\nvar isCallable$h = isCallable$n;\nvar store$1 = sharedStore;\n\nvar functionToString = uncurryThis$j(Function.toString);\n\n// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper\nif (!isCallable$h(store$1.inspectSource)) {\n  store$1.inspectSource = function (it) {\n    return functionToString(it);\n  };\n}\n\nvar inspectSource$4 = store$1.inspectSource;\n\nvar global$m = global$t;\nvar isCallable$g = isCallable$n;\nvar inspectSource$3 = inspectSource$4;\n\nvar WeakMap$1 = global$m.WeakMap;\n\nvar nativeWeakMap = isCallable$g(WeakMap$1) && /native code/.test(inspectSource$3(WeakMap$1));\n\nvar shared$2 = shared$4.exports;\nvar uid$1 = uid$3;\n\nvar keys$1 = shared$2('keys');\n\nvar sharedKey$3 = function (key) {\n  return keys$1[key] || (keys$1[key] = uid$1(key));\n};\n\nvar hiddenKeys$4 = {};\n\nvar NATIVE_WEAK_MAP = nativeWeakMap;\nvar global$l = global$t;\nvar uncurryThis$i = functionUncurryThis;\nvar isObject$8 = isObject$d;\nvar createNonEnumerableProperty$7 = createNonEnumerableProperty$8;\nvar hasOwn$8 = hasOwnProperty_1;\nvar shared$1 = sharedStore;\nvar sharedKey$2 = sharedKey$3;\nvar hiddenKeys$3 = hiddenKeys$4;\n\nvar OBJECT_ALREADY_INITIALIZED = 'Object already initialized';\nvar TypeError$3 = global$l.TypeError;\nvar WeakMap = global$l.WeakMap;\nvar set$2, get$1, has;\n\nvar enforce = function (it) {\n  return has(it) ? get$1(it) : set$2(it, {});\n};\n\nvar getterFor = function (TYPE) {\n  return function (it) {\n    var state;\n    if (!isObject$8(it) || (state = get$1(it)).type !== TYPE) {\n      throw TypeError$3('Incompatible receiver, ' + TYPE + ' required');\n    } return state;\n  };\n};\n\nif (NATIVE_WEAK_MAP || shared$1.state) {\n  var store = shared$1.state || (shared$1.state = new WeakMap());\n  var wmget = uncurryThis$i(store.get);\n  var wmhas = uncurryThis$i(store.has);\n  var wmset = uncurryThis$i(store.set);\n  set$2 = function (it, metadata) {\n    if (wmhas(store, it)) throw new TypeError$3(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    wmset(store, it, metadata);\n    return metadata;\n  };\n  get$1 = function (it) {\n    return wmget(store, it) || {};\n  };\n  has = function (it) {\n    return wmhas(store, it);\n  };\n} else {\n  var STATE = sharedKey$2('state');\n  hiddenKeys$3[STATE] = true;\n  set$2 = function (it, metadata) {\n    if (hasOwn$8(it, STATE)) throw new TypeError$3(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    createNonEnumerableProperty$7(it, STATE, metadata);\n    return metadata;\n  };\n  get$1 = function (it) {\n    return hasOwn$8(it, STATE) ? it[STATE] : {};\n  };\n  has = function (it) {\n    return hasOwn$8(it, STATE);\n  };\n}\n\nvar internalState = {\n  set: set$2,\n  get: get$1,\n  has: has,\n  enforce: enforce,\n  getterFor: getterFor\n};\n\nvar fails$l = fails$s;\nvar isCallable$f = isCallable$n;\nvar hasOwn$7 = hasOwnProperty_1;\nvar DESCRIPTORS$7 = descriptors;\nvar CONFIGURABLE_FUNCTION_NAME$2 = functionName.CONFIGURABLE;\nvar inspectSource$2 = inspectSource$4;\nvar InternalStateModule$5 = internalState;\n\nvar enforceInternalState$2 = InternalStateModule$5.enforce;\nvar getInternalState$5 = InternalStateModule$5.get;\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar defineProperty$6 = Object.defineProperty;\n\nvar CONFIGURABLE_LENGTH = DESCRIPTORS$7 && !fails$l(function () {\n  return defineProperty$6(function () { /* empty */ }, 'length', { value: 8 }).length !== 8;\n});\n\nvar TEMPLATE = String(String).split('String');\n\nvar makeBuiltIn$1 = makeBuiltIn$2.exports = function (value, name, options) {\n  if (String(name).slice(0, 7) === 'Symbol(') {\n    name = '[' + String(name).replace(/^Symbol\\(([^)]*)\\)/, '$1') + ']';\n  }\n  if (options && options.getter) name = 'get ' + name;\n  if (options && options.setter) name = 'set ' + name;\n  if (!hasOwn$7(value, 'name') || (CONFIGURABLE_FUNCTION_NAME$2 && value.name !== name)) {\n    if (DESCRIPTORS$7) defineProperty$6(value, 'name', { value: name, configurable: true });\n    else value.name = name;\n  }\n  if (CONFIGURABLE_LENGTH && options && hasOwn$7(options, 'arity') && value.length !== options.arity) {\n    defineProperty$6(value, 'length', { value: options.arity });\n  }\n  try {\n    if (options && hasOwn$7(options, 'constructor') && options.constructor) {\n      if (DESCRIPTORS$7) defineProperty$6(value, 'prototype', { writable: false });\n    // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable\n    } else if (value.prototype) value.prototype = undefined;\n  } catch (error) { /* empty */ }\n  var state = enforceInternalState$2(value);\n  if (!hasOwn$7(state, 'source')) {\n    state.source = TEMPLATE.join(typeof name == 'string' ? name : '');\n  } return value;\n};\n\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n// eslint-disable-next-line no-extend-native -- required\nFunction.prototype.toString = makeBuiltIn$1(function toString() {\n  return isCallable$f(this) && getInternalState$5(this).source || inspectSource$2(this);\n}, 'toString');\n\nvar isCallable$e = isCallable$n;\nvar definePropertyModule$5 = objectDefineProperty;\nvar makeBuiltIn = makeBuiltIn$2.exports;\nvar defineGlobalProperty$1 = defineGlobalProperty$3;\n\nvar defineBuiltIn$8 = function (O, key, value, options) {\n  if (!options) options = {};\n  var simple = options.enumerable;\n  var name = options.name !== undefined ? options.name : key;\n  if (isCallable$e(value)) makeBuiltIn(value, name, options);\n  if (options.global) {\n    if (simple) O[key] = value;\n    else defineGlobalProperty$1(key, value);\n  } else {\n    try {\n      if (!options.unsafe) delete O[key];\n      else if (O[key]) simple = true;\n    } catch (error) { /* empty */ }\n    if (simple) O[key] = value;\n    else definePropertyModule$5.f(O, key, {\n      value: value,\n      enumerable: false,\n      configurable: !options.nonConfigurable,\n      writable: !options.nonWritable\n    });\n  } return O;\n};\n\nvar objectGetOwnPropertyNames = {};\n\nvar ceil = Math.ceil;\nvar floor$3 = Math.floor;\n\n// `Math.trunc` method\n// https://tc39.es/ecma262/#sec-math.trunc\n// eslint-disable-next-line es-x/no-math-trunc -- safe\nvar mathTrunc = Math.trunc || function trunc(x) {\n  var n = +x;\n  return (n > 0 ? floor$3 : ceil)(n);\n};\n\nvar trunc = mathTrunc;\n\n// `ToIntegerOrInfinity` abstract operation\n// https://tc39.es/ecma262/#sec-tointegerorinfinity\nvar toIntegerOrInfinity$6 = function (argument) {\n  var number = +argument;\n  // eslint-disable-next-line no-self-compare -- NaN check\n  return number !== number || number === 0 ? 0 : trunc(number);\n};\n\nvar toIntegerOrInfinity$5 = toIntegerOrInfinity$6;\n\nvar max$1 = Math.max;\nvar min$2 = Math.min;\n\n// Helper for a popular repeating case of the spec:\n// Let integer be ? ToInteger(index).\n// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).\nvar toAbsoluteIndex$4 = function (index, length) {\n  var integer = toIntegerOrInfinity$5(index);\n  return integer < 0 ? max$1(integer + length, 0) : min$2(integer, length);\n};\n\nvar toIntegerOrInfinity$4 = toIntegerOrInfinity$6;\n\nvar min$1 = Math.min;\n\n// `ToLength` abstract operation\n// https://tc39.es/ecma262/#sec-tolength\nvar toLength$6 = function (argument) {\n  return argument > 0 ? min$1(toIntegerOrInfinity$4(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n};\n\nvar toLength$5 = toLength$6;\n\n// `LengthOfArrayLike` abstract operation\n// https://tc39.es/ecma262/#sec-lengthofarraylike\nvar lengthOfArrayLike$8 = function (obj) {\n  return toLength$5(obj.length);\n};\n\nvar toIndexedObject$4 = toIndexedObject$6;\nvar toAbsoluteIndex$3 = toAbsoluteIndex$4;\nvar lengthOfArrayLike$7 = lengthOfArrayLike$8;\n\n// `Array.prototype.{ indexOf, includes }` methods implementation\nvar createMethod$4 = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIndexedObject$4($this);\n    var length = lengthOfArrayLike$7(O);\n    var index = toAbsoluteIndex$3(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare -- NaN check\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare -- NaN check\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) {\n      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\nvar arrayIncludes = {\n  // `Array.prototype.includes` method\n  // https://tc39.es/ecma262/#sec-array.prototype.includes\n  includes: createMethod$4(true),\n  // `Array.prototype.indexOf` method\n  // https://tc39.es/ecma262/#sec-array.prototype.indexof\n  indexOf: createMethod$4(false)\n};\n\nvar uncurryThis$h = functionUncurryThis;\nvar hasOwn$6 = hasOwnProperty_1;\nvar toIndexedObject$3 = toIndexedObject$6;\nvar indexOf$1 = arrayIncludes.indexOf;\nvar hiddenKeys$2 = hiddenKeys$4;\n\nvar push$2 = uncurryThis$h([].push);\n\nvar objectKeysInternal = function (object, names) {\n  var O = toIndexedObject$3(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) !hasOwn$6(hiddenKeys$2, key) && hasOwn$6(O, key) && push$2(result, key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (hasOwn$6(O, key = names[i++])) {\n    ~indexOf$1(result, key) || push$2(result, key);\n  }\n  return result;\n};\n\n// IE8- don't enum bug keys\nvar enumBugKeys$3 = [\n  'constructor',\n  'hasOwnProperty',\n  'isPrototypeOf',\n  'propertyIsEnumerable',\n  'toLocaleString',\n  'toString',\n  'valueOf'\n];\n\nvar internalObjectKeys$1 = objectKeysInternal;\nvar enumBugKeys$2 = enumBugKeys$3;\n\nvar hiddenKeys$1 = enumBugKeys$2.concat('length', 'prototype');\n\n// `Object.getOwnPropertyNames` method\n// https://tc39.es/ecma262/#sec-object.getownpropertynames\n// eslint-disable-next-line es-x/no-object-getownpropertynames -- safe\nobjectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return internalObjectKeys$1(O, hiddenKeys$1);\n};\n\nvar objectGetOwnPropertySymbols = {};\n\n// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- safe\nobjectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;\n\nvar getBuiltIn$5 = getBuiltIn$8;\nvar uncurryThis$g = functionUncurryThis;\nvar getOwnPropertyNamesModule = objectGetOwnPropertyNames;\nvar getOwnPropertySymbolsModule$1 = objectGetOwnPropertySymbols;\nvar anObject$c = anObject$e;\n\nvar concat$1 = uncurryThis$g([].concat);\n\n// all object keys, includes non-enumerable and symbols\nvar ownKeys$1 = getBuiltIn$5('Reflect', 'ownKeys') || function ownKeys(it) {\n  var keys = getOwnPropertyNamesModule.f(anObject$c(it));\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule$1.f;\n  return getOwnPropertySymbols ? concat$1(keys, getOwnPropertySymbols(it)) : keys;\n};\n\nvar hasOwn$5 = hasOwnProperty_1;\nvar ownKeys = ownKeys$1;\nvar getOwnPropertyDescriptorModule$1 = objectGetOwnPropertyDescriptor;\nvar definePropertyModule$4 = objectDefineProperty;\n\nvar copyConstructorProperties$1 = function (target, source, exceptions) {\n  var keys = ownKeys(source);\n  var defineProperty = definePropertyModule$4.f;\n  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule$1.f;\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    if (!hasOwn$5(target, key) && !(exceptions && hasOwn$5(exceptions, key))) {\n      defineProperty(target, key, getOwnPropertyDescriptor(source, key));\n    }\n  }\n};\n\nvar fails$k = fails$s;\nvar isCallable$d = isCallable$n;\n\nvar replacement = /#|\\.prototype\\./;\n\nvar isForced$2 = function (feature, detection) {\n  var value = data[normalize(feature)];\n  return value == POLYFILL ? true\n    : value == NATIVE ? false\n    : isCallable$d(detection) ? fails$k(detection)\n    : !!detection;\n};\n\nvar normalize = isForced$2.normalize = function (string) {\n  return String(string).replace(replacement, '.').toLowerCase();\n};\n\nvar data = isForced$2.data = {};\nvar NATIVE = isForced$2.NATIVE = 'N';\nvar POLYFILL = isForced$2.POLYFILL = 'P';\n\nvar isForced_1 = isForced$2;\n\nvar global$k = global$t;\nvar getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;\nvar createNonEnumerableProperty$6 = createNonEnumerableProperty$8;\nvar defineBuiltIn$7 = defineBuiltIn$8;\nvar defineGlobalProperty = defineGlobalProperty$3;\nvar copyConstructorProperties = copyConstructorProperties$1;\nvar isForced$1 = isForced_1;\n\n/*\n  options.target         - name of the target object\n  options.global         - target is the global object\n  options.stat           - export as static methods of target\n  options.proto          - export as prototype methods of target\n  options.real           - real prototype method for the `pure` version\n  options.forced         - export even if the native feature is available\n  options.bind           - bind methods to the target, required for the `pure` version\n  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version\n  options.unsafe         - use the simple assignment of property instead of delete + defineProperty\n  options.sham           - add a flag to not completely full polyfills\n  options.enumerable     - export as enumerable property\n  options.dontCallGetSet - prevent calling a getter on target\n  options.name           - the .name of the function if it does not match the key\n*/\nvar _export = function (options, source) {\n  var TARGET = options.target;\n  var GLOBAL = options.global;\n  var STATIC = options.stat;\n  var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n  if (GLOBAL) {\n    target = global$k;\n  } else if (STATIC) {\n    target = global$k[TARGET] || defineGlobalProperty(TARGET, {});\n  } else {\n    target = (global$k[TARGET] || {}).prototype;\n  }\n  if (target) for (key in source) {\n    sourceProperty = source[key];\n    if (options.dontCallGetSet) {\n      descriptor = getOwnPropertyDescriptor$1(target, key);\n      targetProperty = descriptor && descriptor.value;\n    } else targetProperty = target[key];\n    FORCED = isForced$1(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);\n    // contained in target\n    if (!FORCED && targetProperty !== undefined) {\n      if (typeof sourceProperty == typeof targetProperty) continue;\n      copyConstructorProperties(sourceProperty, targetProperty);\n    }\n    // add a flag to not completely full polyfills\n    if (options.sham || (targetProperty && targetProperty.sham)) {\n      createNonEnumerableProperty$6(sourceProperty, 'sham', true);\n    }\n    defineBuiltIn$7(target, key, sourceProperty, options);\n  }\n};\n\nvar classof$a = classofRaw$1;\nvar global$j = global$t;\n\nvar engineIsNode = classof$a(global$j.process) == 'process';\n\nvar isCallable$c = isCallable$n;\n\nvar $String$1 = String;\nvar $TypeError$9 = TypeError;\n\nvar aPossiblePrototype$1 = function (argument) {\n  if (typeof argument == 'object' || isCallable$c(argument)) return argument;\n  throw $TypeError$9(\"Can't set \" + $String$1(argument) + ' as a prototype');\n};\n\n/* eslint-disable no-proto -- safe */\n\nvar uncurryThis$f = functionUncurryThis;\nvar anObject$b = anObject$e;\nvar aPossiblePrototype = aPossiblePrototype$1;\n\n// `Object.setPrototypeOf` method\n// https://tc39.es/ecma262/#sec-object.setprototypeof\n// Works with __proto__ only. Old v8 can't work with null proto objects.\n// eslint-disable-next-line es-x/no-object-setprototypeof -- safe\nvar objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {\n  var CORRECT_SETTER = false;\n  var test = {};\n  var setter;\n  try {\n    // eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\n    setter = uncurryThis$f(Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set);\n    setter(test, []);\n    CORRECT_SETTER = test instanceof Array;\n  } catch (error) { /* empty */ }\n  return function setPrototypeOf(O, proto) {\n    anObject$b(O);\n    aPossiblePrototype(proto);\n    if (CORRECT_SETTER) setter(O, proto);\n    else O.__proto__ = proto;\n    return O;\n  };\n}() : undefined);\n\nvar defineProperty$5 = objectDefineProperty.f;\nvar hasOwn$4 = hasOwnProperty_1;\nvar wellKnownSymbol$h = wellKnownSymbol$j;\n\nvar TO_STRING_TAG$4 = wellKnownSymbol$h('toStringTag');\n\nvar setToStringTag$4 = function (target, TAG, STATIC) {\n  if (target && !STATIC) target = target.prototype;\n  if (target && !hasOwn$4(target, TO_STRING_TAG$4)) {\n    defineProperty$5(target, TO_STRING_TAG$4, { configurable: true, value: TAG });\n  }\n};\n\nvar getBuiltIn$4 = getBuiltIn$8;\nvar definePropertyModule$3 = objectDefineProperty;\nvar wellKnownSymbol$g = wellKnownSymbol$j;\nvar DESCRIPTORS$6 = descriptors;\n\nvar SPECIES$4 = wellKnownSymbol$g('species');\n\nvar setSpecies$2 = function (CONSTRUCTOR_NAME) {\n  var Constructor = getBuiltIn$4(CONSTRUCTOR_NAME);\n  var defineProperty = definePropertyModule$3.f;\n\n  if (DESCRIPTORS$6 && Constructor && !Constructor[SPECIES$4]) {\n    defineProperty(Constructor, SPECIES$4, {\n      configurable: true,\n      get: function () { return this; }\n    });\n  }\n};\n\nvar isPrototypeOf$3 = objectIsPrototypeOf;\n\nvar $TypeError$8 = TypeError;\n\nvar anInstance$3 = function (it, Prototype) {\n  if (isPrototypeOf$3(Prototype, it)) return it;\n  throw $TypeError$8('Incorrect invocation');\n};\n\nvar wellKnownSymbol$f = wellKnownSymbol$j;\n\nvar TO_STRING_TAG$3 = wellKnownSymbol$f('toStringTag');\nvar test = {};\n\ntest[TO_STRING_TAG$3] = 'z';\n\nvar toStringTagSupport = String(test) === '[object z]';\n\nvar TO_STRING_TAG_SUPPORT = toStringTagSupport;\nvar isCallable$b = isCallable$n;\nvar classofRaw = classofRaw$1;\nvar wellKnownSymbol$e = wellKnownSymbol$j;\n\nvar TO_STRING_TAG$2 = wellKnownSymbol$e('toStringTag');\nvar $Object$1 = Object;\n\n// ES3 wrong here\nvar CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function (it, key) {\n  try {\n    return it[key];\n  } catch (error) { /* empty */ }\n};\n\n// getting tag from ES6+ `Object.prototype.toString`\nvar classof$9 = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {\n  var O, tag, result;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (tag = tryGet(O = $Object$1(it), TO_STRING_TAG$2)) == 'string' ? tag\n    // builtinTag case\n    : CORRECT_ARGUMENTS ? classofRaw(O)\n    // ES3 arguments fallback\n    : (result = classofRaw(O)) == 'Object' && isCallable$b(O.callee) ? 'Arguments' : result;\n};\n\nvar uncurryThis$e = functionUncurryThis;\nvar fails$j = fails$s;\nvar isCallable$a = isCallable$n;\nvar classof$8 = classof$9;\nvar getBuiltIn$3 = getBuiltIn$8;\nvar inspectSource$1 = inspectSource$4;\n\nvar noop = function () { /* empty */ };\nvar empty = [];\nvar construct = getBuiltIn$3('Reflect', 'construct');\nvar constructorRegExp = /^\\s*(?:class|function)\\b/;\nvar exec$2 = uncurryThis$e(constructorRegExp.exec);\nvar INCORRECT_TO_STRING = !constructorRegExp.exec(noop);\n\nvar isConstructorModern = function isConstructor(argument) {\n  if (!isCallable$a(argument)) return false;\n  try {\n    construct(noop, empty, argument);\n    return true;\n  } catch (error) {\n    return false;\n  }\n};\n\nvar isConstructorLegacy = function isConstructor(argument) {\n  if (!isCallable$a(argument)) return false;\n  switch (classof$8(argument)) {\n    case 'AsyncFunction':\n    case 'GeneratorFunction':\n    case 'AsyncGeneratorFunction': return false;\n  }\n  try {\n    // we can't check .prototype since constructors produced by .bind haven't it\n    // `Function#toString` throws on some built-it function in some legacy engines\n    // (for example, `DOMQuad` and similar in FF41-)\n    return INCORRECT_TO_STRING || !!exec$2(constructorRegExp, inspectSource$1(argument));\n  } catch (error) {\n    return true;\n  }\n};\n\nisConstructorLegacy.sham = true;\n\n// `IsConstructor` abstract operation\n// https://tc39.es/ecma262/#sec-isconstructor\nvar isConstructor$2 = !construct || fails$j(function () {\n  var called;\n  return isConstructorModern(isConstructorModern.call)\n    || !isConstructorModern(Object)\n    || !isConstructorModern(function () { called = true; })\n    || called;\n}) ? isConstructorLegacy : isConstructorModern;\n\nvar isConstructor$1 = isConstructor$2;\nvar tryToString$3 = tryToString$5;\n\nvar $TypeError$7 = TypeError;\n\n// `Assert: IsConstructor(argument) is true`\nvar aConstructor$2 = function (argument) {\n  if (isConstructor$1(argument)) return argument;\n  throw $TypeError$7(tryToString$3(argument) + ' is not a constructor');\n};\n\nvar anObject$a = anObject$e;\nvar aConstructor$1 = aConstructor$2;\nvar wellKnownSymbol$d = wellKnownSymbol$j;\n\nvar SPECIES$3 = wellKnownSymbol$d('species');\n\n// `SpeciesConstructor` abstract operation\n// https://tc39.es/ecma262/#sec-speciesconstructor\nvar speciesConstructor$3 = function (O, defaultConstructor) {\n  var C = anObject$a(O).constructor;\n  var S;\n  return C === undefined || (S = anObject$a(C)[SPECIES$3]) == undefined ? defaultConstructor : aConstructor$1(S);\n};\n\nvar NATIVE_BIND$1 = functionBindNative;\n\nvar FunctionPrototype = Function.prototype;\nvar apply$3 = FunctionPrototype.apply;\nvar call$g = FunctionPrototype.call;\n\n// eslint-disable-next-line es-x/no-reflect -- safe\nvar functionApply = typeof Reflect == 'object' && Reflect.apply || (NATIVE_BIND$1 ? call$g.bind(apply$3) : function () {\n  return call$g.apply(apply$3, arguments);\n});\n\nvar uncurryThis$d = functionUncurryThis;\nvar aCallable$7 = aCallable$9;\nvar NATIVE_BIND = functionBindNative;\n\nvar bind$6 = uncurryThis$d(uncurryThis$d.bind);\n\n// optional / simple context binding\nvar functionBindContext = function (fn, that) {\n  aCallable$7(fn);\n  return that === undefined ? fn : NATIVE_BIND ? bind$6(fn, that) : function (/* ...args */) {\n    return fn.apply(that, arguments);\n  };\n};\n\nvar getBuiltIn$2 = getBuiltIn$8;\n\nvar html$2 = getBuiltIn$2('document', 'documentElement');\n\nvar uncurryThis$c = functionUncurryThis;\n\nvar arraySlice$5 = uncurryThis$c([].slice);\n\nvar $TypeError$6 = TypeError;\n\nvar validateArgumentsLength$1 = function (passed, required) {\n  if (passed < required) throw $TypeError$6('Not enough arguments');\n  return passed;\n};\n\nvar userAgent$4 = engineUserAgent;\n\nvar engineIsIos = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent$4);\n\nvar global$i = global$t;\nvar apply$2 = functionApply;\nvar bind$5 = functionBindContext;\nvar isCallable$9 = isCallable$n;\nvar hasOwn$3 = hasOwnProperty_1;\nvar fails$i = fails$s;\nvar html$1 = html$2;\nvar arraySlice$4 = arraySlice$5;\nvar createElement = documentCreateElement$2;\nvar validateArgumentsLength = validateArgumentsLength$1;\nvar IS_IOS$1 = engineIsIos;\nvar IS_NODE$3 = engineIsNode;\n\nvar set$1 = global$i.setImmediate;\nvar clear = global$i.clearImmediate;\nvar process$2 = global$i.process;\nvar Dispatch = global$i.Dispatch;\nvar Function$1 = global$i.Function;\nvar MessageChannel = global$i.MessageChannel;\nvar String$1 = global$i.String;\nvar counter = 0;\nvar queue$1 = {};\nvar ONREADYSTATECHANGE = 'onreadystatechange';\nvar location, defer, channel, port;\n\ntry {\n  // Deno throws a ReferenceError on `location` access without `--location` flag\n  location = global$i.location;\n} catch (error) { /* empty */ }\n\nvar run = function (id) {\n  if (hasOwn$3(queue$1, id)) {\n    var fn = queue$1[id];\n    delete queue$1[id];\n    fn();\n  }\n};\n\nvar runner = function (id) {\n  return function () {\n    run(id);\n  };\n};\n\nvar listener = function (event) {\n  run(event.data);\n};\n\nvar post = function (id) {\n  // old engines have not location.origin\n  global$i.postMessage(String$1(id), location.protocol + '//' + location.host);\n};\n\n// Node.js 0.9+ & IE10+ has setImmediate, otherwise:\nif (!set$1 || !clear) {\n  set$1 = function setImmediate(handler) {\n    validateArgumentsLength(arguments.length, 1);\n    var fn = isCallable$9(handler) ? handler : Function$1(handler);\n    var args = arraySlice$4(arguments, 1);\n    queue$1[++counter] = function () {\n      apply$2(fn, undefined, args);\n    };\n    defer(counter);\n    return counter;\n  };\n  clear = function clearImmediate(id) {\n    delete queue$1[id];\n  };\n  // Node.js 0.8-\n  if (IS_NODE$3) {\n    defer = function (id) {\n      process$2.nextTick(runner(id));\n    };\n  // Sphere (JS game engine) Dispatch API\n  } else if (Dispatch && Dispatch.now) {\n    defer = function (id) {\n      Dispatch.now(runner(id));\n    };\n  // Browsers with MessageChannel, includes WebWorkers\n  // except iOS - https://github.com/zloirock/core-js/issues/624\n  } else if (MessageChannel && !IS_IOS$1) {\n    channel = new MessageChannel();\n    port = channel.port2;\n    channel.port1.onmessage = listener;\n    defer = bind$5(port.postMessage, port);\n  // Browsers with postMessage, skip WebWorkers\n  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'\n  } else if (\n    global$i.addEventListener &&\n    isCallable$9(global$i.postMessage) &&\n    !global$i.importScripts &&\n    location && location.protocol !== 'file:' &&\n    !fails$i(post)\n  ) {\n    defer = post;\n    global$i.addEventListener('message', listener, false);\n  // IE8-\n  } else if (ONREADYSTATECHANGE in createElement('script')) {\n    defer = function (id) {\n      html$1.appendChild(createElement('script'))[ONREADYSTATECHANGE] = function () {\n        html$1.removeChild(this);\n        run(id);\n      };\n    };\n  // Rest old browsers\n  } else {\n    defer = function (id) {\n      setTimeout(runner(id), 0);\n    };\n  }\n}\n\nvar task$1 = {\n  set: set$1,\n  clear: clear\n};\n\nvar userAgent$3 = engineUserAgent;\nvar global$h = global$t;\n\nvar engineIsIosPebble = /ipad|iphone|ipod/i.test(userAgent$3) && global$h.Pebble !== undefined;\n\nvar userAgent$2 = engineUserAgent;\n\nvar engineIsWebosWebkit = /web0s(?!.*chrome)/i.test(userAgent$2);\n\nvar global$g = global$t;\nvar bind$4 = functionBindContext;\nvar getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;\nvar macrotask = task$1.set;\nvar IS_IOS = engineIsIos;\nvar IS_IOS_PEBBLE = engineIsIosPebble;\nvar IS_WEBOS_WEBKIT = engineIsWebosWebkit;\nvar IS_NODE$2 = engineIsNode;\n\nvar MutationObserver = global$g.MutationObserver || global$g.WebKitMutationObserver;\nvar document$2 = global$g.document;\nvar process$1 = global$g.process;\nvar Promise$1 = global$g.Promise;\n// Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`\nvar queueMicrotaskDescriptor = getOwnPropertyDescriptor(global$g, 'queueMicrotask');\nvar queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;\n\nvar flush, head, last, notify$1, toggle, node, promise, then;\n\n// modern engines have queueMicrotask method\nif (!queueMicrotask) {\n  flush = function () {\n    var parent, fn;\n    if (IS_NODE$2 && (parent = process$1.domain)) parent.exit();\n    while (head) {\n      fn = head.fn;\n      head = head.next;\n      try {\n        fn();\n      } catch (error) {\n        if (head) notify$1();\n        else last = undefined;\n        throw error;\n      }\n    } last = undefined;\n    if (parent) parent.enter();\n  };\n\n  // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339\n  // also except WebOS Webkit https://github.com/zloirock/core-js/issues/898\n  if (!IS_IOS && !IS_NODE$2 && !IS_WEBOS_WEBKIT && MutationObserver && document$2) {\n    toggle = true;\n    node = document$2.createTextNode('');\n    new MutationObserver(flush).observe(node, { characterData: true });\n    notify$1 = function () {\n      node.data = toggle = !toggle;\n    };\n  // environments with maybe non-completely correct, but existent Promise\n  } else if (!IS_IOS_PEBBLE && Promise$1 && Promise$1.resolve) {\n    // Promise.resolve without an argument throws an error in LG WebOS 2\n    promise = Promise$1.resolve(undefined);\n    // workaround of WebKit ~ iOS Safari 10.1 bug\n    promise.constructor = Promise$1;\n    then = bind$4(promise.then, promise);\n    notify$1 = function () {\n      then(flush);\n    };\n  // Node.js without promises\n  } else if (IS_NODE$2) {\n    notify$1 = function () {\n      process$1.nextTick(flush);\n    };\n  // for other environments - macrotask based on:\n  // - setImmediate\n  // - MessageChannel\n  // - window.postMessage\n  // - onreadystatechange\n  // - setTimeout\n  } else {\n    // strange IE + webpack dev server bug - use .bind(global)\n    macrotask = bind$4(macrotask, global$g);\n    notify$1 = function () {\n      macrotask(flush);\n    };\n  }\n}\n\nvar microtask$1 = queueMicrotask || function (fn) {\n  var task = { fn: fn, next: undefined };\n  if (last) last.next = task;\n  if (!head) {\n    head = task;\n    notify$1();\n  } last = task;\n};\n\nvar global$f = global$t;\n\nvar hostReportErrors$1 = function (a, b) {\n  var console = global$f.console;\n  if (console && console.error) {\n    arguments.length == 1 ? console.error(a) : console.error(a, b);\n  }\n};\n\nvar perform$3 = function (exec) {\n  try {\n    return { error: false, value: exec() };\n  } catch (error) {\n    return { error: true, value: error };\n  }\n};\n\nvar Queue$1 = function () {\n  this.head = null;\n  this.tail = null;\n};\n\nQueue$1.prototype = {\n  add: function (item) {\n    var entry = { item: item, next: null };\n    if (this.head) this.tail.next = entry;\n    else this.head = entry;\n    this.tail = entry;\n  },\n  get: function () {\n    var entry = this.head;\n    if (entry) {\n      this.head = entry.next;\n      if (this.tail === entry) this.tail = null;\n      return entry.item;\n    }\n  }\n};\n\nvar queue = Queue$1;\n\nvar global$e = global$t;\n\nvar promiseNativeConstructor = global$e.Promise;\n\nvar engineIsBrowser = typeof window == 'object' && typeof Deno != 'object';\n\nvar global$d = global$t;\nvar NativePromiseConstructor$3 = promiseNativeConstructor;\nvar isCallable$8 = isCallable$n;\nvar isForced = isForced_1;\nvar inspectSource = inspectSource$4;\nvar wellKnownSymbol$c = wellKnownSymbol$j;\nvar IS_BROWSER = engineIsBrowser;\nvar V8_VERSION = engineV8Version;\n\nNativePromiseConstructor$3 && NativePromiseConstructor$3.prototype;\nvar SPECIES$2 = wellKnownSymbol$c('species');\nvar SUBCLASSING = false;\nvar NATIVE_PROMISE_REJECTION_EVENT$1 = isCallable$8(global$d.PromiseRejectionEvent);\n\nvar FORCED_PROMISE_CONSTRUCTOR$5 = isForced('Promise', function () {\n  var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(NativePromiseConstructor$3);\n  var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(NativePromiseConstructor$3);\n  // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=830565\n  // We can't detect it synchronously, so just check versions\n  if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66) return true;\n  // We can't use @@species feature detection in V8 since it causes\n  // deoptimization and performance degradation\n  // https://github.com/zloirock/core-js/issues/679\n  if (V8_VERSION >= 51 && /native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) return false;\n  // Detect correctness of subclassing with @@species support\n  var promise = new NativePromiseConstructor$3(function (resolve) { resolve(1); });\n  var FakePromise = function (exec) {\n    exec(function () { /* empty */ }, function () { /* empty */ });\n  };\n  var constructor = promise.constructor = {};\n  constructor[SPECIES$2] = FakePromise;\n  SUBCLASSING = promise.then(function () { /* empty */ }) instanceof FakePromise;\n  if (!SUBCLASSING) return true;\n  // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test\n  return !GLOBAL_CORE_JS_PROMISE && IS_BROWSER && !NATIVE_PROMISE_REJECTION_EVENT$1;\n});\n\nvar promiseConstructorDetection = {\n  CONSTRUCTOR: FORCED_PROMISE_CONSTRUCTOR$5,\n  REJECTION_EVENT: NATIVE_PROMISE_REJECTION_EVENT$1,\n  SUBCLASSING: SUBCLASSING\n};\n\nvar newPromiseCapability$2 = {};\n\nvar aCallable$6 = aCallable$9;\n\nvar PromiseCapability = function (C) {\n  var resolve, reject;\n  this.promise = new C(function ($$resolve, $$reject) {\n    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');\n    resolve = $$resolve;\n    reject = $$reject;\n  });\n  this.resolve = aCallable$6(resolve);\n  this.reject = aCallable$6(reject);\n};\n\n// `NewPromiseCapability` abstract operation\n// https://tc39.es/ecma262/#sec-newpromisecapability\nnewPromiseCapability$2.f = function (C) {\n  return new PromiseCapability(C);\n};\n\nvar $$e = _export;\nvar IS_NODE$1 = engineIsNode;\nvar global$c = global$t;\nvar call$f = functionCall;\nvar defineBuiltIn$6 = defineBuiltIn$8;\nvar setPrototypeOf$5 = objectSetPrototypeOf;\nvar setToStringTag$3 = setToStringTag$4;\nvar setSpecies$1 = setSpecies$2;\nvar aCallable$5 = aCallable$9;\nvar isCallable$7 = isCallable$n;\nvar isObject$7 = isObject$d;\nvar anInstance$2 = anInstance$3;\nvar speciesConstructor$2 = speciesConstructor$3;\nvar task = task$1.set;\nvar microtask = microtask$1;\nvar hostReportErrors = hostReportErrors$1;\nvar perform$2 = perform$3;\nvar Queue = queue;\nvar InternalStateModule$4 = internalState;\nvar NativePromiseConstructor$2 = promiseNativeConstructor;\nvar PromiseConstructorDetection = promiseConstructorDetection;\nvar newPromiseCapabilityModule$3 = newPromiseCapability$2;\n\nvar PROMISE = 'Promise';\nvar FORCED_PROMISE_CONSTRUCTOR$4 = PromiseConstructorDetection.CONSTRUCTOR;\nvar NATIVE_PROMISE_REJECTION_EVENT = PromiseConstructorDetection.REJECTION_EVENT;\nvar NATIVE_PROMISE_SUBCLASSING = PromiseConstructorDetection.SUBCLASSING;\nvar getInternalPromiseState = InternalStateModule$4.getterFor(PROMISE);\nvar setInternalState$3 = InternalStateModule$4.set;\nvar NativePromisePrototype$1 = NativePromiseConstructor$2 && NativePromiseConstructor$2.prototype;\nvar PromiseConstructor = NativePromiseConstructor$2;\nvar PromisePrototype = NativePromisePrototype$1;\nvar TypeError$2 = global$c.TypeError;\nvar document$1 = global$c.document;\nvar process = global$c.process;\nvar newPromiseCapability$1 = newPromiseCapabilityModule$3.f;\nvar newGenericPromiseCapability = newPromiseCapability$1;\n\nvar DISPATCH_EVENT = !!(document$1 && document$1.createEvent && global$c.dispatchEvent);\nvar UNHANDLED_REJECTION = 'unhandledrejection';\nvar REJECTION_HANDLED = 'rejectionhandled';\nvar PENDING = 0;\nvar FULFILLED = 1;\nvar REJECTED = 2;\nvar HANDLED = 1;\nvar UNHANDLED = 2;\n\nvar Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;\n\n// helpers\nvar isThenable = function (it) {\n  var then;\n  return isObject$7(it) && isCallable$7(then = it.then) ? then : false;\n};\n\nvar callReaction = function (reaction, state) {\n  var value = state.value;\n  var ok = state.state == FULFILLED;\n  var handler = ok ? reaction.ok : reaction.fail;\n  var resolve = reaction.resolve;\n  var reject = reaction.reject;\n  var domain = reaction.domain;\n  var result, then, exited;\n  try {\n    if (handler) {\n      if (!ok) {\n        if (state.rejection === UNHANDLED) onHandleUnhandled(state);\n        state.rejection = HANDLED;\n      }\n      if (handler === true) result = value;\n      else {\n        if (domain) domain.enter();\n        result = handler(value); // can throw\n        if (domain) {\n          domain.exit();\n          exited = true;\n        }\n      }\n      if (result === reaction.promise) {\n        reject(TypeError$2('Promise-chain cycle'));\n      } else if (then = isThenable(result)) {\n        call$f(then, result, resolve, reject);\n      } else resolve(result);\n    } else reject(value);\n  } catch (error) {\n    if (domain && !exited) domain.exit();\n    reject(error);\n  }\n};\n\nvar notify = function (state, isReject) {\n  if (state.notified) return;\n  state.notified = true;\n  microtask(function () {\n    var reactions = state.reactions;\n    var reaction;\n    while (reaction = reactions.get()) {\n      callReaction(reaction, state);\n    }\n    state.notified = false;\n    if (isReject && !state.rejection) onUnhandled(state);\n  });\n};\n\nvar dispatchEvent = function (name, promise, reason) {\n  var event, handler;\n  if (DISPATCH_EVENT) {\n    event = document$1.createEvent('Event');\n    event.promise = promise;\n    event.reason = reason;\n    event.initEvent(name, false, true);\n    global$c.dispatchEvent(event);\n  } else event = { promise: promise, reason: reason };\n  if (!NATIVE_PROMISE_REJECTION_EVENT && (handler = global$c['on' + name])) handler(event);\n  else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);\n};\n\nvar onUnhandled = function (state) {\n  call$f(task, global$c, function () {\n    var promise = state.facade;\n    var value = state.value;\n    var IS_UNHANDLED = isUnhandled(state);\n    var result;\n    if (IS_UNHANDLED) {\n      result = perform$2(function () {\n        if (IS_NODE$1) {\n          process.emit('unhandledRejection', value, promise);\n        } else dispatchEvent(UNHANDLED_REJECTION, promise, value);\n      });\n      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should\n      state.rejection = IS_NODE$1 || isUnhandled(state) ? UNHANDLED : HANDLED;\n      if (result.error) throw result.value;\n    }\n  });\n};\n\nvar isUnhandled = function (state) {\n  return state.rejection !== HANDLED && !state.parent;\n};\n\nvar onHandleUnhandled = function (state) {\n  call$f(task, global$c, function () {\n    var promise = state.facade;\n    if (IS_NODE$1) {\n      process.emit('rejectionHandled', promise);\n    } else dispatchEvent(REJECTION_HANDLED, promise, state.value);\n  });\n};\n\nvar bind$3 = function (fn, state, unwrap) {\n  return function (value) {\n    fn(state, value, unwrap);\n  };\n};\n\nvar internalReject = function (state, value, unwrap) {\n  if (state.done) return;\n  state.done = true;\n  if (unwrap) state = unwrap;\n  state.value = value;\n  state.state = REJECTED;\n  notify(state, true);\n};\n\nvar internalResolve = function (state, value, unwrap) {\n  if (state.done) return;\n  state.done = true;\n  if (unwrap) state = unwrap;\n  try {\n    if (state.facade === value) throw TypeError$2(\"Promise can't be resolved itself\");\n    var then = isThenable(value);\n    if (then) {\n      microtask(function () {\n        var wrapper = { done: false };\n        try {\n          call$f(then, value,\n            bind$3(internalResolve, wrapper, state),\n            bind$3(internalReject, wrapper, state)\n          );\n        } catch (error) {\n          internalReject(wrapper, error, state);\n        }\n      });\n    } else {\n      state.value = value;\n      state.state = FULFILLED;\n      notify(state, false);\n    }\n  } catch (error) {\n    internalReject({ done: false }, error, state);\n  }\n};\n\n// constructor polyfill\nif (FORCED_PROMISE_CONSTRUCTOR$4) {\n  // 25.4.3.1 Promise(executor)\n  PromiseConstructor = function Promise(executor) {\n    anInstance$2(this, PromisePrototype);\n    aCallable$5(executor);\n    call$f(Internal, this);\n    var state = getInternalPromiseState(this);\n    try {\n      executor(bind$3(internalResolve, state), bind$3(internalReject, state));\n    } catch (error) {\n      internalReject(state, error);\n    }\n  };\n\n  PromisePrototype = PromiseConstructor.prototype;\n\n  // eslint-disable-next-line no-unused-vars -- required for `.length`\n  Internal = function Promise(executor) {\n    setInternalState$3(this, {\n      type: PROMISE,\n      done: false,\n      notified: false,\n      parent: false,\n      reactions: new Queue(),\n      rejection: false,\n      state: PENDING,\n      value: undefined\n    });\n  };\n\n  // `Promise.prototype.then` method\n  // https://tc39.es/ecma262/#sec-promise.prototype.then\n  Internal.prototype = defineBuiltIn$6(PromisePrototype, 'then', function then(onFulfilled, onRejected) {\n    var state = getInternalPromiseState(this);\n    var reaction = newPromiseCapability$1(speciesConstructor$2(this, PromiseConstructor));\n    state.parent = true;\n    reaction.ok = isCallable$7(onFulfilled) ? onFulfilled : true;\n    reaction.fail = isCallable$7(onRejected) && onRejected;\n    reaction.domain = IS_NODE$1 ? process.domain : undefined;\n    if (state.state == PENDING) state.reactions.add(reaction);\n    else microtask(function () {\n      callReaction(reaction, state);\n    });\n    return reaction.promise;\n  });\n\n  OwnPromiseCapability = function () {\n    var promise = new Internal();\n    var state = getInternalPromiseState(promise);\n    this.promise = promise;\n    this.resolve = bind$3(internalResolve, state);\n    this.reject = bind$3(internalReject, state);\n  };\n\n  newPromiseCapabilityModule$3.f = newPromiseCapability$1 = function (C) {\n    return C === PromiseConstructor || C === PromiseWrapper\n      ? new OwnPromiseCapability(C)\n      : newGenericPromiseCapability(C);\n  };\n\n  if (isCallable$7(NativePromiseConstructor$2) && NativePromisePrototype$1 !== Object.prototype) {\n    nativeThen = NativePromisePrototype$1.then;\n\n    if (!NATIVE_PROMISE_SUBCLASSING) {\n      // make `Promise#then` return a polyfilled `Promise` for native promise-based APIs\n      defineBuiltIn$6(NativePromisePrototype$1, 'then', function then(onFulfilled, onRejected) {\n        var that = this;\n        return new PromiseConstructor(function (resolve, reject) {\n          call$f(nativeThen, that, resolve, reject);\n        }).then(onFulfilled, onRejected);\n      // https://github.com/zloirock/core-js/issues/640\n      }, { unsafe: true });\n    }\n\n    // make `.constructor === Promise` work for native promise-based APIs\n    try {\n      delete NativePromisePrototype$1.constructor;\n    } catch (error) { /* empty */ }\n\n    // make `instanceof Promise` work for native promise-based APIs\n    if (setPrototypeOf$5) {\n      setPrototypeOf$5(NativePromisePrototype$1, PromisePrototype);\n    }\n  }\n}\n\n$$e({ global: true, constructor: true, wrap: true, forced: FORCED_PROMISE_CONSTRUCTOR$4 }, {\n  Promise: PromiseConstructor\n});\n\nsetToStringTag$3(PromiseConstructor, PROMISE, false);\nsetSpecies$1(PROMISE);\n\nvar iterators = {};\n\nvar wellKnownSymbol$b = wellKnownSymbol$j;\nvar Iterators$4 = iterators;\n\nvar ITERATOR$5 = wellKnownSymbol$b('iterator');\nvar ArrayPrototype$1 = Array.prototype;\n\n// check on default Array iterator\nvar isArrayIteratorMethod$2 = function (it) {\n  return it !== undefined && (Iterators$4.Array === it || ArrayPrototype$1[ITERATOR$5] === it);\n};\n\nvar classof$7 = classof$9;\nvar getMethod$2 = getMethod$4;\nvar Iterators$3 = iterators;\nvar wellKnownSymbol$a = wellKnownSymbol$j;\n\nvar ITERATOR$4 = wellKnownSymbol$a('iterator');\n\nvar getIteratorMethod$3 = function (it) {\n  if (it != undefined) return getMethod$2(it, ITERATOR$4)\n    || getMethod$2(it, '@@iterator')\n    || Iterators$3[classof$7(it)];\n};\n\nvar call$e = functionCall;\nvar aCallable$4 = aCallable$9;\nvar anObject$9 = anObject$e;\nvar tryToString$2 = tryToString$5;\nvar getIteratorMethod$2 = getIteratorMethod$3;\n\nvar $TypeError$5 = TypeError;\n\nvar getIterator$2 = function (argument, usingIterator) {\n  var iteratorMethod = arguments.length < 2 ? getIteratorMethod$2(argument) : usingIterator;\n  if (aCallable$4(iteratorMethod)) return anObject$9(call$e(iteratorMethod, argument));\n  throw $TypeError$5(tryToString$2(argument) + ' is not iterable');\n};\n\nvar call$d = functionCall;\nvar anObject$8 = anObject$e;\nvar getMethod$1 = getMethod$4;\n\nvar iteratorClose$1 = function (iterator, kind, value) {\n  var innerResult, innerError;\n  anObject$8(iterator);\n  try {\n    innerResult = getMethod$1(iterator, 'return');\n    if (!innerResult) {\n      if (kind === 'throw') throw value;\n      return value;\n    }\n    innerResult = call$d(innerResult, iterator);\n  } catch (error) {\n    innerError = true;\n    innerResult = error;\n  }\n  if (kind === 'throw') throw value;\n  if (innerError) throw innerResult;\n  anObject$8(innerResult);\n  return value;\n};\n\nvar bind$2 = functionBindContext;\nvar call$c = functionCall;\nvar anObject$7 = anObject$e;\nvar tryToString$1 = tryToString$5;\nvar isArrayIteratorMethod$1 = isArrayIteratorMethod$2;\nvar lengthOfArrayLike$6 = lengthOfArrayLike$8;\nvar isPrototypeOf$2 = objectIsPrototypeOf;\nvar getIterator$1 = getIterator$2;\nvar getIteratorMethod$1 = getIteratorMethod$3;\nvar iteratorClose = iteratorClose$1;\n\nvar $TypeError$4 = TypeError;\n\nvar Result = function (stopped, result) {\n  this.stopped = stopped;\n  this.result = result;\n};\n\nvar ResultPrototype = Result.prototype;\n\nvar iterate$2 = function (iterable, unboundFunction, options) {\n  var that = options && options.that;\n  var AS_ENTRIES = !!(options && options.AS_ENTRIES);\n  var IS_ITERATOR = !!(options && options.IS_ITERATOR);\n  var INTERRUPTED = !!(options && options.INTERRUPTED);\n  var fn = bind$2(unboundFunction, that);\n  var iterator, iterFn, index, length, result, next, step;\n\n  var stop = function (condition) {\n    if (iterator) iteratorClose(iterator, 'normal', condition);\n    return new Result(true, condition);\n  };\n\n  var callFn = function (value) {\n    if (AS_ENTRIES) {\n      anObject$7(value);\n      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);\n    } return INTERRUPTED ? fn(value, stop) : fn(value);\n  };\n\n  if (IS_ITERATOR) {\n    iterator = iterable;\n  } else {\n    iterFn = getIteratorMethod$1(iterable);\n    if (!iterFn) throw $TypeError$4(tryToString$1(iterable) + ' is not iterable');\n    // optimisation for array iterators\n    if (isArrayIteratorMethod$1(iterFn)) {\n      for (index = 0, length = lengthOfArrayLike$6(iterable); length > index; index++) {\n        result = callFn(iterable[index]);\n        if (result && isPrototypeOf$2(ResultPrototype, result)) return result;\n      } return new Result(false);\n    }\n    iterator = getIterator$1(iterable, iterFn);\n  }\n\n  next = iterator.next;\n  while (!(step = call$c(next, iterator)).done) {\n    try {\n      result = callFn(step.value);\n    } catch (error) {\n      iteratorClose(iterator, 'throw', error);\n    }\n    if (typeof result == 'object' && result && isPrototypeOf$2(ResultPrototype, result)) return result;\n  } return new Result(false);\n};\n\nvar wellKnownSymbol$9 = wellKnownSymbol$j;\n\nvar ITERATOR$3 = wellKnownSymbol$9('iterator');\nvar SAFE_CLOSING = false;\n\ntry {\n  var called = 0;\n  var iteratorWithReturn = {\n    next: function () {\n      return { done: !!called++ };\n    },\n    'return': function () {\n      SAFE_CLOSING = true;\n    }\n  };\n  iteratorWithReturn[ITERATOR$3] = function () {\n    return this;\n  };\n  // eslint-disable-next-line es-x/no-array-from, no-throw-literal -- required for testing\n  Array.from(iteratorWithReturn, function () { throw 2; });\n} catch (error) { /* empty */ }\n\nvar checkCorrectnessOfIteration$2 = function (exec, SKIP_CLOSING) {\n  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;\n  var ITERATION_SUPPORT = false;\n  try {\n    var object = {};\n    object[ITERATOR$3] = function () {\n      return {\n        next: function () {\n          return { done: ITERATION_SUPPORT = true };\n        }\n      };\n    };\n    exec(object);\n  } catch (error) { /* empty */ }\n  return ITERATION_SUPPORT;\n};\n\nvar NativePromiseConstructor$1 = promiseNativeConstructor;\nvar checkCorrectnessOfIteration$1 = checkCorrectnessOfIteration$2;\nvar FORCED_PROMISE_CONSTRUCTOR$3 = promiseConstructorDetection.CONSTRUCTOR;\n\nvar promiseStaticsIncorrectIteration = FORCED_PROMISE_CONSTRUCTOR$3 || !checkCorrectnessOfIteration$1(function (iterable) {\n  NativePromiseConstructor$1.all(iterable).then(undefined, function () { /* empty */ });\n});\n\nvar $$d = _export;\nvar call$b = functionCall;\nvar aCallable$3 = aCallable$9;\nvar newPromiseCapabilityModule$2 = newPromiseCapability$2;\nvar perform$1 = perform$3;\nvar iterate$1 = iterate$2;\nvar PROMISE_STATICS_INCORRECT_ITERATION$1 = promiseStaticsIncorrectIteration;\n\n// `Promise.all` method\n// https://tc39.es/ecma262/#sec-promise.all\n$$d({ target: 'Promise', stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION$1 }, {\n  all: function all(iterable) {\n    var C = this;\n    var capability = newPromiseCapabilityModule$2.f(C);\n    var resolve = capability.resolve;\n    var reject = capability.reject;\n    var result = perform$1(function () {\n      var $promiseResolve = aCallable$3(C.resolve);\n      var values = [];\n      var counter = 0;\n      var remaining = 1;\n      iterate$1(iterable, function (promise) {\n        var index = counter++;\n        var alreadyCalled = false;\n        remaining++;\n        call$b($promiseResolve, C, promise).then(function (value) {\n          if (alreadyCalled) return;\n          alreadyCalled = true;\n          values[index] = value;\n          --remaining || resolve(values);\n        }, reject);\n      });\n      --remaining || resolve(values);\n    });\n    if (result.error) reject(result.value);\n    return capability.promise;\n  }\n});\n\nvar $$c = _export;\nvar FORCED_PROMISE_CONSTRUCTOR$2 = promiseConstructorDetection.CONSTRUCTOR;\nvar NativePromiseConstructor = promiseNativeConstructor;\nvar getBuiltIn$1 = getBuiltIn$8;\nvar isCallable$6 = isCallable$n;\nvar defineBuiltIn$5 = defineBuiltIn$8;\n\nvar NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;\n\n// `Promise.prototype.catch` method\n// https://tc39.es/ecma262/#sec-promise.prototype.catch\n$$c({ target: 'Promise', proto: true, forced: FORCED_PROMISE_CONSTRUCTOR$2, real: true }, {\n  'catch': function (onRejected) {\n    return this.then(undefined, onRejected);\n  }\n});\n\n// makes sure that native promise-based APIs `Promise#catch` properly works with patched `Promise#then`\nif (isCallable$6(NativePromiseConstructor)) {\n  var method = getBuiltIn$1('Promise').prototype['catch'];\n  if (NativePromisePrototype['catch'] !== method) {\n    defineBuiltIn$5(NativePromisePrototype, 'catch', method, { unsafe: true });\n  }\n}\n\nvar $$b = _export;\nvar call$a = functionCall;\nvar aCallable$2 = aCallable$9;\nvar newPromiseCapabilityModule$1 = newPromiseCapability$2;\nvar perform = perform$3;\nvar iterate = iterate$2;\nvar PROMISE_STATICS_INCORRECT_ITERATION = promiseStaticsIncorrectIteration;\n\n// `Promise.race` method\n// https://tc39.es/ecma262/#sec-promise.race\n$$b({ target: 'Promise', stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {\n  race: function race(iterable) {\n    var C = this;\n    var capability = newPromiseCapabilityModule$1.f(C);\n    var reject = capability.reject;\n    var result = perform(function () {\n      var $promiseResolve = aCallable$2(C.resolve);\n      iterate(iterable, function (promise) {\n        call$a($promiseResolve, C, promise).then(capability.resolve, reject);\n      });\n    });\n    if (result.error) reject(result.value);\n    return capability.promise;\n  }\n});\n\nvar $$a = _export;\nvar call$9 = functionCall;\nvar newPromiseCapabilityModule = newPromiseCapability$2;\nvar FORCED_PROMISE_CONSTRUCTOR$1 = promiseConstructorDetection.CONSTRUCTOR;\n\n// `Promise.reject` method\n// https://tc39.es/ecma262/#sec-promise.reject\n$$a({ target: 'Promise', stat: true, forced: FORCED_PROMISE_CONSTRUCTOR$1 }, {\n  reject: function reject(r) {\n    var capability = newPromiseCapabilityModule.f(this);\n    call$9(capability.reject, undefined, r);\n    return capability.promise;\n  }\n});\n\nvar anObject$6 = anObject$e;\nvar isObject$6 = isObject$d;\nvar newPromiseCapability = newPromiseCapability$2;\n\nvar promiseResolve$1 = function (C, x) {\n  anObject$6(C);\n  if (isObject$6(x) && x.constructor === C) return x;\n  var promiseCapability = newPromiseCapability.f(C);\n  var resolve = promiseCapability.resolve;\n  resolve(x);\n  return promiseCapability.promise;\n};\n\nvar $$9 = _export;\nvar getBuiltIn = getBuiltIn$8;\nvar FORCED_PROMISE_CONSTRUCTOR = promiseConstructorDetection.CONSTRUCTOR;\nvar promiseResolve = promiseResolve$1;\n\ngetBuiltIn('Promise');\n\n// `Promise.resolve` method\n// https://tc39.es/ecma262/#sec-promise.resolve\n$$9({ target: 'Promise', stat: true, forced: FORCED_PROMISE_CONSTRUCTOR }, {\n  resolve: function resolve(x) {\n    return promiseResolve(this, x);\n  }\n});\n\nclass WebStorageService {\n  getItem(key) {\n    return new Promise(resolve => {\n      const value = localStorage.getItem(key);\n      resolve(value);\n    });\n  }\n  setItem(key, value) {\n    return new Promise(resolve => {\n      localStorage.setItem(key, value);\n      resolve();\n    });\n  }\n  removeItem(key) {\n    return new Promise(resolve => {\n      localStorage.removeItem(key);\n      resolve();\n    });\n  }\n}\n\nvar objectDefineProperties = {};\n\nvar internalObjectKeys = objectKeysInternal;\nvar enumBugKeys$1 = enumBugKeys$3;\n\n// `Object.keys` method\n// https://tc39.es/ecma262/#sec-object.keys\n// eslint-disable-next-line es-x/no-object-keys -- safe\nvar objectKeys$2 = Object.keys || function keys(O) {\n  return internalObjectKeys(O, enumBugKeys$1);\n};\n\nvar DESCRIPTORS$5 = descriptors;\nvar V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;\nvar definePropertyModule$2 = objectDefineProperty;\nvar anObject$5 = anObject$e;\nvar toIndexedObject$2 = toIndexedObject$6;\nvar objectKeys$1 = objectKeys$2;\n\n// `Object.defineProperties` method\n// https://tc39.es/ecma262/#sec-object.defineproperties\n// eslint-disable-next-line es-x/no-object-defineproperties -- safe\nobjectDefineProperties.f = DESCRIPTORS$5 && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {\n  anObject$5(O);\n  var props = toIndexedObject$2(Properties);\n  var keys = objectKeys$1(Properties);\n  var length = keys.length;\n  var index = 0;\n  var key;\n  while (length > index) definePropertyModule$2.f(O, key = keys[index++], props[key]);\n  return O;\n};\n\n/* global ActiveXObject -- old IE, WSH */\n\nvar anObject$4 = anObject$e;\nvar definePropertiesModule = objectDefineProperties;\nvar enumBugKeys = enumBugKeys$3;\nvar hiddenKeys = hiddenKeys$4;\nvar html = html$2;\nvar documentCreateElement$1 = documentCreateElement$2;\nvar sharedKey$1 = sharedKey$3;\n\nvar GT = '>';\nvar LT = '<';\nvar PROTOTYPE$1 = 'prototype';\nvar SCRIPT = 'script';\nvar IE_PROTO$1 = sharedKey$1('IE_PROTO');\n\nvar EmptyConstructor = function () { /* empty */ };\n\nvar scriptTag = function (content) {\n  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;\n};\n\n// Create object with fake `null` prototype: use ActiveX Object with cleared prototype\nvar NullProtoObjectViaActiveX = function (activeXDocument) {\n  activeXDocument.write(scriptTag(''));\n  activeXDocument.close();\n  var temp = activeXDocument.parentWindow.Object;\n  activeXDocument = null; // avoid memory leak\n  return temp;\n};\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar NullProtoObjectViaIFrame = function () {\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = documentCreateElement$1('iframe');\n  var JS = 'java' + SCRIPT + ':';\n  var iframeDocument;\n  iframe.style.display = 'none';\n  html.appendChild(iframe);\n  // https://github.com/zloirock/core-js/issues/475\n  iframe.src = String(JS);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(scriptTag('document.F=Object'));\n  iframeDocument.close();\n  return iframeDocument.F;\n};\n\n// Check for document.domain and active x support\n// No need to use active x approach when document.domain is not set\n// see https://github.com/es-shims/es5-shim/issues/150\n// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346\n// avoid IE GC bug\nvar activeXDocument;\nvar NullProtoObject = function () {\n  try {\n    activeXDocument = new ActiveXObject('htmlfile');\n  } catch (error) { /* ignore */ }\n  NullProtoObject = typeof document != 'undefined'\n    ? document.domain && activeXDocument\n      ? NullProtoObjectViaActiveX(activeXDocument) // old IE\n      : NullProtoObjectViaIFrame()\n    : NullProtoObjectViaActiveX(activeXDocument); // WSH\n  var length = enumBugKeys.length;\n  while (length--) delete NullProtoObject[PROTOTYPE$1][enumBugKeys[length]];\n  return NullProtoObject();\n};\n\nhiddenKeys[IE_PROTO$1] = true;\n\n// `Object.create` method\n// https://tc39.es/ecma262/#sec-object.create\n// eslint-disable-next-line es-x/no-object-create -- safe\nvar objectCreate = Object.create || function create(O, Properties) {\n  var result;\n  if (O !== null) {\n    EmptyConstructor[PROTOTYPE$1] = anObject$4(O);\n    result = new EmptyConstructor();\n    EmptyConstructor[PROTOTYPE$1] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO$1] = O;\n  } else result = NullProtoObject();\n  return Properties === undefined ? result : definePropertiesModule.f(result, Properties);\n};\n\nvar wellKnownSymbol$8 = wellKnownSymbol$j;\nvar create$3 = objectCreate;\nvar defineProperty$4 = objectDefineProperty.f;\n\nvar UNSCOPABLES = wellKnownSymbol$8('unscopables');\nvar ArrayPrototype = Array.prototype;\n\n// Array.prototype[@@unscopables]\n// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\nif (ArrayPrototype[UNSCOPABLES] == undefined) {\n  defineProperty$4(ArrayPrototype, UNSCOPABLES, {\n    configurable: true,\n    value: create$3(null)\n  });\n}\n\n// add a key to Array.prototype[@@unscopables]\nvar addToUnscopables$2 = function (key) {\n  ArrayPrototype[UNSCOPABLES][key] = true;\n};\n\nvar fails$h = fails$s;\n\nvar correctPrototypeGetter = !fails$h(function () {\n  function F() { /* empty */ }\n  F.prototype.constructor = null;\n  // eslint-disable-next-line es-x/no-object-getprototypeof -- required for testing\n  return Object.getPrototypeOf(new F()) !== F.prototype;\n});\n\nvar hasOwn$2 = hasOwnProperty_1;\nvar isCallable$5 = isCallable$n;\nvar toObject$5 = toObject$7;\nvar sharedKey = sharedKey$3;\nvar CORRECT_PROTOTYPE_GETTER = correctPrototypeGetter;\n\nvar IE_PROTO = sharedKey('IE_PROTO');\nvar $Object = Object;\nvar ObjectPrototype$2 = $Object.prototype;\n\n// `Object.getPrototypeOf` method\n// https://tc39.es/ecma262/#sec-object.getprototypeof\n// eslint-disable-next-line es-x/no-object-getprototypeof -- safe\nvar objectGetPrototypeOf = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function (O) {\n  var object = toObject$5(O);\n  if (hasOwn$2(object, IE_PROTO)) return object[IE_PROTO];\n  var constructor = object.constructor;\n  if (isCallable$5(constructor) && object instanceof constructor) {\n    return constructor.prototype;\n  } return object instanceof $Object ? ObjectPrototype$2 : null;\n};\n\nvar fails$g = fails$s;\nvar isCallable$4 = isCallable$n;\nvar getPrototypeOf$3 = objectGetPrototypeOf;\nvar defineBuiltIn$4 = defineBuiltIn$8;\nvar wellKnownSymbol$7 = wellKnownSymbol$j;\n\nvar ITERATOR$2 = wellKnownSymbol$7('iterator');\nvar BUGGY_SAFARI_ITERATORS$1 = false;\n\n// `%IteratorPrototype%` object\n// https://tc39.es/ecma262/#sec-%iteratorprototype%-object\nvar IteratorPrototype$2, PrototypeOfArrayIteratorPrototype, arrayIterator;\n\n/* eslint-disable es-x/no-array-prototype-keys -- safe */\nif ([].keys) {\n  arrayIterator = [].keys();\n  // Safari 8 has buggy iterators w/o `next`\n  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS$1 = true;\n  else {\n    PrototypeOfArrayIteratorPrototype = getPrototypeOf$3(getPrototypeOf$3(arrayIterator));\n    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype$2 = PrototypeOfArrayIteratorPrototype;\n  }\n}\n\nvar NEW_ITERATOR_PROTOTYPE = IteratorPrototype$2 == undefined || fails$g(function () {\n  var test = {};\n  // FF44- legacy iterators case\n  return IteratorPrototype$2[ITERATOR$2].call(test) !== test;\n});\n\nif (NEW_ITERATOR_PROTOTYPE) IteratorPrototype$2 = {};\n\n// `%IteratorPrototype%[@@iterator]()` method\n// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator\nif (!isCallable$4(IteratorPrototype$2[ITERATOR$2])) {\n  defineBuiltIn$4(IteratorPrototype$2, ITERATOR$2, function () {\n    return this;\n  });\n}\n\nvar iteratorsCore = {\n  IteratorPrototype: IteratorPrototype$2,\n  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1\n};\n\nvar IteratorPrototype$1 = iteratorsCore.IteratorPrototype;\nvar create$2 = objectCreate;\nvar createPropertyDescriptor$2 = createPropertyDescriptor$5;\nvar setToStringTag$2 = setToStringTag$4;\nvar Iterators$2 = iterators;\n\nvar returnThis$1 = function () { return this; };\n\nvar createIteratorConstructor$1 = function (IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {\n  var TO_STRING_TAG = NAME + ' Iterator';\n  IteratorConstructor.prototype = create$2(IteratorPrototype$1, { next: createPropertyDescriptor$2(+!ENUMERABLE_NEXT, next) });\n  setToStringTag$2(IteratorConstructor, TO_STRING_TAG, false);\n  Iterators$2[TO_STRING_TAG] = returnThis$1;\n  return IteratorConstructor;\n};\n\nvar $$8 = _export;\nvar call$8 = functionCall;\nvar FunctionName$1 = functionName;\nvar isCallable$3 = isCallable$n;\nvar createIteratorConstructor = createIteratorConstructor$1;\nvar getPrototypeOf$2 = objectGetPrototypeOf;\nvar setPrototypeOf$4 = objectSetPrototypeOf;\nvar setToStringTag$1 = setToStringTag$4;\nvar createNonEnumerableProperty$5 = createNonEnumerableProperty$8;\nvar defineBuiltIn$3 = defineBuiltIn$8;\nvar wellKnownSymbol$6 = wellKnownSymbol$j;\nvar Iterators$1 = iterators;\nvar IteratorsCore = iteratorsCore;\n\nvar PROPER_FUNCTION_NAME$2 = FunctionName$1.PROPER;\nvar CONFIGURABLE_FUNCTION_NAME$1 = FunctionName$1.CONFIGURABLE;\nvar IteratorPrototype = IteratorsCore.IteratorPrototype;\nvar BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;\nvar ITERATOR$1 = wellKnownSymbol$6('iterator');\nvar KEYS = 'keys';\nvar VALUES = 'values';\nvar ENTRIES = 'entries';\n\nvar returnThis = function () { return this; };\n\nvar defineIterator$1 = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {\n  createIteratorConstructor(IteratorConstructor, NAME, next);\n\n  var getIterationMethod = function (KIND) {\n    if (KIND === DEFAULT && defaultIterator) return defaultIterator;\n    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];\n    switch (KIND) {\n      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };\n      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };\n      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };\n    } return function () { return new IteratorConstructor(this); };\n  };\n\n  var TO_STRING_TAG = NAME + ' Iterator';\n  var INCORRECT_VALUES_NAME = false;\n  var IterablePrototype = Iterable.prototype;\n  var nativeIterator = IterablePrototype[ITERATOR$1]\n    || IterablePrototype['@@iterator']\n    || DEFAULT && IterablePrototype[DEFAULT];\n  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);\n  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;\n  var CurrentIteratorPrototype, methods, KEY;\n\n  // fix native\n  if (anyNativeIterator) {\n    CurrentIteratorPrototype = getPrototypeOf$2(anyNativeIterator.call(new Iterable()));\n    if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {\n      if (getPrototypeOf$2(CurrentIteratorPrototype) !== IteratorPrototype) {\n        if (setPrototypeOf$4) {\n          setPrototypeOf$4(CurrentIteratorPrototype, IteratorPrototype);\n        } else if (!isCallable$3(CurrentIteratorPrototype[ITERATOR$1])) {\n          defineBuiltIn$3(CurrentIteratorPrototype, ITERATOR$1, returnThis);\n        }\n      }\n      // Set @@toStringTag to native iterators\n      setToStringTag$1(CurrentIteratorPrototype, TO_STRING_TAG, true);\n    }\n  }\n\n  // fix Array.prototype.{ values, @@iterator }.name in V8 / FF\n  if (PROPER_FUNCTION_NAME$2 && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {\n    if (CONFIGURABLE_FUNCTION_NAME$1) {\n      createNonEnumerableProperty$5(IterablePrototype, 'name', VALUES);\n    } else {\n      INCORRECT_VALUES_NAME = true;\n      defaultIterator = function values() { return call$8(nativeIterator, this); };\n    }\n  }\n\n  // export additional methods\n  if (DEFAULT) {\n    methods = {\n      values: getIterationMethod(VALUES),\n      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),\n      entries: getIterationMethod(ENTRIES)\n    };\n    if (FORCED) for (KEY in methods) {\n      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {\n        defineBuiltIn$3(IterablePrototype, KEY, methods[KEY]);\n      }\n    } else $$8({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);\n  }\n\n  // define iterator\n  if (IterablePrototype[ITERATOR$1] !== defaultIterator) {\n    defineBuiltIn$3(IterablePrototype, ITERATOR$1, defaultIterator, { name: DEFAULT });\n  }\n  Iterators$1[NAME] = defaultIterator;\n\n  return methods;\n};\n\nvar toIndexedObject$1 = toIndexedObject$6;\nvar addToUnscopables$1 = addToUnscopables$2;\nvar Iterators = iterators;\nvar InternalStateModule$3 = internalState;\nvar defineProperty$3 = objectDefineProperty.f;\nvar defineIterator = defineIterator$1;\nvar DESCRIPTORS$4 = descriptors;\n\nvar ARRAY_ITERATOR = 'Array Iterator';\nvar setInternalState$2 = InternalStateModule$3.set;\nvar getInternalState$4 = InternalStateModule$3.getterFor(ARRAY_ITERATOR);\n\n// `Array.prototype.entries` method\n// https://tc39.es/ecma262/#sec-array.prototype.entries\n// `Array.prototype.keys` method\n// https://tc39.es/ecma262/#sec-array.prototype.keys\n// `Array.prototype.values` method\n// https://tc39.es/ecma262/#sec-array.prototype.values\n// `Array.prototype[@@iterator]` method\n// https://tc39.es/ecma262/#sec-array.prototype-@@iterator\n// `CreateArrayIterator` internal method\n// https://tc39.es/ecma262/#sec-createarrayiterator\nvar es_array_iterator = defineIterator(Array, 'Array', function (iterated, kind) {\n  setInternalState$2(this, {\n    type: ARRAY_ITERATOR,\n    target: toIndexedObject$1(iterated), // target\n    index: 0,                          // next index\n    kind: kind                         // kind\n  });\n// `%ArrayIteratorPrototype%.next` method\n// https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next\n}, function () {\n  var state = getInternalState$4(this);\n  var target = state.target;\n  var kind = state.kind;\n  var index = state.index++;\n  if (!target || index >= target.length) {\n    state.target = undefined;\n    return { value: undefined, done: true };\n  }\n  if (kind == 'keys') return { value: index, done: false };\n  if (kind == 'values') return { value: target[index], done: false };\n  return { value: [index, target[index]], done: false };\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values%\n// https://tc39.es/ecma262/#sec-createunmappedargumentsobject\n// https://tc39.es/ecma262/#sec-createmappedargumentsobject\nvar values = Iterators.Arguments = Iterators.Array;\n\n// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\naddToUnscopables$1('keys');\naddToUnscopables$1('values');\naddToUnscopables$1('entries');\n\n// V8 ~ Chrome 45- bug\nif (DESCRIPTORS$4 && values.name !== 'values') try {\n  defineProperty$3(values, 'name', { value: 'values' });\n} catch (error) { /* empty */ }\n\n// iterable DOM collections\n// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods\nvar domIterables = {\n  CSSRuleList: 0,\n  CSSStyleDeclaration: 0,\n  CSSValueList: 0,\n  ClientRectList: 0,\n  DOMRectList: 0,\n  DOMStringList: 0,\n  DOMTokenList: 1,\n  DataTransferItemList: 0,\n  FileList: 0,\n  HTMLAllCollection: 0,\n  HTMLCollection: 0,\n  HTMLFormElement: 0,\n  HTMLSelectElement: 0,\n  MediaList: 0,\n  MimeTypeArray: 0,\n  NamedNodeMap: 0,\n  NodeList: 1,\n  PaintRequestList: 0,\n  Plugin: 0,\n  PluginArray: 0,\n  SVGLengthList: 0,\n  SVGNumberList: 0,\n  SVGPathSegList: 0,\n  SVGPointList: 0,\n  SVGStringList: 0,\n  SVGTransformList: 0,\n  SourceBufferList: 0,\n  StyleSheetList: 0,\n  TextTrackCueList: 0,\n  TextTrackList: 0,\n  TouchList: 0\n};\n\n// in old WebKit versions, `element.classList` is not an instance of global `DOMTokenList`\nvar documentCreateElement = documentCreateElement$2;\n\nvar classList = documentCreateElement('span').classList;\nvar DOMTokenListPrototype$1 = classList && classList.constructor && classList.constructor.prototype;\n\nvar domTokenListPrototype = DOMTokenListPrototype$1 === Object.prototype ? undefined : DOMTokenListPrototype$1;\n\nvar global$b = global$t;\nvar DOMIterables = domIterables;\nvar DOMTokenListPrototype = domTokenListPrototype;\nvar ArrayIteratorMethods = es_array_iterator;\nvar createNonEnumerableProperty$4 = createNonEnumerableProperty$8;\nvar wellKnownSymbol$5 = wellKnownSymbol$j;\n\nvar ITERATOR = wellKnownSymbol$5('iterator');\nvar TO_STRING_TAG$1 = wellKnownSymbol$5('toStringTag');\nvar ArrayValues = ArrayIteratorMethods.values;\n\nvar handlePrototype = function (CollectionPrototype, COLLECTION_NAME) {\n  if (CollectionPrototype) {\n    // some Chrome versions have non-configurable methods on DOMTokenList\n    if (CollectionPrototype[ITERATOR] !== ArrayValues) try {\n      createNonEnumerableProperty$4(CollectionPrototype, ITERATOR, ArrayValues);\n    } catch (error) {\n      CollectionPrototype[ITERATOR] = ArrayValues;\n    }\n    if (!CollectionPrototype[TO_STRING_TAG$1]) {\n      createNonEnumerableProperty$4(CollectionPrototype, TO_STRING_TAG$1, COLLECTION_NAME);\n    }\n    if (DOMIterables[COLLECTION_NAME]) for (var METHOD_NAME in ArrayIteratorMethods) {\n      // some Chrome versions have non-configurable methods on DOMTokenList\n      if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {\n        createNonEnumerableProperty$4(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);\n      } catch (error) {\n        CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];\n      }\n    }\n  }\n};\n\nfor (var COLLECTION_NAME in DOMIterables) {\n  handlePrototype(global$b[COLLECTION_NAME] && global$b[COLLECTION_NAME].prototype, COLLECTION_NAME);\n}\n\nhandlePrototype(DOMTokenListPrototype, 'DOMTokenList');\n\nclass Logger {\n  constructor(namespace) {\n    this.namespace = namespace;\n  }\n  emit(method, ...params) {\n    if (!Logger.debug) {\n      return;\n    }\n    if (this.namespace && method !== \"error\") {\n      // eslint-disable-next-line no-console\n      console[method](this.namespace, ...params);\n      return;\n    }\n    // eslint-disable-next-line no-console\n    console[method](...params);\n  }\n  log(...params) {\n    this.emit(\"log\", ...params);\n  }\n  info(...params) {\n    this.emit(\"info\", ...params);\n  }\n  warn(...params) {\n    this.emit(\"warn\", ...params);\n  }\n  error(...params) {\n    this.emit(\"error\", ...params);\n  }\n}\nLogger.debug = false;\nconst logger = new Logger();\n\nvar $$7 = _export;\nvar $includes = arrayIncludes.includes;\nvar fails$f = fails$s;\nvar addToUnscopables = addToUnscopables$2;\n\n// FF99+ bug\nvar BROKEN_ON_SPARSE = fails$f(function () {\n  return !Array(1).includes();\n});\n\n// `Array.prototype.includes` method\n// https://tc39.es/ecma262/#sec-array.prototype.includes\n$$7({ target: 'Array', proto: true, forced: BROKEN_ON_SPARSE }, {\n  includes: function includes(el /* , fromIndex = 0 */) {\n    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n\n// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\naddToUnscopables('includes');\n\nvar isObject$5 = isObject$d;\nvar classof$6 = classofRaw$1;\nvar wellKnownSymbol$4 = wellKnownSymbol$j;\n\nvar MATCH$1 = wellKnownSymbol$4('match');\n\n// `IsRegExp` abstract operation\n// https://tc39.es/ecma262/#sec-isregexp\nvar isRegexp = function (it) {\n  var isRegExp;\n  return isObject$5(it) && ((isRegExp = it[MATCH$1]) !== undefined ? !!isRegExp : classof$6(it) == 'RegExp');\n};\n\nvar isRegExp$1 = isRegexp;\n\nvar $TypeError$3 = TypeError;\n\nvar notARegexp = function (it) {\n  if (isRegExp$1(it)) {\n    throw $TypeError$3(\"The method doesn't accept regular expressions\");\n  } return it;\n};\n\nvar classof$5 = classof$9;\n\nvar $String = String;\n\nvar toString$5 = function (argument) {\n  if (classof$5(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');\n  return $String(argument);\n};\n\nvar wellKnownSymbol$3 = wellKnownSymbol$j;\n\nvar MATCH = wellKnownSymbol$3('match');\n\nvar correctIsRegexpLogic = function (METHOD_NAME) {\n  var regexp = /./;\n  try {\n    '/./'[METHOD_NAME](regexp);\n  } catch (error1) {\n    try {\n      regexp[MATCH] = false;\n      return '/./'[METHOD_NAME](regexp);\n    } catch (error2) { /* empty */ }\n  } return false;\n};\n\nvar $$6 = _export;\nvar uncurryThis$b = functionUncurryThis;\nvar notARegExp = notARegexp;\nvar requireObjectCoercible$3 = requireObjectCoercible$6;\nvar toString$4 = toString$5;\nvar correctIsRegExpLogic = correctIsRegexpLogic;\n\nvar stringIndexOf = uncurryThis$b(''.indexOf);\n\n// `String.prototype.includes` method\n// https://tc39.es/ecma262/#sec-string.prototype.includes\n$$6({ target: 'String', proto: true, forced: !correctIsRegExpLogic('includes') }, {\n  includes: function includes(searchString /* , position = 0 */) {\n    return !!~stringIndexOf(\n      toString$4(requireObjectCoercible$3(this)),\n      toString$4(notARegExp(searchString)),\n      arguments.length > 1 ? arguments[1] : undefined\n    );\n  }\n});\n\n// a string of all valid unicode whitespaces\nvar whitespaces$2 = '\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u2000\\u2001\\u2002' +\n  '\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF';\n\nvar uncurryThis$a = functionUncurryThis;\nvar requireObjectCoercible$2 = requireObjectCoercible$6;\nvar toString$3 = toString$5;\nvar whitespaces$1 = whitespaces$2;\n\nvar replace$1 = uncurryThis$a(''.replace);\nvar whitespace = '[' + whitespaces$1 + ']';\nvar ltrim = RegExp('^' + whitespace + whitespace + '*');\nvar rtrim = RegExp(whitespace + whitespace + '*$');\n\n// `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation\nvar createMethod$3 = function (TYPE) {\n  return function ($this) {\n    var string = toString$3(requireObjectCoercible$2($this));\n    if (TYPE & 1) string = replace$1(string, ltrim, '');\n    if (TYPE & 2) string = replace$1(string, rtrim, '');\n    return string;\n  };\n};\n\nvar stringTrim = {\n  // `String.prototype.{ trimLeft, trimStart }` methods\n  // https://tc39.es/ecma262/#sec-string.prototype.trimstart\n  start: createMethod$3(1),\n  // `String.prototype.{ trimRight, trimEnd }` methods\n  // https://tc39.es/ecma262/#sec-string.prototype.trimend\n  end: createMethod$3(2),\n  // `String.prototype.trim` method\n  // https://tc39.es/ecma262/#sec-string.prototype.trim\n  trim: createMethod$3(3)\n};\n\nvar PROPER_FUNCTION_NAME$1 = functionName.PROPER;\nvar fails$e = fails$s;\nvar whitespaces = whitespaces$2;\n\nvar non = '\\u200B\\u0085\\u180E';\n\n// check that a method works with the correct list\n// of whitespaces and has a correct name\nvar stringTrimForced = function (METHOD_NAME) {\n  return fails$e(function () {\n    return !!whitespaces[METHOD_NAME]()\n      || non[METHOD_NAME]() !== non\n      || (PROPER_FUNCTION_NAME$1 && whitespaces[METHOD_NAME].name !== METHOD_NAME);\n  });\n};\n\nvar $$5 = _export;\nvar $trim = stringTrim.trim;\nvar forcedStringTrimMethod = stringTrimForced;\n\n// `String.prototype.trim` method\n// https://tc39.es/ecma262/#sec-string.prototype.trim\n$$5({ target: 'String', proto: true, forced: forcedStringTrimMethod('trim') }, {\n  trim: function trim() {\n    return $trim(this);\n  }\n});\n\nvar DESCRIPTORS$3 = descriptors;\nvar uncurryThis$9 = functionUncurryThis;\nvar call$7 = functionCall;\nvar fails$d = fails$s;\nvar objectKeys = objectKeys$2;\nvar getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;\nvar propertyIsEnumerableModule = objectPropertyIsEnumerable;\nvar toObject$4 = toObject$7;\nvar IndexedObject$2 = indexedObject;\n\n// eslint-disable-next-line es-x/no-object-assign -- safe\nvar $assign = Object.assign;\n// eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\nvar defineProperty$2 = Object.defineProperty;\nvar concat = uncurryThis$9([].concat);\n\n// `Object.assign` method\n// https://tc39.es/ecma262/#sec-object.assign\nvar objectAssign = !$assign || fails$d(function () {\n  // should have correct order of operations (Edge bug)\n  if (DESCRIPTORS$3 && $assign({ b: 1 }, $assign(defineProperty$2({}, 'a', {\n    enumerable: true,\n    get: function () {\n      defineProperty$2(this, 'b', {\n        value: 3,\n        enumerable: false\n      });\n    }\n  }), { b: 2 })).b !== 1) return true;\n  // should work with symbols and should have deterministic property order (V8 bug)\n  var A = {};\n  var B = {};\n  // eslint-disable-next-line es-x/no-symbol -- safe\n  var symbol = Symbol();\n  var alphabet = 'abcdefghijklmnopqrst';\n  A[symbol] = 7;\n  alphabet.split('').forEach(function (chr) { B[chr] = chr; });\n  return $assign({}, A)[symbol] != 7 || objectKeys($assign({}, B)).join('') != alphabet;\n}) ? function assign(target, source) { // eslint-disable-line no-unused-vars -- required for `.length`\n  var T = toObject$4(target);\n  var argumentsLength = arguments.length;\n  var index = 1;\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n  var propertyIsEnumerable = propertyIsEnumerableModule.f;\n  while (argumentsLength > index) {\n    var S = IndexedObject$2(arguments[index++]);\n    var keys = getOwnPropertySymbols ? concat(objectKeys(S), getOwnPropertySymbols(S)) : objectKeys(S);\n    var length = keys.length;\n    var j = 0;\n    var key;\n    while (length > j) {\n      key = keys[j++];\n      if (!DESCRIPTORS$3 || call$7(propertyIsEnumerable, S, key)) T[key] = S[key];\n    }\n  } return T;\n} : $assign;\n\nvar $$4 = _export;\nvar assign = objectAssign;\n\n// `Object.assign` method\n// https://tc39.es/ecma262/#sec-object.assign\n// eslint-disable-next-line es-x/no-object-assign -- required for testing\n$$4({ target: 'Object', stat: true, arity: 2, forced: Object.assign !== assign }, {\n  assign: assign\n});\n\nclass EventEmitter {\n  constructor() {\n    this.emitter = new events__WEBPACK_IMPORTED_MODULE_1__.EventEmitter();\n  }\n  on(eventName, callback) {\n    this.emitter.on(eventName, callback);\n    return {\n      remove: () => this.emitter.off(eventName, callback)\n    };\n  }\n  off(eventName, callback) {\n    this.emitter.off(eventName, callback);\n  }\n  emit(eventName, event) {\n    this.emitter.emit(eventName, event);\n  }\n}\n\nconst PACKAGE_NAME = \"near-wallet-selector\";\nconst RECENTLY_SIGNED_IN_WALLETS = \"recentlySignedInWallets\";\nconst CONTRACT = \"contract\";\nconst PENDING_CONTRACT = \"contract:pending\";\nconst SELECTED_WALLET_ID = `selectedWalletId`;\nconst PENDING_SELECTED_WALLET_ID = `selectedWalletId:pending`;\n\nclass WalletModules {\n  constructor({\n    factories,\n    storage,\n    options,\n    store,\n    emitter,\n    provider\n  }) {\n    this.factories = factories;\n    this.storage = storage;\n    this.options = options;\n    this.store = store;\n    this.emitter = emitter;\n    this.provider = provider;\n    this.modules = [];\n    this.instances = {};\n  }\n  validateWallet(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let accounts = [];\n      const wallet = yield this.getWallet(id);\n      if (wallet) {\n        // Ensure our persistent state aligns with the selected wallet.\n        // For example a wallet is selected, but it returns no accounts (not signed in).\n        accounts = yield wallet.getAccounts().catch(err => {\n          logger.log(`Failed to validate ${wallet.id} during setup`);\n          logger.error(err);\n          return [];\n        });\n      }\n      return accounts;\n    });\n  }\n  resolveStorageState() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const jsonStorage = new JsonStorage(this.storage, PACKAGE_NAME);\n      const pendingSelectedWalletId = yield jsonStorage.getItem(PENDING_SELECTED_WALLET_ID);\n      const pendingContract = yield jsonStorage.getItem(PENDING_CONTRACT);\n      if (pendingSelectedWalletId && pendingContract) {\n        const _accounts = yield this.validateWallet(pendingSelectedWalletId);\n        yield jsonStorage.removeItem(PENDING_SELECTED_WALLET_ID);\n        yield jsonStorage.removeItem(PENDING_CONTRACT);\n        if (_accounts.length) {\n          const {\n            selectedWalletId: _selectedWalletId\n          } = this.store.getState();\n          const selectedWallet = yield this.getWallet(_selectedWalletId);\n          if (selectedWallet && pendingSelectedWalletId !== _selectedWalletId) {\n            yield selectedWallet.signOut().catch(err => {\n              logger.log(\"Failed to sign out existing wallet\");\n              logger.error(err);\n            });\n          }\n          const recentlySignedInWalletsFromPending = yield this.setWalletAsRecentlySignedIn(pendingSelectedWalletId);\n          return {\n            accounts: _accounts,\n            contract: pendingContract,\n            selectedWalletId: pendingSelectedWalletId,\n            recentlySignedInWallets: recentlySignedInWalletsFromPending\n          };\n        }\n      }\n      const {\n        contract,\n        selectedWalletId\n      } = this.store.getState();\n      const accounts = yield this.validateWallet(selectedWalletId);\n      const recentlySignedInWallets = yield jsonStorage.getItem(RECENTLY_SIGNED_IN_WALLETS);\n      if (!accounts.length) {\n        return {\n          accounts: [],\n          contract: null,\n          selectedWalletId: null,\n          recentlySignedInWallets: recentlySignedInWallets || []\n        };\n      }\n      return {\n        accounts,\n        contract,\n        selectedWalletId,\n        recentlySignedInWallets: recentlySignedInWallets || []\n      };\n    });\n  }\n  setWalletAsRecentlySignedIn(walletId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const jsonStorage = new JsonStorage(this.storage, PACKAGE_NAME);\n      let recentlySignedInWallets = yield jsonStorage.getItem(RECENTLY_SIGNED_IN_WALLETS);\n      if (!recentlySignedInWallets) {\n        recentlySignedInWallets = [];\n      }\n      if (!recentlySignedInWallets.includes(walletId)) {\n        recentlySignedInWallets.unshift(walletId);\n        recentlySignedInWallets = recentlySignedInWallets.slice(0, 5);\n        yield jsonStorage.setItem(RECENTLY_SIGNED_IN_WALLETS, recentlySignedInWallets);\n      }\n      return recentlySignedInWallets;\n    });\n  }\n  signOutWallet(walletId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const wallet = yield this.getWallet(walletId);\n      yield wallet.signOut().catch(err => {\n        logger.log(`Failed to sign out ${wallet.id}`);\n        logger.error(err);\n        // At least clean up state on our side.\n        this.onWalletSignedOut(wallet.id);\n      });\n    });\n  }\n  onWalletSignedIn(walletId, {\n    accounts,\n    contractId,\n    methodNames\n  }) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        selectedWalletId\n      } = this.store.getState();\n      const jsonStorage = new JsonStorage(this.storage, PACKAGE_NAME);\n      const contract = {\n        contractId,\n        methodNames\n      };\n      if (!accounts.length) {\n        const module = this.getModule(walletId);\n        // We can't guarantee the user will actually sign in with browser wallets.\n        // Best we can do is set in storage and validate on init.\n        if (module.type === \"browser\") {\n          yield jsonStorage.setItem(PENDING_SELECTED_WALLET_ID, walletId);\n          yield jsonStorage.setItem(PENDING_CONTRACT, contract);\n        }\n        return;\n      }\n      if (selectedWalletId && selectedWalletId !== walletId) {\n        yield this.signOutWallet(selectedWalletId);\n      }\n      const recentlySignedInWallets = yield this.setWalletAsRecentlySignedIn(walletId);\n      this.store.dispatch({\n        type: \"WALLET_CONNECTED\",\n        payload: {\n          walletId,\n          contract,\n          accounts,\n          recentlySignedInWallets\n        }\n      });\n      this.emitter.emit(\"signedIn\", {\n        walletId,\n        contractId,\n        methodNames,\n        accounts\n      });\n    });\n  }\n  onWalletSignedOut(walletId) {\n    this.store.dispatch({\n      type: \"WALLET_DISCONNECTED\",\n      payload: {\n        walletId\n      }\n    });\n    this.emitter.emit(\"signedOut\", {\n      walletId\n    });\n  }\n  setupWalletEmitter(module) {\n    const emitter = new EventEmitter();\n    emitter.on(\"signedOut\", () => {\n      this.onWalletSignedOut(module.id);\n    });\n    emitter.on(\"signedIn\", event => {\n      this.onWalletSignedIn(module.id, event);\n    });\n    emitter.on(\"accountsChanged\", ({\n      accounts\n    }) => __awaiter(this, void 0, void 0, function* () {\n      this.emitter.emit(\"accountsChanged\", {\n        walletId: module.id,\n        accounts\n      });\n      if (!accounts.length) {\n        return this.signOutWallet(module.id);\n      }\n      this.store.dispatch({\n        type: \"ACCOUNTS_CHANGED\",\n        payload: {\n          walletId: module.id,\n          accounts\n        }\n      });\n    }));\n    emitter.on(\"networkChanged\", ({\n      networkId\n    }) => {\n      this.emitter.emit(\"networkChanged\", {\n        walletId: module.id,\n        networkId\n      });\n    });\n    emitter.on(\"uriChanged\", ({\n      uri\n    }) => {\n      this.emitter.emit(\"uriChanged\", {\n        walletId: module.id,\n        uri\n      });\n    });\n    return emitter;\n  }\n  validateSignMessageParams({\n    message,\n    nonce,\n    recipient\n  }) {\n    if (!message || message.trim() === \"\") {\n      throw new Error(\"Invalid message. It must be a non-empty string.\");\n    }\n    if (!Buffer.isBuffer(nonce) || nonce.length !== 32) {\n      throw new Error(\"Invalid nonce. It must be a Buffer with a length of 32 bytes.\");\n    }\n    if (!recipient || recipient.trim() === \"\") {\n      throw new Error(\"Invalid recipient. It must be a non-empty string.\");\n    }\n  }\n  decorateWallet(wallet) {\n    const _signIn = wallet.signIn;\n    const _signOut = wallet.signOut;\n    const _signMessage = wallet.signMessage;\n    wallet.signIn = params => __awaiter(this, void 0, void 0, function* () {\n      const accounts = yield _signIn(params);\n      const {\n        contractId,\n        methodNames = []\n      } = params;\n      yield this.onWalletSignedIn(wallet.id, {\n        accounts,\n        contractId,\n        methodNames\n      });\n      return accounts;\n    });\n    wallet.signOut = () => __awaiter(this, void 0, void 0, function* () {\n      yield _signOut();\n      this.onWalletSignedOut(wallet.id);\n    });\n    wallet.signMessage = params => __awaiter(this, void 0, void 0, function* () {\n      if (_signMessage === undefined) {\n        throw Error(`The signMessage method is not supported by ${wallet.metadata.name}`);\n      }\n      this.validateSignMessageParams(params);\n      return yield _signMessage(params);\n    });\n    return wallet;\n  }\n  setupInstance(module) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!module.metadata.available) {\n        const message = module.type === \"injected\" ? \"not installed\" : \"not available\";\n        throw Error(`${module.metadata.name} is ${message}`);\n      }\n      const wallet = Object.assign({\n        id: module.id,\n        type: module.type,\n        metadata: module.metadata\n      }, yield module.init({\n        id: module.id,\n        type: module.type,\n        metadata: module.metadata,\n        options: this.options,\n        store: this.store.toReadOnly(),\n        provider: this.provider,\n        emitter: this.setupWalletEmitter(module),\n        logger: new Logger(module.id),\n        storage: new JsonStorage(this.storage, [PACKAGE_NAME, module.id])\n      }));\n      return this.decorateWallet(wallet);\n    });\n  }\n  getModule(id) {\n    return this.modules.find(x => x.id === id);\n  }\n  getWallet(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const module = this.getModule(id);\n      if (!module) {\n        return null;\n      }\n      const {\n        selectedWalletId\n      } = this.store.getState();\n      // If user uninstalled/removed a wallet which was previously signed in with\n      // best we can do is clean up state on our side.\n      if (!module.metadata.available && selectedWalletId) {\n        this.onWalletSignedOut(selectedWalletId);\n        return null;\n      }\n      return yield module.wallet();\n    });\n  }\n  setup() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const modules = [];\n      for (let i = 0; i < this.factories.length; i += 1) {\n        const module = yield this.factories[i]({\n          options: this.options\n        }).catch(err => {\n          logger.log(\"Failed to setup module\");\n          logger.error(err);\n          return null;\n        });\n        // Filter out wallets that aren't available.\n        if (!module) {\n          continue;\n        }\n        // Skip duplicated module.\n        if (modules.some(x => x.id === module.id)) {\n          continue;\n        }\n        modules.push({\n          id: module.id,\n          type: module.type,\n          metadata: module.metadata,\n          wallet: () => __awaiter(this, void 0, void 0, function* () {\n            let instance = this.instances[module.id];\n            if (instance) {\n              return instance;\n            }\n            instance = yield this.setupInstance(module);\n            this.instances[module.id] = instance;\n            return instance;\n          })\n        });\n      }\n      this.modules = modules;\n      const {\n        accounts,\n        contract,\n        selectedWalletId,\n        recentlySignedInWallets\n      } = yield this.resolveStorageState();\n      this.store.dispatch({\n        type: \"SETUP_WALLET_MODULES\",\n        payload: {\n          modules,\n          accounts,\n          contract,\n          selectedWalletId,\n          recentlySignedInWallets\n        }\n      });\n      for (let i = 0; i < this.modules.length; i++) {\n        if (this.modules[i].type !== \"instant-link\") {\n          continue;\n        }\n        const wallet = yield this.modules[i].wallet();\n        if (!wallet.metadata.runOnStartup) {\n          continue;\n        }\n        try {\n          yield wallet.signIn({\n            contractId: wallet.getContractId()\n          });\n        } catch (err) {\n          logger.error(\"Failed to sign in to wallet. \" + err);\n        }\n      }\n    });\n  }\n}\n\nconst getNetworkPreset = networkId => {\n  switch (networkId) {\n    case \"mainnet\":\n      return {\n        networkId,\n        nodeUrl: \"https://rpc.mainnet.near.org\",\n        helperUrl: \"https://helper.mainnet.near.org\",\n        explorerUrl: \"https://nearblocks.io\",\n        indexerUrl: \"https://api.kitwallet.app\"\n      };\n    case \"testnet\":\n      return {\n        networkId,\n        nodeUrl: \"https://rpc.testnet.near.org\",\n        helperUrl: \"https://helper.testnet.near.org\",\n        explorerUrl: \"https://testnet.nearblocks.io\",\n        indexerUrl: \"https://testnet-api.kitwallet.app\"\n      };\n    default:\n      throw Error(`Failed to find config for: '${networkId}'`);\n  }\n};\nconst resolveNetwork = network => {\n  return typeof network === \"string\" ? getNetworkPreset(network) : network;\n};\nconst resolveOptions = params => {\n  const options = {\n    languageCode: params.languageCode || undefined,\n    network: resolveNetwork(params.network),\n    debug: params.debug || false,\n    optimizeWalletOrder: params.optimizeWalletOrder === false ? false : true,\n    randomizeWalletOrder: params.randomizeWalletOrder || false,\n    relayerUrl: params.relayerUrl || undefined\n  };\n  return {\n    options,\n    storage: params.storage || new WebStorageService()\n  };\n};\n\nconst reducer = (state, action) => {\n  logger.log(\"Store Action\", action);\n  switch (action.type) {\n    case \"SETUP_WALLET_MODULES\":\n      {\n        const {\n          modules,\n          accounts,\n          contract,\n          selectedWalletId,\n          recentlySignedInWallets\n        } = action.payload;\n        const accountStates = accounts.map((account, i) => {\n          return Object.assign(Object.assign({}, account), {\n            active: i === 0\n          });\n        });\n        return Object.assign(Object.assign({}, state), {\n          modules,\n          accounts: accountStates,\n          contract,\n          selectedWalletId,\n          recentlySignedInWallets\n        });\n      }\n    case \"WALLET_CONNECTED\":\n      {\n        const {\n          walletId,\n          contract,\n          accounts,\n          recentlySignedInWallets\n        } = action.payload;\n        if (!accounts.length) {\n          return state;\n        }\n        const activeAccountIndex = state.accounts.findIndex(account => account.active);\n        const accountStates = accounts.map((account, i) => {\n          return Object.assign(Object.assign({}, account), {\n            active: i === (activeAccountIndex > -1 ? activeAccountIndex : 0)\n          });\n        });\n        return Object.assign(Object.assign({}, state), {\n          contract,\n          accounts: accountStates,\n          selectedWalletId: walletId,\n          recentlySignedInWallets\n        });\n      }\n    case \"WALLET_DISCONNECTED\":\n      {\n        const {\n          walletId\n        } = action.payload;\n        if (walletId !== state.selectedWalletId) {\n          return state;\n        }\n        return Object.assign(Object.assign({}, state), {\n          contract: null,\n          accounts: [],\n          selectedWalletId: null\n        });\n      }\n    case \"ACCOUNTS_CHANGED\":\n      {\n        const {\n          walletId,\n          accounts\n        } = action.payload;\n        if (walletId !== state.selectedWalletId) {\n          return state;\n        }\n        const activeAccount = state.accounts.find(account => account.active);\n        const isActiveAccountRemoved = !accounts.some(account => account.accountId === (activeAccount === null || activeAccount === void 0 ? void 0 : activeAccount.accountId));\n        const accountStates = accounts.map((account, i) => {\n          return Object.assign(Object.assign({}, account), {\n            active: isActiveAccountRemoved ? i === 0 : account.accountId === (activeAccount === null || activeAccount === void 0 ? void 0 : activeAccount.accountId)\n          });\n        });\n        return Object.assign(Object.assign({}, state), {\n          accounts: accountStates\n        });\n      }\n    case \"SET_ACTIVE_ACCOUNT\":\n      {\n        const {\n          accountId\n        } = action.payload;\n        const accountStates = state.accounts.map(account => {\n          return Object.assign(Object.assign({}, account), {\n            active: account.accountId === accountId\n          });\n        });\n        return Object.assign(Object.assign({}, state), {\n          accounts: accountStates\n        });\n      }\n    default:\n      return state;\n  }\n};\nconst createStore = storage => __awaiter(void 0, void 0, void 0, function* () {\n  const jsonStorage = new JsonStorage(storage, PACKAGE_NAME);\n  const initialState = {\n    modules: [],\n    accounts: [],\n    contract: yield jsonStorage.getItem(CONTRACT),\n    selectedWalletId: yield jsonStorage.getItem(SELECTED_WALLET_ID),\n    recentlySignedInWallets: (yield jsonStorage.getItem(RECENTLY_SIGNED_IN_WALLETS)) || []\n  };\n  const state$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__.BehaviorSubject(initialState);\n  const actions$ = new rxjs__WEBPACK_IMPORTED_MODULE_5__.Subject();\n  actions$.pipe((0,rxjs__WEBPACK_IMPORTED_MODULE_6__.scan)(reducer, initialState)).subscribe(state$);\n  const syncStorage = (prevState, state, storageKey, property) => __awaiter(void 0, void 0, void 0, function* () {\n    if (state[property] === prevState[property]) {\n      return;\n    }\n    if (state[property]) {\n      yield jsonStorage.setItem(storageKey, state[property]);\n      return;\n    }\n    yield jsonStorage.removeItem(storageKey);\n  });\n  let prevState = state$.getValue();\n  state$.subscribe(state => {\n    syncStorage(prevState, state, SELECTED_WALLET_ID, \"selectedWalletId\");\n    syncStorage(prevState, state, CONTRACT, \"contract\");\n    syncStorage(prevState, state, RECENTLY_SIGNED_IN_WALLETS, \"recentlySignedInWallets\");\n    prevState = state;\n  });\n  return {\n    observable: state$,\n    getState: () => state$.getValue(),\n    dispatch: action => actions$.next(action),\n    toReadOnly: () => ({\n      getState: () => state$.getValue(),\n      observable: state$.asObservable()\n    })\n  };\n});\n\nlet walletSelectorInstance = null;\nconst createSelector = (options, store, walletModules, emitter) => {\n  return {\n    options,\n    store: store.toReadOnly(),\n    wallet: id => __awaiter(void 0, void 0, void 0, function* () {\n      const {\n        selectedWalletId\n      } = store.getState();\n      const wallet = yield walletModules.getWallet(id || selectedWalletId);\n      if (!wallet) {\n        if (id) {\n          throw new Error(\"Invalid wallet id\");\n        }\n        throw new Error(\"No wallet selected\");\n      }\n      return wallet;\n    }),\n    setActiveAccount: accountId => {\n      const {\n        accounts\n      } = store.getState();\n      if (!accounts.some(account => account.accountId === accountId)) {\n        throw new Error(\"Invalid account id\");\n      }\n      store.dispatch({\n        type: \"SET_ACTIVE_ACCOUNT\",\n        payload: {\n          accountId\n        }\n      });\n    },\n    isSignedIn() {\n      const {\n        accounts\n      } = store.getState();\n      return Boolean(accounts.length);\n    },\n    on: (eventName, callback) => {\n      return emitter.on(eventName, callback);\n    },\n    off: (eventName, callback) => {\n      emitter.off(eventName, callback);\n    }\n  };\n};\n/**\r\n * Initiates a wallet selector instance\r\n * @param {WalletSelectorParams} params Selector parameters (network, modules...)\r\n * @returns {Promise<WalletSelector>} Returns a WalletSelector object\r\n */\nconst setupWalletSelector = params => __awaiter(void 0, void 0, void 0, function* () {\n  const {\n    options,\n    storage\n  } = resolveOptions(params);\n  Logger.debug = options.debug;\n  const emitter = new EventEmitter();\n  const store = yield createStore(storage);\n  const walletModules = new WalletModules({\n    factories: params.modules,\n    storage,\n    options,\n    store,\n    emitter,\n    provider: new Provider(options.network.nodeUrl)\n  });\n  yield walletModules.setup();\n  if (params.allowMultipleSelectors) {\n    return createSelector(options, store, walletModules, emitter);\n  }\n  if (!walletSelectorInstance) {\n    walletSelectorInstance = createSelector(options, store, walletModules, emitter);\n  }\n  return walletSelectorInstance;\n});\n\nconst wait = ms => {\n  return new Promise(resolve => setTimeout(resolve, ms));\n};\nconst poll = (cb, interval, remaining) => __awaiter(void 0, void 0, void 0, function* () {\n  const result = cb();\n  if (result) {\n    return result;\n  }\n  if (!remaining) {\n    throw new Error(\"Exceeded timeout\");\n  }\n  return wait(interval).then(() => poll(cb, interval, remaining - 1));\n});\nconst waitFor = (cb, opts = {}) => __awaiter(void 0, void 0, void 0, function* () {\n  const {\n    timeout = 100,\n    interval = 50\n  } = opts;\n  return Promise.race([wait(timeout).then(() => {\n    throw new Error(\"Exceeded timeout\");\n  }), poll(cb, interval, Math.floor(timeout / interval))]);\n});\n\nconst getActiveAccount = state => {\n  return state.accounts.find(account => account.active) || null;\n};\n\nvar aCallable$1 = aCallable$9;\nvar toObject$3 = toObject$7;\nvar IndexedObject$1 = indexedObject;\nvar lengthOfArrayLike$5 = lengthOfArrayLike$8;\n\nvar $TypeError$2 = TypeError;\n\n// `Array.prototype.{ reduce, reduceRight }` methods implementation\nvar createMethod$2 = function (IS_RIGHT) {\n  return function (that, callbackfn, argumentsLength, memo) {\n    aCallable$1(callbackfn);\n    var O = toObject$3(that);\n    var self = IndexedObject$1(O);\n    var length = lengthOfArrayLike$5(O);\n    var index = IS_RIGHT ? length - 1 : 0;\n    var i = IS_RIGHT ? -1 : 1;\n    if (argumentsLength < 2) while (true) {\n      if (index in self) {\n        memo = self[index];\n        index += i;\n        break;\n      }\n      index += i;\n      if (IS_RIGHT ? index < 0 : length <= index) {\n        throw $TypeError$2('Reduce of empty array with no initial value');\n      }\n    }\n    for (;IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {\n      memo = callbackfn(memo, self[index], index, O);\n    }\n    return memo;\n  };\n};\n\nvar arrayReduce = {\n  // `Array.prototype.reduce` method\n  // https://tc39.es/ecma262/#sec-array.prototype.reduce\n  left: createMethod$2(false),\n  // `Array.prototype.reduceRight` method\n  // https://tc39.es/ecma262/#sec-array.prototype.reduceright\n  right: createMethod$2(true)\n};\n\nvar fails$c = fails$s;\n\nvar arrayMethodIsStrict$1 = function (METHOD_NAME, argument) {\n  var method = [][METHOD_NAME];\n  return !!method && fails$c(function () {\n    // eslint-disable-next-line no-useless-call -- required for testing\n    method.call(null, argument || function () { return 1; }, 1);\n  });\n};\n\nvar $$3 = _export;\nvar $reduce = arrayReduce.left;\nvar arrayMethodIsStrict = arrayMethodIsStrict$1;\nvar CHROME_VERSION = engineV8Version;\nvar IS_NODE = engineIsNode;\n\nvar STRICT_METHOD = arrayMethodIsStrict('reduce');\n// Chrome 80-82 has a critical bug\n// https://bugs.chromium.org/p/chromium/issues/detail?id=1049982\nvar CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83;\n\n// `Array.prototype.reduce` method\n// https://tc39.es/ecma262/#sec-array.prototype.reduce\n$$3({ target: 'Array', proto: true, forced: !STRICT_METHOD || CHROME_BUG }, {\n  reduce: function reduce(callbackfn /* , initialValue */) {\n    var length = arguments.length;\n    return $reduce(this, callbackfn, length, length > 1 ? arguments[1] : undefined);\n  }\n});\n\nvar anObject$3 = anObject$e;\n\n// `RegExp.prototype.flags` getter implementation\n// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags\nvar regexpFlags$1 = function () {\n  var that = anObject$3(this);\n  var result = '';\n  if (that.hasIndices) result += 'd';\n  if (that.global) result += 'g';\n  if (that.ignoreCase) result += 'i';\n  if (that.multiline) result += 'm';\n  if (that.dotAll) result += 's';\n  if (that.unicode) result += 'u';\n  if (that.unicodeSets) result += 'v';\n  if (that.sticky) result += 'y';\n  return result;\n};\n\nvar fails$b = fails$s;\nvar global$a = global$t;\n\n// babel-minify and Closure Compiler transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError\nvar $RegExp$2 = global$a.RegExp;\n\nvar UNSUPPORTED_Y$2 = fails$b(function () {\n  var re = $RegExp$2('a', 'y');\n  re.lastIndex = 2;\n  return re.exec('abcd') != null;\n});\n\n// UC Browser bug\n// https://github.com/zloirock/core-js/issues/1008\nvar MISSED_STICKY = UNSUPPORTED_Y$2 || fails$b(function () {\n  return !$RegExp$2('a', 'y').sticky;\n});\n\nvar BROKEN_CARET = UNSUPPORTED_Y$2 || fails$b(function () {\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=773687\n  var re = $RegExp$2('^r', 'gy');\n  re.lastIndex = 2;\n  return re.exec('str') != null;\n});\n\nvar regexpStickyHelpers = {\n  BROKEN_CARET: BROKEN_CARET,\n  MISSED_STICKY: MISSED_STICKY,\n  UNSUPPORTED_Y: UNSUPPORTED_Y$2\n};\n\nvar fails$a = fails$s;\nvar global$9 = global$t;\n\n// babel-minify and Closure Compiler transpiles RegExp('.', 's') -> /./s and it causes SyntaxError\nvar $RegExp$1 = global$9.RegExp;\n\nvar regexpUnsupportedDotAll = fails$a(function () {\n  var re = $RegExp$1('.', 's');\n  return !(re.dotAll && re.exec('\\n') && re.flags === 's');\n});\n\nvar fails$9 = fails$s;\nvar global$8 = global$t;\n\n// babel-minify and Closure Compiler transpiles RegExp('(?<a>b)', 'g') -> /(?<a>b)/g and it causes SyntaxError\nvar $RegExp = global$8.RegExp;\n\nvar regexpUnsupportedNcg = fails$9(function () {\n  var re = $RegExp('(?<a>b)', 'g');\n  return re.exec('b').groups.a !== 'b' ||\n    'b'.replace(re, '$<a>c') !== 'bc';\n});\n\n/* eslint-disable regexp/no-empty-capturing-group, regexp/no-empty-group, regexp/no-lazy-ends -- testing */\n/* eslint-disable regexp/no-useless-quantifier -- testing */\nvar call$6 = functionCall;\nvar uncurryThis$8 = functionUncurryThis;\nvar toString$2 = toString$5;\nvar regexpFlags = regexpFlags$1;\nvar stickyHelpers$1 = regexpStickyHelpers;\nvar shared = shared$4.exports;\nvar create$1 = objectCreate;\nvar getInternalState$3 = internalState.get;\nvar UNSUPPORTED_DOT_ALL = regexpUnsupportedDotAll;\nvar UNSUPPORTED_NCG = regexpUnsupportedNcg;\n\nvar nativeReplace = shared('native-string-replace', String.prototype.replace);\nvar nativeExec = RegExp.prototype.exec;\nvar patchedExec = nativeExec;\nvar charAt$2 = uncurryThis$8(''.charAt);\nvar indexOf = uncurryThis$8(''.indexOf);\nvar replace = uncurryThis$8(''.replace);\nvar stringSlice$2 = uncurryThis$8(''.slice);\n\nvar UPDATES_LAST_INDEX_WRONG = (function () {\n  var re1 = /a/;\n  var re2 = /b*/g;\n  call$6(nativeExec, re1, 'a');\n  call$6(nativeExec, re2, 'a');\n  return re1.lastIndex !== 0 || re2.lastIndex !== 0;\n})();\n\nvar UNSUPPORTED_Y$1 = stickyHelpers$1.BROKEN_CARET;\n\n// nonparticipating capturing group, copied from es5-shim's String#split patch.\nvar NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;\n\nvar PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y$1 || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG;\n\nif (PATCH) {\n  patchedExec = function exec(string) {\n    var re = this;\n    var state = getInternalState$3(re);\n    var str = toString$2(string);\n    var raw = state.raw;\n    var result, reCopy, lastIndex, match, i, object, group;\n\n    if (raw) {\n      raw.lastIndex = re.lastIndex;\n      result = call$6(patchedExec, raw, str);\n      re.lastIndex = raw.lastIndex;\n      return result;\n    }\n\n    var groups = state.groups;\n    var sticky = UNSUPPORTED_Y$1 && re.sticky;\n    var flags = call$6(regexpFlags, re);\n    var source = re.source;\n    var charsAdded = 0;\n    var strCopy = str;\n\n    if (sticky) {\n      flags = replace(flags, 'y', '');\n      if (indexOf(flags, 'g') === -1) {\n        flags += 'g';\n      }\n\n      strCopy = stringSlice$2(str, re.lastIndex);\n      // Support anchored sticky behavior.\n      if (re.lastIndex > 0 && (!re.multiline || re.multiline && charAt$2(str, re.lastIndex - 1) !== '\\n')) {\n        source = '(?: ' + source + ')';\n        strCopy = ' ' + strCopy;\n        charsAdded++;\n      }\n      // ^(? + rx + ) is needed, in combination with some str slicing, to\n      // simulate the 'y' flag.\n      reCopy = new RegExp('^(?:' + source + ')', flags);\n    }\n\n    if (NPCG_INCLUDED) {\n      reCopy = new RegExp('^' + source + '$(?!\\\\s)', flags);\n    }\n    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;\n\n    match = call$6(nativeExec, sticky ? reCopy : re, strCopy);\n\n    if (sticky) {\n      if (match) {\n        match.input = stringSlice$2(match.input, charsAdded);\n        match[0] = stringSlice$2(match[0], charsAdded);\n        match.index = re.lastIndex;\n        re.lastIndex += match[0].length;\n      } else re.lastIndex = 0;\n    } else if (UPDATES_LAST_INDEX_WRONG && match) {\n      re.lastIndex = re.global ? match.index + match[0].length : lastIndex;\n    }\n    if (NPCG_INCLUDED && match && match.length > 1) {\n      // Fix browsers whose `exec` methods don't consistently return `undefined`\n      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/\n      call$6(nativeReplace, match[0], reCopy, function () {\n        for (i = 1; i < arguments.length - 2; i++) {\n          if (arguments[i] === undefined) match[i] = undefined;\n        }\n      });\n    }\n\n    if (match && groups) {\n      match.groups = object = create$1(null);\n      for (i = 0; i < groups.length; i++) {\n        group = groups[i];\n        object[group[0]] = match[group[1]];\n      }\n    }\n\n    return match;\n  };\n}\n\nvar regexpExec$3 = patchedExec;\n\nvar $$2 = _export;\nvar exec$1 = regexpExec$3;\n\n// `RegExp.prototype.exec` method\n// https://tc39.es/ecma262/#sec-regexp.prototype.exec\n$$2({ target: 'RegExp', proto: true, forced: /./.exec !== exec$1 }, {\n  exec: exec$1\n});\n\n/* eslint-disable no-useless-escape */\n// https://github.com/DamonOehlman/detect-browser/blob/master/src/index.ts\nconst SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;\nconst userAgentRules = [[\"aol\", /AOLShield\\/([0-9\\._]+)/], [\"edge\", /Edge\\/([0-9\\._]+)/], [\"edge-ios\", /EdgiOS\\/([0-9\\._]+)/], [\"yandexbrowser\", /YaBrowser\\/([0-9\\._]+)/], [\"kakaotalk\", /KAKAOTALK\\s([0-9\\.]+)/], [\"samsung\", /SamsungBrowser\\/([0-9\\.]+)/], [\"silk\", /\\bSilk\\/([0-9._-]+)\\b/], [\"miui\", /MiuiBrowser\\/([0-9\\.]+)$/], [\"beaker\", /BeakerBrowser\\/([0-9\\.]+)/], [\"edge-chromium\", /EdgA?\\/([0-9\\.]+)/], [\"chromium-webview\", /(?!Chrom.*OPR)wv\\).*Chrom(?:e|ium)\\/([0-9\\.]+)(:?\\s|$)/], [\"chrome\", /(?!Chrom.*OPR)Chrom(?:e|ium)\\/([0-9\\.]+)(:?\\s|$)/], [\"phantomjs\", /PhantomJS\\/([0-9\\.]+)(:?\\s|$)/], [\"crios\", /CriOS\\/([0-9\\.]+)(:?\\s|$)/], [\"firefox\", /Firefox\\/([0-9\\.]+)(?:\\s|$)/], [\"fxios\", /FxiOS\\/([0-9\\.]+)/], [\"opera-mini\", /Opera Mini.*Version\\/([0-9\\.]+)/], [\"opera\", /Opera\\/([0-9\\.]+)(?:\\s|$)/], [\"opera\", /OPR\\/([0-9\\.]+)(:?\\s|$)/], [\"pie\", /^Microsoft Pocket Internet Explorer\\/(\\d+\\.\\d+)$/], [\"pie\", /^Mozilla\\/\\d\\.\\d+\\s\\(compatible;\\s(?:MSP?IE|MSInternet Explorer) (\\d+\\.\\d+);.*Windows CE.*\\)$/], [\"netfront\", /^Mozilla\\/\\d\\.\\d+.*NetFront\\/(\\d.\\d)/], [\"ie\", /Trident\\/7\\.0.*rv\\:([0-9\\.]+).*\\).*Gecko$/], [\"ie\", /MSIE\\s([0-9\\.]+);.*Trident\\/[4-7].0/], [\"ie\", /MSIE\\s(7\\.0)/], [\"bb10\", /BB10;\\sTouch.*Version\\/([0-9\\.]+)/], [\"android\", /Android\\s([0-9\\.]+)/], [\"ios\", /Version\\/([0-9\\._]+).*Mobile.*Safari.*/], [\"safari\", /Version\\/([0-9\\._]+).*Safari/], [\"facebook\", /FB[AS]V\\/([0-9\\.]+)/], [\"instagram\", /Instagram\\s([0-9\\.]+)/], [\"ios-webview\", /AppleWebKit\\/([0-9\\.]+).*Mobile/], [\"ios-webview\", /AppleWebKit\\/([0-9\\.]+).*Gecko\\)$/], [\"curl\", /^curl\\/([0-9\\.]+)$/], [\"searchbot\", SEARCHBOX_UA_REGEX]];\nconst matchUserAgent = ua => {\n  return ua !== \"\" && userAgentRules.reduce((matched, [browser, regex]) => {\n    if (matched) {\n      return matched;\n    }\n    const uaMatch = regex.exec(ua);\n    return !!uaMatch && [browser, uaMatch];\n  }, false);\n};\nconst isCurrentBrowserSupported = supportedBrowser => {\n  if (typeof navigator === \"undefined\") {\n    return false;\n  }\n  const matchedRule = matchUserAgent(navigator.userAgent);\n  if (!matchedRule) {\n    return false;\n  }\n  const [name] = matchedRule;\n  if (name === \"searchbot\") {\n    return false;\n  }\n  return !!supportedBrowser.find(item => item === name);\n};\n\n// eslint-disable-next-line es-x/no-typed-arrays -- safe\nvar arrayBufferNative = typeof ArrayBuffer != 'undefined' && typeof DataView != 'undefined';\n\nvar NATIVE_ARRAY_BUFFER$1 = arrayBufferNative;\nvar DESCRIPTORS$2 = descriptors;\nvar global$7 = global$t;\nvar isCallable$2 = isCallable$n;\nvar isObject$4 = isObject$d;\nvar hasOwn$1 = hasOwnProperty_1;\nvar classof$4 = classof$9;\nvar tryToString = tryToString$5;\nvar createNonEnumerableProperty$3 = createNonEnumerableProperty$8;\nvar defineBuiltIn$2 = defineBuiltIn$8;\nvar defineProperty$1 = objectDefineProperty.f;\nvar isPrototypeOf$1 = objectIsPrototypeOf;\nvar getPrototypeOf$1 = objectGetPrototypeOf;\nvar setPrototypeOf$3 = objectSetPrototypeOf;\nvar wellKnownSymbol$2 = wellKnownSymbol$j;\nvar uid = uid$3;\nvar InternalStateModule$2 = internalState;\n\nvar enforceInternalState$1 = InternalStateModule$2.enforce;\nvar getInternalState$2 = InternalStateModule$2.get;\nvar Int8Array$4 = global$7.Int8Array;\nvar Int8ArrayPrototype$1 = Int8Array$4 && Int8Array$4.prototype;\nvar Uint8ClampedArray$1 = global$7.Uint8ClampedArray;\nvar Uint8ClampedArrayPrototype = Uint8ClampedArray$1 && Uint8ClampedArray$1.prototype;\nvar TypedArray$1 = Int8Array$4 && getPrototypeOf$1(Int8Array$4);\nvar TypedArrayPrototype$1 = Int8ArrayPrototype$1 && getPrototypeOf$1(Int8ArrayPrototype$1);\nvar ObjectPrototype$1 = Object.prototype;\nvar TypeError$1 = global$7.TypeError;\n\nvar TO_STRING_TAG = wellKnownSymbol$2('toStringTag');\nvar TYPED_ARRAY_TAG$1 = uid('TYPED_ARRAY_TAG');\nvar TYPED_ARRAY_CONSTRUCTOR = 'TypedArrayConstructor';\n// Fixing native typed arrays in Opera Presto crashes the browser, see #595\nvar NATIVE_ARRAY_BUFFER_VIEWS$2 = NATIVE_ARRAY_BUFFER$1 && !!setPrototypeOf$3 && classof$4(global$7.opera) !== 'Opera';\nvar TYPED_ARRAY_TAG_REQUIRED = false;\nvar NAME, Constructor, Prototype;\n\nvar TypedArrayConstructorsList = {\n  Int8Array: 1,\n  Uint8Array: 1,\n  Uint8ClampedArray: 1,\n  Int16Array: 2,\n  Uint16Array: 2,\n  Int32Array: 4,\n  Uint32Array: 4,\n  Float32Array: 4,\n  Float64Array: 8\n};\n\nvar BigIntArrayConstructorsList = {\n  BigInt64Array: 8,\n  BigUint64Array: 8\n};\n\nvar isView = function isView(it) {\n  if (!isObject$4(it)) return false;\n  var klass = classof$4(it);\n  return klass === 'DataView'\n    || hasOwn$1(TypedArrayConstructorsList, klass)\n    || hasOwn$1(BigIntArrayConstructorsList, klass);\n};\n\nvar getTypedArrayConstructor = function (it) {\n  var proto = getPrototypeOf$1(it);\n  if (!isObject$4(proto)) return;\n  var state = getInternalState$2(proto);\n  return (state && hasOwn$1(state, TYPED_ARRAY_CONSTRUCTOR)) ? state[TYPED_ARRAY_CONSTRUCTOR] : getTypedArrayConstructor(proto);\n};\n\nvar isTypedArray$1 = function (it) {\n  if (!isObject$4(it)) return false;\n  var klass = classof$4(it);\n  return hasOwn$1(TypedArrayConstructorsList, klass)\n    || hasOwn$1(BigIntArrayConstructorsList, klass);\n};\n\nvar aTypedArray$4 = function (it) {\n  if (isTypedArray$1(it)) return it;\n  throw TypeError$1('Target is not a typed array');\n};\n\nvar aTypedArrayConstructor$2 = function (C) {\n  if (isCallable$2(C) && (!setPrototypeOf$3 || isPrototypeOf$1(TypedArray$1, C))) return C;\n  throw TypeError$1(tryToString(C) + ' is not a typed array constructor');\n};\n\nvar exportTypedArrayMethod$4 = function (KEY, property, forced, options) {\n  if (!DESCRIPTORS$2) return;\n  if (forced) for (var ARRAY in TypedArrayConstructorsList) {\n    var TypedArrayConstructor = global$7[ARRAY];\n    if (TypedArrayConstructor && hasOwn$1(TypedArrayConstructor.prototype, KEY)) try {\n      delete TypedArrayConstructor.prototype[KEY];\n    } catch (error) {\n      // old WebKit bug - some methods are non-configurable\n      try {\n        TypedArrayConstructor.prototype[KEY] = property;\n      } catch (error2) { /* empty */ }\n    }\n  }\n  if (!TypedArrayPrototype$1[KEY] || forced) {\n    defineBuiltIn$2(TypedArrayPrototype$1, KEY, forced ? property\n      : NATIVE_ARRAY_BUFFER_VIEWS$2 && Int8ArrayPrototype$1[KEY] || property, options);\n  }\n};\n\nvar exportTypedArrayStaticMethod$1 = function (KEY, property, forced) {\n  var ARRAY, TypedArrayConstructor;\n  if (!DESCRIPTORS$2) return;\n  if (setPrototypeOf$3) {\n    if (forced) for (ARRAY in TypedArrayConstructorsList) {\n      TypedArrayConstructor = global$7[ARRAY];\n      if (TypedArrayConstructor && hasOwn$1(TypedArrayConstructor, KEY)) try {\n        delete TypedArrayConstructor[KEY];\n      } catch (error) { /* empty */ }\n    }\n    if (!TypedArray$1[KEY] || forced) {\n      // V8 ~ Chrome 49-50 `%TypedArray%` methods are non-writable non-configurable\n      try {\n        return defineBuiltIn$2(TypedArray$1, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS$2 && TypedArray$1[KEY] || property);\n      } catch (error) { /* empty */ }\n    } else return;\n  }\n  for (ARRAY in TypedArrayConstructorsList) {\n    TypedArrayConstructor = global$7[ARRAY];\n    if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {\n      defineBuiltIn$2(TypedArrayConstructor, KEY, property);\n    }\n  }\n};\n\nfor (NAME in TypedArrayConstructorsList) {\n  Constructor = global$7[NAME];\n  Prototype = Constructor && Constructor.prototype;\n  if (Prototype) enforceInternalState$1(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;\n  else NATIVE_ARRAY_BUFFER_VIEWS$2 = false;\n}\n\nfor (NAME in BigIntArrayConstructorsList) {\n  Constructor = global$7[NAME];\n  Prototype = Constructor && Constructor.prototype;\n  if (Prototype) enforceInternalState$1(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;\n}\n\n// WebKit bug - typed arrays constructors prototype is Object.prototype\nif (!NATIVE_ARRAY_BUFFER_VIEWS$2 || !isCallable$2(TypedArray$1) || TypedArray$1 === Function.prototype) {\n  // eslint-disable-next-line no-shadow -- safe\n  TypedArray$1 = function TypedArray() {\n    throw TypeError$1('Incorrect invocation');\n  };\n  if (NATIVE_ARRAY_BUFFER_VIEWS$2) for (NAME in TypedArrayConstructorsList) {\n    if (global$7[NAME]) setPrototypeOf$3(global$7[NAME], TypedArray$1);\n  }\n}\n\nif (!NATIVE_ARRAY_BUFFER_VIEWS$2 || !TypedArrayPrototype$1 || TypedArrayPrototype$1 === ObjectPrototype$1) {\n  TypedArrayPrototype$1 = TypedArray$1.prototype;\n  if (NATIVE_ARRAY_BUFFER_VIEWS$2) for (NAME in TypedArrayConstructorsList) {\n    if (global$7[NAME]) setPrototypeOf$3(global$7[NAME].prototype, TypedArrayPrototype$1);\n  }\n}\n\n// WebKit bug - one more object in Uint8ClampedArray prototype chain\nif (NATIVE_ARRAY_BUFFER_VIEWS$2 && getPrototypeOf$1(Uint8ClampedArrayPrototype) !== TypedArrayPrototype$1) {\n  setPrototypeOf$3(Uint8ClampedArrayPrototype, TypedArrayPrototype$1);\n}\n\nif (DESCRIPTORS$2 && !hasOwn$1(TypedArrayPrototype$1, TO_STRING_TAG)) {\n  TYPED_ARRAY_TAG_REQUIRED = true;\n  defineProperty$1(TypedArrayPrototype$1, TO_STRING_TAG, { get: function () {\n    return isObject$4(this) ? this[TYPED_ARRAY_TAG$1] : undefined;\n  } });\n  for (NAME in TypedArrayConstructorsList) if (global$7[NAME]) {\n    createNonEnumerableProperty$3(global$7[NAME], TYPED_ARRAY_TAG$1, NAME);\n  }\n}\n\nvar arrayBufferViewCore = {\n  NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS$2,\n  TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQUIRED && TYPED_ARRAY_TAG$1,\n  aTypedArray: aTypedArray$4,\n  aTypedArrayConstructor: aTypedArrayConstructor$2,\n  exportTypedArrayMethod: exportTypedArrayMethod$4,\n  exportTypedArrayStaticMethod: exportTypedArrayStaticMethod$1,\n  getTypedArrayConstructor: getTypedArrayConstructor,\n  isView: isView,\n  isTypedArray: isTypedArray$1,\n  TypedArray: TypedArray$1,\n  TypedArrayPrototype: TypedArrayPrototype$1\n};\n\n/* eslint-disable no-new -- required for testing */\n\nvar global$6 = global$t;\nvar fails$8 = fails$s;\nvar checkCorrectnessOfIteration = checkCorrectnessOfIteration$2;\nvar NATIVE_ARRAY_BUFFER_VIEWS$1 = arrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;\n\nvar ArrayBuffer$3 = global$6.ArrayBuffer;\nvar Int8Array$3 = global$6.Int8Array;\n\nvar typedArrayConstructorsRequireWrappers = !NATIVE_ARRAY_BUFFER_VIEWS$1 || !fails$8(function () {\n  Int8Array$3(1);\n}) || !fails$8(function () {\n  new Int8Array$3(-1);\n}) || !checkCorrectnessOfIteration(function (iterable) {\n  new Int8Array$3();\n  new Int8Array$3(null);\n  new Int8Array$3(1.5);\n  new Int8Array$3(iterable);\n}, true) || fails$8(function () {\n  // Safari (11+) bug - a reason why even Safari 13 should load a typed array polyfill\n  return new Int8Array$3(new ArrayBuffer$3(2), 1, undefined).length !== 1;\n});\n\nvar bind$1 = functionBindContext;\nvar call$5 = functionCall;\nvar aConstructor = aConstructor$2;\nvar toObject$2 = toObject$7;\nvar lengthOfArrayLike$4 = lengthOfArrayLike$8;\nvar getIterator = getIterator$2;\nvar getIteratorMethod = getIteratorMethod$3;\nvar isArrayIteratorMethod = isArrayIteratorMethod$2;\nvar aTypedArrayConstructor$1 = arrayBufferViewCore.aTypedArrayConstructor;\n\nvar typedArrayFrom$2 = function from(source /* , mapfn, thisArg */) {\n  var C = aConstructor(this);\n  var O = toObject$2(source);\n  var argumentsLength = arguments.length;\n  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;\n  var mapping = mapfn !== undefined;\n  var iteratorMethod = getIteratorMethod(O);\n  var i, length, result, step, iterator, next;\n  if (iteratorMethod && !isArrayIteratorMethod(iteratorMethod)) {\n    iterator = getIterator(O, iteratorMethod);\n    next = iterator.next;\n    O = [];\n    while (!(step = call$5(next, iterator)).done) {\n      O.push(step.value);\n    }\n  }\n  if (mapping && argumentsLength > 2) {\n    mapfn = bind$1(mapfn, arguments[2]);\n  }\n  length = lengthOfArrayLike$4(O);\n  result = new (aTypedArrayConstructor$1(C))(length);\n  for (i = 0; length > i; i++) {\n    result[i] = mapping ? mapfn(O[i], i) : O[i];\n  }\n  return result;\n};\n\nvar TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS$1 = typedArrayConstructorsRequireWrappers;\nvar exportTypedArrayStaticMethod = arrayBufferViewCore.exportTypedArrayStaticMethod;\nvar typedArrayFrom$1 = typedArrayFrom$2;\n\n// `%TypedArray%.from` method\n// https://tc39.es/ecma262/#sec-%typedarray%.from\nexportTypedArrayStaticMethod('from', typedArrayFrom$1, TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS$1);\n\nvar defineBuiltIn$1 = defineBuiltIn$8;\n\nvar defineBuiltIns$1 = function (target, src, options) {\n  for (var key in src) defineBuiltIn$1(target, key, src[key], options);\n  return target;\n};\n\nvar toIntegerOrInfinity$3 = toIntegerOrInfinity$6;\nvar toLength$4 = toLength$6;\n\nvar $RangeError$2 = RangeError;\n\n// `ToIndex` abstract operation\n// https://tc39.es/ecma262/#sec-toindex\nvar toIndex$2 = function (it) {\n  if (it === undefined) return 0;\n  var number = toIntegerOrInfinity$3(it);\n  var length = toLength$4(number);\n  if (number !== length) throw $RangeError$2('Wrong length or index');\n  return length;\n};\n\n// IEEE754 conversions based on https://github.com/feross/ieee754\nvar $Array$2 = Array;\nvar abs = Math.abs;\nvar pow = Math.pow;\nvar floor$2 = Math.floor;\nvar log = Math.log;\nvar LN2 = Math.LN2;\n\nvar pack = function (number, mantissaLength, bytes) {\n  var buffer = $Array$2(bytes);\n  var exponentLength = bytes * 8 - mantissaLength - 1;\n  var eMax = (1 << exponentLength) - 1;\n  var eBias = eMax >> 1;\n  var rt = mantissaLength === 23 ? pow(2, -24) - pow(2, -77) : 0;\n  var sign = number < 0 || number === 0 && 1 / number < 0 ? 1 : 0;\n  var index = 0;\n  var exponent, mantissa, c;\n  number = abs(number);\n  // eslint-disable-next-line no-self-compare -- NaN check\n  if (number != number || number === Infinity) {\n    // eslint-disable-next-line no-self-compare -- NaN check\n    mantissa = number != number ? 1 : 0;\n    exponent = eMax;\n  } else {\n    exponent = floor$2(log(number) / LN2);\n    c = pow(2, -exponent);\n    if (number * c < 1) {\n      exponent--;\n      c *= 2;\n    }\n    if (exponent + eBias >= 1) {\n      number += rt / c;\n    } else {\n      number += rt * pow(2, 1 - eBias);\n    }\n    if (number * c >= 2) {\n      exponent++;\n      c /= 2;\n    }\n    if (exponent + eBias >= eMax) {\n      mantissa = 0;\n      exponent = eMax;\n    } else if (exponent + eBias >= 1) {\n      mantissa = (number * c - 1) * pow(2, mantissaLength);\n      exponent = exponent + eBias;\n    } else {\n      mantissa = number * pow(2, eBias - 1) * pow(2, mantissaLength);\n      exponent = 0;\n    }\n  }\n  while (mantissaLength >= 8) {\n    buffer[index++] = mantissa & 255;\n    mantissa /= 256;\n    mantissaLength -= 8;\n  }\n  exponent = exponent << mantissaLength | mantissa;\n  exponentLength += mantissaLength;\n  while (exponentLength > 0) {\n    buffer[index++] = exponent & 255;\n    exponent /= 256;\n    exponentLength -= 8;\n  }\n  buffer[--index] |= sign * 128;\n  return buffer;\n};\n\nvar unpack = function (buffer, mantissaLength) {\n  var bytes = buffer.length;\n  var exponentLength = bytes * 8 - mantissaLength - 1;\n  var eMax = (1 << exponentLength) - 1;\n  var eBias = eMax >> 1;\n  var nBits = exponentLength - 7;\n  var index = bytes - 1;\n  var sign = buffer[index--];\n  var exponent = sign & 127;\n  var mantissa;\n  sign >>= 7;\n  while (nBits > 0) {\n    exponent = exponent * 256 + buffer[index--];\n    nBits -= 8;\n  }\n  mantissa = exponent & (1 << -nBits) - 1;\n  exponent >>= -nBits;\n  nBits += mantissaLength;\n  while (nBits > 0) {\n    mantissa = mantissa * 256 + buffer[index--];\n    nBits -= 8;\n  }\n  if (exponent === 0) {\n    exponent = 1 - eBias;\n  } else if (exponent === eMax) {\n    return mantissa ? NaN : sign ? -Infinity : Infinity;\n  } else {\n    mantissa = mantissa + pow(2, mantissaLength);\n    exponent = exponent - eBias;\n  } return (sign ? -1 : 1) * mantissa * pow(2, exponent - mantissaLength);\n};\n\nvar ieee754 = {\n  pack: pack,\n  unpack: unpack\n};\n\nvar toObject$1 = toObject$7;\nvar toAbsoluteIndex$2 = toAbsoluteIndex$4;\nvar lengthOfArrayLike$3 = lengthOfArrayLike$8;\n\n// `Array.prototype.fill` method implementation\n// https://tc39.es/ecma262/#sec-array.prototype.fill\nvar arrayFill$1 = function fill(value /* , start = 0, end = @length */) {\n  var O = toObject$1(this);\n  var length = lengthOfArrayLike$3(O);\n  var argumentsLength = arguments.length;\n  var index = toAbsoluteIndex$2(argumentsLength > 1 ? arguments[1] : undefined, length);\n  var end = argumentsLength > 2 ? arguments[2] : undefined;\n  var endPos = end === undefined ? length : toAbsoluteIndex$2(end, length);\n  while (endPos > index) O[index++] = value;\n  return O;\n};\n\nvar toPropertyKey$1 = toPropertyKey$4;\nvar definePropertyModule$1 = objectDefineProperty;\nvar createPropertyDescriptor$1 = createPropertyDescriptor$5;\n\nvar createProperty$1 = function (object, key, value) {\n  var propertyKey = toPropertyKey$1(key);\n  if (propertyKey in object) definePropertyModule$1.f(object, propertyKey, createPropertyDescriptor$1(0, value));\n  else object[propertyKey] = value;\n};\n\nvar toAbsoluteIndex$1 = toAbsoluteIndex$4;\nvar lengthOfArrayLike$2 = lengthOfArrayLike$8;\nvar createProperty = createProperty$1;\n\nvar $Array$1 = Array;\nvar max = Math.max;\n\nvar arraySliceSimple = function (O, start, end) {\n  var length = lengthOfArrayLike$2(O);\n  var k = toAbsoluteIndex$1(start, length);\n  var fin = toAbsoluteIndex$1(end === undefined ? length : end, length);\n  var result = $Array$1(max(fin - k, 0));\n  for (var n = 0; k < fin; k++, n++) createProperty(result, n, O[k]);\n  result.length = n;\n  return result;\n};\n\nvar global$5 = global$t;\nvar uncurryThis$7 = functionUncurryThis;\nvar DESCRIPTORS$1 = descriptors;\nvar NATIVE_ARRAY_BUFFER = arrayBufferNative;\nvar FunctionName = functionName;\nvar createNonEnumerableProperty$2 = createNonEnumerableProperty$8;\nvar defineBuiltIns = defineBuiltIns$1;\nvar fails$7 = fails$s;\nvar anInstance$1 = anInstance$3;\nvar toIntegerOrInfinity$2 = toIntegerOrInfinity$6;\nvar toLength$3 = toLength$6;\nvar toIndex$1 = toIndex$2;\nvar IEEE754 = ieee754;\nvar getPrototypeOf = objectGetPrototypeOf;\nvar setPrototypeOf$2 = objectSetPrototypeOf;\nvar getOwnPropertyNames$1 = objectGetOwnPropertyNames.f;\nvar defineProperty = objectDefineProperty.f;\nvar arrayFill = arrayFill$1;\nvar arraySlice$3 = arraySliceSimple;\nvar setToStringTag = setToStringTag$4;\nvar InternalStateModule$1 = internalState;\n\nvar PROPER_FUNCTION_NAME = FunctionName.PROPER;\nvar CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;\nvar getInternalState$1 = InternalStateModule$1.get;\nvar setInternalState$1 = InternalStateModule$1.set;\nvar ARRAY_BUFFER = 'ArrayBuffer';\nvar DATA_VIEW = 'DataView';\nvar PROTOTYPE = 'prototype';\nvar WRONG_LENGTH$1 = 'Wrong length';\nvar WRONG_INDEX = 'Wrong index';\nvar NativeArrayBuffer = global$5[ARRAY_BUFFER];\nvar $ArrayBuffer = NativeArrayBuffer;\nvar ArrayBufferPrototype$1 = $ArrayBuffer && $ArrayBuffer[PROTOTYPE];\nvar $DataView = global$5[DATA_VIEW];\nvar DataViewPrototype$1 = $DataView && $DataView[PROTOTYPE];\nvar ObjectPrototype = Object.prototype;\nvar Array$1 = global$5.Array;\nvar RangeError$3 = global$5.RangeError;\nvar fill = uncurryThis$7(arrayFill);\nvar reverse = uncurryThis$7([].reverse);\n\nvar packIEEE754 = IEEE754.pack;\nvar unpackIEEE754 = IEEE754.unpack;\n\nvar packInt8 = function (number) {\n  return [number & 0xFF];\n};\n\nvar packInt16 = function (number) {\n  return [number & 0xFF, number >> 8 & 0xFF];\n};\n\nvar packInt32 = function (number) {\n  return [number & 0xFF, number >> 8 & 0xFF, number >> 16 & 0xFF, number >> 24 & 0xFF];\n};\n\nvar unpackInt32 = function (buffer) {\n  return buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];\n};\n\nvar packFloat32 = function (number) {\n  return packIEEE754(number, 23, 4);\n};\n\nvar packFloat64 = function (number) {\n  return packIEEE754(number, 52, 8);\n};\n\nvar addGetter$1 = function (Constructor, key) {\n  defineProperty(Constructor[PROTOTYPE], key, { get: function () { return getInternalState$1(this)[key]; } });\n};\n\nvar get = function (view, count, index, isLittleEndian) {\n  var intIndex = toIndex$1(index);\n  var store = getInternalState$1(view);\n  if (intIndex + count > store.byteLength) throw RangeError$3(WRONG_INDEX);\n  var bytes = getInternalState$1(store.buffer).bytes;\n  var start = intIndex + store.byteOffset;\n  var pack = arraySlice$3(bytes, start, start + count);\n  return isLittleEndian ? pack : reverse(pack);\n};\n\nvar set = function (view, count, index, conversion, value, isLittleEndian) {\n  var intIndex = toIndex$1(index);\n  var store = getInternalState$1(view);\n  if (intIndex + count > store.byteLength) throw RangeError$3(WRONG_INDEX);\n  var bytes = getInternalState$1(store.buffer).bytes;\n  var start = intIndex + store.byteOffset;\n  var pack = conversion(+value);\n  for (var i = 0; i < count; i++) bytes[start + i] = pack[isLittleEndian ? i : count - i - 1];\n};\n\nif (!NATIVE_ARRAY_BUFFER) {\n  $ArrayBuffer = function ArrayBuffer(length) {\n    anInstance$1(this, ArrayBufferPrototype$1);\n    var byteLength = toIndex$1(length);\n    setInternalState$1(this, {\n      bytes: fill(Array$1(byteLength), 0),\n      byteLength: byteLength\n    });\n    if (!DESCRIPTORS$1) this.byteLength = byteLength;\n  };\n\n  ArrayBufferPrototype$1 = $ArrayBuffer[PROTOTYPE];\n\n  $DataView = function DataView(buffer, byteOffset, byteLength) {\n    anInstance$1(this, DataViewPrototype$1);\n    anInstance$1(buffer, ArrayBufferPrototype$1);\n    var bufferLength = getInternalState$1(buffer).byteLength;\n    var offset = toIntegerOrInfinity$2(byteOffset);\n    if (offset < 0 || offset > bufferLength) throw RangeError$3('Wrong offset');\n    byteLength = byteLength === undefined ? bufferLength - offset : toLength$3(byteLength);\n    if (offset + byteLength > bufferLength) throw RangeError$3(WRONG_LENGTH$1);\n    setInternalState$1(this, {\n      buffer: buffer,\n      byteLength: byteLength,\n      byteOffset: offset\n    });\n    if (!DESCRIPTORS$1) {\n      this.buffer = buffer;\n      this.byteLength = byteLength;\n      this.byteOffset = offset;\n    }\n  };\n\n  DataViewPrototype$1 = $DataView[PROTOTYPE];\n\n  if (DESCRIPTORS$1) {\n    addGetter$1($ArrayBuffer, 'byteLength');\n    addGetter$1($DataView, 'buffer');\n    addGetter$1($DataView, 'byteLength');\n    addGetter$1($DataView, 'byteOffset');\n  }\n\n  defineBuiltIns(DataViewPrototype$1, {\n    getInt8: function getInt8(byteOffset) {\n      return get(this, 1, byteOffset)[0] << 24 >> 24;\n    },\n    getUint8: function getUint8(byteOffset) {\n      return get(this, 1, byteOffset)[0];\n    },\n    getInt16: function getInt16(byteOffset /* , littleEndian */) {\n      var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);\n      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;\n    },\n    getUint16: function getUint16(byteOffset /* , littleEndian */) {\n      var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);\n      return bytes[1] << 8 | bytes[0];\n    },\n    getInt32: function getInt32(byteOffset /* , littleEndian */) {\n      return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined));\n    },\n    getUint32: function getUint32(byteOffset /* , littleEndian */) {\n      return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined)) >>> 0;\n    },\n    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {\n      return unpackIEEE754(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 23);\n    },\n    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {\n      return unpackIEEE754(get(this, 8, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 52);\n    },\n    setInt8: function setInt8(byteOffset, value) {\n      set(this, 1, byteOffset, packInt8, value);\n    },\n    setUint8: function setUint8(byteOffset, value) {\n      set(this, 1, byteOffset, packInt8, value);\n    },\n    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {\n      set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);\n    },\n    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {\n      set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);\n    },\n    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {\n      set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);\n    },\n    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {\n      set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);\n    },\n    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {\n      set(this, 4, byteOffset, packFloat32, value, arguments.length > 2 ? arguments[2] : undefined);\n    },\n    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {\n      set(this, 8, byteOffset, packFloat64, value, arguments.length > 2 ? arguments[2] : undefined);\n    }\n  });\n} else {\n  var INCORRECT_ARRAY_BUFFER_NAME = PROPER_FUNCTION_NAME && NativeArrayBuffer.name !== ARRAY_BUFFER;\n  /* eslint-disable no-new -- required for testing */\n  if (!fails$7(function () {\n    NativeArrayBuffer(1);\n  }) || !fails$7(function () {\n    new NativeArrayBuffer(-1);\n  }) || fails$7(function () {\n    new NativeArrayBuffer();\n    new NativeArrayBuffer(1.5);\n    new NativeArrayBuffer(NaN);\n    return INCORRECT_ARRAY_BUFFER_NAME && !CONFIGURABLE_FUNCTION_NAME;\n  })) {\n  /* eslint-enable no-new -- required for testing */\n    $ArrayBuffer = function ArrayBuffer(length) {\n      anInstance$1(this, ArrayBufferPrototype$1);\n      return new NativeArrayBuffer(toIndex$1(length));\n    };\n\n    $ArrayBuffer[PROTOTYPE] = ArrayBufferPrototype$1;\n\n    for (var keys = getOwnPropertyNames$1(NativeArrayBuffer), j = 0, key; keys.length > j;) {\n      if (!((key = keys[j++]) in $ArrayBuffer)) {\n        createNonEnumerableProperty$2($ArrayBuffer, key, NativeArrayBuffer[key]);\n      }\n    }\n\n    ArrayBufferPrototype$1.constructor = $ArrayBuffer;\n  } else if (INCORRECT_ARRAY_BUFFER_NAME && CONFIGURABLE_FUNCTION_NAME) {\n    createNonEnumerableProperty$2(NativeArrayBuffer, 'name', ARRAY_BUFFER);\n  }\n\n  // WebKit bug - the same parent prototype for typed arrays and data view\n  if (setPrototypeOf$2 && getPrototypeOf(DataViewPrototype$1) !== ObjectPrototype) {\n    setPrototypeOf$2(DataViewPrototype$1, ObjectPrototype);\n  }\n\n  // iOS Safari 7.x bug\n  var testView = new $DataView(new $ArrayBuffer(2));\n  var $setInt8 = uncurryThis$7(DataViewPrototype$1.setInt8);\n  testView.setInt8(0, 2147483648);\n  testView.setInt8(1, 2147483649);\n  if (testView.getInt8(0) || !testView.getInt8(1)) defineBuiltIns(DataViewPrototype$1, {\n    setInt8: function setInt8(byteOffset, value) {\n      $setInt8(this, byteOffset, value << 24 >> 24);\n    },\n    setUint8: function setUint8(byteOffset, value) {\n      $setInt8(this, byteOffset, value << 24 >> 24);\n    }\n  }, { unsafe: true });\n}\n\nsetToStringTag($ArrayBuffer, ARRAY_BUFFER);\nsetToStringTag($DataView, DATA_VIEW);\n\nvar arrayBuffer = {\n  ArrayBuffer: $ArrayBuffer,\n  DataView: $DataView\n};\n\nvar $$1 = _export;\nvar uncurryThis$6 = functionUncurryThis;\nvar fails$6 = fails$s;\nvar ArrayBufferModule$1 = arrayBuffer;\nvar anObject$2 = anObject$e;\nvar toAbsoluteIndex = toAbsoluteIndex$4;\nvar toLength$2 = toLength$6;\nvar speciesConstructor$1 = speciesConstructor$3;\n\nvar ArrayBuffer$2 = ArrayBufferModule$1.ArrayBuffer;\nvar DataView$2 = ArrayBufferModule$1.DataView;\nvar DataViewPrototype = DataView$2.prototype;\nvar un$ArrayBufferSlice = uncurryThis$6(ArrayBuffer$2.prototype.slice);\nvar getUint8 = uncurryThis$6(DataViewPrototype.getUint8);\nvar setUint8 = uncurryThis$6(DataViewPrototype.setUint8);\n\nvar INCORRECT_SLICE = fails$6(function () {\n  return !new ArrayBuffer$2(2).slice(1, undefined).byteLength;\n});\n\n// `ArrayBuffer.prototype.slice` method\n// https://tc39.es/ecma262/#sec-arraybuffer.prototype.slice\n$$1({ target: 'ArrayBuffer', proto: true, unsafe: true, forced: INCORRECT_SLICE }, {\n  slice: function slice(start, end) {\n    if (un$ArrayBufferSlice && end === undefined) {\n      return un$ArrayBufferSlice(anObject$2(this), start); // FF fix\n    }\n    var length = anObject$2(this).byteLength;\n    var first = toAbsoluteIndex(start, length);\n    var fin = toAbsoluteIndex(end === undefined ? length : end, length);\n    var result = new (speciesConstructor$1(this, ArrayBuffer$2))(toLength$2(fin - first));\n    var viewSource = new DataView$2(this);\n    var viewTarget = new DataView$2(result);\n    var index = 0;\n    while (first < fin) {\n      setUint8(viewTarget, index++, getUint8(viewSource, first++));\n    } return result;\n  }\n});\n\nvar typedArrayConstructor = {exports: {}};\n\nvar isObject$3 = isObject$d;\n\nvar floor$1 = Math.floor;\n\n// `IsIntegralNumber` abstract operation\n// https://tc39.es/ecma262/#sec-isintegralnumber\n// eslint-disable-next-line es-x/no-number-isinteger -- safe\nvar isIntegralNumber$1 = Number.isInteger || function isInteger(it) {\n  return !isObject$3(it) && isFinite(it) && floor$1(it) === it;\n};\n\nvar toIntegerOrInfinity$1 = toIntegerOrInfinity$6;\n\nvar $RangeError$1 = RangeError;\n\nvar toPositiveInteger$1 = function (it) {\n  var result = toIntegerOrInfinity$1(it);\n  if (result < 0) throw $RangeError$1(\"The argument can't be less than 0\");\n  return result;\n};\n\nvar toPositiveInteger = toPositiveInteger$1;\n\nvar $RangeError = RangeError;\n\nvar toOffset$2 = function (it, BYTES) {\n  var offset = toPositiveInteger(it);\n  if (offset % BYTES) throw $RangeError('Wrong offset');\n  return offset;\n};\n\nvar classof$3 = classofRaw$1;\n\n// `IsArray` abstract operation\n// https://tc39.es/ecma262/#sec-isarray\n// eslint-disable-next-line es-x/no-array-isarray -- safe\nvar isArray$1 = Array.isArray || function isArray(argument) {\n  return classof$3(argument) == 'Array';\n};\n\nvar isArray = isArray$1;\nvar isConstructor = isConstructor$2;\nvar isObject$2 = isObject$d;\nvar wellKnownSymbol$1 = wellKnownSymbol$j;\n\nvar SPECIES$1 = wellKnownSymbol$1('species');\nvar $Array = Array;\n\n// a part of `ArraySpeciesCreate` abstract operation\n// https://tc39.es/ecma262/#sec-arrayspeciescreate\nvar arraySpeciesConstructor$1 = function (originalArray) {\n  var C;\n  if (isArray(originalArray)) {\n    C = originalArray.constructor;\n    // cross-realm fallback\n    if (isConstructor(C) && (C === $Array || isArray(C.prototype))) C = undefined;\n    else if (isObject$2(C)) {\n      C = C[SPECIES$1];\n      if (C === null) C = undefined;\n    }\n  } return C === undefined ? $Array : C;\n};\n\nvar arraySpeciesConstructor = arraySpeciesConstructor$1;\n\n// `ArraySpeciesCreate` abstract operation\n// https://tc39.es/ecma262/#sec-arrayspeciescreate\nvar arraySpeciesCreate$1 = function (originalArray, length) {\n  return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);\n};\n\nvar bind = functionBindContext;\nvar uncurryThis$5 = functionUncurryThis;\nvar IndexedObject = indexedObject;\nvar toObject = toObject$7;\nvar lengthOfArrayLike$1 = lengthOfArrayLike$8;\nvar arraySpeciesCreate = arraySpeciesCreate$1;\n\nvar push$1 = uncurryThis$5([].push);\n\n// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterReject }` methods implementation\nvar createMethod$1 = function (TYPE) {\n  var IS_MAP = TYPE == 1;\n  var IS_FILTER = TYPE == 2;\n  var IS_SOME = TYPE == 3;\n  var IS_EVERY = TYPE == 4;\n  var IS_FIND_INDEX = TYPE == 6;\n  var IS_FILTER_REJECT = TYPE == 7;\n  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;\n  return function ($this, callbackfn, that, specificCreate) {\n    var O = toObject($this);\n    var self = IndexedObject(O);\n    var boundFunction = bind(callbackfn, that);\n    var length = lengthOfArrayLike$1(self);\n    var index = 0;\n    var create = specificCreate || arraySpeciesCreate;\n    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : undefined;\n    var value, result;\n    for (;length > index; index++) if (NO_HOLES || index in self) {\n      value = self[index];\n      result = boundFunction(value, index, O);\n      if (TYPE) {\n        if (IS_MAP) target[index] = result; // map\n        else if (result) switch (TYPE) {\n          case 3: return true;              // some\n          case 5: return value;             // find\n          case 6: return index;             // findIndex\n          case 2: push$1(target, value);      // filter\n        } else switch (TYPE) {\n          case 4: return false;             // every\n          case 7: push$1(target, value);      // filterReject\n        }\n      }\n    }\n    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;\n  };\n};\n\nvar arrayIteration = {\n  // `Array.prototype.forEach` method\n  // https://tc39.es/ecma262/#sec-array.prototype.foreach\n  forEach: createMethod$1(0),\n  // `Array.prototype.map` method\n  // https://tc39.es/ecma262/#sec-array.prototype.map\n  map: createMethod$1(1),\n  // `Array.prototype.filter` method\n  // https://tc39.es/ecma262/#sec-array.prototype.filter\n  filter: createMethod$1(2),\n  // `Array.prototype.some` method\n  // https://tc39.es/ecma262/#sec-array.prototype.some\n  some: createMethod$1(3),\n  // `Array.prototype.every` method\n  // https://tc39.es/ecma262/#sec-array.prototype.every\n  every: createMethod$1(4),\n  // `Array.prototype.find` method\n  // https://tc39.es/ecma262/#sec-array.prototype.find\n  find: createMethod$1(5),\n  // `Array.prototype.findIndex` method\n  // https://tc39.es/ecma262/#sec-array.prototype.findIndex\n  findIndex: createMethod$1(6),\n  // `Array.prototype.filterReject` method\n  // https://github.com/tc39/proposal-array-filtering\n  filterReject: createMethod$1(7)\n};\n\nvar isCallable$1 = isCallable$n;\nvar isObject$1 = isObject$d;\nvar setPrototypeOf$1 = objectSetPrototypeOf;\n\n// makes subclassing work correct for wrapped built-ins\nvar inheritIfRequired$1 = function ($this, dummy, Wrapper) {\n  var NewTarget, NewTargetPrototype;\n  if (\n    // it can work only with native `setPrototypeOf`\n    setPrototypeOf$1 &&\n    // we haven't completely correct pre-ES6 way for getting `new.target`, so use this\n    isCallable$1(NewTarget = dummy.constructor) &&\n    NewTarget !== Wrapper &&\n    isObject$1(NewTargetPrototype = NewTarget.prototype) &&\n    NewTargetPrototype !== Wrapper.prototype\n  ) setPrototypeOf$1($this, NewTargetPrototype);\n  return $this;\n};\n\nvar $ = _export;\nvar global$4 = global$t;\nvar call$4 = functionCall;\nvar DESCRIPTORS = descriptors;\nvar TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = typedArrayConstructorsRequireWrappers;\nvar ArrayBufferViewCore$4 = arrayBufferViewCore;\nvar ArrayBufferModule = arrayBuffer;\nvar anInstance = anInstance$3;\nvar createPropertyDescriptor = createPropertyDescriptor$5;\nvar createNonEnumerableProperty$1 = createNonEnumerableProperty$8;\nvar isIntegralNumber = isIntegralNumber$1;\nvar toLength$1 = toLength$6;\nvar toIndex = toIndex$2;\nvar toOffset$1 = toOffset$2;\nvar toPropertyKey = toPropertyKey$4;\nvar hasOwn = hasOwnProperty_1;\nvar classof$2 = classof$9;\nvar isObject = isObject$d;\nvar isSymbol = isSymbol$3;\nvar create = objectCreate;\nvar isPrototypeOf = objectIsPrototypeOf;\nvar setPrototypeOf = objectSetPrototypeOf;\nvar getOwnPropertyNames = objectGetOwnPropertyNames.f;\nvar typedArrayFrom = typedArrayFrom$2;\nvar forEach = arrayIteration.forEach;\nvar setSpecies = setSpecies$2;\nvar definePropertyModule = objectDefineProperty;\nvar getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;\nvar InternalStateModule = internalState;\nvar inheritIfRequired = inheritIfRequired$1;\n\nvar getInternalState = InternalStateModule.get;\nvar setInternalState = InternalStateModule.set;\nvar enforceInternalState = InternalStateModule.enforce;\nvar nativeDefineProperty = definePropertyModule.f;\nvar nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\nvar round = Math.round;\nvar RangeError$2 = global$4.RangeError;\nvar ArrayBuffer$1 = ArrayBufferModule.ArrayBuffer;\nvar ArrayBufferPrototype = ArrayBuffer$1.prototype;\nvar DataView$1 = ArrayBufferModule.DataView;\nvar NATIVE_ARRAY_BUFFER_VIEWS = ArrayBufferViewCore$4.NATIVE_ARRAY_BUFFER_VIEWS;\nvar TYPED_ARRAY_TAG = ArrayBufferViewCore$4.TYPED_ARRAY_TAG;\nvar TypedArray = ArrayBufferViewCore$4.TypedArray;\nvar TypedArrayPrototype = ArrayBufferViewCore$4.TypedArrayPrototype;\nvar aTypedArrayConstructor = ArrayBufferViewCore$4.aTypedArrayConstructor;\nvar isTypedArray = ArrayBufferViewCore$4.isTypedArray;\nvar BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';\nvar WRONG_LENGTH = 'Wrong length';\n\nvar fromList = function (C, list) {\n  aTypedArrayConstructor(C);\n  var index = 0;\n  var length = list.length;\n  var result = new C(length);\n  while (length > index) result[index] = list[index++];\n  return result;\n};\n\nvar addGetter = function (it, key) {\n  nativeDefineProperty(it, key, { get: function () {\n    return getInternalState(this)[key];\n  } });\n};\n\nvar isArrayBuffer = function (it) {\n  var klass;\n  return isPrototypeOf(ArrayBufferPrototype, it) || (klass = classof$2(it)) == 'ArrayBuffer' || klass == 'SharedArrayBuffer';\n};\n\nvar isTypedArrayIndex = function (target, key) {\n  return isTypedArray(target)\n    && !isSymbol(key)\n    && key in target\n    && isIntegralNumber(+key)\n    && key >= 0;\n};\n\nvar wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor(target, key) {\n  key = toPropertyKey(key);\n  return isTypedArrayIndex(target, key)\n    ? createPropertyDescriptor(2, target[key])\n    : nativeGetOwnPropertyDescriptor(target, key);\n};\n\nvar wrappedDefineProperty = function defineProperty(target, key, descriptor) {\n  key = toPropertyKey(key);\n  if (isTypedArrayIndex(target, key)\n    && isObject(descriptor)\n    && hasOwn(descriptor, 'value')\n    && !hasOwn(descriptor, 'get')\n    && !hasOwn(descriptor, 'set')\n    // TODO: add validation descriptor w/o calling accessors\n    && !descriptor.configurable\n    && (!hasOwn(descriptor, 'writable') || descriptor.writable)\n    && (!hasOwn(descriptor, 'enumerable') || descriptor.enumerable)\n  ) {\n    target[key] = descriptor.value;\n    return target;\n  } return nativeDefineProperty(target, key, descriptor);\n};\n\nif (DESCRIPTORS) {\n  if (!NATIVE_ARRAY_BUFFER_VIEWS) {\n    getOwnPropertyDescriptorModule.f = wrappedGetOwnPropertyDescriptor;\n    definePropertyModule.f = wrappedDefineProperty;\n    addGetter(TypedArrayPrototype, 'buffer');\n    addGetter(TypedArrayPrototype, 'byteOffset');\n    addGetter(TypedArrayPrototype, 'byteLength');\n    addGetter(TypedArrayPrototype, 'length');\n  }\n\n  $({ target: 'Object', stat: true, forced: !NATIVE_ARRAY_BUFFER_VIEWS }, {\n    getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,\n    defineProperty: wrappedDefineProperty\n  });\n\n  typedArrayConstructor.exports = function (TYPE, wrapper, CLAMPED) {\n    var BYTES = TYPE.match(/\\d+$/)[0] / 8;\n    var CONSTRUCTOR_NAME = TYPE + (CLAMPED ? 'Clamped' : '') + 'Array';\n    var GETTER = 'get' + TYPE;\n    var SETTER = 'set' + TYPE;\n    var NativeTypedArrayConstructor = global$4[CONSTRUCTOR_NAME];\n    var TypedArrayConstructor = NativeTypedArrayConstructor;\n    var TypedArrayConstructorPrototype = TypedArrayConstructor && TypedArrayConstructor.prototype;\n    var exported = {};\n\n    var getter = function (that, index) {\n      var data = getInternalState(that);\n      return data.view[GETTER](index * BYTES + data.byteOffset, true);\n    };\n\n    var setter = function (that, index, value) {\n      var data = getInternalState(that);\n      if (CLAMPED) value = (value = round(value)) < 0 ? 0 : value > 0xFF ? 0xFF : value & 0xFF;\n      data.view[SETTER](index * BYTES + data.byteOffset, value, true);\n    };\n\n    var addElement = function (that, index) {\n      nativeDefineProperty(that, index, {\n        get: function () {\n          return getter(this, index);\n        },\n        set: function (value) {\n          return setter(this, index, value);\n        },\n        enumerable: true\n      });\n    };\n\n    if (!NATIVE_ARRAY_BUFFER_VIEWS) {\n      TypedArrayConstructor = wrapper(function (that, data, offset, $length) {\n        anInstance(that, TypedArrayConstructorPrototype);\n        var index = 0;\n        var byteOffset = 0;\n        var buffer, byteLength, length;\n        if (!isObject(data)) {\n          length = toIndex(data);\n          byteLength = length * BYTES;\n          buffer = new ArrayBuffer$1(byteLength);\n        } else if (isArrayBuffer(data)) {\n          buffer = data;\n          byteOffset = toOffset$1(offset, BYTES);\n          var $len = data.byteLength;\n          if ($length === undefined) {\n            if ($len % BYTES) throw RangeError$2(WRONG_LENGTH);\n            byteLength = $len - byteOffset;\n            if (byteLength < 0) throw RangeError$2(WRONG_LENGTH);\n          } else {\n            byteLength = toLength$1($length) * BYTES;\n            if (byteLength + byteOffset > $len) throw RangeError$2(WRONG_LENGTH);\n          }\n          length = byteLength / BYTES;\n        } else if (isTypedArray(data)) {\n          return fromList(TypedArrayConstructor, data);\n        } else {\n          return call$4(typedArrayFrom, TypedArrayConstructor, data);\n        }\n        setInternalState(that, {\n          buffer: buffer,\n          byteOffset: byteOffset,\n          byteLength: byteLength,\n          length: length,\n          view: new DataView$1(buffer)\n        });\n        while (index < length) addElement(that, index++);\n      });\n\n      if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);\n      TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = create(TypedArrayPrototype);\n    } else if (TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS) {\n      TypedArrayConstructor = wrapper(function (dummy, data, typedArrayOffset, $length) {\n        anInstance(dummy, TypedArrayConstructorPrototype);\n        return inheritIfRequired(function () {\n          if (!isObject(data)) return new NativeTypedArrayConstructor(toIndex(data));\n          if (isArrayBuffer(data)) return $length !== undefined\n            ? new NativeTypedArrayConstructor(data, toOffset$1(typedArrayOffset, BYTES), $length)\n            : typedArrayOffset !== undefined\n              ? new NativeTypedArrayConstructor(data, toOffset$1(typedArrayOffset, BYTES))\n              : new NativeTypedArrayConstructor(data);\n          if (isTypedArray(data)) return fromList(TypedArrayConstructor, data);\n          return call$4(typedArrayFrom, TypedArrayConstructor, data);\n        }(), dummy, TypedArrayConstructor);\n      });\n\n      if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);\n      forEach(getOwnPropertyNames(NativeTypedArrayConstructor), function (key) {\n        if (!(key in TypedArrayConstructor)) {\n          createNonEnumerableProperty$1(TypedArrayConstructor, key, NativeTypedArrayConstructor[key]);\n        }\n      });\n      TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;\n    }\n\n    if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) {\n      createNonEnumerableProperty$1(TypedArrayConstructorPrototype, 'constructor', TypedArrayConstructor);\n    }\n\n    enforceInternalState(TypedArrayConstructorPrototype).TypedArrayConstructor = TypedArrayConstructor;\n\n    if (TYPED_ARRAY_TAG) {\n      createNonEnumerableProperty$1(TypedArrayConstructorPrototype, TYPED_ARRAY_TAG, CONSTRUCTOR_NAME);\n    }\n\n    var FORCED = TypedArrayConstructor != NativeTypedArrayConstructor;\n\n    exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;\n\n    $({ global: true, constructor: true, forced: FORCED, sham: !NATIVE_ARRAY_BUFFER_VIEWS }, exported);\n\n    if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {\n      createNonEnumerableProperty$1(TypedArrayConstructor, BYTES_PER_ELEMENT, BYTES);\n    }\n\n    if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {\n      createNonEnumerableProperty$1(TypedArrayConstructorPrototype, BYTES_PER_ELEMENT, BYTES);\n    }\n\n    setSpecies(CONSTRUCTOR_NAME);\n  };\n} else typedArrayConstructor.exports = function () { /* empty */ };\n\nvar createTypedArrayConstructor = typedArrayConstructor.exports;\n\n// `Uint8Array` constructor\n// https://tc39.es/ecma262/#sec-typedarray-objects\ncreateTypedArrayConstructor('Uint8', function (init) {\n  return function Uint8Array(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n});\n\nvar toPrimitive = toPrimitive$2;\n\nvar $TypeError$1 = TypeError;\n\n// `ToBigInt` abstract operation\n// https://tc39.es/ecma262/#sec-tobigint\nvar toBigInt$1 = function (argument) {\n  var prim = toPrimitive(argument, 'number');\n  if (typeof prim == 'number') throw $TypeError$1(\"Can't convert number to bigint\");\n  // eslint-disable-next-line es-x/no-bigint -- safe\n  return BigInt(prim);\n};\n\nvar ArrayBufferViewCore$3 = arrayBufferViewCore;\nvar $fill = arrayFill$1;\nvar toBigInt = toBigInt$1;\nvar classof$1 = classof$9;\nvar call$3 = functionCall;\nvar uncurryThis$4 = functionUncurryThis;\nvar fails$5 = fails$s;\n\nvar aTypedArray$3 = ArrayBufferViewCore$3.aTypedArray;\nvar exportTypedArrayMethod$3 = ArrayBufferViewCore$3.exportTypedArrayMethod;\nvar slice = uncurryThis$4(''.slice);\n\n// V8 ~ Chrome < 59, Safari < 14.1, FF < 55, Edge <=18\nvar CONVERSION_BUG = fails$5(function () {\n  var count = 0;\n  // eslint-disable-next-line es-x/no-typed-arrays -- safe\n  new Int8Array(2).fill({ valueOf: function () { return count++; } });\n  return count !== 1;\n});\n\n// `%TypedArray%.prototype.fill` method\n// https://tc39.es/ecma262/#sec-%typedarray%.prototype.fill\nexportTypedArrayMethod$3('fill', function fill(value /* , start, end */) {\n  var length = arguments.length;\n  aTypedArray$3(this);\n  var actualValue = slice(classof$1(this), 0, 3) === 'Big' ? toBigInt(value) : +value;\n  return call$3($fill, this, actualValue, length > 1 ? arguments[1] : undefined, length > 2 ? arguments[2] : undefined);\n}, CONVERSION_BUG);\n\nvar global$3 = global$t;\nvar call$2 = functionCall;\nvar ArrayBufferViewCore$2 = arrayBufferViewCore;\nvar lengthOfArrayLike = lengthOfArrayLike$8;\nvar toOffset = toOffset$2;\nvar toIndexedObject = toObject$7;\nvar fails$4 = fails$s;\n\nvar RangeError$1 = global$3.RangeError;\nvar Int8Array$2 = global$3.Int8Array;\nvar Int8ArrayPrototype = Int8Array$2 && Int8Array$2.prototype;\nvar $set = Int8ArrayPrototype && Int8ArrayPrototype.set;\nvar aTypedArray$2 = ArrayBufferViewCore$2.aTypedArray;\nvar exportTypedArrayMethod$2 = ArrayBufferViewCore$2.exportTypedArrayMethod;\n\nvar WORKS_WITH_OBJECTS_AND_GEERIC_ON_TYPED_ARRAYS = !fails$4(function () {\n  // eslint-disable-next-line es-x/no-typed-arrays -- required for testing\n  var array = new Uint8ClampedArray(2);\n  call$2($set, array, { length: 1, 0: 3 }, 1);\n  return array[1] !== 3;\n});\n\n// https://bugs.chromium.org/p/v8/issues/detail?id=11294 and other\nvar TO_OBJECT_BUG = WORKS_WITH_OBJECTS_AND_GEERIC_ON_TYPED_ARRAYS && ArrayBufferViewCore$2.NATIVE_ARRAY_BUFFER_VIEWS && fails$4(function () {\n  var array = new Int8Array$2(2);\n  array.set(1);\n  array.set('2', 1);\n  return array[0] !== 0 || array[1] !== 2;\n});\n\n// `%TypedArray%.prototype.set` method\n// https://tc39.es/ecma262/#sec-%typedarray%.prototype.set\nexportTypedArrayMethod$2('set', function set(arrayLike /* , offset */) {\n  aTypedArray$2(this);\n  var offset = toOffset(arguments.length > 1 ? arguments[1] : undefined, 1);\n  var src = toIndexedObject(arrayLike);\n  if (WORKS_WITH_OBJECTS_AND_GEERIC_ON_TYPED_ARRAYS) return call$2($set, this, src, offset);\n  var length = this.length;\n  var len = lengthOfArrayLike(src);\n  var index = 0;\n  if (len + offset > length) throw RangeError$1('Wrong length');\n  while (index < len) this[offset + index] = src[index++];\n}, !WORKS_WITH_OBJECTS_AND_GEERIC_ON_TYPED_ARRAYS || TO_OBJECT_BUG);\n\nvar arraySlice$2 = arraySliceSimple;\n\nvar floor = Math.floor;\n\nvar mergeSort = function (array, comparefn) {\n  var length = array.length;\n  var middle = floor(length / 2);\n  return length < 8 ? insertionSort(array, comparefn) : merge(\n    array,\n    mergeSort(arraySlice$2(array, 0, middle), comparefn),\n    mergeSort(arraySlice$2(array, middle), comparefn),\n    comparefn\n  );\n};\n\nvar insertionSort = function (array, comparefn) {\n  var length = array.length;\n  var i = 1;\n  var element, j;\n\n  while (i < length) {\n    j = i;\n    element = array[i];\n    while (j && comparefn(array[j - 1], element) > 0) {\n      array[j] = array[--j];\n    }\n    if (j !== i++) array[j] = element;\n  } return array;\n};\n\nvar merge = function (array, left, right, comparefn) {\n  var llength = left.length;\n  var rlength = right.length;\n  var lindex = 0;\n  var rindex = 0;\n\n  while (lindex < llength || rindex < rlength) {\n    array[lindex + rindex] = (lindex < llength && rindex < rlength)\n      ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++]\n      : lindex < llength ? left[lindex++] : right[rindex++];\n  } return array;\n};\n\nvar arraySort = mergeSort;\n\nvar userAgent$1 = engineUserAgent;\n\nvar firefox = userAgent$1.match(/firefox\\/(\\d+)/i);\n\nvar engineFfVersion = !!firefox && +firefox[1];\n\nvar UA = engineUserAgent;\n\nvar engineIsIeOrEdge = /MSIE|Trident/.test(UA);\n\nvar userAgent = engineUserAgent;\n\nvar webkit = userAgent.match(/AppleWebKit\\/(\\d+)\\./);\n\nvar engineWebkitVersion = !!webkit && +webkit[1];\n\nvar global$2 = global$t;\nvar uncurryThis$3 = functionUncurryThis;\nvar fails$3 = fails$s;\nvar aCallable = aCallable$9;\nvar internalSort = arraySort;\nvar ArrayBufferViewCore$1 = arrayBufferViewCore;\nvar FF = engineFfVersion;\nvar IE_OR_EDGE = engineIsIeOrEdge;\nvar V8 = engineV8Version;\nvar WEBKIT = engineWebkitVersion;\n\nvar aTypedArray$1 = ArrayBufferViewCore$1.aTypedArray;\nvar exportTypedArrayMethod$1 = ArrayBufferViewCore$1.exportTypedArrayMethod;\nvar Uint16Array = global$2.Uint16Array;\nvar un$Sort = Uint16Array && uncurryThis$3(Uint16Array.prototype.sort);\n\n// WebKit\nvar ACCEPT_INCORRECT_ARGUMENTS = !!un$Sort && !(fails$3(function () {\n  un$Sort(new Uint16Array(2), null);\n}) && fails$3(function () {\n  un$Sort(new Uint16Array(2), {});\n}));\n\nvar STABLE_SORT = !!un$Sort && !fails$3(function () {\n  // feature detection can be too slow, so check engines versions\n  if (V8) return V8 < 74;\n  if (FF) return FF < 67;\n  if (IE_OR_EDGE) return true;\n  if (WEBKIT) return WEBKIT < 602;\n\n  var array = new Uint16Array(516);\n  var expected = Array(516);\n  var index, mod;\n\n  for (index = 0; index < 516; index++) {\n    mod = index % 4;\n    array[index] = 515 - index;\n    expected[index] = index - 2 * mod + 3;\n  }\n\n  un$Sort(array, function (a, b) {\n    return (a / 4 | 0) - (b / 4 | 0);\n  });\n\n  for (index = 0; index < 516; index++) {\n    if (array[index] !== expected[index]) return true;\n  }\n});\n\nvar getSortCompare = function (comparefn) {\n  return function (x, y) {\n    if (comparefn !== undefined) return +comparefn(x, y) || 0;\n    // eslint-disable-next-line no-self-compare -- NaN check\n    if (y !== y) return -1;\n    // eslint-disable-next-line no-self-compare -- NaN check\n    if (x !== x) return 1;\n    if (x === 0 && y === 0) return 1 / x > 0 && 1 / y < 0 ? 1 : -1;\n    return x > y;\n  };\n};\n\n// `%TypedArray%.prototype.sort` method\n// https://tc39.es/ecma262/#sec-%typedarray%.prototype.sort\nexportTypedArrayMethod$1('sort', function sort(comparefn) {\n  if (comparefn !== undefined) aCallable(comparefn);\n  if (STABLE_SORT) return un$Sort(this, comparefn);\n\n  return internalSort(aTypedArray$1(this), getSortCompare(comparefn));\n}, !STABLE_SORT || ACCEPT_INCORRECT_ARGUMENTS);\n\nvar global$1 = global$t;\nvar apply$1 = functionApply;\nvar ArrayBufferViewCore = arrayBufferViewCore;\nvar fails$2 = fails$s;\nvar arraySlice$1 = arraySlice$5;\n\nvar Int8Array$1 = global$1.Int8Array;\nvar aTypedArray = ArrayBufferViewCore.aTypedArray;\nvar exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;\nvar $toLocaleString = [].toLocaleString;\n\n// iOS Safari 6.x fails here\nvar TO_LOCALE_STRING_BUG = !!Int8Array$1 && fails$2(function () {\n  $toLocaleString.call(new Int8Array$1(1));\n});\n\nvar FORCED = fails$2(function () {\n  return [1, 2].toLocaleString() != new Int8Array$1([1, 2]).toLocaleString();\n}) || !fails$2(function () {\n  Int8Array$1.prototype.toLocaleString.call([1, 2]);\n});\n\n// `%TypedArray%.prototype.toLocaleString` method\n// https://tc39.es/ecma262/#sec-%typedarray%.prototype.tolocalestring\nexportTypedArrayMethod('toLocaleString', function toLocaleString() {\n  return apply$1(\n    $toLocaleString,\n    TO_LOCALE_STRING_BUG ? arraySlice$1(aTypedArray(this)) : aTypedArray(this),\n    arraySlice$1(arguments)\n  );\n}, FORCED);\n\nclass Payload {\n  constructor(data) {\n    // The tag's value is a hardcoded value as per\n    // defined in the NEP [NEP413](https://github.com/near/NEPs/blob/master/neps/nep-0413.md)\n    this.tag = 2147484061;\n    this.message = data.message;\n    this.nonce = data.nonce;\n    this.recipient = data.recipient;\n    if (data.callbackUrl) {\n      this.callbackUrl = data.callbackUrl;\n    }\n  }\n}\nconst payloadSchema = new Map([[Payload, {\n  kind: \"struct\",\n  fields: [[\"tag\", \"u32\"], [\"message\", \"string\"], [\"nonce\", [32]], [\"recipient\", \"string\"], [\"callbackUrl\", {\n    kind: \"option\",\n    type: \"string\"\n  }]]\n}]]);\nconst serializeNep413 = signMessageParams => {\n  const payload = new Payload(Object.assign({}, signMessageParams));\n  return Buffer.from((0,borsh__WEBPACK_IMPORTED_MODULE_2__.serialize)(payloadSchema, payload));\n};\n\nconst verifySignature = ({\n  publicKey,\n  signature,\n  message,\n  nonce,\n  recipient,\n  callbackUrl\n}) => {\n  // Reconstruct the payload that was **actually signed**\n  const payload = new Payload({\n    message,\n    nonce,\n    recipient,\n    callbackUrl\n  });\n  // Serialize payload based on payloadSchema\n  const borshPayload = (0,borsh__WEBPACK_IMPORTED_MODULE_2__.serialize)(payloadSchema, payload);\n  // Hash the payload as in the NEP0413 referenced example\n  // https://github.com/near/NEPs/blob/master/neps/nep-0413.md#references\n  // https://github.com/gagdiez/near-login/blob/main/authenticate/wallet-authenticate.js#L21\n  const hashedPayload = Uint8Array.from(js_sha256__WEBPACK_IMPORTED_MODULE_3__.sha256.array(borshPayload));\n  // Convert real signature to buffer base64\n  const realSignature = Buffer.from(signature, \"base64\");\n  const pk = near_api_js__WEBPACK_IMPORTED_MODULE_0__.utils.PublicKey.from(publicKey);\n  // Verify the signature\n  return pk.verify(hashedPayload, realSignature);\n};\nconst fetchAllUserKeys = ({\n  accountId,\n  network,\n  publicKey\n}) => __awaiter(void 0, void 0, void 0, function* () {\n  const provider = new near_api_js__WEBPACK_IMPORTED_MODULE_0__.providers.JsonRpcProvider({\n    url: network.nodeUrl\n  });\n  const key = yield provider.query({\n    request_type: \"view_access_key\",\n    account_id: accountId,\n    finality: \"final\",\n    public_key: publicKey\n  });\n  return key;\n});\nconst verifyFullKeyBelongsToUser = ({\n  publicKey,\n  accountId,\n  network\n}) => __awaiter(void 0, void 0, void 0, function* () {\n  const {\n    permission\n  } = yield fetchAllUserKeys({\n    accountId,\n    network,\n    publicKey\n  });\n  return permission === \"FullAccess\";\n});\n\n// TODO: Remove from `core-js@4` since it's moved to entry points\n\nvar uncurryThis$2 = functionUncurryThis;\nvar defineBuiltIn = defineBuiltIn$8;\nvar regexpExec$2 = regexpExec$3;\nvar fails$1 = fails$s;\nvar wellKnownSymbol = wellKnownSymbol$j;\nvar createNonEnumerableProperty = createNonEnumerableProperty$8;\n\nvar SPECIES = wellKnownSymbol('species');\nvar RegExpPrototype = RegExp.prototype;\n\nvar fixRegexpWellKnownSymbolLogic = function (KEY, exec, FORCED, SHAM) {\n  var SYMBOL = wellKnownSymbol(KEY);\n\n  var DELEGATES_TO_SYMBOL = !fails$1(function () {\n    // String methods call symbol-named RegEp methods\n    var O = {};\n    O[SYMBOL] = function () { return 7; };\n    return ''[KEY](O) != 7;\n  });\n\n  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails$1(function () {\n    // Symbol-named RegExp methods call .exec\n    var execCalled = false;\n    var re = /a/;\n\n    if (KEY === 'split') {\n      // We can't use real regex here since it causes deoptimization\n      // and serious performance degradation in V8\n      // https://github.com/zloirock/core-js/issues/306\n      re = {};\n      // RegExp[@@split] doesn't call the regex's exec method, but first creates\n      // a new one. We need to return the patched regex when creating the new one.\n      re.constructor = {};\n      re.constructor[SPECIES] = function () { return re; };\n      re.flags = '';\n      re[SYMBOL] = /./[SYMBOL];\n    }\n\n    re.exec = function () { execCalled = true; return null; };\n\n    re[SYMBOL]('');\n    return !execCalled;\n  });\n\n  if (\n    !DELEGATES_TO_SYMBOL ||\n    !DELEGATES_TO_EXEC ||\n    FORCED\n  ) {\n    var uncurriedNativeRegExpMethod = uncurryThis$2(/./[SYMBOL]);\n    var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {\n      var uncurriedNativeMethod = uncurryThis$2(nativeMethod);\n      var $exec = regexp.exec;\n      if ($exec === regexpExec$2 || $exec === RegExpPrototype.exec) {\n        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {\n          // The native String method already delegates to @@method (this\n          // polyfilled function), leasing to infinite recursion.\n          // We avoid it by directly calling the native @@method method.\n          return { done: true, value: uncurriedNativeRegExpMethod(regexp, str, arg2) };\n        }\n        return { done: true, value: uncurriedNativeMethod(str, regexp, arg2) };\n      }\n      return { done: false };\n    });\n\n    defineBuiltIn(String.prototype, KEY, methods[0]);\n    defineBuiltIn(RegExpPrototype, SYMBOL, methods[1]);\n  }\n\n  if (SHAM) createNonEnumerableProperty(RegExpPrototype[SYMBOL], 'sham', true);\n};\n\nvar uncurryThis$1 = functionUncurryThis;\nvar toIntegerOrInfinity = toIntegerOrInfinity$6;\nvar toString$1 = toString$5;\nvar requireObjectCoercible$1 = requireObjectCoercible$6;\n\nvar charAt$1 = uncurryThis$1(''.charAt);\nvar charCodeAt = uncurryThis$1(''.charCodeAt);\nvar stringSlice$1 = uncurryThis$1(''.slice);\n\nvar createMethod = function (CONVERT_TO_STRING) {\n  return function ($this, pos) {\n    var S = toString$1(requireObjectCoercible$1($this));\n    var position = toIntegerOrInfinity(pos);\n    var size = S.length;\n    var first, second;\n    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;\n    first = charCodeAt(S, position);\n    return first < 0xD800 || first > 0xDBFF || position + 1 === size\n      || (second = charCodeAt(S, position + 1)) < 0xDC00 || second > 0xDFFF\n        ? CONVERT_TO_STRING\n          ? charAt$1(S, position)\n          : first\n        : CONVERT_TO_STRING\n          ? stringSlice$1(S, position, position + 2)\n          : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;\n  };\n};\n\nvar stringMultibyte = {\n  // `String.prototype.codePointAt` method\n  // https://tc39.es/ecma262/#sec-string.prototype.codepointat\n  codeAt: createMethod(false),\n  // `String.prototype.at` method\n  // https://github.com/mathiasbynens/String.prototype.at\n  charAt: createMethod(true)\n};\n\nvar charAt = stringMultibyte.charAt;\n\n// `AdvanceStringIndex` abstract operation\n// https://tc39.es/ecma262/#sec-advancestringindex\nvar advanceStringIndex$1 = function (S, index, unicode) {\n  return index + (unicode ? charAt(S, index).length : 1);\n};\n\nvar call$1 = functionCall;\nvar anObject$1 = anObject$e;\nvar isCallable = isCallable$n;\nvar classof = classofRaw$1;\nvar regexpExec$1 = regexpExec$3;\n\nvar $TypeError = TypeError;\n\n// `RegExpExec` abstract operation\n// https://tc39.es/ecma262/#sec-regexpexec\nvar regexpExecAbstract = function (R, S) {\n  var exec = R.exec;\n  if (isCallable(exec)) {\n    var result = call$1(exec, R, S);\n    if (result !== null) anObject$1(result);\n    return result;\n  }\n  if (classof(R) === 'RegExp') return call$1(regexpExec$1, R, S);\n  throw $TypeError('RegExp#exec called on incompatible receiver');\n};\n\nvar apply = functionApply;\nvar call = functionCall;\nvar uncurryThis = functionUncurryThis;\nvar fixRegExpWellKnownSymbolLogic = fixRegexpWellKnownSymbolLogic;\nvar isRegExp = isRegexp;\nvar anObject = anObject$e;\nvar requireObjectCoercible = requireObjectCoercible$6;\nvar speciesConstructor = speciesConstructor$3;\nvar advanceStringIndex = advanceStringIndex$1;\nvar toLength = toLength$6;\nvar toString = toString$5;\nvar getMethod = getMethod$4;\nvar arraySlice = arraySliceSimple;\nvar callRegExpExec = regexpExecAbstract;\nvar regexpExec = regexpExec$3;\nvar stickyHelpers = regexpStickyHelpers;\nvar fails = fails$s;\n\nvar UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;\nvar MAX_UINT32 = 0xFFFFFFFF;\nvar min = Math.min;\nvar $push = [].push;\nvar exec = uncurryThis(/./.exec);\nvar push = uncurryThis($push);\nvar stringSlice = uncurryThis(''.slice);\n\n// Chrome 51 has a buggy \"split\" implementation when RegExp#exec !== nativeExec\n// Weex JS has frozen built-in prototypes, so use try / catch wrapper\nvar SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function () {\n  // eslint-disable-next-line regexp/no-empty-group -- required for testing\n  var re = /(?:)/;\n  var originalExec = re.exec;\n  re.exec = function () { return originalExec.apply(this, arguments); };\n  var result = 'ab'.split(re);\n  return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';\n});\n\n// @@split logic\nfixRegExpWellKnownSymbolLogic('split', function (SPLIT, nativeSplit, maybeCallNative) {\n  var internalSplit;\n  if (\n    'abbc'.split(/(b)*/)[1] == 'c' ||\n    // eslint-disable-next-line regexp/no-empty-group -- required for testing\n    'test'.split(/(?:)/, -1).length != 4 ||\n    'ab'.split(/(?:ab)*/).length != 2 ||\n    '.'.split(/(.?)(.?)/).length != 4 ||\n    // eslint-disable-next-line regexp/no-empty-capturing-group, regexp/no-empty-group -- required for testing\n    '.'.split(/()()/).length > 1 ||\n    ''.split(/.?/).length\n  ) {\n    // based on es5-shim implementation, need to rework it\n    internalSplit = function (separator, limit) {\n      var string = toString(requireObjectCoercible(this));\n      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;\n      if (lim === 0) return [];\n      if (separator === undefined) return [string];\n      // If `separator` is not a regex, use native split\n      if (!isRegExp(separator)) {\n        return call(nativeSplit, string, separator, lim);\n      }\n      var output = [];\n      var flags = (separator.ignoreCase ? 'i' : '') +\n                  (separator.multiline ? 'm' : '') +\n                  (separator.unicode ? 'u' : '') +\n                  (separator.sticky ? 'y' : '');\n      var lastLastIndex = 0;\n      // Make `global` and avoid `lastIndex` issues by working with a copy\n      var separatorCopy = new RegExp(separator.source, flags + 'g');\n      var match, lastIndex, lastLength;\n      while (match = call(regexpExec, separatorCopy, string)) {\n        lastIndex = separatorCopy.lastIndex;\n        if (lastIndex > lastLastIndex) {\n          push(output, stringSlice(string, lastLastIndex, match.index));\n          if (match.length > 1 && match.index < string.length) apply($push, output, arraySlice(match, 1));\n          lastLength = match[0].length;\n          lastLastIndex = lastIndex;\n          if (output.length >= lim) break;\n        }\n        if (separatorCopy.lastIndex === match.index) separatorCopy.lastIndex++; // Avoid an infinite loop\n      }\n      if (lastLastIndex === string.length) {\n        if (lastLength || !exec(separatorCopy, '')) push(output, '');\n      } else push(output, stringSlice(string, lastLastIndex));\n      return output.length > lim ? arraySlice(output, 0, lim) : output;\n    };\n  // Chakra, V8\n  } else if ('0'.split(undefined, 0).length) {\n    internalSplit = function (separator, limit) {\n      return separator === undefined && limit === 0 ? [] : call(nativeSplit, this, separator, limit);\n    };\n  } else internalSplit = nativeSplit;\n\n  return [\n    // `String.prototype.split` method\n    // https://tc39.es/ecma262/#sec-string.prototype.split\n    function split(separator, limit) {\n      var O = requireObjectCoercible(this);\n      var splitter = separator == undefined ? undefined : getMethod(separator, SPLIT);\n      return splitter\n        ? call(splitter, separator, O, limit)\n        : call(internalSplit, toString(O), separator, limit);\n    },\n    // `RegExp.prototype[@@split]` method\n    // https://tc39.es/ecma262/#sec-regexp.prototype-@@split\n    //\n    // NOTE: This cannot be properly polyfilled in engines that don't support\n    // the 'y' flag.\n    function (string, limit) {\n      var rx = anObject(this);\n      var S = toString(string);\n      var res = maybeCallNative(internalSplit, rx, S, limit, internalSplit !== nativeSplit);\n\n      if (res.done) return res.value;\n\n      var C = speciesConstructor(rx, RegExp);\n\n      var unicodeMatching = rx.unicode;\n      var flags = (rx.ignoreCase ? 'i' : '') +\n                  (rx.multiline ? 'm' : '') +\n                  (rx.unicode ? 'u' : '') +\n                  (UNSUPPORTED_Y ? 'g' : 'y');\n\n      // ^(? + rx + ) is needed, in combination with some S slicing, to\n      // simulate the 'y' flag.\n      var splitter = new C(UNSUPPORTED_Y ? '^(?:' + rx.source + ')' : rx, flags);\n      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;\n      if (lim === 0) return [];\n      if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : [];\n      var p = 0;\n      var q = 0;\n      var A = [];\n      while (q < S.length) {\n        splitter.lastIndex = UNSUPPORTED_Y ? 0 : q;\n        var z = callRegExpExec(splitter, UNSUPPORTED_Y ? stringSlice(S, q) : S);\n        var e;\n        if (\n          z === null ||\n          (e = min(toLength(splitter.lastIndex + (UNSUPPORTED_Y ? q : 0)), S.length)) === p\n        ) {\n          q = advanceStringIndex(S, q, unicodeMatching);\n        } else {\n          push(A, stringSlice(S, p, q));\n          if (A.length === lim) return A;\n          for (var i = 1; i <= z.length - 1; i++) {\n            push(A, z[i]);\n            if (A.length === lim) return A;\n          }\n          q = p = e;\n        }\n      }\n      push(A, stringSlice(S, p));\n      return A;\n    }\n  ];\n}, !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC, UNSUPPORTED_Y);\n\nvar modal$b = {\n\twallet: {\n\t\tconnectYourWallet: \"Connect Your Wallet\",\n\t\twhatIsAWallet: \"What is a Wallet?\",\n\t\tsecureAndManage: \"Secure & Manage Your Digital Assets\",\n\t\tsafelyStore: \"Safely store and transfer your crypto and NFTs.\",\n\t\tlogInToAny: \"Log In to Any NEAR App\",\n\t\tnoNeedToCreate: \"No need to create new accounts or credentials. Connect your wallet and you are good to go!\",\n\t\tgetAWallet: \"Get a Wallet\",\n\t\tuseAWallet: \"Use a wallet to secure and manage your NEAR assets, and to log in to any NEAR app without the need for usernames and passwords.\",\n\t\tconnectionFailed: \"Connection Failed\",\n\t\tconnectionSuccessful: \"Connection Successful\",\n\t\tconnected: \"Connected\",\n\t\tconnectingTo: \"Connecting to\",\n\t\tconnectingMessage: {\n\t\t\tinjected: \"Confirm the connection in the extension window\",\n\t\t\tbrowser: \"Confirm the connection in the wallet after redirect\",\n\t\t\thardware: \"Confirm the connection in the ledger device\",\n\t\t\tbridge: \"Confirm the connection in the wallet\"\n\t\t}\n\t},\n\tledger: {\n\t\tconnectWithLedger: \"Connect with Ledger\",\n\t\tmakeSureYourLedger: \"Make sure your Ledger is connected securely, and that the NEAR app is open on your device\",\n\t\t\"continue\": \"Continue\",\n\t\tspecifyHDPath: \"Specify HD Path\",\n\t\tenterYourPreferredHDPath: \"Enter your preferred HD path, then scan for any active accounts.\",\n\t\tscan: \"Scan\",\n\t\tretry: \"Retry\",\n\t\tledgerIsNotAvailable: \"Ledger is not available\",\n\t\taccessDeniedToUseLedgerDevice: \"Access denied to use Ledger device\",\n\t\tnoAccountsFound: \"No Accounts Found\",\n\t\tselectYourAccounts: \"Select Your Accounts\",\n\t\tconnecting1Account: \"Connecting 1 Account\",\n\t\tcantFindAnyAccount: \"Can't find any account associated with this Ledger. Please create a new NEAR account on\",\n\t\torConnectAnAnotherLedger: \"or connect an another Ledger.\",\n\t\tconnecting: \"Connecting\",\n\t\tofAccounts: \"of Accounts\",\n\t\tfailedToAutomatically: \"Failed to automatically find account id. Provide it manually:\",\n\t\toverviewTheListOfAuthorized: \"Overview the list of authorized account(s), complete sign in by clicking the button below.\",\n\t\tfinish: \"Finish\"\n\t},\n\tinstall: {\n\t\tyoullNeedToInstall: \"You'll need to install\",\n\t\ttoContinueAfterInstalling: \"to continue. After installing\",\n\t\trefreshThePage: \"refresh the page.\",\n\t\topen: \"Open\"\n\t},\n\tqr: {\n\t\tcopiedToClipboard: \"Copied to clipboard\",\n\t\tfailedToCopy: \"Failed to copy to clipboard\",\n\t\tscanWithYourMobile: \"Scan with Your Mobile Device\",\n\t\tcopyToClipboard: \" Copy to clipboard\",\n\t\tpreferTheOfficial: \"Prefer the official dialogue of\",\n\t\topen: \"Open\"\n\t},\n\twalletTypes: {\n\t\thardware: \"Hardware Wallet\",\n\t\tbrowser: \"Browser Wallet\",\n\t\tinjected: \"Wallet Extension\",\n\t\tbridge: \"Bridge Wallet\",\n\t\tmobile: \"Mobile Wallet\",\n\t\t\"instant-link\": \"Instant Wallet\"\n\t},\n\texportAccounts: {\n\t\tchooseAWallet: \"Choose a Wallet\",\n\t\ttransferYourAccounts: \"Transfer Your Accounts\",\n\t\tselectAWallet: \"Select a wallet that fits your needs and supports your connected accounts.\",\n\t\tselectYourAccounts: \"Select Your Accounts\",\n\t\tafterDecide: \"After you decide on a wallet, you can select which accounts you want to transfer.\",\n\t\tdisclaimer: \"You won’t be able to transfer accounts that have never been funded or used on NEAR.\",\n\t\twarning: \"does not support account export at this time. Please select another wallet.\",\n\t\twalletTypes: {\n\t\t\thardware: \"Hardware Wallet\",\n\t\t\tbrowser: \"Browser Wallet\",\n\t\t\tinjected: \"Wallet Extension\",\n\t\t\tbridge: \"Bridge Wallet\",\n\t\t\tmobile: \"Mobile Wallet\"\n\t\t},\n\t\tselectAccounts: {\n\t\t\ttitle: \"Select Accounts to Transfer\",\n\t\t\tbutton: \"Continue\",\n\t\t\tdeselectAll: \"Deselect All\",\n\t\t\tselectAll: \"Select All\",\n\t\t\tunavailable: \"Transfer Unavailable\",\n\t\t\terror: \"Account does not exist\",\n\t\t\twarningLedger: \"Ledger support required\",\n\t\t\tnoBalance: \"Account not funded\"\n\t\t},\n\t\tgetPassphrase: {\n\t\t\ttitle: \"Copy Temporary Password\",\n\t\t\tdesc: \"You’ll need to enter this password when you begin exporting your accounts to a different wallet.\",\n\t\t\tbutton: \"Continue\",\n\t\t\ttransferButton: \"Transfer Accounts\",\n\t\t\tlabel: \"Click to Copy\",\n\t\t\tcheckLabel: \"I copied or wrote down the password\"\n\t\t},\n\t\tcomplete: {\n\t\t\ttitle: \"Complete the Transfer\",\n\t\t\tdescOne: \"You will now be redirected to the wallet you selected to complete the transfer.\",\n\t\t\tdescTwo: \"Once import part of process is completed from selected wallet, press button to complete the transfer process.\",\n\t\t\tstartOverButton: \"Start Over\",\n\t\t\tbutton: \"Complete\"\n\t\t}\n\t}\n};\nvar component$1 = {\n\tclickToCopy: {\n\t\tlabel: \"Copied\",\n\t\ttooltip: \"Click to copy\"\n\t}\n};\nvar en = {\n\tmodal: modal$b,\n\tcomponent: component$1\n};\n\nvar modal$a = {\n\twallet: {\n\t\tconnectYourWallet: \"Conecta Tu Billetera\",\n\t\twhatIsAWallet: \"¿Que es una Billetera?\",\n\t\tsecureAndManage: \"Resguarda y Administrar Tus Activos Digitales\",\n\t\tsafelyStore: \"Almacena de forma segura y transfiere tus cryptos y NFT's\",\n\t\tlogInToAny: \"Inicie sesión en Cualquier Aplicacion NEAR\",\n\t\tnoNeedToCreate: \"No es necesario crear nuevas cuentas o credenciales, ¡Conecta tu billetera y listo!\",\n\t\tgetAWallet: \"Obten una Billetera\",\n\t\tuseAWallet: \"Usa tu Billetera para resguardar y administrar tus activos en NEAR, e Iniciar sesión en cualquier aplicacion NEAR sin la necesidad de nombres de usuarios y contraseñas\",\n\t\tconnectionFailed: \"Conexión Fallida\",\n\t\tconnectionSuccessful: \"Conexión Existosa\",\n\t\tconnected: \"Conectado\",\n\t\tconnectingTo: \"Conectando a \",\n\t\tconnectingMessage: {\n\t\t\tinjected: \"Confirme la conexión en la ventana de extensión\",\n\t\t\tbrowser: \"Confirme la conexión en la billetera después de la redirección\",\n\t\t\thardware: \"Confirme la conexión en el dispositivo de libro mayor\",\n\t\t\tbridge: \"Confirmar la conexión en la billetera\"\n\t\t}\n\t},\n\tledger: {\n\t\tconnectWithLedger: \"Conectar con Ledger\",\n\t\tmakeSureYourLedger: \"Asegúrese de que su ledger está conectada de forma segura y que la aplicacion NEAR esté abierta en su dispositivo\",\n\t\t\"continue\": \"Continuar\",\n\t\tspecifyHDPath: \"Especifique la ruta HD\",\n\t\tenterYourPreferredHDPath: \"Ingrese su ruta HD prerida,y luego busque cualquier cuenta activa.\",\n\t\tscan: \"Escanear\",\n\t\tretry: \"Reintentar\",\n\t\tledgerIsNotAvailable: \"El Ledger no está disponible\",\n\t\taccessDeniedToUseLedgerDevice: \"Acceso denegado para usar el dispositivo ledger\",\n\t\tnoAccountsFound: \"No se encontraron cuentas\",\n\t\tselectYourAccounts: \"Selecciona tus cuentas\",\n\t\tconnecting1Account: \"Conectando a 1 cuenta\",\n\t\tcantFindAnyAccount: \"No se pudo encontrar ninguna cuenta asociada con este ledger,Por favor crea una nueva cuenta en NEAR\",\n\t\torConnectAnAnotherLedger: \"o conecta otro ledger\",\n\t\tconnecting: \"Conectando\",\n\t\tofAccounts: \"de Cuentas\",\n\t\tfailedToAutomatically: \"No se pudo encontrar automaticamente el id de la cuenta,Ingresalo manualmente:\",\n\t\toverviewTheListOfAuthorized: \"Revise la lista de las cuentas autorizadas,Complete el inicio de sesión haciedo click a countinuacion.\",\n\t\tfinish: \"Finalizar\"\n\t},\n\tinstall: {\n\t\tyoullNeedToInstall: \"Tendrás que instalar\",\n\t\ttoContinueAfterInstalling: \"Para continuar, Despues de instalar\",\n\t\trefreshThePage: \"Recarga la pagina\",\n\t\topen: \"Abrir\"\n\t},\n\tqr: {\n\t\tcopiedToClipboard: \"Copiado al Portapapeles\",\n\t\tfailedToCopy: \"Falló la copia al Portapapeles\",\n\t\tscanWithYourMobile: \"Busca con tu dispositivo movil\",\n\t\tcopyToClipboard: \" Copiar al Portapapeles\",\n\t\tpreferTheOfficial: \"¿Prefires el diálogo oficial de\",\n\t\topen: \"Abrir\"\n\t},\n\twalletTypes: {\n\t\thardware: \"Hardware Wallet\",\n\t\tbrowser: \"Browser Wallet\",\n\t\tinjected: \"Wallet Extension\",\n\t\tbridge: \"Bridge Wallet\",\n\t\tmobile: \"Mobile Wallet\",\n\t\t\"instant-link\": \"Instant Wallet\"\n\t}\n};\nvar es = {\n\tmodal: modal$a\n};\n\nvar modal$9 = {\n\twallet: {\n\t\tconnectYourWallet: \"连接你的钱包\",\n\t\twhatIsAWallet: \"什么是钱包？\",\n\t\tsecureAndManage: \"保护和管理你的数字资产\",\n\t\tsafelyStore: \"安全存储和转移你的加密货币和NFT\",\n\t\tlogInToAny: \"登录任何 NEAR 应用\",\n\t\tnoNeedToCreate: \"不需要创建新账户或密码。连接你的钱包，即可开始使用！\",\n\t\tgetAWallet: \"获取新账户\",\n\t\tuseAWallet: \"使用钱包来保护和管理你的 NEAR 资产，无需用户名和密码即可登录任何 NEAR 应用\",\n\t\tconnectionFailed: \"连接失败\",\n\t\tconnectionSuccessful: \"连接成功\",\n\t\tconnected: \"已连接\",\n\t\tconnectingTo: \"正在连接\"\n\t},\n\tledger: {\n\t\tconnectWithLedger: \"连接 Ledger\",\n\t\tmakeSureYourLedger: \"确保你的 Ledger 已经安全连接，并且 NEAR 应用已经在你设备上打开\",\n\t\t\"continue\": \"继续\",\n\t\tspecifyHDPath: \"指定 HD 路径\",\n\t\tenterYourPreferredHDPath: \"输入你偏好的 HD 路径，然后为任意活跃账户扫码\",\n\t\tscan: \"扫码\",\n\t\tretry: \"重试\",\n\t\tledgerIsNotAvailable: \"Ledger 不可用\",\n\t\taccessDeniedToUseLedgerDevice: \"访问 Ledger 设备被拒绝\",\n\t\tnoAccountsFound: \"没有找到账户\",\n\t\tselectYourAccounts: \"选择你的账户\",\n\t\tconnecting1Account: \"正在连接1个账户\",\n\t\tcantFindAnyAccount: \"没有找到任何与这个 Ledger 相关联的账户。请创建新账户于\",\n\t\t\"orConnectAnAnotherLedger.\": \"或连接另一个 Ledger\",\n\t\tconnecting: \"正在连接\",\n\t\tofAccounts: \"个账户\",\n\t\tfailedToAutomatically: \"无法自动找到账户ID，请主动提供：\",\n\t\toverviewTheListOfAuthorized: \"请查看已授权的账户列表，点击以下按钮完成登录\",\n\t\tfinish: \"完成\"\n\t},\n\tinstall: {\n\t\tyoullNeedToInstall: \"你将需要安装\",\n\t\ttoContinueAfterInstalling: \"以继续。安装完\",\n\t\trefreshThePage: \"请刷新页面\",\n\t\topen: \"打开\"\n\t},\n\tqr: {\n\t\tcopiedToClipboard: \"复制到了剪贴板\",\n\t\tfailedToCopy: \"复制到剪贴板失败\",\n\t\tscanWithYourMobile: \"用你的移动设备扫码\",\n\t\tcopyToClipboard: \" 复制到剪贴板\",\n\t\tpreferTheOfficial: \"希望使用官方对话框于\",\n\t\topen: \"打开\"\n\t},\n\twalletTypes: {\n\t\thardware: \"Hardware Wallet\",\n\t\tbrowser: \"Browser Wallet\",\n\t\tinjected: \"Wallet Extension\",\n\t\tbridge: \"Bridge Wallet\",\n\t\tmobile: \"Mobile Wallet\",\n\t\t\"instant-link\": \"Instant Wallet\"\n\t}\n};\nvar zh = {\n\tmodal: modal$9\n};\n\nvar modal$8 = {\n\twallet: {\n\t\tconnectYourWallet: \"Свържете вашия Портфейл\",\n\t\twhatIsAWallet: \"Какво е Портфейл?\",\n\t\tsecureAndManage: \"Защитете и управлявайте дигиталните си активи\",\n\t\tsafelyStore: \"Съхранявайте и прехвърляйте безопасно вашите крипто и NFT.\",\n\t\tlogInToAny: \"Използвайте всяко приложение на NEAR\",\n\t\tnoNeedToCreate: \"Няма нужда да създавате нови профили. Свържете портфейла си и сте готови!\",\n\t\tgetAWallet: \"Създайте Портфейл\",\n\t\tuseAWallet: \"Използвайте портфейла, за да защитите и управлявате активите си на NEAR както и да използвате всяко приложение на NEAR без нужда от потребителски имена и пароли.\",\n\t\tconnectionFailed: \"Свързването неуспешно\",\n\t\tconnectionSuccessful: \"Свързването успешно\",\n\t\tconnected: \"Свързан\",\n\t\tconnectingTo: \"Свързване към\",\n\t\tconnectingMessage: {\n\t\t\tinjected: \"Потвърдете свързването в прозореца на разширението\",\n\t\t\tbrowser: \"Потвърдете свързването в портфейла след пренасочването\",\n\t\t\thardware: \"Потвърдете свързването в хардуерния портфейл\",\n\t\t\tbridge: \"Потвърдете връзката в портфейла\"\n\t\t}\n\t},\n\tledger: {\n\t\tconnectWithLedger: \"Свържете се с Ledger\",\n\t\tmakeSureYourLedger: \"Уверете се, че вашият Ledger е свързан и че приложението NEAR е отворено нa него.\",\n\t\t\"continue\": \"Продължете\",\n\t\tspecifyHDPath: \"Посочете HD път\",\n\t\tenterYourPreferredHDPath: \"Въведете предпочитания HD път, след което сканирайте за активни акаунти.\",\n\t\tscan: \"Сканирайте\",\n\t\tretry: \"Опитайте отново\",\n\t\tledgerIsNotAvailable: \"Ledger устройството не е достъпно\",\n\t\taccessDeniedToUseLedgerDevice: \"Достъпът за използване на Ledger е отказан\",\n\t\tnoAccountsFound: \"Няма намерени профили\",\n\t\tselectYourAccounts: \"Изберете вашите профили\",\n\t\tconnecting1Account: \"Свързване на 1 профил\",\n\t\tcantFindAnyAccount: \"Няма намерени профили, съврзани с този Ledger. Моля, създайте нов NEAR профил на\",\n\t\torConnectAnAnotherLedger: \"или свържете друг Ledger.\",\n\t\tconnecting: \"Свързване\",\n\t\tofAccounts: \"от профили\",\n\t\tfailedToAutomatically: \"Автоматичното намиране на профила не бе успешно. Въведете го ръчно:\",\n\t\toverviewTheListOfAuthorized: \"Прегледайте списъка с упълномощени профили, завършете влизането, като щракнете върху бутона по-долу..\",\n\t\tfinish: \"Завършете\"\n\t},\n\tinstall: {\n\t\tyoullNeedToInstall: \"Ще трябва да инсталирате\",\n\t\ttoContinueAfterInstalling: \"за да продължите. След инсталиране\",\n\t\trefreshThePage: \"презаредете страницата.\",\n\t\topen: \"Отворете\"\n\t},\n\tqr: {\n\t\tcopiedToClipboard: \"Копирано в клипборда\",\n\t\tfailedToCopy: \"Неуспешно копиране в клипборда\",\n\t\tscanWithYourMobile: \" Сканирайте с мобилното си устройство\",\n\t\tcopyToClipboard: \" Копирайте в клипборда\",\n\t\tpreferTheOfficial: \"Предпочитан език за кореспонденция\",\n\t\topen: \"Отворете\"\n\t},\n\twalletTypes: {\n\t\thardware: \"Hardware Wallet\",\n\t\tbrowser: \"Browser Wallet\",\n\t\tinjected: \"Wallet Extension\",\n\t\tbridge: \"Bridge Wallet\",\n\t\tmobile: \"Mobile Wallet\",\n\t\t\"instant-link\": \"Instant Wallet\"\n\t}\n};\nvar bg = {\n\tmodal: modal$8\n};\n\nvar modal$7 = {\n\twallet: {\n\t\tconnectYourWallet: \"지갑 연결하기\",\n\t\twhatIsAWallet: \"지갑은 무슨 역할을 하나요?\",\n\t\tsecureAndManage: \"당신의 디지털 자산을 보호하고 관리합니다.\",\n\t\tsafelyStore: \"암호화폐와 NFT를 안전하게 저장하고 전송할 수 있습니다.\",\n\t\tlogInToAny: \"NEAR App에 로그인합니다.\",\n\t\tnoNeedToCreate: \"새로운 계정이나 비밀번호를 만들 필요 없이 지갑을 연결한 후 바로 사용할 수 있습니다.\",\n\t\tgetAWallet: \"지갑 가져오기\",\n\t\tuseAWallet: \"지갑을 사용하여 NEAR 자산을 보호·관리하고, 아이디와 비밀번호 없이 NEAR 앱에 로그인할 수 있습니다.\",\n\t\tconnectionFailed: \"연결 실패\",\n\t\tconnectionSuccessful: \"연결 성공\",\n\t\tconnected: \"Connected\",\n\t\tconnectingTo: \"연결 중: \",\n\t\tconnectingMessage: {\n\t\t\tinjected: \"익스텐션 창에서 연결을 확인하세요\",\n\t\t\tbrowser: \"리다이렉트 된 지갑에서 연결을 확인하세요\",\n\t\t\thardware: \"Ledger 기기에서 연결을 확인하세요\",\n\t\t\tbridge: \"지갑에서 연결 확인\"\n\t\t}\n\t},\n\tledger: {\n\t\tconnectWithLedger: \"Ledger 연결하기\",\n\t\tmakeSureYourLedger: \"Ledger가 안전하게 연결되어 있고, NEAR 앱이 열려 있는 지 확인하세요\",\n\t\t\"continue\": \"계속하기\",\n\t\tspecifyHDPath: \"HD Path 지정하기\",\n\t\tenterYourPreferredHDPath: \"원하는 HD Path를 선택하고, 활성화된 계정이 있는 지 검색하세요\",\n\t\tscan: \"검색\",\n\t\tretry: \"다시 시도\",\n\t\tledgerIsNotAvailable: \"Ledger를 사용할 수 없습니다\",\n\t\taccessDeniedToUseLedgerDevice: \"Ledger 기기 접근 권한이 거부되었습니다\",\n\t\tnoAccountsFound: \"계정을 찾을 수 없습니다\",\n\t\tselectYourAccounts: \"계정 선택하기\",\n\t\tconnecting1Account: \"하나의 계정에 연결\",\n\t\tcantFindAnyAccount: \"Ledger와 연결된 계정을 찾을 수 없습니다. 새로운 계정을 생성하거나 \",\n\t\torConnectAnAnotherLedger: \"다른 Ledger를 연결하세요\",\n\t\tconnecting: \"계정 연결하기: \",\n\t\tofAccounts: \"개 계정을 찾았습니다\",\n\t\tfailedToAutomatically: \"계정 ID를 찾지 못했습니다. 수동으로 입력해주세요.\",\n\t\toverviewTheListOfAuthorized: \"인증된 계정 목록을 확인한 후 아래 버튼을 클릭하여 로그인을 완료하세요\",\n\t\tfinish: \"완료\"\n\t},\n\twalletTypes: {\n\t\thardware: \"하드웨어 지갑\",\n\t\tbrowser: \"브라우저 지갑\",\n\t\tinjected: \"지갑 확장\",\n\t\tbridge: \"브리지 지갑\",\n\t\tmobile: \"모바일 지갑\",\n\t\t\"instant-link\": \"인스턴트 지갑\"\n\t},\n\tinstall: {\n\t\tyoullNeedToInstall: \"다음 확장 프로그램을 설치해주세요:\",\n\t\ttoContinueAfterInstalling: \". 설치 완료 후 페이지 새로 고침이 필요합니다. \",\n\t\trefreshThePage: \"새로 고침\",\n\t\topen: \"Open\"\n\t},\n\tqr: {\n\t\tcopiedToClipboard: \"클립보드에 복사 완료\",\n\t\tfailedToCopy: \"클립보드에 복사 실패\",\n\t\tscanWithYourMobile: \"모바일 장치를 사용하여 스캔해주세요\",\n\t\tcopyToClipboard: \" 클립보드에 복사하기\",\n\t\tpreferTheOfficial: \"다음 프로그램에서 제공하는 공식 프로세스를 선호하십니까: \",\n\t\topen: \"Open\"\n\t}\n};\nvar ko = {\n\tmodal: modal$7\n};\n\nvar modal$6 = {\n\twallet: {\n\t\tconnectYourWallet: \"Kết nối ví của bạn\",\n\t\twhatIsAWallet: \"Ví là gì?\",\n\t\tsecureAndManage: \"Bảo mật & Quản lý tài sản số của bạn\",\n\t\tsafelyStore: \"Lưu trữ và chuyển tiền điện tử và NFT của bạn một cách an toàn.\",\n\t\tlogInToAny: \"Đăng nhập vào bất kỳ ứng dụng trên NEAR\",\n\t\tnoNeedToCreate: \"Không cần tạo tài khoản hoặc thông tin đăng nhập mới. Kết nối ví của bạn và bắt đầu!\",\n\t\tgetAWallet: \"Tạo Ví\",\n\t\tuseAWallet: \"Sử dụng ví để bảo mật và quản lý tài sản trên NEAR của bạn và đăng nhập vào bất kỳ ứng dụng NEAR nào, không cần tên người dùng và mật khẩu.\",\n\t\tconnectionFailed: \"Kết nối thất bại\",\n\t\tconnectionSuccessful: \"Kết nối thành công\",\n\t\tconnected: \"Đã kết nối\",\n\t\tconnectingTo: \"Đang kết nối tới\",\n\t\tconnectingMessage: {\n\t\t\tinjected: \"Xác nhận kết nối trong cửa sổ tiện ích mở rộng\",\n\t\t\tbrowser: \"Xác nhận kết nối trong ví sau khi được chuyển hướng\",\n\t\t\thardware: \"Xác nhận kết nối với ví lạnh\",\n\t\t\tbridge: \"Xác nhận kết nối trong ví\"\n\t\t}\n\t},\n\tledger: {\n\t\tconnectWithLedger: \"Kết nối ví Ledger\",\n\t\tmakeSureYourLedger: \"Đảm bảo Ledger của bạn được kết nối an toàn và ứng dụng NEAR đang mở sẵn trên thiết bị\",\n\t\t\"continue\": \"Tiếp tục\",\n\t\tspecifyHDPath: \"Chỉ định HD Path\",\n\t\tenterYourPreferredHDPath: \"Nhập HD Path của bạn, sau đó quét tìm các tài khoản hoạt động\",\n\t\tscan: \"Quét\",\n\t\tretry: \"Thử lại\",\n\t\tledgerIsNotAvailable: \"Ledger không khả dụng\",\n\t\taccessDeniedToUseLedgerDevice: \"Truy cập Ledger bị từ chối\",\n\t\tnoAccountsFound: \"Không tìm thấy tài khoản\",\n\t\tselectYourAccounts: \"Chọn tài khoản của bạn\",\n\t\tconnecting1Account: \"Đang kết nối 1 tài khoản\",\n\t\tcantFindAnyAccount: \"Không thể tìm thấy bất kỳ tài khoản nào được liên kết với Ledger này. Vui lòng tạo một tài khoản NEAR mới\",\n\t\torConnectAnAnotherLedger: \"hoặc kết nối với ví Ledger khác.\",\n\t\tconnecting: \"Đang kết nối\",\n\t\tofAccounts: \"của tài khoản\",\n\t\tfailedToAutomatically: \"Không thể tự động tìm id tài khoản. Nhập thủ công:\",\n\t\toverviewTheListOfAuthorized: \"Tổng quan danh sách các tài khoản được ủy quyền, hoàn tất đăng nhập bằng cách bấm vào nút bên dưới.\",\n\t\tfinish: \"Hoàn thành\"\n\t},\n\tinstall: {\n\t\tyoullNeedToInstall: \"Bạn sẽ cần cài đặt\",\n\t\ttoContinueAfterInstalling: \"để bắt đầu. Sau khi cài đặt xong\",\n\t\trefreshThePage: \"Tải lại trang.\",\n\t\topen: \"Mở\"\n\t},\n\tqr: {\n\t\tcopiedToClipboard: \"Đã sao chép vào bảng ghi tạm\",\n\t\tfailedToCopy: \"Sao chép vào bảng ghi tạm thất bại\",\n\t\tscanWithYourMobile: \"Quét với điện thoại của bạn\",\n\t\tcopyToClipboard: \" Sao chép vào bảng ghi tạm\",\n\t\tpreferTheOfficial: \"Dialogue chính thức của\",\n\t\topen: \"Mở\"\n\t},\n\twalletTypes: {\n\t\thardware: \"Ví lạnh\",\n\t\tbrowser: \"Ví trình duyệt\",\n\t\tinjected: \"Ví tiện ích mở rộng\",\n\t\tbridge: \"Ví Cầu\",\n\t\tmobile: \"Ví Mobile\",\n\t\t\"instant-link\": \"Ví tức thì\"\n\t},\n\texportAccounts: {\n\t\tchooseAWallet: \"Chọn ví\",\n\t\ttransferYourAccounts: \"Chuyển tài khoản\",\n\t\tselectAWallet: \"Chọn ví phù hợp với nhu cầu của bạn, ví được chọn cần hỗ trợ các tài khoản đang sử dụng.\",\n\t\tselectYourAccounts: \"Chọn tài khoản\",\n\t\tafterDecide: \"Sau khi chọn được tài khoản bạn có chuyển.\",\n\t\tdisclaimer: \"Bạn không thể chuyển tài khoản nếu tài khoản đó chưa được nhận tiền hoặc chưa phát sinh giao dịch trên NEAR.\",\n\t\twarning: \"không hỗ trợ xuất tài khoản. Vui lòng chọn ví khác.\",\n\t\twalletTypes: {\n\t\t\thardware: \"Ví lạnh\",\n\t\t\tbrowser: \"Ví trình duyệt\",\n\t\t\tinjected: \"Ví tiện ích mở rộng\",\n\t\t\tbridge: \"Ví Cầu\",\n\t\t\tmobile: \"Ví Mobile\"\n\t\t},\n\t\tselectAccounts: {\n\t\t\ttitle: \"Chọn tài khoản để chuyển\",\n\t\t\tbutton: \"Lấy cụm mật khẩu\",\n\t\t\tdeselectAll: \"Bỏ chọn tất cả\",\n\t\t\tselectAll: \"Chọn tất cả\",\n\t\t\tunavailable: \"Chuyển không khả dụng\",\n\t\t\terror: \"Tài khoản không tồn tại\",\n\t\t\twarningLedger: \"Yêu cầu hỗ trợ Ledger\",\n\t\t\tnoBalance: \"Tài khoản trống\"\n\t\t},\n\t\tgetPassphrase: {\n\t\t\ttitle: \"Sao chép mật khẩu tạm thời\",\n\t\t\tdesc: \"Bạn sẽ cần nhập mật khẩu khi bắt đầu xuất các khoản tới ví khác.\",\n\t\t\tbutton: \"Tiếp tục\",\n\t\t\tlabel: \"Bấm để sao chép\",\n\t\t\tcheckLabel: \"Tôi đã chép hoặc ghi lại mật khẩu\"\n\t\t},\n\t\tcomplete: {\n\t\t\ttitle: \"Hoàn thành chuyển\",\n\t\t\tdescOne: \"Bạn sẽ được chuyển hướng tới tài khoản đã chọn để hoàn tất quá trình.\",\n\t\t\tdescTwo: \"Sau khi nhập, nhấn nút để hoàn tất quy trình chuyển.\",\n\t\t\tbutton: \"Hoàn thành\"\n\t\t}\n\t}\n};\nvar component = {\n\tclickToCopy: {\n\t\tlabel: \"Đã sao chép\",\n\t\ttooltip: \"Bấm để sao chép\"\n\t}\n};\nvar vi = {\n\tmodal: modal$6,\n\tcomponent: component\n};\n\nvar modal$5 = {\n\twallet: {\n\t\tconnectYourWallet: \"अपना वॉलेट (Wallet) कनेक्ट करें।\",\n\t\twhatIsAWallet: \"वॉलेट क्या है?\",\n\t\tsecureAndManage: \"सुरक्षित और प्रबंधित करें।\",\n\t\tsafelyStore: \"अपनी क्रिप्टोकरेंसी और एनएफटी को सुरक्षित रूप से स्टोर और ट्रांसफर करें।\",\n\t\tlogInToAny: \"NEAR पर किसी भी ऐप में साइन इन करें।\",\n\t\tnoNeedToCreate: \"नए खाते या लॉगिन बनाने की आवश्यकता नहीं है। अपना वॉलेट(NEAR Wallet)कनेक्ट करें और आरंभ करें।\",\n\t\tgetAWallet: \"एक वॉलेट बनाएँ।\",\n\t\tuseAWallet: \"अपनी NEAR संपत्तियों को सुरक्षित और प्रबंधित करने के लिए वॉलेट का उपयोग करें और किसी भी NEAR ऐप (app) में लॉग इन करें, किसी उपयोगकर्ता (user) नाम और पासवर्ड की आवश्यकता नहीं है।\",\n\t\tconnectionFailed: \"कनेक्शन विफल|\",\n\t\tconnectionSuccessful: \"कनेक्शन सफल|\",\n\t\tconnected: \"वॉलेट जुड़ गया|\",\n\t\tconnectingTo: \"वॉलेट जुड़ रहा हे|\",\n\t\tconnectingMessage: {\n\t\t\tinjected: \"एक्सटेंशन विंडो में कनेक्शन की पुष्टि करें|\",\n\t\t\tbrowser: \"रीडायरेक्ट होने के बाद वॉलेट में कनेक्शन की पुष्टि करें|\",\n\t\t\thardware: \"कोल्ड वॉलेट के साथ कनेक्शन की पुष्टि करें|\"\n\t\t}\n\t},\n\tledger: {\n\t\tconnectWithLedger: \"लेजर(Ledger)वॉलेट कनेक्ट करें|\",\n\t\tmakeSureYourLedger: \"सुनिश्चित करें कि आपका लेजर सुरक्षित रूप से जुड़ा हुआ है और NEAR ऐप आपके डिवाइस (Device)पर पहले से ही खुला है|\",\n\t\t\"continue\": \"जारी रखे|\",\n\t\tspecifyHDPath: \"हार्ड डिस्क(Hard Disk)पथ(Path)निर्धारित करे|\",\n\t\tenterYourPreferredHDPath: \"अपना एचडी पथ दर्ज करें, फिर सक्रिय खातों के लिए स्कैन करें|\",\n\t\tscan: \"स्कैन करे|\",\n\t\tretry: \"दोबारा प्रयास करे|\",\n\t\tledgerIsNotAvailable: \"लेजर उपलब्ध नहीं है|\",\n\t\taccessDeniedToUseLedgerDevice: \"लेजर डिवाइस का उपयोग करने के लिए प्रवेश निषेध|\",\n\t\tnoAccountsFound: \"खाता नहीं मिला|\",\n\t\tselectYourAccounts: \"अपने खाते चुनें|\",\n\t\tconnecting1Account: \"एक खाता कनेक्ट हो रहा है|\",\n\t\tcantFindAnyAccount: \"इस लेजर से जुड़ा कोई खाता नहीं मिला। कृपया एक नया NEAR खाता बनाएँ|\",\n\t\torConnectAnAnotherLedger: \"अथवा दूसरे लेजर वॉलेट से कनेक्ट करें।\",\n\t\tconnecting: \"जुड़ रहा हे|\",\n\t\tofAccounts: \"खाता अब जुड़ा नहीं हे|\",\n\t\tfailedToAutomatically: \"खाता आईडी स्वचालित रूप से खोजने में असमर्थ। मैन्युअल (Manuall) रूप से कोशिश करें|\",\n\t\toverviewTheListOfAuthorized: \"अवलोकन अधिकृत की सूची, नीचे दिए गए बटन पर क्लिक करके लॉगिन पूरा करें।\",\n\t\tfinish: \"समाप्त|\"\n\t},\n\tinstall: {\n\t\tyoullNeedToInstall: \"आपको इंस्टॉल करना होगा|\",\n\t\ttoContinueAfterInstalling: \"इंस्टॉल करने के बाद जारी रखे|\",\n\t\trefreshThePage: \"पुन: लोड करें।\",\n\t\topen: \"खोले|\"\n\t},\n\tqr: {\n\t\tcopiedToClipboard: \"क्लिपबोर्ड(Clipboard)पर कॉपी किया गया|\",\n\t\tfailedToCopy: \"क्लिपबोर्ड पर कॉपी करना विफल रहा|\",\n\t\tscanWithYourMobile: \"अपने फोन (Mobile)से स्कैन करें|\",\n\t\tcopyToClipboard: \" क्लिपबोर्ड पर कॉपी करें|\",\n\t\tpreferTheOfficial: \"आधिकारिक संवाद को प्राथमिकता दें|\",\n\t\topen: \"खोले|\"\n\t},\n\twalletTypes: {\n\t\thardware: \"Hardware Wallet\",\n\t\tbrowser: \"Browser Wallet\",\n\t\tinjected: \"Wallet Extension\",\n\t\tbridge: \"Bridge Wallet\",\n\t\tmobile: \"Mobile Wallet\",\n\t\t\"instant-link\": \"Instant Wallet\"\n\t}\n};\nvar hi = {\n\tmodal: modal$5\n};\n\nvar modal$4 = {\n\twallet: {\n\t\tconnectYourWallet: \"صل محفظتك\",\n\t\twhatIsAWallet: \"ما هي المحفظة؟\",\n\t\tsecureAndManage: \"تأمين وإدارة الممتلكات الرقمية الخاصة بك\",\n\t\tsafelyStore: \"قم بتخزين و ارسال عملاتك و أصولك الرقمية بأمان\",\n\t\tlogInToAny: \"سجل الدخول إلى أي تطبيق يستخدم نير\",\n\t\tnoNeedToCreate: \".لا داعي لإنشاء حساب جديد. فقط قم بتوصيل محفظتك وانطلق\",\n\t\tgetAWallet: \"احصل على محفظة\",\n\t\tuseAWallet: \"استخدم محفظة لتأمين وإدارة أصول نير الخاصة بك، وادخل لأي تطبيق يستخدم نير دون الحاجة إلى اسم المستخدم وكلمةالمرور\",\n\t\tconnectionFailed: \"اتصال فاشل\",\n\t\tconnectionSuccessful: \"اتصال ناجح\",\n\t\tconnected: \"متصل\",\n\t\tconnectingTo: \"جاري الاتصال ب\",\n\t\tconnectingMessage: {\n\t\t\tinjected: \"وافق على الاتصال في نافذة الإضافة\",\n\t\t\tbrowser: \"وافق على الاتصال في المحفظة بعد إعادة توجيه\",\n\t\t\thardware: \"وافق على الاتصال في جهاز ليدجر\",\n\t\t\tbridge: \"وافق على الاتصال في المحفظة\"\n\t\t}\n\t},\n\tledger: {\n\t\tconnectWithLedger: \"اتصل مع ليدجر\",\n\t\tmakeSureYourLedger: \"تأكد أن ليدجر متصل بأمان, و أن تطبيق نير مفتوح في جهازك\",\n\t\t\"continue\": \"تابع\",\n\t\tspecifyHDPath: \"حدد مسار الحساب\",\n\t\tenterYourPreferredHDPath: \"أدخل مسار الحساب المفضل، ثم ابحث عن كل الحسابات النشطة\",\n\t\tscan: \"مسح\",\n\t\tretry: \"أعد المحاولة\",\n\t\tledgerIsNotAvailable: \"ليدجر غير متوفر\",\n\t\taccessDeniedToUseLedgerDevice: \"تم رفض الاتصال بليدجر\",\n\t\tnoAccountsFound: \"لم يتم العثور على أي حسابات\",\n\t\tselectYourAccounts: \"حدد حساباتك\",\n\t\tconnecting1Account: \"جاري الاتصال بحساب واحد\",\n\t\tcantFindAnyAccount: \"لا يمكن العثور على أي حساب مرتبط بهذا ليدجر الرجاء إنشاء حساب نير جديد على\",\n\t\torConnectAnAnotherLedger: \"او اربط جهاز ليدجر آخر\",\n\t\tconnecting: \"جاري الاتصال\",\n\t\tofAccounts: \"من الحسابات\",\n\t\tfailedToAutomatically: \"فشل في الاتصال بالحساب تلقائيا. يرجى الاتصال بالحساب يدويا\",\n\t\toverviewTheListOfAuthorized: \"لائحة الحسابات المصرح بها, أكمل تسجيل الدخول بالنقر على الزر أدناه\",\n\t\tfinish: \"إنهاء\"\n\t},\n\tinstall: {\n\t\tyoullNeedToInstall: \"ستحتاج لتثبيت\",\n\t\ttoContinueAfterInstalling: \"للاستكمال. بعد التثبيت\",\n\t\trefreshThePage: \"قم بتحديث الصفحة\",\n\t\topen: \"افتح\"\n\t},\n\tqr: {\n\t\tcopiedToClipboard: \"تم النسخ\",\n\t\tfailedToCopy: \"فشل النسخ\",\n\t\tscanWithYourMobile: \"امسح بجهازك المحمول\",\n\t\tcopyToClipboard: \"نسخ\",\n\t\tpreferTheOfficial: \"تفضل الحوار الرسمي ل\",\n\t\topen: \"فتح\"\n\t},\n\twalletTypes: {\n\t\thardware: \"Hardware Wallet\",\n\t\tbrowser: \"Browser Wallet\",\n\t\tinjected: \"Wallet Extension\",\n\t\tbridge: \"Bridge Wallet\",\n\t\tmobile: \"Mobile Wallet\",\n\t\t\"instant-link\": \"Instant Wallet\"\n\t}\n};\nvar ar = {\n\tmodal: modal$4\n};\n\nvar modal$3 = {\n\twallet: {\n\t\tconnectYourWallet: \"Spojite crypto novčanik!\",\n\t\twhatIsAWallet: \"Što je to crypto novčanik?\",\n\t\tsecureAndManage: \"Osigurajte i upravljajte svojom digitalnom imovinom.\",\n\t\tsafelyStore: \"Sigurno pohranite i prebacite svoj crypto i NFT-eve.\",\n\t\tlogInToAny: \" Prijavite se u bilo koju NEAR aplikaciju\",\n\t\tnoNeedToCreate: \"Nema potrebe za stvaranjem novih naloga ili korisničkih podataka. Spojite svoj crypto novčanik i spremni ste!\",\n\t\tgetAWallet: \"Otvorite crypto novčanik\",\n\t\tuseAWallet: \"Koristite crypto novčanik da biste osigurali i upravljali svojom NEAR imovinom, te se prijavite u bilo koju NEAR aplikaciju bez korisničkog imena i lozinke.\",\n\t\tconnectionFailed: \"Neuspješno povezivanje.\",\n\t\tconnectionSuccessful: \"Uspješno povezivanje.\",\n\t\tconnected: \"Povezano.\",\n\t\tconnectingTo: \"Povezivanje u tijeku\",\n\t\tconnectingMessage: {\n\t\t\tinjected: \"Potvrdite vezu u eksternom prozoru\",\n\t\t\tbrowser: \"Nakon redirekcije, potvrdite vezu u novčaniku\",\n\t\t\thardware: \"Potvrdite vezu sa novčanikom\",\n\t\t\tbridge: \"Potvrdite vezu u novčaniku\"\n\t\t}\n\t},\n\tledger: {\n\t\tconnectWithLedger: \"Povežite se hardverskim novčanikom\",\n\t\tmakeSureYourLedger: \"Osigurajte sigurnu vezu s hardverskim novčanikom, te da je NEAR aplikacija otvorena na vašem uređaju\",\n\t\t\"continue\": \"Nastavite\",\n\t\tspecifyHDPath: \"Specificirajte HD putanju\",\n\t\tenterYourPreferredHDPath: \"Upišite preferiranu HD putanju, zatim skenirajte aktivne naloge\",\n\t\tscan: \"Skenirajte\",\n\t\tretry: \"Pokušajte ponovno\",\n\t\tledgerIsNotAvailable: \"Hardverski novčanik nije dostupan.\",\n\t\taccessDeniedToUseLedgerDevice: \"Odbijen pristup za korištenjem hardverskog novčanika\",\n\t\tnoAccountsFound: \"Nalozi nisu pronađeni\",\n\t\tselectYourAccounts: \"Odaberite svoje naloge\",\n\t\tconnecting1Account: \"Povezivanje 1 naloga\",\n\t\tcantFindAnyAccount: \"Nije moguće pronaći niti jedan nalog povezan s ovim hardverskim novčanikom. Molimo vas, kreirajte novi NEAR nalog\",\n\t\torConnectAnAnotherLedger: \"Ili povežite drugi hardverski novčanik.\",\n\t\tconnecting: \"Povezivanje\",\n\t\tofAccounts: \"naloga\",\n\t\tfailedToAutomatically: \"Neuspješno automatsko pronalaženje ID naloga. Unesite ručno:\",\n\t\toverviewTheListOfAuthorized: \"Pregledajte popis odobrenih naloga, završite prijavu pritiskom na niže prikazani gumb.\",\n\t\tfinish: \"Završite\"\n\t},\n\tinstall: {\n\t\tyoullNeedToInstall: \" Potrebno je instalirati modal\",\n\t\ttoContinueAfterInstalling: \"za nastavak. Nakon instalacije\",\n\t\trefreshThePage: \"osvježite stranicu.\",\n\t\topen: \"Otvorite QR modal\"\n\t},\n\tqr: {\n\t\tcopiedToClipboard: \"Kopirano u međuspremnik\",\n\t\tfailedToCopy: \"Neupsješno kopiranje u međuspremnik\",\n\t\tscanWithYourMobile: \"Skenirajte svojim mobilnim uređajem\",\n\t\tcopyToClipboard: \" Kopirajte u međuspremnik\",\n\t\tpreferTheOfficial: \"Odaberite službeni dijalog\",\n\t\topen: \"Otvorite\"\n\t},\n\twalletTypes: {\n\t\thardware: \"Hardware Wallet\",\n\t\tbrowser: \"Browser Wallet\",\n\t\tinjected: \"Wallet Extension\",\n\t\tbridge: \"Bridge Wallet\",\n\t\tmobile: \"Mobile Wallet\",\n\t\t\"instant-link\": \"Instant Wallet\"\n\t},\n\texportAccounts: {\n\t\tchooseAWallet: \"Odaberi Wallet\",\n\t\ttransferYourAccounts: \"Prenesi svoje naloge\",\n\t\tselectAWallet: \"Odaberite wallet koji odgovara vašim potrebama i podržava vaše povezane naloge.\",\n\t\tselectYourAccounts: \"Odaberi svoje naloge\",\n\t\tafterDecide: \"Nakon što odlučite koji wallet koristite, možete odabrati koje račune želite prebaciti.\",\n\t\tdisclaimer: \"Nećete moći prebaciti naloge koji nisu nikada bili korišteni na NEAR-u.\",\n\t\twarning: \"ne podržava izvoz naloga u ovom trenutku. Molimo odaberite drugi wallet.\",\n\t\twalletTypes: {\n\t\t\thardware: \"Hardware Wallet\",\n\t\t\tbrowser: \"Browser Wallet\",\n\t\t\tinjected: \"Wallet Extension\",\n\t\t\tbridge: \"Bridge Wallet\",\n\t\t\tmobile: \"Mobile Wallet\"\n\t\t},\n\t\tselectAccounts: {\n\t\t\ttitle: \"Odaberi naloge za prijenos\",\n\t\t\tbutton: \"Generiraj lozinku\",\n\t\t\tdeselectAll: \"Makni odabir sa svih\",\n\t\t\tselectAll: \"Odaberi sve\",\n\t\t\tunavailable: \"Prijenos nije dostupan\",\n\t\t\terror: \"Nalog ne postoji\",\n\t\t\twarningLedger: \"Potrebna ledger podrška\",\n\t\t\tnoBalance: \"Nalog nema sredstava\"\n\t\t},\n\t\tgetPassphrase: {\n\t\t\ttitle: \"Kopiraj privremenu lozinku\",\n\t\t\tdesc: \"Bit će potrebno unijeti ovu lozinku na početku izvoza naloga na drugi wallet.\",\n\t\t\tbutton: \"Nastavi\",\n\t\t\tlabel: \"Klikni za kopiju\",\n\t\t\tcheckLabel: \"Kopirao sam ili zapisao lozinku\"\n\t\t},\n\t\tcomplete: {\n\t\t\ttitle: \"Završi prijenos\",\n\t\t\tdescOne: \"You will now be redirected to the wallet you selected to complete the transfer.\",\n\t\t\tdescTwo: \"Kada je unos s odabranog walleta završen, pritisnite gumb da biste završili prijenos.\",\n\t\t\tbutton: \"Završi\"\n\t\t}\n\t}\n};\nvar hr = {\n\tmodal: modal$3\n};\n\nvar modal$2 = {\n\twallet: {\n\t\tconnectYourWallet: \"Поврзете го вашиот новчаник!\",\n\t\twhatIsAWallet: \"Што е новчаник?\",\n\t\tsecureAndManage: \"Заштитете ги и управувајте со вашите дигитални средства.\",\n\t\tsafelyStore: \"Безбедно складирајте и извршувајте трансакции со вашите крипто и NFT.\",\n\t\tlogInToAny: \"Најавете се на која било NEAR апликација\",\n\t\tnoNeedToCreate: \"Нема потреба да креирате нови сметки или ингеренции. Поврзете го вашиот паричник и сте подготвени!\",\n\t\tgetAWallet: \"Направете новчаник\",\n\t\tuseAWallet: \"Користете паричник за да ги заштитите и управувате вашите NEAR средства и да се најавите на која било NEAR апликација без потреба од кориснички имиња и лозинки.\",\n\t\tconnectionFailed: \"Поврзувањето не беше успешно.\",\n\t\tconnectionSuccessful: \"Успешно поврзување.\",\n\t\tconnected: \"Поврзано.\",\n\t\tconnectingTo: \"Поврзување со\",\n\t\tconnectingMessage: {\n\t\t\tinjected: \"Потврдете го поврзувањето во екстерниот прозорец\",\n\t\t\tbrowser: \"По преусмерувањето, потврдете го поврзувањето од новчаниокт\",\n\t\t\thardware: \"Потврдете го поврзувањето со ладен новчаник\",\n\t\t\tbridge: \"Потврдете ја врската во новчаникот\"\n\t\t}\n\t},\n\tledger: {\n\t\tconnectWithLedger: \"Поврзете се со Леџер\",\n\t\tmakeSureYourLedger: \"Осигурајте се дека вашиот Леџер е поврзан безбедно, и дека NEAR апликацијата е отворена на вашиот уред\",\n\t\t\"continue\": \"Продолжете\",\n\t\tspecifyHDPath: \"Наведете ХД локација\",\n\t\tenterYourPreferredHDPath: \"Внесете ја вашата преферирана ХД локација, а потоа скенирајте да ги најдете активните сметки.\",\n\t\tscan: \"Скенирајте\",\n\t\tretry: \"Обидете се повторно\",\n\t\tledgerIsNotAvailable: \"Леџерот не е достапен.\",\n\t\taccessDeniedToUseLedgerDevice: \"Пристапот за користење на Леџер уред е одбиен\",\n\t\tnoAccountsFound: \"Нема најдени сметки\",\n\t\tselectYourAccounts: \"Изберете ги вашите сметки\",\n\t\tconnecting1Account: \"Поврзување на една сметка\",\n\t\tcantFindAnyAccount: \"Не се најдени сметки поврзани со овој Леџер. Ве молиме креирајте нова NEAR сметка \",\n\t\torConnectAnAnotherLedger: \"или поврзете друг Леџер.\",\n\t\tconnecting: \"Поврзување\",\n\t\tofAccounts: \"на сметки\",\n\t\tfailedToAutomatically: \"Неуспешно автоматско барање на ИД на сметката. Внесете го рачно:\",\n\t\toverviewTheListOfAuthorized: \"Преглед на листата на овластени сметки, завршете се најавата со кликнување на копчето подолу.\",\n\t\tfinish: \"Завршете\"\n\t},\n\tinstall: {\n\t\tyoullNeedToInstall: \"Треба да инсталирате\",\n\t\ttoContinueAfterInstalling: \"за да продолжите. По инсталирањето\",\n\t\trefreshThePage: \"Освежете ја страната.\",\n\t\topen: \"Отворете\"\n\t},\n\tqr: {\n\t\tcopiedToClipboard: \"Копирано на клипбордот\",\n\t\tfailedToCopy: \"Неуспешно копирање на клипборд\",\n\t\tscanWithYourMobile: \"Скенирајте со вашиот телефонски уред\",\n\t\tcopyToClipboard: \"Копирајте на клипборд\",\n\t\tpreferTheOfficial: \"Преферирајте официјален диалог на\",\n\t\topen: \"Отворете\"\n\t},\n\twalletTypes: {\n\t\thardware: \"Хардверски новчаник\",\n\t\tbrowser: \"Новчаник на интернет прелистувач\",\n\t\tinjected: \"Екстензија за новчаник\",\n\t\tbridge: \"Bridge новчаник\",\n\t\tmobile: \"Мобилен новчаник\",\n\t\t\"instant-link\": \"Инстант паричник\"\n\t},\n\texportAccounts: {\n\t\tchooseAWallet: \"Одберете паричник\",\n\t\ttransferYourAccounts: \"Префрлете ги вашите кориснички сметки\",\n\t\tselectAWallet: \"Изберетен новчаник кој ги задоволува вашите баранња и ги поддржува вашите поврзани кориснички сметки.\",\n\t\tselectYourAccounts: \"Изберете ги вашите кориснички сметки\",\n\t\tafterDecide: \"Одкако ќе изберете новчаник, можете да изберете кои кориснички сметки сакате да ги префрлите.\",\n\t\tdisclaimer: \"Не можете да прфрлате кориснички сметки кои никогаш не биле надополнати или користени на NEAR.\",\n\t\twarning: \"не поддржува извезување на кориснички сметки во овој момент. Ве молиме изберете друг новчаник.\",\n\t\twalletTypes: {\n\t\t\thardware: \"Хардверски новчаник\",\n\t\t\tbrowser: \"Новчаник на интернет прелистувач\",\n\t\t\tinjected: \"Екстензија за новчаник\",\n\t\t\tbridge: \"Bridge новчаник\",\n\t\t\tmobile: \"Мобилен новчаник\"\n\t\t},\n\t\tselectAccounts: {\n\t\t\ttitle: \"Изберете ги корисничките сметки за да ги префрлите.\",\n\t\t\tbutton: \"Добијте лозинка\",\n\t\t\tdeselectAll: \"Отселектирајте се\",\n\t\t\tselectAll: \"Изберете се\",\n\t\t\tunavailable: \"Трансферот е недостапен\",\n\t\t\terror: \"Корисничката сметка не постои\",\n\t\t\twarningLedger: \"Потребна е поддршка од Леџер\",\n\t\t\tnoBalance: \"Сметката не е финансирана\"\n\t\t},\n\t\tgetPassphrase: {\n\t\t\ttitle: \"Копирајте ја привремената лозинка\",\n\t\t\tdesc: \"Ќе треба да ја внесете оваа лозинка кога ќе започнете да ги извезувате вашите сметки на друг новчаник.\",\n\t\t\tbutton: \"Продолжете\",\n\t\t\tlabel: \"Кликнете за да копирате\",\n\t\t\tcheckLabel: \"Ја копирав или запишав лозинката\"\n\t\t},\n\t\tcomplete: {\n\t\t\ttitle: \"Завршете го преносот\",\n\t\t\tdescOne: \"Сега ќе бидете пренасочени на избраниот новчаник за завршување на преносот.\",\n\t\t\tdescTwo: \"Откако ќе заврши увозот од избраниот новчаник, притиснете го копчето за да го завршите преносот.\",\n\t\t\tbutton: \"Завршете\"\n\t\t}\n\t}\n};\nvar mk = {\n\tmodal: modal$2\n};\n\nvar modal$1 = {\n\twallet: {\n\t\tconnectYourWallet: \"Povežite svojo denarnico!\",\n\t\twhatIsAWallet: \"Kaj je denarnica?\",\n\t\tsecureAndManage: \"Zavarujte in upravljajte svoja digitalna sredstva.\",\n\t\tsafelyStore: \"Varno shranjujte in prenašajte svoje kriptovalute in NFTje.\",\n\t\tlogInToAny: \"Prijavite se v katero koli aplikacijo na NEAR\",\n\t\tnoNeedToCreate: \"Ni vam treba ustvarjati novih računov. Povežite svojo denarnico in začnite!\",\n\t\tgetAWallet: \"Ustvarite denarnico\",\n\t\tuseAWallet: \"Uporabite denarnico, da bi zavarovali in upravljali s svoja NEAR digitalna sredstva, in se prijavite v katero koli aplikacijo ekosistema NEAR\",\n\t\tconnectionFailed: \"Povezava ni bila uspešna.\",\n\t\tconnectionSuccessful: \"Povezava je bila uspešna.\",\n\t\tconnected: \"Vaša denarnica je povezana.\",\n\t\tconnectingTo: \"Povezovanje z\",\n\t\tconnectingMessage: {\n\t\t\tinjected: \"Potrdite povezavo v oknu razširitve\",\n\t\t\tbrowser: \"Po preusmeritvi potrdite povezavo v denarnici\",\n\t\t\thardware: \"Potrdite povezavo s hladno denarnico\",\n\t\t\tbridge: \"Potrdite povezavo v denarnici\"\n\t\t}\n\t},\n\tledger: {\n\t\tconnectWithLedger: \"Povežite se z Ledger\",\n\t\tmakeSureYourLedger: \"Prepričajte se, da je vaš Ledger varno povezan in da je aplikacija NEAR odprta v vaši napravi\",\n\t\t\"continue\": \"Nadaljuj\",\n\t\tspecifyHDPath: \"Določite HD pot\",\n\t\tenterYourPreferredHDPath: \"Vnesite želeno HD pot, nato poiščite vse aktivne račune.\",\n\t\tscan: \"Skenirajte\",\n\t\tretry: \"Poskusite znova\",\n\t\tledgerIsNotAvailable: \"Ledger ni na voljo\",\n\t\taccessDeniedToUseLedgerDevice: \"Dostop za uporabo naprave Ledger zavrnjen\",\n\t\tnoAccountsFound: \"Ni najdenih računov\",\n\t\tselectYourAccounts: \"Izberite Vaši računi\",\n\t\tconnecting1Account: \"Povezovanje enega računa\",\n\t\tcantFindAnyAccount: \"Ni mogoče najti nobenega računa, povezanega s tem Ledgerjem. Ustvarite nov NEAR račun \",\n\t\torConnectAnAnotherLedger: \"ali povežite drug Ledger..\",\n\t\tconnecting: \"Povezovanje\",\n\t\tofAccounts: \"računov\",\n\t\tfailedToAutomatically: \"ID-ja računa ni bilo mogoče samodejno najti. Zagotovite ga ročno:\",\n\t\toverviewTheListOfAuthorized: \"Oglejte si seznam pooblaščenih računov, dokončajte prijavo s klikom na spodnji gumb.\",\n\t\tfinish: \"Končajte\"\n\t},\n\tinstall: {\n\t\tyoullNeedToInstall: \"Morali ga boste namestiti\",\n\t\ttoContinueAfterInstalling: \"nadaljevati. Po namestitvi\",\n\t\trefreshThePage: \"Osvežite stran.\",\n\t\topen: \"Odprite\"\n\t},\n\tqr: {\n\t\tcopiedToClipboard: \"Kopirano v podložni mapi\",\n\t\tfailedToCopy: \"Kopiranje v podložni mapi ni uspelo\",\n\t\tscanWithYourMobile: \"Skenirajte s svojo mobilno napravo\",\n\t\tcopyToClipboard: \" Kopirajte v podložni mapi\",\n\t\tpreferTheOfficial: \"Preferirajte uradno pogovorno okno\",\n\t\topen: \"Odprite\"\n\t},\n\twalletTypes: {\n\t\thardware: \"Hladna denarnica\",\n\t\tbrowser: \"Denarnica brskalnika\",\n\t\tinjected: \"Razširitev za denarnico\",\n\t\tbridge: \"Bridge denarnica\",\n\t\tmobile: \"Mobilna denarnica\",\n\t\t\"instant-link\": \"Takojšnja denarnica\"\n\t},\n\texportAccounts: {\n\t\tchooseAWallet: \"Izberite denarnico\",\n\t\ttransferYourAccounts: \"Prenesite svoje račune\",\n\t\tselectAWallet: \"Izberite denarnico, ki ustreza vašim potrebam in podpira vaše povezane račune.\",\n\t\tselectYourAccounts: \"Izberite vaši računi\",\n\t\tafterDecide: \"Ko se odločite za denarnico, lahko izberete, katere račune želite prenesti.\",\n\t\tdisclaimer: \"Ne boste mogli prenesti Računov, ki nikoli niso bili financirani ali uporabljeni na NEAR.\",\n\t\twarning: \"trenutno ne podpira izvoza računa. Izberite drugo denarnico\",\n\t\twalletTypes: {\n\t\t\thardware: \"Hladna denarnica\",\n\t\t\tbrowser: \"Denarnica brskalnika\",\n\t\t\tinjected: \"Razširitev za denarnico\",\n\t\t\tbridge: \"Bridge denarnica\",\n\t\t\tmobile: \"Mobilna denarnica\"\n\t\t},\n\t\tselectAccounts: {\n\t\t\ttitle: \"Izberite računi za prenos.\",\n\t\t\tbutton: \"Pridobite geslo\",\n\t\t\tdeselectAll: \"Prekliči izbiro vseh\",\n\t\t\tselectAll: \"Izberi vse\",\n\t\t\tunavailable: \"Prenos ni na voljo\",\n\t\t\terror: \"Račun ne obstaja\",\n\t\t\twarningLedger: \"Potrebna je podpora za Ledger\",\n\t\t\tnoBalance: \"Račun ni financiran\"\n\t\t},\n\t\tgetPassphrase: {\n\t\t\ttitle: \"Kopiraj začasno geslo\",\n\t\t\tdesc: \"To geslo boste morali vnesti, ko boste začeli izvažati svoje račune v drugo denarnico.\",\n\t\t\tbutton: \"Nadaljujte\",\n\t\t\tlabel: \"Kliknite za kopiranje\",\n\t\t\tcheckLabel: \"Geslo sem kopiral ali zapisal\"\n\t\t},\n\t\tcomplete: {\n\t\t\ttitle: \"Dokončajte prenos\",\n\t\t\tdescOne: \"Zdaj boste preusmerjeni v denarnico, ki ste jo izbrali za dokončanje prenosa.\",\n\t\t\tdescTwo: \"Ko je uvozni del postopka končan iz izbrane denarnice, pritisnite gumb za dokončanje postopka prenosa.\",\n\t\t\tbutton: \"Končajte\"\n\t\t}\n\t}\n};\nvar sl = {\n\tmodal: modal$1\n};\n\nvar modal = {\n\twallet: {\n\t\tconnectYourWallet: \"Повежите свој новчаник!\",\n\t\twhatIsAWallet: \"Шта је новчаник?\",\n\t\tsecureAndManage: \"Обезбедите и управљајте својом дигиталном имовином.\",\n\t\tsafelyStore: \"Безбедно чувајте и преносите своје криптовалуте и NFT.\",\n\t\tlogInToAny: \"Пријавите се на било коју апликацију NEAR\",\n\t\tnoNeedToCreate: \"Нема потребе да креирате нове налоге или акредитиве. Повежите новчаник и спремни стe!\",\n\t\tgetAWallet: \"Набавите новчаник\",\n\t\tuseAWallet: \"Користите новчаник да обезбедите и управљате својим NEAR средствима и да се пријавите у било коју апликацију NEAR без потребе за корисничким именима и лозинкама.\",\n\t\tconnectionFailed: \"Веза није успостављена.\",\n\t\tconnectionSuccessful: \"Веза је успела.\",\n\t\tconnected: \"Повезан.\",\n\t\tconnectingTo: \"Повезивање на\",\n\t\tconnectingMessage: {\n\t\t\tinjected: \"Потврдите везу у спољном прозору\",\n\t\t\tbrowser: \"Након преусмеравања, потврдите везу у новчанику\",\n\t\t\thardware: \"Потврдите везу са хладним новчаником\",\n\t\t\tbridge: \"Потврдите везу са новчаником\"\n\t\t}\n\t},\n\tledger: {\n\t\tconnectWithLedger: \"Повежите се са Ledger\",\n\t\tmakeSureYourLedger: \"Уверите се да је ваш Ledger безбедно повезан и да је апликација NEAR отворена на вашем уређају\",\n\t\t\"continue\": \"Настави\",\n\t\tspecifyHDPath: \"Наведите ХД путању\",\n\t\tenterYourPreferredHDPath: \"Унесите жељену жељену ХД путању, а затим скенирајте све активне налоге.\",\n\t\tscan: \"Скенирајте\",\n\t\tretry: \"Покушај поново\",\n\t\tledgerIsNotAvailable: \"Ledger није доступан.\",\n\t\taccessDeniedToUseLedgerDevice: \"Приступ је одбијен за коришћење Ledger уређаја\",\n\t\tnoAccountsFound: \"Наlози нису пронађени\",\n\t\tselectYourAccounts: \"Изаберите Ваш наlог\",\n\t\tconnecting1Account: \"Повезати 1 наlог\",\n\t\tcantFindAnyAccount: \"Није могуће пронаћи ниједан наlог повезан са овим Ledger-ом. Направите нови NEAR наlог\",\n\t\torConnectAnAnotherLedger: \"или повежите други Ledger.\",\n\t\tconnecting: \"Повезивање\",\n\t\tofAccounts: \"наlога\",\n\t\tfailedToAutomatically: \"Аутоматско проналажење ID-a наlога није успело. Наведите га ручно:\",\n\t\toverviewTheListOfAuthorized: \"Прегледајте листу овлашћених рачуна, завршите пријаву кликом на дугме испод.\",\n\t\tfinish: \"Заврши\"\n\t},\n\tinstall: {\n\t\tyoullNeedToInstall: \"Мораћете да инсталирате\",\n\t\ttoContinueAfterInstalling: \"за наставак. Након инсталирања\",\n\t\trefreshThePage: \"поново учитати страницу.\",\n\t\topen: \"Отвори\"\n\t},\n\tqr: {\n\t\tcopiedToClipboard: \"Копирано у међуспремник\",\n\t\tfailedToCopy: \"Копирање у међуспремник није успело\",\n\t\tscanWithYourMobile: \"Скенирајте помоћу мобилног уређаја\",\n\t\tcopyToClipboard: \" Копирај у међуспремник\",\n\t\tpreferTheOfficial: \"Преферирате званични дијалог од\",\n\t\topen: \"Отвори\"\n\t},\n\twalletTypes: {\n\t\thardware: \"Хардверски новчаник\",\n\t\tbrowser: \"Новчаник претраживача,\",\n\t\tinjected: \"Додатак за новчаник,\",\n\t\tbridge: \"Bridge новчаник\",\n\t\tmobile: \"Мобилни новчаник\",\n\t\t\"instant-link\": \"Инстант новчаник\"\n\t},\n\texportAccounts: {\n\t\tchooseAWallet: \"Изаберите новчаник\",\n\t\ttransferYourAccounts: \"Пренесите своје налоге\",\n\t\tselectAWallet: \"Изаберите новчаник који одговара вашим потребама и који подржава ваше повезане налоге.\",\n\t\tselectYourAccounts: \"Изаберите ваше налоге\",\n\t\tafterDecide: \"Након што се одлучите за новчаник, можете изабрати које налоге желите да пренесете.\",\n\t\tdisclaimer: \"Нећете моћи да пренесете налоге који никада нису били финансирани или коришћени на  NEAR.\",\n\t\twarning: \"тренутно не подржава извоз налога. Изаберите други новчаник.\",\n\t\twalletTypes: {\n\t\t\thardware: \"Хардверски новчаник\",\n\t\t\tbrowser: \"Новчаник претраживача,\",\n\t\t\tinjected: \"Додатак за новчаник,\",\n\t\t\tbridge: \"Bridge новчаник\",\n\t\t\tmobile: \"Мобилни новчаник\"\n\t\t},\n\t\tselectAccounts: {\n\t\t\ttitle: \"Изаберите налоге за пренос.\",\n\t\t\tbutton: \"Добијте приступну фразу\",\n\t\t\tdeselectAll: \"Поништите избор\",\n\t\t\tselectAll: \"Изаберите све\",\n\t\t\tunavailable: \"Трансфер није доступан\",\n\t\t\terror: \"Налог не постоји\",\n\t\t\twarningLedger: \"Потребна подршка за Ledger\",\n\t\t\tnoBalance: \"Налог није финансиран\"\n\t\t},\n\t\tgetPassphrase: {\n\t\t\ttitle: \"Копирај привремену лозинку\",\n\t\t\tdesc: \"Мораћете да унесете ову лозинку када почнете да извозите своје налоге у други новчаник.\",\n\t\t\tbutton: \"Наставите\",\n\t\t\tlabel: \"Кликните да бисте копирали\",\n\t\t\tcheckLabel: \"Копирао сам или записао лозинку\"\n\t\t},\n\t\tcomplete: {\n\t\t\ttitle: \"Довршите трансфер\",\n\t\t\tdescOne: \"Сада ћете бити преусмерени на новчаник који сте изабрали да завршите трансфер.\",\n\t\t\tdescTwo: \"Када се део процеса увоза заврши из изабраног новчаника, притисните дугме да завршите процес преноса.\",\n\t\t\tbutton: \"Завршите\"\n\t\t}\n\t}\n};\nvar sr = {\n\tmodal: modal\n};\n\nconst getLanguage = languageCode => {\n  switch (languageCode) {\n    case \"en\":\n      return en;\n    case \"es\":\n      return es;\n    case \"zh\":\n      return zh;\n    case \"bg\":\n      return bg;\n    case \"ko\":\n      return ko;\n    case \"vi\":\n      return vi;\n    case \"hi\":\n      return hi;\n    case \"ar\":\n      return ar;\n    case \"hr\":\n      return hr;\n    case \"mk\":\n      return mk;\n    case \"sl\":\n      return sl;\n    case \"sr\":\n      return sr;\n    default:\n      return en;\n  }\n};\nlet chosenLang;\nconst allowOnlyLanguage = langCode => {\n  chosenLang = langCode;\n};\n// (i.e en-CA returns just en)\nconst shortenLanguageCode = lang => {\n  return lang.indexOf(\"-\") !== -1 ? lang.split(\"-\")[0] : lang.split(\"_\")[0];\n};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst findObjectPropByStringPath = (obj, prop) => {\n  if (!obj) {\n    return \"\";\n  }\n  const _index = prop.indexOf(\".\");\n  if (_index > -1) {\n    const currentProp = prop.substring(0, _index);\n    const nextProp = prop.substring(_index + 1);\n    return findObjectPropByStringPath(obj[currentProp], nextProp);\n  }\n  return obj[prop];\n};\nconst translate = path => {\n  let browserLang = window.navigator.languages ? window.navigator.languages[0] : null;\n  browserLang = browserLang || window.navigator.language;\n  const languageCode = shortenLanguageCode(chosenLang || browserLang);\n  const selectedLanguage = getLanguage(languageCode);\n  const text = findObjectPropByStringPath(selectedLanguage, path);\n  return text && typeof text === \"string\" ? text : path;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5lYXItd2FsbGV0LXNlbGVjdG9yL2NvcmUvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBdUM7QUFDUTtBQUNTO0FBQ0Y7QUFDcEI7QUFDQzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixrREFBaUI7QUFDekM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsY0FBYzs7QUFFL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsT0FBTyxtQkFBbUIsYUFBYTtBQUN4RSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsYUFBYTtBQUN6QztBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQSw4RUFBOEUsTUFBTTs7QUFFcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlDQUFpQztBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDBDQUEwQzs7QUFFMUM7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtB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QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRSxnQkFBZ0I7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELHFCQUFxQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLElBQUk7QUFDSixhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsYUFBYTtBQUNqRjtBQUNBLHVCQUF1QixhQUFhLGdCQUFnQixhQUFhO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxhQUFhO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUixNQUFNO0FBQ04sSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZUFBZTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU0sa0ZBQWtGO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsY0FBYztBQUM3RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLDRFQUE0RTtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLHFFQUFxRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxtRUFBbUU7QUFDekU7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdCQUFnQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQSxrRUFBa0UsMkRBQTJEO0FBQzdIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCOztBQUUvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLDhDQUE4QztBQUM5QyxnREFBZ0Q7QUFDaEQsTUFBTSxxQkFBcUI7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQixvQkFBb0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sV0FBVyxvRkFBb0Y7QUFDckc7O0FBRUE7QUFDQTtBQUNBLHNFQUFzRSxlQUFlO0FBQ3JGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSwrQkFBK0I7QUFDL0IsaUNBQWlDO0FBQ2pDLFdBQVc7QUFDWCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUMsaUJBQWlCO0FBQ3RELEVBQUUsZ0JBQWdCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLE1BQU0sd0RBQXdEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNLGlCQUFpQjtBQUN2QixJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLDBFQUEwRTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QiwrQ0FBK0M7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QixxQkFBcUI7QUFDOUM7QUFDQTtBQUNBLHlCQUF5QixvQkFBb0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sdUVBQXVFO0FBQzdFO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsTUFBTSw2QkFBNkI7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUcsS0FBSyxNQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsZUFBZTtBQUM3RCxtQkFBbUIsMENBQTBDO0FBQzdELENBQUMsc0NBQXNDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTSwwRUFBMEU7QUFDaEY7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSx1QkFBdUIsZ0RBQWM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFVBQVU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGtFQUFrRSxxQkFBcUI7QUFDdkY7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0IsS0FBSyxRQUFRO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7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REFBNkQ7QUFDdHJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlCQUFpQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnQkFBZ0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0JBQWdCO0FBQ3hCLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxZQUFZO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0RBQWdELG1CQUFtQix5Q0FBeUM7QUFDNUc7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFdBQVc7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMEVBQTBFLGdCQUFnQjtBQUMxRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRyxJQUFJLGNBQWM7QUFDckI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsTUFBTSwyRUFBMkU7QUFDakY7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLENBQUM7O0FBRUQsNkJBQTZCOztBQUU3Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzQkFBc0Isa0VBQWtFO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGdCQUFnQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQSw0Q0FBNEM7QUFDNUMsNENBQTRDO0FBQzVDLDRDQUE0QztBQUM1Qyw4Q0FBOEM7QUFDOUMsVUFBVTtBQUNWLDRDQUE0QztBQUM1Qyw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNLGtFQUFrRTtBQUN4RTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLFFBQVEsbUZBQW1GOztBQUUzRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFLG1EQUFtRDs7QUFFckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1QkFBdUIsbUJBQW1CO0FBQ3BFO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxnQ0FBZ0M7QUFDaEMsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixhQUFhO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVILGtCQUFrQixhQUFhO0FBQy9CO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQSw4Q0FBOEM7QUFDOUMscUJBQXFCLGdEQUFTO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHVCQUF1QixnREFBUztBQUNoQztBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsNkNBQU07QUFDOUM7QUFDQTtBQUNBLGFBQWEsOENBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsdUJBQXVCLGtEQUFTO0FBQ2hDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIsbUJBQW1COztBQUUvQztBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsZUFBZTtBQUNmLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRjtBQUNoRjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsMEJBQTBCLG1CQUFtQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFK0wiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9udXJzZWJsb2MvLi9ub2RlX21vZHVsZXMvQG5lYXItd2FsbGV0LXNlbGVjdG9yL2NvcmUvaW5kZXguanM/ZjgzMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBuZWFyQVBJIGZyb20gJ25lYXItYXBpLWpzJztcbmltcG9ydCB7IHV0aWxzLCBwcm92aWRlcnMgfSBmcm9tICduZWFyLWFwaS1qcyc7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgYXMgRXZlbnRFbWl0dGVyJDEgfSBmcm9tICdldmVudHMnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0LCBTdWJqZWN0LCBzY2FuIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBzZXJpYWxpemUgfSBmcm9tICdib3JzaCc7XG5pbXBvcnQgeyBzaGEyNTYgfSBmcm9tICdqcy1zaGEyNTYnO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHJcbmZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbnR5cGVvZiBTdXBwcmVzc2VkRXJyb3IgPT09IFwiZnVuY3Rpb25cIiA/IFN1cHByZXNzZWRFcnJvciA6IGZ1bmN0aW9uIChlcnJvciwgc3VwcHJlc3NlZCwgbWVzc2FnZSkge1xyXG4gICAgdmFyIGUgPSBuZXcgRXJyb3IobWVzc2FnZSk7XHJcbiAgICByZXR1cm4gZS5uYW1lID0gXCJTdXBwcmVzc2VkRXJyb3JcIiwgZS5lcnJvciA9IGVycm9yLCBlLnN1cHByZXNzZWQgPSBzdXBwcmVzc2VkLCBlO1xyXG59O1xuXG5jbGFzcyBQcm92aWRlciB7XG4gIGNvbnN0cnVjdG9yKHVybCkge1xuICAgIHRoaXMucHJvdmlkZXIgPSBuZXcgbmVhckFQSS5wcm92aWRlcnMuSnNvblJwY1Byb3ZpZGVyKHtcbiAgICAgIHVybFxuICAgIH0pO1xuICB9XG4gIHF1ZXJ5KHBhcmFtcykge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLnF1ZXJ5KHBhcmFtcyk7XG4gIH1cbiAgdmlld0FjY2Vzc0tleSh7XG4gICAgYWNjb3VudElkLFxuICAgIHB1YmxpY0tleVxuICB9KSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnkoe1xuICAgICAgcmVxdWVzdF90eXBlOiBcInZpZXdfYWNjZXNzX2tleVwiLFxuICAgICAgZmluYWxpdHk6IFwiZmluYWxcIixcbiAgICAgIGFjY291bnRfaWQ6IGFjY291bnRJZCxcbiAgICAgIHB1YmxpY19rZXk6IHB1YmxpY0tleVxuICAgIH0pO1xuICB9XG4gIGJsb2NrKHJlZmVyZW5jZSkge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLmJsb2NrKHJlZmVyZW5jZSk7XG4gIH1cbiAgc2VuZFRyYW5zYWN0aW9uKHNpZ25lZFRyYW5zYWN0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuc2VuZFRyYW5zYWN0aW9uKHNpZ25lZFRyYW5zYWN0aW9uKTtcbiAgfVxufVxuXG5jb25zdCBLRVlfREVMSU1JVEVSID0gXCI6XCI7XG5jbGFzcyBKc29uU3RvcmFnZSB7XG4gIGNvbnN0cnVjdG9yKHN0b3JhZ2UsIG5hbWVzcGFjZSkge1xuICAgIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XG4gICAgdGhpcy5uYW1lc3BhY2UgPSBBcnJheS5pc0FycmF5KG5hbWVzcGFjZSkgPyBuYW1lc3BhY2Uuam9pbihLRVlfREVMSU1JVEVSKSA6IG5hbWVzcGFjZTtcbiAgfVxuICByZXNvbHZlS2V5KGtleSkge1xuICAgIHJldHVybiBbdGhpcy5uYW1lc3BhY2UsIGtleV0uam9pbihLRVlfREVMSU1JVEVSKTtcbiAgfVxuICBnZXRJdGVtKGtleSkge1xuICAgIHJldHVybiB0aGlzLnN0b3JhZ2UuZ2V0SXRlbSh0aGlzLnJlc29sdmVLZXkoa2V5KSkudGhlbihpdGVtID0+IHtcbiAgICAgIHJldHVybiB0eXBlb2YgaXRlbSA9PT0gXCJzdHJpbmdcIiA/IEpTT04ucGFyc2UoaXRlbSkgOiBudWxsO1xuICAgIH0pO1xuICB9XG4gIHNldEl0ZW0oa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLnN0b3JhZ2Uuc2V0SXRlbSh0aGlzLnJlc29sdmVLZXkoa2V5KSwgSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbiAgfVxuICByZW1vdmVJdGVtKGtleSkge1xuICAgIHJldHVybiB0aGlzLnN0b3JhZ2UucmVtb3ZlSXRlbSh0aGlzLnJlc29sdmVLZXkoa2V5KSk7XG4gIH1cbn1cblxudmFyIGNvbW1vbmpzR2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge307XG5cbnZhciBjaGVjayA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgJiYgaXQuTWF0aCA9PSBNYXRoICYmIGl0O1xufTtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwkdCA9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLWdsb2JhbC10aGlzIC0tIHNhZmVcbiAgY2hlY2sodHlwZW9mIGdsb2JhbFRoaXMgPT0gJ29iamVjdCcgJiYgZ2xvYmFsVGhpcykgfHxcbiAgY2hlY2sodHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cpIHx8XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHMgLS0gc2FmZVxuICBjaGVjayh0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmKSB8fFxuICBjaGVjayh0eXBlb2YgY29tbW9uanNHbG9iYWwgPT0gJ29iamVjdCcgJiYgY29tbW9uanNHbG9iYWwpIHx8XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuYyAtLSBmYWxsYmFja1xuICAoZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSkoKSB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG52YXIgb2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0ge307XG5cbnZhciBmYWlscyRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cbnZhciBmYWlscyRyID0gZmFpbHMkcztcblxuLy8gRGV0ZWN0IElFOCdzIGluY29tcGxldGUgZGVmaW5lUHJvcGVydHkgaW1wbGVtZW50YXRpb25cbnZhciBkZXNjcmlwdG9ycyA9ICFmYWlscyRyKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sIDEsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pWzFdICE9IDc7XG59KTtcblxudmFyIGZhaWxzJHEgPSBmYWlscyRzO1xuXG52YXIgZnVuY3Rpb25CaW5kTmF0aXZlID0gIWZhaWxzJHEoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1mdW5jdGlvbi1wcm90b3R5cGUtYmluZCAtLSBzYWZlXG4gIHZhciB0ZXN0ID0gKGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSkuYmluZCgpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zIC0tIHNhZmVcbiAgcmV0dXJuIHR5cGVvZiB0ZXN0ICE9ICdmdW5jdGlvbicgfHwgdGVzdC5oYXNPd25Qcm9wZXJ0eSgncHJvdG90eXBlJyk7XG59KTtcblxudmFyIE5BVElWRV9CSU5EJDMgPSBmdW5jdGlvbkJpbmROYXRpdmU7XG5cbnZhciBjYWxsJGwgPSBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbDtcblxudmFyIGZ1bmN0aW9uQ2FsbCA9IE5BVElWRV9CSU5EJDMgPyBjYWxsJGwuYmluZChjYWxsJGwpIDogZnVuY3Rpb24gKCkge1xuICByZXR1cm4gY2FsbCRsLmFwcGx5KGNhbGwkbCwgYXJndW1lbnRzKTtcbn07XG5cbnZhciBvYmplY3RQcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHt9O1xuXG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbi8vIE5hc2hvcm4gfiBKREs4IGJ1Z1xudmFyIE5BU0hPUk5fQlVHID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDIgJiYgISRwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHsgMTogMiB9LCAxKTtcblxuLy8gYE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGVgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QucHJvdG90eXBlLnByb3BlcnR5aXNlbnVtZXJhYmxlXG5vYmplY3RQcm9wZXJ0eUlzRW51bWVyYWJsZS5mID0gTkFTSE9STl9CVUcgPyBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShWKSB7XG4gIHZhciBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDIodGhpcywgVik7XG4gIHJldHVybiAhIWRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci5lbnVtZXJhYmxlO1xufSA6ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQ1ID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn07XG5cbnZhciBOQVRJVkVfQklORCQyID0gZnVuY3Rpb25CaW5kTmF0aXZlO1xuXG52YXIgRnVuY3Rpb25Qcm90b3R5cGUkMiA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbnZhciBiaW5kJDcgPSBGdW5jdGlvblByb3RvdHlwZSQyLmJpbmQ7XG52YXIgY2FsbCRrID0gRnVuY3Rpb25Qcm90b3R5cGUkMi5jYWxsO1xudmFyIHVuY3VycnlUaGlzJHAgPSBOQVRJVkVfQklORCQyICYmIGJpbmQkNy5iaW5kKGNhbGwkaywgY2FsbCRrKTtcblxudmFyIGZ1bmN0aW9uVW5jdXJyeVRoaXMgPSBOQVRJVkVfQklORCQyID8gZnVuY3Rpb24gKGZuKSB7XG4gIHJldHVybiBmbiAmJiB1bmN1cnJ5VGhpcyRwKGZuKTtcbn0gOiBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIGZuICYmIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY2FsbCRrLmFwcGx5KGZuLCBhcmd1bWVudHMpO1xuICB9O1xufTtcblxudmFyIHVuY3VycnlUaGlzJG8gPSBmdW5jdGlvblVuY3VycnlUaGlzO1xuXG52YXIgdG9TdHJpbmckNyA9IHVuY3VycnlUaGlzJG8oe30udG9TdHJpbmcpO1xudmFyIHN0cmluZ1NsaWNlJDMgPSB1bmN1cnJ5VGhpcyRvKCcnLnNsaWNlKTtcblxudmFyIGNsYXNzb2ZSYXckMSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gc3RyaW5nU2xpY2UkMyh0b1N0cmluZyQ3KGl0KSwgOCwgLTEpO1xufTtcblxudmFyIHVuY3VycnlUaGlzJG4gPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGZhaWxzJHAgPSBmYWlscyRzO1xudmFyIGNsYXNzb2YkYiA9IGNsYXNzb2ZSYXckMTtcblxudmFyICRPYmplY3QkNCA9IE9iamVjdDtcbnZhciBzcGxpdCA9IHVuY3VycnlUaGlzJG4oJycuc3BsaXQpO1xuXG4vLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xudmFyIGluZGV4ZWRPYmplY3QgPSBmYWlscyRwKGZ1bmN0aW9uICgpIHtcbiAgLy8gdGhyb3dzIGFuIGVycm9yIGluIHJoaW5vLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvcmhpbm8vaXNzdWVzLzM0NlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zIC0tIHNhZmVcbiAgcmV0dXJuICEkT2JqZWN0JDQoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKTtcbn0pID8gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBjbGFzc29mJGIoaXQpID09ICdTdHJpbmcnID8gc3BsaXQoaXQsICcnKSA6ICRPYmplY3QkNChpdCk7XG59IDogJE9iamVjdCQ0O1xuXG52YXIgJFR5cGVFcnJvciRmID0gVHlwZUVycm9yO1xuXG4vLyBgUmVxdWlyZU9iamVjdENvZXJjaWJsZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXJlcXVpcmVvYmplY3Rjb2VyY2libGVcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDYgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ID09IHVuZGVmaW5lZCkgdGhyb3cgJFR5cGVFcnJvciRmKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gXCIgKyBpdCk7XG4gIHJldHVybiBpdDtcbn07XG5cbi8vIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSW5kZXhlZE9iamVjdCQzID0gaW5kZXhlZE9iamVjdDtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDUgPSByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDY7XG5cbnZhciB0b0luZGV4ZWRPYmplY3QkNiA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gSW5kZXhlZE9iamVjdCQzKHJlcXVpcmVPYmplY3RDb2VyY2libGUkNShpdCkpO1xufTtcblxuLy8gYElzQ2FsbGFibGVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1pc2NhbGxhYmxlXG52YXIgaXNDYWxsYWJsZSRuID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiB0eXBlb2YgYXJndW1lbnQgPT0gJ2Z1bmN0aW9uJztcbn07XG5cbnZhciBpc0NhbGxhYmxlJG0gPSBpc0NhbGxhYmxlJG47XG5cbnZhciBpc09iamVjdCRkID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IGlzQ2FsbGFibGUkbShpdCk7XG59O1xuXG52YXIgZ2xvYmFsJHMgPSBnbG9iYWwkdDtcbnZhciBpc0NhbGxhYmxlJGwgPSBpc0NhbGxhYmxlJG47XG5cbnZhciBhRnVuY3Rpb24gPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIGlzQ2FsbGFibGUkbChhcmd1bWVudCkgPyBhcmd1bWVudCA6IHVuZGVmaW5lZDtcbn07XG5cbnZhciBnZXRCdWlsdEluJDggPSBmdW5jdGlvbiAobmFtZXNwYWNlLCBtZXRob2QpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPCAyID8gYUZ1bmN0aW9uKGdsb2JhbCRzW25hbWVzcGFjZV0pIDogZ2xvYmFsJHNbbmFtZXNwYWNlXSAmJiBnbG9iYWwkc1tuYW1lc3BhY2VdW21ldGhvZF07XG59O1xuXG52YXIgdW5jdXJyeVRoaXMkbSA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG5cbnZhciBvYmplY3RJc1Byb3RvdHlwZU9mID0gdW5jdXJyeVRoaXMkbSh7fS5pc1Byb3RvdHlwZU9mKTtcblxudmFyIGdldEJ1aWx0SW4kNyA9IGdldEJ1aWx0SW4kODtcblxudmFyIGVuZ2luZVVzZXJBZ2VudCA9IGdldEJ1aWx0SW4kNygnbmF2aWdhdG9yJywgJ3VzZXJBZ2VudCcpIHx8ICcnO1xuXG52YXIgZ2xvYmFsJHIgPSBnbG9iYWwkdDtcbnZhciB1c2VyQWdlbnQkNSA9IGVuZ2luZVVzZXJBZ2VudDtcblxudmFyIHByb2Nlc3MkMyA9IGdsb2JhbCRyLnByb2Nlc3M7XG52YXIgRGVubyQxID0gZ2xvYmFsJHIuRGVubztcbnZhciB2ZXJzaW9ucyA9IHByb2Nlc3MkMyAmJiBwcm9jZXNzJDMudmVyc2lvbnMgfHwgRGVubyQxICYmIERlbm8kMS52ZXJzaW9uO1xudmFyIHY4ID0gdmVyc2lvbnMgJiYgdmVyc2lvbnMudjg7XG52YXIgbWF0Y2gsIHZlcnNpb247XG5cbmlmICh2OCkge1xuICBtYXRjaCA9IHY4LnNwbGl0KCcuJyk7XG4gIC8vIGluIG9sZCBDaHJvbWUsIHZlcnNpb25zIG9mIFY4IGlzbid0IFY4ID0gQ2hyb21lIC8gMTBcbiAgLy8gYnV0IHRoZWlyIGNvcnJlY3QgdmVyc2lvbnMgYXJlIG5vdCBpbnRlcmVzdGluZyBmb3IgdXNcbiAgdmVyc2lvbiA9IG1hdGNoWzBdID4gMCAmJiBtYXRjaFswXSA8IDQgPyAxIDogKyhtYXRjaFswXSArIG1hdGNoWzFdKTtcbn1cblxuLy8gQnJvd3NlckZTIE5vZGVKUyBgcHJvY2Vzc2AgcG9seWZpbGwgaW5jb3JyZWN0bHkgc2V0IGAudjhgIHRvIGAwLjBgXG4vLyBzbyBjaGVjayBgdXNlckFnZW50YCBldmVuIGlmIGAudjhgIGV4aXN0cywgYnV0IDBcbmlmICghdmVyc2lvbiAmJiB1c2VyQWdlbnQkNSkge1xuICBtYXRjaCA9IHVzZXJBZ2VudCQ1Lm1hdGNoKC9FZGdlXFwvKFxcZCspLyk7XG4gIGlmICghbWF0Y2ggfHwgbWF0Y2hbMV0gPj0gNzQpIHtcbiAgICBtYXRjaCA9IHVzZXJBZ2VudCQ1Lm1hdGNoKC9DaHJvbWVcXC8oXFxkKykvKTtcbiAgICBpZiAobWF0Y2gpIHZlcnNpb24gPSArbWF0Y2hbMV07XG4gIH1cbn1cblxudmFyIGVuZ2luZVY4VmVyc2lvbiA9IHZlcnNpb247XG5cbi8qIGVzbGludC1kaXNhYmxlIGVzLXgvbm8tc3ltYm9sIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nICovXG5cbnZhciBWOF9WRVJTSU9OJDEgPSBlbmdpbmVWOFZlcnNpb247XG52YXIgZmFpbHMkbyA9IGZhaWxzJHM7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eXN5bWJvbHMgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbnZhciBuYXRpdmVTeW1ib2wgPSAhIU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgJiYgIWZhaWxzJG8oZnVuY3Rpb24gKCkge1xuICB2YXIgc3ltYm9sID0gU3ltYm9sKCk7XG4gIC8vIENocm9tZSAzOCBTeW1ib2wgaGFzIGluY29ycmVjdCB0b1N0cmluZyBjb252ZXJzaW9uXG4gIC8vIGBnZXQtb3duLXByb3BlcnR5LXN5bWJvbHNgIHBvbHlmaWxsIHN5bWJvbHMgY29udmVydGVkIHRvIG9iamVjdCBhcmUgbm90IFN5bWJvbCBpbnN0YW5jZXNcbiAgcmV0dXJuICFTdHJpbmcoc3ltYm9sKSB8fCAhKE9iamVjdChzeW1ib2wpIGluc3RhbmNlb2YgU3ltYm9sKSB8fFxuICAgIC8vIENocm9tZSAzOC00MCBzeW1ib2xzIGFyZSBub3QgaW5oZXJpdGVkIGZyb20gRE9NIGNvbGxlY3Rpb25zIHByb3RvdHlwZXMgdG8gaW5zdGFuY2VzXG4gICAgIVN5bWJvbC5zaGFtICYmIFY4X1ZFUlNJT04kMSAmJiBWOF9WRVJTSU9OJDEgPCA0MTtcbn0pO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBlcy14L25vLXN5bWJvbCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZyAqL1xuXG52YXIgTkFUSVZFX1NZTUJPTCQxID0gbmF0aXZlU3ltYm9sO1xuXG52YXIgdXNlU3ltYm9sQXNVaWQgPSBOQVRJVkVfU1lNQk9MJDFcbiAgJiYgIVN5bWJvbC5zaGFtXG4gICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT0gJ3N5bWJvbCc7XG5cbnZhciBnZXRCdWlsdEluJDYgPSBnZXRCdWlsdEluJDg7XG52YXIgaXNDYWxsYWJsZSRrID0gaXNDYWxsYWJsZSRuO1xudmFyIGlzUHJvdG90eXBlT2YkNCA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG52YXIgVVNFX1NZTUJPTF9BU19VSUQkMSA9IHVzZVN5bWJvbEFzVWlkO1xuXG52YXIgJE9iamVjdCQzID0gT2JqZWN0O1xuXG52YXIgaXNTeW1ib2wkMyA9IFVTRV9TWU1CT0xfQVNfVUlEJDEgPyBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJztcbn0gOiBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyICRTeW1ib2wgPSBnZXRCdWlsdEluJDYoJ1N5bWJvbCcpO1xuICByZXR1cm4gaXNDYWxsYWJsZSRrKCRTeW1ib2wpICYmIGlzUHJvdG90eXBlT2YkNCgkU3ltYm9sLnByb3RvdHlwZSwgJE9iamVjdCQzKGl0KSk7XG59O1xuXG52YXIgJFN0cmluZyQzID0gU3RyaW5nO1xuXG52YXIgdHJ5VG9TdHJpbmckNSA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICB0cnkge1xuICAgIHJldHVybiAkU3RyaW5nJDMoYXJndW1lbnQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiAnT2JqZWN0JztcbiAgfVxufTtcblxudmFyIGlzQ2FsbGFibGUkaiA9IGlzQ2FsbGFibGUkbjtcbnZhciB0cnlUb1N0cmluZyQ0ID0gdHJ5VG9TdHJpbmckNTtcblxudmFyICRUeXBlRXJyb3IkZSA9IFR5cGVFcnJvcjtcblxuLy8gYEFzc2VydDogSXNDYWxsYWJsZShhcmd1bWVudCkgaXMgdHJ1ZWBcbnZhciBhQ2FsbGFibGUkOSA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAoaXNDYWxsYWJsZSRqKGFyZ3VtZW50KSkgcmV0dXJuIGFyZ3VtZW50O1xuICB0aHJvdyAkVHlwZUVycm9yJGUodHJ5VG9TdHJpbmckNChhcmd1bWVudCkgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG59O1xuXG52YXIgYUNhbGxhYmxlJDggPSBhQ2FsbGFibGUkOTtcblxuLy8gYEdldE1ldGhvZGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWdldG1ldGhvZFxudmFyIGdldE1ldGhvZCQ0ID0gZnVuY3Rpb24gKFYsIFApIHtcbiAgdmFyIGZ1bmMgPSBWW1BdO1xuICByZXR1cm4gZnVuYyA9PSBudWxsID8gdW5kZWZpbmVkIDogYUNhbGxhYmxlJDgoZnVuYyk7XG59O1xuXG52YXIgY2FsbCRqID0gZnVuY3Rpb25DYWxsO1xudmFyIGlzQ2FsbGFibGUkaSA9IGlzQ2FsbGFibGUkbjtcbnZhciBpc09iamVjdCRjID0gaXNPYmplY3QkZDtcblxudmFyICRUeXBlRXJyb3IkZCA9IFR5cGVFcnJvcjtcblxuLy8gYE9yZGluYXJ5VG9QcmltaXRpdmVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vcmRpbmFyeXRvcHJpbWl0aXZlXG52YXIgb3JkaW5hcnlUb1ByaW1pdGl2ZSQxID0gZnVuY3Rpb24gKGlucHV0LCBwcmVmKSB7XG4gIHZhciBmbiwgdmFsO1xuICBpZiAocHJlZiA9PT0gJ3N0cmluZycgJiYgaXNDYWxsYWJsZSRpKGZuID0gaW5wdXQudG9TdHJpbmcpICYmICFpc09iamVjdCRjKHZhbCA9IGNhbGwkaihmbiwgaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKGlzQ2FsbGFibGUkaShmbiA9IGlucHV0LnZhbHVlT2YpICYmICFpc09iamVjdCRjKHZhbCA9IGNhbGwkaihmbiwgaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKHByZWYgIT09ICdzdHJpbmcnICYmIGlzQ2FsbGFibGUkaShmbiA9IGlucHV0LnRvU3RyaW5nKSAmJiAhaXNPYmplY3QkYyh2YWwgPSBjYWxsJGooZm4sIGlucHV0KSkpIHJldHVybiB2YWw7XG4gIHRocm93ICRUeXBlRXJyb3IkZChcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07XG5cbnZhciBzaGFyZWQkNCA9IHtleHBvcnRzOiB7fX07XG5cbnZhciBnbG9iYWwkcSA9IGdsb2JhbCR0O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gc2FmZVxudmFyIGRlZmluZVByb3BlcnR5JDcgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbnZhciBkZWZpbmVHbG9iYWxQcm9wZXJ0eSQzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgdHJ5IHtcbiAgICBkZWZpbmVQcm9wZXJ0eSQ3KGdsb2JhbCRxLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGdsb2JhbCRxW2tleV0gPSB2YWx1ZTtcbiAgfSByZXR1cm4gdmFsdWU7XG59O1xuXG52YXIgZ2xvYmFsJHAgPSBnbG9iYWwkdDtcbnZhciBkZWZpbmVHbG9iYWxQcm9wZXJ0eSQyID0gZGVmaW5lR2xvYmFsUHJvcGVydHkkMztcblxudmFyIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nO1xudmFyIHN0b3JlJDMgPSBnbG9iYWwkcFtTSEFSRURdIHx8IGRlZmluZUdsb2JhbFByb3BlcnR5JDIoU0hBUkVELCB7fSk7XG5cbnZhciBzaGFyZWRTdG9yZSA9IHN0b3JlJDM7XG5cbnZhciBzdG9yZSQyID0gc2hhcmVkU3RvcmU7XG5cbihzaGFyZWQkNC5leHBvcnRzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIHN0b3JlJDJba2V5XSB8fCAoc3RvcmUkMltrZXldID0gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoge30pO1xufSkoJ3ZlcnNpb25zJywgW10pLnB1c2goe1xuICB2ZXJzaW9uOiAnMy4yMy4zJyxcbiAgbW9kZTogJ2dsb2JhbCcsXG4gIGNvcHlyaWdodDogJ8KpIDIwMTQtMjAyMiBEZW5pcyBQdXNoa2FyZXYgKHpsb2lyb2NrLnJ1KScsXG4gIGxpY2Vuc2U6ICdodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9ibG9iL3YzLjIzLjMvTElDRU5TRScsXG4gIHNvdXJjZTogJ2h0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzJ1xufSk7XG5cbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDQgPSByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDY7XG5cbnZhciAkT2JqZWN0JDIgPSBPYmplY3Q7XG5cbi8vIGBUb09iamVjdGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvb2JqZWN0XG52YXIgdG9PYmplY3QkNyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gJE9iamVjdCQyKHJlcXVpcmVPYmplY3RDb2VyY2libGUkNChhcmd1bWVudCkpO1xufTtcblxudmFyIHVuY3VycnlUaGlzJGwgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIHRvT2JqZWN0JDYgPSB0b09iamVjdCQ3O1xuXG52YXIgaGFzT3duUHJvcGVydHkgPSB1bmN1cnJ5VGhpcyRsKHt9Lmhhc093blByb3BlcnR5KTtcblxuLy8gYEhhc093blByb3BlcnR5YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaGFzb3ducHJvcGVydHlcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1oYXNvd24gLS0gc2FmZVxudmFyIGhhc093blByb3BlcnR5XzEgPSBPYmplY3QuaGFzT3duIHx8IGZ1bmN0aW9uIGhhc093bihpdCwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eSh0b09iamVjdCQ2KGl0KSwga2V5KTtcbn07XG5cbnZhciB1bmN1cnJ5VGhpcyRrID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcblxudmFyIGlkID0gMDtcbnZhciBwb3N0Zml4ID0gTWF0aC5yYW5kb20oKTtcbnZhciB0b1N0cmluZyQ2ID0gdW5jdXJyeVRoaXMkaygxLjAudG9TdHJpbmcpO1xuXG52YXIgdWlkJDMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiAnU3ltYm9sKCcgKyAoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSkgKyAnKV8nICsgdG9TdHJpbmckNigrK2lkICsgcG9zdGZpeCwgMzYpO1xufTtcblxudmFyIGdsb2JhbCRvID0gZ2xvYmFsJHQ7XG52YXIgc2hhcmVkJDMgPSBzaGFyZWQkNC5leHBvcnRzO1xudmFyIGhhc093biRiID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciB1aWQkMiA9IHVpZCQzO1xudmFyIE5BVElWRV9TWU1CT0wgPSBuYXRpdmVTeW1ib2w7XG52YXIgVVNFX1NZTUJPTF9BU19VSUQgPSB1c2VTeW1ib2xBc1VpZDtcblxudmFyIFdlbGxLbm93blN5bWJvbHNTdG9yZSA9IHNoYXJlZCQzKCd3a3MnKTtcbnZhciBTeW1ib2wkMSA9IGdsb2JhbCRvLlN5bWJvbDtcbnZhciBzeW1ib2xGb3IgPSBTeW1ib2wkMSAmJiBTeW1ib2wkMVsnZm9yJ107XG52YXIgY3JlYXRlV2VsbEtub3duU3ltYm9sID0gVVNFX1NZTUJPTF9BU19VSUQgPyBTeW1ib2wkMSA6IFN5bWJvbCQxICYmIFN5bWJvbCQxLndpdGhvdXRTZXR0ZXIgfHwgdWlkJDI7XG5cbnZhciB3ZWxsS25vd25TeW1ib2wkaiA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGlmICghaGFzT3duJGIoV2VsbEtub3duU3ltYm9sc1N0b3JlLCBuYW1lKSB8fCAhKE5BVElWRV9TWU1CT0wgfHwgdHlwZW9mIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9PSAnc3RyaW5nJykpIHtcbiAgICB2YXIgZGVzY3JpcHRpb24gPSAnU3ltYm9sLicgKyBuYW1lO1xuICAgIGlmIChOQVRJVkVfU1lNQk9MICYmIGhhc093biRiKFN5bWJvbCQxLCBuYW1lKSkge1xuICAgICAgV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdID0gU3ltYm9sJDFbbmFtZV07XG4gICAgfSBlbHNlIGlmIChVU0VfU1lNQk9MX0FTX1VJRCAmJiBzeW1ib2xGb3IpIHtcbiAgICAgIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9IHN5bWJvbEZvcihkZXNjcmlwdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9IGNyZWF0ZVdlbGxLbm93blN5bWJvbChkZXNjcmlwdGlvbik7XG4gICAgfVxuICB9IHJldHVybiBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV07XG59O1xuXG52YXIgY2FsbCRpID0gZnVuY3Rpb25DYWxsO1xudmFyIGlzT2JqZWN0JGIgPSBpc09iamVjdCRkO1xudmFyIGlzU3ltYm9sJDIgPSBpc1N5bWJvbCQzO1xudmFyIGdldE1ldGhvZCQzID0gZ2V0TWV0aG9kJDQ7XG52YXIgb3JkaW5hcnlUb1ByaW1pdGl2ZSA9IG9yZGluYXJ5VG9QcmltaXRpdmUkMTtcbnZhciB3ZWxsS25vd25TeW1ib2wkaSA9IHdlbGxLbm93blN5bWJvbCRqO1xuXG52YXIgJFR5cGVFcnJvciRjID0gVHlwZUVycm9yO1xudmFyIFRPX1BSSU1JVElWRSA9IHdlbGxLbm93blN5bWJvbCRpKCd0b1ByaW1pdGl2ZScpO1xuXG4vLyBgVG9QcmltaXRpdmVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b3ByaW1pdGl2ZVxudmFyIHRvUHJpbWl0aXZlJDIgPSBmdW5jdGlvbiAoaW5wdXQsIHByZWYpIHtcbiAgaWYgKCFpc09iamVjdCRiKGlucHV0KSB8fCBpc1N5bWJvbCQyKGlucHV0KSkgcmV0dXJuIGlucHV0O1xuICB2YXIgZXhvdGljVG9QcmltID0gZ2V0TWV0aG9kJDMoaW5wdXQsIFRPX1BSSU1JVElWRSk7XG4gIHZhciByZXN1bHQ7XG4gIGlmIChleG90aWNUb1ByaW0pIHtcbiAgICBpZiAocHJlZiA9PT0gdW5kZWZpbmVkKSBwcmVmID0gJ2RlZmF1bHQnO1xuICAgIHJlc3VsdCA9IGNhbGwkaShleG90aWNUb1ByaW0sIGlucHV0LCBwcmVmKTtcbiAgICBpZiAoIWlzT2JqZWN0JGIocmVzdWx0KSB8fCBpc1N5bWJvbCQyKHJlc3VsdCkpIHJldHVybiByZXN1bHQ7XG4gICAgdGhyb3cgJFR5cGVFcnJvciRjKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xuICB9XG4gIGlmIChwcmVmID09PSB1bmRlZmluZWQpIHByZWYgPSAnbnVtYmVyJztcbiAgcmV0dXJuIG9yZGluYXJ5VG9QcmltaXRpdmUoaW5wdXQsIHByZWYpO1xufTtcblxudmFyIHRvUHJpbWl0aXZlJDEgPSB0b1ByaW1pdGl2ZSQyO1xudmFyIGlzU3ltYm9sJDEgPSBpc1N5bWJvbCQzO1xuXG4vLyBgVG9Qcm9wZXJ0eUtleWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvcHJvcGVydHlrZXlcbnZhciB0b1Byb3BlcnR5S2V5JDQgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgdmFyIGtleSA9IHRvUHJpbWl0aXZlJDEoYXJndW1lbnQsICdzdHJpbmcnKTtcbiAgcmV0dXJuIGlzU3ltYm9sJDEoa2V5KSA/IGtleSA6IGtleSArICcnO1xufTtcblxudmFyIGdsb2JhbCRuID0gZ2xvYmFsJHQ7XG52YXIgaXNPYmplY3QkYSA9IGlzT2JqZWN0JGQ7XG5cbnZhciBkb2N1bWVudCQzID0gZ2xvYmFsJG4uZG9jdW1lbnQ7XG4vLyB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0JyBpbiBvbGQgSUVcbnZhciBFWElTVFMkMSA9IGlzT2JqZWN0JGEoZG9jdW1lbnQkMykgJiYgaXNPYmplY3QkYShkb2N1bWVudCQzLmNyZWF0ZUVsZW1lbnQpO1xuXG52YXIgZG9jdW1lbnRDcmVhdGVFbGVtZW50JDIgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIEVYSVNUUyQxID8gZG9jdW1lbnQkMy5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTtcblxudmFyIERFU0NSSVBUT1JTJGQgPSBkZXNjcmlwdG9ycztcbnZhciBmYWlscyRuID0gZmFpbHMkcztcbnZhciBjcmVhdGVFbGVtZW50JDEgPSBkb2N1bWVudENyZWF0ZUVsZW1lbnQkMjtcblxuLy8gVGhhbmtzIHRvIElFOCBmb3IgaXRzIGZ1bm55IGRlZmluZVByb3BlcnR5XG52YXIgaWU4RG9tRGVmaW5lID0gIURFU0NSSVBUT1JTJGQgJiYgIWZhaWxzJG4oZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjcmVhdGVFbGVtZW50JDEoJ2RpdicpLCAnYScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH1cbiAgfSkuYSAhPSA3O1xufSk7XG5cbnZhciBERVNDUklQVE9SUyRjID0gZGVzY3JpcHRvcnM7XG52YXIgY2FsbCRoID0gZnVuY3Rpb25DYWxsO1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlJDEgPSBvYmplY3RQcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkNCA9IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQ1O1xudmFyIHRvSW5kZXhlZE9iamVjdCQ1ID0gdG9JbmRleGVkT2JqZWN0JDY7XG52YXIgdG9Qcm9wZXJ0eUtleSQzID0gdG9Qcm9wZXJ0eUtleSQ0O1xudmFyIGhhc093biRhID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBJRThfRE9NX0RFRklORSQxID0gaWU4RG9tRGVmaW5lO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG4vLyBgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3Jcbm9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvci5mID0gREVTQ1JJUFRPUlMkYyA/ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMSA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKSB7XG4gIE8gPSB0b0luZGV4ZWRPYmplY3QkNShPKTtcbiAgUCA9IHRvUHJvcGVydHlLZXkkMyhQKTtcbiAgaWYgKElFOF9ET01fREVGSU5FJDEpIHRyeSB7XG4gICAgcmV0dXJuICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMShPLCBQKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoaGFzT3duJGEoTywgUCkpIHJldHVybiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkNCghY2FsbCRoKHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlJDEuZiwgTywgUCksIE9bUF0pO1xufTtcblxudmFyIG9iamVjdERlZmluZVByb3BlcnR5ID0ge307XG5cbnZhciBERVNDUklQVE9SUyRiID0gZGVzY3JpcHRvcnM7XG52YXIgZmFpbHMkbSA9IGZhaWxzJHM7XG5cbi8vIFY4IH4gQ2hyb21lIDM2LVxuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzMzNFxudmFyIHY4UHJvdG90eXBlRGVmaW5lQnVnID0gREVTQ1JJUFRPUlMkYiAmJiBmYWlscyRtKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9LCAncHJvdG90eXBlJywge1xuICAgIHZhbHVlOiA0MixcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSkucHJvdG90eXBlICE9IDQyO1xufSk7XG5cbnZhciBpc09iamVjdCQ5ID0gaXNPYmplY3QkZDtcblxudmFyICRTdHJpbmckMiA9IFN0cmluZztcbnZhciAkVHlwZUVycm9yJGIgPSBUeXBlRXJyb3I7XG5cbi8vIGBBc3NlcnQ6IFR5cGUoYXJndW1lbnQpIGlzIE9iamVjdGBcbnZhciBhbk9iamVjdCRlID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmIChpc09iamVjdCQ5KGFyZ3VtZW50KSkgcmV0dXJuIGFyZ3VtZW50O1xuICB0aHJvdyAkVHlwZUVycm9yJGIoJFN0cmluZyQyKGFyZ3VtZW50KSArICcgaXMgbm90IGFuIG9iamVjdCcpO1xufTtcblxudmFyIERFU0NSSVBUT1JTJGEgPSBkZXNjcmlwdG9ycztcbnZhciBJRThfRE9NX0RFRklORSA9IGllOERvbURlZmluZTtcbnZhciBWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyQxID0gdjhQcm90b3R5cGVEZWZpbmVCdWc7XG52YXIgYW5PYmplY3QkZCA9IGFuT2JqZWN0JGU7XG52YXIgdG9Qcm9wZXJ0eUtleSQyID0gdG9Qcm9wZXJ0eUtleSQ0O1xuXG52YXIgJFR5cGVFcnJvciRhID0gVHlwZUVycm9yO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcbnZhciAkZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBFTlVNRVJBQkxFID0gJ2VudW1lcmFibGUnO1xudmFyIENPTkZJR1VSQUJMRSQxID0gJ2NvbmZpZ3VyYWJsZSc7XG52YXIgV1JJVEFCTEUgPSAnd3JpdGFibGUnO1xuXG4vLyBgT2JqZWN0LmRlZmluZVByb3BlcnR5YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnR5XG5vYmplY3REZWZpbmVQcm9wZXJ0eS5mID0gREVTQ1JJUFRPUlMkYSA/IFY4X1BST1RPVFlQRV9ERUZJTkVfQlVHJDEgPyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGFuT2JqZWN0JGQoTyk7XG4gIFAgPSB0b1Byb3BlcnR5S2V5JDIoUCk7XG4gIGFuT2JqZWN0JGQoQXR0cmlidXRlcyk7XG4gIGlmICh0eXBlb2YgTyA9PT0gJ2Z1bmN0aW9uJyAmJiBQID09PSAncHJvdG90eXBlJyAmJiAndmFsdWUnIGluIEF0dHJpYnV0ZXMgJiYgV1JJVEFCTEUgaW4gQXR0cmlidXRlcyAmJiAhQXR0cmlidXRlc1tXUklUQUJMRV0pIHtcbiAgICB2YXIgY3VycmVudCA9ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCk7XG4gICAgaWYgKGN1cnJlbnQgJiYgY3VycmVudFtXUklUQUJMRV0pIHtcbiAgICAgIE9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICAgICAgQXR0cmlidXRlcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBDT05GSUdVUkFCTEUkMSBpbiBBdHRyaWJ1dGVzID8gQXR0cmlidXRlc1tDT05GSUdVUkFCTEUkMV0gOiBjdXJyZW50W0NPTkZJR1VSQUJMRSQxXSxcbiAgICAgICAgZW51bWVyYWJsZTogRU5VTUVSQUJMRSBpbiBBdHRyaWJ1dGVzID8gQXR0cmlidXRlc1tFTlVNRVJBQkxFXSA6IGN1cnJlbnRbRU5VTUVSQUJMRV0sXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gIH0gcmV0dXJuICRkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKTtcbn0gOiAkZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGFuT2JqZWN0JGQoTyk7XG4gIFAgPSB0b1Byb3BlcnR5S2V5JDIoUCk7XG4gIGFuT2JqZWN0JGQoQXR0cmlidXRlcyk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gJGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIGlmICgnZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpIHRocm93ICRUeXBlRXJyb3IkYSgnQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgaWYgKCd2YWx1ZScgaW4gQXR0cmlidXRlcykgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTtcblxudmFyIERFU0NSSVBUT1JTJDkgPSBkZXNjcmlwdG9ycztcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQ2ID0gb2JqZWN0RGVmaW5lUHJvcGVydHk7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDMgPSBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkNTtcblxudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ4ID0gREVTQ1JJUFRPUlMkOSA/IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5TW9kdWxlJDYuZihvYmplY3QsIGtleSwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDMoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59O1xuXG52YXIgbWFrZUJ1aWx0SW4kMiA9IHtleHBvcnRzOiB7fX07XG5cbnZhciBERVNDUklQVE9SUyQ4ID0gZGVzY3JpcHRvcnM7XG52YXIgaGFzT3duJDkgPSBoYXNPd25Qcm9wZXJ0eV8xO1xuXG52YXIgRnVuY3Rpb25Qcm90b3R5cGUkMSA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxudmFyIGdldERlc2NyaXB0b3IgPSBERVNDUklQVE9SUyQ4ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbnZhciBFWElTVFMgPSBoYXNPd24kOShGdW5jdGlvblByb3RvdHlwZSQxLCAnbmFtZScpO1xuLy8gYWRkaXRpb25hbCBwcm90ZWN0aW9uIGZyb20gbWluaWZpZWQgLyBtYW5nbGVkIC8gZHJvcHBlZCBmdW5jdGlvbiBuYW1lc1xudmFyIFBST1BFUiA9IEVYSVNUUyAmJiAoZnVuY3Rpb24gc29tZXRoaW5nKCkgeyAvKiBlbXB0eSAqLyB9KS5uYW1lID09PSAnc29tZXRoaW5nJztcbnZhciBDT05GSUdVUkFCTEUgPSBFWElTVFMgJiYgKCFERVNDUklQVE9SUyQ4IHx8IChERVNDUklQVE9SUyQ4ICYmIGdldERlc2NyaXB0b3IoRnVuY3Rpb25Qcm90b3R5cGUkMSwgJ25hbWUnKS5jb25maWd1cmFibGUpKTtcblxudmFyIGZ1bmN0aW9uTmFtZSA9IHtcbiAgRVhJU1RTOiBFWElTVFMsXG4gIFBST1BFUjogUFJPUEVSLFxuICBDT05GSUdVUkFCTEU6IENPTkZJR1VSQUJMRVxufTtcblxudmFyIHVuY3VycnlUaGlzJGogPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGlzQ2FsbGFibGUkaCA9IGlzQ2FsbGFibGUkbjtcbnZhciBzdG9yZSQxID0gc2hhcmVkU3RvcmU7XG5cbnZhciBmdW5jdGlvblRvU3RyaW5nID0gdW5jdXJyeVRoaXMkaihGdW5jdGlvbi50b1N0cmluZyk7XG5cbi8vIHRoaXMgaGVscGVyIGJyb2tlbiBpbiBgY29yZS1qc0AzLjQuMS0zLjQuNGAsIHNvIHdlIGNhbid0IHVzZSBgc2hhcmVkYCBoZWxwZXJcbmlmICghaXNDYWxsYWJsZSRoKHN0b3JlJDEuaW5zcGVjdFNvdXJjZSkpIHtcbiAgc3RvcmUkMS5pbnNwZWN0U291cmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uVG9TdHJpbmcoaXQpO1xuICB9O1xufVxuXG52YXIgaW5zcGVjdFNvdXJjZSQ0ID0gc3RvcmUkMS5pbnNwZWN0U291cmNlO1xuXG52YXIgZ2xvYmFsJG0gPSBnbG9iYWwkdDtcbnZhciBpc0NhbGxhYmxlJGcgPSBpc0NhbGxhYmxlJG47XG52YXIgaW5zcGVjdFNvdXJjZSQzID0gaW5zcGVjdFNvdXJjZSQ0O1xuXG52YXIgV2Vha01hcCQxID0gZ2xvYmFsJG0uV2Vha01hcDtcblxudmFyIG5hdGl2ZVdlYWtNYXAgPSBpc0NhbGxhYmxlJGcoV2Vha01hcCQxKSAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoaW5zcGVjdFNvdXJjZSQzKFdlYWtNYXAkMSkpO1xuXG52YXIgc2hhcmVkJDIgPSBzaGFyZWQkNC5leHBvcnRzO1xudmFyIHVpZCQxID0gdWlkJDM7XG5cbnZhciBrZXlzJDEgPSBzaGFyZWQkMigna2V5cycpO1xuXG52YXIgc2hhcmVkS2V5JDMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBrZXlzJDFba2V5XSB8fCAoa2V5cyQxW2tleV0gPSB1aWQkMShrZXkpKTtcbn07XG5cbnZhciBoaWRkZW5LZXlzJDQgPSB7fTtcblxudmFyIE5BVElWRV9XRUFLX01BUCA9IG5hdGl2ZVdlYWtNYXA7XG52YXIgZ2xvYmFsJGwgPSBnbG9iYWwkdDtcbnZhciB1bmN1cnJ5VGhpcyRpID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBpc09iamVjdCQ4ID0gaXNPYmplY3QkZDtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNyA9IGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ4O1xudmFyIGhhc093biQ4ID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBzaGFyZWQkMSA9IHNoYXJlZFN0b3JlO1xudmFyIHNoYXJlZEtleSQyID0gc2hhcmVkS2V5JDM7XG52YXIgaGlkZGVuS2V5cyQzID0gaGlkZGVuS2V5cyQ0O1xuXG52YXIgT0JKRUNUX0FMUkVBRFlfSU5JVElBTElaRUQgPSAnT2JqZWN0IGFscmVhZHkgaW5pdGlhbGl6ZWQnO1xudmFyIFR5cGVFcnJvciQzID0gZ2xvYmFsJGwuVHlwZUVycm9yO1xudmFyIFdlYWtNYXAgPSBnbG9iYWwkbC5XZWFrTWFwO1xudmFyIHNldCQyLCBnZXQkMSwgaGFzO1xuXG52YXIgZW5mb3JjZSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaGFzKGl0KSA/IGdldCQxKGl0KSA6IHNldCQyKGl0LCB7fSk7XG59O1xuXG52YXIgZ2V0dGVyRm9yID0gZnVuY3Rpb24gKFRZUEUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpdCkge1xuICAgIHZhciBzdGF0ZTtcbiAgICBpZiAoIWlzT2JqZWN0JDgoaXQpIHx8IChzdGF0ZSA9IGdldCQxKGl0KSkudHlwZSAhPT0gVFlQRSkge1xuICAgICAgdGhyb3cgVHlwZUVycm9yJDMoJ0luY29tcGF0aWJsZSByZWNlaXZlciwgJyArIFRZUEUgKyAnIHJlcXVpcmVkJyk7XG4gICAgfSByZXR1cm4gc3RhdGU7XG4gIH07XG59O1xuXG5pZiAoTkFUSVZFX1dFQUtfTUFQIHx8IHNoYXJlZCQxLnN0YXRlKSB7XG4gIHZhciBzdG9yZSA9IHNoYXJlZCQxLnN0YXRlIHx8IChzaGFyZWQkMS5zdGF0ZSA9IG5ldyBXZWFrTWFwKCkpO1xuICB2YXIgd21nZXQgPSB1bmN1cnJ5VGhpcyRpKHN0b3JlLmdldCk7XG4gIHZhciB3bWhhcyA9IHVuY3VycnlUaGlzJGkoc3RvcmUuaGFzKTtcbiAgdmFyIHdtc2V0ID0gdW5jdXJyeVRoaXMkaShzdG9yZS5zZXQpO1xuICBzZXQkMiA9IGZ1bmN0aW9uIChpdCwgbWV0YWRhdGEpIHtcbiAgICBpZiAod21oYXMoc3RvcmUsIGl0KSkgdGhyb3cgbmV3IFR5cGVFcnJvciQzKE9CSkVDVF9BTFJFQURZX0lOSVRJQUxJWkVEKTtcbiAgICBtZXRhZGF0YS5mYWNhZGUgPSBpdDtcbiAgICB3bXNldChzdG9yZSwgaXQsIG1ldGFkYXRhKTtcbiAgICByZXR1cm4gbWV0YWRhdGE7XG4gIH07XG4gIGdldCQxID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIHdtZ2V0KHN0b3JlLCBpdCkgfHwge307XG4gIH07XG4gIGhhcyA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiB3bWhhcyhzdG9yZSwgaXQpO1xuICB9O1xufSBlbHNlIHtcbiAgdmFyIFNUQVRFID0gc2hhcmVkS2V5JDIoJ3N0YXRlJyk7XG4gIGhpZGRlbktleXMkM1tTVEFURV0gPSB0cnVlO1xuICBzZXQkMiA9IGZ1bmN0aW9uIChpdCwgbWV0YWRhdGEpIHtcbiAgICBpZiAoaGFzT3duJDgoaXQsIFNUQVRFKSkgdGhyb3cgbmV3IFR5cGVFcnJvciQzKE9CSkVDVF9BTFJFQURZX0lOSVRJQUxJWkVEKTtcbiAgICBtZXRhZGF0YS5mYWNhZGUgPSBpdDtcbiAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNyhpdCwgU1RBVEUsIG1ldGFkYXRhKTtcbiAgICByZXR1cm4gbWV0YWRhdGE7XG4gIH07XG4gIGdldCQxID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGhhc093biQ4KGl0LCBTVEFURSkgPyBpdFtTVEFURV0gOiB7fTtcbiAgfTtcbiAgaGFzID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGhhc093biQ4KGl0LCBTVEFURSk7XG4gIH07XG59XG5cbnZhciBpbnRlcm5hbFN0YXRlID0ge1xuICBzZXQ6IHNldCQyLFxuICBnZXQ6IGdldCQxLFxuICBoYXM6IGhhcyxcbiAgZW5mb3JjZTogZW5mb3JjZSxcbiAgZ2V0dGVyRm9yOiBnZXR0ZXJGb3Jcbn07XG5cbnZhciBmYWlscyRsID0gZmFpbHMkcztcbnZhciBpc0NhbGxhYmxlJGYgPSBpc0NhbGxhYmxlJG47XG52YXIgaGFzT3duJDcgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIERFU0NSSVBUT1JTJDcgPSBkZXNjcmlwdG9ycztcbnZhciBDT05GSUdVUkFCTEVfRlVOQ1RJT05fTkFNRSQyID0gZnVuY3Rpb25OYW1lLkNPTkZJR1VSQUJMRTtcbnZhciBpbnNwZWN0U291cmNlJDIgPSBpbnNwZWN0U291cmNlJDQ7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSQ1ID0gaW50ZXJuYWxTdGF0ZTtcblxudmFyIGVuZm9yY2VJbnRlcm5hbFN0YXRlJDIgPSBJbnRlcm5hbFN0YXRlTW9kdWxlJDUuZW5mb3JjZTtcbnZhciBnZXRJbnRlcm5hbFN0YXRlJDUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlJDUuZ2V0O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcbnZhciBkZWZpbmVQcm9wZXJ0eSQ2ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG52YXIgQ09ORklHVVJBQkxFX0xFTkdUSCA9IERFU0NSSVBUT1JTJDcgJiYgIWZhaWxzJGwoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZGVmaW5lUHJvcGVydHkkNihmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0sICdsZW5ndGgnLCB7IHZhbHVlOiA4IH0pLmxlbmd0aCAhPT0gODtcbn0pO1xuXG52YXIgVEVNUExBVEUgPSBTdHJpbmcoU3RyaW5nKS5zcGxpdCgnU3RyaW5nJyk7XG5cbnZhciBtYWtlQnVpbHRJbiQxID0gbWFrZUJ1aWx0SW4kMi5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlLCBuYW1lLCBvcHRpb25zKSB7XG4gIGlmIChTdHJpbmcobmFtZSkuc2xpY2UoMCwgNykgPT09ICdTeW1ib2woJykge1xuICAgIG5hbWUgPSAnWycgKyBTdHJpbmcobmFtZSkucmVwbGFjZSgvXlN5bWJvbFxcKChbXildKilcXCkvLCAnJDEnKSArICddJztcbiAgfVxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmdldHRlcikgbmFtZSA9ICdnZXQgJyArIG5hbWU7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuc2V0dGVyKSBuYW1lID0gJ3NldCAnICsgbmFtZTtcbiAgaWYgKCFoYXNPd24kNyh2YWx1ZSwgJ25hbWUnKSB8fCAoQ09ORklHVVJBQkxFX0ZVTkNUSU9OX05BTUUkMiAmJiB2YWx1ZS5uYW1lICE9PSBuYW1lKSkge1xuICAgIGlmIChERVNDUklQVE9SUyQ3KSBkZWZpbmVQcm9wZXJ0eSQ2KHZhbHVlLCAnbmFtZScsIHsgdmFsdWU6IG5hbWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcbiAgICBlbHNlIHZhbHVlLm5hbWUgPSBuYW1lO1xuICB9XG4gIGlmIChDT05GSUdVUkFCTEVfTEVOR1RIICYmIG9wdGlvbnMgJiYgaGFzT3duJDcob3B0aW9ucywgJ2FyaXR5JykgJiYgdmFsdWUubGVuZ3RoICE9PSBvcHRpb25zLmFyaXR5KSB7XG4gICAgZGVmaW5lUHJvcGVydHkkNih2YWx1ZSwgJ2xlbmd0aCcsIHsgdmFsdWU6IG9wdGlvbnMuYXJpdHkgfSk7XG4gIH1cbiAgdHJ5IHtcbiAgICBpZiAob3B0aW9ucyAmJiBoYXNPd24kNyhvcHRpb25zLCAnY29uc3RydWN0b3InKSAmJiBvcHRpb25zLmNvbnN0cnVjdG9yKSB7XG4gICAgICBpZiAoREVTQ1JJUFRPUlMkNykgZGVmaW5lUHJvcGVydHkkNih2YWx1ZSwgJ3Byb3RvdHlwZScsIHsgd3JpdGFibGU6IGZhbHNlIH0pO1xuICAgIC8vIGluIFY4IH4gQ2hyb21lIDUzLCBwcm90b3R5cGVzIG9mIHNvbWUgbWV0aG9kcywgbGlrZSBgQXJyYXkucHJvdG90eXBlLnZhbHVlc2AsIGFyZSBub24td3JpdGFibGVcbiAgICB9IGVsc2UgaWYgKHZhbHVlLnByb3RvdHlwZSkgdmFsdWUucHJvdG90eXBlID0gdW5kZWZpbmVkO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIHZhciBzdGF0ZSA9IGVuZm9yY2VJbnRlcm5hbFN0YXRlJDIodmFsdWUpO1xuICBpZiAoIWhhc093biQ3KHN0YXRlLCAnc291cmNlJykpIHtcbiAgICBzdGF0ZS5zb3VyY2UgPSBURU1QTEFURS5qb2luKHR5cGVvZiBuYW1lID09ICdzdHJpbmcnID8gbmFtZSA6ICcnKTtcbiAgfSByZXR1cm4gdmFsdWU7XG59O1xuXG4vLyBhZGQgZmFrZSBGdW5jdGlvbiN0b1N0cmluZyBmb3IgY29ycmVjdCB3b3JrIHdyYXBwZWQgbWV0aG9kcyAvIGNvbnN0cnVjdG9ycyB3aXRoIG1ldGhvZHMgbGlrZSBMb0Rhc2ggaXNOYXRpdmVcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1leHRlbmQtbmF0aXZlIC0tIHJlcXVpcmVkXG5GdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBtYWtlQnVpbHRJbiQxKGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gaXNDYWxsYWJsZSRmKHRoaXMpICYmIGdldEludGVybmFsU3RhdGUkNSh0aGlzKS5zb3VyY2UgfHwgaW5zcGVjdFNvdXJjZSQyKHRoaXMpO1xufSwgJ3RvU3RyaW5nJyk7XG5cbnZhciBpc0NhbGxhYmxlJGUgPSBpc0NhbGxhYmxlJG47XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUkNSA9IG9iamVjdERlZmluZVByb3BlcnR5O1xudmFyIG1ha2VCdWlsdEluID0gbWFrZUJ1aWx0SW4kMi5leHBvcnRzO1xudmFyIGRlZmluZUdsb2JhbFByb3BlcnR5JDEgPSBkZWZpbmVHbG9iYWxQcm9wZXJ0eSQzO1xuXG52YXIgZGVmaW5lQnVpbHRJbiQ4ID0gZnVuY3Rpb24gKE8sIGtleSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG4gIHZhciBzaW1wbGUgPSBvcHRpb25zLmVudW1lcmFibGU7XG4gIHZhciBuYW1lID0gb3B0aW9ucy5uYW1lICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm5hbWUgOiBrZXk7XG4gIGlmIChpc0NhbGxhYmxlJGUodmFsdWUpKSBtYWtlQnVpbHRJbih2YWx1ZSwgbmFtZSwgb3B0aW9ucyk7XG4gIGlmIChvcHRpb25zLmdsb2JhbCkge1xuICAgIGlmIChzaW1wbGUpIE9ba2V5XSA9IHZhbHVlO1xuICAgIGVsc2UgZGVmaW5lR2xvYmFsUHJvcGVydHkkMShrZXksIHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFvcHRpb25zLnVuc2FmZSkgZGVsZXRlIE9ba2V5XTtcbiAgICAgIGVsc2UgaWYgKE9ba2V5XSkgc2ltcGxlID0gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gICAgaWYgKHNpbXBsZSkgT1trZXldID0gdmFsdWU7XG4gICAgZWxzZSBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQ1LmYoTywga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogIW9wdGlvbnMubm9uQ29uZmlndXJhYmxlLFxuICAgICAgd3JpdGFibGU6ICFvcHRpb25zLm5vbldyaXRhYmxlXG4gICAgfSk7XG4gIH0gcmV0dXJuIE87XG59O1xuXG52YXIgb2JqZWN0R2V0T3duUHJvcGVydHlOYW1lcyA9IHt9O1xuXG52YXIgY2VpbCA9IE1hdGguY2VpbDtcbnZhciBmbG9vciQzID0gTWF0aC5mbG9vcjtcblxuLy8gYE1hdGgudHJ1bmNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXRoLnRydW5jXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1tYXRoLXRydW5jIC0tIHNhZmVcbnZhciBtYXRoVHJ1bmMgPSBNYXRoLnRydW5jIHx8IGZ1bmN0aW9uIHRydW5jKHgpIHtcbiAgdmFyIG4gPSAreDtcbiAgcmV0dXJuIChuID4gMCA/IGZsb29yJDMgOiBjZWlsKShuKTtcbn07XG5cbnZhciB0cnVuYyA9IG1hdGhUcnVuYztcblxuLy8gYFRvSW50ZWdlck9ySW5maW5pdHlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b2ludGVnZXJvcmluZmluaXR5XG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSQ2ID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHZhciBudW1iZXIgPSArYXJndW1lbnQ7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG4gIHJldHVybiBudW1iZXIgIT09IG51bWJlciB8fCBudW1iZXIgPT09IDAgPyAwIDogdHJ1bmMobnVtYmVyKTtcbn07XG5cbnZhciB0b0ludGVnZXJPckluZmluaXR5JDUgPSB0b0ludGVnZXJPckluZmluaXR5JDY7XG5cbnZhciBtYXgkMSA9IE1hdGgubWF4O1xudmFyIG1pbiQyID0gTWF0aC5taW47XG5cbi8vIEhlbHBlciBmb3IgYSBwb3B1bGFyIHJlcGVhdGluZyBjYXNlIG9mIHRoZSBzcGVjOlxuLy8gTGV0IGludGVnZXIgYmUgPyBUb0ludGVnZXIoaW5kZXgpLlxuLy8gSWYgaW50ZWdlciA8IDAsIGxldCByZXN1bHQgYmUgbWF4KChsZW5ndGggKyBpbnRlZ2VyKSwgMCk7IGVsc2UgbGV0IHJlc3VsdCBiZSBtaW4oaW50ZWdlciwgbGVuZ3RoKS5cbnZhciB0b0Fic29sdXRlSW5kZXgkNCA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XG4gIHZhciBpbnRlZ2VyID0gdG9JbnRlZ2VyT3JJbmZpbml0eSQ1KGluZGV4KTtcbiAgcmV0dXJuIGludGVnZXIgPCAwID8gbWF4JDEoaW50ZWdlciArIGxlbmd0aCwgMCkgOiBtaW4kMihpbnRlZ2VyLCBsZW5ndGgpO1xufTtcblxudmFyIHRvSW50ZWdlck9ySW5maW5pdHkkNCA9IHRvSW50ZWdlck9ySW5maW5pdHkkNjtcblxudmFyIG1pbiQxID0gTWF0aC5taW47XG5cbi8vIGBUb0xlbmd0aGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvbGVuZ3RoXG52YXIgdG9MZW5ndGgkNiA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gYXJndW1lbnQgPiAwID8gbWluJDEodG9JbnRlZ2VyT3JJbmZpbml0eSQ0KGFyZ3VtZW50KSwgMHgxRkZGRkZGRkZGRkZGRikgOiAwOyAvLyAyICoqIDUzIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59O1xuXG52YXIgdG9MZW5ndGgkNSA9IHRvTGVuZ3RoJDY7XG5cbi8vIGBMZW5ndGhPZkFycmF5TGlrZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWxlbmd0aG9mYXJyYXlsaWtlXG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UkOCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIHRvTGVuZ3RoJDUob2JqLmxlbmd0aCk7XG59O1xuXG52YXIgdG9JbmRleGVkT2JqZWN0JDQgPSB0b0luZGV4ZWRPYmplY3QkNjtcbnZhciB0b0Fic29sdXRlSW5kZXgkMyA9IHRvQWJzb2x1dGVJbmRleCQ0O1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlJDcgPSBsZW5ndGhPZkFycmF5TGlrZSQ4O1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLnsgaW5kZXhPZiwgaW5jbHVkZXMgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxudmFyIGNyZWF0ZU1ldGhvZCQ0ID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdCQ0KCR0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UkNyhPKTtcbiAgICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgkMyhmcm9tSW5kZXgsIGxlbmd0aCk7XG4gICAgdmFyIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xuICAgIGlmIChJU19JTkNMVURFUyAmJiBlbCAhPSBlbCkgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSB7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xuICAgICAgaWYgKHZhbHVlICE9IHZhbHVlKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSNpbmRleE9mIGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgICBpZiAoKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pICYmIE9baW5kZXhdID09PSBlbCkgcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcblxudmFyIGFycmF5SW5jbHVkZXMgPSB7XG4gIC8vIGBBcnJheS5wcm90b3R5cGUuaW5jbHVkZXNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmNsdWRlc1xuICBpbmNsdWRlczogY3JlYXRlTWV0aG9kJDQodHJ1ZSksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuaW5kZXhPZmAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmluZGV4b2ZcbiAgaW5kZXhPZjogY3JlYXRlTWV0aG9kJDQoZmFsc2UpXG59O1xuXG52YXIgdW5jdXJyeVRoaXMkaCA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgaGFzT3duJDYgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIHRvSW5kZXhlZE9iamVjdCQzID0gdG9JbmRleGVkT2JqZWN0JDY7XG52YXIgaW5kZXhPZiQxID0gYXJyYXlJbmNsdWRlcy5pbmRleE9mO1xudmFyIGhpZGRlbktleXMkMiA9IGhpZGRlbktleXMkNDtcblxudmFyIHB1c2gkMiA9IHVuY3VycnlUaGlzJGgoW10ucHVzaCk7XG5cbnZhciBvYmplY3RLZXlzSW50ZXJuYWwgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xuICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdCQzKG9iamVjdCk7XG4gIHZhciBpID0gMDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBPKSAhaGFzT3duJDYoaGlkZGVuS2V5cyQyLCBrZXkpICYmIGhhc093biQ2KE8sIGtleSkgJiYgcHVzaCQyKHJlc3VsdCwga2V5KTtcbiAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkgaWYgKGhhc093biQ2KE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICAgfmluZGV4T2YkMShyZXN1bHQsIGtleSkgfHwgcHVzaCQyKHJlc3VsdCwga2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gSUU4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG52YXIgZW51bUJ1Z0tleXMkMyA9IFtcbiAgJ2NvbnN0cnVjdG9yJyxcbiAgJ2hhc093blByb3BlcnR5JyxcbiAgJ2lzUHJvdG90eXBlT2YnLFxuICAncHJvcGVydHlJc0VudW1lcmFibGUnLFxuICAndG9Mb2NhbGVTdHJpbmcnLFxuICAndG9TdHJpbmcnLFxuICAndmFsdWVPZidcbl07XG5cbnZhciBpbnRlcm5hbE9iamVjdEtleXMkMSA9IG9iamVjdEtleXNJbnRlcm5hbDtcbnZhciBlbnVtQnVnS2V5cyQyID0gZW51bUJ1Z0tleXMkMztcblxudmFyIGhpZGRlbktleXMkMSA9IGVudW1CdWdLZXlzJDIuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7XG5cbi8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eW5hbWVzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0b3ducHJvcGVydHluYW1lcyAtLSBzYWZlXG5vYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pIHtcbiAgcmV0dXJuIGludGVybmFsT2JqZWN0S2V5cyQxKE8sIGhpZGRlbktleXMkMSk7XG59O1xuXG52YXIgb2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzID0ge307XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eXN5bWJvbHMgLS0gc2FmZVxub2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG52YXIgZ2V0QnVpbHRJbiQ1ID0gZ2V0QnVpbHRJbiQ4O1xudmFyIHVuY3VycnlUaGlzJGcgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSQxID0gb2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGFuT2JqZWN0JGMgPSBhbk9iamVjdCRlO1xuXG52YXIgY29uY2F0JDEgPSB1bmN1cnJ5VGhpcyRnKFtdLmNvbmNhdCk7XG5cbi8vIGFsbCBvYmplY3Qga2V5cywgaW5jbHVkZXMgbm9uLWVudW1lcmFibGUgYW5kIHN5bWJvbHNcbnZhciBvd25LZXlzJDEgPSBnZXRCdWlsdEluJDUoJ1JlZmxlY3QnLCAnb3duS2V5cycpIHx8IGZ1bmN0aW9uIG93bktleXMoaXQpIHtcbiAgdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlLmYoYW5PYmplY3QkYyhpdCkpO1xuICB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlJDEuZjtcbiAgcmV0dXJuIGdldE93blByb3BlcnR5U3ltYm9scyA/IGNvbmNhdCQxKGtleXMsIGdldE93blByb3BlcnR5U3ltYm9scyhpdCkpIDoga2V5cztcbn07XG5cbnZhciBoYXNPd24kNSA9IGhhc093blByb3BlcnR5XzE7XG52YXIgb3duS2V5cyA9IG93bktleXMkMTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUkMSA9IG9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQ0ID0gb2JqZWN0RGVmaW5lUHJvcGVydHk7XG5cbnZhciBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzJDEgPSBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UsIGV4Y2VwdGlvbnMpIHtcbiAgdmFyIGtleXMgPSBvd25LZXlzKHNvdXJjZSk7XG4gIHZhciBkZWZpbmVQcm9wZXJ0eSA9IGRlZmluZVByb3BlcnR5TW9kdWxlJDQuZjtcbiAgdmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZSQxLmY7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIGlmICghaGFzT3duJDUodGFyZ2V0LCBrZXkpICYmICEoZXhjZXB0aW9ucyAmJiBoYXNPd24kNShleGNlcHRpb25zLCBrZXkpKSkge1xuICAgICAgZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIGZhaWxzJGsgPSBmYWlscyRzO1xudmFyIGlzQ2FsbGFibGUkZCA9IGlzQ2FsbGFibGUkbjtcblxudmFyIHJlcGxhY2VtZW50ID0gLyN8XFwucHJvdG90eXBlXFwuLztcblxudmFyIGlzRm9yY2VkJDIgPSBmdW5jdGlvbiAoZmVhdHVyZSwgZGV0ZWN0aW9uKSB7XG4gIHZhciB2YWx1ZSA9IGRhdGFbbm9ybWFsaXplKGZlYXR1cmUpXTtcbiAgcmV0dXJuIHZhbHVlID09IFBPTFlGSUxMID8gdHJ1ZVxuICAgIDogdmFsdWUgPT0gTkFUSVZFID8gZmFsc2VcbiAgICA6IGlzQ2FsbGFibGUkZChkZXRlY3Rpb24pID8gZmFpbHMkayhkZXRlY3Rpb24pXG4gICAgOiAhIWRldGVjdGlvbjtcbn07XG5cbnZhciBub3JtYWxpemUgPSBpc0ZvcmNlZCQyLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgcmV0dXJuIFN0cmluZyhzdHJpbmcpLnJlcGxhY2UocmVwbGFjZW1lbnQsICcuJykudG9Mb3dlckNhc2UoKTtcbn07XG5cbnZhciBkYXRhID0gaXNGb3JjZWQkMi5kYXRhID0ge307XG52YXIgTkFUSVZFID0gaXNGb3JjZWQkMi5OQVRJVkUgPSAnTic7XG52YXIgUE9MWUZJTEwgPSBpc0ZvcmNlZCQyLlBPTFlGSUxMID0gJ1AnO1xuXG52YXIgaXNGb3JjZWRfMSA9IGlzRm9yY2VkJDI7XG5cbnZhciBnbG9iYWwkayA9IGdsb2JhbCR0O1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciQxID0gb2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLmY7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDYgPSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkODtcbnZhciBkZWZpbmVCdWlsdEluJDcgPSBkZWZpbmVCdWlsdEluJDg7XG52YXIgZGVmaW5lR2xvYmFsUHJvcGVydHkgPSBkZWZpbmVHbG9iYWxQcm9wZXJ0eSQzO1xudmFyIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMgPSBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzJDE7XG52YXIgaXNGb3JjZWQkMSA9IGlzRm9yY2VkXzE7XG5cbi8qXG4gIG9wdGlvbnMudGFyZ2V0ICAgICAgICAgLSBuYW1lIG9mIHRoZSB0YXJnZXQgb2JqZWN0XG4gIG9wdGlvbnMuZ2xvYmFsICAgICAgICAgLSB0YXJnZXQgaXMgdGhlIGdsb2JhbCBvYmplY3RcbiAgb3B0aW9ucy5zdGF0ICAgICAgICAgICAtIGV4cG9ydCBhcyBzdGF0aWMgbWV0aG9kcyBvZiB0YXJnZXRcbiAgb3B0aW9ucy5wcm90byAgICAgICAgICAtIGV4cG9ydCBhcyBwcm90b3R5cGUgbWV0aG9kcyBvZiB0YXJnZXRcbiAgb3B0aW9ucy5yZWFsICAgICAgICAgICAtIHJlYWwgcHJvdG90eXBlIG1ldGhvZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMuZm9yY2VkICAgICAgICAgLSBleHBvcnQgZXZlbiBpZiB0aGUgbmF0aXZlIGZlYXR1cmUgaXMgYXZhaWxhYmxlXG4gIG9wdGlvbnMuYmluZCAgICAgICAgICAgLSBiaW5kIG1ldGhvZHMgdG8gdGhlIHRhcmdldCwgcmVxdWlyZWQgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuICBvcHRpb25zLndyYXAgICAgICAgICAgIC0gd3JhcCBjb25zdHJ1Y3RvcnMgdG8gcHJldmVudGluZyBnbG9iYWwgcG9sbHV0aW9uLCByZXF1aXJlZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMudW5zYWZlICAgICAgICAgLSB1c2UgdGhlIHNpbXBsZSBhc3NpZ25tZW50IG9mIHByb3BlcnR5IGluc3RlYWQgb2YgZGVsZXRlICsgZGVmaW5lUHJvcGVydHlcbiAgb3B0aW9ucy5zaGFtICAgICAgICAgICAtIGFkZCBhIGZsYWcgdG8gbm90IGNvbXBsZXRlbHkgZnVsbCBwb2x5ZmlsbHNcbiAgb3B0aW9ucy5lbnVtZXJhYmxlICAgICAtIGV4cG9ydCBhcyBlbnVtZXJhYmxlIHByb3BlcnR5XG4gIG9wdGlvbnMuZG9udENhbGxHZXRTZXQgLSBwcmV2ZW50IGNhbGxpbmcgYSBnZXR0ZXIgb24gdGFyZ2V0XG4gIG9wdGlvbnMubmFtZSAgICAgICAgICAgLSB0aGUgLm5hbWUgb2YgdGhlIGZ1bmN0aW9uIGlmIGl0IGRvZXMgbm90IG1hdGNoIHRoZSBrZXlcbiovXG52YXIgX2V4cG9ydCA9IGZ1bmN0aW9uIChvcHRpb25zLCBzb3VyY2UpIHtcbiAgdmFyIFRBUkdFVCA9IG9wdGlvbnMudGFyZ2V0O1xuICB2YXIgR0xPQkFMID0gb3B0aW9ucy5nbG9iYWw7XG4gIHZhciBTVEFUSUMgPSBvcHRpb25zLnN0YXQ7XG4gIHZhciBGT1JDRUQsIHRhcmdldCwga2V5LCB0YXJnZXRQcm9wZXJ0eSwgc291cmNlUHJvcGVydHksIGRlc2NyaXB0b3I7XG4gIGlmIChHTE9CQUwpIHtcbiAgICB0YXJnZXQgPSBnbG9iYWwkaztcbiAgfSBlbHNlIGlmIChTVEFUSUMpIHtcbiAgICB0YXJnZXQgPSBnbG9iYWwka1tUQVJHRVRdIHx8IGRlZmluZUdsb2JhbFByb3BlcnR5KFRBUkdFVCwge30pO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldCA9IChnbG9iYWwka1tUQVJHRVRdIHx8IHt9KS5wcm90b3R5cGU7XG4gIH1cbiAgaWYgKHRhcmdldCkgZm9yIChrZXkgaW4gc291cmNlKSB7XG4gICAgc291cmNlUHJvcGVydHkgPSBzb3VyY2Vba2V5XTtcbiAgICBpZiAob3B0aW9ucy5kb250Q2FsbEdldFNldCkge1xuICAgICAgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvciQxKHRhcmdldCwga2V5KTtcbiAgICAgIHRhcmdldFByb3BlcnR5ID0gZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLnZhbHVlO1xuICAgIH0gZWxzZSB0YXJnZXRQcm9wZXJ0eSA9IHRhcmdldFtrZXldO1xuICAgIEZPUkNFRCA9IGlzRm9yY2VkJDEoR0xPQkFMID8ga2V5IDogVEFSR0VUICsgKFNUQVRJQyA/ICcuJyA6ICcjJykgKyBrZXksIG9wdGlvbnMuZm9yY2VkKTtcbiAgICAvLyBjb250YWluZWQgaW4gdGFyZ2V0XG4gICAgaWYgKCFGT1JDRUQgJiYgdGFyZ2V0UHJvcGVydHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHR5cGVvZiBzb3VyY2VQcm9wZXJ0eSA9PSB0eXBlb2YgdGFyZ2V0UHJvcGVydHkpIGNvbnRpbnVlO1xuICAgICAgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyhzb3VyY2VQcm9wZXJ0eSwgdGFyZ2V0UHJvcGVydHkpO1xuICAgIH1cbiAgICAvLyBhZGQgYSBmbGFnIHRvIG5vdCBjb21wbGV0ZWx5IGZ1bGwgcG9seWZpbGxzXG4gICAgaWYgKG9wdGlvbnMuc2hhbSB8fCAodGFyZ2V0UHJvcGVydHkgJiYgdGFyZ2V0UHJvcGVydHkuc2hhbSkpIHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ2KHNvdXJjZVByb3BlcnR5LCAnc2hhbScsIHRydWUpO1xuICAgIH1cbiAgICBkZWZpbmVCdWlsdEluJDcodGFyZ2V0LCBrZXksIHNvdXJjZVByb3BlcnR5LCBvcHRpb25zKTtcbiAgfVxufTtcblxudmFyIGNsYXNzb2YkYSA9IGNsYXNzb2ZSYXckMTtcbnZhciBnbG9iYWwkaiA9IGdsb2JhbCR0O1xuXG52YXIgZW5naW5lSXNOb2RlID0gY2xhc3NvZiRhKGdsb2JhbCRqLnByb2Nlc3MpID09ICdwcm9jZXNzJztcblxudmFyIGlzQ2FsbGFibGUkYyA9IGlzQ2FsbGFibGUkbjtcblxudmFyICRTdHJpbmckMSA9IFN0cmluZztcbnZhciAkVHlwZUVycm9yJDkgPSBUeXBlRXJyb3I7XG5cbnZhciBhUG9zc2libGVQcm90b3R5cGUkMSA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAodHlwZW9mIGFyZ3VtZW50ID09ICdvYmplY3QnIHx8IGlzQ2FsbGFibGUkYyhhcmd1bWVudCkpIHJldHVybiBhcmd1bWVudDtcbiAgdGhyb3cgJFR5cGVFcnJvciQ5KFwiQ2FuJ3Qgc2V0IFwiICsgJFN0cmluZyQxKGFyZ3VtZW50KSArICcgYXMgYSBwcm90b3R5cGUnKTtcbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvIC0tIHNhZmUgKi9cblxudmFyIHVuY3VycnlUaGlzJGYgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGFuT2JqZWN0JGIgPSBhbk9iamVjdCRlO1xudmFyIGFQb3NzaWJsZVByb3RvdHlwZSA9IGFQb3NzaWJsZVByb3RvdHlwZSQxO1xuXG4vLyBgT2JqZWN0LnNldFByb3RvdHlwZU9mYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LnNldHByb3RvdHlwZW9mXG4vLyBXb3JrcyB3aXRoIF9fcHJvdG9fXyBvbmx5LiBPbGQgdjggY2FuJ3Qgd29yayB3aXRoIG51bGwgcHJvdG8gb2JqZWN0cy5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1zZXRwcm90b3R5cGVvZiAtLSBzYWZlXG52YXIgb2JqZWN0U2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gZnVuY3Rpb24gKCkge1xuICB2YXIgQ09SUkVDVF9TRVRURVIgPSBmYWxzZTtcbiAgdmFyIHRlc3QgPSB7fTtcbiAgdmFyIHNldHRlcjtcbiAgdHJ5IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbiAgICBzZXR0ZXIgPSB1bmN1cnJ5VGhpcyRmKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycpLnNldCk7XG4gICAgc2V0dGVyKHRlc3QsIFtdKTtcbiAgICBDT1JSRUNUX1NFVFRFUiA9IHRlc3QgaW5zdGFuY2VvZiBBcnJheTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pIHtcbiAgICBhbk9iamVjdCRiKE8pO1xuICAgIGFQb3NzaWJsZVByb3RvdHlwZShwcm90byk7XG4gICAgaWYgKENPUlJFQ1RfU0VUVEVSKSBzZXR0ZXIoTywgcHJvdG8pO1xuICAgIGVsc2UgTy5fX3Byb3RvX18gPSBwcm90bztcbiAgICByZXR1cm4gTztcbiAgfTtcbn0oKSA6IHVuZGVmaW5lZCk7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSQ1ID0gb2JqZWN0RGVmaW5lUHJvcGVydHkuZjtcbnZhciBoYXNPd24kNCA9IGhhc093blByb3BlcnR5XzE7XG52YXIgd2VsbEtub3duU3ltYm9sJGggPSB3ZWxsS25vd25TeW1ib2wkajtcblxudmFyIFRPX1NUUklOR19UQUckNCA9IHdlbGxLbm93blN5bWJvbCRoKCd0b1N0cmluZ1RhZycpO1xuXG52YXIgc2V0VG9TdHJpbmdUYWckNCA9IGZ1bmN0aW9uICh0YXJnZXQsIFRBRywgU1RBVElDKSB7XG4gIGlmICh0YXJnZXQgJiYgIVNUQVRJQykgdGFyZ2V0ID0gdGFyZ2V0LnByb3RvdHlwZTtcbiAgaWYgKHRhcmdldCAmJiAhaGFzT3duJDQodGFyZ2V0LCBUT19TVFJJTkdfVEFHJDQpKSB7XG4gICAgZGVmaW5lUHJvcGVydHkkNSh0YXJnZXQsIFRPX1NUUklOR19UQUckNCwgeyBjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiBUQUcgfSk7XG4gIH1cbn07XG5cbnZhciBnZXRCdWlsdEluJDQgPSBnZXRCdWlsdEluJDg7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUkMyA9IG9iamVjdERlZmluZVByb3BlcnR5O1xudmFyIHdlbGxLbm93blN5bWJvbCRnID0gd2VsbEtub3duU3ltYm9sJGo7XG52YXIgREVTQ1JJUFRPUlMkNiA9IGRlc2NyaXB0b3JzO1xuXG52YXIgU1BFQ0lFUyQ0ID0gd2VsbEtub3duU3ltYm9sJGcoJ3NwZWNpZXMnKTtcblxudmFyIHNldFNwZWNpZXMkMiA9IGZ1bmN0aW9uIChDT05TVFJVQ1RPUl9OQU1FKSB7XG4gIHZhciBDb25zdHJ1Y3RvciA9IGdldEJ1aWx0SW4kNChDT05TVFJVQ1RPUl9OQU1FKTtcbiAgdmFyIGRlZmluZVByb3BlcnR5ID0gZGVmaW5lUHJvcGVydHlNb2R1bGUkMy5mO1xuXG4gIGlmIChERVNDUklQVE9SUyQ2ICYmIENvbnN0cnVjdG9yICYmICFDb25zdHJ1Y3RvcltTUEVDSUVTJDRdKSB7XG4gICAgZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFNQRUNJRVMkNCwge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9XG4gICAgfSk7XG4gIH1cbn07XG5cbnZhciBpc1Byb3RvdHlwZU9mJDMgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xuXG52YXIgJFR5cGVFcnJvciQ4ID0gVHlwZUVycm9yO1xuXG52YXIgYW5JbnN0YW5jZSQzID0gZnVuY3Rpb24gKGl0LCBQcm90b3R5cGUpIHtcbiAgaWYgKGlzUHJvdG90eXBlT2YkMyhQcm90b3R5cGUsIGl0KSkgcmV0dXJuIGl0O1xuICB0aHJvdyAkVHlwZUVycm9yJDgoJ0luY29ycmVjdCBpbnZvY2F0aW9uJyk7XG59O1xuXG52YXIgd2VsbEtub3duU3ltYm9sJGYgPSB3ZWxsS25vd25TeW1ib2wkajtcblxudmFyIFRPX1NUUklOR19UQUckMyA9IHdlbGxLbm93blN5bWJvbCRmKCd0b1N0cmluZ1RhZycpO1xudmFyIHRlc3QgPSB7fTtcblxudGVzdFtUT19TVFJJTkdfVEFHJDNdID0gJ3onO1xuXG52YXIgdG9TdHJpbmdUYWdTdXBwb3J0ID0gU3RyaW5nKHRlc3QpID09PSAnW29iamVjdCB6XSc7XG5cbnZhciBUT19TVFJJTkdfVEFHX1NVUFBPUlQgPSB0b1N0cmluZ1RhZ1N1cHBvcnQ7XG52YXIgaXNDYWxsYWJsZSRiID0gaXNDYWxsYWJsZSRuO1xudmFyIGNsYXNzb2ZSYXcgPSBjbGFzc29mUmF3JDE7XG52YXIgd2VsbEtub3duU3ltYm9sJGUgPSB3ZWxsS25vd25TeW1ib2wkajtcblxudmFyIFRPX1NUUklOR19UQUckMiA9IHdlbGxLbm93blN5bWJvbCRlKCd0b1N0cmluZ1RhZycpO1xudmFyICRPYmplY3QkMSA9IE9iamVjdDtcblxuLy8gRVMzIHdyb25nIGhlcmVcbnZhciBDT1JSRUNUX0FSR1VNRU5UUyA9IGNsYXNzb2ZSYXcoZnVuY3Rpb24gKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID09ICdBcmd1bWVudHMnO1xuXG4vLyBmYWxsYmFjayBmb3IgSUUxMSBTY3JpcHQgQWNjZXNzIERlbmllZCBlcnJvclxudmFyIHRyeUdldCA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGl0W2tleV07XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbn07XG5cbi8vIGdldHRpbmcgdGFnIGZyb20gRVM2KyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2BcbnZhciBjbGFzc29mJDkgPSBUT19TVFJJTkdfVEFHX1NVUFBPUlQgPyBjbGFzc29mUmF3IDogZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBPLCB0YWcsIHJlc3VsdDtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXG4gICAgLy8gQEB0b1N0cmluZ1RhZyBjYXNlXG4gICAgOiB0eXBlb2YgKHRhZyA9IHRyeUdldChPID0gJE9iamVjdCQxKGl0KSwgVE9fU1RSSU5HX1RBRyQyKSkgPT0gJ3N0cmluZycgPyB0YWdcbiAgICAvLyBidWlsdGluVGFnIGNhc2VcbiAgICA6IENPUlJFQ1RfQVJHVU1FTlRTID8gY2xhc3NvZlJhdyhPKVxuICAgIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcbiAgICA6IChyZXN1bHQgPSBjbGFzc29mUmF3KE8pKSA9PSAnT2JqZWN0JyAmJiBpc0NhbGxhYmxlJGIoTy5jYWxsZWUpID8gJ0FyZ3VtZW50cycgOiByZXN1bHQ7XG59O1xuXG52YXIgdW5jdXJyeVRoaXMkZSA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgZmFpbHMkaiA9IGZhaWxzJHM7XG52YXIgaXNDYWxsYWJsZSRhID0gaXNDYWxsYWJsZSRuO1xudmFyIGNsYXNzb2YkOCA9IGNsYXNzb2YkOTtcbnZhciBnZXRCdWlsdEluJDMgPSBnZXRCdWlsdEluJDg7XG52YXIgaW5zcGVjdFNvdXJjZSQxID0gaW5zcGVjdFNvdXJjZSQ0O1xuXG52YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbnZhciBlbXB0eSA9IFtdO1xudmFyIGNvbnN0cnVjdCA9IGdldEJ1aWx0SW4kMygnUmVmbGVjdCcsICdjb25zdHJ1Y3QnKTtcbnZhciBjb25zdHJ1Y3RvclJlZ0V4cCA9IC9eXFxzKig/OmNsYXNzfGZ1bmN0aW9uKVxcYi87XG52YXIgZXhlYyQyID0gdW5jdXJyeVRoaXMkZShjb25zdHJ1Y3RvclJlZ0V4cC5leGVjKTtcbnZhciBJTkNPUlJFQ1RfVE9fU1RSSU5HID0gIWNvbnN0cnVjdG9yUmVnRXhwLmV4ZWMobm9vcCk7XG5cbnZhciBpc0NvbnN0cnVjdG9yTW9kZXJuID0gZnVuY3Rpb24gaXNDb25zdHJ1Y3Rvcihhcmd1bWVudCkge1xuICBpZiAoIWlzQ2FsbGFibGUkYShhcmd1bWVudCkpIHJldHVybiBmYWxzZTtcbiAgdHJ5IHtcbiAgICBjb25zdHJ1Y3Qobm9vcCwgZW1wdHksIGFyZ3VtZW50KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbnZhciBpc0NvbnN0cnVjdG9yTGVnYWN5ID0gZnVuY3Rpb24gaXNDb25zdHJ1Y3Rvcihhcmd1bWVudCkge1xuICBpZiAoIWlzQ2FsbGFibGUkYShhcmd1bWVudCkpIHJldHVybiBmYWxzZTtcbiAgc3dpdGNoIChjbGFzc29mJDgoYXJndW1lbnQpKSB7XG4gICAgY2FzZSAnQXN5bmNGdW5jdGlvbic6XG4gICAgY2FzZSAnR2VuZXJhdG9yRnVuY3Rpb24nOlxuICAgIGNhc2UgJ0FzeW5jR2VuZXJhdG9yRnVuY3Rpb24nOiByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdHJ5IHtcbiAgICAvLyB3ZSBjYW4ndCBjaGVjayAucHJvdG90eXBlIHNpbmNlIGNvbnN0cnVjdG9ycyBwcm9kdWNlZCBieSAuYmluZCBoYXZlbid0IGl0XG4gICAgLy8gYEZ1bmN0aW9uI3RvU3RyaW5nYCB0aHJvd3Mgb24gc29tZSBidWlsdC1pdCBmdW5jdGlvbiBpbiBzb21lIGxlZ2FjeSBlbmdpbmVzXG4gICAgLy8gKGZvciBleGFtcGxlLCBgRE9NUXVhZGAgYW5kIHNpbWlsYXIgaW4gRkY0MS0pXG4gICAgcmV0dXJuIElOQ09SUkVDVF9UT19TVFJJTkcgfHwgISFleGVjJDIoY29uc3RydWN0b3JSZWdFeHAsIGluc3BlY3RTb3VyY2UkMShhcmd1bWVudCkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG5pc0NvbnN0cnVjdG9yTGVnYWN5LnNoYW0gPSB0cnVlO1xuXG4vLyBgSXNDb25zdHJ1Y3RvcmAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWlzY29uc3RydWN0b3JcbnZhciBpc0NvbnN0cnVjdG9yJDIgPSAhY29uc3RydWN0IHx8IGZhaWxzJGooZnVuY3Rpb24gKCkge1xuICB2YXIgY2FsbGVkO1xuICByZXR1cm4gaXNDb25zdHJ1Y3Rvck1vZGVybihpc0NvbnN0cnVjdG9yTW9kZXJuLmNhbGwpXG4gICAgfHwgIWlzQ29uc3RydWN0b3JNb2Rlcm4oT2JqZWN0KVxuICAgIHx8ICFpc0NvbnN0cnVjdG9yTW9kZXJuKGZ1bmN0aW9uICgpIHsgY2FsbGVkID0gdHJ1ZTsgfSlcbiAgICB8fCBjYWxsZWQ7XG59KSA/IGlzQ29uc3RydWN0b3JMZWdhY3kgOiBpc0NvbnN0cnVjdG9yTW9kZXJuO1xuXG52YXIgaXNDb25zdHJ1Y3RvciQxID0gaXNDb25zdHJ1Y3RvciQyO1xudmFyIHRyeVRvU3RyaW5nJDMgPSB0cnlUb1N0cmluZyQ1O1xuXG52YXIgJFR5cGVFcnJvciQ3ID0gVHlwZUVycm9yO1xuXG4vLyBgQXNzZXJ0OiBJc0NvbnN0cnVjdG9yKGFyZ3VtZW50KSBpcyB0cnVlYFxudmFyIGFDb25zdHJ1Y3RvciQyID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmIChpc0NvbnN0cnVjdG9yJDEoYXJndW1lbnQpKSByZXR1cm4gYXJndW1lbnQ7XG4gIHRocm93ICRUeXBlRXJyb3IkNyh0cnlUb1N0cmluZyQzKGFyZ3VtZW50KSArICcgaXMgbm90IGEgY29uc3RydWN0b3InKTtcbn07XG5cbnZhciBhbk9iamVjdCRhID0gYW5PYmplY3QkZTtcbnZhciBhQ29uc3RydWN0b3IkMSA9IGFDb25zdHJ1Y3RvciQyO1xudmFyIHdlbGxLbm93blN5bWJvbCRkID0gd2VsbEtub3duU3ltYm9sJGo7XG5cbnZhciBTUEVDSUVTJDMgPSB3ZWxsS25vd25TeW1ib2wkZCgnc3BlY2llcycpO1xuXG4vLyBgU3BlY2llc0NvbnN0cnVjdG9yYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3BlY2llc2NvbnN0cnVjdG9yXG52YXIgc3BlY2llc0NvbnN0cnVjdG9yJDMgPSBmdW5jdGlvbiAoTywgZGVmYXVsdENvbnN0cnVjdG9yKSB7XG4gIHZhciBDID0gYW5PYmplY3QkYShPKS5jb25zdHJ1Y3RvcjtcbiAgdmFyIFM7XG4gIHJldHVybiBDID09PSB1bmRlZmluZWQgfHwgKFMgPSBhbk9iamVjdCRhKEMpW1NQRUNJRVMkM10pID09IHVuZGVmaW5lZCA/IGRlZmF1bHRDb25zdHJ1Y3RvciA6IGFDb25zdHJ1Y3RvciQxKFMpO1xufTtcblxudmFyIE5BVElWRV9CSU5EJDEgPSBmdW5jdGlvbkJpbmROYXRpdmU7XG5cbnZhciBGdW5jdGlvblByb3RvdHlwZSA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbnZhciBhcHBseSQzID0gRnVuY3Rpb25Qcm90b3R5cGUuYXBwbHk7XG52YXIgY2FsbCRnID0gRnVuY3Rpb25Qcm90b3R5cGUuY2FsbDtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tcmVmbGVjdCAtLSBzYWZlXG52YXIgZnVuY3Rpb25BcHBseSA9IHR5cGVvZiBSZWZsZWN0ID09ICdvYmplY3QnICYmIFJlZmxlY3QuYXBwbHkgfHwgKE5BVElWRV9CSU5EJDEgPyBjYWxsJGcuYmluZChhcHBseSQzKSA6IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGNhbGwkZy5hcHBseShhcHBseSQzLCBhcmd1bWVudHMpO1xufSk7XG5cbnZhciB1bmN1cnJ5VGhpcyRkID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBhQ2FsbGFibGUkNyA9IGFDYWxsYWJsZSQ5O1xudmFyIE5BVElWRV9CSU5EID0gZnVuY3Rpb25CaW5kTmF0aXZlO1xuXG52YXIgYmluZCQ2ID0gdW5jdXJyeVRoaXMkZCh1bmN1cnJ5VGhpcyRkLmJpbmQpO1xuXG4vLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBmdW5jdGlvbkJpbmRDb250ZXh0ID0gZnVuY3Rpb24gKGZuLCB0aGF0KSB7XG4gIGFDYWxsYWJsZSQ3KGZuKTtcbiAgcmV0dXJuIHRoYXQgPT09IHVuZGVmaW5lZCA/IGZuIDogTkFUSVZFX0JJTkQgPyBiaW5kJDYoZm4sIHRoYXQpIDogZnVuY3Rpb24gKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG5cbnZhciBnZXRCdWlsdEluJDIgPSBnZXRCdWlsdEluJDg7XG5cbnZhciBodG1sJDIgPSBnZXRCdWlsdEluJDIoJ2RvY3VtZW50JywgJ2RvY3VtZW50RWxlbWVudCcpO1xuXG52YXIgdW5jdXJyeVRoaXMkYyA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG5cbnZhciBhcnJheVNsaWNlJDUgPSB1bmN1cnJ5VGhpcyRjKFtdLnNsaWNlKTtcblxudmFyICRUeXBlRXJyb3IkNiA9IFR5cGVFcnJvcjtcblxudmFyIHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoJDEgPSBmdW5jdGlvbiAocGFzc2VkLCByZXF1aXJlZCkge1xuICBpZiAocGFzc2VkIDwgcmVxdWlyZWQpIHRocm93ICRUeXBlRXJyb3IkNignTm90IGVub3VnaCBhcmd1bWVudHMnKTtcbiAgcmV0dXJuIHBhc3NlZDtcbn07XG5cbnZhciB1c2VyQWdlbnQkNCA9IGVuZ2luZVVzZXJBZ2VudDtcblxudmFyIGVuZ2luZUlzSW9zID0gLyg/OmlwYWR8aXBob25lfGlwb2QpLiphcHBsZXdlYmtpdC9pLnRlc3QodXNlckFnZW50JDQpO1xuXG52YXIgZ2xvYmFsJGkgPSBnbG9iYWwkdDtcbnZhciBhcHBseSQyID0gZnVuY3Rpb25BcHBseTtcbnZhciBiaW5kJDUgPSBmdW5jdGlvbkJpbmRDb250ZXh0O1xudmFyIGlzQ2FsbGFibGUkOSA9IGlzQ2FsbGFibGUkbjtcbnZhciBoYXNPd24kMyA9IGhhc093blByb3BlcnR5XzE7XG52YXIgZmFpbHMkaSA9IGZhaWxzJHM7XG52YXIgaHRtbCQxID0gaHRtbCQyO1xudmFyIGFycmF5U2xpY2UkNCA9IGFycmF5U2xpY2UkNTtcbnZhciBjcmVhdGVFbGVtZW50ID0gZG9jdW1lbnRDcmVhdGVFbGVtZW50JDI7XG52YXIgdmFsaWRhdGVBcmd1bWVudHNMZW5ndGggPSB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aCQxO1xudmFyIElTX0lPUyQxID0gZW5naW5lSXNJb3M7XG52YXIgSVNfTk9ERSQzID0gZW5naW5lSXNOb2RlO1xuXG52YXIgc2V0JDEgPSBnbG9iYWwkaS5zZXRJbW1lZGlhdGU7XG52YXIgY2xlYXIgPSBnbG9iYWwkaS5jbGVhckltbWVkaWF0ZTtcbnZhciBwcm9jZXNzJDIgPSBnbG9iYWwkaS5wcm9jZXNzO1xudmFyIERpc3BhdGNoID0gZ2xvYmFsJGkuRGlzcGF0Y2g7XG52YXIgRnVuY3Rpb24kMSA9IGdsb2JhbCRpLkZ1bmN0aW9uO1xudmFyIE1lc3NhZ2VDaGFubmVsID0gZ2xvYmFsJGkuTWVzc2FnZUNoYW5uZWw7XG52YXIgU3RyaW5nJDEgPSBnbG9iYWwkaS5TdHJpbmc7XG52YXIgY291bnRlciA9IDA7XG52YXIgcXVldWUkMSA9IHt9O1xudmFyIE9OUkVBRFlTVEFURUNIQU5HRSA9ICdvbnJlYWR5c3RhdGVjaGFuZ2UnO1xudmFyIGxvY2F0aW9uLCBkZWZlciwgY2hhbm5lbCwgcG9ydDtcblxudHJ5IHtcbiAgLy8gRGVubyB0aHJvd3MgYSBSZWZlcmVuY2VFcnJvciBvbiBgbG9jYXRpb25gIGFjY2VzcyB3aXRob3V0IGAtLWxvY2F0aW9uYCBmbGFnXG4gIGxvY2F0aW9uID0gZ2xvYmFsJGkubG9jYXRpb247XG59IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG5cbnZhciBydW4gPSBmdW5jdGlvbiAoaWQpIHtcbiAgaWYgKGhhc093biQzKHF1ZXVlJDEsIGlkKSkge1xuICAgIHZhciBmbiA9IHF1ZXVlJDFbaWRdO1xuICAgIGRlbGV0ZSBxdWV1ZSQxW2lkXTtcbiAgICBmbigpO1xuICB9XG59O1xuXG52YXIgcnVubmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcnVuKGlkKTtcbiAgfTtcbn07XG5cbnZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudCkge1xuICBydW4oZXZlbnQuZGF0YSk7XG59O1xuXG52YXIgcG9zdCA9IGZ1bmN0aW9uIChpZCkge1xuICAvLyBvbGQgZW5naW5lcyBoYXZlIG5vdCBsb2NhdGlvbi5vcmlnaW5cbiAgZ2xvYmFsJGkucG9zdE1lc3NhZ2UoU3RyaW5nJDEoaWQpLCBsb2NhdGlvbi5wcm90b2NvbCArICcvLycgKyBsb2NhdGlvbi5ob3N0KTtcbn07XG5cbi8vIE5vZGUuanMgMC45KyAmIElFMTArIGhhcyBzZXRJbW1lZGlhdGUsIG90aGVyd2lzZTpcbmlmICghc2V0JDEgfHwgIWNsZWFyKSB7XG4gIHNldCQxID0gZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGhhbmRsZXIpIHtcbiAgICB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aChhcmd1bWVudHMubGVuZ3RoLCAxKTtcbiAgICB2YXIgZm4gPSBpc0NhbGxhYmxlJDkoaGFuZGxlcikgPyBoYW5kbGVyIDogRnVuY3Rpb24kMShoYW5kbGVyKTtcbiAgICB2YXIgYXJncyA9IGFycmF5U2xpY2UkNChhcmd1bWVudHMsIDEpO1xuICAgIHF1ZXVlJDFbKytjb3VudGVyXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGFwcGx5JDIoZm4sIHVuZGVmaW5lZCwgYXJncyk7XG4gICAgfTtcbiAgICBkZWZlcihjb3VudGVyKTtcbiAgICByZXR1cm4gY291bnRlcjtcbiAgfTtcbiAgY2xlYXIgPSBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShpZCkge1xuICAgIGRlbGV0ZSBxdWV1ZSQxW2lkXTtcbiAgfTtcbiAgLy8gTm9kZS5qcyAwLjgtXG4gIGlmIChJU19OT0RFJDMpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgcHJvY2VzcyQyLm5leHRUaWNrKHJ1bm5lcihpZCkpO1xuICAgIH07XG4gIC8vIFNwaGVyZSAoSlMgZ2FtZSBlbmdpbmUpIERpc3BhdGNoIEFQSVxuICB9IGVsc2UgaWYgKERpc3BhdGNoICYmIERpc3BhdGNoLm5vdykge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBEaXNwYXRjaC5ub3cocnVubmVyKGlkKSk7XG4gICAgfTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBNZXNzYWdlQ2hhbm5lbCwgaW5jbHVkZXMgV2ViV29ya2Vyc1xuICAvLyBleGNlcHQgaU9TIC0gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzYyNFxuICB9IGVsc2UgaWYgKE1lc3NhZ2VDaGFubmVsICYmICFJU19JT1MkMSkge1xuICAgIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICBwb3J0ID0gY2hhbm5lbC5wb3J0MjtcbiAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGxpc3RlbmVyO1xuICAgIGRlZmVyID0gYmluZCQ1KHBvcnQucG9zdE1lc3NhZ2UsIHBvcnQpO1xuICAvLyBCcm93c2VycyB3aXRoIHBvc3RNZXNzYWdlLCBza2lwIFdlYldvcmtlcnNcbiAgLy8gSUU4IGhhcyBwb3N0TWVzc2FnZSwgYnV0IGl0J3Mgc3luYyAmIHR5cGVvZiBpdHMgcG9zdE1lc3NhZ2UgaXMgJ29iamVjdCdcbiAgfSBlbHNlIGlmIChcbiAgICBnbG9iYWwkaS5hZGRFdmVudExpc3RlbmVyICYmXG4gICAgaXNDYWxsYWJsZSQ5KGdsb2JhbCRpLnBvc3RNZXNzYWdlKSAmJlxuICAgICFnbG9iYWwkaS5pbXBvcnRTY3JpcHRzICYmXG4gICAgbG9jYXRpb24gJiYgbG9jYXRpb24ucHJvdG9jb2wgIT09ICdmaWxlOicgJiZcbiAgICAhZmFpbHMkaShwb3N0KVxuICApIHtcbiAgICBkZWZlciA9IHBvc3Q7XG4gICAgZ2xvYmFsJGkuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGxpc3RlbmVyLCBmYWxzZSk7XG4gIC8vIElFOC1cbiAgfSBlbHNlIGlmIChPTlJFQURZU1RBVEVDSEFOR0UgaW4gY3JlYXRlRWxlbWVudCgnc2NyaXB0JykpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgaHRtbCQxLmFwcGVuZENoaWxkKGNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpKVtPTlJFQURZU1RBVEVDSEFOR0VdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBodG1sJDEucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgICAgIHJ1bihpZCk7XG4gICAgICB9O1xuICAgIH07XG4gIC8vIFJlc3Qgb2xkIGJyb3dzZXJzXG4gIH0gZWxzZSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHNldFRpbWVvdXQocnVubmVyKGlkKSwgMCk7XG4gICAgfTtcbiAgfVxufVxuXG52YXIgdGFzayQxID0ge1xuICBzZXQ6IHNldCQxLFxuICBjbGVhcjogY2xlYXJcbn07XG5cbnZhciB1c2VyQWdlbnQkMyA9IGVuZ2luZVVzZXJBZ2VudDtcbnZhciBnbG9iYWwkaCA9IGdsb2JhbCR0O1xuXG52YXIgZW5naW5lSXNJb3NQZWJibGUgPSAvaXBhZHxpcGhvbmV8aXBvZC9pLnRlc3QodXNlckFnZW50JDMpICYmIGdsb2JhbCRoLlBlYmJsZSAhPT0gdW5kZWZpbmVkO1xuXG52YXIgdXNlckFnZW50JDIgPSBlbmdpbmVVc2VyQWdlbnQ7XG5cbnZhciBlbmdpbmVJc1dlYm9zV2Via2l0ID0gL3dlYjBzKD8hLipjaHJvbWUpL2kudGVzdCh1c2VyQWdlbnQkMik7XG5cbnZhciBnbG9iYWwkZyA9IGdsb2JhbCR0O1xudmFyIGJpbmQkNCA9IGZ1bmN0aW9uQmluZENvbnRleHQ7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gb2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLmY7XG52YXIgbWFjcm90YXNrID0gdGFzayQxLnNldDtcbnZhciBJU19JT1MgPSBlbmdpbmVJc0lvcztcbnZhciBJU19JT1NfUEVCQkxFID0gZW5naW5lSXNJb3NQZWJibGU7XG52YXIgSVNfV0VCT1NfV0VCS0lUID0gZW5naW5lSXNXZWJvc1dlYmtpdDtcbnZhciBJU19OT0RFJDIgPSBlbmdpbmVJc05vZGU7XG5cbnZhciBNdXRhdGlvbk9ic2VydmVyID0gZ2xvYmFsJGcuTXV0YXRpb25PYnNlcnZlciB8fCBnbG9iYWwkZy5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xudmFyIGRvY3VtZW50JDIgPSBnbG9iYWwkZy5kb2N1bWVudDtcbnZhciBwcm9jZXNzJDEgPSBnbG9iYWwkZy5wcm9jZXNzO1xudmFyIFByb21pc2UkMSA9IGdsb2JhbCRnLlByb21pc2U7XG4vLyBOb2RlLmpzIDExIHNob3dzIEV4cGVyaW1lbnRhbFdhcm5pbmcgb24gZ2V0dGluZyBgcXVldWVNaWNyb3Rhc2tgXG52YXIgcXVldWVNaWNyb3Rhc2tEZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGdsb2JhbCRnLCAncXVldWVNaWNyb3Rhc2snKTtcbnZhciBxdWV1ZU1pY3JvdGFzayA9IHF1ZXVlTWljcm90YXNrRGVzY3JpcHRvciAmJiBxdWV1ZU1pY3JvdGFza0Rlc2NyaXB0b3IudmFsdWU7XG5cbnZhciBmbHVzaCwgaGVhZCwgbGFzdCwgbm90aWZ5JDEsIHRvZ2dsZSwgbm9kZSwgcHJvbWlzZSwgdGhlbjtcblxuLy8gbW9kZXJuIGVuZ2luZXMgaGF2ZSBxdWV1ZU1pY3JvdGFzayBtZXRob2RcbmlmICghcXVldWVNaWNyb3Rhc2spIHtcbiAgZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBhcmVudCwgZm47XG4gICAgaWYgKElTX05PREUkMiAmJiAocGFyZW50ID0gcHJvY2VzcyQxLmRvbWFpbikpIHBhcmVudC5leGl0KCk7XG4gICAgd2hpbGUgKGhlYWQpIHtcbiAgICAgIGZuID0gaGVhZC5mbjtcbiAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICAgICB0cnkge1xuICAgICAgICBmbigpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGhlYWQpIG5vdGlmeSQxKCk7XG4gICAgICAgIGVsc2UgbGFzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSBsYXN0ID0gdW5kZWZpbmVkO1xuICAgIGlmIChwYXJlbnQpIHBhcmVudC5lbnRlcigpO1xuICB9O1xuXG4gIC8vIGJyb3dzZXJzIHdpdGggTXV0YXRpb25PYnNlcnZlciwgZXhjZXB0IGlPUyAtIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8zMzlcbiAgLy8gYWxzbyBleGNlcHQgV2ViT1MgV2Via2l0IGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84OThcbiAgaWYgKCFJU19JT1MgJiYgIUlTX05PREUkMiAmJiAhSVNfV0VCT1NfV0VCS0lUICYmIE11dGF0aW9uT2JzZXJ2ZXIgJiYgZG9jdW1lbnQkMikge1xuICAgIHRvZ2dsZSA9IHRydWU7XG4gICAgbm9kZSA9IGRvY3VtZW50JDIuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgIG5ldyBNdXRhdGlvbk9ic2VydmVyKGZsdXNoKS5vYnNlcnZlKG5vZGUsIHsgY2hhcmFjdGVyRGF0YTogdHJ1ZSB9KTtcbiAgICBub3RpZnkkMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIG5vZGUuZGF0YSA9IHRvZ2dsZSA9ICF0b2dnbGU7XG4gICAgfTtcbiAgLy8gZW52aXJvbm1lbnRzIHdpdGggbWF5YmUgbm9uLWNvbXBsZXRlbHkgY29ycmVjdCwgYnV0IGV4aXN0ZW50IFByb21pc2VcbiAgfSBlbHNlIGlmICghSVNfSU9TX1BFQkJMRSAmJiBQcm9taXNlJDEgJiYgUHJvbWlzZSQxLnJlc29sdmUpIHtcbiAgICAvLyBQcm9taXNlLnJlc29sdmUgd2l0aG91dCBhbiBhcmd1bWVudCB0aHJvd3MgYW4gZXJyb3IgaW4gTEcgV2ViT1MgMlxuICAgIHByb21pc2UgPSBQcm9taXNlJDEucmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgIC8vIHdvcmthcm91bmQgb2YgV2ViS2l0IH4gaU9TIFNhZmFyaSAxMC4xIGJ1Z1xuICAgIHByb21pc2UuY29uc3RydWN0b3IgPSBQcm9taXNlJDE7XG4gICAgdGhlbiA9IGJpbmQkNChwcm9taXNlLnRoZW4sIHByb21pc2UpO1xuICAgIG5vdGlmeSQxID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhlbihmbHVzaCk7XG4gICAgfTtcbiAgLy8gTm9kZS5qcyB3aXRob3V0IHByb21pc2VzXG4gIH0gZWxzZSBpZiAoSVNfTk9ERSQyKSB7XG4gICAgbm90aWZ5JDEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwcm9jZXNzJDEubmV4dFRpY2soZmx1c2gpO1xuICAgIH07XG4gIC8vIGZvciBvdGhlciBlbnZpcm9ubWVudHMgLSBtYWNyb3Rhc2sgYmFzZWQgb246XG4gIC8vIC0gc2V0SW1tZWRpYXRlXG4gIC8vIC0gTWVzc2FnZUNoYW5uZWxcbiAgLy8gLSB3aW5kb3cucG9zdE1lc3NhZ2VcbiAgLy8gLSBvbnJlYWR5c3RhdGVjaGFuZ2VcbiAgLy8gLSBzZXRUaW1lb3V0XG4gIH0gZWxzZSB7XG4gICAgLy8gc3RyYW5nZSBJRSArIHdlYnBhY2sgZGV2IHNlcnZlciBidWcgLSB1c2UgLmJpbmQoZ2xvYmFsKVxuICAgIG1hY3JvdGFzayA9IGJpbmQkNChtYWNyb3Rhc2ssIGdsb2JhbCRnKTtcbiAgICBub3RpZnkkMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIG1hY3JvdGFzayhmbHVzaCk7XG4gICAgfTtcbiAgfVxufVxuXG52YXIgbWljcm90YXNrJDEgPSBxdWV1ZU1pY3JvdGFzayB8fCBmdW5jdGlvbiAoZm4pIHtcbiAgdmFyIHRhc2sgPSB7IGZuOiBmbiwgbmV4dDogdW5kZWZpbmVkIH07XG4gIGlmIChsYXN0KSBsYXN0Lm5leHQgPSB0YXNrO1xuICBpZiAoIWhlYWQpIHtcbiAgICBoZWFkID0gdGFzaztcbiAgICBub3RpZnkkMSgpO1xuICB9IGxhc3QgPSB0YXNrO1xufTtcblxudmFyIGdsb2JhbCRmID0gZ2xvYmFsJHQ7XG5cbnZhciBob3N0UmVwb3J0RXJyb3JzJDEgPSBmdW5jdGlvbiAoYSwgYikge1xuICB2YXIgY29uc29sZSA9IGdsb2JhbCRmLmNvbnNvbGU7XG4gIGlmIChjb25zb2xlICYmIGNvbnNvbGUuZXJyb3IpIHtcbiAgICBhcmd1bWVudHMubGVuZ3RoID09IDEgPyBjb25zb2xlLmVycm9yKGEpIDogY29uc29sZS5lcnJvcihhLCBiKTtcbiAgfVxufTtcblxudmFyIHBlcmZvcm0kMyA9IGZ1bmN0aW9uIChleGVjKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHsgZXJyb3I6IGZhbHNlLCB2YWx1ZTogZXhlYygpIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHsgZXJyb3I6IHRydWUsIHZhbHVlOiBlcnJvciB9O1xuICB9XG59O1xuXG52YXIgUXVldWUkMSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5oZWFkID0gbnVsbDtcbiAgdGhpcy50YWlsID0gbnVsbDtcbn07XG5cblF1ZXVlJDEucHJvdG90eXBlID0ge1xuICBhZGQ6IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgdmFyIGVudHJ5ID0geyBpdGVtOiBpdGVtLCBuZXh0OiBudWxsIH07XG4gICAgaWYgKHRoaXMuaGVhZCkgdGhpcy50YWlsLm5leHQgPSBlbnRyeTtcbiAgICBlbHNlIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgIHRoaXMudGFpbCA9IGVudHJ5O1xuICB9LFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZW50cnkgPSB0aGlzLmhlYWQ7XG4gICAgaWYgKGVudHJ5KSB7XG4gICAgICB0aGlzLmhlYWQgPSBlbnRyeS5uZXh0O1xuICAgICAgaWYgKHRoaXMudGFpbCA9PT0gZW50cnkpIHRoaXMudGFpbCA9IG51bGw7XG4gICAgICByZXR1cm4gZW50cnkuaXRlbTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBxdWV1ZSA9IFF1ZXVlJDE7XG5cbnZhciBnbG9iYWwkZSA9IGdsb2JhbCR0O1xuXG52YXIgcHJvbWlzZU5hdGl2ZUNvbnN0cnVjdG9yID0gZ2xvYmFsJGUuUHJvbWlzZTtcblxudmFyIGVuZ2luZUlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgdHlwZW9mIERlbm8gIT0gJ29iamVjdCc7XG5cbnZhciBnbG9iYWwkZCA9IGdsb2JhbCR0O1xudmFyIE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQzID0gcHJvbWlzZU5hdGl2ZUNvbnN0cnVjdG9yO1xudmFyIGlzQ2FsbGFibGUkOCA9IGlzQ2FsbGFibGUkbjtcbnZhciBpc0ZvcmNlZCA9IGlzRm9yY2VkXzE7XG52YXIgaW5zcGVjdFNvdXJjZSA9IGluc3BlY3RTb3VyY2UkNDtcbnZhciB3ZWxsS25vd25TeW1ib2wkYyA9IHdlbGxLbm93blN5bWJvbCRqO1xudmFyIElTX0JST1dTRVIgPSBlbmdpbmVJc0Jyb3dzZXI7XG52YXIgVjhfVkVSU0lPTiA9IGVuZ2luZVY4VmVyc2lvbjtcblxuTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yJDMgJiYgTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yJDMucHJvdG90eXBlO1xudmFyIFNQRUNJRVMkMiA9IHdlbGxLbm93blN5bWJvbCRjKCdzcGVjaWVzJyk7XG52YXIgU1VCQ0xBU1NJTkcgPSBmYWxzZTtcbnZhciBOQVRJVkVfUFJPTUlTRV9SRUpFQ1RJT05fRVZFTlQkMSA9IGlzQ2FsbGFibGUkOChnbG9iYWwkZC5Qcm9taXNlUmVqZWN0aW9uRXZlbnQpO1xuXG52YXIgRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkNSA9IGlzRm9yY2VkKCdQcm9taXNlJywgZnVuY3Rpb24gKCkge1xuICB2YXIgUFJPTUlTRV9DT05TVFJVQ1RPUl9TT1VSQ0UgPSBpbnNwZWN0U291cmNlKE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQzKTtcbiAgdmFyIEdMT0JBTF9DT1JFX0pTX1BST01JU0UgPSBQUk9NSVNFX0NPTlNUUlVDVE9SX1NPVVJDRSAhPT0gU3RyaW5nKE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQzKTtcbiAgLy8gVjggNi42IChOb2RlIDEwIGFuZCBDaHJvbWUgNjYpIGhhdmUgYSBidWcgd2l0aCByZXNvbHZpbmcgY3VzdG9tIHRoZW5hYmxlc1xuICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD04MzA1NjVcbiAgLy8gV2UgY2FuJ3QgZGV0ZWN0IGl0IHN5bmNocm9ub3VzbHksIHNvIGp1c3QgY2hlY2sgdmVyc2lvbnNcbiAgaWYgKCFHTE9CQUxfQ09SRV9KU19QUk9NSVNFICYmIFY4X1ZFUlNJT04gPT09IDY2KSByZXR1cm4gdHJ1ZTtcbiAgLy8gV2UgY2FuJ3QgdXNlIEBAc3BlY2llcyBmZWF0dXJlIGRldGVjdGlvbiBpbiBWOCBzaW5jZSBpdCBjYXVzZXNcbiAgLy8gZGVvcHRpbWl6YXRpb24gYW5kIHBlcmZvcm1hbmNlIGRlZ3JhZGF0aW9uXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy82NzlcbiAgaWYgKFY4X1ZFUlNJT04gPj0gNTEgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KFBST01JU0VfQ09OU1RSVUNUT1JfU09VUkNFKSkgcmV0dXJuIGZhbHNlO1xuICAvLyBEZXRlY3QgY29ycmVjdG5lc3Mgb2Ygc3ViY2xhc3Npbmcgd2l0aCBAQHNwZWNpZXMgc3VwcG9ydFxuICB2YXIgcHJvbWlzZSA9IG5ldyBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMyhmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKDEpOyB9KTtcbiAgdmFyIEZha2VQcm9taXNlID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgICBleGVjKGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSwgZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9KTtcbiAgfTtcbiAgdmFyIGNvbnN0cnVjdG9yID0gcHJvbWlzZS5jb25zdHJ1Y3RvciA9IHt9O1xuICBjb25zdHJ1Y3RvcltTUEVDSUVTJDJdID0gRmFrZVByb21pc2U7XG4gIFNVQkNMQVNTSU5HID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSkgaW5zdGFuY2VvZiBGYWtlUHJvbWlzZTtcbiAgaWYgKCFTVUJDTEFTU0lORykgcmV0dXJuIHRydWU7XG4gIC8vIFVuaGFuZGxlZCByZWplY3Rpb25zIHRyYWNraW5nIHN1cHBvcnQsIE5vZGVKUyBQcm9taXNlIHdpdGhvdXQgaXQgZmFpbHMgQEBzcGVjaWVzIHRlc3RcbiAgcmV0dXJuICFHTE9CQUxfQ09SRV9KU19QUk9NSVNFICYmIElTX0JST1dTRVIgJiYgIU5BVElWRV9QUk9NSVNFX1JFSkVDVElPTl9FVkVOVCQxO1xufSk7XG5cbnZhciBwcm9taXNlQ29uc3RydWN0b3JEZXRlY3Rpb24gPSB7XG4gIENPTlNUUlVDVE9SOiBGT1JDRURfUFJPTUlTRV9DT05TVFJVQ1RPUiQ1LFxuICBSRUpFQ1RJT05fRVZFTlQ6IE5BVElWRV9QUk9NSVNFX1JFSkVDVElPTl9FVkVOVCQxLFxuICBTVUJDTEFTU0lORzogU1VCQ0xBU1NJTkdcbn07XG5cbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSQyID0ge307XG5cbnZhciBhQ2FsbGFibGUkNiA9IGFDYWxsYWJsZSQ5O1xuXG52YXIgUHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbiAoQykge1xuICB2YXIgcmVzb2x2ZSwgcmVqZWN0O1xuICB0aGlzLnByb21pc2UgPSBuZXcgQyhmdW5jdGlvbiAoJCRyZXNvbHZlLCAkJHJlamVjdCkge1xuICAgIGlmIChyZXNvbHZlICE9PSB1bmRlZmluZWQgfHwgcmVqZWN0ICE9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcignQmFkIFByb21pc2UgY29uc3RydWN0b3InKTtcbiAgICByZXNvbHZlID0gJCRyZXNvbHZlO1xuICAgIHJlamVjdCA9ICQkcmVqZWN0O1xuICB9KTtcbiAgdGhpcy5yZXNvbHZlID0gYUNhbGxhYmxlJDYocmVzb2x2ZSk7XG4gIHRoaXMucmVqZWN0ID0gYUNhbGxhYmxlJDYocmVqZWN0KTtcbn07XG5cbi8vIGBOZXdQcm9taXNlQ2FwYWJpbGl0eWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW5ld3Byb21pc2VjYXBhYmlsaXR5XG5uZXdQcm9taXNlQ2FwYWJpbGl0eSQyLmYgPSBmdW5jdGlvbiAoQykge1xuICByZXR1cm4gbmV3IFByb21pc2VDYXBhYmlsaXR5KEMpO1xufTtcblxudmFyICQkZSA9IF9leHBvcnQ7XG52YXIgSVNfTk9ERSQxID0gZW5naW5lSXNOb2RlO1xudmFyIGdsb2JhbCRjID0gZ2xvYmFsJHQ7XG52YXIgY2FsbCRmID0gZnVuY3Rpb25DYWxsO1xudmFyIGRlZmluZUJ1aWx0SW4kNiA9IGRlZmluZUJ1aWx0SW4kODtcbnZhciBzZXRQcm90b3R5cGVPZiQ1ID0gb2JqZWN0U2V0UHJvdG90eXBlT2Y7XG52YXIgc2V0VG9TdHJpbmdUYWckMyA9IHNldFRvU3RyaW5nVGFnJDQ7XG52YXIgc2V0U3BlY2llcyQxID0gc2V0U3BlY2llcyQyO1xudmFyIGFDYWxsYWJsZSQ1ID0gYUNhbGxhYmxlJDk7XG52YXIgaXNDYWxsYWJsZSQ3ID0gaXNDYWxsYWJsZSRuO1xudmFyIGlzT2JqZWN0JDcgPSBpc09iamVjdCRkO1xudmFyIGFuSW5zdGFuY2UkMiA9IGFuSW5zdGFuY2UkMztcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IkMiA9IHNwZWNpZXNDb25zdHJ1Y3RvciQzO1xudmFyIHRhc2sgPSB0YXNrJDEuc2V0O1xudmFyIG1pY3JvdGFzayA9IG1pY3JvdGFzayQxO1xudmFyIGhvc3RSZXBvcnRFcnJvcnMgPSBob3N0UmVwb3J0RXJyb3JzJDE7XG52YXIgcGVyZm9ybSQyID0gcGVyZm9ybSQzO1xudmFyIFF1ZXVlID0gcXVldWU7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSQ0ID0gaW50ZXJuYWxTdGF0ZTtcbnZhciBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMiA9IHByb21pc2VOYXRpdmVDb25zdHJ1Y3RvcjtcbnZhciBQcm9taXNlQ29uc3RydWN0b3JEZXRlY3Rpb24gPSBwcm9taXNlQ29uc3RydWN0b3JEZXRlY3Rpb247XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUkMyA9IG5ld1Byb21pc2VDYXBhYmlsaXR5JDI7XG5cbnZhciBQUk9NSVNFID0gJ1Byb21pc2UnO1xudmFyIEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SJDQgPSBQcm9taXNlQ29uc3RydWN0b3JEZXRlY3Rpb24uQ09OU1RSVUNUT1I7XG52YXIgTkFUSVZFX1BST01JU0VfUkVKRUNUSU9OX0VWRU5UID0gUHJvbWlzZUNvbnN0cnVjdG9yRGV0ZWN0aW9uLlJFSkVDVElPTl9FVkVOVDtcbnZhciBOQVRJVkVfUFJPTUlTRV9TVUJDTEFTU0lORyA9IFByb21pc2VDb25zdHJ1Y3RvckRldGVjdGlvbi5TVUJDTEFTU0lORztcbnZhciBnZXRJbnRlcm5hbFByb21pc2VTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUkNC5nZXR0ZXJGb3IoUFJPTUlTRSk7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSQzID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQ0LnNldDtcbnZhciBOYXRpdmVQcm9taXNlUHJvdG90eXBlJDEgPSBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMiAmJiBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMi5wcm90b3R5cGU7XG52YXIgUHJvbWlzZUNvbnN0cnVjdG9yID0gTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yJDI7XG52YXIgUHJvbWlzZVByb3RvdHlwZSA9IE5hdGl2ZVByb21pc2VQcm90b3R5cGUkMTtcbnZhciBUeXBlRXJyb3IkMiA9IGdsb2JhbCRjLlR5cGVFcnJvcjtcbnZhciBkb2N1bWVudCQxID0gZ2xvYmFsJGMuZG9jdW1lbnQ7XG52YXIgcHJvY2VzcyA9IGdsb2JhbCRjLnByb2Nlc3M7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkkMSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlJDMuZjtcbnZhciBuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSQxO1xuXG52YXIgRElTUEFUQ0hfRVZFTlQgPSAhIShkb2N1bWVudCQxICYmIGRvY3VtZW50JDEuY3JlYXRlRXZlbnQgJiYgZ2xvYmFsJGMuZGlzcGF0Y2hFdmVudCk7XG52YXIgVU5IQU5ETEVEX1JFSkVDVElPTiA9ICd1bmhhbmRsZWRyZWplY3Rpb24nO1xudmFyIFJFSkVDVElPTl9IQU5ETEVEID0gJ3JlamVjdGlvbmhhbmRsZWQnO1xudmFyIFBFTkRJTkcgPSAwO1xudmFyIEZVTEZJTExFRCA9IDE7XG52YXIgUkVKRUNURUQgPSAyO1xudmFyIEhBTkRMRUQgPSAxO1xudmFyIFVOSEFORExFRCA9IDI7XG5cbnZhciBJbnRlcm5hbCwgT3duUHJvbWlzZUNhcGFiaWxpdHksIFByb21pc2VXcmFwcGVyLCBuYXRpdmVUaGVuO1xuXG4vLyBoZWxwZXJzXG52YXIgaXNUaGVuYWJsZSA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgdGhlbjtcbiAgcmV0dXJuIGlzT2JqZWN0JDcoaXQpICYmIGlzQ2FsbGFibGUkNyh0aGVuID0gaXQudGhlbikgPyB0aGVuIDogZmFsc2U7XG59O1xuXG52YXIgY2FsbFJlYWN0aW9uID0gZnVuY3Rpb24gKHJlYWN0aW9uLCBzdGF0ZSkge1xuICB2YXIgdmFsdWUgPSBzdGF0ZS52YWx1ZTtcbiAgdmFyIG9rID0gc3RhdGUuc3RhdGUgPT0gRlVMRklMTEVEO1xuICB2YXIgaGFuZGxlciA9IG9rID8gcmVhY3Rpb24ub2sgOiByZWFjdGlvbi5mYWlsO1xuICB2YXIgcmVzb2x2ZSA9IHJlYWN0aW9uLnJlc29sdmU7XG4gIHZhciByZWplY3QgPSByZWFjdGlvbi5yZWplY3Q7XG4gIHZhciBkb21haW4gPSByZWFjdGlvbi5kb21haW47XG4gIHZhciByZXN1bHQsIHRoZW4sIGV4aXRlZDtcbiAgdHJ5IHtcbiAgICBpZiAoaGFuZGxlcikge1xuICAgICAgaWYgKCFvaykge1xuICAgICAgICBpZiAoc3RhdGUucmVqZWN0aW9uID09PSBVTkhBTkRMRUQpIG9uSGFuZGxlVW5oYW5kbGVkKHN0YXRlKTtcbiAgICAgICAgc3RhdGUucmVqZWN0aW9uID0gSEFORExFRDtcbiAgICAgIH1cbiAgICAgIGlmIChoYW5kbGVyID09PSB0cnVlKSByZXN1bHQgPSB2YWx1ZTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoZG9tYWluKSBkb21haW4uZW50ZXIoKTtcbiAgICAgICAgcmVzdWx0ID0gaGFuZGxlcih2YWx1ZSk7IC8vIGNhbiB0aHJvd1xuICAgICAgICBpZiAoZG9tYWluKSB7XG4gICAgICAgICAgZG9tYWluLmV4aXQoKTtcbiAgICAgICAgICBleGl0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0ID09PSByZWFjdGlvbi5wcm9taXNlKSB7XG4gICAgICAgIHJlamVjdChUeXBlRXJyb3IkMignUHJvbWlzZS1jaGFpbiBjeWNsZScpKTtcbiAgICAgIH0gZWxzZSBpZiAodGhlbiA9IGlzVGhlbmFibGUocmVzdWx0KSkge1xuICAgICAgICBjYWxsJGYodGhlbiwgcmVzdWx0LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgfSBlbHNlIHJlc29sdmUocmVzdWx0KTtcbiAgICB9IGVsc2UgcmVqZWN0KHZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoZG9tYWluICYmICFleGl0ZWQpIGRvbWFpbi5leGl0KCk7XG4gICAgcmVqZWN0KGVycm9yKTtcbiAgfVxufTtcblxudmFyIG5vdGlmeSA9IGZ1bmN0aW9uIChzdGF0ZSwgaXNSZWplY3QpIHtcbiAgaWYgKHN0YXRlLm5vdGlmaWVkKSByZXR1cm47XG4gIHN0YXRlLm5vdGlmaWVkID0gdHJ1ZTtcbiAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVhY3Rpb25zID0gc3RhdGUucmVhY3Rpb25zO1xuICAgIHZhciByZWFjdGlvbjtcbiAgICB3aGlsZSAocmVhY3Rpb24gPSByZWFjdGlvbnMuZ2V0KCkpIHtcbiAgICAgIGNhbGxSZWFjdGlvbihyZWFjdGlvbiwgc3RhdGUpO1xuICAgIH1cbiAgICBzdGF0ZS5ub3RpZmllZCA9IGZhbHNlO1xuICAgIGlmIChpc1JlamVjdCAmJiAhc3RhdGUucmVqZWN0aW9uKSBvblVuaGFuZGxlZChzdGF0ZSk7XG4gIH0pO1xufTtcblxudmFyIGRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbiAobmFtZSwgcHJvbWlzZSwgcmVhc29uKSB7XG4gIHZhciBldmVudCwgaGFuZGxlcjtcbiAgaWYgKERJU1BBVENIX0VWRU5UKSB7XG4gICAgZXZlbnQgPSBkb2N1bWVudCQxLmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgIGV2ZW50LnByb21pc2UgPSBwcm9taXNlO1xuICAgIGV2ZW50LnJlYXNvbiA9IHJlYXNvbjtcbiAgICBldmVudC5pbml0RXZlbnQobmFtZSwgZmFsc2UsIHRydWUpO1xuICAgIGdsb2JhbCRjLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICB9IGVsc2UgZXZlbnQgPSB7IHByb21pc2U6IHByb21pc2UsIHJlYXNvbjogcmVhc29uIH07XG4gIGlmICghTkFUSVZFX1BST01JU0VfUkVKRUNUSU9OX0VWRU5UICYmIChoYW5kbGVyID0gZ2xvYmFsJGNbJ29uJyArIG5hbWVdKSkgaGFuZGxlcihldmVudCk7XG4gIGVsc2UgaWYgKG5hbWUgPT09IFVOSEFORExFRF9SRUpFQ1RJT04pIGhvc3RSZXBvcnRFcnJvcnMoJ1VuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbicsIHJlYXNvbik7XG59O1xuXG52YXIgb25VbmhhbmRsZWQgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgY2FsbCRmKHRhc2ssIGdsb2JhbCRjLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByb21pc2UgPSBzdGF0ZS5mYWNhZGU7XG4gICAgdmFyIHZhbHVlID0gc3RhdGUudmFsdWU7XG4gICAgdmFyIElTX1VOSEFORExFRCA9IGlzVW5oYW5kbGVkKHN0YXRlKTtcbiAgICB2YXIgcmVzdWx0O1xuICAgIGlmIChJU19VTkhBTkRMRUQpIHtcbiAgICAgIHJlc3VsdCA9IHBlcmZvcm0kMihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChJU19OT0RFJDEpIHtcbiAgICAgICAgICBwcm9jZXNzLmVtaXQoJ3VuaGFuZGxlZFJlamVjdGlvbicsIHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgfSBlbHNlIGRpc3BhdGNoRXZlbnQoVU5IQU5ETEVEX1JFSkVDVElPTiwgcHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgICAvLyBCcm93c2VycyBzaG91bGQgbm90IHRyaWdnZXIgYHJlamVjdGlvbkhhbmRsZWRgIGV2ZW50IGlmIGl0IHdhcyBoYW5kbGVkIGhlcmUsIE5vZGVKUyAtIHNob3VsZFxuICAgICAgc3RhdGUucmVqZWN0aW9uID0gSVNfTk9ERSQxIHx8IGlzVW5oYW5kbGVkKHN0YXRlKSA/IFVOSEFORExFRCA6IEhBTkRMRUQ7XG4gICAgICBpZiAocmVzdWx0LmVycm9yKSB0aHJvdyByZXN1bHQudmFsdWU7XG4gICAgfVxuICB9KTtcbn07XG5cbnZhciBpc1VuaGFuZGxlZCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUucmVqZWN0aW9uICE9PSBIQU5ETEVEICYmICFzdGF0ZS5wYXJlbnQ7XG59O1xuXG52YXIgb25IYW5kbGVVbmhhbmRsZWQgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgY2FsbCRmKHRhc2ssIGdsb2JhbCRjLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByb21pc2UgPSBzdGF0ZS5mYWNhZGU7XG4gICAgaWYgKElTX05PREUkMSkge1xuICAgICAgcHJvY2Vzcy5lbWl0KCdyZWplY3Rpb25IYW5kbGVkJywgcHJvbWlzZSk7XG4gICAgfSBlbHNlIGRpc3BhdGNoRXZlbnQoUkVKRUNUSU9OX0hBTkRMRUQsIHByb21pc2UsIHN0YXRlLnZhbHVlKTtcbiAgfSk7XG59O1xuXG52YXIgYmluZCQzID0gZnVuY3Rpb24gKGZuLCBzdGF0ZSwgdW53cmFwKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBmbihzdGF0ZSwgdmFsdWUsIHVud3JhcCk7XG4gIH07XG59O1xuXG52YXIgaW50ZXJuYWxSZWplY3QgPSBmdW5jdGlvbiAoc3RhdGUsIHZhbHVlLCB1bndyYXApIHtcbiAgaWYgKHN0YXRlLmRvbmUpIHJldHVybjtcbiAgc3RhdGUuZG9uZSA9IHRydWU7XG4gIGlmICh1bndyYXApIHN0YXRlID0gdW53cmFwO1xuICBzdGF0ZS52YWx1ZSA9IHZhbHVlO1xuICBzdGF0ZS5zdGF0ZSA9IFJFSkVDVEVEO1xuICBub3RpZnkoc3RhdGUsIHRydWUpO1xufTtcblxudmFyIGludGVybmFsUmVzb2x2ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgdmFsdWUsIHVud3JhcCkge1xuICBpZiAoc3RhdGUuZG9uZSkgcmV0dXJuO1xuICBzdGF0ZS5kb25lID0gdHJ1ZTtcbiAgaWYgKHVud3JhcCkgc3RhdGUgPSB1bndyYXA7XG4gIHRyeSB7XG4gICAgaWYgKHN0YXRlLmZhY2FkZSA9PT0gdmFsdWUpIHRocm93IFR5cGVFcnJvciQyKFwiUHJvbWlzZSBjYW4ndCBiZSByZXNvbHZlZCBpdHNlbGZcIik7XG4gICAgdmFyIHRoZW4gPSBpc1RoZW5hYmxlKHZhbHVlKTtcbiAgICBpZiAodGhlbikge1xuICAgICAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHdyYXBwZXIgPSB7IGRvbmU6IGZhbHNlIH07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2FsbCRmKHRoZW4sIHZhbHVlLFxuICAgICAgICAgICAgYmluZCQzKGludGVybmFsUmVzb2x2ZSwgd3JhcHBlciwgc3RhdGUpLFxuICAgICAgICAgICAgYmluZCQzKGludGVybmFsUmVqZWN0LCB3cmFwcGVyLCBzdGF0ZSlcbiAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGludGVybmFsUmVqZWN0KHdyYXBwZXIsIGVycm9yLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS52YWx1ZSA9IHZhbHVlO1xuICAgICAgc3RhdGUuc3RhdGUgPSBGVUxGSUxMRUQ7XG4gICAgICBub3RpZnkoc3RhdGUsIGZhbHNlKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaW50ZXJuYWxSZWplY3QoeyBkb25lOiBmYWxzZSB9LCBlcnJvciwgc3RhdGUpO1xuICB9XG59O1xuXG4vLyBjb25zdHJ1Y3RvciBwb2x5ZmlsbFxuaWYgKEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SJDQpIHtcbiAgLy8gMjUuNC4zLjEgUHJvbWlzZShleGVjdXRvcilcbiAgUHJvbWlzZUNvbnN0cnVjdG9yID0gZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcikge1xuICAgIGFuSW5zdGFuY2UkMih0aGlzLCBQcm9taXNlUHJvdG90eXBlKTtcbiAgICBhQ2FsbGFibGUkNShleGVjdXRvcik7XG4gICAgY2FsbCRmKEludGVybmFsLCB0aGlzKTtcbiAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFByb21pc2VTdGF0ZSh0aGlzKTtcbiAgICB0cnkge1xuICAgICAgZXhlY3V0b3IoYmluZCQzKGludGVybmFsUmVzb2x2ZSwgc3RhdGUpLCBiaW5kJDMoaW50ZXJuYWxSZWplY3QsIHN0YXRlKSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGludGVybmFsUmVqZWN0KHN0YXRlLCBlcnJvcik7XG4gICAgfVxuICB9O1xuXG4gIFByb21pc2VQcm90b3R5cGUgPSBQcm9taXNlQ29uc3RydWN0b3IucHJvdG90eXBlO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFycyAtLSByZXF1aXJlZCBmb3IgYC5sZW5ndGhgXG4gIEludGVybmFsID0gZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcikge1xuICAgIHNldEludGVybmFsU3RhdGUkMyh0aGlzLCB7XG4gICAgICB0eXBlOiBQUk9NSVNFLFxuICAgICAgZG9uZTogZmFsc2UsXG4gICAgICBub3RpZmllZDogZmFsc2UsXG4gICAgICBwYXJlbnQ6IGZhbHNlLFxuICAgICAgcmVhY3Rpb25zOiBuZXcgUXVldWUoKSxcbiAgICAgIHJlamVjdGlvbjogZmFsc2UsXG4gICAgICBzdGF0ZTogUEVORElORyxcbiAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICB9KTtcbiAgfTtcblxuICAvLyBgUHJvbWlzZS5wcm90b3R5cGUudGhlbmAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcHJvbWlzZS5wcm90b3R5cGUudGhlblxuICBJbnRlcm5hbC5wcm90b3R5cGUgPSBkZWZpbmVCdWlsdEluJDYoUHJvbWlzZVByb3RvdHlwZSwgJ3RoZW4nLCBmdW5jdGlvbiB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxQcm9taXNlU3RhdGUodGhpcyk7XG4gICAgdmFyIHJlYWN0aW9uID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkkMShzcGVjaWVzQ29uc3RydWN0b3IkMih0aGlzLCBQcm9taXNlQ29uc3RydWN0b3IpKTtcbiAgICBzdGF0ZS5wYXJlbnQgPSB0cnVlO1xuICAgIHJlYWN0aW9uLm9rID0gaXNDYWxsYWJsZSQ3KG9uRnVsZmlsbGVkKSA/IG9uRnVsZmlsbGVkIDogdHJ1ZTtcbiAgICByZWFjdGlvbi5mYWlsID0gaXNDYWxsYWJsZSQ3KG9uUmVqZWN0ZWQpICYmIG9uUmVqZWN0ZWQ7XG4gICAgcmVhY3Rpb24uZG9tYWluID0gSVNfTk9ERSQxID8gcHJvY2Vzcy5kb21haW4gOiB1bmRlZmluZWQ7XG4gICAgaWYgKHN0YXRlLnN0YXRlID09IFBFTkRJTkcpIHN0YXRlLnJlYWN0aW9ucy5hZGQocmVhY3Rpb24pO1xuICAgIGVsc2UgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxSZWFjdGlvbihyZWFjdGlvbiwgc3RhdGUpO1xuICAgIH0pO1xuICAgIHJldHVybiByZWFjdGlvbi5wcm9taXNlO1xuICB9KTtcblxuICBPd25Qcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBJbnRlcm5hbCgpO1xuICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsUHJvbWlzZVN0YXRlKHByb21pc2UpO1xuICAgIHRoaXMucHJvbWlzZSA9IHByb21pc2U7XG4gICAgdGhpcy5yZXNvbHZlID0gYmluZCQzKGludGVybmFsUmVzb2x2ZSwgc3RhdGUpO1xuICAgIHRoaXMucmVqZWN0ID0gYmluZCQzKGludGVybmFsUmVqZWN0LCBzdGF0ZSk7XG4gIH07XG5cbiAgbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUkMy5mID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkkMSA9IGZ1bmN0aW9uIChDKSB7XG4gICAgcmV0dXJuIEMgPT09IFByb21pc2VDb25zdHJ1Y3RvciB8fCBDID09PSBQcm9taXNlV3JhcHBlclxuICAgICAgPyBuZXcgT3duUHJvbWlzZUNhcGFiaWxpdHkoQylcbiAgICAgIDogbmV3R2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5KEMpO1xuICB9O1xuXG4gIGlmIChpc0NhbGxhYmxlJDcoTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yJDIpICYmIE5hdGl2ZVByb21pc2VQcm90b3R5cGUkMSAhPT0gT2JqZWN0LnByb3RvdHlwZSkge1xuICAgIG5hdGl2ZVRoZW4gPSBOYXRpdmVQcm9taXNlUHJvdG90eXBlJDEudGhlbjtcblxuICAgIGlmICghTkFUSVZFX1BST01JU0VfU1VCQ0xBU1NJTkcpIHtcbiAgICAgIC8vIG1ha2UgYFByb21pc2UjdGhlbmAgcmV0dXJuIGEgcG9seWZpbGxlZCBgUHJvbWlzZWAgZm9yIG5hdGl2ZSBwcm9taXNlLWJhc2VkIEFQSXNcbiAgICAgIGRlZmluZUJ1aWx0SW4kNihOYXRpdmVQcm9taXNlUHJvdG90eXBlJDEsICd0aGVuJywgZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZUNvbnN0cnVjdG9yKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBjYWxsJGYobmF0aXZlVGhlbiwgdGhhdCwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSkudGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCk7XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNjQwXG4gICAgICB9LCB7IHVuc2FmZTogdHJ1ZSB9KTtcbiAgICB9XG5cbiAgICAvLyBtYWtlIGAuY29uc3RydWN0b3IgPT09IFByb21pc2VgIHdvcmsgZm9yIG5hdGl2ZSBwcm9taXNlLWJhc2VkIEFQSXNcbiAgICB0cnkge1xuICAgICAgZGVsZXRlIE5hdGl2ZVByb21pc2VQcm90b3R5cGUkMS5jb25zdHJ1Y3RvcjtcbiAgICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG5cbiAgICAvLyBtYWtlIGBpbnN0YW5jZW9mIFByb21pc2VgIHdvcmsgZm9yIG5hdGl2ZSBwcm9taXNlLWJhc2VkIEFQSXNcbiAgICBpZiAoc2V0UHJvdG90eXBlT2YkNSkge1xuICAgICAgc2V0UHJvdG90eXBlT2YkNShOYXRpdmVQcm9taXNlUHJvdG90eXBlJDEsIFByb21pc2VQcm90b3R5cGUpO1xuICAgIH1cbiAgfVxufVxuXG4kJGUoeyBnbG9iYWw6IHRydWUsIGNvbnN0cnVjdG9yOiB0cnVlLCB3cmFwOiB0cnVlLCBmb3JjZWQ6IEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SJDQgfSwge1xuICBQcm9taXNlOiBQcm9taXNlQ29uc3RydWN0b3Jcbn0pO1xuXG5zZXRUb1N0cmluZ1RhZyQzKFByb21pc2VDb25zdHJ1Y3RvciwgUFJPTUlTRSwgZmFsc2UpO1xuc2V0U3BlY2llcyQxKFBST01JU0UpO1xuXG52YXIgaXRlcmF0b3JzID0ge307XG5cbnZhciB3ZWxsS25vd25TeW1ib2wkYiA9IHdlbGxLbm93blN5bWJvbCRqO1xudmFyIEl0ZXJhdG9ycyQ0ID0gaXRlcmF0b3JzO1xuXG52YXIgSVRFUkFUT1IkNSA9IHdlbGxLbm93blN5bWJvbCRiKCdpdGVyYXRvcicpO1xudmFyIEFycmF5UHJvdG90eXBlJDEgPSBBcnJheS5wcm90b3R5cGU7XG5cbi8vIGNoZWNrIG9uIGRlZmF1bHQgQXJyYXkgaXRlcmF0b3JcbnZhciBpc0FycmF5SXRlcmF0b3JNZXRob2QkMiA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJiAoSXRlcmF0b3JzJDQuQXJyYXkgPT09IGl0IHx8IEFycmF5UHJvdG90eXBlJDFbSVRFUkFUT1IkNV0gPT09IGl0KTtcbn07XG5cbnZhciBjbGFzc29mJDcgPSBjbGFzc29mJDk7XG52YXIgZ2V0TWV0aG9kJDIgPSBnZXRNZXRob2QkNDtcbnZhciBJdGVyYXRvcnMkMyA9IGl0ZXJhdG9ycztcbnZhciB3ZWxsS25vd25TeW1ib2wkYSA9IHdlbGxLbm93blN5bWJvbCRqO1xuXG52YXIgSVRFUkFUT1IkNCA9IHdlbGxLbm93blN5bWJvbCRhKCdpdGVyYXRvcicpO1xuXG52YXIgZ2V0SXRlcmF0b3JNZXRob2QkMyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgIT0gdW5kZWZpbmVkKSByZXR1cm4gZ2V0TWV0aG9kJDIoaXQsIElURVJBVE9SJDQpXG4gICAgfHwgZ2V0TWV0aG9kJDIoaXQsICdAQGl0ZXJhdG9yJylcbiAgICB8fCBJdGVyYXRvcnMkM1tjbGFzc29mJDcoaXQpXTtcbn07XG5cbnZhciBjYWxsJGUgPSBmdW5jdGlvbkNhbGw7XG52YXIgYUNhbGxhYmxlJDQgPSBhQ2FsbGFibGUkOTtcbnZhciBhbk9iamVjdCQ5ID0gYW5PYmplY3QkZTtcbnZhciB0cnlUb1N0cmluZyQyID0gdHJ5VG9TdHJpbmckNTtcbnZhciBnZXRJdGVyYXRvck1ldGhvZCQyID0gZ2V0SXRlcmF0b3JNZXRob2QkMztcblxudmFyICRUeXBlRXJyb3IkNSA9IFR5cGVFcnJvcjtcblxudmFyIGdldEl0ZXJhdG9yJDIgPSBmdW5jdGlvbiAoYXJndW1lbnQsIHVzaW5nSXRlcmF0b3IpIHtcbiAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBnZXRJdGVyYXRvck1ldGhvZCQyKGFyZ3VtZW50KSA6IHVzaW5nSXRlcmF0b3I7XG4gIGlmIChhQ2FsbGFibGUkNChpdGVyYXRvck1ldGhvZCkpIHJldHVybiBhbk9iamVjdCQ5KGNhbGwkZShpdGVyYXRvck1ldGhvZCwgYXJndW1lbnQpKTtcbiAgdGhyb3cgJFR5cGVFcnJvciQ1KHRyeVRvU3RyaW5nJDIoYXJndW1lbnQpICsgJyBpcyBub3QgaXRlcmFibGUnKTtcbn07XG5cbnZhciBjYWxsJGQgPSBmdW5jdGlvbkNhbGw7XG52YXIgYW5PYmplY3QkOCA9IGFuT2JqZWN0JGU7XG52YXIgZ2V0TWV0aG9kJDEgPSBnZXRNZXRob2QkNDtcblxudmFyIGl0ZXJhdG9yQ2xvc2UkMSA9IGZ1bmN0aW9uIChpdGVyYXRvciwga2luZCwgdmFsdWUpIHtcbiAgdmFyIGlubmVyUmVzdWx0LCBpbm5lckVycm9yO1xuICBhbk9iamVjdCQ4KGl0ZXJhdG9yKTtcbiAgdHJ5IHtcbiAgICBpbm5lclJlc3VsdCA9IGdldE1ldGhvZCQxKGl0ZXJhdG9yLCAncmV0dXJuJyk7XG4gICAgaWYgKCFpbm5lclJlc3VsdCkge1xuICAgICAgaWYgKGtpbmQgPT09ICd0aHJvdycpIHRocm93IHZhbHVlO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpbm5lclJlc3VsdCA9IGNhbGwkZChpbm5lclJlc3VsdCwgaXRlcmF0b3IpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlubmVyRXJyb3IgPSB0cnVlO1xuICAgIGlubmVyUmVzdWx0ID0gZXJyb3I7XG4gIH1cbiAgaWYgKGtpbmQgPT09ICd0aHJvdycpIHRocm93IHZhbHVlO1xuICBpZiAoaW5uZXJFcnJvcikgdGhyb3cgaW5uZXJSZXN1bHQ7XG4gIGFuT2JqZWN0JDgoaW5uZXJSZXN1bHQpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuXG52YXIgYmluZCQyID0gZnVuY3Rpb25CaW5kQ29udGV4dDtcbnZhciBjYWxsJGMgPSBmdW5jdGlvbkNhbGw7XG52YXIgYW5PYmplY3QkNyA9IGFuT2JqZWN0JGU7XG52YXIgdHJ5VG9TdHJpbmckMSA9IHRyeVRvU3RyaW5nJDU7XG52YXIgaXNBcnJheUl0ZXJhdG9yTWV0aG9kJDEgPSBpc0FycmF5SXRlcmF0b3JNZXRob2QkMjtcbnZhciBsZW5ndGhPZkFycmF5TGlrZSQ2ID0gbGVuZ3RoT2ZBcnJheUxpa2UkODtcbnZhciBpc1Byb3RvdHlwZU9mJDIgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xudmFyIGdldEl0ZXJhdG9yJDEgPSBnZXRJdGVyYXRvciQyO1xudmFyIGdldEl0ZXJhdG9yTWV0aG9kJDEgPSBnZXRJdGVyYXRvck1ldGhvZCQzO1xudmFyIGl0ZXJhdG9yQ2xvc2UgPSBpdGVyYXRvckNsb3NlJDE7XG5cbnZhciAkVHlwZUVycm9yJDQgPSBUeXBlRXJyb3I7XG5cbnZhciBSZXN1bHQgPSBmdW5jdGlvbiAoc3RvcHBlZCwgcmVzdWx0KSB7XG4gIHRoaXMuc3RvcHBlZCA9IHN0b3BwZWQ7XG4gIHRoaXMucmVzdWx0ID0gcmVzdWx0O1xufTtcblxudmFyIFJlc3VsdFByb3RvdHlwZSA9IFJlc3VsdC5wcm90b3R5cGU7XG5cbnZhciBpdGVyYXRlJDIgPSBmdW5jdGlvbiAoaXRlcmFibGUsIHVuYm91bmRGdW5jdGlvbiwgb3B0aW9ucykge1xuICB2YXIgdGhhdCA9IG9wdGlvbnMgJiYgb3B0aW9ucy50aGF0O1xuICB2YXIgQVNfRU5UUklFUyA9ICEhKG9wdGlvbnMgJiYgb3B0aW9ucy5BU19FTlRSSUVTKTtcbiAgdmFyIElTX0lURVJBVE9SID0gISEob3B0aW9ucyAmJiBvcHRpb25zLklTX0lURVJBVE9SKTtcbiAgdmFyIElOVEVSUlVQVEVEID0gISEob3B0aW9ucyAmJiBvcHRpb25zLklOVEVSUlVQVEVEKTtcbiAgdmFyIGZuID0gYmluZCQyKHVuYm91bmRGdW5jdGlvbiwgdGhhdCk7XG4gIHZhciBpdGVyYXRvciwgaXRlckZuLCBpbmRleCwgbGVuZ3RoLCByZXN1bHQsIG5leHQsIHN0ZXA7XG5cbiAgdmFyIHN0b3AgPSBmdW5jdGlvbiAoY29uZGl0aW9uKSB7XG4gICAgaWYgKGl0ZXJhdG9yKSBpdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCAnbm9ybWFsJywgY29uZGl0aW9uKTtcbiAgICByZXR1cm4gbmV3IFJlc3VsdCh0cnVlLCBjb25kaXRpb24pO1xuICB9O1xuXG4gIHZhciBjYWxsRm4gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAoQVNfRU5UUklFUykge1xuICAgICAgYW5PYmplY3QkNyh2YWx1ZSk7XG4gICAgICByZXR1cm4gSU5URVJSVVBURUQgPyBmbih2YWx1ZVswXSwgdmFsdWVbMV0sIHN0b3ApIDogZm4odmFsdWVbMF0sIHZhbHVlWzFdKTtcbiAgICB9IHJldHVybiBJTlRFUlJVUFRFRCA/IGZuKHZhbHVlLCBzdG9wKSA6IGZuKHZhbHVlKTtcbiAgfTtcblxuICBpZiAoSVNfSVRFUkFUT1IpIHtcbiAgICBpdGVyYXRvciA9IGl0ZXJhYmxlO1xuICB9IGVsc2Uge1xuICAgIGl0ZXJGbiA9IGdldEl0ZXJhdG9yTWV0aG9kJDEoaXRlcmFibGUpO1xuICAgIGlmICghaXRlckZuKSB0aHJvdyAkVHlwZUVycm9yJDQodHJ5VG9TdHJpbmckMShpdGVyYWJsZSkgKyAnIGlzIG5vdCBpdGVyYWJsZScpO1xuICAgIC8vIG9wdGltaXNhdGlvbiBmb3IgYXJyYXkgaXRlcmF0b3JzXG4gICAgaWYgKGlzQXJyYXlJdGVyYXRvck1ldGhvZCQxKGl0ZXJGbikpIHtcbiAgICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBsZW5ndGhPZkFycmF5TGlrZSQ2KGl0ZXJhYmxlKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICAgICAgcmVzdWx0ID0gY2FsbEZuKGl0ZXJhYmxlW2luZGV4XSk7XG4gICAgICAgIGlmIChyZXN1bHQgJiYgaXNQcm90b3R5cGVPZiQyKFJlc3VsdFByb3RvdHlwZSwgcmVzdWx0KSkgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0gcmV0dXJuIG5ldyBSZXN1bHQoZmFsc2UpO1xuICAgIH1cbiAgICBpdGVyYXRvciA9IGdldEl0ZXJhdG9yJDEoaXRlcmFibGUsIGl0ZXJGbik7XG4gIH1cblxuICBuZXh0ID0gaXRlcmF0b3IubmV4dDtcbiAgd2hpbGUgKCEoc3RlcCA9IGNhbGwkYyhuZXh0LCBpdGVyYXRvcikpLmRvbmUpIHtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gY2FsbEZuKHN0ZXAudmFsdWUpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCAndGhyb3cnLCBlcnJvcik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcmVzdWx0ID09ICdvYmplY3QnICYmIHJlc3VsdCAmJiBpc1Byb3RvdHlwZU9mJDIoUmVzdWx0UHJvdG90eXBlLCByZXN1bHQpKSByZXR1cm4gcmVzdWx0O1xuICB9IHJldHVybiBuZXcgUmVzdWx0KGZhbHNlKTtcbn07XG5cbnZhciB3ZWxsS25vd25TeW1ib2wkOSA9IHdlbGxLbm93blN5bWJvbCRqO1xuXG52YXIgSVRFUkFUT1IkMyA9IHdlbGxLbm93blN5bWJvbCQ5KCdpdGVyYXRvcicpO1xudmFyIFNBRkVfQ0xPU0lORyA9IGZhbHNlO1xuXG50cnkge1xuICB2YXIgY2FsbGVkID0gMDtcbiAgdmFyIGl0ZXJhdG9yV2l0aFJldHVybiA9IHtcbiAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4geyBkb25lOiAhIWNhbGxlZCsrIH07XG4gICAgfSxcbiAgICAncmV0dXJuJzogZnVuY3Rpb24gKCkge1xuICAgICAgU0FGRV9DTE9TSU5HID0gdHJ1ZTtcbiAgICB9XG4gIH07XG4gIGl0ZXJhdG9yV2l0aFJldHVybltJVEVSQVRPUiQzXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tYXJyYXktZnJvbSwgbm8tdGhyb3ctbGl0ZXJhbCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICBBcnJheS5mcm9tKGl0ZXJhdG9yV2l0aFJldHVybiwgZnVuY3Rpb24gKCkgeyB0aHJvdyAyOyB9KTtcbn0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cblxudmFyIGNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbiQyID0gZnVuY3Rpb24gKGV4ZWMsIFNLSVBfQ0xPU0lORykge1xuICBpZiAoIVNLSVBfQ0xPU0lORyAmJiAhU0FGRV9DTE9TSU5HKSByZXR1cm4gZmFsc2U7XG4gIHZhciBJVEVSQVRJT05fU1VQUE9SVCA9IGZhbHNlO1xuICB0cnkge1xuICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICBvYmplY3RbSVRFUkFUT1IkM10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHsgZG9uZTogSVRFUkFUSU9OX1NVUFBPUlQgPSB0cnVlIH07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcbiAgICBleGVjKG9iamVjdCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIElURVJBVElPTl9TVVBQT1JUO1xufTtcblxudmFyIE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQxID0gcHJvbWlzZU5hdGl2ZUNvbnN0cnVjdG9yO1xudmFyIGNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbiQxID0gY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uJDI7XG52YXIgRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkMyA9IHByb21pc2VDb25zdHJ1Y3RvckRldGVjdGlvbi5DT05TVFJVQ1RPUjtcblxudmFyIHByb21pc2VTdGF0aWNzSW5jb3JyZWN0SXRlcmF0aW9uID0gRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkMyB8fCAhY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uJDEoZnVuY3Rpb24gKGl0ZXJhYmxlKSB7XG4gIE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQxLmFsbChpdGVyYWJsZSkudGhlbih1bmRlZmluZWQsIGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSk7XG59KTtcblxudmFyICQkZCA9IF9leHBvcnQ7XG52YXIgY2FsbCRiID0gZnVuY3Rpb25DYWxsO1xudmFyIGFDYWxsYWJsZSQzID0gYUNhbGxhYmxlJDk7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUkMiA9IG5ld1Byb21pc2VDYXBhYmlsaXR5JDI7XG52YXIgcGVyZm9ybSQxID0gcGVyZm9ybSQzO1xudmFyIGl0ZXJhdGUkMSA9IGl0ZXJhdGUkMjtcbnZhciBQUk9NSVNFX1NUQVRJQ1NfSU5DT1JSRUNUX0lURVJBVElPTiQxID0gcHJvbWlzZVN0YXRpY3NJbmNvcnJlY3RJdGVyYXRpb247XG5cbi8vIGBQcm9taXNlLmFsbGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXByb21pc2UuYWxsXG4kJGQoeyB0YXJnZXQ6ICdQcm9taXNlJywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBQUk9NSVNFX1NUQVRJQ1NfSU5DT1JSRUNUX0lURVJBVElPTiQxIH0sIHtcbiAgYWxsOiBmdW5jdGlvbiBhbGwoaXRlcmFibGUpIHtcbiAgICB2YXIgQyA9IHRoaXM7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSQyLmYoQyk7XG4gICAgdmFyIHJlc29sdmUgPSBjYXBhYmlsaXR5LnJlc29sdmU7XG4gICAgdmFyIHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciByZXN1bHQgPSBwZXJmb3JtJDEoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICRwcm9taXNlUmVzb2x2ZSA9IGFDYWxsYWJsZSQzKEMucmVzb2x2ZSk7XG4gICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICB2YXIgY291bnRlciA9IDA7XG4gICAgICB2YXIgcmVtYWluaW5nID0gMTtcbiAgICAgIGl0ZXJhdGUkMShpdGVyYWJsZSwgZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gY291bnRlcisrO1xuICAgICAgICB2YXIgYWxyZWFkeUNhbGxlZCA9IGZhbHNlO1xuICAgICAgICByZW1haW5pbmcrKztcbiAgICAgICAgY2FsbCRiKCRwcm9taXNlUmVzb2x2ZSwgQywgcHJvbWlzZSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICBpZiAoYWxyZWFkeUNhbGxlZCkgcmV0dXJuO1xuICAgICAgICAgIGFscmVhZHlDYWxsZWQgPSB0cnVlO1xuICAgICAgICAgIHZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICB9KTtcbiAgICBpZiAocmVzdWx0LmVycm9yKSByZWplY3QocmVzdWx0LnZhbHVlKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcblxudmFyICQkYyA9IF9leHBvcnQ7XG52YXIgRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkMiA9IHByb21pc2VDb25zdHJ1Y3RvckRldGVjdGlvbi5DT05TVFJVQ1RPUjtcbnZhciBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IgPSBwcm9taXNlTmF0aXZlQ29uc3RydWN0b3I7XG52YXIgZ2V0QnVpbHRJbiQxID0gZ2V0QnVpbHRJbiQ4O1xudmFyIGlzQ2FsbGFibGUkNiA9IGlzQ2FsbGFibGUkbjtcbnZhciBkZWZpbmVCdWlsdEluJDUgPSBkZWZpbmVCdWlsdEluJDg7XG5cbnZhciBOYXRpdmVQcm9taXNlUHJvdG90eXBlID0gTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yICYmIE5hdGl2ZVByb21pc2VDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG5cbi8vIGBQcm9taXNlLnByb3RvdHlwZS5jYXRjaGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXByb21pc2UucHJvdG90eXBlLmNhdGNoXG4kJGMoeyB0YXJnZXQ6ICdQcm9taXNlJywgcHJvdG86IHRydWUsIGZvcmNlZDogRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkMiwgcmVhbDogdHJ1ZSB9LCB7XG4gICdjYXRjaCc6IGZ1bmN0aW9uIChvblJlamVjdGVkKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIG9uUmVqZWN0ZWQpO1xuICB9XG59KTtcblxuLy8gbWFrZXMgc3VyZSB0aGF0IG5hdGl2ZSBwcm9taXNlLWJhc2VkIEFQSXMgYFByb21pc2UjY2F0Y2hgIHByb3Blcmx5IHdvcmtzIHdpdGggcGF0Y2hlZCBgUHJvbWlzZSN0aGVuYFxuaWYgKGlzQ2FsbGFibGUkNihOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IpKSB7XG4gIHZhciBtZXRob2QgPSBnZXRCdWlsdEluJDEoJ1Byb21pc2UnKS5wcm90b3R5cGVbJ2NhdGNoJ107XG4gIGlmIChOYXRpdmVQcm9taXNlUHJvdG90eXBlWydjYXRjaCddICE9PSBtZXRob2QpIHtcbiAgICBkZWZpbmVCdWlsdEluJDUoTmF0aXZlUHJvbWlzZVByb3RvdHlwZSwgJ2NhdGNoJywgbWV0aG9kLCB7IHVuc2FmZTogdHJ1ZSB9KTtcbiAgfVxufVxuXG52YXIgJCRiID0gX2V4cG9ydDtcbnZhciBjYWxsJGEgPSBmdW5jdGlvbkNhbGw7XG52YXIgYUNhbGxhYmxlJDIgPSBhQ2FsbGFibGUkOTtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSQxID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkkMjtcbnZhciBwZXJmb3JtID0gcGVyZm9ybSQzO1xudmFyIGl0ZXJhdGUgPSBpdGVyYXRlJDI7XG52YXIgUFJPTUlTRV9TVEFUSUNTX0lOQ09SUkVDVF9JVEVSQVRJT04gPSBwcm9taXNlU3RhdGljc0luY29ycmVjdEl0ZXJhdGlvbjtcblxuLy8gYFByb21pc2UucmFjZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXByb21pc2UucmFjZVxuJCRiKHsgdGFyZ2V0OiAnUHJvbWlzZScsIHN0YXQ6IHRydWUsIGZvcmNlZDogUFJPTUlTRV9TVEFUSUNTX0lOQ09SUkVDVF9JVEVSQVRJT04gfSwge1xuICByYWNlOiBmdW5jdGlvbiByYWNlKGl0ZXJhYmxlKSB7XG4gICAgdmFyIEMgPSB0aGlzO1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUkMS5mKEMpO1xuICAgIHZhciByZWplY3QgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICB2YXIgcmVzdWx0ID0gcGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHByb21pc2VSZXNvbHZlID0gYUNhbGxhYmxlJDIoQy5yZXNvbHZlKTtcbiAgICAgIGl0ZXJhdGUoaXRlcmFibGUsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgIGNhbGwkYSgkcHJvbWlzZVJlc29sdmUsIEMsIHByb21pc2UpLnRoZW4oY2FwYWJpbGl0eS5yZXNvbHZlLCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYgKHJlc3VsdC5lcnJvcikgcmVqZWN0KHJlc3VsdC52YWx1ZSk7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG5cbnZhciAkJGEgPSBfZXhwb3J0O1xudmFyIGNhbGwkOSA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5JDI7XG52YXIgRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkMSA9IHByb21pc2VDb25zdHJ1Y3RvckRldGVjdGlvbi5DT05TVFJVQ1RPUjtcblxuLy8gYFByb21pc2UucmVqZWN0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcHJvbWlzZS5yZWplY3RcbiQkYSh7IHRhcmdldDogJ1Byb21pc2UnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SJDEgfSwge1xuICByZWplY3Q6IGZ1bmN0aW9uIHJlamVjdChyKSB7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZS5mKHRoaXMpO1xuICAgIGNhbGwkOShjYXBhYmlsaXR5LnJlamVjdCwgdW5kZWZpbmVkLCByKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcblxudmFyIGFuT2JqZWN0JDYgPSBhbk9iamVjdCRlO1xudmFyIGlzT2JqZWN0JDYgPSBpc09iamVjdCRkO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkkMjtcblxudmFyIHByb21pc2VSZXNvbHZlJDEgPSBmdW5jdGlvbiAoQywgeCkge1xuICBhbk9iamVjdCQ2KEMpO1xuICBpZiAoaXNPYmplY3QkNih4KSAmJiB4LmNvbnN0cnVjdG9yID09PSBDKSByZXR1cm4geDtcbiAgdmFyIHByb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkuZihDKTtcbiAgdmFyIHJlc29sdmUgPSBwcm9taXNlQ2FwYWJpbGl0eS5yZXNvbHZlO1xuICByZXNvbHZlKHgpO1xuICByZXR1cm4gcHJvbWlzZUNhcGFiaWxpdHkucHJvbWlzZTtcbn07XG5cbnZhciAkJDkgPSBfZXhwb3J0O1xudmFyIGdldEJ1aWx0SW4gPSBnZXRCdWlsdEluJDg7XG52YXIgRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IgPSBwcm9taXNlQ29uc3RydWN0b3JEZXRlY3Rpb24uQ09OU1RSVUNUT1I7XG52YXIgcHJvbWlzZVJlc29sdmUgPSBwcm9taXNlUmVzb2x2ZSQxO1xuXG5nZXRCdWlsdEluKCdQcm9taXNlJyk7XG5cbi8vIGBQcm9taXNlLnJlc29sdmVgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1wcm9taXNlLnJlc29sdmVcbiQkOSh7IHRhcmdldDogJ1Byb21pc2UnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SIH0sIHtcbiAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZSh4KSB7XG4gICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKHRoaXMsIHgpO1xuICB9XG59KTtcblxuY2xhc3MgV2ViU3RvcmFnZVNlcnZpY2Uge1xuICBnZXRJdGVtKGtleSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KTtcbiAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgIH0pO1xuICB9XG4gIHNldEl0ZW0oa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGtleSwgdmFsdWUpO1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH0pO1xuICB9XG4gIHJlbW92ZUl0ZW0oa2V5KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcbiAgICAgIHJlc29sdmUoKTtcbiAgICB9KTtcbiAgfVxufVxuXG52YXIgb2JqZWN0RGVmaW5lUHJvcGVydGllcyA9IHt9O1xuXG52YXIgaW50ZXJuYWxPYmplY3RLZXlzID0gb2JqZWN0S2V5c0ludGVybmFsO1xudmFyIGVudW1CdWdLZXlzJDEgPSBlbnVtQnVnS2V5cyQzO1xuXG4vLyBgT2JqZWN0LmtleXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3Qua2V5c1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWtleXMgLS0gc2FmZVxudmFyIG9iamVjdEtleXMkMiA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTykge1xuICByZXR1cm4gaW50ZXJuYWxPYmplY3RLZXlzKE8sIGVudW1CdWdLZXlzJDEpO1xufTtcblxudmFyIERFU0NSSVBUT1JTJDUgPSBkZXNjcmlwdG9ycztcbnZhciBWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyA9IHY4UHJvdG90eXBlRGVmaW5lQnVnO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlJDIgPSBvYmplY3REZWZpbmVQcm9wZXJ0eTtcbnZhciBhbk9iamVjdCQ1ID0gYW5PYmplY3QkZTtcbnZhciB0b0luZGV4ZWRPYmplY3QkMiA9IHRvSW5kZXhlZE9iamVjdCQ2O1xudmFyIG9iamVjdEtleXMkMSA9IG9iamVjdEtleXMkMjtcblxuLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnRpZXNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0aWVzIC0tIHNhZmVcbm9iamVjdERlZmluZVByb3BlcnRpZXMuZiA9IERFU0NSSVBUT1JTJDUgJiYgIVY4X1BST1RPVFlQRV9ERUZJTkVfQlVHID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpIHtcbiAgYW5PYmplY3QkNShPKTtcbiAgdmFyIHByb3BzID0gdG9JbmRleGVkT2JqZWN0JDIoUHJvcGVydGllcyk7XG4gIHZhciBrZXlzID0gb2JqZWN0S2V5cyQxKFByb3BlcnRpZXMpO1xuICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChsZW5ndGggPiBpbmRleCkgZGVmaW5lUHJvcGVydHlNb2R1bGUkMi5mKE8sIGtleSA9IGtleXNbaW5kZXgrK10sIHByb3BzW2tleV0pO1xuICByZXR1cm4gTztcbn07XG5cbi8qIGdsb2JhbCBBY3RpdmVYT2JqZWN0IC0tIG9sZCBJRSwgV1NIICovXG5cbnZhciBhbk9iamVjdCQ0ID0gYW5PYmplY3QkZTtcbnZhciBkZWZpbmVQcm9wZXJ0aWVzTW9kdWxlID0gb2JqZWN0RGVmaW5lUHJvcGVydGllcztcbnZhciBlbnVtQnVnS2V5cyA9IGVudW1CdWdLZXlzJDM7XG52YXIgaGlkZGVuS2V5cyA9IGhpZGRlbktleXMkNDtcbnZhciBodG1sID0gaHRtbCQyO1xudmFyIGRvY3VtZW50Q3JlYXRlRWxlbWVudCQxID0gZG9jdW1lbnRDcmVhdGVFbGVtZW50JDI7XG52YXIgc2hhcmVkS2V5JDEgPSBzaGFyZWRLZXkkMztcblxudmFyIEdUID0gJz4nO1xudmFyIExUID0gJzwnO1xudmFyIFBST1RPVFlQRSQxID0gJ3Byb3RvdHlwZSc7XG52YXIgU0NSSVBUID0gJ3NjcmlwdCc7XG52YXIgSUVfUFJPVE8kMSA9IHNoYXJlZEtleSQxKCdJRV9QUk9UTycpO1xuXG52YXIgRW1wdHlDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcblxudmFyIHNjcmlwdFRhZyA9IGZ1bmN0aW9uIChjb250ZW50KSB7XG4gIHJldHVybiBMVCArIFNDUklQVCArIEdUICsgY29udGVudCArIExUICsgJy8nICsgU0NSSVBUICsgR1Q7XG59O1xuXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgQWN0aXZlWCBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxudmFyIE51bGxQcm90b09iamVjdFZpYUFjdGl2ZVggPSBmdW5jdGlvbiAoYWN0aXZlWERvY3VtZW50KSB7XG4gIGFjdGl2ZVhEb2N1bWVudC53cml0ZShzY3JpcHRUYWcoJycpKTtcbiAgYWN0aXZlWERvY3VtZW50LmNsb3NlKCk7XG4gIHZhciB0ZW1wID0gYWN0aXZlWERvY3VtZW50LnBhcmVudFdpbmRvdy5PYmplY3Q7XG4gIGFjdGl2ZVhEb2N1bWVudCA9IG51bGw7IC8vIGF2b2lkIG1lbW9yeSBsZWFrXG4gIHJldHVybiB0ZW1wO1xufTtcblxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIGlmcmFtZSBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxudmFyIE51bGxQcm90b09iamVjdFZpYUlGcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gVGhyYXNoLCB3YXN0ZSBhbmQgc29kb215OiBJRSBHQyBidWdcbiAgdmFyIGlmcmFtZSA9IGRvY3VtZW50Q3JlYXRlRWxlbWVudCQxKCdpZnJhbWUnKTtcbiAgdmFyIEpTID0gJ2phdmEnICsgU0NSSVBUICsgJzonO1xuICB2YXIgaWZyYW1lRG9jdW1lbnQ7XG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICBodG1sLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy80NzVcbiAgaWZyYW1lLnNyYyA9IFN0cmluZyhKUyk7XG4gIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcbiAgaWZyYW1lRG9jdW1lbnQud3JpdGUoc2NyaXB0VGFnKCdkb2N1bWVudC5GPU9iamVjdCcpKTtcbiAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcbiAgcmV0dXJuIGlmcmFtZURvY3VtZW50LkY7XG59O1xuXG4vLyBDaGVjayBmb3IgZG9jdW1lbnQuZG9tYWluIGFuZCBhY3RpdmUgeCBzdXBwb3J0XG4vLyBObyBuZWVkIHRvIHVzZSBhY3RpdmUgeCBhcHByb2FjaCB3aGVuIGRvY3VtZW50LmRvbWFpbiBpcyBub3Qgc2V0XG4vLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltL2lzc3Vlcy8xNTBcbi8vIHZhcmlhdGlvbiBvZiBodHRwczovL2dpdGh1Yi5jb20va2l0Y2FtYnJpZGdlL2VzNS1zaGltL2NvbW1pdC80ZjczOGFjMDY2MzQ2XG4vLyBhdm9pZCBJRSBHQyBidWdcbnZhciBhY3RpdmVYRG9jdW1lbnQ7XG52YXIgTnVsbFByb3RvT2JqZWN0ID0gZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIGFjdGl2ZVhEb2N1bWVudCA9IG5ldyBBY3RpdmVYT2JqZWN0KCdodG1sZmlsZScpO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBpZ25vcmUgKi8gfVxuICBOdWxsUHJvdG9PYmplY3QgPSB0eXBlb2YgZG9jdW1lbnQgIT0gJ3VuZGVmaW5lZCdcbiAgICA/IGRvY3VtZW50LmRvbWFpbiAmJiBhY3RpdmVYRG9jdW1lbnRcbiAgICAgID8gTnVsbFByb3RvT2JqZWN0VmlhQWN0aXZlWChhY3RpdmVYRG9jdW1lbnQpIC8vIG9sZCBJRVxuICAgICAgOiBOdWxsUHJvdG9PYmplY3RWaWFJRnJhbWUoKVxuICAgIDogTnVsbFByb3RvT2JqZWN0VmlhQWN0aXZlWChhY3RpdmVYRG9jdW1lbnQpOyAvLyBXU0hcbiAgdmFyIGxlbmd0aCA9IGVudW1CdWdLZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSBkZWxldGUgTnVsbFByb3RvT2JqZWN0W1BST1RPVFlQRSQxXVtlbnVtQnVnS2V5c1tsZW5ndGhdXTtcbiAgcmV0dXJuIE51bGxQcm90b09iamVjdCgpO1xufTtcblxuaGlkZGVuS2V5c1tJRV9QUk9UTyQxXSA9IHRydWU7XG5cbi8vIGBPYmplY3QuY3JlYXRlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmNyZWF0ZVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWNyZWF0ZSAtLSBzYWZlXG52YXIgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoTyAhPT0gbnVsbCkge1xuICAgIEVtcHR5Q29uc3RydWN0b3JbUFJPVE9UWVBFJDFdID0gYW5PYmplY3QkNChPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHlDb25zdHJ1Y3RvcigpO1xuICAgIEVtcHR5Q29uc3RydWN0b3JbUFJPVE9UWVBFJDFdID0gbnVsbDtcbiAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXG4gICAgcmVzdWx0W0lFX1BST1RPJDFdID0gTztcbiAgfSBlbHNlIHJlc3VsdCA9IE51bGxQcm90b09iamVjdCgpO1xuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZGVmaW5lUHJvcGVydGllc01vZHVsZS5mKHJlc3VsdCwgUHJvcGVydGllcyk7XG59O1xuXG52YXIgd2VsbEtub3duU3ltYm9sJDggPSB3ZWxsS25vd25TeW1ib2wkajtcbnZhciBjcmVhdGUkMyA9IG9iamVjdENyZWF0ZTtcbnZhciBkZWZpbmVQcm9wZXJ0eSQ0ID0gb2JqZWN0RGVmaW5lUHJvcGVydHkuZjtcblxudmFyIFVOU0NPUEFCTEVTID0gd2VsbEtub3duU3ltYm9sJDgoJ3Vuc2NvcGFibGVzJyk7XG52YXIgQXJyYXlQcm90b3R5cGUgPSBBcnJheS5wcm90b3R5cGU7XG5cbi8vIEFycmF5LnByb3RvdHlwZVtAQHVuc2NvcGFibGVzXVxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUtQEB1bnNjb3BhYmxlc1xuaWYgKEFycmF5UHJvdG90eXBlW1VOU0NPUEFCTEVTXSA9PSB1bmRlZmluZWQpIHtcbiAgZGVmaW5lUHJvcGVydHkkNChBcnJheVByb3RvdHlwZSwgVU5TQ09QQUJMRVMsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgdmFsdWU6IGNyZWF0ZSQzKG51bGwpXG4gIH0pO1xufVxuXG4vLyBhZGQgYSBrZXkgdG8gQXJyYXkucHJvdG90eXBlW0BAdW5zY29wYWJsZXNdXG52YXIgYWRkVG9VbnNjb3BhYmxlcyQyID0gZnVuY3Rpb24gKGtleSkge1xuICBBcnJheVByb3RvdHlwZVtVTlNDT1BBQkxFU11ba2V5XSA9IHRydWU7XG59O1xuXG52YXIgZmFpbHMkaCA9IGZhaWxzJHM7XG5cbnZhciBjb3JyZWN0UHJvdG90eXBlR2V0dGVyID0gIWZhaWxzJGgoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGKCkgeyAvKiBlbXB0eSAqLyB9XG4gIEYucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbnVsbDtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldHByb3RvdHlwZW9mIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YobmV3IEYoKSkgIT09IEYucHJvdG90eXBlO1xufSk7XG5cbnZhciBoYXNPd24kMiA9IGhhc093blByb3BlcnR5XzE7XG52YXIgaXNDYWxsYWJsZSQ1ID0gaXNDYWxsYWJsZSRuO1xudmFyIHRvT2JqZWN0JDUgPSB0b09iamVjdCQ3O1xudmFyIHNoYXJlZEtleSA9IHNoYXJlZEtleSQzO1xudmFyIENPUlJFQ1RfUFJPVE9UWVBFX0dFVFRFUiA9IGNvcnJlY3RQcm90b3R5cGVHZXR0ZXI7XG5cbnZhciBJRV9QUk9UTyA9IHNoYXJlZEtleSgnSUVfUFJPVE8nKTtcbnZhciAkT2JqZWN0ID0gT2JqZWN0O1xudmFyIE9iamVjdFByb3RvdHlwZSQyID0gJE9iamVjdC5wcm90b3R5cGU7XG5cbi8vIGBPYmplY3QuZ2V0UHJvdG90eXBlT2ZgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0cHJvdG90eXBlb2Zcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRwcm90b3R5cGVvZiAtLSBzYWZlXG52YXIgb2JqZWN0R2V0UHJvdG90eXBlT2YgPSBDT1JSRUNUX1BST1RPVFlQRV9HRVRURVIgPyAkT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gKE8pIHtcbiAgdmFyIG9iamVjdCA9IHRvT2JqZWN0JDUoTyk7XG4gIGlmIChoYXNPd24kMihvYmplY3QsIElFX1BST1RPKSkgcmV0dXJuIG9iamVjdFtJRV9QUk9UT107XG4gIHZhciBjb25zdHJ1Y3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgaWYgKGlzQ2FsbGFibGUkNShjb25zdHJ1Y3RvcikgJiYgb2JqZWN0IGluc3RhbmNlb2YgY29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gY29uc3RydWN0b3IucHJvdG90eXBlO1xuICB9IHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiAkT2JqZWN0ID8gT2JqZWN0UHJvdG90eXBlJDIgOiBudWxsO1xufTtcblxudmFyIGZhaWxzJGcgPSBmYWlscyRzO1xudmFyIGlzQ2FsbGFibGUkNCA9IGlzQ2FsbGFibGUkbjtcbnZhciBnZXRQcm90b3R5cGVPZiQzID0gb2JqZWN0R2V0UHJvdG90eXBlT2Y7XG52YXIgZGVmaW5lQnVpbHRJbiQ0ID0gZGVmaW5lQnVpbHRJbiQ4O1xudmFyIHdlbGxLbm93blN5bWJvbCQ3ID0gd2VsbEtub3duU3ltYm9sJGo7XG5cbnZhciBJVEVSQVRPUiQyID0gd2VsbEtub3duU3ltYm9sJDcoJ2l0ZXJhdG9yJyk7XG52YXIgQlVHR1lfU0FGQVJJX0lURVJBVE9SUyQxID0gZmFsc2U7XG5cbi8vIGAlSXRlcmF0b3JQcm90b3R5cGUlYCBvYmplY3Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJWl0ZXJhdG9ycHJvdG90eXBlJS1vYmplY3RcbnZhciBJdGVyYXRvclByb3RvdHlwZSQyLCBQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUsIGFycmF5SXRlcmF0b3I7XG5cbi8qIGVzbGludC1kaXNhYmxlIGVzLXgvbm8tYXJyYXktcHJvdG90eXBlLWtleXMgLS0gc2FmZSAqL1xuaWYgKFtdLmtleXMpIHtcbiAgYXJyYXlJdGVyYXRvciA9IFtdLmtleXMoKTtcbiAgLy8gU2FmYXJpIDggaGFzIGJ1Z2d5IGl0ZXJhdG9ycyB3L28gYG5leHRgXG4gIGlmICghKCduZXh0JyBpbiBhcnJheUl0ZXJhdG9yKSkgQlVHR1lfU0FGQVJJX0lURVJBVE9SUyQxID0gdHJ1ZTtcbiAgZWxzZSB7XG4gICAgUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YkMyhnZXRQcm90b3R5cGVPZiQzKGFycmF5SXRlcmF0b3IpKTtcbiAgICBpZiAoUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlKSBJdGVyYXRvclByb3RvdHlwZSQyID0gUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG59XG5cbnZhciBORVdfSVRFUkFUT1JfUFJPVE9UWVBFID0gSXRlcmF0b3JQcm90b3R5cGUkMiA9PSB1bmRlZmluZWQgfHwgZmFpbHMkZyhmdW5jdGlvbiAoKSB7XG4gIHZhciB0ZXN0ID0ge307XG4gIC8vIEZGNDQtIGxlZ2FjeSBpdGVyYXRvcnMgY2FzZVxuICByZXR1cm4gSXRlcmF0b3JQcm90b3R5cGUkMltJVEVSQVRPUiQyXS5jYWxsKHRlc3QpICE9PSB0ZXN0O1xufSk7XG5cbmlmIChORVdfSVRFUkFUT1JfUFJPVE9UWVBFKSBJdGVyYXRvclByb3RvdHlwZSQyID0ge307XG5cbi8vIGAlSXRlcmF0b3JQcm90b3R5cGUlW0BAaXRlcmF0b3JdKClgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0laXRlcmF0b3Jwcm90b3R5cGUlLUBAaXRlcmF0b3JcbmlmICghaXNDYWxsYWJsZSQ0KEl0ZXJhdG9yUHJvdG90eXBlJDJbSVRFUkFUT1IkMl0pKSB7XG4gIGRlZmluZUJ1aWx0SW4kNChJdGVyYXRvclByb3RvdHlwZSQyLCBJVEVSQVRPUiQyLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pO1xufVxuXG52YXIgaXRlcmF0b3JzQ29yZSA9IHtcbiAgSXRlcmF0b3JQcm90b3R5cGU6IEl0ZXJhdG9yUHJvdG90eXBlJDIsXG4gIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlM6IEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMkMVxufTtcblxudmFyIEl0ZXJhdG9yUHJvdG90eXBlJDEgPSBpdGVyYXRvcnNDb3JlLkl0ZXJhdG9yUHJvdG90eXBlO1xudmFyIGNyZWF0ZSQyID0gb2JqZWN0Q3JlYXRlO1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQyID0gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDU7XG52YXIgc2V0VG9TdHJpbmdUYWckMiA9IHNldFRvU3RyaW5nVGFnJDQ7XG52YXIgSXRlcmF0b3JzJDIgPSBpdGVyYXRvcnM7XG5cbnZhciByZXR1cm5UaGlzJDEgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuXG52YXIgY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvciQxID0gZnVuY3Rpb24gKEl0ZXJhdG9yQ29uc3RydWN0b3IsIE5BTUUsIG5leHQsIEVOVU1FUkFCTEVfTkVYVCkge1xuICB2YXIgVE9fU1RSSU5HX1RBRyA9IE5BTUUgKyAnIEl0ZXJhdG9yJztcbiAgSXRlcmF0b3JDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUkMihJdGVyYXRvclByb3RvdHlwZSQxLCB7IG5leHQ6IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQyKCshRU5VTUVSQUJMRV9ORVhULCBuZXh0KSB9KTtcbiAgc2V0VG9TdHJpbmdUYWckMihJdGVyYXRvckNvbnN0cnVjdG9yLCBUT19TVFJJTkdfVEFHLCBmYWxzZSk7XG4gIEl0ZXJhdG9ycyQyW1RPX1NUUklOR19UQUddID0gcmV0dXJuVGhpcyQxO1xuICByZXR1cm4gSXRlcmF0b3JDb25zdHJ1Y3Rvcjtcbn07XG5cbnZhciAkJDggPSBfZXhwb3J0O1xudmFyIGNhbGwkOCA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBGdW5jdGlvbk5hbWUkMSA9IGZ1bmN0aW9uTmFtZTtcbnZhciBpc0NhbGxhYmxlJDMgPSBpc0NhbGxhYmxlJG47XG52YXIgY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvciA9IGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IkMTtcbnZhciBnZXRQcm90b3R5cGVPZiQyID0gb2JqZWN0R2V0UHJvdG90eXBlT2Y7XG52YXIgc2V0UHJvdG90eXBlT2YkNCA9IG9iamVjdFNldFByb3RvdHlwZU9mO1xudmFyIHNldFRvU3RyaW5nVGFnJDEgPSBzZXRUb1N0cmluZ1RhZyQ0O1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ1ID0gY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDg7XG52YXIgZGVmaW5lQnVpbHRJbiQzID0gZGVmaW5lQnVpbHRJbiQ4O1xudmFyIHdlbGxLbm93blN5bWJvbCQ2ID0gd2VsbEtub3duU3ltYm9sJGo7XG52YXIgSXRlcmF0b3JzJDEgPSBpdGVyYXRvcnM7XG52YXIgSXRlcmF0b3JzQ29yZSA9IGl0ZXJhdG9yc0NvcmU7XG5cbnZhciBQUk9QRVJfRlVOQ1RJT05fTkFNRSQyID0gRnVuY3Rpb25OYW1lJDEuUFJPUEVSO1xudmFyIENPTkZJR1VSQUJMRV9GVU5DVElPTl9OQU1FJDEgPSBGdW5jdGlvbk5hbWUkMS5DT05GSUdVUkFCTEU7XG52YXIgSXRlcmF0b3JQcm90b3R5cGUgPSBJdGVyYXRvcnNDb3JlLkl0ZXJhdG9yUHJvdG90eXBlO1xudmFyIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgPSBJdGVyYXRvcnNDb3JlLkJVR0dZX1NBRkFSSV9JVEVSQVRPUlM7XG52YXIgSVRFUkFUT1IkMSA9IHdlbGxLbm93blN5bWJvbCQ2KCdpdGVyYXRvcicpO1xudmFyIEtFWVMgPSAna2V5cyc7XG52YXIgVkFMVUVTID0gJ3ZhbHVlcyc7XG52YXIgRU5UUklFUyA9ICdlbnRyaWVzJztcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuXG52YXIgZGVmaW5lSXRlcmF0b3IkMSA9IGZ1bmN0aW9uIChJdGVyYWJsZSwgTkFNRSwgSXRlcmF0b3JDb25zdHJ1Y3RvciwgbmV4dCwgREVGQVVMVCwgSVNfU0VULCBGT1JDRUQpIHtcbiAgY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvcihJdGVyYXRvckNvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KTtcblxuICB2YXIgZ2V0SXRlcmF0aW9uTWV0aG9kID0gZnVuY3Rpb24gKEtJTkQpIHtcbiAgICBpZiAoS0lORCA9PT0gREVGQVVMVCAmJiBkZWZhdWx0SXRlcmF0b3IpIHJldHVybiBkZWZhdWx0SXRlcmF0b3I7XG4gICAgaWYgKCFCVUdHWV9TQUZBUklfSVRFUkFUT1JTICYmIEtJTkQgaW4gSXRlcmFibGVQcm90b3R5cGUpIHJldHVybiBJdGVyYWJsZVByb3RvdHlwZVtLSU5EXTtcbiAgICBzd2l0Y2ggKEtJTkQpIHtcbiAgICAgIGNhc2UgS0VZUzogcmV0dXJuIGZ1bmN0aW9uIGtleXMoKSB7IHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzLCBLSU5EKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcywgS0lORCk7IH07XG4gICAgICBjYXNlIEVOVFJJRVM6IHJldHVybiBmdW5jdGlvbiBlbnRyaWVzKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcywgS0lORCk7IH07XG4gICAgfSByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcyk7IH07XG4gIH07XG5cbiAgdmFyIFRPX1NUUklOR19UQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIHZhciBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgPSBmYWxzZTtcbiAgdmFyIEl0ZXJhYmxlUHJvdG90eXBlID0gSXRlcmFibGUucHJvdG90eXBlO1xuICB2YXIgbmF0aXZlSXRlcmF0b3IgPSBJdGVyYWJsZVByb3RvdHlwZVtJVEVSQVRPUiQxXVxuICAgIHx8IEl0ZXJhYmxlUHJvdG90eXBlWydAQGl0ZXJhdG9yJ11cbiAgICB8fCBERUZBVUxUICYmIEl0ZXJhYmxlUHJvdG90eXBlW0RFRkFVTFRdO1xuICB2YXIgZGVmYXVsdEl0ZXJhdG9yID0gIUJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgJiYgbmF0aXZlSXRlcmF0b3IgfHwgZ2V0SXRlcmF0aW9uTWV0aG9kKERFRkFVTFQpO1xuICB2YXIgYW55TmF0aXZlSXRlcmF0b3IgPSBOQU1FID09ICdBcnJheScgPyBJdGVyYWJsZVByb3RvdHlwZS5lbnRyaWVzIHx8IG5hdGl2ZUl0ZXJhdG9yIDogbmF0aXZlSXRlcmF0b3I7XG4gIHZhciBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUsIG1ldGhvZHMsIEtFWTtcblxuICAvLyBmaXggbmF0aXZlXG4gIGlmIChhbnlOYXRpdmVJdGVyYXRvcikge1xuICAgIEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mJDIoYW55TmF0aXZlSXRlcmF0b3IuY2FsbChuZXcgSXRlcmFibGUoKSkpO1xuICAgIGlmIChDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUgJiYgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLm5leHQpIHtcbiAgICAgIGlmIChnZXRQcm90b3R5cGVPZiQyKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSkgIT09IEl0ZXJhdG9yUHJvdG90eXBlKSB7XG4gICAgICAgIGlmIChzZXRQcm90b3R5cGVPZiQ0KSB7XG4gICAgICAgICAgc2V0UHJvdG90eXBlT2YkNChDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUsIEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgICAgICAgfSBlbHNlIGlmICghaXNDYWxsYWJsZSQzKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZVtJVEVSQVRPUiQxXSkpIHtcbiAgICAgICAgICBkZWZpbmVCdWlsdEluJDMoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiQxLCByZXR1cm5UaGlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9yc1xuICAgICAgc2V0VG9TdHJpbmdUYWckMShDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUsIFRPX1NUUklOR19UQUcsIHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGZpeCBBcnJheS5wcm90b3R5cGUueyB2YWx1ZXMsIEBAaXRlcmF0b3IgfS5uYW1lIGluIFY4IC8gRkZcbiAgaWYgKFBST1BFUl9GVU5DVElPTl9OQU1FJDIgJiYgREVGQVVMVCA9PSBWQUxVRVMgJiYgbmF0aXZlSXRlcmF0b3IgJiYgbmF0aXZlSXRlcmF0b3IubmFtZSAhPT0gVkFMVUVTKSB7XG4gICAgaWYgKENPTkZJR1VSQUJMRV9GVU5DVElPTl9OQU1FJDEpIHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ1KEl0ZXJhYmxlUHJvdG90eXBlLCAnbmFtZScsIFZBTFVFUyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIElOQ09SUkVDVF9WQUxVRVNfTkFNRSA9IHRydWU7XG4gICAgICBkZWZhdWx0SXRlcmF0b3IgPSBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiBjYWxsJDgobmF0aXZlSXRlcmF0b3IsIHRoaXMpOyB9O1xuICAgIH1cbiAgfVxuXG4gIC8vIGV4cG9ydCBhZGRpdGlvbmFsIG1ldGhvZHNcbiAgaWYgKERFRkFVTFQpIHtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiBnZXRJdGVyYXRpb25NZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6IElTX1NFVCA/IGRlZmF1bHRJdGVyYXRvciA6IGdldEl0ZXJhdGlvbk1ldGhvZChLRVlTKSxcbiAgICAgIGVudHJpZXM6IGdldEl0ZXJhdGlvbk1ldGhvZChFTlRSSUVTKVxuICAgIH07XG4gICAgaWYgKEZPUkNFRCkgZm9yIChLRVkgaW4gbWV0aG9kcykge1xuICAgICAgaWYgKEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgfHwgSU5DT1JSRUNUX1ZBTFVFU19OQU1FIHx8ICEoS0VZIGluIEl0ZXJhYmxlUHJvdG90eXBlKSkge1xuICAgICAgICBkZWZpbmVCdWlsdEluJDMoSXRlcmFibGVQcm90b3R5cGUsIEtFWSwgbWV0aG9kc1tLRVldKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgJCQ4KHsgdGFyZ2V0OiBOQU1FLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBCVUdHWV9TQUZBUklfSVRFUkFUT1JTIHx8IElOQ09SUkVDVF9WQUxVRVNfTkFNRSB9LCBtZXRob2RzKTtcbiAgfVxuXG4gIC8vIGRlZmluZSBpdGVyYXRvclxuICBpZiAoSXRlcmFibGVQcm90b3R5cGVbSVRFUkFUT1IkMV0gIT09IGRlZmF1bHRJdGVyYXRvcikge1xuICAgIGRlZmluZUJ1aWx0SW4kMyhJdGVyYWJsZVByb3RvdHlwZSwgSVRFUkFUT1IkMSwgZGVmYXVsdEl0ZXJhdG9yLCB7IG5hbWU6IERFRkFVTFQgfSk7XG4gIH1cbiAgSXRlcmF0b3JzJDFbTkFNRV0gPSBkZWZhdWx0SXRlcmF0b3I7XG5cbiAgcmV0dXJuIG1ldGhvZHM7XG59O1xuXG52YXIgdG9JbmRleGVkT2JqZWN0JDEgPSB0b0luZGV4ZWRPYmplY3QkNjtcbnZhciBhZGRUb1Vuc2NvcGFibGVzJDEgPSBhZGRUb1Vuc2NvcGFibGVzJDI7XG52YXIgSXRlcmF0b3JzID0gaXRlcmF0b3JzO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUkMyA9IGludGVybmFsU3RhdGU7XG52YXIgZGVmaW5lUHJvcGVydHkkMyA9IG9iamVjdERlZmluZVByb3BlcnR5LmY7XG52YXIgZGVmaW5lSXRlcmF0b3IgPSBkZWZpbmVJdGVyYXRvciQxO1xudmFyIERFU0NSSVBUT1JTJDQgPSBkZXNjcmlwdG9ycztcblxudmFyIEFSUkFZX0lURVJBVE9SID0gJ0FycmF5IEl0ZXJhdG9yJztcbnZhciBzZXRJbnRlcm5hbFN0YXRlJDIgPSBJbnRlcm5hbFN0YXRlTW9kdWxlJDMuc2V0O1xudmFyIGdldEludGVybmFsU3RhdGUkNCA9IEludGVybmFsU3RhdGVNb2R1bGUkMy5nZXR0ZXJGb3IoQVJSQVlfSVRFUkFUT1IpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmVudHJpZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZW50cmllc1xuLy8gYEFycmF5LnByb3RvdHlwZS5rZXlzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmtleXNcbi8vIGBBcnJheS5wcm90b3R5cGUudmFsdWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnZhbHVlc1xuLy8gYEFycmF5LnByb3RvdHlwZVtAQGl0ZXJhdG9yXWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQGl0ZXJhdG9yXG4vLyBgQ3JlYXRlQXJyYXlJdGVyYXRvcmAgaW50ZXJuYWwgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWNyZWF0ZWFycmF5aXRlcmF0b3JcbnZhciBlc19hcnJheV9pdGVyYXRvciA9IGRlZmluZUl0ZXJhdG9yKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbiAoaXRlcmF0ZWQsIGtpbmQpIHtcbiAgc2V0SW50ZXJuYWxTdGF0ZSQyKHRoaXMsIHtcbiAgICB0eXBlOiBBUlJBWV9JVEVSQVRPUixcbiAgICB0YXJnZXQ6IHRvSW5kZXhlZE9iamVjdCQxKGl0ZXJhdGVkKSwgLy8gdGFyZ2V0XG4gICAgaW5kZXg6IDAsICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4gICAga2luZDoga2luZCAgICAgICAgICAgICAgICAgICAgICAgICAvLyBraW5kXG4gIH0pO1xuLy8gYCVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJWFycmF5aXRlcmF0b3Jwcm90b3R5cGUlLm5leHRcbn0sIGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSQ0KHRoaXMpO1xuICB2YXIgdGFyZ2V0ID0gc3RhdGUudGFyZ2V0O1xuICB2YXIga2luZCA9IHN0YXRlLmtpbmQ7XG4gIHZhciBpbmRleCA9IHN0YXRlLmluZGV4Kys7XG4gIGlmICghdGFyZ2V0IHx8IGluZGV4ID49IHRhcmdldC5sZW5ndGgpIHtcbiAgICBzdGF0ZS50YXJnZXQgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG4gIGlmIChraW5kID09ICdrZXlzJykgcmV0dXJuIHsgdmFsdWU6IGluZGV4LCBkb25lOiBmYWxzZSB9O1xuICBpZiAoa2luZCA9PSAndmFsdWVzJykgcmV0dXJuIHsgdmFsdWU6IHRhcmdldFtpbmRleF0sIGRvbmU6IGZhbHNlIH07XG4gIHJldHVybiB7IHZhbHVlOiBbaW5kZXgsIHRhcmdldFtpbmRleF1dLCBkb25lOiBmYWxzZSB9O1xufSwgJ3ZhbHVlcycpO1xuXG4vLyBhcmd1bWVudHNMaXN0W0BAaXRlcmF0b3JdIGlzICVBcnJheVByb3RvX3ZhbHVlcyVcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtY3JlYXRldW5tYXBwZWRhcmd1bWVudHNvYmplY3Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtY3JlYXRlbWFwcGVkYXJndW1lbnRzb2JqZWN0XG52YXIgdmFsdWVzID0gSXRlcmF0b3JzLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycy5BcnJheTtcblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUtQEB1bnNjb3BhYmxlc1xuYWRkVG9VbnNjb3BhYmxlcyQxKCdrZXlzJyk7XG5hZGRUb1Vuc2NvcGFibGVzJDEoJ3ZhbHVlcycpO1xuYWRkVG9VbnNjb3BhYmxlcyQxKCdlbnRyaWVzJyk7XG5cbi8vIFY4IH4gQ2hyb21lIDQ1LSBidWdcbmlmIChERVNDUklQVE9SUyQ0ICYmIHZhbHVlcy5uYW1lICE9PSAndmFsdWVzJykgdHJ5IHtcbiAgZGVmaW5lUHJvcGVydHkkMyh2YWx1ZXMsICduYW1lJywgeyB2YWx1ZTogJ3ZhbHVlcycgfSk7XG59IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG5cbi8vIGl0ZXJhYmxlIERPTSBjb2xsZWN0aW9uc1xuLy8gZmxhZyAtIGBpdGVyYWJsZWAgaW50ZXJmYWNlIC0gJ2VudHJpZXMnLCAna2V5cycsICd2YWx1ZXMnLCAnZm9yRWFjaCcgbWV0aG9kc1xudmFyIGRvbUl0ZXJhYmxlcyA9IHtcbiAgQ1NTUnVsZUxpc3Q6IDAsXG4gIENTU1N0eWxlRGVjbGFyYXRpb246IDAsXG4gIENTU1ZhbHVlTGlzdDogMCxcbiAgQ2xpZW50UmVjdExpc3Q6IDAsXG4gIERPTVJlY3RMaXN0OiAwLFxuICBET01TdHJpbmdMaXN0OiAwLFxuICBET01Ub2tlbkxpc3Q6IDEsXG4gIERhdGFUcmFuc2Zlckl0ZW1MaXN0OiAwLFxuICBGaWxlTGlzdDogMCxcbiAgSFRNTEFsbENvbGxlY3Rpb246IDAsXG4gIEhUTUxDb2xsZWN0aW9uOiAwLFxuICBIVE1MRm9ybUVsZW1lbnQ6IDAsXG4gIEhUTUxTZWxlY3RFbGVtZW50OiAwLFxuICBNZWRpYUxpc3Q6IDAsXG4gIE1pbWVUeXBlQXJyYXk6IDAsXG4gIE5hbWVkTm9kZU1hcDogMCxcbiAgTm9kZUxpc3Q6IDEsXG4gIFBhaW50UmVxdWVzdExpc3Q6IDAsXG4gIFBsdWdpbjogMCxcbiAgUGx1Z2luQXJyYXk6IDAsXG4gIFNWR0xlbmd0aExpc3Q6IDAsXG4gIFNWR051bWJlckxpc3Q6IDAsXG4gIFNWR1BhdGhTZWdMaXN0OiAwLFxuICBTVkdQb2ludExpc3Q6IDAsXG4gIFNWR1N0cmluZ0xpc3Q6IDAsXG4gIFNWR1RyYW5zZm9ybUxpc3Q6IDAsXG4gIFNvdXJjZUJ1ZmZlckxpc3Q6IDAsXG4gIFN0eWxlU2hlZXRMaXN0OiAwLFxuICBUZXh0VHJhY2tDdWVMaXN0OiAwLFxuICBUZXh0VHJhY2tMaXN0OiAwLFxuICBUb3VjaExpc3Q6IDBcbn07XG5cbi8vIGluIG9sZCBXZWJLaXQgdmVyc2lvbnMsIGBlbGVtZW50LmNsYXNzTGlzdGAgaXMgbm90IGFuIGluc3RhbmNlIG9mIGdsb2JhbCBgRE9NVG9rZW5MaXN0YFxudmFyIGRvY3VtZW50Q3JlYXRlRWxlbWVudCA9IGRvY3VtZW50Q3JlYXRlRWxlbWVudCQyO1xuXG52YXIgY2xhc3NMaXN0ID0gZG9jdW1lbnRDcmVhdGVFbGVtZW50KCdzcGFuJykuY2xhc3NMaXN0O1xudmFyIERPTVRva2VuTGlzdFByb3RvdHlwZSQxID0gY2xhc3NMaXN0ICYmIGNsYXNzTGlzdC5jb25zdHJ1Y3RvciAmJiBjbGFzc0xpc3QuY29uc3RydWN0b3IucHJvdG90eXBlO1xuXG52YXIgZG9tVG9rZW5MaXN0UHJvdG90eXBlID0gRE9NVG9rZW5MaXN0UHJvdG90eXBlJDEgPT09IE9iamVjdC5wcm90b3R5cGUgPyB1bmRlZmluZWQgOiBET01Ub2tlbkxpc3RQcm90b3R5cGUkMTtcblxudmFyIGdsb2JhbCRiID0gZ2xvYmFsJHQ7XG52YXIgRE9NSXRlcmFibGVzID0gZG9tSXRlcmFibGVzO1xudmFyIERPTVRva2VuTGlzdFByb3RvdHlwZSA9IGRvbVRva2VuTGlzdFByb3RvdHlwZTtcbnZhciBBcnJheUl0ZXJhdG9yTWV0aG9kcyA9IGVzX2FycmF5X2l0ZXJhdG9yO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ0ID0gY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDg7XG52YXIgd2VsbEtub3duU3ltYm9sJDUgPSB3ZWxsS25vd25TeW1ib2wkajtcblxudmFyIElURVJBVE9SID0gd2VsbEtub3duU3ltYm9sJDUoJ2l0ZXJhdG9yJyk7XG52YXIgVE9fU1RSSU5HX1RBRyQxID0gd2VsbEtub3duU3ltYm9sJDUoJ3RvU3RyaW5nVGFnJyk7XG52YXIgQXJyYXlWYWx1ZXMgPSBBcnJheUl0ZXJhdG9yTWV0aG9kcy52YWx1ZXM7XG5cbnZhciBoYW5kbGVQcm90b3R5cGUgPSBmdW5jdGlvbiAoQ29sbGVjdGlvblByb3RvdHlwZSwgQ09MTEVDVElPTl9OQU1FKSB7XG4gIGlmIChDb2xsZWN0aW9uUHJvdG90eXBlKSB7XG4gICAgLy8gc29tZSBDaHJvbWUgdmVyc2lvbnMgaGF2ZSBub24tY29uZmlndXJhYmxlIG1ldGhvZHMgb24gRE9NVG9rZW5MaXN0XG4gICAgaWYgKENvbGxlY3Rpb25Qcm90b3R5cGVbSVRFUkFUT1JdICE9PSBBcnJheVZhbHVlcykgdHJ5IHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ0KENvbGxlY3Rpb25Qcm90b3R5cGUsIElURVJBVE9SLCBBcnJheVZhbHVlcyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIENvbGxlY3Rpb25Qcm90b3R5cGVbSVRFUkFUT1JdID0gQXJyYXlWYWx1ZXM7XG4gICAgfVxuICAgIGlmICghQ29sbGVjdGlvblByb3RvdHlwZVtUT19TVFJJTkdfVEFHJDFdKSB7XG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNChDb2xsZWN0aW9uUHJvdG90eXBlLCBUT19TVFJJTkdfVEFHJDEsIENPTExFQ1RJT05fTkFNRSk7XG4gICAgfVxuICAgIGlmIChET01JdGVyYWJsZXNbQ09MTEVDVElPTl9OQU1FXSkgZm9yICh2YXIgTUVUSE9EX05BTUUgaW4gQXJyYXlJdGVyYXRvck1ldGhvZHMpIHtcbiAgICAgIC8vIHNvbWUgQ2hyb21lIHZlcnNpb25zIGhhdmUgbm9uLWNvbmZpZ3VyYWJsZSBtZXRob2RzIG9uIERPTVRva2VuTGlzdFxuICAgICAgaWYgKENvbGxlY3Rpb25Qcm90b3R5cGVbTUVUSE9EX05BTUVdICE9PSBBcnJheUl0ZXJhdG9yTWV0aG9kc1tNRVRIT0RfTkFNRV0pIHRyeSB7XG4gICAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ0KENvbGxlY3Rpb25Qcm90b3R5cGUsIE1FVEhPRF9OQU1FLCBBcnJheUl0ZXJhdG9yTWV0aG9kc1tNRVRIT0RfTkFNRV0pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgQ29sbGVjdGlvblByb3RvdHlwZVtNRVRIT0RfTkFNRV0gPSBBcnJheUl0ZXJhdG9yTWV0aG9kc1tNRVRIT0RfTkFNRV07XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mb3IgKHZhciBDT0xMRUNUSU9OX05BTUUgaW4gRE9NSXRlcmFibGVzKSB7XG4gIGhhbmRsZVByb3RvdHlwZShnbG9iYWwkYltDT0xMRUNUSU9OX05BTUVdICYmIGdsb2JhbCRiW0NPTExFQ1RJT05fTkFNRV0ucHJvdG90eXBlLCBDT0xMRUNUSU9OX05BTUUpO1xufVxuXG5oYW5kbGVQcm90b3R5cGUoRE9NVG9rZW5MaXN0UHJvdG90eXBlLCAnRE9NVG9rZW5MaXN0Jyk7XG5cbmNsYXNzIExvZ2dlciB7XG4gIGNvbnN0cnVjdG9yKG5hbWVzcGFjZSkge1xuICAgIHRoaXMubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuICB9XG4gIGVtaXQobWV0aG9kLCAuLi5wYXJhbXMpIHtcbiAgICBpZiAoIUxvZ2dlci5kZWJ1Zykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5uYW1lc3BhY2UgJiYgbWV0aG9kICE9PSBcImVycm9yXCIpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlW21ldGhvZF0odGhpcy5uYW1lc3BhY2UsIC4uLnBhcmFtcyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgY29uc29sZVttZXRob2RdKC4uLnBhcmFtcyk7XG4gIH1cbiAgbG9nKC4uLnBhcmFtcykge1xuICAgIHRoaXMuZW1pdChcImxvZ1wiLCAuLi5wYXJhbXMpO1xuICB9XG4gIGluZm8oLi4ucGFyYW1zKSB7XG4gICAgdGhpcy5lbWl0KFwiaW5mb1wiLCAuLi5wYXJhbXMpO1xuICB9XG4gIHdhcm4oLi4ucGFyYW1zKSB7XG4gICAgdGhpcy5lbWl0KFwid2FyblwiLCAuLi5wYXJhbXMpO1xuICB9XG4gIGVycm9yKC4uLnBhcmFtcykge1xuICAgIHRoaXMuZW1pdChcImVycm9yXCIsIC4uLnBhcmFtcyk7XG4gIH1cbn1cbkxvZ2dlci5kZWJ1ZyA9IGZhbHNlO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcigpO1xuXG52YXIgJCQ3ID0gX2V4cG9ydDtcbnZhciAkaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzLmluY2x1ZGVzO1xudmFyIGZhaWxzJGYgPSBmYWlscyRzO1xudmFyIGFkZFRvVW5zY29wYWJsZXMgPSBhZGRUb1Vuc2NvcGFibGVzJDI7XG5cbi8vIEZGOTkrIGJ1Z1xudmFyIEJST0tFTl9PTl9TUEFSU0UgPSBmYWlscyRmKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICFBcnJheSgxKS5pbmNsdWRlcygpO1xufSk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuaW5jbHVkZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuaW5jbHVkZXNcbiQkNyh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogQlJPS0VOX09OX1NQQVJTRSB9LCB7XG4gIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhlbCAvKiAsIGZyb21JbmRleCA9IDAgKi8pIHtcbiAgICByZXR1cm4gJGluY2x1ZGVzKHRoaXMsIGVsLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQHVuc2NvcGFibGVzXG5hZGRUb1Vuc2NvcGFibGVzKCdpbmNsdWRlcycpO1xuXG52YXIgaXNPYmplY3QkNSA9IGlzT2JqZWN0JGQ7XG52YXIgY2xhc3NvZiQ2ID0gY2xhc3NvZlJhdyQxO1xudmFyIHdlbGxLbm93blN5bWJvbCQ0ID0gd2VsbEtub3duU3ltYm9sJGo7XG5cbnZhciBNQVRDSCQxID0gd2VsbEtub3duU3ltYm9sJDQoJ21hdGNoJyk7XG5cbi8vIGBJc1JlZ0V4cGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWlzcmVnZXhwXG52YXIgaXNSZWdleHAgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIGlzUmVnRXhwO1xuICByZXR1cm4gaXNPYmplY3QkNShpdCkgJiYgKChpc1JlZ0V4cCA9IGl0W01BVENIJDFdKSAhPT0gdW5kZWZpbmVkID8gISFpc1JlZ0V4cCA6IGNsYXNzb2YkNihpdCkgPT0gJ1JlZ0V4cCcpO1xufTtcblxudmFyIGlzUmVnRXhwJDEgPSBpc1JlZ2V4cDtcblxudmFyICRUeXBlRXJyb3IkMyA9IFR5cGVFcnJvcjtcblxudmFyIG5vdEFSZWdleHAgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGlzUmVnRXhwJDEoaXQpKSB7XG4gICAgdGhyb3cgJFR5cGVFcnJvciQzKFwiVGhlIG1ldGhvZCBkb2Vzbid0IGFjY2VwdCByZWd1bGFyIGV4cHJlc3Npb25zXCIpO1xuICB9IHJldHVybiBpdDtcbn07XG5cbnZhciBjbGFzc29mJDUgPSBjbGFzc29mJDk7XG5cbnZhciAkU3RyaW5nID0gU3RyaW5nO1xuXG52YXIgdG9TdHJpbmckNSA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAoY2xhc3NvZiQ1KGFyZ3VtZW50KSA9PT0gJ1N5bWJvbCcpIHRocm93IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgYSBTeW1ib2wgdmFsdWUgdG8gYSBzdHJpbmcnKTtcbiAgcmV0dXJuICRTdHJpbmcoYXJndW1lbnQpO1xufTtcblxudmFyIHdlbGxLbm93blN5bWJvbCQzID0gd2VsbEtub3duU3ltYm9sJGo7XG5cbnZhciBNQVRDSCA9IHdlbGxLbm93blN5bWJvbCQzKCdtYXRjaCcpO1xuXG52YXIgY29ycmVjdElzUmVnZXhwTG9naWMgPSBmdW5jdGlvbiAoTUVUSE9EX05BTUUpIHtcbiAgdmFyIHJlZ2V4cCA9IC8uLztcbiAgdHJ5IHtcbiAgICAnLy4vJ1tNRVRIT0RfTkFNRV0ocmVnZXhwKTtcbiAgfSBjYXRjaCAoZXJyb3IxKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJlZ2V4cFtNQVRDSF0gPSBmYWxzZTtcbiAgICAgIHJldHVybiAnLy4vJ1tNRVRIT0RfTkFNRV0ocmVnZXhwKTtcbiAgICB9IGNhdGNoIChlcnJvcjIpIHsgLyogZW1wdHkgKi8gfVxuICB9IHJldHVybiBmYWxzZTtcbn07XG5cbnZhciAkJDYgPSBfZXhwb3J0O1xudmFyIHVuY3VycnlUaGlzJGIgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIG5vdEFSZWdFeHAgPSBub3RBUmVnZXhwO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUkMyA9IHJlcXVpcmVPYmplY3RDb2VyY2libGUkNjtcbnZhciB0b1N0cmluZyQ0ID0gdG9TdHJpbmckNTtcbnZhciBjb3JyZWN0SXNSZWdFeHBMb2dpYyA9IGNvcnJlY3RJc1JlZ2V4cExvZ2ljO1xuXG52YXIgc3RyaW5nSW5kZXhPZiA9IHVuY3VycnlUaGlzJGIoJycuaW5kZXhPZik7XG5cbi8vIGBTdHJpbmcucHJvdG90eXBlLmluY2x1ZGVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5pbmNsdWRlc1xuJCQ2KHsgdGFyZ2V0OiAnU3RyaW5nJywgcHJvdG86IHRydWUsIGZvcmNlZDogIWNvcnJlY3RJc1JlZ0V4cExvZ2ljKCdpbmNsdWRlcycpIH0sIHtcbiAgaW5jbHVkZXM6IGZ1bmN0aW9uIGluY2x1ZGVzKHNlYXJjaFN0cmluZyAvKiAsIHBvc2l0aW9uID0gMCAqLykge1xuICAgIHJldHVybiAhIX5zdHJpbmdJbmRleE9mKFxuICAgICAgdG9TdHJpbmckNChyZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDModGhpcykpLFxuICAgICAgdG9TdHJpbmckNChub3RBUmVnRXhwKHNlYXJjaFN0cmluZykpLFxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWRcbiAgICApO1xuICB9XG59KTtcblxuLy8gYSBzdHJpbmcgb2YgYWxsIHZhbGlkIHVuaWNvZGUgd2hpdGVzcGFjZXNcbnZhciB3aGl0ZXNwYWNlcyQyID0gJ1xcdTAwMDlcXHUwMDBBXFx1MDAwQlxcdTAwMENcXHUwMDBEXFx1MDAyMFxcdTAwQTBcXHUxNjgwXFx1MjAwMFxcdTIwMDFcXHUyMDAyJyArXG4gICdcXHUyMDAzXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MzAwMFxcdTIwMjhcXHUyMDI5XFx1RkVGRic7XG5cbnZhciB1bmN1cnJ5VGhpcyRhID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDIgPSByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDY7XG52YXIgdG9TdHJpbmckMyA9IHRvU3RyaW5nJDU7XG52YXIgd2hpdGVzcGFjZXMkMSA9IHdoaXRlc3BhY2VzJDI7XG5cbnZhciByZXBsYWNlJDEgPSB1bmN1cnJ5VGhpcyRhKCcnLnJlcGxhY2UpO1xudmFyIHdoaXRlc3BhY2UgPSAnWycgKyB3aGl0ZXNwYWNlcyQxICsgJ10nO1xudmFyIGx0cmltID0gUmVnRXhwKCdeJyArIHdoaXRlc3BhY2UgKyB3aGl0ZXNwYWNlICsgJyonKTtcbnZhciBydHJpbSA9IFJlZ0V4cCh3aGl0ZXNwYWNlICsgd2hpdGVzcGFjZSArICcqJCcpO1xuXG4vLyBgU3RyaW5nLnByb3RvdHlwZS57IHRyaW0sIHRyaW1TdGFydCwgdHJpbUVuZCwgdHJpbUxlZnQsIHRyaW1SaWdodCB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG52YXIgY3JlYXRlTWV0aG9kJDMgPSBmdW5jdGlvbiAoVFlQRSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzKSB7XG4gICAgdmFyIHN0cmluZyA9IHRvU3RyaW5nJDMocmVxdWlyZU9iamVjdENvZXJjaWJsZSQyKCR0aGlzKSk7XG4gICAgaWYgKFRZUEUgJiAxKSBzdHJpbmcgPSByZXBsYWNlJDEoc3RyaW5nLCBsdHJpbSwgJycpO1xuICAgIGlmIChUWVBFICYgMikgc3RyaW5nID0gcmVwbGFjZSQxKHN0cmluZywgcnRyaW0sICcnKTtcbiAgICByZXR1cm4gc3RyaW5nO1xuICB9O1xufTtcblxudmFyIHN0cmluZ1RyaW0gPSB7XG4gIC8vIGBTdHJpbmcucHJvdG90eXBlLnsgdHJpbUxlZnQsIHRyaW1TdGFydCB9YCBtZXRob2RzXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS50cmltc3RhcnRcbiAgc3RhcnQ6IGNyZWF0ZU1ldGhvZCQzKDEpLFxuICAvLyBgU3RyaW5nLnByb3RvdHlwZS57IHRyaW1SaWdodCwgdHJpbUVuZCB9YCBtZXRob2RzXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS50cmltZW5kXG4gIGVuZDogY3JlYXRlTWV0aG9kJDMoMiksXG4gIC8vIGBTdHJpbmcucHJvdG90eXBlLnRyaW1gIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUudHJpbVxuICB0cmltOiBjcmVhdGVNZXRob2QkMygzKVxufTtcblxudmFyIFBST1BFUl9GVU5DVElPTl9OQU1FJDEgPSBmdW5jdGlvbk5hbWUuUFJPUEVSO1xudmFyIGZhaWxzJGUgPSBmYWlscyRzO1xudmFyIHdoaXRlc3BhY2VzID0gd2hpdGVzcGFjZXMkMjtcblxudmFyIG5vbiA9ICdcXHUyMDBCXFx1MDA4NVxcdTE4MEUnO1xuXG4vLyBjaGVjayB0aGF0IGEgbWV0aG9kIHdvcmtzIHdpdGggdGhlIGNvcnJlY3QgbGlzdFxuLy8gb2Ygd2hpdGVzcGFjZXMgYW5kIGhhcyBhIGNvcnJlY3QgbmFtZVxudmFyIHN0cmluZ1RyaW1Gb3JjZWQgPSBmdW5jdGlvbiAoTUVUSE9EX05BTUUpIHtcbiAgcmV0dXJuIGZhaWxzJGUoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhIXdoaXRlc3BhY2VzW01FVEhPRF9OQU1FXSgpXG4gICAgICB8fCBub25bTUVUSE9EX05BTUVdKCkgIT09IG5vblxuICAgICAgfHwgKFBST1BFUl9GVU5DVElPTl9OQU1FJDEgJiYgd2hpdGVzcGFjZXNbTUVUSE9EX05BTUVdLm5hbWUgIT09IE1FVEhPRF9OQU1FKTtcbiAgfSk7XG59O1xuXG52YXIgJCQ1ID0gX2V4cG9ydDtcbnZhciAkdHJpbSA9IHN0cmluZ1RyaW0udHJpbTtcbnZhciBmb3JjZWRTdHJpbmdUcmltTWV0aG9kID0gc3RyaW5nVHJpbUZvcmNlZDtcblxuLy8gYFN0cmluZy5wcm90b3R5cGUudHJpbWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUudHJpbVxuJCQ1KHsgdGFyZ2V0OiAnU3RyaW5nJywgcHJvdG86IHRydWUsIGZvcmNlZDogZm9yY2VkU3RyaW5nVHJpbU1ldGhvZCgndHJpbScpIH0sIHtcbiAgdHJpbTogZnVuY3Rpb24gdHJpbSgpIHtcbiAgICByZXR1cm4gJHRyaW0odGhpcyk7XG4gIH1cbn0pO1xuXG52YXIgREVTQ1JJUFRPUlMkMyA9IGRlc2NyaXB0b3JzO1xudmFyIHVuY3VycnlUaGlzJDkgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGNhbGwkNyA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBmYWlscyRkID0gZmFpbHMkcztcbnZhciBvYmplY3RLZXlzID0gb2JqZWN0S2V5cyQyO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSA9IG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSA9IG9iamVjdFByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIHRvT2JqZWN0JDQgPSB0b09iamVjdCQ3O1xudmFyIEluZGV4ZWRPYmplY3QkMiA9IGluZGV4ZWRPYmplY3Q7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1hc3NpZ24gLS0gc2FmZVxudmFyICRhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG52YXIgZGVmaW5lUHJvcGVydHkkMiA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBjb25jYXQgPSB1bmN1cnJ5VGhpcyQ5KFtdLmNvbmNhdCk7XG5cbi8vIGBPYmplY3QuYXNzaWduYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmFzc2lnblxudmFyIG9iamVjdEFzc2lnbiA9ICEkYXNzaWduIHx8IGZhaWxzJGQoZnVuY3Rpb24gKCkge1xuICAvLyBzaG91bGQgaGF2ZSBjb3JyZWN0IG9yZGVyIG9mIG9wZXJhdGlvbnMgKEVkZ2UgYnVnKVxuICBpZiAoREVTQ1JJUFRPUlMkMyAmJiAkYXNzaWduKHsgYjogMSB9LCAkYXNzaWduKGRlZmluZVByb3BlcnR5JDIoe30sICdhJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICBkZWZpbmVQcm9wZXJ0eSQyKHRoaXMsICdiJywge1xuICAgICAgICB2YWx1ZTogMyxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfSksIHsgYjogMiB9KSkuYiAhPT0gMSkgcmV0dXJuIHRydWU7XG4gIC8vIHNob3VsZCB3b3JrIHdpdGggc3ltYm9scyBhbmQgc2hvdWxkIGhhdmUgZGV0ZXJtaW5pc3RpYyBwcm9wZXJ0eSBvcmRlciAoVjggYnVnKVxuICB2YXIgQSA9IHt9O1xuICB2YXIgQiA9IHt9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1zeW1ib2wgLS0gc2FmZVxuICB2YXIgc3ltYm9sID0gU3ltYm9sKCk7XG4gIHZhciBhbHBoYWJldCA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdCc7XG4gIEFbc3ltYm9sXSA9IDc7XG4gIGFscGhhYmV0LnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChjaHIpIHsgQltjaHJdID0gY2hyOyB9KTtcbiAgcmV0dXJuICRhc3NpZ24oe30sIEEpW3N5bWJvbF0gIT0gNyB8fCBvYmplY3RLZXlzKCRhc3NpZ24oe30sIEIpKS5qb2luKCcnKSAhPSBhbHBoYWJldDtcbn0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnMgLS0gcmVxdWlyZWQgZm9yIGAubGVuZ3RoYFxuICB2YXIgVCA9IHRvT2JqZWN0JDQodGFyZ2V0KTtcbiAgdmFyIGFyZ3VtZW50c0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBpbmRleCA9IDE7XG4gIHZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUuZjtcbiAgdmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUuZjtcbiAgd2hpbGUgKGFyZ3VtZW50c0xlbmd0aCA+IGluZGV4KSB7XG4gICAgdmFyIFMgPSBJbmRleGVkT2JqZWN0JDIoYXJndW1lbnRzW2luZGV4KytdKTtcbiAgICB2YXIga2V5cyA9IGdldE93blByb3BlcnR5U3ltYm9scyA/IGNvbmNhdChvYmplY3RLZXlzKFMpLCBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoUykpIDogb2JqZWN0S2V5cyhTKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIGogPSAwO1xuICAgIHZhciBrZXk7XG4gICAgd2hpbGUgKGxlbmd0aCA+IGopIHtcbiAgICAgIGtleSA9IGtleXNbaisrXTtcbiAgICAgIGlmICghREVTQ1JJUFRPUlMkMyB8fCBjYWxsJDcocHJvcGVydHlJc0VudW1lcmFibGUsIFMsIGtleSkpIFRba2V5XSA9IFNba2V5XTtcbiAgICB9XG4gIH0gcmV0dXJuIFQ7XG59IDogJGFzc2lnbjtcblxudmFyICQkNCA9IF9leHBvcnQ7XG52YXIgYXNzaWduID0gb2JqZWN0QXNzaWduO1xuXG4vLyBgT2JqZWN0LmFzc2lnbmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5hc3NpZ25cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1hc3NpZ24gLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiQkNCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIGFyaXR5OiAyLCBmb3JjZWQ6IE9iamVjdC5hc3NpZ24gIT09IGFzc2lnbiB9LCB7XG4gIGFzc2lnbjogYXNzaWduXG59KTtcblxuY2xhc3MgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5lbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlciQxKCk7XG4gIH1cbiAgb24oZXZlbnROYW1lLCBjYWxsYmFjaykge1xuICAgIHRoaXMuZW1pdHRlci5vbihldmVudE5hbWUsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVtb3ZlOiAoKSA9PiB0aGlzLmVtaXR0ZXIub2ZmKGV2ZW50TmFtZSwgY2FsbGJhY2spXG4gICAgfTtcbiAgfVxuICBvZmYoZXZlbnROYW1lLCBjYWxsYmFjaykge1xuICAgIHRoaXMuZW1pdHRlci5vZmYoZXZlbnROYW1lLCBjYWxsYmFjayk7XG4gIH1cbiAgZW1pdChldmVudE5hbWUsIGV2ZW50KSB7XG4gICAgdGhpcy5lbWl0dGVyLmVtaXQoZXZlbnROYW1lLCBldmVudCk7XG4gIH1cbn1cblxuY29uc3QgUEFDS0FHRV9OQU1FID0gXCJuZWFyLXdhbGxldC1zZWxlY3RvclwiO1xuY29uc3QgUkVDRU5UTFlfU0lHTkVEX0lOX1dBTExFVFMgPSBcInJlY2VudGx5U2lnbmVkSW5XYWxsZXRzXCI7XG5jb25zdCBDT05UUkFDVCA9IFwiY29udHJhY3RcIjtcbmNvbnN0IFBFTkRJTkdfQ09OVFJBQ1QgPSBcImNvbnRyYWN0OnBlbmRpbmdcIjtcbmNvbnN0IFNFTEVDVEVEX1dBTExFVF9JRCA9IGBzZWxlY3RlZFdhbGxldElkYDtcbmNvbnN0IFBFTkRJTkdfU0VMRUNURURfV0FMTEVUX0lEID0gYHNlbGVjdGVkV2FsbGV0SWQ6cGVuZGluZ2A7XG5cbmNsYXNzIFdhbGxldE1vZHVsZXMge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgZmFjdG9yaWVzLFxuICAgIHN0b3JhZ2UsXG4gICAgb3B0aW9ucyxcbiAgICBzdG9yZSxcbiAgICBlbWl0dGVyLFxuICAgIHByb3ZpZGVyXG4gIH0pIHtcbiAgICB0aGlzLmZhY3RvcmllcyA9IGZhY3RvcmllcztcbiAgICB0aGlzLnN0b3JhZ2UgPSBzdG9yYWdlO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5zdG9yZSA9IHN0b3JlO1xuICAgIHRoaXMuZW1pdHRlciA9IGVtaXR0ZXI7XG4gICAgdGhpcy5wcm92aWRlciA9IHByb3ZpZGVyO1xuICAgIHRoaXMubW9kdWxlcyA9IFtdO1xuICAgIHRoaXMuaW5zdGFuY2VzID0ge307XG4gIH1cbiAgdmFsaWRhdGVXYWxsZXQoaWQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgbGV0IGFjY291bnRzID0gW107XG4gICAgICBjb25zdCB3YWxsZXQgPSB5aWVsZCB0aGlzLmdldFdhbGxldChpZCk7XG4gICAgICBpZiAod2FsbGV0KSB7XG4gICAgICAgIC8vIEVuc3VyZSBvdXIgcGVyc2lzdGVudCBzdGF0ZSBhbGlnbnMgd2l0aCB0aGUgc2VsZWN0ZWQgd2FsbGV0LlxuICAgICAgICAvLyBGb3IgZXhhbXBsZSBhIHdhbGxldCBpcyBzZWxlY3RlZCwgYnV0IGl0IHJldHVybnMgbm8gYWNjb3VudHMgKG5vdCBzaWduZWQgaW4pLlxuICAgICAgICBhY2NvdW50cyA9IHlpZWxkIHdhbGxldC5nZXRBY2NvdW50cygpLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgbG9nZ2VyLmxvZyhgRmFpbGVkIHRvIHZhbGlkYXRlICR7d2FsbGV0LmlkfSBkdXJpbmcgc2V0dXBgKTtcbiAgICAgICAgICBsb2dnZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjY291bnRzO1xuICAgIH0pO1xuICB9XG4gIHJlc29sdmVTdG9yYWdlU3RhdGUoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IGpzb25TdG9yYWdlID0gbmV3IEpzb25TdG9yYWdlKHRoaXMuc3RvcmFnZSwgUEFDS0FHRV9OQU1FKTtcbiAgICAgIGNvbnN0IHBlbmRpbmdTZWxlY3RlZFdhbGxldElkID0geWllbGQganNvblN0b3JhZ2UuZ2V0SXRlbShQRU5ESU5HX1NFTEVDVEVEX1dBTExFVF9JRCk7XG4gICAgICBjb25zdCBwZW5kaW5nQ29udHJhY3QgPSB5aWVsZCBqc29uU3RvcmFnZS5nZXRJdGVtKFBFTkRJTkdfQ09OVFJBQ1QpO1xuICAgICAgaWYgKHBlbmRpbmdTZWxlY3RlZFdhbGxldElkICYmIHBlbmRpbmdDb250cmFjdCkge1xuICAgICAgICBjb25zdCBfYWNjb3VudHMgPSB5aWVsZCB0aGlzLnZhbGlkYXRlV2FsbGV0KHBlbmRpbmdTZWxlY3RlZFdhbGxldElkKTtcbiAgICAgICAgeWllbGQganNvblN0b3JhZ2UucmVtb3ZlSXRlbShQRU5ESU5HX1NFTEVDVEVEX1dBTExFVF9JRCk7XG4gICAgICAgIHlpZWxkIGpzb25TdG9yYWdlLnJlbW92ZUl0ZW0oUEVORElOR19DT05UUkFDVCk7XG4gICAgICAgIGlmIChfYWNjb3VudHMubGVuZ3RoKSB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgc2VsZWN0ZWRXYWxsZXRJZDogX3NlbGVjdGVkV2FsbGV0SWRcbiAgICAgICAgICB9ID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgIGNvbnN0IHNlbGVjdGVkV2FsbGV0ID0geWllbGQgdGhpcy5nZXRXYWxsZXQoX3NlbGVjdGVkV2FsbGV0SWQpO1xuICAgICAgICAgIGlmIChzZWxlY3RlZFdhbGxldCAmJiBwZW5kaW5nU2VsZWN0ZWRXYWxsZXRJZCAhPT0gX3NlbGVjdGVkV2FsbGV0SWQpIHtcbiAgICAgICAgICAgIHlpZWxkIHNlbGVjdGVkV2FsbGV0LnNpZ25PdXQoKS5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICBsb2dnZXIubG9nKFwiRmFpbGVkIHRvIHNpZ24gb3V0IGV4aXN0aW5nIHdhbGxldFwiKTtcbiAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgcmVjZW50bHlTaWduZWRJbldhbGxldHNGcm9tUGVuZGluZyA9IHlpZWxkIHRoaXMuc2V0V2FsbGV0QXNSZWNlbnRseVNpZ25lZEluKHBlbmRpbmdTZWxlY3RlZFdhbGxldElkKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWNjb3VudHM6IF9hY2NvdW50cyxcbiAgICAgICAgICAgIGNvbnRyYWN0OiBwZW5kaW5nQ29udHJhY3QsXG4gICAgICAgICAgICBzZWxlY3RlZFdhbGxldElkOiBwZW5kaW5nU2VsZWN0ZWRXYWxsZXRJZCxcbiAgICAgICAgICAgIHJlY2VudGx5U2lnbmVkSW5XYWxsZXRzOiByZWNlbnRseVNpZ25lZEluV2FsbGV0c0Zyb21QZW5kaW5nXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3Qge1xuICAgICAgICBjb250cmFjdCxcbiAgICAgICAgc2VsZWN0ZWRXYWxsZXRJZFxuICAgICAgfSA9IHRoaXMuc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgIGNvbnN0IGFjY291bnRzID0geWllbGQgdGhpcy52YWxpZGF0ZVdhbGxldChzZWxlY3RlZFdhbGxldElkKTtcbiAgICAgIGNvbnN0IHJlY2VudGx5U2lnbmVkSW5XYWxsZXRzID0geWllbGQganNvblN0b3JhZ2UuZ2V0SXRlbShSRUNFTlRMWV9TSUdORURfSU5fV0FMTEVUUyk7XG4gICAgICBpZiAoIWFjY291bnRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGFjY291bnRzOiBbXSxcbiAgICAgICAgICBjb250cmFjdDogbnVsbCxcbiAgICAgICAgICBzZWxlY3RlZFdhbGxldElkOiBudWxsLFxuICAgICAgICAgIHJlY2VudGx5U2lnbmVkSW5XYWxsZXRzOiByZWNlbnRseVNpZ25lZEluV2FsbGV0cyB8fCBbXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYWNjb3VudHMsXG4gICAgICAgIGNvbnRyYWN0LFxuICAgICAgICBzZWxlY3RlZFdhbGxldElkLFxuICAgICAgICByZWNlbnRseVNpZ25lZEluV2FsbGV0czogcmVjZW50bHlTaWduZWRJbldhbGxldHMgfHwgW11cbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgc2V0V2FsbGV0QXNSZWNlbnRseVNpZ25lZEluKHdhbGxldElkKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IGpzb25TdG9yYWdlID0gbmV3IEpzb25TdG9yYWdlKHRoaXMuc3RvcmFnZSwgUEFDS0FHRV9OQU1FKTtcbiAgICAgIGxldCByZWNlbnRseVNpZ25lZEluV2FsbGV0cyA9IHlpZWxkIGpzb25TdG9yYWdlLmdldEl0ZW0oUkVDRU5UTFlfU0lHTkVEX0lOX1dBTExFVFMpO1xuICAgICAgaWYgKCFyZWNlbnRseVNpZ25lZEluV2FsbGV0cykge1xuICAgICAgICByZWNlbnRseVNpZ25lZEluV2FsbGV0cyA9IFtdO1xuICAgICAgfVxuICAgICAgaWYgKCFyZWNlbnRseVNpZ25lZEluV2FsbGV0cy5pbmNsdWRlcyh3YWxsZXRJZCkpIHtcbiAgICAgICAgcmVjZW50bHlTaWduZWRJbldhbGxldHMudW5zaGlmdCh3YWxsZXRJZCk7XG4gICAgICAgIHJlY2VudGx5U2lnbmVkSW5XYWxsZXRzID0gcmVjZW50bHlTaWduZWRJbldhbGxldHMuc2xpY2UoMCwgNSk7XG4gICAgICAgIHlpZWxkIGpzb25TdG9yYWdlLnNldEl0ZW0oUkVDRU5UTFlfU0lHTkVEX0lOX1dBTExFVFMsIHJlY2VudGx5U2lnbmVkSW5XYWxsZXRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZWNlbnRseVNpZ25lZEluV2FsbGV0cztcbiAgICB9KTtcbiAgfVxuICBzaWduT3V0V2FsbGV0KHdhbGxldElkKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IHdhbGxldCA9IHlpZWxkIHRoaXMuZ2V0V2FsbGV0KHdhbGxldElkKTtcbiAgICAgIHlpZWxkIHdhbGxldC5zaWduT3V0KCkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgbG9nZ2VyLmxvZyhgRmFpbGVkIHRvIHNpZ24gb3V0ICR7d2FsbGV0LmlkfWApO1xuICAgICAgICBsb2dnZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgLy8gQXQgbGVhc3QgY2xlYW4gdXAgc3RhdGUgb24gb3VyIHNpZGUuXG4gICAgICAgIHRoaXMub25XYWxsZXRTaWduZWRPdXQod2FsbGV0LmlkKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIG9uV2FsbGV0U2lnbmVkSW4od2FsbGV0SWQsIHtcbiAgICBhY2NvdW50cyxcbiAgICBjb250cmFjdElkLFxuICAgIG1ldGhvZE5hbWVzXG4gIH0pIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzZWxlY3RlZFdhbGxldElkXG4gICAgICB9ID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgY29uc3QganNvblN0b3JhZ2UgPSBuZXcgSnNvblN0b3JhZ2UodGhpcy5zdG9yYWdlLCBQQUNLQUdFX05BTUUpO1xuICAgICAgY29uc3QgY29udHJhY3QgPSB7XG4gICAgICAgIGNvbnRyYWN0SWQsXG4gICAgICAgIG1ldGhvZE5hbWVzXG4gICAgICB9O1xuICAgICAgaWYgKCFhY2NvdW50cy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgbW9kdWxlID0gdGhpcy5nZXRNb2R1bGUod2FsbGV0SWQpO1xuICAgICAgICAvLyBXZSBjYW4ndCBndWFyYW50ZWUgdGhlIHVzZXIgd2lsbCBhY3R1YWxseSBzaWduIGluIHdpdGggYnJvd3NlciB3YWxsZXRzLlxuICAgICAgICAvLyBCZXN0IHdlIGNhbiBkbyBpcyBzZXQgaW4gc3RvcmFnZSBhbmQgdmFsaWRhdGUgb24gaW5pdC5cbiAgICAgICAgaWYgKG1vZHVsZS50eXBlID09PSBcImJyb3dzZXJcIikge1xuICAgICAgICAgIHlpZWxkIGpzb25TdG9yYWdlLnNldEl0ZW0oUEVORElOR19TRUxFQ1RFRF9XQUxMRVRfSUQsIHdhbGxldElkKTtcbiAgICAgICAgICB5aWVsZCBqc29uU3RvcmFnZS5zZXRJdGVtKFBFTkRJTkdfQ09OVFJBQ1QsIGNvbnRyYWN0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoc2VsZWN0ZWRXYWxsZXRJZCAmJiBzZWxlY3RlZFdhbGxldElkICE9PSB3YWxsZXRJZCkge1xuICAgICAgICB5aWVsZCB0aGlzLnNpZ25PdXRXYWxsZXQoc2VsZWN0ZWRXYWxsZXRJZCk7XG4gICAgICB9XG4gICAgICBjb25zdCByZWNlbnRseVNpZ25lZEluV2FsbGV0cyA9IHlpZWxkIHRoaXMuc2V0V2FsbGV0QXNSZWNlbnRseVNpZ25lZEluKHdhbGxldElkKTtcbiAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiBcIldBTExFVF9DT05ORUNURURcIixcbiAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgIHdhbGxldElkLFxuICAgICAgICAgIGNvbnRyYWN0LFxuICAgICAgICAgIGFjY291bnRzLFxuICAgICAgICAgIHJlY2VudGx5U2lnbmVkSW5XYWxsZXRzXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5lbWl0dGVyLmVtaXQoXCJzaWduZWRJblwiLCB7XG4gICAgICAgIHdhbGxldElkLFxuICAgICAgICBjb250cmFjdElkLFxuICAgICAgICBtZXRob2ROYW1lcyxcbiAgICAgICAgYWNjb3VudHNcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIG9uV2FsbGV0U2lnbmVkT3V0KHdhbGxldElkKSB7XG4gICAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgICB0eXBlOiBcIldBTExFVF9ESVNDT05ORUNURURcIixcbiAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgd2FsbGV0SWRcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmVtaXR0ZXIuZW1pdChcInNpZ25lZE91dFwiLCB7XG4gICAgICB3YWxsZXRJZFxuICAgIH0pO1xuICB9XG4gIHNldHVwV2FsbGV0RW1pdHRlcihtb2R1bGUpIHtcbiAgICBjb25zdCBlbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIGVtaXR0ZXIub24oXCJzaWduZWRPdXRcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5vbldhbGxldFNpZ25lZE91dChtb2R1bGUuaWQpO1xuICAgIH0pO1xuICAgIGVtaXR0ZXIub24oXCJzaWduZWRJblwiLCBldmVudCA9PiB7XG4gICAgICB0aGlzLm9uV2FsbGV0U2lnbmVkSW4obW9kdWxlLmlkLCBldmVudCk7XG4gICAgfSk7XG4gICAgZW1pdHRlci5vbihcImFjY291bnRzQ2hhbmdlZFwiLCAoe1xuICAgICAgYWNjb3VudHNcbiAgICB9KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB0aGlzLmVtaXR0ZXIuZW1pdChcImFjY291bnRzQ2hhbmdlZFwiLCB7XG4gICAgICAgIHdhbGxldElkOiBtb2R1bGUuaWQsXG4gICAgICAgIGFjY291bnRzXG4gICAgICB9KTtcbiAgICAgIGlmICghYWNjb3VudHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpZ25PdXRXYWxsZXQobW9kdWxlLmlkKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiBcIkFDQ09VTlRTX0NIQU5HRURcIixcbiAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgIHdhbGxldElkOiBtb2R1bGUuaWQsXG4gICAgICAgICAgYWNjb3VudHNcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSkpO1xuICAgIGVtaXR0ZXIub24oXCJuZXR3b3JrQ2hhbmdlZFwiLCAoe1xuICAgICAgbmV0d29ya0lkXG4gICAgfSkgPT4ge1xuICAgICAgdGhpcy5lbWl0dGVyLmVtaXQoXCJuZXR3b3JrQ2hhbmdlZFwiLCB7XG4gICAgICAgIHdhbGxldElkOiBtb2R1bGUuaWQsXG4gICAgICAgIG5ldHdvcmtJZFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgZW1pdHRlci5vbihcInVyaUNoYW5nZWRcIiwgKHtcbiAgICAgIHVyaVxuICAgIH0pID0+IHtcbiAgICAgIHRoaXMuZW1pdHRlci5lbWl0KFwidXJpQ2hhbmdlZFwiLCB7XG4gICAgICAgIHdhbGxldElkOiBtb2R1bGUuaWQsXG4gICAgICAgIHVyaVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGVtaXR0ZXI7XG4gIH1cbiAgdmFsaWRhdGVTaWduTWVzc2FnZVBhcmFtcyh7XG4gICAgbWVzc2FnZSxcbiAgICBub25jZSxcbiAgICByZWNpcGllbnRcbiAgfSkge1xuICAgIGlmICghbWVzc2FnZSB8fCBtZXNzYWdlLnRyaW0oKSA9PT0gXCJcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBtZXNzYWdlLiBJdCBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZy5cIik7XG4gICAgfVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKG5vbmNlKSB8fCBub25jZS5sZW5ndGggIT09IDMyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG5vbmNlLiBJdCBtdXN0IGJlIGEgQnVmZmVyIHdpdGggYSBsZW5ndGggb2YgMzIgYnl0ZXMuXCIpO1xuICAgIH1cbiAgICBpZiAoIXJlY2lwaWVudCB8fCByZWNpcGllbnQudHJpbSgpID09PSBcIlwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJlY2lwaWVudC4gSXQgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcuXCIpO1xuICAgIH1cbiAgfVxuICBkZWNvcmF0ZVdhbGxldCh3YWxsZXQpIHtcbiAgICBjb25zdCBfc2lnbkluID0gd2FsbGV0LnNpZ25JbjtcbiAgICBjb25zdCBfc2lnbk91dCA9IHdhbGxldC5zaWduT3V0O1xuICAgIGNvbnN0IF9zaWduTWVzc2FnZSA9IHdhbGxldC5zaWduTWVzc2FnZTtcbiAgICB3YWxsZXQuc2lnbkluID0gcGFyYW1zID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IGFjY291bnRzID0geWllbGQgX3NpZ25JbihwYXJhbXMpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBjb250cmFjdElkLFxuICAgICAgICBtZXRob2ROYW1lcyA9IFtdXG4gICAgICB9ID0gcGFyYW1zO1xuICAgICAgeWllbGQgdGhpcy5vbldhbGxldFNpZ25lZEluKHdhbGxldC5pZCwge1xuICAgICAgICBhY2NvdW50cyxcbiAgICAgICAgY29udHJhY3RJZCxcbiAgICAgICAgbWV0aG9kTmFtZXNcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFjY291bnRzO1xuICAgIH0pO1xuICAgIHdhbGxldC5zaWduT3V0ID0gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgeWllbGQgX3NpZ25PdXQoKTtcbiAgICAgIHRoaXMub25XYWxsZXRTaWduZWRPdXQod2FsbGV0LmlkKTtcbiAgICB9KTtcbiAgICB3YWxsZXQuc2lnbk1lc3NhZ2UgPSBwYXJhbXMgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKF9zaWduTWVzc2FnZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IEVycm9yKGBUaGUgc2lnbk1lc3NhZ2UgbWV0aG9kIGlzIG5vdCBzdXBwb3J0ZWQgYnkgJHt3YWxsZXQubWV0YWRhdGEubmFtZX1gKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudmFsaWRhdGVTaWduTWVzc2FnZVBhcmFtcyhwYXJhbXMpO1xuICAgICAgcmV0dXJuIHlpZWxkIF9zaWduTWVzc2FnZShwYXJhbXMpO1xuICAgIH0pO1xuICAgIHJldHVybiB3YWxsZXQ7XG4gIH1cbiAgc2V0dXBJbnN0YW5jZShtb2R1bGUpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKCFtb2R1bGUubWV0YWRhdGEuYXZhaWxhYmxlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBtb2R1bGUudHlwZSA9PT0gXCJpbmplY3RlZFwiID8gXCJub3QgaW5zdGFsbGVkXCIgOiBcIm5vdCBhdmFpbGFibGVcIjtcbiAgICAgICAgdGhyb3cgRXJyb3IoYCR7bW9kdWxlLm1ldGFkYXRhLm5hbWV9IGlzICR7bWVzc2FnZX1gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHdhbGxldCA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBpZDogbW9kdWxlLmlkLFxuICAgICAgICB0eXBlOiBtb2R1bGUudHlwZSxcbiAgICAgICAgbWV0YWRhdGE6IG1vZHVsZS5tZXRhZGF0YVxuICAgICAgfSwgeWllbGQgbW9kdWxlLmluaXQoe1xuICAgICAgICBpZDogbW9kdWxlLmlkLFxuICAgICAgICB0eXBlOiBtb2R1bGUudHlwZSxcbiAgICAgICAgbWV0YWRhdGE6IG1vZHVsZS5tZXRhZGF0YSxcbiAgICAgICAgb3B0aW9uczogdGhpcy5vcHRpb25zLFxuICAgICAgICBzdG9yZTogdGhpcy5zdG9yZS50b1JlYWRPbmx5KCksXG4gICAgICAgIHByb3ZpZGVyOiB0aGlzLnByb3ZpZGVyLFxuICAgICAgICBlbWl0dGVyOiB0aGlzLnNldHVwV2FsbGV0RW1pdHRlcihtb2R1bGUpLFxuICAgICAgICBsb2dnZXI6IG5ldyBMb2dnZXIobW9kdWxlLmlkKSxcbiAgICAgICAgc3RvcmFnZTogbmV3IEpzb25TdG9yYWdlKHRoaXMuc3RvcmFnZSwgW1BBQ0tBR0VfTkFNRSwgbW9kdWxlLmlkXSlcbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiB0aGlzLmRlY29yYXRlV2FsbGV0KHdhbGxldCk7XG4gICAgfSk7XG4gIH1cbiAgZ2V0TW9kdWxlKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMubW9kdWxlcy5maW5kKHggPT4geC5pZCA9PT0gaWQpO1xuICB9XG4gIGdldFdhbGxldChpZCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCBtb2R1bGUgPSB0aGlzLmdldE1vZHVsZShpZCk7XG4gICAgICBpZiAoIW1vZHVsZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc2VsZWN0ZWRXYWxsZXRJZFxuICAgICAgfSA9IHRoaXMuc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgIC8vIElmIHVzZXIgdW5pbnN0YWxsZWQvcmVtb3ZlZCBhIHdhbGxldCB3aGljaCB3YXMgcHJldmlvdXNseSBzaWduZWQgaW4gd2l0aFxuICAgICAgLy8gYmVzdCB3ZSBjYW4gZG8gaXMgY2xlYW4gdXAgc3RhdGUgb24gb3VyIHNpZGUuXG4gICAgICBpZiAoIW1vZHVsZS5tZXRhZGF0YS5hdmFpbGFibGUgJiYgc2VsZWN0ZWRXYWxsZXRJZCkge1xuICAgICAgICB0aGlzLm9uV2FsbGV0U2lnbmVkT3V0KHNlbGVjdGVkV2FsbGV0SWQpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB5aWVsZCBtb2R1bGUud2FsbGV0KCk7XG4gICAgfSk7XG4gIH1cbiAgc2V0dXAoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IG1vZHVsZXMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5mYWN0b3JpZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgbW9kdWxlID0geWllbGQgdGhpcy5mYWN0b3JpZXNbaV0oe1xuICAgICAgICAgIG9wdGlvbnM6IHRoaXMub3B0aW9uc1xuICAgICAgICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgIGxvZ2dlci5sb2coXCJGYWlsZWQgdG8gc2V0dXAgbW9kdWxlXCIpO1xuICAgICAgICAgIGxvZ2dlci5lcnJvcihlcnIpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gRmlsdGVyIG91dCB3YWxsZXRzIHRoYXQgYXJlbid0IGF2YWlsYWJsZS5cbiAgICAgICAgaWYgKCFtb2R1bGUpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTa2lwIGR1cGxpY2F0ZWQgbW9kdWxlLlxuICAgICAgICBpZiAobW9kdWxlcy5zb21lKHggPT4geC5pZCA9PT0gbW9kdWxlLmlkKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIG1vZHVsZXMucHVzaCh7XG4gICAgICAgICAgaWQ6IG1vZHVsZS5pZCxcbiAgICAgICAgICB0eXBlOiBtb2R1bGUudHlwZSxcbiAgICAgICAgICBtZXRhZGF0YTogbW9kdWxlLm1ldGFkYXRhLFxuICAgICAgICAgIHdhbGxldDogKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgbGV0IGluc3RhbmNlID0gdGhpcy5pbnN0YW5jZXNbbW9kdWxlLmlkXTtcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnN0YW5jZSA9IHlpZWxkIHRoaXMuc2V0dXBJbnN0YW5jZShtb2R1bGUpO1xuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZXNbbW9kdWxlLmlkXSA9IGluc3RhbmNlO1xuICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5tb2R1bGVzID0gbW9kdWxlcztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYWNjb3VudHMsXG4gICAgICAgIGNvbnRyYWN0LFxuICAgICAgICBzZWxlY3RlZFdhbGxldElkLFxuICAgICAgICByZWNlbnRseVNpZ25lZEluV2FsbGV0c1xuICAgICAgfSA9IHlpZWxkIHRoaXMucmVzb2x2ZVN0b3JhZ2VTdGF0ZSgpO1xuICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IFwiU0VUVVBfV0FMTEVUX01PRFVMRVNcIixcbiAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgIG1vZHVsZXMsXG4gICAgICAgICAgYWNjb3VudHMsXG4gICAgICAgICAgY29udHJhY3QsXG4gICAgICAgICAgc2VsZWN0ZWRXYWxsZXRJZCxcbiAgICAgICAgICByZWNlbnRseVNpZ25lZEluV2FsbGV0c1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLm1vZHVsZXNbaV0udHlwZSAhPT0gXCJpbnN0YW50LWxpbmtcIikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdhbGxldCA9IHlpZWxkIHRoaXMubW9kdWxlc1tpXS53YWxsZXQoKTtcbiAgICAgICAgaWYgKCF3YWxsZXQubWV0YWRhdGEucnVuT25TdGFydHVwKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB5aWVsZCB3YWxsZXQuc2lnbkluKHtcbiAgICAgICAgICAgIGNvbnRyYWN0SWQ6IHdhbGxldC5nZXRDb250cmFjdElkKClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgbG9nZ2VyLmVycm9yKFwiRmFpbGVkIHRvIHNpZ24gaW4gdG8gd2FsbGV0LiBcIiArIGVycik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5jb25zdCBnZXROZXR3b3JrUHJlc2V0ID0gbmV0d29ya0lkID0+IHtcbiAgc3dpdGNoIChuZXR3b3JrSWQpIHtcbiAgICBjYXNlIFwibWFpbm5ldFwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmV0d29ya0lkLFxuICAgICAgICBub2RlVXJsOiBcImh0dHBzOi8vcnBjLm1haW5uZXQubmVhci5vcmdcIixcbiAgICAgICAgaGVscGVyVXJsOiBcImh0dHBzOi8vaGVscGVyLm1haW5uZXQubmVhci5vcmdcIixcbiAgICAgICAgZXhwbG9yZXJVcmw6IFwiaHR0cHM6Ly9uZWFyYmxvY2tzLmlvXCIsXG4gICAgICAgIGluZGV4ZXJVcmw6IFwiaHR0cHM6Ly9hcGkua2l0d2FsbGV0LmFwcFwiXG4gICAgICB9O1xuICAgIGNhc2UgXCJ0ZXN0bmV0XCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuZXR3b3JrSWQsXG4gICAgICAgIG5vZGVVcmw6IFwiaHR0cHM6Ly9ycGMudGVzdG5ldC5uZWFyLm9yZ1wiLFxuICAgICAgICBoZWxwZXJVcmw6IFwiaHR0cHM6Ly9oZWxwZXIudGVzdG5ldC5uZWFyLm9yZ1wiLFxuICAgICAgICBleHBsb3JlclVybDogXCJodHRwczovL3Rlc3RuZXQubmVhcmJsb2Nrcy5pb1wiLFxuICAgICAgICBpbmRleGVyVXJsOiBcImh0dHBzOi8vdGVzdG5ldC1hcGkua2l0d2FsbGV0LmFwcFwiXG4gICAgICB9O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBFcnJvcihgRmFpbGVkIHRvIGZpbmQgY29uZmlnIGZvcjogJyR7bmV0d29ya0lkfSdgKTtcbiAgfVxufTtcbmNvbnN0IHJlc29sdmVOZXR3b3JrID0gbmV0d29yayA9PiB7XG4gIHJldHVybiB0eXBlb2YgbmV0d29yayA9PT0gXCJzdHJpbmdcIiA/IGdldE5ldHdvcmtQcmVzZXQobmV0d29yaykgOiBuZXR3b3JrO1xufTtcbmNvbnN0IHJlc29sdmVPcHRpb25zID0gcGFyYW1zID0+IHtcbiAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICBsYW5ndWFnZUNvZGU6IHBhcmFtcy5sYW5ndWFnZUNvZGUgfHwgdW5kZWZpbmVkLFxuICAgIG5ldHdvcms6IHJlc29sdmVOZXR3b3JrKHBhcmFtcy5uZXR3b3JrKSxcbiAgICBkZWJ1ZzogcGFyYW1zLmRlYnVnIHx8IGZhbHNlLFxuICAgIG9wdGltaXplV2FsbGV0T3JkZXI6IHBhcmFtcy5vcHRpbWl6ZVdhbGxldE9yZGVyID09PSBmYWxzZSA/IGZhbHNlIDogdHJ1ZSxcbiAgICByYW5kb21pemVXYWxsZXRPcmRlcjogcGFyYW1zLnJhbmRvbWl6ZVdhbGxldE9yZGVyIHx8IGZhbHNlLFxuICAgIHJlbGF5ZXJVcmw6IHBhcmFtcy5yZWxheWVyVXJsIHx8IHVuZGVmaW5lZFxuICB9O1xuICByZXR1cm4ge1xuICAgIG9wdGlvbnMsXG4gICAgc3RvcmFnZTogcGFyYW1zLnN0b3JhZ2UgfHwgbmV3IFdlYlN0b3JhZ2VTZXJ2aWNlKClcbiAgfTtcbn07XG5cbmNvbnN0IHJlZHVjZXIgPSAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICBsb2dnZXIubG9nKFwiU3RvcmUgQWN0aW9uXCIsIGFjdGlvbik7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlIFwiU0VUVVBfV0FMTEVUX01PRFVMRVNcIjpcbiAgICAgIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIG1vZHVsZXMsXG4gICAgICAgICAgYWNjb3VudHMsXG4gICAgICAgICAgY29udHJhY3QsXG4gICAgICAgICAgc2VsZWN0ZWRXYWxsZXRJZCxcbiAgICAgICAgICByZWNlbnRseVNpZ25lZEluV2FsbGV0c1xuICAgICAgICB9ID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgICAgIGNvbnN0IGFjY291bnRTdGF0ZXMgPSBhY2NvdW50cy5tYXAoKGFjY291bnQsIGkpID0+IHtcbiAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhY2NvdW50KSwge1xuICAgICAgICAgICAgYWN0aXZlOiBpID09PSAwXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSksIHtcbiAgICAgICAgICBtb2R1bGVzLFxuICAgICAgICAgIGFjY291bnRzOiBhY2NvdW50U3RhdGVzLFxuICAgICAgICAgIGNvbnRyYWN0LFxuICAgICAgICAgIHNlbGVjdGVkV2FsbGV0SWQsXG4gICAgICAgICAgcmVjZW50bHlTaWduZWRJbldhbGxldHNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgY2FzZSBcIldBTExFVF9DT05ORUNURURcIjpcbiAgICAgIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHdhbGxldElkLFxuICAgICAgICAgIGNvbnRyYWN0LFxuICAgICAgICAgIGFjY291bnRzLFxuICAgICAgICAgIHJlY2VudGx5U2lnbmVkSW5XYWxsZXRzXG4gICAgICAgIH0gPSBhY3Rpb24ucGF5bG9hZDtcbiAgICAgICAgaWYgKCFhY2NvdW50cy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWN0aXZlQWNjb3VudEluZGV4ID0gc3RhdGUuYWNjb3VudHMuZmluZEluZGV4KGFjY291bnQgPT4gYWNjb3VudC5hY3RpdmUpO1xuICAgICAgICBjb25zdCBhY2NvdW50U3RhdGVzID0gYWNjb3VudHMubWFwKChhY2NvdW50LCBpKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYWNjb3VudCksIHtcbiAgICAgICAgICAgIGFjdGl2ZTogaSA9PT0gKGFjdGl2ZUFjY291bnRJbmRleCA+IC0xID8gYWN0aXZlQWNjb3VudEluZGV4IDogMClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0YXRlKSwge1xuICAgICAgICAgIGNvbnRyYWN0LFxuICAgICAgICAgIGFjY291bnRzOiBhY2NvdW50U3RhdGVzLFxuICAgICAgICAgIHNlbGVjdGVkV2FsbGV0SWQ6IHdhbGxldElkLFxuICAgICAgICAgIHJlY2VudGx5U2lnbmVkSW5XYWxsZXRzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIGNhc2UgXCJXQUxMRVRfRElTQ09OTkVDVEVEXCI6XG4gICAgICB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICB3YWxsZXRJZFxuICAgICAgICB9ID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgICAgIGlmICh3YWxsZXRJZCAhPT0gc3RhdGUuc2VsZWN0ZWRXYWxsZXRJZCkge1xuICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSksIHtcbiAgICAgICAgICBjb250cmFjdDogbnVsbCxcbiAgICAgICAgICBhY2NvdW50czogW10sXG4gICAgICAgICAgc2VsZWN0ZWRXYWxsZXRJZDogbnVsbFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICBjYXNlIFwiQUNDT1VOVFNfQ0hBTkdFRFwiOlxuICAgICAge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgd2FsbGV0SWQsXG4gICAgICAgICAgYWNjb3VudHNcbiAgICAgICAgfSA9IGFjdGlvbi5wYXlsb2FkO1xuICAgICAgICBpZiAod2FsbGV0SWQgIT09IHN0YXRlLnNlbGVjdGVkV2FsbGV0SWQpIHtcbiAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWN0aXZlQWNjb3VudCA9IHN0YXRlLmFjY291bnRzLmZpbmQoYWNjb3VudCA9PiBhY2NvdW50LmFjdGl2ZSk7XG4gICAgICAgIGNvbnN0IGlzQWN0aXZlQWNjb3VudFJlbW92ZWQgPSAhYWNjb3VudHMuc29tZShhY2NvdW50ID0+IGFjY291bnQuYWNjb3VudElkID09PSAoYWN0aXZlQWNjb3VudCA9PT0gbnVsbCB8fCBhY3RpdmVBY2NvdW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhY3RpdmVBY2NvdW50LmFjY291bnRJZCkpO1xuICAgICAgICBjb25zdCBhY2NvdW50U3RhdGVzID0gYWNjb3VudHMubWFwKChhY2NvdW50LCBpKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYWNjb3VudCksIHtcbiAgICAgICAgICAgIGFjdGl2ZTogaXNBY3RpdmVBY2NvdW50UmVtb3ZlZCA/IGkgPT09IDAgOiBhY2NvdW50LmFjY291bnRJZCA9PT0gKGFjdGl2ZUFjY291bnQgPT09IG51bGwgfHwgYWN0aXZlQWNjb3VudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWN0aXZlQWNjb3VudC5hY2NvdW50SWQpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSksIHtcbiAgICAgICAgICBhY2NvdW50czogYWNjb3VudFN0YXRlc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICBjYXNlIFwiU0VUX0FDVElWRV9BQ0NPVU5UXCI6XG4gICAgICB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBhY2NvdW50SWRcbiAgICAgICAgfSA9IGFjdGlvbi5wYXlsb2FkO1xuICAgICAgICBjb25zdCBhY2NvdW50U3RhdGVzID0gc3RhdGUuYWNjb3VudHMubWFwKGFjY291bnQgPT4ge1xuICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFjY291bnQpLCB7XG4gICAgICAgICAgICBhY3RpdmU6IGFjY291bnQuYWNjb3VudElkID09PSBhY2NvdW50SWRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0YXRlKSwge1xuICAgICAgICAgIGFjY291bnRzOiBhY2NvdW50U3RhdGVzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn07XG5jb25zdCBjcmVhdGVTdG9yZSA9IHN0b3JhZ2UgPT4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gIGNvbnN0IGpzb25TdG9yYWdlID0gbmV3IEpzb25TdG9yYWdlKHN0b3JhZ2UsIFBBQ0tBR0VfTkFNRSk7XG4gIGNvbnN0IGluaXRpYWxTdGF0ZSA9IHtcbiAgICBtb2R1bGVzOiBbXSxcbiAgICBhY2NvdW50czogW10sXG4gICAgY29udHJhY3Q6IHlpZWxkIGpzb25TdG9yYWdlLmdldEl0ZW0oQ09OVFJBQ1QpLFxuICAgIHNlbGVjdGVkV2FsbGV0SWQ6IHlpZWxkIGpzb25TdG9yYWdlLmdldEl0ZW0oU0VMRUNURURfV0FMTEVUX0lEKSxcbiAgICByZWNlbnRseVNpZ25lZEluV2FsbGV0czogKHlpZWxkIGpzb25TdG9yYWdlLmdldEl0ZW0oUkVDRU5UTFlfU0lHTkVEX0lOX1dBTExFVFMpKSB8fCBbXVxuICB9O1xuICBjb25zdCBzdGF0ZSQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KGluaXRpYWxTdGF0ZSk7XG4gIGNvbnN0IGFjdGlvbnMkID0gbmV3IFN1YmplY3QoKTtcbiAgYWN0aW9ucyQucGlwZShzY2FuKHJlZHVjZXIsIGluaXRpYWxTdGF0ZSkpLnN1YnNjcmliZShzdGF0ZSQpO1xuICBjb25zdCBzeW5jU3RvcmFnZSA9IChwcmV2U3RhdGUsIHN0YXRlLCBzdG9yYWdlS2V5LCBwcm9wZXJ0eSkgPT4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgaWYgKHN0YXRlW3Byb3BlcnR5XSA9PT0gcHJldlN0YXRlW3Byb3BlcnR5XSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc3RhdGVbcHJvcGVydHldKSB7XG4gICAgICB5aWVsZCBqc29uU3RvcmFnZS5zZXRJdGVtKHN0b3JhZ2VLZXksIHN0YXRlW3Byb3BlcnR5XSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHlpZWxkIGpzb25TdG9yYWdlLnJlbW92ZUl0ZW0oc3RvcmFnZUtleSk7XG4gIH0pO1xuICBsZXQgcHJldlN0YXRlID0gc3RhdGUkLmdldFZhbHVlKCk7XG4gIHN0YXRlJC5zdWJzY3JpYmUoc3RhdGUgPT4ge1xuICAgIHN5bmNTdG9yYWdlKHByZXZTdGF0ZSwgc3RhdGUsIFNFTEVDVEVEX1dBTExFVF9JRCwgXCJzZWxlY3RlZFdhbGxldElkXCIpO1xuICAgIHN5bmNTdG9yYWdlKHByZXZTdGF0ZSwgc3RhdGUsIENPTlRSQUNULCBcImNvbnRyYWN0XCIpO1xuICAgIHN5bmNTdG9yYWdlKHByZXZTdGF0ZSwgc3RhdGUsIFJFQ0VOVExZX1NJR05FRF9JTl9XQUxMRVRTLCBcInJlY2VudGx5U2lnbmVkSW5XYWxsZXRzXCIpO1xuICAgIHByZXZTdGF0ZSA9IHN0YXRlO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBvYnNlcnZhYmxlOiBzdGF0ZSQsXG4gICAgZ2V0U3RhdGU6ICgpID0+IHN0YXRlJC5nZXRWYWx1ZSgpLFxuICAgIGRpc3BhdGNoOiBhY3Rpb24gPT4gYWN0aW9ucyQubmV4dChhY3Rpb24pLFxuICAgIHRvUmVhZE9ubHk6ICgpID0+ICh7XG4gICAgICBnZXRTdGF0ZTogKCkgPT4gc3RhdGUkLmdldFZhbHVlKCksXG4gICAgICBvYnNlcnZhYmxlOiBzdGF0ZSQuYXNPYnNlcnZhYmxlKClcbiAgICB9KVxuICB9O1xufSk7XG5cbmxldCB3YWxsZXRTZWxlY3Rvckluc3RhbmNlID0gbnVsbDtcbmNvbnN0IGNyZWF0ZVNlbGVjdG9yID0gKG9wdGlvbnMsIHN0b3JlLCB3YWxsZXRNb2R1bGVzLCBlbWl0dGVyKSA9PiB7XG4gIHJldHVybiB7XG4gICAgb3B0aW9ucyxcbiAgICBzdG9yZTogc3RvcmUudG9SZWFkT25seSgpLFxuICAgIHdhbGxldDogaWQgPT4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNlbGVjdGVkV2FsbGV0SWRcbiAgICAgIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgY29uc3Qgd2FsbGV0ID0geWllbGQgd2FsbGV0TW9kdWxlcy5nZXRXYWxsZXQoaWQgfHwgc2VsZWN0ZWRXYWxsZXRJZCk7XG4gICAgICBpZiAoIXdhbGxldCkge1xuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHdhbGxldCBpZFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyB3YWxsZXQgc2VsZWN0ZWRcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gd2FsbGV0O1xuICAgIH0pLFxuICAgIHNldEFjdGl2ZUFjY291bnQ6IGFjY291bnRJZCA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFjY291bnRzXG4gICAgICB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgIGlmICghYWNjb3VudHMuc29tZShhY2NvdW50ID0+IGFjY291bnQuYWNjb3VudElkID09PSBhY2NvdW50SWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYWNjb3VudCBpZFwiKTtcbiAgICAgIH1cbiAgICAgIHN0b3JlLmRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogXCJTRVRfQUNUSVZFX0FDQ09VTlRcIixcbiAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgIGFjY291bnRJZFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGlzU2lnbmVkSW4oKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFjY291bnRzXG4gICAgICB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgIHJldHVybiBCb29sZWFuKGFjY291bnRzLmxlbmd0aCk7XG4gICAgfSxcbiAgICBvbjogKGV2ZW50TmFtZSwgY2FsbGJhY2spID0+IHtcbiAgICAgIHJldHVybiBlbWl0dGVyLm9uKGV2ZW50TmFtZSwgY2FsbGJhY2spO1xuICAgIH0sXG4gICAgb2ZmOiAoZXZlbnROYW1lLCBjYWxsYmFjaykgPT4ge1xuICAgICAgZW1pdHRlci5vZmYoZXZlbnROYW1lLCBjYWxsYmFjayk7XG4gICAgfVxuICB9O1xufTtcbi8qKlxyXG4gKiBJbml0aWF0ZXMgYSB3YWxsZXQgc2VsZWN0b3IgaW5zdGFuY2VcclxuICogQHBhcmFtIHtXYWxsZXRTZWxlY3RvclBhcmFtc30gcGFyYW1zIFNlbGVjdG9yIHBhcmFtZXRlcnMgKG5ldHdvcmssIG1vZHVsZXMuLi4pXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPFdhbGxldFNlbGVjdG9yPn0gUmV0dXJucyBhIFdhbGxldFNlbGVjdG9yIG9iamVjdFxyXG4gKi9cbmNvbnN0IHNldHVwV2FsbGV0U2VsZWN0b3IgPSBwYXJhbXMgPT4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gIGNvbnN0IHtcbiAgICBvcHRpb25zLFxuICAgIHN0b3JhZ2VcbiAgfSA9IHJlc29sdmVPcHRpb25zKHBhcmFtcyk7XG4gIExvZ2dlci5kZWJ1ZyA9IG9wdGlvbnMuZGVidWc7XG4gIGNvbnN0IGVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gIGNvbnN0IHN0b3JlID0geWllbGQgY3JlYXRlU3RvcmUoc3RvcmFnZSk7XG4gIGNvbnN0IHdhbGxldE1vZHVsZXMgPSBuZXcgV2FsbGV0TW9kdWxlcyh7XG4gICAgZmFjdG9yaWVzOiBwYXJhbXMubW9kdWxlcyxcbiAgICBzdG9yYWdlLFxuICAgIG9wdGlvbnMsXG4gICAgc3RvcmUsXG4gICAgZW1pdHRlcixcbiAgICBwcm92aWRlcjogbmV3IFByb3ZpZGVyKG9wdGlvbnMubmV0d29yay5ub2RlVXJsKVxuICB9KTtcbiAgeWllbGQgd2FsbGV0TW9kdWxlcy5zZXR1cCgpO1xuICBpZiAocGFyYW1zLmFsbG93TXVsdGlwbGVTZWxlY3RvcnMpIHtcbiAgICByZXR1cm4gY3JlYXRlU2VsZWN0b3Iob3B0aW9ucywgc3RvcmUsIHdhbGxldE1vZHVsZXMsIGVtaXR0ZXIpO1xuICB9XG4gIGlmICghd2FsbGV0U2VsZWN0b3JJbnN0YW5jZSkge1xuICAgIHdhbGxldFNlbGVjdG9ySW5zdGFuY2UgPSBjcmVhdGVTZWxlY3RvcihvcHRpb25zLCBzdG9yZSwgd2FsbGV0TW9kdWxlcywgZW1pdHRlcik7XG4gIH1cbiAgcmV0dXJuIHdhbGxldFNlbGVjdG9ySW5zdGFuY2U7XG59KTtcblxuY29uc3Qgd2FpdCA9IG1zID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBtcykpO1xufTtcbmNvbnN0IHBvbGwgPSAoY2IsIGludGVydmFsLCByZW1haW5pbmcpID0+IF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICBjb25zdCByZXN1bHQgPSBjYigpO1xuICBpZiAocmVzdWx0KSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAoIXJlbWFpbmluZykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkV4Y2VlZGVkIHRpbWVvdXRcIik7XG4gIH1cbiAgcmV0dXJuIHdhaXQoaW50ZXJ2YWwpLnRoZW4oKCkgPT4gcG9sbChjYiwgaW50ZXJ2YWwsIHJlbWFpbmluZyAtIDEpKTtcbn0pO1xuY29uc3Qgd2FpdEZvciA9IChjYiwgb3B0cyA9IHt9KSA9PiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgY29uc3Qge1xuICAgIHRpbWVvdXQgPSAxMDAsXG4gICAgaW50ZXJ2YWwgPSA1MFxuICB9ID0gb3B0cztcbiAgcmV0dXJuIFByb21pc2UucmFjZShbd2FpdCh0aW1lb3V0KS50aGVuKCgpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeGNlZWRlZCB0aW1lb3V0XCIpO1xuICB9KSwgcG9sbChjYiwgaW50ZXJ2YWwsIE1hdGguZmxvb3IodGltZW91dCAvIGludGVydmFsKSldKTtcbn0pO1xuXG5jb25zdCBnZXRBY3RpdmVBY2NvdW50ID0gc3RhdGUgPT4ge1xuICByZXR1cm4gc3RhdGUuYWNjb3VudHMuZmluZChhY2NvdW50ID0+IGFjY291bnQuYWN0aXZlKSB8fCBudWxsO1xufTtcblxudmFyIGFDYWxsYWJsZSQxID0gYUNhbGxhYmxlJDk7XG52YXIgdG9PYmplY3QkMyA9IHRvT2JqZWN0JDc7XG52YXIgSW5kZXhlZE9iamVjdCQxID0gaW5kZXhlZE9iamVjdDtcbnZhciBsZW5ndGhPZkFycmF5TGlrZSQ1ID0gbGVuZ3RoT2ZBcnJheUxpa2UkODtcblxudmFyICRUeXBlRXJyb3IkMiA9IFR5cGVFcnJvcjtcblxuLy8gYEFycmF5LnByb3RvdHlwZS57IHJlZHVjZSwgcmVkdWNlUmlnaHQgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxudmFyIGNyZWF0ZU1ldGhvZCQyID0gZnVuY3Rpb24gKElTX1JJR0hUKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodGhhdCwgY2FsbGJhY2tmbiwgYXJndW1lbnRzTGVuZ3RoLCBtZW1vKSB7XG4gICAgYUNhbGxhYmxlJDEoY2FsbGJhY2tmbik7XG4gICAgdmFyIE8gPSB0b09iamVjdCQzKHRoYXQpO1xuICAgIHZhciBzZWxmID0gSW5kZXhlZE9iamVjdCQxKE8pO1xuICAgIHZhciBsZW5ndGggPSBsZW5ndGhPZkFycmF5TGlrZSQ1KE8pO1xuICAgIHZhciBpbmRleCA9IElTX1JJR0hUID8gbGVuZ3RoIC0gMSA6IDA7XG4gICAgdmFyIGkgPSBJU19SSUdIVCA/IC0xIDogMTtcbiAgICBpZiAoYXJndW1lbnRzTGVuZ3RoIDwgMikgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChpbmRleCBpbiBzZWxmKSB7XG4gICAgICAgIG1lbW8gPSBzZWxmW2luZGV4XTtcbiAgICAgICAgaW5kZXggKz0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpbmRleCArPSBpO1xuICAgICAgaWYgKElTX1JJR0hUID8gaW5kZXggPCAwIDogbGVuZ3RoIDw9IGluZGV4KSB7XG4gICAgICAgIHRocm93ICRUeXBlRXJyb3IkMignUmVkdWNlIG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKDtJU19SSUdIVCA/IGluZGV4ID49IDAgOiBsZW5ndGggPiBpbmRleDsgaW5kZXggKz0gaSkgaWYgKGluZGV4IGluIHNlbGYpIHtcbiAgICAgIG1lbW8gPSBjYWxsYmFja2ZuKG1lbW8sIHNlbGZbaW5kZXhdLCBpbmRleCwgTyk7XG4gICAgfVxuICAgIHJldHVybiBtZW1vO1xuICB9O1xufTtcblxudmFyIGFycmF5UmVkdWNlID0ge1xuICAvLyBgQXJyYXkucHJvdG90eXBlLnJlZHVjZWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnJlZHVjZVxuICBsZWZ0OiBjcmVhdGVNZXRob2QkMihmYWxzZSksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUucmVkdWNlUmlnaHRgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5yZWR1Y2VyaWdodFxuICByaWdodDogY3JlYXRlTWV0aG9kJDIodHJ1ZSlcbn07XG5cbnZhciBmYWlscyRjID0gZmFpbHMkcztcblxudmFyIGFycmF5TWV0aG9kSXNTdHJpY3QkMSA9IGZ1bmN0aW9uIChNRVRIT0RfTkFNRSwgYXJndW1lbnQpIHtcbiAgdmFyIG1ldGhvZCA9IFtdW01FVEhPRF9OQU1FXTtcbiAgcmV0dXJuICEhbWV0aG9kICYmIGZhaWxzJGMoZnVuY3Rpb24gKCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2VsZXNzLWNhbGwgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgICBtZXRob2QuY2FsbChudWxsLCBhcmd1bWVudCB8fCBmdW5jdGlvbiAoKSB7IHJldHVybiAxOyB9LCAxKTtcbiAgfSk7XG59O1xuXG52YXIgJCQzID0gX2V4cG9ydDtcbnZhciAkcmVkdWNlID0gYXJyYXlSZWR1Y2UubGVmdDtcbnZhciBhcnJheU1ldGhvZElzU3RyaWN0ID0gYXJyYXlNZXRob2RJc1N0cmljdCQxO1xudmFyIENIUk9NRV9WRVJTSU9OID0gZW5naW5lVjhWZXJzaW9uO1xudmFyIElTX05PREUgPSBlbmdpbmVJc05vZGU7XG5cbnZhciBTVFJJQ1RfTUVUSE9EID0gYXJyYXlNZXRob2RJc1N0cmljdCgncmVkdWNlJyk7XG4vLyBDaHJvbWUgODAtODIgaGFzIGEgY3JpdGljYWwgYnVnXG4vLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xMDQ5OTgyXG52YXIgQ0hST01FX0JVRyA9ICFJU19OT0RFICYmIENIUk9NRV9WRVJTSU9OID4gNzkgJiYgQ0hST01FX1ZFUlNJT04gPCA4MztcblxuLy8gYEFycmF5LnByb3RvdHlwZS5yZWR1Y2VgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUucmVkdWNlXG4kJDMoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6ICFTVFJJQ1RfTUVUSE9EIHx8IENIUk9NRV9CVUcgfSwge1xuICByZWR1Y2U6IGZ1bmN0aW9uIHJlZHVjZShjYWxsYmFja2ZuIC8qICwgaW5pdGlhbFZhbHVlICovKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgcmV0dXJuICRyZWR1Y2UodGhpcywgY2FsbGJhY2tmbiwgbGVuZ3RoLCBsZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG5cbnZhciBhbk9iamVjdCQzID0gYW5PYmplY3QkZTtcblxuLy8gYFJlZ0V4cC5wcm90b3R5cGUuZmxhZ3NgIGdldHRlciBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1nZXQtcmVnZXhwLnByb3RvdHlwZS5mbGFnc1xudmFyIHJlZ2V4cEZsYWdzJDEgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0aGF0ID0gYW5PYmplY3QkMyh0aGlzKTtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuICBpZiAodGhhdC5oYXNJbmRpY2VzKSByZXN1bHQgKz0gJ2QnO1xuICBpZiAodGhhdC5nbG9iYWwpIHJlc3VsdCArPSAnZyc7XG4gIGlmICh0aGF0Lmlnbm9yZUNhc2UpIHJlc3VsdCArPSAnaSc7XG4gIGlmICh0aGF0Lm11bHRpbGluZSkgcmVzdWx0ICs9ICdtJztcbiAgaWYgKHRoYXQuZG90QWxsKSByZXN1bHQgKz0gJ3MnO1xuICBpZiAodGhhdC51bmljb2RlKSByZXN1bHQgKz0gJ3UnO1xuICBpZiAodGhhdC51bmljb2RlU2V0cykgcmVzdWx0ICs9ICd2JztcbiAgaWYgKHRoYXQuc3RpY2t5KSByZXN1bHQgKz0gJ3knO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxudmFyIGZhaWxzJGIgPSBmYWlscyRzO1xudmFyIGdsb2JhbCRhID0gZ2xvYmFsJHQ7XG5cbi8vIGJhYmVsLW1pbmlmeSBhbmQgQ2xvc3VyZSBDb21waWxlciB0cmFuc3BpbGVzIFJlZ0V4cCgnYScsICd5JykgLT4gL2EveSBhbmQgaXQgY2F1c2VzIFN5bnRheEVycm9yXG52YXIgJFJlZ0V4cCQyID0gZ2xvYmFsJGEuUmVnRXhwO1xuXG52YXIgVU5TVVBQT1JURURfWSQyID0gZmFpbHMkYihmdW5jdGlvbiAoKSB7XG4gIHZhciByZSA9ICRSZWdFeHAkMignYScsICd5Jyk7XG4gIHJlLmxhc3RJbmRleCA9IDI7XG4gIHJldHVybiByZS5leGVjKCdhYmNkJykgIT0gbnVsbDtcbn0pO1xuXG4vLyBVQyBCcm93c2VyIGJ1Z1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzEwMDhcbnZhciBNSVNTRURfU1RJQ0tZID0gVU5TVVBQT1JURURfWSQyIHx8IGZhaWxzJGIoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gISRSZWdFeHAkMignYScsICd5Jykuc3RpY2t5O1xufSk7XG5cbnZhciBCUk9LRU5fQ0FSRVQgPSBVTlNVUFBPUlRFRF9ZJDIgfHwgZmFpbHMkYihmdW5jdGlvbiAoKSB7XG4gIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTc3MzY4N1xuICB2YXIgcmUgPSAkUmVnRXhwJDIoJ15yJywgJ2d5Jyk7XG4gIHJlLmxhc3RJbmRleCA9IDI7XG4gIHJldHVybiByZS5leGVjKCdzdHInKSAhPSBudWxsO1xufSk7XG5cbnZhciByZWdleHBTdGlja3lIZWxwZXJzID0ge1xuICBCUk9LRU5fQ0FSRVQ6IEJST0tFTl9DQVJFVCxcbiAgTUlTU0VEX1NUSUNLWTogTUlTU0VEX1NUSUNLWSxcbiAgVU5TVVBQT1JURURfWTogVU5TVVBQT1JURURfWSQyXG59O1xuXG52YXIgZmFpbHMkYSA9IGZhaWxzJHM7XG52YXIgZ2xvYmFsJDkgPSBnbG9iYWwkdDtcblxuLy8gYmFiZWwtbWluaWZ5IGFuZCBDbG9zdXJlIENvbXBpbGVyIHRyYW5zcGlsZXMgUmVnRXhwKCcuJywgJ3MnKSAtPiAvLi9zIGFuZCBpdCBjYXVzZXMgU3ludGF4RXJyb3JcbnZhciAkUmVnRXhwJDEgPSBnbG9iYWwkOS5SZWdFeHA7XG5cbnZhciByZWdleHBVbnN1cHBvcnRlZERvdEFsbCA9IGZhaWxzJGEoZnVuY3Rpb24gKCkge1xuICB2YXIgcmUgPSAkUmVnRXhwJDEoJy4nLCAncycpO1xuICByZXR1cm4gIShyZS5kb3RBbGwgJiYgcmUuZXhlYygnXFxuJykgJiYgcmUuZmxhZ3MgPT09ICdzJyk7XG59KTtcblxudmFyIGZhaWxzJDkgPSBmYWlscyRzO1xudmFyIGdsb2JhbCQ4ID0gZ2xvYmFsJHQ7XG5cbi8vIGJhYmVsLW1pbmlmeSBhbmQgQ2xvc3VyZSBDb21waWxlciB0cmFuc3BpbGVzIFJlZ0V4cCgnKD88YT5iKScsICdnJykgLT4gLyg/PGE+YikvZyBhbmQgaXQgY2F1c2VzIFN5bnRheEVycm9yXG52YXIgJFJlZ0V4cCA9IGdsb2JhbCQ4LlJlZ0V4cDtcblxudmFyIHJlZ2V4cFVuc3VwcG9ydGVkTmNnID0gZmFpbHMkOShmdW5jdGlvbiAoKSB7XG4gIHZhciByZSA9ICRSZWdFeHAoJyg/PGE+YiknLCAnZycpO1xuICByZXR1cm4gcmUuZXhlYygnYicpLmdyb3Vwcy5hICE9PSAnYicgfHxcbiAgICAnYicucmVwbGFjZShyZSwgJyQ8YT5jJykgIT09ICdiYyc7XG59KTtcblxuLyogZXNsaW50LWRpc2FibGUgcmVnZXhwL25vLWVtcHR5LWNhcHR1cmluZy1ncm91cCwgcmVnZXhwL25vLWVtcHR5LWdyb3VwLCByZWdleHAvbm8tbGF6eS1lbmRzIC0tIHRlc3RpbmcgKi9cbi8qIGVzbGludC1kaXNhYmxlIHJlZ2V4cC9uby11c2VsZXNzLXF1YW50aWZpZXIgLS0gdGVzdGluZyAqL1xudmFyIGNhbGwkNiA9IGZ1bmN0aW9uQ2FsbDtcbnZhciB1bmN1cnJ5VGhpcyQ4ID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciB0b1N0cmluZyQyID0gdG9TdHJpbmckNTtcbnZhciByZWdleHBGbGFncyA9IHJlZ2V4cEZsYWdzJDE7XG52YXIgc3RpY2t5SGVscGVycyQxID0gcmVnZXhwU3RpY2t5SGVscGVycztcbnZhciBzaGFyZWQgPSBzaGFyZWQkNC5leHBvcnRzO1xudmFyIGNyZWF0ZSQxID0gb2JqZWN0Q3JlYXRlO1xudmFyIGdldEludGVybmFsU3RhdGUkMyA9IGludGVybmFsU3RhdGUuZ2V0O1xudmFyIFVOU1VQUE9SVEVEX0RPVF9BTEwgPSByZWdleHBVbnN1cHBvcnRlZERvdEFsbDtcbnZhciBVTlNVUFBPUlRFRF9OQ0cgPSByZWdleHBVbnN1cHBvcnRlZE5jZztcblxudmFyIG5hdGl2ZVJlcGxhY2UgPSBzaGFyZWQoJ25hdGl2ZS1zdHJpbmctcmVwbGFjZScsIFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSk7XG52YXIgbmF0aXZlRXhlYyA9IFJlZ0V4cC5wcm90b3R5cGUuZXhlYztcbnZhciBwYXRjaGVkRXhlYyA9IG5hdGl2ZUV4ZWM7XG52YXIgY2hhckF0JDIgPSB1bmN1cnJ5VGhpcyQ4KCcnLmNoYXJBdCk7XG52YXIgaW5kZXhPZiA9IHVuY3VycnlUaGlzJDgoJycuaW5kZXhPZik7XG52YXIgcmVwbGFjZSA9IHVuY3VycnlUaGlzJDgoJycucmVwbGFjZSk7XG52YXIgc3RyaW5nU2xpY2UkMiA9IHVuY3VycnlUaGlzJDgoJycuc2xpY2UpO1xuXG52YXIgVVBEQVRFU19MQVNUX0lOREVYX1dST05HID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJlMSA9IC9hLztcbiAgdmFyIHJlMiA9IC9iKi9nO1xuICBjYWxsJDYobmF0aXZlRXhlYywgcmUxLCAnYScpO1xuICBjYWxsJDYobmF0aXZlRXhlYywgcmUyLCAnYScpO1xuICByZXR1cm4gcmUxLmxhc3RJbmRleCAhPT0gMCB8fCByZTIubGFzdEluZGV4ICE9PSAwO1xufSkoKTtcblxudmFyIFVOU1VQUE9SVEVEX1kkMSA9IHN0aWNreUhlbHBlcnMkMS5CUk9LRU5fQ0FSRVQ7XG5cbi8vIG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3VwLCBjb3BpZWQgZnJvbSBlczUtc2hpbSdzIFN0cmluZyNzcGxpdCBwYXRjaC5cbnZhciBOUENHX0lOQ0xVREVEID0gLygpPz8vLmV4ZWMoJycpWzFdICE9PSB1bmRlZmluZWQ7XG5cbnZhciBQQVRDSCA9IFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORyB8fCBOUENHX0lOQ0xVREVEIHx8IFVOU1VQUE9SVEVEX1kkMSB8fCBVTlNVUFBPUlRFRF9ET1RfQUxMIHx8IFVOU1VQUE9SVEVEX05DRztcblxuaWYgKFBBVENIKSB7XG4gIHBhdGNoZWRFeGVjID0gZnVuY3Rpb24gZXhlYyhzdHJpbmcpIHtcbiAgICB2YXIgcmUgPSB0aGlzO1xuICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUkMyhyZSk7XG4gICAgdmFyIHN0ciA9IHRvU3RyaW5nJDIoc3RyaW5nKTtcbiAgICB2YXIgcmF3ID0gc3RhdGUucmF3O1xuICAgIHZhciByZXN1bHQsIHJlQ29weSwgbGFzdEluZGV4LCBtYXRjaCwgaSwgb2JqZWN0LCBncm91cDtcblxuICAgIGlmIChyYXcpIHtcbiAgICAgIHJhdy5sYXN0SW5kZXggPSByZS5sYXN0SW5kZXg7XG4gICAgICByZXN1bHQgPSBjYWxsJDYocGF0Y2hlZEV4ZWMsIHJhdywgc3RyKTtcbiAgICAgIHJlLmxhc3RJbmRleCA9IHJhdy5sYXN0SW5kZXg7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHZhciBncm91cHMgPSBzdGF0ZS5ncm91cHM7XG4gICAgdmFyIHN0aWNreSA9IFVOU1VQUE9SVEVEX1kkMSAmJiByZS5zdGlja3k7XG4gICAgdmFyIGZsYWdzID0gY2FsbCQ2KHJlZ2V4cEZsYWdzLCByZSk7XG4gICAgdmFyIHNvdXJjZSA9IHJlLnNvdXJjZTtcbiAgICB2YXIgY2hhcnNBZGRlZCA9IDA7XG4gICAgdmFyIHN0ckNvcHkgPSBzdHI7XG5cbiAgICBpZiAoc3RpY2t5KSB7XG4gICAgICBmbGFncyA9IHJlcGxhY2UoZmxhZ3MsICd5JywgJycpO1xuICAgICAgaWYgKGluZGV4T2YoZmxhZ3MsICdnJykgPT09IC0xKSB7XG4gICAgICAgIGZsYWdzICs9ICdnJztcbiAgICAgIH1cblxuICAgICAgc3RyQ29weSA9IHN0cmluZ1NsaWNlJDIoc3RyLCByZS5sYXN0SW5kZXgpO1xuICAgICAgLy8gU3VwcG9ydCBhbmNob3JlZCBzdGlja3kgYmVoYXZpb3IuXG4gICAgICBpZiAocmUubGFzdEluZGV4ID4gMCAmJiAoIXJlLm11bHRpbGluZSB8fCByZS5tdWx0aWxpbmUgJiYgY2hhckF0JDIoc3RyLCByZS5sYXN0SW5kZXggLSAxKSAhPT0gJ1xcbicpKSB7XG4gICAgICAgIHNvdXJjZSA9ICcoPzogJyArIHNvdXJjZSArICcpJztcbiAgICAgICAgc3RyQ29weSA9ICcgJyArIHN0ckNvcHk7XG4gICAgICAgIGNoYXJzQWRkZWQrKztcbiAgICAgIH1cbiAgICAgIC8vIF4oPyArIHJ4ICsgKSBpcyBuZWVkZWQsIGluIGNvbWJpbmF0aW9uIHdpdGggc29tZSBzdHIgc2xpY2luZywgdG9cbiAgICAgIC8vIHNpbXVsYXRlIHRoZSAneScgZmxhZy5cbiAgICAgIHJlQ29weSA9IG5ldyBSZWdFeHAoJ14oPzonICsgc291cmNlICsgJyknLCBmbGFncyk7XG4gICAgfVxuXG4gICAgaWYgKE5QQ0dfSU5DTFVERUQpIHtcbiAgICAgIHJlQ29weSA9IG5ldyBSZWdFeHAoJ14nICsgc291cmNlICsgJyQoPyFcXFxccyknLCBmbGFncyk7XG4gICAgfVxuICAgIGlmIChVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcpIGxhc3RJbmRleCA9IHJlLmxhc3RJbmRleDtcblxuICAgIG1hdGNoID0gY2FsbCQ2KG5hdGl2ZUV4ZWMsIHN0aWNreSA/IHJlQ29weSA6IHJlLCBzdHJDb3B5KTtcblxuICAgIGlmIChzdGlja3kpIHtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBtYXRjaC5pbnB1dCA9IHN0cmluZ1NsaWNlJDIobWF0Y2guaW5wdXQsIGNoYXJzQWRkZWQpO1xuICAgICAgICBtYXRjaFswXSA9IHN0cmluZ1NsaWNlJDIobWF0Y2hbMF0sIGNoYXJzQWRkZWQpO1xuICAgICAgICBtYXRjaC5pbmRleCA9IHJlLmxhc3RJbmRleDtcbiAgICAgICAgcmUubGFzdEluZGV4ICs9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgIH0gZWxzZSByZS5sYXN0SW5kZXggPSAwO1xuICAgIH0gZWxzZSBpZiAoVVBEQVRFU19MQVNUX0lOREVYX1dST05HICYmIG1hdGNoKSB7XG4gICAgICByZS5sYXN0SW5kZXggPSByZS5nbG9iYWwgPyBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCA6IGxhc3RJbmRleDtcbiAgICB9XG4gICAgaWYgKE5QQ0dfSU5DTFVERUQgJiYgbWF0Y2ggJiYgbWF0Y2gubGVuZ3RoID4gMSkge1xuICAgICAgLy8gRml4IGJyb3dzZXJzIHdob3NlIGBleGVjYCBtZXRob2RzIGRvbid0IGNvbnNpc3RlbnRseSByZXR1cm4gYHVuZGVmaW5lZGBcbiAgICAgIC8vIGZvciBOUENHLCBsaWtlIElFOC4gTk9URTogVGhpcyBkb2Vzbicgd29yayBmb3IgLyguPyk/L1xuICAgICAgY2FsbCQ2KG5hdGl2ZVJlcGxhY2UsIG1hdGNoWzBdLCByZUNvcHksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGggLSAyOyBpKyspIHtcbiAgICAgICAgICBpZiAoYXJndW1lbnRzW2ldID09PSB1bmRlZmluZWQpIG1hdGNoW2ldID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAobWF0Y2ggJiYgZ3JvdXBzKSB7XG4gICAgICBtYXRjaC5ncm91cHMgPSBvYmplY3QgPSBjcmVhdGUkMShudWxsKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZ3JvdXAgPSBncm91cHNbaV07XG4gICAgICAgIG9iamVjdFtncm91cFswXV0gPSBtYXRjaFtncm91cFsxXV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hdGNoO1xuICB9O1xufVxuXG52YXIgcmVnZXhwRXhlYyQzID0gcGF0Y2hlZEV4ZWM7XG5cbnZhciAkJDIgPSBfZXhwb3J0O1xudmFyIGV4ZWMkMSA9IHJlZ2V4cEV4ZWMkMztcblxuLy8gYFJlZ0V4cC5wcm90b3R5cGUuZXhlY2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXJlZ2V4cC5wcm90b3R5cGUuZXhlY1xuJCQyKHsgdGFyZ2V0OiAnUmVnRXhwJywgcHJvdG86IHRydWUsIGZvcmNlZDogLy4vLmV4ZWMgIT09IGV4ZWMkMSB9LCB7XG4gIGV4ZWM6IGV4ZWMkMVxufSk7XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVzZWxlc3MtZXNjYXBlICovXG4vLyBodHRwczovL2dpdGh1Yi5jb20vRGFtb25PZWhsbWFuL2RldGVjdC1icm93c2VyL2Jsb2IvbWFzdGVyL3NyYy9pbmRleC50c1xuY29uc3QgU0VBUkNIQk9YX1VBX1JFR0VYID0gL2FsZXhhfGJvdHxjcmF3bChlcnxpbmcpfGZhY2Vib29rZXh0ZXJuYWxoaXR8ZmVlZGJ1cm5lcnxnb29nbGUgd2ViIHByZXZpZXd8bmFnaW9zfHBvc3RyYW5rfHBpbmdkb218c2x1cnB8c3BpZGVyfHlhaG9vIXx5YW5kZXgvO1xuY29uc3QgdXNlckFnZW50UnVsZXMgPSBbW1wiYW9sXCIsIC9BT0xTaGllbGRcXC8oWzAtOVxcLl9dKykvXSwgW1wiZWRnZVwiLCAvRWRnZVxcLyhbMC05XFwuX10rKS9dLCBbXCJlZGdlLWlvc1wiLCAvRWRnaU9TXFwvKFswLTlcXC5fXSspL10sIFtcInlhbmRleGJyb3dzZXJcIiwgL1lhQnJvd3NlclxcLyhbMC05XFwuX10rKS9dLCBbXCJrYWthb3RhbGtcIiwgL0tBS0FPVEFMS1xccyhbMC05XFwuXSspL10sIFtcInNhbXN1bmdcIiwgL1NhbXN1bmdCcm93c2VyXFwvKFswLTlcXC5dKykvXSwgW1wic2lsa1wiLCAvXFxiU2lsa1xcLyhbMC05Ll8tXSspXFxiL10sIFtcIm1pdWlcIiwgL01pdWlCcm93c2VyXFwvKFswLTlcXC5dKykkL10sIFtcImJlYWtlclwiLCAvQmVha2VyQnJvd3NlclxcLyhbMC05XFwuXSspL10sIFtcImVkZ2UtY2hyb21pdW1cIiwgL0VkZ0E/XFwvKFswLTlcXC5dKykvXSwgW1wiY2hyb21pdW0td2Vidmlld1wiLCAvKD8hQ2hyb20uKk9QUil3dlxcKS4qQ2hyb20oPzplfGl1bSlcXC8oWzAtOVxcLl0rKSg6P1xcc3wkKS9dLCBbXCJjaHJvbWVcIiwgLyg/IUNocm9tLipPUFIpQ2hyb20oPzplfGl1bSlcXC8oWzAtOVxcLl0rKSg6P1xcc3wkKS9dLCBbXCJwaGFudG9tanNcIiwgL1BoYW50b21KU1xcLyhbMC05XFwuXSspKDo/XFxzfCQpL10sIFtcImNyaW9zXCIsIC9DcmlPU1xcLyhbMC05XFwuXSspKDo/XFxzfCQpL10sIFtcImZpcmVmb3hcIiwgL0ZpcmVmb3hcXC8oWzAtOVxcLl0rKSg/Olxcc3wkKS9dLCBbXCJmeGlvc1wiLCAvRnhpT1NcXC8oWzAtOVxcLl0rKS9dLCBbXCJvcGVyYS1taW5pXCIsIC9PcGVyYSBNaW5pLipWZXJzaW9uXFwvKFswLTlcXC5dKykvXSwgW1wib3BlcmFcIiwgL09wZXJhXFwvKFswLTlcXC5dKykoPzpcXHN8JCkvXSwgW1wib3BlcmFcIiwgL09QUlxcLyhbMC05XFwuXSspKDo/XFxzfCQpL10sIFtcInBpZVwiLCAvXk1pY3Jvc29mdCBQb2NrZXQgSW50ZXJuZXQgRXhwbG9yZXJcXC8oXFxkK1xcLlxcZCspJC9dLCBbXCJwaWVcIiwgL15Nb3ppbGxhXFwvXFxkXFwuXFxkK1xcc1xcKGNvbXBhdGlibGU7XFxzKD86TVNQP0lFfE1TSW50ZXJuZXQgRXhwbG9yZXIpIChcXGQrXFwuXFxkKyk7LipXaW5kb3dzIENFLipcXCkkL10sIFtcIm5ldGZyb250XCIsIC9eTW96aWxsYVxcL1xcZFxcLlxcZCsuKk5ldEZyb250XFwvKFxcZC5cXGQpL10sIFtcImllXCIsIC9UcmlkZW50XFwvN1xcLjAuKnJ2XFw6KFswLTlcXC5dKykuKlxcKS4qR2Vja28kL10sIFtcImllXCIsIC9NU0lFXFxzKFswLTlcXC5dKyk7LipUcmlkZW50XFwvWzQtN10uMC9dLCBbXCJpZVwiLCAvTVNJRVxccyg3XFwuMCkvXSwgW1wiYmIxMFwiLCAvQkIxMDtcXHNUb3VjaC4qVmVyc2lvblxcLyhbMC05XFwuXSspL10sIFtcImFuZHJvaWRcIiwgL0FuZHJvaWRcXHMoWzAtOVxcLl0rKS9dLCBbXCJpb3NcIiwgL1ZlcnNpb25cXC8oWzAtOVxcLl9dKykuKk1vYmlsZS4qU2FmYXJpLiovXSwgW1wic2FmYXJpXCIsIC9WZXJzaW9uXFwvKFswLTlcXC5fXSspLipTYWZhcmkvXSwgW1wiZmFjZWJvb2tcIiwgL0ZCW0FTXVZcXC8oWzAtOVxcLl0rKS9dLCBbXCJpbnN0YWdyYW1cIiwgL0luc3RhZ3JhbVxccyhbMC05XFwuXSspL10sIFtcImlvcy13ZWJ2aWV3XCIsIC9BcHBsZVdlYktpdFxcLyhbMC05XFwuXSspLipNb2JpbGUvXSwgW1wiaW9zLXdlYnZpZXdcIiwgL0FwcGxlV2ViS2l0XFwvKFswLTlcXC5dKykuKkdlY2tvXFwpJC9dLCBbXCJjdXJsXCIsIC9eY3VybFxcLyhbMC05XFwuXSspJC9dLCBbXCJzZWFyY2hib3RcIiwgU0VBUkNIQk9YX1VBX1JFR0VYXV07XG5jb25zdCBtYXRjaFVzZXJBZ2VudCA9IHVhID0+IHtcbiAgcmV0dXJuIHVhICE9PSBcIlwiICYmIHVzZXJBZ2VudFJ1bGVzLnJlZHVjZSgobWF0Y2hlZCwgW2Jyb3dzZXIsIHJlZ2V4XSkgPT4ge1xuICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICByZXR1cm4gbWF0Y2hlZDtcbiAgICB9XG4gICAgY29uc3QgdWFNYXRjaCA9IHJlZ2V4LmV4ZWModWEpO1xuICAgIHJldHVybiAhIXVhTWF0Y2ggJiYgW2Jyb3dzZXIsIHVhTWF0Y2hdO1xuICB9LCBmYWxzZSk7XG59O1xuY29uc3QgaXNDdXJyZW50QnJvd3NlclN1cHBvcnRlZCA9IHN1cHBvcnRlZEJyb3dzZXIgPT4ge1xuICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBtYXRjaGVkUnVsZSA9IG1hdGNoVXNlckFnZW50KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICBpZiAoIW1hdGNoZWRSdWxlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IFtuYW1lXSA9IG1hdGNoZWRSdWxlO1xuICBpZiAobmFtZSA9PT0gXCJzZWFyY2hib3RcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gISFzdXBwb3J0ZWRCcm93c2VyLmZpbmQoaXRlbSA9PiBpdGVtID09PSBuYW1lKTtcbn07XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLXR5cGVkLWFycmF5cyAtLSBzYWZlXG52YXIgYXJyYXlCdWZmZXJOYXRpdmUgPSB0eXBlb2YgQXJyYXlCdWZmZXIgIT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIERhdGFWaWV3ICE9ICd1bmRlZmluZWQnO1xuXG52YXIgTkFUSVZFX0FSUkFZX0JVRkZFUiQxID0gYXJyYXlCdWZmZXJOYXRpdmU7XG52YXIgREVTQ1JJUFRPUlMkMiA9IGRlc2NyaXB0b3JzO1xudmFyIGdsb2JhbCQ3ID0gZ2xvYmFsJHQ7XG52YXIgaXNDYWxsYWJsZSQyID0gaXNDYWxsYWJsZSRuO1xudmFyIGlzT2JqZWN0JDQgPSBpc09iamVjdCRkO1xudmFyIGhhc093biQxID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBjbGFzc29mJDQgPSBjbGFzc29mJDk7XG52YXIgdHJ5VG9TdHJpbmcgPSB0cnlUb1N0cmluZyQ1O1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQzID0gY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDg7XG52YXIgZGVmaW5lQnVpbHRJbiQyID0gZGVmaW5lQnVpbHRJbiQ4O1xudmFyIGRlZmluZVByb3BlcnR5JDEgPSBvYmplY3REZWZpbmVQcm9wZXJ0eS5mO1xudmFyIGlzUHJvdG90eXBlT2YkMSA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG52YXIgZ2V0UHJvdG90eXBlT2YkMSA9IG9iamVjdEdldFByb3RvdHlwZU9mO1xudmFyIHNldFByb3RvdHlwZU9mJDMgPSBvYmplY3RTZXRQcm90b3R5cGVPZjtcbnZhciB3ZWxsS25vd25TeW1ib2wkMiA9IHdlbGxLbm93blN5bWJvbCRqO1xudmFyIHVpZCA9IHVpZCQzO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUkMiA9IGludGVybmFsU3RhdGU7XG5cbnZhciBlbmZvcmNlSW50ZXJuYWxTdGF0ZSQxID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQyLmVuZm9yY2U7XG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSQyID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQyLmdldDtcbnZhciBJbnQ4QXJyYXkkNCA9IGdsb2JhbCQ3LkludDhBcnJheTtcbnZhciBJbnQ4QXJyYXlQcm90b3R5cGUkMSA9IEludDhBcnJheSQ0ICYmIEludDhBcnJheSQ0LnByb3RvdHlwZTtcbnZhciBVaW50OENsYW1wZWRBcnJheSQxID0gZ2xvYmFsJDcuVWludDhDbGFtcGVkQXJyYXk7XG52YXIgVWludDhDbGFtcGVkQXJyYXlQcm90b3R5cGUgPSBVaW50OENsYW1wZWRBcnJheSQxICYmIFVpbnQ4Q2xhbXBlZEFycmF5JDEucHJvdG90eXBlO1xudmFyIFR5cGVkQXJyYXkkMSA9IEludDhBcnJheSQ0ICYmIGdldFByb3RvdHlwZU9mJDEoSW50OEFycmF5JDQpO1xudmFyIFR5cGVkQXJyYXlQcm90b3R5cGUkMSA9IEludDhBcnJheVByb3RvdHlwZSQxICYmIGdldFByb3RvdHlwZU9mJDEoSW50OEFycmF5UHJvdG90eXBlJDEpO1xudmFyIE9iamVjdFByb3RvdHlwZSQxID0gT2JqZWN0LnByb3RvdHlwZTtcbnZhciBUeXBlRXJyb3IkMSA9IGdsb2JhbCQ3LlR5cGVFcnJvcjtcblxudmFyIFRPX1NUUklOR19UQUcgPSB3ZWxsS25vd25TeW1ib2wkMigndG9TdHJpbmdUYWcnKTtcbnZhciBUWVBFRF9BUlJBWV9UQUckMSA9IHVpZCgnVFlQRURfQVJSQVlfVEFHJyk7XG52YXIgVFlQRURfQVJSQVlfQ09OU1RSVUNUT1IgPSAnVHlwZWRBcnJheUNvbnN0cnVjdG9yJztcbi8vIEZpeGluZyBuYXRpdmUgdHlwZWQgYXJyYXlzIGluIE9wZXJhIFByZXN0byBjcmFzaGVzIHRoZSBicm93c2VyLCBzZWUgIzU5NVxudmFyIE5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MkMiA9IE5BVElWRV9BUlJBWV9CVUZGRVIkMSAmJiAhIXNldFByb3RvdHlwZU9mJDMgJiYgY2xhc3NvZiQ0KGdsb2JhbCQ3Lm9wZXJhKSAhPT0gJ09wZXJhJztcbnZhciBUWVBFRF9BUlJBWV9UQUdfUkVRVUlSRUQgPSBmYWxzZTtcbnZhciBOQU1FLCBDb25zdHJ1Y3RvciwgUHJvdG90eXBlO1xuXG52YXIgVHlwZWRBcnJheUNvbnN0cnVjdG9yc0xpc3QgPSB7XG4gIEludDhBcnJheTogMSxcbiAgVWludDhBcnJheTogMSxcbiAgVWludDhDbGFtcGVkQXJyYXk6IDEsXG4gIEludDE2QXJyYXk6IDIsXG4gIFVpbnQxNkFycmF5OiAyLFxuICBJbnQzMkFycmF5OiA0LFxuICBVaW50MzJBcnJheTogNCxcbiAgRmxvYXQzMkFycmF5OiA0LFxuICBGbG9hdDY0QXJyYXk6IDhcbn07XG5cbnZhciBCaWdJbnRBcnJheUNvbnN0cnVjdG9yc0xpc3QgPSB7XG4gIEJpZ0ludDY0QXJyYXk6IDgsXG4gIEJpZ1VpbnQ2NEFycmF5OiA4XG59O1xuXG52YXIgaXNWaWV3ID0gZnVuY3Rpb24gaXNWaWV3KGl0KSB7XG4gIGlmICghaXNPYmplY3QkNChpdCkpIHJldHVybiBmYWxzZTtcbiAgdmFyIGtsYXNzID0gY2xhc3NvZiQ0KGl0KTtcbiAgcmV0dXJuIGtsYXNzID09PSAnRGF0YVZpZXcnXG4gICAgfHwgaGFzT3duJDEoVHlwZWRBcnJheUNvbnN0cnVjdG9yc0xpc3QsIGtsYXNzKVxuICAgIHx8IGhhc093biQxKEJpZ0ludEFycmF5Q29uc3RydWN0b3JzTGlzdCwga2xhc3MpO1xufTtcblxudmFyIGdldFR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGVPZiQxKGl0KTtcbiAgaWYgKCFpc09iamVjdCQ0KHByb3RvKSkgcmV0dXJuO1xuICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlJDIocHJvdG8pO1xuICByZXR1cm4gKHN0YXRlICYmIGhhc093biQxKHN0YXRlLCBUWVBFRF9BUlJBWV9DT05TVFJVQ1RPUikpID8gc3RhdGVbVFlQRURfQVJSQVlfQ09OU1RSVUNUT1JdIDogZ2V0VHlwZWRBcnJheUNvbnN0cnVjdG9yKHByb3RvKTtcbn07XG5cbnZhciBpc1R5cGVkQXJyYXkkMSA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoIWlzT2JqZWN0JDQoaXQpKSByZXR1cm4gZmFsc2U7XG4gIHZhciBrbGFzcyA9IGNsYXNzb2YkNChpdCk7XG4gIHJldHVybiBoYXNPd24kMShUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCwga2xhc3MpXG4gICAgfHwgaGFzT3duJDEoQmlnSW50QXJyYXlDb25zdHJ1Y3RvcnNMaXN0LCBrbGFzcyk7XG59O1xuXG52YXIgYVR5cGVkQXJyYXkkNCA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXNUeXBlZEFycmF5JDEoaXQpKSByZXR1cm4gaXQ7XG4gIHRocm93IFR5cGVFcnJvciQxKCdUYXJnZXQgaXMgbm90IGEgdHlwZWQgYXJyYXknKTtcbn07XG5cbnZhciBhVHlwZWRBcnJheUNvbnN0cnVjdG9yJDIgPSBmdW5jdGlvbiAoQykge1xuICBpZiAoaXNDYWxsYWJsZSQyKEMpICYmICghc2V0UHJvdG90eXBlT2YkMyB8fCBpc1Byb3RvdHlwZU9mJDEoVHlwZWRBcnJheSQxLCBDKSkpIHJldHVybiBDO1xuICB0aHJvdyBUeXBlRXJyb3IkMSh0cnlUb1N0cmluZyhDKSArICcgaXMgbm90IGEgdHlwZWQgYXJyYXkgY29uc3RydWN0b3InKTtcbn07XG5cbnZhciBleHBvcnRUeXBlZEFycmF5TWV0aG9kJDQgPSBmdW5jdGlvbiAoS0VZLCBwcm9wZXJ0eSwgZm9yY2VkLCBvcHRpb25zKSB7XG4gIGlmICghREVTQ1JJUFRPUlMkMikgcmV0dXJuO1xuICBpZiAoZm9yY2VkKSBmb3IgKHZhciBBUlJBWSBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCkge1xuICAgIHZhciBUeXBlZEFycmF5Q29uc3RydWN0b3IgPSBnbG9iYWwkN1tBUlJBWV07XG4gICAgaWYgKFR5cGVkQXJyYXlDb25zdHJ1Y3RvciAmJiBoYXNPd24kMShUeXBlZEFycmF5Q29uc3RydWN0b3IucHJvdG90eXBlLCBLRVkpKSB0cnkge1xuICAgICAgZGVsZXRlIFR5cGVkQXJyYXlDb25zdHJ1Y3Rvci5wcm90b3R5cGVbS0VZXTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gb2xkIFdlYktpdCBidWcgLSBzb21lIG1ldGhvZHMgYXJlIG5vbi1jb25maWd1cmFibGVcbiAgICAgIHRyeSB7XG4gICAgICAgIFR5cGVkQXJyYXlDb25zdHJ1Y3Rvci5wcm90b3R5cGVbS0VZXSA9IHByb3BlcnR5O1xuICAgICAgfSBjYXRjaCAoZXJyb3IyKSB7IC8qIGVtcHR5ICovIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFUeXBlZEFycmF5UHJvdG90eXBlJDFbS0VZXSB8fCBmb3JjZWQpIHtcbiAgICBkZWZpbmVCdWlsdEluJDIoVHlwZWRBcnJheVByb3RvdHlwZSQxLCBLRVksIGZvcmNlZCA/IHByb3BlcnR5XG4gICAgICA6IE5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MkMiAmJiBJbnQ4QXJyYXlQcm90b3R5cGUkMVtLRVldIHx8IHByb3BlcnR5LCBvcHRpb25zKTtcbiAgfVxufTtcblxudmFyIGV4cG9ydFR5cGVkQXJyYXlTdGF0aWNNZXRob2QkMSA9IGZ1bmN0aW9uIChLRVksIHByb3BlcnR5LCBmb3JjZWQpIHtcbiAgdmFyIEFSUkFZLCBUeXBlZEFycmF5Q29uc3RydWN0b3I7XG4gIGlmICghREVTQ1JJUFRPUlMkMikgcmV0dXJuO1xuICBpZiAoc2V0UHJvdG90eXBlT2YkMykge1xuICAgIGlmIChmb3JjZWQpIGZvciAoQVJSQVkgaW4gVHlwZWRBcnJheUNvbnN0cnVjdG9yc0xpc3QpIHtcbiAgICAgIFR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IGdsb2JhbCQ3W0FSUkFZXTtcbiAgICAgIGlmIChUeXBlZEFycmF5Q29uc3RydWN0b3IgJiYgaGFzT3duJDEoVHlwZWRBcnJheUNvbnN0cnVjdG9yLCBLRVkpKSB0cnkge1xuICAgICAgICBkZWxldGUgVHlwZWRBcnJheUNvbnN0cnVjdG9yW0tFWV07XG4gICAgICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gICAgfVxuICAgIGlmICghVHlwZWRBcnJheSQxW0tFWV0gfHwgZm9yY2VkKSB7XG4gICAgICAvLyBWOCB+IENocm9tZSA0OS01MCBgJVR5cGVkQXJyYXklYCBtZXRob2RzIGFyZSBub24td3JpdGFibGUgbm9uLWNvbmZpZ3VyYWJsZVxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGRlZmluZUJ1aWx0SW4kMihUeXBlZEFycmF5JDEsIEtFWSwgZm9yY2VkID8gcHJvcGVydHkgOiBOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTJDIgJiYgVHlwZWRBcnJheSQxW0tFWV0gfHwgcHJvcGVydHkpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICAgIH0gZWxzZSByZXR1cm47XG4gIH1cbiAgZm9yIChBUlJBWSBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCkge1xuICAgIFR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IGdsb2JhbCQ3W0FSUkFZXTtcbiAgICBpZiAoVHlwZWRBcnJheUNvbnN0cnVjdG9yICYmICghVHlwZWRBcnJheUNvbnN0cnVjdG9yW0tFWV0gfHwgZm9yY2VkKSkge1xuICAgICAgZGVmaW5lQnVpbHRJbiQyKFR5cGVkQXJyYXlDb25zdHJ1Y3RvciwgS0VZLCBwcm9wZXJ0eSk7XG4gICAgfVxuICB9XG59O1xuXG5mb3IgKE5BTUUgaW4gVHlwZWRBcnJheUNvbnN0cnVjdG9yc0xpc3QpIHtcbiAgQ29uc3RydWN0b3IgPSBnbG9iYWwkN1tOQU1FXTtcbiAgUHJvdG90eXBlID0gQ29uc3RydWN0b3IgJiYgQ29uc3RydWN0b3IucHJvdG90eXBlO1xuICBpZiAoUHJvdG90eXBlKSBlbmZvcmNlSW50ZXJuYWxTdGF0ZSQxKFByb3RvdHlwZSlbVFlQRURfQVJSQVlfQ09OU1RSVUNUT1JdID0gQ29uc3RydWN0b3I7XG4gIGVsc2UgTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyQyID0gZmFsc2U7XG59XG5cbmZvciAoTkFNRSBpbiBCaWdJbnRBcnJheUNvbnN0cnVjdG9yc0xpc3QpIHtcbiAgQ29uc3RydWN0b3IgPSBnbG9iYWwkN1tOQU1FXTtcbiAgUHJvdG90eXBlID0gQ29uc3RydWN0b3IgJiYgQ29uc3RydWN0b3IucHJvdG90eXBlO1xuICBpZiAoUHJvdG90eXBlKSBlbmZvcmNlSW50ZXJuYWxTdGF0ZSQxKFByb3RvdHlwZSlbVFlQRURfQVJSQVlfQ09OU1RSVUNUT1JdID0gQ29uc3RydWN0b3I7XG59XG5cbi8vIFdlYktpdCBidWcgLSB0eXBlZCBhcnJheXMgY29uc3RydWN0b3JzIHByb3RvdHlwZSBpcyBPYmplY3QucHJvdG90eXBlXG5pZiAoIU5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MkMiB8fCAhaXNDYWxsYWJsZSQyKFR5cGVkQXJyYXkkMSkgfHwgVHlwZWRBcnJheSQxID09PSBGdW5jdGlvbi5wcm90b3R5cGUpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNoYWRvdyAtLSBzYWZlXG4gIFR5cGVkQXJyYXkkMSA9IGZ1bmN0aW9uIFR5cGVkQXJyYXkoKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yJDEoJ0luY29ycmVjdCBpbnZvY2F0aW9uJyk7XG4gIH07XG4gIGlmIChOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTJDIpIGZvciAoTkFNRSBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCkge1xuICAgIGlmIChnbG9iYWwkN1tOQU1FXSkgc2V0UHJvdG90eXBlT2YkMyhnbG9iYWwkN1tOQU1FXSwgVHlwZWRBcnJheSQxKTtcbiAgfVxufVxuXG5pZiAoIU5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MkMiB8fCAhVHlwZWRBcnJheVByb3RvdHlwZSQxIHx8IFR5cGVkQXJyYXlQcm90b3R5cGUkMSA9PT0gT2JqZWN0UHJvdG90eXBlJDEpIHtcbiAgVHlwZWRBcnJheVByb3RvdHlwZSQxID0gVHlwZWRBcnJheSQxLnByb3RvdHlwZTtcbiAgaWYgKE5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MkMikgZm9yIChOQU1FIGluIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0KSB7XG4gICAgaWYgKGdsb2JhbCQ3W05BTUVdKSBzZXRQcm90b3R5cGVPZiQzKGdsb2JhbCQ3W05BTUVdLnByb3RvdHlwZSwgVHlwZWRBcnJheVByb3RvdHlwZSQxKTtcbiAgfVxufVxuXG4vLyBXZWJLaXQgYnVnIC0gb25lIG1vcmUgb2JqZWN0IGluIFVpbnQ4Q2xhbXBlZEFycmF5IHByb3RvdHlwZSBjaGFpblxuaWYgKE5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MkMiAmJiBnZXRQcm90b3R5cGVPZiQxKFVpbnQ4Q2xhbXBlZEFycmF5UHJvdG90eXBlKSAhPT0gVHlwZWRBcnJheVByb3RvdHlwZSQxKSB7XG4gIHNldFByb3RvdHlwZU9mJDMoVWludDhDbGFtcGVkQXJyYXlQcm90b3R5cGUsIFR5cGVkQXJyYXlQcm90b3R5cGUkMSk7XG59XG5cbmlmIChERVNDUklQVE9SUyQyICYmICFoYXNPd24kMShUeXBlZEFycmF5UHJvdG90eXBlJDEsIFRPX1NUUklOR19UQUcpKSB7XG4gIFRZUEVEX0FSUkFZX1RBR19SRVFVSVJFRCA9IHRydWU7XG4gIGRlZmluZVByb3BlcnR5JDEoVHlwZWRBcnJheVByb3RvdHlwZSQxLCBUT19TVFJJTkdfVEFHLCB7IGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBpc09iamVjdCQ0KHRoaXMpID8gdGhpc1tUWVBFRF9BUlJBWV9UQUckMV0gOiB1bmRlZmluZWQ7XG4gIH0gfSk7XG4gIGZvciAoTkFNRSBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCkgaWYgKGdsb2JhbCQ3W05BTUVdKSB7XG4gICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDMoZ2xvYmFsJDdbTkFNRV0sIFRZUEVEX0FSUkFZX1RBRyQxLCBOQU1FKTtcbiAgfVxufVxuXG52YXIgYXJyYXlCdWZmZXJWaWV3Q29yZSA9IHtcbiAgTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUzogTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyQyLFxuICBUWVBFRF9BUlJBWV9UQUc6IFRZUEVEX0FSUkFZX1RBR19SRVFVSVJFRCAmJiBUWVBFRF9BUlJBWV9UQUckMSxcbiAgYVR5cGVkQXJyYXk6IGFUeXBlZEFycmF5JDQsXG4gIGFUeXBlZEFycmF5Q29uc3RydWN0b3I6IGFUeXBlZEFycmF5Q29uc3RydWN0b3IkMixcbiAgZXhwb3J0VHlwZWRBcnJheU1ldGhvZDogZXhwb3J0VHlwZWRBcnJheU1ldGhvZCQ0LFxuICBleHBvcnRUeXBlZEFycmF5U3RhdGljTWV0aG9kOiBleHBvcnRUeXBlZEFycmF5U3RhdGljTWV0aG9kJDEsXG4gIGdldFR5cGVkQXJyYXlDb25zdHJ1Y3RvcjogZ2V0VHlwZWRBcnJheUNvbnN0cnVjdG9yLFxuICBpc1ZpZXc6IGlzVmlldyxcbiAgaXNUeXBlZEFycmF5OiBpc1R5cGVkQXJyYXkkMSxcbiAgVHlwZWRBcnJheTogVHlwZWRBcnJheSQxLFxuICBUeXBlZEFycmF5UHJvdG90eXBlOiBUeXBlZEFycmF5UHJvdG90eXBlJDFcbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLW5ldyAtLSByZXF1aXJlZCBmb3IgdGVzdGluZyAqL1xuXG52YXIgZ2xvYmFsJDYgPSBnbG9iYWwkdDtcbnZhciBmYWlscyQ4ID0gZmFpbHMkcztcbnZhciBjaGVja0NvcnJlY3RuZXNzT2ZJdGVyYXRpb24gPSBjaGVja0NvcnJlY3RuZXNzT2ZJdGVyYXRpb24kMjtcbnZhciBOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTJDEgPSBhcnJheUJ1ZmZlclZpZXdDb3JlLk5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1M7XG5cbnZhciBBcnJheUJ1ZmZlciQzID0gZ2xvYmFsJDYuQXJyYXlCdWZmZXI7XG52YXIgSW50OEFycmF5JDMgPSBnbG9iYWwkNi5JbnQ4QXJyYXk7XG5cbnZhciB0eXBlZEFycmF5Q29uc3RydWN0b3JzUmVxdWlyZVdyYXBwZXJzID0gIU5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MkMSB8fCAhZmFpbHMkOChmdW5jdGlvbiAoKSB7XG4gIEludDhBcnJheSQzKDEpO1xufSkgfHwgIWZhaWxzJDgoZnVuY3Rpb24gKCkge1xuICBuZXcgSW50OEFycmF5JDMoLTEpO1xufSkgfHwgIWNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbihmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiAgbmV3IEludDhBcnJheSQzKCk7XG4gIG5ldyBJbnQ4QXJyYXkkMyhudWxsKTtcbiAgbmV3IEludDhBcnJheSQzKDEuNSk7XG4gIG5ldyBJbnQ4QXJyYXkkMyhpdGVyYWJsZSk7XG59LCB0cnVlKSB8fCBmYWlscyQ4KGZ1bmN0aW9uICgpIHtcbiAgLy8gU2FmYXJpICgxMSspIGJ1ZyAtIGEgcmVhc29uIHdoeSBldmVuIFNhZmFyaSAxMyBzaG91bGQgbG9hZCBhIHR5cGVkIGFycmF5IHBvbHlmaWxsXG4gIHJldHVybiBuZXcgSW50OEFycmF5JDMobmV3IEFycmF5QnVmZmVyJDMoMiksIDEsIHVuZGVmaW5lZCkubGVuZ3RoICE9PSAxO1xufSk7XG5cbnZhciBiaW5kJDEgPSBmdW5jdGlvbkJpbmRDb250ZXh0O1xudmFyIGNhbGwkNSA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBhQ29uc3RydWN0b3IgPSBhQ29uc3RydWN0b3IkMjtcbnZhciB0b09iamVjdCQyID0gdG9PYmplY3QkNztcbnZhciBsZW5ndGhPZkFycmF5TGlrZSQ0ID0gbGVuZ3RoT2ZBcnJheUxpa2UkODtcbnZhciBnZXRJdGVyYXRvciA9IGdldEl0ZXJhdG9yJDI7XG52YXIgZ2V0SXRlcmF0b3JNZXRob2QgPSBnZXRJdGVyYXRvck1ldGhvZCQzO1xudmFyIGlzQXJyYXlJdGVyYXRvck1ldGhvZCA9IGlzQXJyYXlJdGVyYXRvck1ldGhvZCQyO1xudmFyIGFUeXBlZEFycmF5Q29uc3RydWN0b3IkMSA9IGFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXlDb25zdHJ1Y3RvcjtcblxudmFyIHR5cGVkQXJyYXlGcm9tJDIgPSBmdW5jdGlvbiBmcm9tKHNvdXJjZSAvKiAsIG1hcGZuLCB0aGlzQXJnICovKSB7XG4gIHZhciBDID0gYUNvbnN0cnVjdG9yKHRoaXMpO1xuICB2YXIgTyA9IHRvT2JqZWN0JDIoc291cmNlKTtcbiAgdmFyIGFyZ3VtZW50c0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBtYXBmbiA9IGFyZ3VtZW50c0xlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gIHZhciBtYXBwaW5nID0gbWFwZm4gIT09IHVuZGVmaW5lZDtcbiAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gZ2V0SXRlcmF0b3JNZXRob2QoTyk7XG4gIHZhciBpLCBsZW5ndGgsIHJlc3VsdCwgc3RlcCwgaXRlcmF0b3IsIG5leHQ7XG4gIGlmIChpdGVyYXRvck1ldGhvZCAmJiAhaXNBcnJheUl0ZXJhdG9yTWV0aG9kKGl0ZXJhdG9yTWV0aG9kKSkge1xuICAgIGl0ZXJhdG9yID0gZ2V0SXRlcmF0b3IoTywgaXRlcmF0b3JNZXRob2QpO1xuICAgIG5leHQgPSBpdGVyYXRvci5uZXh0O1xuICAgIE8gPSBbXTtcbiAgICB3aGlsZSAoIShzdGVwID0gY2FsbCQ1KG5leHQsIGl0ZXJhdG9yKSkuZG9uZSkge1xuICAgICAgTy5wdXNoKHN0ZXAudmFsdWUpO1xuICAgIH1cbiAgfVxuICBpZiAobWFwcGluZyAmJiBhcmd1bWVudHNMZW5ndGggPiAyKSB7XG4gICAgbWFwZm4gPSBiaW5kJDEobWFwZm4sIGFyZ3VtZW50c1syXSk7XG4gIH1cbiAgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UkNChPKTtcbiAgcmVzdWx0ID0gbmV3IChhVHlwZWRBcnJheUNvbnN0cnVjdG9yJDEoQykpKGxlbmd0aCk7XG4gIGZvciAoaSA9IDA7IGxlbmd0aCA+IGk7IGkrKykge1xuICAgIHJlc3VsdFtpXSA9IG1hcHBpbmcgPyBtYXBmbihPW2ldLCBpKSA6IE9baV07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciBUWVBFRF9BUlJBWVNfQ09OU1RSVUNUT1JTX1JFUVVJUkVTX1dSQVBQRVJTJDEgPSB0eXBlZEFycmF5Q29uc3RydWN0b3JzUmVxdWlyZVdyYXBwZXJzO1xudmFyIGV4cG9ydFR5cGVkQXJyYXlTdGF0aWNNZXRob2QgPSBhcnJheUJ1ZmZlclZpZXdDb3JlLmV4cG9ydFR5cGVkQXJyYXlTdGF0aWNNZXRob2Q7XG52YXIgdHlwZWRBcnJheUZyb20kMSA9IHR5cGVkQXJyYXlGcm9tJDI7XG5cbi8vIGAlVHlwZWRBcnJheSUuZnJvbWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSV0eXBlZGFycmF5JS5mcm9tXG5leHBvcnRUeXBlZEFycmF5U3RhdGljTWV0aG9kKCdmcm9tJywgdHlwZWRBcnJheUZyb20kMSwgVFlQRURfQVJSQVlTX0NPTlNUUlVDVE9SU19SRVFVSVJFU19XUkFQUEVSUyQxKTtcblxudmFyIGRlZmluZUJ1aWx0SW4kMSA9IGRlZmluZUJ1aWx0SW4kODtcblxudmFyIGRlZmluZUJ1aWx0SW5zJDEgPSBmdW5jdGlvbiAodGFyZ2V0LCBzcmMsIG9wdGlvbnMpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykgZGVmaW5lQnVpbHRJbiQxKHRhcmdldCwga2V5LCBzcmNba2V5XSwgb3B0aW9ucyk7XG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSQzID0gdG9JbnRlZ2VyT3JJbmZpbml0eSQ2O1xudmFyIHRvTGVuZ3RoJDQgPSB0b0xlbmd0aCQ2O1xuXG52YXIgJFJhbmdlRXJyb3IkMiA9IFJhbmdlRXJyb3I7XG5cbi8vIGBUb0luZGV4YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9pbmRleFxudmFyIHRvSW5kZXgkMiA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIDA7XG4gIHZhciBudW1iZXIgPSB0b0ludGVnZXJPckluZmluaXR5JDMoaXQpO1xuICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgkNChudW1iZXIpO1xuICBpZiAobnVtYmVyICE9PSBsZW5ndGgpIHRocm93ICRSYW5nZUVycm9yJDIoJ1dyb25nIGxlbmd0aCBvciBpbmRleCcpO1xuICByZXR1cm4gbGVuZ3RoO1xufTtcblxuLy8gSUVFRTc1NCBjb252ZXJzaW9ucyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2llZWU3NTRcbnZhciAkQXJyYXkkMiA9IEFycmF5O1xudmFyIGFicyA9IE1hdGguYWJzO1xudmFyIHBvdyA9IE1hdGgucG93O1xudmFyIGZsb29yJDIgPSBNYXRoLmZsb29yO1xudmFyIGxvZyA9IE1hdGgubG9nO1xudmFyIExOMiA9IE1hdGguTE4yO1xuXG52YXIgcGFjayA9IGZ1bmN0aW9uIChudW1iZXIsIG1hbnRpc3NhTGVuZ3RoLCBieXRlcykge1xuICB2YXIgYnVmZmVyID0gJEFycmF5JDIoYnl0ZXMpO1xuICB2YXIgZXhwb25lbnRMZW5ndGggPSBieXRlcyAqIDggLSBtYW50aXNzYUxlbmd0aCAtIDE7XG4gIHZhciBlTWF4ID0gKDEgPDwgZXhwb25lbnRMZW5ndGgpIC0gMTtcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxO1xuICB2YXIgcnQgPSBtYW50aXNzYUxlbmd0aCA9PT0gMjMgPyBwb3coMiwgLTI0KSAtIHBvdygyLCAtNzcpIDogMDtcbiAgdmFyIHNpZ24gPSBudW1iZXIgPCAwIHx8IG51bWJlciA9PT0gMCAmJiAxIC8gbnVtYmVyIDwgMCA/IDEgOiAwO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgZXhwb25lbnQsIG1hbnRpc3NhLCBjO1xuICBudW1iZXIgPSBhYnMobnVtYmVyKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcbiAgaWYgKG51bWJlciAhPSBudW1iZXIgfHwgbnVtYmVyID09PSBJbmZpbml0eSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG4gICAgbWFudGlzc2EgPSBudW1iZXIgIT0gbnVtYmVyID8gMSA6IDA7XG4gICAgZXhwb25lbnQgPSBlTWF4O1xuICB9IGVsc2Uge1xuICAgIGV4cG9uZW50ID0gZmxvb3IkMihsb2cobnVtYmVyKSAvIExOMik7XG4gICAgYyA9IHBvdygyLCAtZXhwb25lbnQpO1xuICAgIGlmIChudW1iZXIgKiBjIDwgMSkge1xuICAgICAgZXhwb25lbnQtLTtcbiAgICAgIGMgKj0gMjtcbiAgICB9XG4gICAgaWYgKGV4cG9uZW50ICsgZUJpYXMgPj0gMSkge1xuICAgICAgbnVtYmVyICs9IHJ0IC8gYztcbiAgICB9IGVsc2Uge1xuICAgICAgbnVtYmVyICs9IHJ0ICogcG93KDIsIDEgLSBlQmlhcyk7XG4gICAgfVxuICAgIGlmIChudW1iZXIgKiBjID49IDIpIHtcbiAgICAgIGV4cG9uZW50Kys7XG4gICAgICBjIC89IDI7XG4gICAgfVxuICAgIGlmIChleHBvbmVudCArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG1hbnRpc3NhID0gMDtcbiAgICAgIGV4cG9uZW50ID0gZU1heDtcbiAgICB9IGVsc2UgaWYgKGV4cG9uZW50ICsgZUJpYXMgPj0gMSkge1xuICAgICAgbWFudGlzc2EgPSAobnVtYmVyICogYyAtIDEpICogcG93KDIsIG1hbnRpc3NhTGVuZ3RoKTtcbiAgICAgIGV4cG9uZW50ID0gZXhwb25lbnQgKyBlQmlhcztcbiAgICB9IGVsc2Uge1xuICAgICAgbWFudGlzc2EgPSBudW1iZXIgKiBwb3coMiwgZUJpYXMgLSAxKSAqIHBvdygyLCBtYW50aXNzYUxlbmd0aCk7XG4gICAgICBleHBvbmVudCA9IDA7XG4gICAgfVxuICB9XG4gIHdoaWxlIChtYW50aXNzYUxlbmd0aCA+PSA4KSB7XG4gICAgYnVmZmVyW2luZGV4KytdID0gbWFudGlzc2EgJiAyNTU7XG4gICAgbWFudGlzc2EgLz0gMjU2O1xuICAgIG1hbnRpc3NhTGVuZ3RoIC09IDg7XG4gIH1cbiAgZXhwb25lbnQgPSBleHBvbmVudCA8PCBtYW50aXNzYUxlbmd0aCB8IG1hbnRpc3NhO1xuICBleHBvbmVudExlbmd0aCArPSBtYW50aXNzYUxlbmd0aDtcbiAgd2hpbGUgKGV4cG9uZW50TGVuZ3RoID4gMCkge1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IGV4cG9uZW50ICYgMjU1O1xuICAgIGV4cG9uZW50IC89IDI1NjtcbiAgICBleHBvbmVudExlbmd0aCAtPSA4O1xuICB9XG4gIGJ1ZmZlclstLWluZGV4XSB8PSBzaWduICogMTI4O1xuICByZXR1cm4gYnVmZmVyO1xufTtcblxudmFyIHVucGFjayA9IGZ1bmN0aW9uIChidWZmZXIsIG1hbnRpc3NhTGVuZ3RoKSB7XG4gIHZhciBieXRlcyA9IGJ1ZmZlci5sZW5ndGg7XG4gIHZhciBleHBvbmVudExlbmd0aCA9IGJ5dGVzICogOCAtIG1hbnRpc3NhTGVuZ3RoIC0gMTtcbiAgdmFyIGVNYXggPSAoMSA8PCBleHBvbmVudExlbmd0aCkgLSAxO1xuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDE7XG4gIHZhciBuQml0cyA9IGV4cG9uZW50TGVuZ3RoIC0gNztcbiAgdmFyIGluZGV4ID0gYnl0ZXMgLSAxO1xuICB2YXIgc2lnbiA9IGJ1ZmZlcltpbmRleC0tXTtcbiAgdmFyIGV4cG9uZW50ID0gc2lnbiAmIDEyNztcbiAgdmFyIG1hbnRpc3NhO1xuICBzaWduID4+PSA3O1xuICB3aGlsZSAobkJpdHMgPiAwKSB7XG4gICAgZXhwb25lbnQgPSBleHBvbmVudCAqIDI1NiArIGJ1ZmZlcltpbmRleC0tXTtcbiAgICBuQml0cyAtPSA4O1xuICB9XG4gIG1hbnRpc3NhID0gZXhwb25lbnQgJiAoMSA8PCAtbkJpdHMpIC0gMTtcbiAgZXhwb25lbnQgPj49IC1uQml0cztcbiAgbkJpdHMgKz0gbWFudGlzc2FMZW5ndGg7XG4gIHdoaWxlIChuQml0cyA+IDApIHtcbiAgICBtYW50aXNzYSA9IG1hbnRpc3NhICogMjU2ICsgYnVmZmVyW2luZGV4LS1dO1xuICAgIG5CaXRzIC09IDg7XG4gIH1cbiAgaWYgKGV4cG9uZW50ID09PSAwKSB7XG4gICAgZXhwb25lbnQgPSAxIC0gZUJpYXM7XG4gIH0gZWxzZSBpZiAoZXhwb25lbnQgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbWFudGlzc2EgPyBOYU4gOiBzaWduID8gLUluZmluaXR5IDogSW5maW5pdHk7XG4gIH0gZWxzZSB7XG4gICAgbWFudGlzc2EgPSBtYW50aXNzYSArIHBvdygyLCBtYW50aXNzYUxlbmd0aCk7XG4gICAgZXhwb25lbnQgPSBleHBvbmVudCAtIGVCaWFzO1xuICB9IHJldHVybiAoc2lnbiA/IC0xIDogMSkgKiBtYW50aXNzYSAqIHBvdygyLCBleHBvbmVudCAtIG1hbnRpc3NhTGVuZ3RoKTtcbn07XG5cbnZhciBpZWVlNzU0ID0ge1xuICBwYWNrOiBwYWNrLFxuICB1bnBhY2s6IHVucGFja1xufTtcblxudmFyIHRvT2JqZWN0JDEgPSB0b09iamVjdCQ3O1xudmFyIHRvQWJzb2x1dGVJbmRleCQyID0gdG9BYnNvbHV0ZUluZGV4JDQ7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UkMyA9IGxlbmd0aE9mQXJyYXlMaWtlJDg7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuZmlsbGAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maWxsXG52YXIgYXJyYXlGaWxsJDEgPSBmdW5jdGlvbiBmaWxsKHZhbHVlIC8qICwgc3RhcnQgPSAwLCBlbmQgPSBAbGVuZ3RoICovKSB7XG4gIHZhciBPID0gdG9PYmplY3QkMSh0aGlzKTtcbiAgdmFyIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlJDMoTyk7XG4gIHZhciBhcmd1bWVudHNMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgkMihhcmd1bWVudHNMZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCBsZW5ndGgpO1xuICB2YXIgZW5kID0gYXJndW1lbnRzTGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgdmFyIGVuZFBvcyA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogdG9BYnNvbHV0ZUluZGV4JDIoZW5kLCBsZW5ndGgpO1xuICB3aGlsZSAoZW5kUG9zID4gaW5kZXgpIE9baW5kZXgrK10gPSB2YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuXG52YXIgdG9Qcm9wZXJ0eUtleSQxID0gdG9Qcm9wZXJ0eUtleSQ0O1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlJDEgPSBvYmplY3REZWZpbmVQcm9wZXJ0eTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkMSA9IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQ1O1xuXG52YXIgY3JlYXRlUHJvcGVydHkkMSA9IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgdmFyIHByb3BlcnR5S2V5ID0gdG9Qcm9wZXJ0eUtleSQxKGtleSk7XG4gIGlmIChwcm9wZXJ0eUtleSBpbiBvYmplY3QpIGRlZmluZVByb3BlcnR5TW9kdWxlJDEuZihvYmplY3QsIHByb3BlcnR5S2V5LCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkMSgwLCB2YWx1ZSkpO1xuICBlbHNlIG9iamVjdFtwcm9wZXJ0eUtleV0gPSB2YWx1ZTtcbn07XG5cbnZhciB0b0Fic29sdXRlSW5kZXgkMSA9IHRvQWJzb2x1dGVJbmRleCQ0O1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlJDIgPSBsZW5ndGhPZkFycmF5TGlrZSQ4O1xudmFyIGNyZWF0ZVByb3BlcnR5ID0gY3JlYXRlUHJvcGVydHkkMTtcblxudmFyICRBcnJheSQxID0gQXJyYXk7XG52YXIgbWF4ID0gTWF0aC5tYXg7XG5cbnZhciBhcnJheVNsaWNlU2ltcGxlID0gZnVuY3Rpb24gKE8sIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlJDIoTyk7XG4gIHZhciBrID0gdG9BYnNvbHV0ZUluZGV4JDEoc3RhcnQsIGxlbmd0aCk7XG4gIHZhciBmaW4gPSB0b0Fic29sdXRlSW5kZXgkMShlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IGVuZCwgbGVuZ3RoKTtcbiAgdmFyIHJlc3VsdCA9ICRBcnJheSQxKG1heChmaW4gLSBrLCAwKSk7XG4gIGZvciAodmFyIG4gPSAwOyBrIDwgZmluOyBrKyssIG4rKykgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBuLCBPW2tdKTtcbiAgcmVzdWx0Lmxlbmd0aCA9IG47XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgZ2xvYmFsJDUgPSBnbG9iYWwkdDtcbnZhciB1bmN1cnJ5VGhpcyQ3ID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBERVNDUklQVE9SUyQxID0gZGVzY3JpcHRvcnM7XG52YXIgTkFUSVZFX0FSUkFZX0JVRkZFUiA9IGFycmF5QnVmZmVyTmF0aXZlO1xudmFyIEZ1bmN0aW9uTmFtZSA9IGZ1bmN0aW9uTmFtZTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMiA9IGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ4O1xudmFyIGRlZmluZUJ1aWx0SW5zID0gZGVmaW5lQnVpbHRJbnMkMTtcbnZhciBmYWlscyQ3ID0gZmFpbHMkcztcbnZhciBhbkluc3RhbmNlJDEgPSBhbkluc3RhbmNlJDM7XG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSQyID0gdG9JbnRlZ2VyT3JJbmZpbml0eSQ2O1xudmFyIHRvTGVuZ3RoJDMgPSB0b0xlbmd0aCQ2O1xudmFyIHRvSW5kZXgkMSA9IHRvSW5kZXgkMjtcbnZhciBJRUVFNzU0ID0gaWVlZTc1NDtcbnZhciBnZXRQcm90b3R5cGVPZiA9IG9iamVjdEdldFByb3RvdHlwZU9mO1xudmFyIHNldFByb3RvdHlwZU9mJDIgPSBvYmplY3RTZXRQcm90b3R5cGVPZjtcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzJDEgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzLmY7XG52YXIgZGVmaW5lUHJvcGVydHkgPSBvYmplY3REZWZpbmVQcm9wZXJ0eS5mO1xudmFyIGFycmF5RmlsbCA9IGFycmF5RmlsbCQxO1xudmFyIGFycmF5U2xpY2UkMyA9IGFycmF5U2xpY2VTaW1wbGU7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSBzZXRUb1N0cmluZ1RhZyQ0O1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUkMSA9IGludGVybmFsU3RhdGU7XG5cbnZhciBQUk9QRVJfRlVOQ1RJT05fTkFNRSA9IEZ1bmN0aW9uTmFtZS5QUk9QRVI7XG52YXIgQ09ORklHVVJBQkxFX0ZVTkNUSU9OX05BTUUgPSBGdW5jdGlvbk5hbWUuQ09ORklHVVJBQkxFO1xudmFyIGdldEludGVybmFsU3RhdGUkMSA9IEludGVybmFsU3RhdGVNb2R1bGUkMS5nZXQ7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSQxID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQxLnNldDtcbnZhciBBUlJBWV9CVUZGRVIgPSAnQXJyYXlCdWZmZXInO1xudmFyIERBVEFfVklFVyA9ICdEYXRhVmlldyc7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG52YXIgV1JPTkdfTEVOR1RIJDEgPSAnV3JvbmcgbGVuZ3RoJztcbnZhciBXUk9OR19JTkRFWCA9ICdXcm9uZyBpbmRleCc7XG52YXIgTmF0aXZlQXJyYXlCdWZmZXIgPSBnbG9iYWwkNVtBUlJBWV9CVUZGRVJdO1xudmFyICRBcnJheUJ1ZmZlciA9IE5hdGl2ZUFycmF5QnVmZmVyO1xudmFyIEFycmF5QnVmZmVyUHJvdG90eXBlJDEgPSAkQXJyYXlCdWZmZXIgJiYgJEFycmF5QnVmZmVyW1BST1RPVFlQRV07XG52YXIgJERhdGFWaWV3ID0gZ2xvYmFsJDVbREFUQV9WSUVXXTtcbnZhciBEYXRhVmlld1Byb3RvdHlwZSQxID0gJERhdGFWaWV3ICYmICREYXRhVmlld1tQUk9UT1RZUEVdO1xudmFyIE9iamVjdFByb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGU7XG52YXIgQXJyYXkkMSA9IGdsb2JhbCQ1LkFycmF5O1xudmFyIFJhbmdlRXJyb3IkMyA9IGdsb2JhbCQ1LlJhbmdlRXJyb3I7XG52YXIgZmlsbCA9IHVuY3VycnlUaGlzJDcoYXJyYXlGaWxsKTtcbnZhciByZXZlcnNlID0gdW5jdXJyeVRoaXMkNyhbXS5yZXZlcnNlKTtcblxudmFyIHBhY2tJRUVFNzU0ID0gSUVFRTc1NC5wYWNrO1xudmFyIHVucGFja0lFRUU3NTQgPSBJRUVFNzU0LnVucGFjaztcblxudmFyIHBhY2tJbnQ4ID0gZnVuY3Rpb24gKG51bWJlcikge1xuICByZXR1cm4gW251bWJlciAmIDB4RkZdO1xufTtcblxudmFyIHBhY2tJbnQxNiA9IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgcmV0dXJuIFtudW1iZXIgJiAweEZGLCBudW1iZXIgPj4gOCAmIDB4RkZdO1xufTtcblxudmFyIHBhY2tJbnQzMiA9IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgcmV0dXJuIFtudW1iZXIgJiAweEZGLCBudW1iZXIgPj4gOCAmIDB4RkYsIG51bWJlciA+PiAxNiAmIDB4RkYsIG51bWJlciA+PiAyNCAmIDB4RkZdO1xufTtcblxudmFyIHVucGFja0ludDMyID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xuICByZXR1cm4gYnVmZmVyWzNdIDw8IDI0IHwgYnVmZmVyWzJdIDw8IDE2IHwgYnVmZmVyWzFdIDw8IDggfCBidWZmZXJbMF07XG59O1xuXG52YXIgcGFja0Zsb2F0MzIgPSBmdW5jdGlvbiAobnVtYmVyKSB7XG4gIHJldHVybiBwYWNrSUVFRTc1NChudW1iZXIsIDIzLCA0KTtcbn07XG5cbnZhciBwYWNrRmxvYXQ2NCA9IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgcmV0dXJuIHBhY2tJRUVFNzU0KG51bWJlciwgNTIsIDgpO1xufTtcblxudmFyIGFkZEdldHRlciQxID0gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBrZXkpIHtcbiAgZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3JbUFJPVE9UWVBFXSwga2V5LCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2V0SW50ZXJuYWxTdGF0ZSQxKHRoaXMpW2tleV07IH0gfSk7XG59O1xuXG52YXIgZ2V0ID0gZnVuY3Rpb24gKHZpZXcsIGNvdW50LCBpbmRleCwgaXNMaXR0bGVFbmRpYW4pIHtcbiAgdmFyIGludEluZGV4ID0gdG9JbmRleCQxKGluZGV4KTtcbiAgdmFyIHN0b3JlID0gZ2V0SW50ZXJuYWxTdGF0ZSQxKHZpZXcpO1xuICBpZiAoaW50SW5kZXggKyBjb3VudCA+IHN0b3JlLmJ5dGVMZW5ndGgpIHRocm93IFJhbmdlRXJyb3IkMyhXUk9OR19JTkRFWCk7XG4gIHZhciBieXRlcyA9IGdldEludGVybmFsU3RhdGUkMShzdG9yZS5idWZmZXIpLmJ5dGVzO1xuICB2YXIgc3RhcnQgPSBpbnRJbmRleCArIHN0b3JlLmJ5dGVPZmZzZXQ7XG4gIHZhciBwYWNrID0gYXJyYXlTbGljZSQzKGJ5dGVzLCBzdGFydCwgc3RhcnQgKyBjb3VudCk7XG4gIHJldHVybiBpc0xpdHRsZUVuZGlhbiA/IHBhY2sgOiByZXZlcnNlKHBhY2spO1xufTtcblxudmFyIHNldCA9IGZ1bmN0aW9uICh2aWV3LCBjb3VudCwgaW5kZXgsIGNvbnZlcnNpb24sIHZhbHVlLCBpc0xpdHRsZUVuZGlhbikge1xuICB2YXIgaW50SW5kZXggPSB0b0luZGV4JDEoaW5kZXgpO1xuICB2YXIgc3RvcmUgPSBnZXRJbnRlcm5hbFN0YXRlJDEodmlldyk7XG4gIGlmIChpbnRJbmRleCArIGNvdW50ID4gc3RvcmUuYnl0ZUxlbmd0aCkgdGhyb3cgUmFuZ2VFcnJvciQzKFdST05HX0lOREVYKTtcbiAgdmFyIGJ5dGVzID0gZ2V0SW50ZXJuYWxTdGF0ZSQxKHN0b3JlLmJ1ZmZlcikuYnl0ZXM7XG4gIHZhciBzdGFydCA9IGludEluZGV4ICsgc3RvcmUuYnl0ZU9mZnNldDtcbiAgdmFyIHBhY2sgPSBjb252ZXJzaW9uKCt2YWx1ZSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykgYnl0ZXNbc3RhcnQgKyBpXSA9IHBhY2tbaXNMaXR0bGVFbmRpYW4gPyBpIDogY291bnQgLSBpIC0gMV07XG59O1xuXG5pZiAoIU5BVElWRV9BUlJBWV9CVUZGRVIpIHtcbiAgJEFycmF5QnVmZmVyID0gZnVuY3Rpb24gQXJyYXlCdWZmZXIobGVuZ3RoKSB7XG4gICAgYW5JbnN0YW5jZSQxKHRoaXMsIEFycmF5QnVmZmVyUHJvdG90eXBlJDEpO1xuICAgIHZhciBieXRlTGVuZ3RoID0gdG9JbmRleCQxKGxlbmd0aCk7XG4gICAgc2V0SW50ZXJuYWxTdGF0ZSQxKHRoaXMsIHtcbiAgICAgIGJ5dGVzOiBmaWxsKEFycmF5JDEoYnl0ZUxlbmd0aCksIDApLFxuICAgICAgYnl0ZUxlbmd0aDogYnl0ZUxlbmd0aFxuICAgIH0pO1xuICAgIGlmICghREVTQ1JJUFRPUlMkMSkgdGhpcy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aDtcbiAgfTtcblxuICBBcnJheUJ1ZmZlclByb3RvdHlwZSQxID0gJEFycmF5QnVmZmVyW1BST1RPVFlQRV07XG5cbiAgJERhdGFWaWV3ID0gZnVuY3Rpb24gRGF0YVZpZXcoYnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gICAgYW5JbnN0YW5jZSQxKHRoaXMsIERhdGFWaWV3UHJvdG90eXBlJDEpO1xuICAgIGFuSW5zdGFuY2UkMShidWZmZXIsIEFycmF5QnVmZmVyUHJvdG90eXBlJDEpO1xuICAgIHZhciBidWZmZXJMZW5ndGggPSBnZXRJbnRlcm5hbFN0YXRlJDEoYnVmZmVyKS5ieXRlTGVuZ3RoO1xuICAgIHZhciBvZmZzZXQgPSB0b0ludGVnZXJPckluZmluaXR5JDIoYnl0ZU9mZnNldCk7XG4gICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ID4gYnVmZmVyTGVuZ3RoKSB0aHJvdyBSYW5nZUVycm9yJDMoJ1dyb25nIG9mZnNldCcpO1xuICAgIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID09PSB1bmRlZmluZWQgPyBidWZmZXJMZW5ndGggLSBvZmZzZXQgOiB0b0xlbmd0aCQzKGJ5dGVMZW5ndGgpO1xuICAgIGlmIChvZmZzZXQgKyBieXRlTGVuZ3RoID4gYnVmZmVyTGVuZ3RoKSB0aHJvdyBSYW5nZUVycm9yJDMoV1JPTkdfTEVOR1RIJDEpO1xuICAgIHNldEludGVybmFsU3RhdGUkMSh0aGlzLCB7XG4gICAgICBidWZmZXI6IGJ1ZmZlcixcbiAgICAgIGJ5dGVMZW5ndGg6IGJ5dGVMZW5ndGgsXG4gICAgICBieXRlT2Zmc2V0OiBvZmZzZXRcbiAgICB9KTtcbiAgICBpZiAoIURFU0NSSVBUT1JTJDEpIHtcbiAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgdGhpcy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aDtcbiAgICAgIHRoaXMuYnl0ZU9mZnNldCA9IG9mZnNldDtcbiAgICB9XG4gIH07XG5cbiAgRGF0YVZpZXdQcm90b3R5cGUkMSA9ICREYXRhVmlld1tQUk9UT1RZUEVdO1xuXG4gIGlmIChERVNDUklQVE9SUyQxKSB7XG4gICAgYWRkR2V0dGVyJDEoJEFycmF5QnVmZmVyLCAnYnl0ZUxlbmd0aCcpO1xuICAgIGFkZEdldHRlciQxKCREYXRhVmlldywgJ2J1ZmZlcicpO1xuICAgIGFkZEdldHRlciQxKCREYXRhVmlldywgJ2J5dGVMZW5ndGgnKTtcbiAgICBhZGRHZXR0ZXIkMSgkRGF0YVZpZXcsICdieXRlT2Zmc2V0Jyk7XG4gIH1cblxuICBkZWZpbmVCdWlsdElucyhEYXRhVmlld1Byb3RvdHlwZSQxLCB7XG4gICAgZ2V0SW50ODogZnVuY3Rpb24gZ2V0SW50OChieXRlT2Zmc2V0KSB7XG4gICAgICByZXR1cm4gZ2V0KHRoaXMsIDEsIGJ5dGVPZmZzZXQpWzBdIDw8IDI0ID4+IDI0O1xuICAgIH0sXG4gICAgZ2V0VWludDg6IGZ1bmN0aW9uIGdldFVpbnQ4KGJ5dGVPZmZzZXQpIHtcbiAgICAgIHJldHVybiBnZXQodGhpcywgMSwgYnl0ZU9mZnNldClbMF07XG4gICAgfSxcbiAgICBnZXRJbnQxNjogZnVuY3Rpb24gZ2V0SW50MTYoYnl0ZU9mZnNldCAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgdmFyIGJ5dGVzID0gZ2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICAgIHJldHVybiAoYnl0ZXNbMV0gPDwgOCB8IGJ5dGVzWzBdKSA8PCAxNiA+PiAxNjtcbiAgICB9LFxuICAgIGdldFVpbnQxNjogZnVuY3Rpb24gZ2V0VWludDE2KGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHZhciBieXRlcyA9IGdldCh0aGlzLCAyLCBieXRlT2Zmc2V0LCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgICByZXR1cm4gYnl0ZXNbMV0gPDwgOCB8IGJ5dGVzWzBdO1xuICAgIH0sXG4gICAgZ2V0SW50MzI6IGZ1bmN0aW9uIGdldEludDMyKGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHJldHVybiB1bnBhY2tJbnQzMihnZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpKTtcbiAgICB9LFxuICAgIGdldFVpbnQzMjogZnVuY3Rpb24gZ2V0VWludDMyKGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHJldHVybiB1bnBhY2tJbnQzMihnZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpKSA+Pj4gMDtcbiAgICB9LFxuICAgIGdldEZsb2F0MzI6IGZ1bmN0aW9uIGdldEZsb2F0MzIoYnl0ZU9mZnNldCAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgcmV0dXJuIHVucGFja0lFRUU3NTQoZ2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKSwgMjMpO1xuICAgIH0sXG4gICAgZ2V0RmxvYXQ2NDogZnVuY3Rpb24gZ2V0RmxvYXQ2NChieXRlT2Zmc2V0IC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICByZXR1cm4gdW5wYWNrSUVFRTc1NChnZXQodGhpcywgOCwgYnl0ZU9mZnNldCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpLCA1Mik7XG4gICAgfSxcbiAgICBzZXRJbnQ4OiBmdW5jdGlvbiBzZXRJbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKSB7XG4gICAgICBzZXQodGhpcywgMSwgYnl0ZU9mZnNldCwgcGFja0ludDgsIHZhbHVlKTtcbiAgICB9LFxuICAgIHNldFVpbnQ4OiBmdW5jdGlvbiBzZXRVaW50OChieXRlT2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgc2V0KHRoaXMsIDEsIGJ5dGVPZmZzZXQsIHBhY2tJbnQ4LCB2YWx1ZSk7XG4gICAgfSxcbiAgICBzZXRJbnQxNjogZnVuY3Rpb24gc2V0SW50MTYoYnl0ZU9mZnNldCwgdmFsdWUgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHNldCh0aGlzLCAyLCBieXRlT2Zmc2V0LCBwYWNrSW50MTYsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBzZXRVaW50MTY6IGZ1bmN0aW9uIHNldFVpbnQxNihieXRlT2Zmc2V0LCB2YWx1ZSAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgc2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIHBhY2tJbnQxNiwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIHNldEludDMyOiBmdW5jdGlvbiBzZXRJbnQzMihieXRlT2Zmc2V0LCB2YWx1ZSAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgc2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIHBhY2tJbnQzMiwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIHNldFVpbnQzMjogZnVuY3Rpb24gc2V0VWludDMyKGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICBzZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgcGFja0ludDMyLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgc2V0RmxvYXQzMjogZnVuY3Rpb24gc2V0RmxvYXQzMihieXRlT2Zmc2V0LCB2YWx1ZSAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgc2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIHBhY2tGbG9hdDMyLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgc2V0RmxvYXQ2NDogZnVuY3Rpb24gc2V0RmxvYXQ2NChieXRlT2Zmc2V0LCB2YWx1ZSAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgc2V0KHRoaXMsIDgsIGJ5dGVPZmZzZXQsIHBhY2tGbG9hdDY0LCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQpO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICB2YXIgSU5DT1JSRUNUX0FSUkFZX0JVRkZFUl9OQU1FID0gUFJPUEVSX0ZVTkNUSU9OX05BTUUgJiYgTmF0aXZlQXJyYXlCdWZmZXIubmFtZSAhPT0gQVJSQVlfQlVGRkVSO1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1uZXcgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmcgKi9cbiAgaWYgKCFmYWlscyQ3KGZ1bmN0aW9uICgpIHtcbiAgICBOYXRpdmVBcnJheUJ1ZmZlcigxKTtcbiAgfSkgfHwgIWZhaWxzJDcoZnVuY3Rpb24gKCkge1xuICAgIG5ldyBOYXRpdmVBcnJheUJ1ZmZlcigtMSk7XG4gIH0pIHx8IGZhaWxzJDcoZnVuY3Rpb24gKCkge1xuICAgIG5ldyBOYXRpdmVBcnJheUJ1ZmZlcigpO1xuICAgIG5ldyBOYXRpdmVBcnJheUJ1ZmZlcigxLjUpO1xuICAgIG5ldyBOYXRpdmVBcnJheUJ1ZmZlcihOYU4pO1xuICAgIHJldHVybiBJTkNPUlJFQ1RfQVJSQVlfQlVGRkVSX05BTUUgJiYgIUNPTkZJR1VSQUJMRV9GVU5DVElPTl9OQU1FO1xuICB9KSkge1xuICAvKiBlc2xpbnQtZW5hYmxlIG5vLW5ldyAtLSByZXF1aXJlZCBmb3IgdGVzdGluZyAqL1xuICAgICRBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIEFycmF5QnVmZmVyKGxlbmd0aCkge1xuICAgICAgYW5JbnN0YW5jZSQxKHRoaXMsIEFycmF5QnVmZmVyUHJvdG90eXBlJDEpO1xuICAgICAgcmV0dXJuIG5ldyBOYXRpdmVBcnJheUJ1ZmZlcih0b0luZGV4JDEobGVuZ3RoKSk7XG4gICAgfTtcblxuICAgICRBcnJheUJ1ZmZlcltQUk9UT1RZUEVdID0gQXJyYXlCdWZmZXJQcm90b3R5cGUkMTtcblxuICAgIGZvciAodmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzJDEoTmF0aXZlQXJyYXlCdWZmZXIpLCBqID0gMCwga2V5OyBrZXlzLmxlbmd0aCA+IGo7KSB7XG4gICAgICBpZiAoISgoa2V5ID0ga2V5c1tqKytdKSBpbiAkQXJyYXlCdWZmZXIpKSB7XG4gICAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQyKCRBcnJheUJ1ZmZlciwga2V5LCBOYXRpdmVBcnJheUJ1ZmZlcltrZXldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBBcnJheUJ1ZmZlclByb3RvdHlwZSQxLmNvbnN0cnVjdG9yID0gJEFycmF5QnVmZmVyO1xuICB9IGVsc2UgaWYgKElOQ09SUkVDVF9BUlJBWV9CVUZGRVJfTkFNRSAmJiBDT05GSUdVUkFCTEVfRlVOQ1RJT05fTkFNRSkge1xuICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQyKE5hdGl2ZUFycmF5QnVmZmVyLCAnbmFtZScsIEFSUkFZX0JVRkZFUik7XG4gIH1cblxuICAvLyBXZWJLaXQgYnVnIC0gdGhlIHNhbWUgcGFyZW50IHByb3RvdHlwZSBmb3IgdHlwZWQgYXJyYXlzIGFuZCBkYXRhIHZpZXdcbiAgaWYgKHNldFByb3RvdHlwZU9mJDIgJiYgZ2V0UHJvdG90eXBlT2YoRGF0YVZpZXdQcm90b3R5cGUkMSkgIT09IE9iamVjdFByb3RvdHlwZSkge1xuICAgIHNldFByb3RvdHlwZU9mJDIoRGF0YVZpZXdQcm90b3R5cGUkMSwgT2JqZWN0UHJvdG90eXBlKTtcbiAgfVxuXG4gIC8vIGlPUyBTYWZhcmkgNy54IGJ1Z1xuICB2YXIgdGVzdFZpZXcgPSBuZXcgJERhdGFWaWV3KG5ldyAkQXJyYXlCdWZmZXIoMikpO1xuICB2YXIgJHNldEludDggPSB1bmN1cnJ5VGhpcyQ3KERhdGFWaWV3UHJvdG90eXBlJDEuc2V0SW50OCk7XG4gIHRlc3RWaWV3LnNldEludDgoMCwgMjE0NzQ4MzY0OCk7XG4gIHRlc3RWaWV3LnNldEludDgoMSwgMjE0NzQ4MzY0OSk7XG4gIGlmICh0ZXN0Vmlldy5nZXRJbnQ4KDApIHx8ICF0ZXN0Vmlldy5nZXRJbnQ4KDEpKSBkZWZpbmVCdWlsdElucyhEYXRhVmlld1Byb3RvdHlwZSQxLCB7XG4gICAgc2V0SW50ODogZnVuY3Rpb24gc2V0SW50OChieXRlT2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgJHNldEludDgodGhpcywgYnl0ZU9mZnNldCwgdmFsdWUgPDwgMjQgPj4gMjQpO1xuICAgIH0sXG4gICAgc2V0VWludDg6IGZ1bmN0aW9uIHNldFVpbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKSB7XG4gICAgICAkc2V0SW50OCh0aGlzLCBieXRlT2Zmc2V0LCB2YWx1ZSA8PCAyNCA+PiAyNCk7XG4gICAgfVxuICB9LCB7IHVuc2FmZTogdHJ1ZSB9KTtcbn1cblxuc2V0VG9TdHJpbmdUYWcoJEFycmF5QnVmZmVyLCBBUlJBWV9CVUZGRVIpO1xuc2V0VG9TdHJpbmdUYWcoJERhdGFWaWV3LCBEQVRBX1ZJRVcpO1xuXG52YXIgYXJyYXlCdWZmZXIgPSB7XG4gIEFycmF5QnVmZmVyOiAkQXJyYXlCdWZmZXIsXG4gIERhdGFWaWV3OiAkRGF0YVZpZXdcbn07XG5cbnZhciAkJDEgPSBfZXhwb3J0O1xudmFyIHVuY3VycnlUaGlzJDYgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGZhaWxzJDYgPSBmYWlscyRzO1xudmFyIEFycmF5QnVmZmVyTW9kdWxlJDEgPSBhcnJheUJ1ZmZlcjtcbnZhciBhbk9iamVjdCQyID0gYW5PYmplY3QkZTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSB0b0Fic29sdXRlSW5kZXgkNDtcbnZhciB0b0xlbmd0aCQyID0gdG9MZW5ndGgkNjtcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IkMSA9IHNwZWNpZXNDb25zdHJ1Y3RvciQzO1xuXG52YXIgQXJyYXlCdWZmZXIkMiA9IEFycmF5QnVmZmVyTW9kdWxlJDEuQXJyYXlCdWZmZXI7XG52YXIgRGF0YVZpZXckMiA9IEFycmF5QnVmZmVyTW9kdWxlJDEuRGF0YVZpZXc7XG52YXIgRGF0YVZpZXdQcm90b3R5cGUgPSBEYXRhVmlldyQyLnByb3RvdHlwZTtcbnZhciB1biRBcnJheUJ1ZmZlclNsaWNlID0gdW5jdXJyeVRoaXMkNihBcnJheUJ1ZmZlciQyLnByb3RvdHlwZS5zbGljZSk7XG52YXIgZ2V0VWludDggPSB1bmN1cnJ5VGhpcyQ2KERhdGFWaWV3UHJvdG90eXBlLmdldFVpbnQ4KTtcbnZhciBzZXRVaW50OCA9IHVuY3VycnlUaGlzJDYoRGF0YVZpZXdQcm90b3R5cGUuc2V0VWludDgpO1xuXG52YXIgSU5DT1JSRUNUX1NMSUNFID0gZmFpbHMkNihmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhbmV3IEFycmF5QnVmZmVyJDIoMikuc2xpY2UoMSwgdW5kZWZpbmVkKS5ieXRlTGVuZ3RoO1xufSk7XG5cbi8vIGBBcnJheUJ1ZmZlci5wcm90b3R5cGUuc2xpY2VgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheWJ1ZmZlci5wcm90b3R5cGUuc2xpY2VcbiQkMSh7IHRhcmdldDogJ0FycmF5QnVmZmVyJywgcHJvdG86IHRydWUsIHVuc2FmZTogdHJ1ZSwgZm9yY2VkOiBJTkNPUlJFQ1RfU0xJQ0UgfSwge1xuICBzbGljZTogZnVuY3Rpb24gc2xpY2Uoc3RhcnQsIGVuZCkge1xuICAgIGlmICh1biRBcnJheUJ1ZmZlclNsaWNlICYmIGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdW4kQXJyYXlCdWZmZXJTbGljZShhbk9iamVjdCQyKHRoaXMpLCBzdGFydCk7IC8vIEZGIGZpeFxuICAgIH1cbiAgICB2YXIgbGVuZ3RoID0gYW5PYmplY3QkMih0aGlzKS5ieXRlTGVuZ3RoO1xuICAgIHZhciBmaXJzdCA9IHRvQWJzb2x1dGVJbmRleChzdGFydCwgbGVuZ3RoKTtcbiAgICB2YXIgZmluID0gdG9BYnNvbHV0ZUluZGV4KGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogZW5kLCBsZW5ndGgpO1xuICAgIHZhciByZXN1bHQgPSBuZXcgKHNwZWNpZXNDb25zdHJ1Y3RvciQxKHRoaXMsIEFycmF5QnVmZmVyJDIpKSh0b0xlbmd0aCQyKGZpbiAtIGZpcnN0KSk7XG4gICAgdmFyIHZpZXdTb3VyY2UgPSBuZXcgRGF0YVZpZXckMih0aGlzKTtcbiAgICB2YXIgdmlld1RhcmdldCA9IG5ldyBEYXRhVmlldyQyKHJlc3VsdCk7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB3aGlsZSAoZmlyc3QgPCBmaW4pIHtcbiAgICAgIHNldFVpbnQ4KHZpZXdUYXJnZXQsIGluZGV4KyssIGdldFVpbnQ4KHZpZXdTb3VyY2UsIGZpcnN0KyspKTtcbiAgICB9IHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuXG52YXIgdHlwZWRBcnJheUNvbnN0cnVjdG9yID0ge2V4cG9ydHM6IHt9fTtcblxudmFyIGlzT2JqZWN0JDMgPSBpc09iamVjdCRkO1xuXG52YXIgZmxvb3IkMSA9IE1hdGguZmxvb3I7XG5cbi8vIGBJc0ludGVncmFsTnVtYmVyYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaXNpbnRlZ3JhbG51bWJlclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tbnVtYmVyLWlzaW50ZWdlciAtLSBzYWZlXG52YXIgaXNJbnRlZ3JhbE51bWJlciQxID0gTnVtYmVyLmlzSW50ZWdlciB8fCBmdW5jdGlvbiBpc0ludGVnZXIoaXQpIHtcbiAgcmV0dXJuICFpc09iamVjdCQzKGl0KSAmJiBpc0Zpbml0ZShpdCkgJiYgZmxvb3IkMShpdCkgPT09IGl0O1xufTtcblxudmFyIHRvSW50ZWdlck9ySW5maW5pdHkkMSA9IHRvSW50ZWdlck9ySW5maW5pdHkkNjtcblxudmFyICRSYW5nZUVycm9yJDEgPSBSYW5nZUVycm9yO1xuXG52YXIgdG9Qb3NpdGl2ZUludGVnZXIkMSA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgcmVzdWx0ID0gdG9JbnRlZ2VyT3JJbmZpbml0eSQxKGl0KTtcbiAgaWYgKHJlc3VsdCA8IDApIHRocm93ICRSYW5nZUVycm9yJDEoXCJUaGUgYXJndW1lbnQgY2FuJ3QgYmUgbGVzcyB0aGFuIDBcIik7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgdG9Qb3NpdGl2ZUludGVnZXIgPSB0b1Bvc2l0aXZlSW50ZWdlciQxO1xuXG52YXIgJFJhbmdlRXJyb3IgPSBSYW5nZUVycm9yO1xuXG52YXIgdG9PZmZzZXQkMiA9IGZ1bmN0aW9uIChpdCwgQllURVMpIHtcbiAgdmFyIG9mZnNldCA9IHRvUG9zaXRpdmVJbnRlZ2VyKGl0KTtcbiAgaWYgKG9mZnNldCAlIEJZVEVTKSB0aHJvdyAkUmFuZ2VFcnJvcignV3Jvbmcgb2Zmc2V0Jyk7XG4gIHJldHVybiBvZmZzZXQ7XG59O1xuXG52YXIgY2xhc3NvZiQzID0gY2xhc3NvZlJhdyQxO1xuXG4vLyBgSXNBcnJheWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWlzYXJyYXlcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLWFycmF5LWlzYXJyYXkgLS0gc2FmZVxudmFyIGlzQXJyYXkkMSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmd1bWVudCkge1xuICByZXR1cm4gY2xhc3NvZiQzKGFyZ3VtZW50KSA9PSAnQXJyYXknO1xufTtcblxudmFyIGlzQXJyYXkgPSBpc0FycmF5JDE7XG52YXIgaXNDb25zdHJ1Y3RvciA9IGlzQ29uc3RydWN0b3IkMjtcbnZhciBpc09iamVjdCQyID0gaXNPYmplY3QkZDtcbnZhciB3ZWxsS25vd25TeW1ib2wkMSA9IHdlbGxLbm93blN5bWJvbCRqO1xuXG52YXIgU1BFQ0lFUyQxID0gd2VsbEtub3duU3ltYm9sJDEoJ3NwZWNpZXMnKTtcbnZhciAkQXJyYXkgPSBBcnJheTtcblxuLy8gYSBwYXJ0IG9mIGBBcnJheVNwZWNpZXNDcmVhdGVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheXNwZWNpZXNjcmVhdGVcbnZhciBhcnJheVNwZWNpZXNDb25zdHJ1Y3RvciQxID0gZnVuY3Rpb24gKG9yaWdpbmFsQXJyYXkpIHtcbiAgdmFyIEM7XG4gIGlmIChpc0FycmF5KG9yaWdpbmFsQXJyYXkpKSB7XG4gICAgQyA9IG9yaWdpbmFsQXJyYXkuY29uc3RydWN0b3I7XG4gICAgLy8gY3Jvc3MtcmVhbG0gZmFsbGJhY2tcbiAgICBpZiAoaXNDb25zdHJ1Y3RvcihDKSAmJiAoQyA9PT0gJEFycmF5IHx8IGlzQXJyYXkoQy5wcm90b3R5cGUpKSkgQyA9IHVuZGVmaW5lZDtcbiAgICBlbHNlIGlmIChpc09iamVjdCQyKEMpKSB7XG4gICAgICBDID0gQ1tTUEVDSUVTJDFdO1xuICAgICAgaWYgKEMgPT09IG51bGwpIEMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IHJldHVybiBDID09PSB1bmRlZmluZWQgPyAkQXJyYXkgOiBDO1xufTtcblxudmFyIGFycmF5U3BlY2llc0NvbnN0cnVjdG9yID0gYXJyYXlTcGVjaWVzQ29uc3RydWN0b3IkMTtcblxuLy8gYEFycmF5U3BlY2llc0NyZWF0ZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5c3BlY2llc2NyZWF0ZVxudmFyIGFycmF5U3BlY2llc0NyZWF0ZSQxID0gZnVuY3Rpb24gKG9yaWdpbmFsQXJyYXksIGxlbmd0aCkge1xuICByZXR1cm4gbmV3IChhcnJheVNwZWNpZXNDb25zdHJ1Y3RvcihvcmlnaW5hbEFycmF5KSkobGVuZ3RoID09PSAwID8gMCA6IGxlbmd0aCk7XG59O1xuXG52YXIgYmluZCA9IGZ1bmN0aW9uQmluZENvbnRleHQ7XG52YXIgdW5jdXJyeVRoaXMkNSA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgSW5kZXhlZE9iamVjdCA9IGluZGV4ZWRPYmplY3Q7XG52YXIgdG9PYmplY3QgPSB0b09iamVjdCQ3O1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlJDEgPSBsZW5ndGhPZkFycmF5TGlrZSQ4O1xudmFyIGFycmF5U3BlY2llc0NyZWF0ZSA9IGFycmF5U3BlY2llc0NyZWF0ZSQxO1xuXG52YXIgcHVzaCQxID0gdW5jdXJyeVRoaXMkNShbXS5wdXNoKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS57IGZvckVhY2gsIG1hcCwgZmlsdGVyLCBzb21lLCBldmVyeSwgZmluZCwgZmluZEluZGV4LCBmaWx0ZXJSZWplY3QgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxudmFyIGNyZWF0ZU1ldGhvZCQxID0gZnVuY3Rpb24gKFRZUEUpIHtcbiAgdmFyIElTX01BUCA9IFRZUEUgPT0gMTtcbiAgdmFyIElTX0ZJTFRFUiA9IFRZUEUgPT0gMjtcbiAgdmFyIElTX1NPTUUgPSBUWVBFID09IDM7XG4gIHZhciBJU19FVkVSWSA9IFRZUEUgPT0gNDtcbiAgdmFyIElTX0ZJTkRfSU5ERVggPSBUWVBFID09IDY7XG4gIHZhciBJU19GSUxURVJfUkVKRUNUID0gVFlQRSA9PSA3O1xuICB2YXIgTk9fSE9MRVMgPSBUWVBFID09IDUgfHwgSVNfRklORF9JTkRFWDtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgY2FsbGJhY2tmbiwgdGhhdCwgc3BlY2lmaWNDcmVhdGUpIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgc2VsZiA9IEluZGV4ZWRPYmplY3QoTyk7XG4gICAgdmFyIGJvdW5kRnVuY3Rpb24gPSBiaW5kKGNhbGxiYWNrZm4sIHRoYXQpO1xuICAgIHZhciBsZW5ndGggPSBsZW5ndGhPZkFycmF5TGlrZSQxKHNlbGYpO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGNyZWF0ZSA9IHNwZWNpZmljQ3JlYXRlIHx8IGFycmF5U3BlY2llc0NyZWF0ZTtcbiAgICB2YXIgdGFyZ2V0ID0gSVNfTUFQID8gY3JlYXRlKCR0aGlzLCBsZW5ndGgpIDogSVNfRklMVEVSIHx8IElTX0ZJTFRFUl9SRUpFQ1QgPyBjcmVhdGUoJHRoaXMsIDApIDogdW5kZWZpbmVkO1xuICAgIHZhciB2YWx1ZSwgcmVzdWx0O1xuICAgIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSBpZiAoTk9fSE9MRVMgfHwgaW5kZXggaW4gc2VsZikge1xuICAgICAgdmFsdWUgPSBzZWxmW2luZGV4XTtcbiAgICAgIHJlc3VsdCA9IGJvdW5kRnVuY3Rpb24odmFsdWUsIGluZGV4LCBPKTtcbiAgICAgIGlmIChUWVBFKSB7XG4gICAgICAgIGlmIChJU19NQVApIHRhcmdldFtpbmRleF0gPSByZXN1bHQ7IC8vIG1hcFxuICAgICAgICBlbHNlIGlmIChyZXN1bHQpIHN3aXRjaCAoVFlQRSkge1xuICAgICAgICAgIGNhc2UgMzogcmV0dXJuIHRydWU7ICAgICAgICAgICAgICAvLyBzb21lXG4gICAgICAgICAgY2FzZSA1OiByZXR1cm4gdmFsdWU7ICAgICAgICAgICAgIC8vIGZpbmRcbiAgICAgICAgICBjYXNlIDY6IHJldHVybiBpbmRleDsgICAgICAgICAgICAgLy8gZmluZEluZGV4XG4gICAgICAgICAgY2FzZSAyOiBwdXNoJDEodGFyZ2V0LCB2YWx1ZSk7ICAgICAgLy8gZmlsdGVyXG4gICAgICAgIH0gZWxzZSBzd2l0Y2ggKFRZUEUpIHtcbiAgICAgICAgICBjYXNlIDQ6IHJldHVybiBmYWxzZTsgICAgICAgICAgICAgLy8gZXZlcnlcbiAgICAgICAgICBjYXNlIDc6IHB1c2gkMSh0YXJnZXQsIHZhbHVlKTsgICAgICAvLyBmaWx0ZXJSZWplY3RcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gSVNfRklORF9JTkRFWCA/IC0xIDogSVNfU09NRSB8fCBJU19FVkVSWSA/IElTX0VWRVJZIDogdGFyZ2V0O1xuICB9O1xufTtcblxudmFyIGFycmF5SXRlcmF0aW9uID0ge1xuICAvLyBgQXJyYXkucHJvdG90eXBlLmZvckVhY2hgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5mb3JlYWNoXG4gIGZvckVhY2g6IGNyZWF0ZU1ldGhvZCQxKDApLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLm1hcGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLm1hcFxuICBtYXA6IGNyZWF0ZU1ldGhvZCQxKDEpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmZpbHRlcmAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbHRlclxuICBmaWx0ZXI6IGNyZWF0ZU1ldGhvZCQxKDIpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLnNvbWVgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5zb21lXG4gIHNvbWU6IGNyZWF0ZU1ldGhvZCQxKDMpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmV2ZXJ5YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZXZlcnlcbiAgZXZlcnk6IGNyZWF0ZU1ldGhvZCQxKDQpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmZpbmRgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maW5kXG4gIGZpbmQ6IGNyZWF0ZU1ldGhvZCQxKDUpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmZpbmRJbmRleGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbmRJbmRleFxuICBmaW5kSW5kZXg6IGNyZWF0ZU1ldGhvZCQxKDYpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmZpbHRlclJlamVjdGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWFycmF5LWZpbHRlcmluZ1xuICBmaWx0ZXJSZWplY3Q6IGNyZWF0ZU1ldGhvZCQxKDcpXG59O1xuXG52YXIgaXNDYWxsYWJsZSQxID0gaXNDYWxsYWJsZSRuO1xudmFyIGlzT2JqZWN0JDEgPSBpc09iamVjdCRkO1xudmFyIHNldFByb3RvdHlwZU9mJDEgPSBvYmplY3RTZXRQcm90b3R5cGVPZjtcblxuLy8gbWFrZXMgc3ViY2xhc3Npbmcgd29yayBjb3JyZWN0IGZvciB3cmFwcGVkIGJ1aWx0LWluc1xudmFyIGluaGVyaXRJZlJlcXVpcmVkJDEgPSBmdW5jdGlvbiAoJHRoaXMsIGR1bW15LCBXcmFwcGVyKSB7XG4gIHZhciBOZXdUYXJnZXQsIE5ld1RhcmdldFByb3RvdHlwZTtcbiAgaWYgKFxuICAgIC8vIGl0IGNhbiB3b3JrIG9ubHkgd2l0aCBuYXRpdmUgYHNldFByb3RvdHlwZU9mYFxuICAgIHNldFByb3RvdHlwZU9mJDEgJiZcbiAgICAvLyB3ZSBoYXZlbid0IGNvbXBsZXRlbHkgY29ycmVjdCBwcmUtRVM2IHdheSBmb3IgZ2V0dGluZyBgbmV3LnRhcmdldGAsIHNvIHVzZSB0aGlzXG4gICAgaXNDYWxsYWJsZSQxKE5ld1RhcmdldCA9IGR1bW15LmNvbnN0cnVjdG9yKSAmJlxuICAgIE5ld1RhcmdldCAhPT0gV3JhcHBlciAmJlxuICAgIGlzT2JqZWN0JDEoTmV3VGFyZ2V0UHJvdG90eXBlID0gTmV3VGFyZ2V0LnByb3RvdHlwZSkgJiZcbiAgICBOZXdUYXJnZXRQcm90b3R5cGUgIT09IFdyYXBwZXIucHJvdG90eXBlXG4gICkgc2V0UHJvdG90eXBlT2YkMSgkdGhpcywgTmV3VGFyZ2V0UHJvdG90eXBlKTtcbiAgcmV0dXJuICR0aGlzO1xufTtcblxudmFyICQgPSBfZXhwb3J0O1xudmFyIGdsb2JhbCQ0ID0gZ2xvYmFsJHQ7XG52YXIgY2FsbCQ0ID0gZnVuY3Rpb25DYWxsO1xudmFyIERFU0NSSVBUT1JTID0gZGVzY3JpcHRvcnM7XG52YXIgVFlQRURfQVJSQVlTX0NPTlNUUlVDVE9SU19SRVFVSVJFU19XUkFQUEVSUyA9IHR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNSZXF1aXJlV3JhcHBlcnM7XG52YXIgQXJyYXlCdWZmZXJWaWV3Q29yZSQ0ID0gYXJyYXlCdWZmZXJWaWV3Q29yZTtcbnZhciBBcnJheUJ1ZmZlck1vZHVsZSA9IGFycmF5QnVmZmVyO1xudmFyIGFuSW5zdGFuY2UgPSBhbkluc3RhbmNlJDM7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDU7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDEgPSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkODtcbnZhciBpc0ludGVncmFsTnVtYmVyID0gaXNJbnRlZ3JhbE51bWJlciQxO1xudmFyIHRvTGVuZ3RoJDEgPSB0b0xlbmd0aCQ2O1xudmFyIHRvSW5kZXggPSB0b0luZGV4JDI7XG52YXIgdG9PZmZzZXQkMSA9IHRvT2Zmc2V0JDI7XG52YXIgdG9Qcm9wZXJ0eUtleSA9IHRvUHJvcGVydHlLZXkkNDtcbnZhciBoYXNPd24gPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIGNsYXNzb2YkMiA9IGNsYXNzb2YkOTtcbnZhciBpc09iamVjdCA9IGlzT2JqZWN0JGQ7XG52YXIgaXNTeW1ib2wgPSBpc1N5bWJvbCQzO1xudmFyIGNyZWF0ZSA9IG9iamVjdENyZWF0ZTtcbnZhciBpc1Byb3RvdHlwZU9mID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbnZhciBzZXRQcm90b3R5cGVPZiA9IG9iamVjdFNldFByb3RvdHlwZU9mO1xudmFyIGdldE93blByb3BlcnR5TmFtZXMgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzLmY7XG52YXIgdHlwZWRBcnJheUZyb20gPSB0eXBlZEFycmF5RnJvbSQyO1xudmFyIGZvckVhY2ggPSBhcnJheUl0ZXJhdGlvbi5mb3JFYWNoO1xudmFyIHNldFNwZWNpZXMgPSBzZXRTcGVjaWVzJDI7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSBvYmplY3REZWZpbmVQcm9wZXJ0eTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSA9IGludGVybmFsU3RhdGU7XG52YXIgaW5oZXJpdElmUmVxdWlyZWQgPSBpbmhlcml0SWZSZXF1aXJlZCQxO1xuXG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0O1xudmFyIHNldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLnNldDtcbnZhciBlbmZvcmNlSW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZW5mb3JjZTtcbnZhciBuYXRpdmVEZWZpbmVQcm9wZXJ0eSA9IGRlZmluZVByb3BlcnR5TW9kdWxlLmY7XG52YXIgbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlLmY7XG52YXIgcm91bmQgPSBNYXRoLnJvdW5kO1xudmFyIFJhbmdlRXJyb3IkMiA9IGdsb2JhbCQ0LlJhbmdlRXJyb3I7XG52YXIgQXJyYXlCdWZmZXIkMSA9IEFycmF5QnVmZmVyTW9kdWxlLkFycmF5QnVmZmVyO1xudmFyIEFycmF5QnVmZmVyUHJvdG90eXBlID0gQXJyYXlCdWZmZXIkMS5wcm90b3R5cGU7XG52YXIgRGF0YVZpZXckMSA9IEFycmF5QnVmZmVyTW9kdWxlLkRhdGFWaWV3O1xudmFyIE5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MgPSBBcnJheUJ1ZmZlclZpZXdDb3JlJDQuTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUztcbnZhciBUWVBFRF9BUlJBWV9UQUcgPSBBcnJheUJ1ZmZlclZpZXdDb3JlJDQuVFlQRURfQVJSQVlfVEFHO1xudmFyIFR5cGVkQXJyYXkgPSBBcnJheUJ1ZmZlclZpZXdDb3JlJDQuVHlwZWRBcnJheTtcbnZhciBUeXBlZEFycmF5UHJvdG90eXBlID0gQXJyYXlCdWZmZXJWaWV3Q29yZSQ0LlR5cGVkQXJyYXlQcm90b3R5cGU7XG52YXIgYVR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IEFycmF5QnVmZmVyVmlld0NvcmUkNC5hVHlwZWRBcnJheUNvbnN0cnVjdG9yO1xudmFyIGlzVHlwZWRBcnJheSA9IEFycmF5QnVmZmVyVmlld0NvcmUkNC5pc1R5cGVkQXJyYXk7XG52YXIgQllURVNfUEVSX0VMRU1FTlQgPSAnQllURVNfUEVSX0VMRU1FTlQnO1xudmFyIFdST05HX0xFTkdUSCA9ICdXcm9uZyBsZW5ndGgnO1xuXG52YXIgZnJvbUxpc3QgPSBmdW5jdGlvbiAoQywgbGlzdCkge1xuICBhVHlwZWRBcnJheUNvbnN0cnVjdG9yKEMpO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIHZhciByZXN1bHQgPSBuZXcgQyhsZW5ndGgpO1xuICB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHJlc3VsdFtpbmRleF0gPSBsaXN0W2luZGV4KytdO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxudmFyIGFkZEdldHRlciA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIG5hdGl2ZURlZmluZVByb3BlcnR5KGl0LCBrZXksIHsgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdldEludGVybmFsU3RhdGUodGhpcylba2V5XTtcbiAgfSB9KTtcbn07XG5cbnZhciBpc0FycmF5QnVmZmVyID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBrbGFzcztcbiAgcmV0dXJuIGlzUHJvdG90eXBlT2YoQXJyYXlCdWZmZXJQcm90b3R5cGUsIGl0KSB8fCAoa2xhc3MgPSBjbGFzc29mJDIoaXQpKSA9PSAnQXJyYXlCdWZmZXInIHx8IGtsYXNzID09ICdTaGFyZWRBcnJheUJ1ZmZlcic7XG59O1xuXG52YXIgaXNUeXBlZEFycmF5SW5kZXggPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgcmV0dXJuIGlzVHlwZWRBcnJheSh0YXJnZXQpXG4gICAgJiYgIWlzU3ltYm9sKGtleSlcbiAgICAmJiBrZXkgaW4gdGFyZ2V0XG4gICAgJiYgaXNJbnRlZ3JhbE51bWJlcigra2V5KVxuICAgICYmIGtleSA+PSAwO1xufTtcblxudmFyIHdyYXBwZWRHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIHtcbiAga2V5ID0gdG9Qcm9wZXJ0eUtleShrZXkpO1xuICByZXR1cm4gaXNUeXBlZEFycmF5SW5kZXgodGFyZ2V0LCBrZXkpXG4gICAgPyBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMiwgdGFyZ2V0W2tleV0pXG4gICAgOiBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpO1xufTtcblxudmFyIHdyYXBwZWREZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBkZXNjcmlwdG9yKSB7XG4gIGtleSA9IHRvUHJvcGVydHlLZXkoa2V5KTtcbiAgaWYgKGlzVHlwZWRBcnJheUluZGV4KHRhcmdldCwga2V5KVxuICAgICYmIGlzT2JqZWN0KGRlc2NyaXB0b3IpXG4gICAgJiYgaGFzT3duKGRlc2NyaXB0b3IsICd2YWx1ZScpXG4gICAgJiYgIWhhc093bihkZXNjcmlwdG9yLCAnZ2V0JylcbiAgICAmJiAhaGFzT3duKGRlc2NyaXB0b3IsICdzZXQnKVxuICAgIC8vIFRPRE86IGFkZCB2YWxpZGF0aW9uIGRlc2NyaXB0b3Igdy9vIGNhbGxpbmcgYWNjZXNzb3JzXG4gICAgJiYgIWRlc2NyaXB0b3IuY29uZmlndXJhYmxlXG4gICAgJiYgKCFoYXNPd24oZGVzY3JpcHRvciwgJ3dyaXRhYmxlJykgfHwgZGVzY3JpcHRvci53cml0YWJsZSlcbiAgICAmJiAoIWhhc093bihkZXNjcmlwdG9yLCAnZW51bWVyYWJsZScpIHx8IGRlc2NyaXB0b3IuZW51bWVyYWJsZSlcbiAgKSB7XG4gICAgdGFyZ2V0W2tleV0gPSBkZXNjcmlwdG9yLnZhbHVlO1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH0gcmV0dXJuIG5hdGl2ZURlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBkZXNjcmlwdG9yKTtcbn07XG5cbmlmIChERVNDUklQVE9SUykge1xuICBpZiAoIU5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MpIHtcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUuZiA9IHdyYXBwZWRHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICAgZGVmaW5lUHJvcGVydHlNb2R1bGUuZiA9IHdyYXBwZWREZWZpbmVQcm9wZXJ0eTtcbiAgICBhZGRHZXR0ZXIoVHlwZWRBcnJheVByb3RvdHlwZSwgJ2J1ZmZlcicpO1xuICAgIGFkZEdldHRlcihUeXBlZEFycmF5UHJvdG90eXBlLCAnYnl0ZU9mZnNldCcpO1xuICAgIGFkZEdldHRlcihUeXBlZEFycmF5UHJvdG90eXBlLCAnYnl0ZUxlbmd0aCcpO1xuICAgIGFkZEdldHRlcihUeXBlZEFycmF5UHJvdG90eXBlLCAnbGVuZ3RoJyk7XG4gIH1cblxuICAkKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiAhTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyB9LCB7XG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiB3cmFwcGVkR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICAgIGRlZmluZVByb3BlcnR5OiB3cmFwcGVkRGVmaW5lUHJvcGVydHlcbiAgfSk7XG5cbiAgdHlwZWRBcnJheUNvbnN0cnVjdG9yLmV4cG9ydHMgPSBmdW5jdGlvbiAoVFlQRSwgd3JhcHBlciwgQ0xBTVBFRCkge1xuICAgIHZhciBCWVRFUyA9IFRZUEUubWF0Y2goL1xcZCskLylbMF0gLyA4O1xuICAgIHZhciBDT05TVFJVQ1RPUl9OQU1FID0gVFlQRSArIChDTEFNUEVEID8gJ0NsYW1wZWQnIDogJycpICsgJ0FycmF5JztcbiAgICB2YXIgR0VUVEVSID0gJ2dldCcgKyBUWVBFO1xuICAgIHZhciBTRVRURVIgPSAnc2V0JyArIFRZUEU7XG4gICAgdmFyIE5hdGl2ZVR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IGdsb2JhbCQ0W0NPTlNUUlVDVE9SX05BTUVdO1xuICAgIHZhciBUeXBlZEFycmF5Q29uc3RydWN0b3IgPSBOYXRpdmVUeXBlZEFycmF5Q29uc3RydWN0b3I7XG4gICAgdmFyIFR5cGVkQXJyYXlDb25zdHJ1Y3RvclByb3RvdHlwZSA9IFR5cGVkQXJyYXlDb25zdHJ1Y3RvciAmJiBUeXBlZEFycmF5Q29uc3RydWN0b3IucHJvdG90eXBlO1xuICAgIHZhciBleHBvcnRlZCA9IHt9O1xuXG4gICAgdmFyIGdldHRlciA9IGZ1bmN0aW9uICh0aGF0LCBpbmRleCkge1xuICAgICAgdmFyIGRhdGEgPSBnZXRJbnRlcm5hbFN0YXRlKHRoYXQpO1xuICAgICAgcmV0dXJuIGRhdGEudmlld1tHRVRURVJdKGluZGV4ICogQllURVMgKyBkYXRhLmJ5dGVPZmZzZXQsIHRydWUpO1xuICAgIH07XG5cbiAgICB2YXIgc2V0dGVyID0gZnVuY3Rpb24gKHRoYXQsIGluZGV4LCB2YWx1ZSkge1xuICAgICAgdmFyIGRhdGEgPSBnZXRJbnRlcm5hbFN0YXRlKHRoYXQpO1xuICAgICAgaWYgKENMQU1QRUQpIHZhbHVlID0gKHZhbHVlID0gcm91bmQodmFsdWUpKSA8IDAgPyAwIDogdmFsdWUgPiAweEZGID8gMHhGRiA6IHZhbHVlICYgMHhGRjtcbiAgICAgIGRhdGEudmlld1tTRVRURVJdKGluZGV4ICogQllURVMgKyBkYXRhLmJ5dGVPZmZzZXQsIHZhbHVlLCB0cnVlKTtcbiAgICB9O1xuXG4gICAgdmFyIGFkZEVsZW1lbnQgPSBmdW5jdGlvbiAodGhhdCwgaW5kZXgpIHtcbiAgICAgIG5hdGl2ZURlZmluZVByb3BlcnR5KHRoYXQsIGluZGV4LCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBnZXR0ZXIodGhpcywgaW5kZXgpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBzZXR0ZXIodGhpcywgaW5kZXgsIHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGlmICghTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUykge1xuICAgICAgVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gd3JhcHBlcihmdW5jdGlvbiAodGhhdCwgZGF0YSwgb2Zmc2V0LCAkbGVuZ3RoKSB7XG4gICAgICAgIGFuSW5zdGFuY2UodGhhdCwgVHlwZWRBcnJheUNvbnN0cnVjdG9yUHJvdG90eXBlKTtcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgdmFyIGJ5dGVPZmZzZXQgPSAwO1xuICAgICAgICB2YXIgYnVmZmVyLCBieXRlTGVuZ3RoLCBsZW5ndGg7XG4gICAgICAgIGlmICghaXNPYmplY3QoZGF0YSkpIHtcbiAgICAgICAgICBsZW5ndGggPSB0b0luZGV4KGRhdGEpO1xuICAgICAgICAgIGJ5dGVMZW5ndGggPSBsZW5ndGggKiBCWVRFUztcbiAgICAgICAgICBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIkMShieXRlTGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5QnVmZmVyKGRhdGEpKSB7XG4gICAgICAgICAgYnVmZmVyID0gZGF0YTtcbiAgICAgICAgICBieXRlT2Zmc2V0ID0gdG9PZmZzZXQkMShvZmZzZXQsIEJZVEVTKTtcbiAgICAgICAgICB2YXIgJGxlbiA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgICBpZiAoJGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoJGxlbiAlIEJZVEVTKSB0aHJvdyBSYW5nZUVycm9yJDIoV1JPTkdfTEVOR1RIKTtcbiAgICAgICAgICAgIGJ5dGVMZW5ndGggPSAkbGVuIC0gYnl0ZU9mZnNldDtcbiAgICAgICAgICAgIGlmIChieXRlTGVuZ3RoIDwgMCkgdGhyb3cgUmFuZ2VFcnJvciQyKFdST05HX0xFTkdUSCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ5dGVMZW5ndGggPSB0b0xlbmd0aCQxKCRsZW5ndGgpICogQllURVM7XG4gICAgICAgICAgICBpZiAoYnl0ZUxlbmd0aCArIGJ5dGVPZmZzZXQgPiAkbGVuKSB0aHJvdyBSYW5nZUVycm9yJDIoV1JPTkdfTEVOR1RIKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGVuZ3RoID0gYnl0ZUxlbmd0aCAvIEJZVEVTO1xuICAgICAgICB9IGVsc2UgaWYgKGlzVHlwZWRBcnJheShkYXRhKSkge1xuICAgICAgICAgIHJldHVybiBmcm9tTGlzdChUeXBlZEFycmF5Q29uc3RydWN0b3IsIGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBjYWxsJDQodHlwZWRBcnJheUZyb20sIFR5cGVkQXJyYXlDb25zdHJ1Y3RvciwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0SW50ZXJuYWxTdGF0ZSh0aGF0LCB7XG4gICAgICAgICAgYnVmZmVyOiBidWZmZXIsXG4gICAgICAgICAgYnl0ZU9mZnNldDogYnl0ZU9mZnNldCxcbiAgICAgICAgICBieXRlTGVuZ3RoOiBieXRlTGVuZ3RoLFxuICAgICAgICAgIGxlbmd0aDogbGVuZ3RoLFxuICAgICAgICAgIHZpZXc6IG5ldyBEYXRhVmlldyQxKGJ1ZmZlcilcbiAgICAgICAgfSk7XG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkgYWRkRWxlbWVudCh0aGF0LCBpbmRleCsrKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoc2V0UHJvdG90eXBlT2YpIHNldFByb3RvdHlwZU9mKFR5cGVkQXJyYXlDb25zdHJ1Y3RvciwgVHlwZWRBcnJheSk7XG4gICAgICBUeXBlZEFycmF5Q29uc3RydWN0b3JQcm90b3R5cGUgPSBUeXBlZEFycmF5Q29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlKFR5cGVkQXJyYXlQcm90b3R5cGUpO1xuICAgIH0gZWxzZSBpZiAoVFlQRURfQVJSQVlTX0NPTlNUUlVDVE9SU19SRVFVSVJFU19XUkFQUEVSUykge1xuICAgICAgVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gd3JhcHBlcihmdW5jdGlvbiAoZHVtbXksIGRhdGEsIHR5cGVkQXJyYXlPZmZzZXQsICRsZW5ndGgpIHtcbiAgICAgICAgYW5JbnN0YW5jZShkdW1teSwgVHlwZWRBcnJheUNvbnN0cnVjdG9yUHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIGluaGVyaXRJZlJlcXVpcmVkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoIWlzT2JqZWN0KGRhdGEpKSByZXR1cm4gbmV3IE5hdGl2ZVR5cGVkQXJyYXlDb25zdHJ1Y3Rvcih0b0luZGV4KGRhdGEpKTtcbiAgICAgICAgICBpZiAoaXNBcnJheUJ1ZmZlcihkYXRhKSkgcmV0dXJuICRsZW5ndGggIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBuZXcgTmF0aXZlVHlwZWRBcnJheUNvbnN0cnVjdG9yKGRhdGEsIHRvT2Zmc2V0JDEodHlwZWRBcnJheU9mZnNldCwgQllURVMpLCAkbGVuZ3RoKVxuICAgICAgICAgICAgOiB0eXBlZEFycmF5T2Zmc2V0ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgPyBuZXcgTmF0aXZlVHlwZWRBcnJheUNvbnN0cnVjdG9yKGRhdGEsIHRvT2Zmc2V0JDEodHlwZWRBcnJheU9mZnNldCwgQllURVMpKVxuICAgICAgICAgICAgICA6IG5ldyBOYXRpdmVUeXBlZEFycmF5Q29uc3RydWN0b3IoZGF0YSk7XG4gICAgICAgICAgaWYgKGlzVHlwZWRBcnJheShkYXRhKSkgcmV0dXJuIGZyb21MaXN0KFR5cGVkQXJyYXlDb25zdHJ1Y3RvciwgZGF0YSk7XG4gICAgICAgICAgcmV0dXJuIGNhbGwkNCh0eXBlZEFycmF5RnJvbSwgVHlwZWRBcnJheUNvbnN0cnVjdG9yLCBkYXRhKTtcbiAgICAgICAgfSgpLCBkdW1teSwgVHlwZWRBcnJheUNvbnN0cnVjdG9yKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoc2V0UHJvdG90eXBlT2YpIHNldFByb3RvdHlwZU9mKFR5cGVkQXJyYXlDb25zdHJ1Y3RvciwgVHlwZWRBcnJheSk7XG4gICAgICBmb3JFYWNoKGdldE93blByb3BlcnR5TmFtZXMoTmF0aXZlVHlwZWRBcnJheUNvbnN0cnVjdG9yKSwgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoIShrZXkgaW4gVHlwZWRBcnJheUNvbnN0cnVjdG9yKSkge1xuICAgICAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQxKFR5cGVkQXJyYXlDb25zdHJ1Y3Rvciwga2V5LCBOYXRpdmVUeXBlZEFycmF5Q29uc3RydWN0b3Jba2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgVHlwZWRBcnJheUNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IFR5cGVkQXJyYXlDb25zdHJ1Y3RvclByb3RvdHlwZTtcbiAgICB9XG5cbiAgICBpZiAoVHlwZWRBcnJheUNvbnN0cnVjdG9yUHJvdG90eXBlLmNvbnN0cnVjdG9yICE9PSBUeXBlZEFycmF5Q29uc3RydWN0b3IpIHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQxKFR5cGVkQXJyYXlDb25zdHJ1Y3RvclByb3RvdHlwZSwgJ2NvbnN0cnVjdG9yJywgVHlwZWRBcnJheUNvbnN0cnVjdG9yKTtcbiAgICB9XG5cbiAgICBlbmZvcmNlSW50ZXJuYWxTdGF0ZShUeXBlZEFycmF5Q29uc3RydWN0b3JQcm90b3R5cGUpLlR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IFR5cGVkQXJyYXlDb25zdHJ1Y3RvcjtcblxuICAgIGlmIChUWVBFRF9BUlJBWV9UQUcpIHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQxKFR5cGVkQXJyYXlDb25zdHJ1Y3RvclByb3RvdHlwZSwgVFlQRURfQVJSQVlfVEFHLCBDT05TVFJVQ1RPUl9OQU1FKTtcbiAgICB9XG5cbiAgICB2YXIgRk9SQ0VEID0gVHlwZWRBcnJheUNvbnN0cnVjdG9yICE9IE5hdGl2ZVR5cGVkQXJyYXlDb25zdHJ1Y3RvcjtcblxuICAgIGV4cG9ydGVkW0NPTlNUUlVDVE9SX05BTUVdID0gVHlwZWRBcnJheUNvbnN0cnVjdG9yO1xuXG4gICAgJCh7IGdsb2JhbDogdHJ1ZSwgY29uc3RydWN0b3I6IHRydWUsIGZvcmNlZDogRk9SQ0VELCBzaGFtOiAhTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyB9LCBleHBvcnRlZCk7XG5cbiAgICBpZiAoIShCWVRFU19QRVJfRUxFTUVOVCBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3IpKSB7XG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMShUeXBlZEFycmF5Q29uc3RydWN0b3IsIEJZVEVTX1BFUl9FTEVNRU5ULCBCWVRFUyk7XG4gICAgfVxuXG4gICAgaWYgKCEoQllURVNfUEVSX0VMRU1FTlQgaW4gVHlwZWRBcnJheUNvbnN0cnVjdG9yUHJvdG90eXBlKSkge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDEoVHlwZWRBcnJheUNvbnN0cnVjdG9yUHJvdG90eXBlLCBCWVRFU19QRVJfRUxFTUVOVCwgQllURVMpO1xuICAgIH1cblxuICAgIHNldFNwZWNpZXMoQ09OU1RSVUNUT1JfTkFNRSk7XG4gIH07XG59IGVsc2UgdHlwZWRBcnJheUNvbnN0cnVjdG9yLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG5cbnZhciBjcmVhdGVUeXBlZEFycmF5Q29uc3RydWN0b3IgPSB0eXBlZEFycmF5Q29uc3RydWN0b3IuZXhwb3J0cztcblxuLy8gYFVpbnQ4QXJyYXlgIGNvbnN0cnVjdG9yXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXR5cGVkYXJyYXktb2JqZWN0c1xuY3JlYXRlVHlwZWRBcnJheUNvbnN0cnVjdG9yKCdVaW50OCcsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBVaW50OEFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcblxudmFyIHRvUHJpbWl0aXZlID0gdG9QcmltaXRpdmUkMjtcblxudmFyICRUeXBlRXJyb3IkMSA9IFR5cGVFcnJvcjtcblxuLy8gYFRvQmlnSW50YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9iaWdpbnRcbnZhciB0b0JpZ0ludCQxID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHZhciBwcmltID0gdG9QcmltaXRpdmUoYXJndW1lbnQsICdudW1iZXInKTtcbiAgaWYgKHR5cGVvZiBwcmltID09ICdudW1iZXInKSB0aHJvdyAkVHlwZUVycm9yJDEoXCJDYW4ndCBjb252ZXJ0IG51bWJlciB0byBiaWdpbnRcIik7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLWJpZ2ludCAtLSBzYWZlXG4gIHJldHVybiBCaWdJbnQocHJpbSk7XG59O1xuXG52YXIgQXJyYXlCdWZmZXJWaWV3Q29yZSQzID0gYXJyYXlCdWZmZXJWaWV3Q29yZTtcbnZhciAkZmlsbCA9IGFycmF5RmlsbCQxO1xudmFyIHRvQmlnSW50ID0gdG9CaWdJbnQkMTtcbnZhciBjbGFzc29mJDEgPSBjbGFzc29mJDk7XG52YXIgY2FsbCQzID0gZnVuY3Rpb25DYWxsO1xudmFyIHVuY3VycnlUaGlzJDQgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGZhaWxzJDUgPSBmYWlscyRzO1xuXG52YXIgYVR5cGVkQXJyYXkkMyA9IEFycmF5QnVmZmVyVmlld0NvcmUkMy5hVHlwZWRBcnJheTtcbnZhciBleHBvcnRUeXBlZEFycmF5TWV0aG9kJDMgPSBBcnJheUJ1ZmZlclZpZXdDb3JlJDMuZXhwb3J0VHlwZWRBcnJheU1ldGhvZDtcbnZhciBzbGljZSA9IHVuY3VycnlUaGlzJDQoJycuc2xpY2UpO1xuXG4vLyBWOCB+IENocm9tZSA8IDU5LCBTYWZhcmkgPCAxNC4xLCBGRiA8IDU1LCBFZGdlIDw9MThcbnZhciBDT05WRVJTSU9OX0JVRyA9IGZhaWxzJDUoZnVuY3Rpb24gKCkge1xuICB2YXIgY291bnQgPSAwO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby10eXBlZC1hcnJheXMgLS0gc2FmZVxuICBuZXcgSW50OEFycmF5KDIpLmZpbGwoeyB2YWx1ZU9mOiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb3VudCsrOyB9IH0pO1xuICByZXR1cm4gY291bnQgIT09IDE7XG59KTtcblxuLy8gYCVUeXBlZEFycmF5JS5wcm90b3R5cGUuZmlsbGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSV0eXBlZGFycmF5JS5wcm90b3R5cGUuZmlsbFxuZXhwb3J0VHlwZWRBcnJheU1ldGhvZCQzKCdmaWxsJywgZnVuY3Rpb24gZmlsbCh2YWx1ZSAvKiAsIHN0YXJ0LCBlbmQgKi8pIHtcbiAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIGFUeXBlZEFycmF5JDModGhpcyk7XG4gIHZhciBhY3R1YWxWYWx1ZSA9IHNsaWNlKGNsYXNzb2YkMSh0aGlzKSwgMCwgMykgPT09ICdCaWcnID8gdG9CaWdJbnQodmFsdWUpIDogK3ZhbHVlO1xuICByZXR1cm4gY2FsbCQzKCRmaWxsLCB0aGlzLCBhY3R1YWxWYWx1ZSwgbGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgbGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCk7XG59LCBDT05WRVJTSU9OX0JVRyk7XG5cbnZhciBnbG9iYWwkMyA9IGdsb2JhbCR0O1xudmFyIGNhbGwkMiA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBBcnJheUJ1ZmZlclZpZXdDb3JlJDIgPSBhcnJheUJ1ZmZlclZpZXdDb3JlO1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlID0gbGVuZ3RoT2ZBcnJheUxpa2UkODtcbnZhciB0b09mZnNldCA9IHRvT2Zmc2V0JDI7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gdG9PYmplY3QkNztcbnZhciBmYWlscyQ0ID0gZmFpbHMkcztcblxudmFyIFJhbmdlRXJyb3IkMSA9IGdsb2JhbCQzLlJhbmdlRXJyb3I7XG52YXIgSW50OEFycmF5JDIgPSBnbG9iYWwkMy5JbnQ4QXJyYXk7XG52YXIgSW50OEFycmF5UHJvdG90eXBlID0gSW50OEFycmF5JDIgJiYgSW50OEFycmF5JDIucHJvdG90eXBlO1xudmFyICRzZXQgPSBJbnQ4QXJyYXlQcm90b3R5cGUgJiYgSW50OEFycmF5UHJvdG90eXBlLnNldDtcbnZhciBhVHlwZWRBcnJheSQyID0gQXJyYXlCdWZmZXJWaWV3Q29yZSQyLmFUeXBlZEFycmF5O1xudmFyIGV4cG9ydFR5cGVkQXJyYXlNZXRob2QkMiA9IEFycmF5QnVmZmVyVmlld0NvcmUkMi5leHBvcnRUeXBlZEFycmF5TWV0aG9kO1xuXG52YXIgV09SS1NfV0lUSF9PQkpFQ1RTX0FORF9HRUVSSUNfT05fVFlQRURfQVJSQVlTID0gIWZhaWxzJDQoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby10eXBlZC1hcnJheXMgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgdmFyIGFycmF5ID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KDIpO1xuICBjYWxsJDIoJHNldCwgYXJyYXksIHsgbGVuZ3RoOiAxLCAwOiAzIH0sIDEpO1xuICByZXR1cm4gYXJyYXlbMV0gIT09IDM7XG59KTtcblxuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MTEyOTQgYW5kIG90aGVyXG52YXIgVE9fT0JKRUNUX0JVRyA9IFdPUktTX1dJVEhfT0JKRUNUU19BTkRfR0VFUklDX09OX1RZUEVEX0FSUkFZUyAmJiBBcnJheUJ1ZmZlclZpZXdDb3JlJDIuTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyAmJiBmYWlscyQ0KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFycmF5ID0gbmV3IEludDhBcnJheSQyKDIpO1xuICBhcnJheS5zZXQoMSk7XG4gIGFycmF5LnNldCgnMicsIDEpO1xuICByZXR1cm4gYXJyYXlbMF0gIT09IDAgfHwgYXJyYXlbMV0gIT09IDI7XG59KTtcblxuLy8gYCVUeXBlZEFycmF5JS5wcm90b3R5cGUuc2V0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS5zZXRcbmV4cG9ydFR5cGVkQXJyYXlNZXRob2QkMignc2V0JywgZnVuY3Rpb24gc2V0KGFycmF5TGlrZSAvKiAsIG9mZnNldCAqLykge1xuICBhVHlwZWRBcnJheSQyKHRoaXMpO1xuICB2YXIgb2Zmc2V0ID0gdG9PZmZzZXQoYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIDEpO1xuICB2YXIgc3JjID0gdG9JbmRleGVkT2JqZWN0KGFycmF5TGlrZSk7XG4gIGlmIChXT1JLU19XSVRIX09CSkVDVFNfQU5EX0dFRVJJQ19PTl9UWVBFRF9BUlJBWVMpIHJldHVybiBjYWxsJDIoJHNldCwgdGhpcywgc3JjLCBvZmZzZXQpO1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gIHZhciBsZW4gPSBsZW5ndGhPZkFycmF5TGlrZShzcmMpO1xuICB2YXIgaW5kZXggPSAwO1xuICBpZiAobGVuICsgb2Zmc2V0ID4gbGVuZ3RoKSB0aHJvdyBSYW5nZUVycm9yJDEoJ1dyb25nIGxlbmd0aCcpO1xuICB3aGlsZSAoaW5kZXggPCBsZW4pIHRoaXNbb2Zmc2V0ICsgaW5kZXhdID0gc3JjW2luZGV4KytdO1xufSwgIVdPUktTX1dJVEhfT0JKRUNUU19BTkRfR0VFUklDX09OX1RZUEVEX0FSUkFZUyB8fCBUT19PQkpFQ1RfQlVHKTtcblxudmFyIGFycmF5U2xpY2UkMiA9IGFycmF5U2xpY2VTaW1wbGU7XG5cbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5cbnZhciBtZXJnZVNvcnQgPSBmdW5jdGlvbiAoYXJyYXksIGNvbXBhcmVmbikge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB2YXIgbWlkZGxlID0gZmxvb3IobGVuZ3RoIC8gMik7XG4gIHJldHVybiBsZW5ndGggPCA4ID8gaW5zZXJ0aW9uU29ydChhcnJheSwgY29tcGFyZWZuKSA6IG1lcmdlKFxuICAgIGFycmF5LFxuICAgIG1lcmdlU29ydChhcnJheVNsaWNlJDIoYXJyYXksIDAsIG1pZGRsZSksIGNvbXBhcmVmbiksXG4gICAgbWVyZ2VTb3J0KGFycmF5U2xpY2UkMihhcnJheSwgbWlkZGxlKSwgY29tcGFyZWZuKSxcbiAgICBjb21wYXJlZm5cbiAgKTtcbn07XG5cbnZhciBpbnNlcnRpb25Tb3J0ID0gZnVuY3Rpb24gKGFycmF5LCBjb21wYXJlZm4pIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgdmFyIGkgPSAxO1xuICB2YXIgZWxlbWVudCwgajtcblxuICB3aGlsZSAoaSA8IGxlbmd0aCkge1xuICAgIGogPSBpO1xuICAgIGVsZW1lbnQgPSBhcnJheVtpXTtcbiAgICB3aGlsZSAoaiAmJiBjb21wYXJlZm4oYXJyYXlbaiAtIDFdLCBlbGVtZW50KSA+IDApIHtcbiAgICAgIGFycmF5W2pdID0gYXJyYXlbLS1qXTtcbiAgICB9XG4gICAgaWYgKGogIT09IGkrKykgYXJyYXlbal0gPSBlbGVtZW50O1xuICB9IHJldHVybiBhcnJheTtcbn07XG5cbnZhciBtZXJnZSA9IGZ1bmN0aW9uIChhcnJheSwgbGVmdCwgcmlnaHQsIGNvbXBhcmVmbikge1xuICB2YXIgbGxlbmd0aCA9IGxlZnQubGVuZ3RoO1xuICB2YXIgcmxlbmd0aCA9IHJpZ2h0Lmxlbmd0aDtcbiAgdmFyIGxpbmRleCA9IDA7XG4gIHZhciByaW5kZXggPSAwO1xuXG4gIHdoaWxlIChsaW5kZXggPCBsbGVuZ3RoIHx8IHJpbmRleCA8IHJsZW5ndGgpIHtcbiAgICBhcnJheVtsaW5kZXggKyByaW5kZXhdID0gKGxpbmRleCA8IGxsZW5ndGggJiYgcmluZGV4IDwgcmxlbmd0aClcbiAgICAgID8gY29tcGFyZWZuKGxlZnRbbGluZGV4XSwgcmlnaHRbcmluZGV4XSkgPD0gMCA/IGxlZnRbbGluZGV4KytdIDogcmlnaHRbcmluZGV4KytdXG4gICAgICA6IGxpbmRleCA8IGxsZW5ndGggPyBsZWZ0W2xpbmRleCsrXSA6IHJpZ2h0W3JpbmRleCsrXTtcbiAgfSByZXR1cm4gYXJyYXk7XG59O1xuXG52YXIgYXJyYXlTb3J0ID0gbWVyZ2VTb3J0O1xuXG52YXIgdXNlckFnZW50JDEgPSBlbmdpbmVVc2VyQWdlbnQ7XG5cbnZhciBmaXJlZm94ID0gdXNlckFnZW50JDEubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvaSk7XG5cbnZhciBlbmdpbmVGZlZlcnNpb24gPSAhIWZpcmVmb3ggJiYgK2ZpcmVmb3hbMV07XG5cbnZhciBVQSA9IGVuZ2luZVVzZXJBZ2VudDtcblxudmFyIGVuZ2luZUlzSWVPckVkZ2UgPSAvTVNJRXxUcmlkZW50Ly50ZXN0KFVBKTtcblxudmFyIHVzZXJBZ2VudCA9IGVuZ2luZVVzZXJBZ2VudDtcblxudmFyIHdlYmtpdCA9IHVzZXJBZ2VudC5tYXRjaCgvQXBwbGVXZWJLaXRcXC8oXFxkKylcXC4vKTtcblxudmFyIGVuZ2luZVdlYmtpdFZlcnNpb24gPSAhIXdlYmtpdCAmJiArd2Via2l0WzFdO1xuXG52YXIgZ2xvYmFsJDIgPSBnbG9iYWwkdDtcbnZhciB1bmN1cnJ5VGhpcyQzID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBmYWlscyQzID0gZmFpbHMkcztcbnZhciBhQ2FsbGFibGUgPSBhQ2FsbGFibGUkOTtcbnZhciBpbnRlcm5hbFNvcnQgPSBhcnJheVNvcnQ7XG52YXIgQXJyYXlCdWZmZXJWaWV3Q29yZSQxID0gYXJyYXlCdWZmZXJWaWV3Q29yZTtcbnZhciBGRiA9IGVuZ2luZUZmVmVyc2lvbjtcbnZhciBJRV9PUl9FREdFID0gZW5naW5lSXNJZU9yRWRnZTtcbnZhciBWOCA9IGVuZ2luZVY4VmVyc2lvbjtcbnZhciBXRUJLSVQgPSBlbmdpbmVXZWJraXRWZXJzaW9uO1xuXG52YXIgYVR5cGVkQXJyYXkkMSA9IEFycmF5QnVmZmVyVmlld0NvcmUkMS5hVHlwZWRBcnJheTtcbnZhciBleHBvcnRUeXBlZEFycmF5TWV0aG9kJDEgPSBBcnJheUJ1ZmZlclZpZXdDb3JlJDEuZXhwb3J0VHlwZWRBcnJheU1ldGhvZDtcbnZhciBVaW50MTZBcnJheSA9IGdsb2JhbCQyLlVpbnQxNkFycmF5O1xudmFyIHVuJFNvcnQgPSBVaW50MTZBcnJheSAmJiB1bmN1cnJ5VGhpcyQzKFVpbnQxNkFycmF5LnByb3RvdHlwZS5zb3J0KTtcblxuLy8gV2ViS2l0XG52YXIgQUNDRVBUX0lOQ09SUkVDVF9BUkdVTUVOVFMgPSAhIXVuJFNvcnQgJiYgIShmYWlscyQzKGZ1bmN0aW9uICgpIHtcbiAgdW4kU29ydChuZXcgVWludDE2QXJyYXkoMiksIG51bGwpO1xufSkgJiYgZmFpbHMkMyhmdW5jdGlvbiAoKSB7XG4gIHVuJFNvcnQobmV3IFVpbnQxNkFycmF5KDIpLCB7fSk7XG59KSk7XG5cbnZhciBTVEFCTEVfU09SVCA9ICEhdW4kU29ydCAmJiAhZmFpbHMkMyhmdW5jdGlvbiAoKSB7XG4gIC8vIGZlYXR1cmUgZGV0ZWN0aW9uIGNhbiBiZSB0b28gc2xvdywgc28gY2hlY2sgZW5naW5lcyB2ZXJzaW9uc1xuICBpZiAoVjgpIHJldHVybiBWOCA8IDc0O1xuICBpZiAoRkYpIHJldHVybiBGRiA8IDY3O1xuICBpZiAoSUVfT1JfRURHRSkgcmV0dXJuIHRydWU7XG4gIGlmIChXRUJLSVQpIHJldHVybiBXRUJLSVQgPCA2MDI7XG5cbiAgdmFyIGFycmF5ID0gbmV3IFVpbnQxNkFycmF5KDUxNik7XG4gIHZhciBleHBlY3RlZCA9IEFycmF5KDUxNik7XG4gIHZhciBpbmRleCwgbW9kO1xuXG4gIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IDUxNjsgaW5kZXgrKykge1xuICAgIG1vZCA9IGluZGV4ICUgNDtcbiAgICBhcnJheVtpbmRleF0gPSA1MTUgLSBpbmRleDtcbiAgICBleHBlY3RlZFtpbmRleF0gPSBpbmRleCAtIDIgKiBtb2QgKyAzO1xuICB9XG5cbiAgdW4kU29ydChhcnJheSwgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gKGEgLyA0IHwgMCkgLSAoYiAvIDQgfCAwKTtcbiAgfSk7XG5cbiAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgNTE2OyBpbmRleCsrKSB7XG4gICAgaWYgKGFycmF5W2luZGV4XSAhPT0gZXhwZWN0ZWRbaW5kZXhdKSByZXR1cm4gdHJ1ZTtcbiAgfVxufSk7XG5cbnZhciBnZXRTb3J0Q29tcGFyZSA9IGZ1bmN0aW9uIChjb21wYXJlZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgaWYgKGNvbXBhcmVmbiAhPT0gdW5kZWZpbmVkKSByZXR1cm4gK2NvbXBhcmVmbih4LCB5KSB8fCAwO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG4gICAgaWYgKHkgIT09IHkpIHJldHVybiAtMTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xuICAgIGlmICh4ICE9PSB4KSByZXR1cm4gMTtcbiAgICBpZiAoeCA9PT0gMCAmJiB5ID09PSAwKSByZXR1cm4gMSAvIHggPiAwICYmIDEgLyB5IDwgMCA/IDEgOiAtMTtcbiAgICByZXR1cm4geCA+IHk7XG4gIH07XG59O1xuXG4vLyBgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5zb3J0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS5zb3J0XG5leHBvcnRUeXBlZEFycmF5TWV0aG9kJDEoJ3NvcnQnLCBmdW5jdGlvbiBzb3J0KGNvbXBhcmVmbikge1xuICBpZiAoY29tcGFyZWZuICE9PSB1bmRlZmluZWQpIGFDYWxsYWJsZShjb21wYXJlZm4pO1xuICBpZiAoU1RBQkxFX1NPUlQpIHJldHVybiB1biRTb3J0KHRoaXMsIGNvbXBhcmVmbik7XG5cbiAgcmV0dXJuIGludGVybmFsU29ydChhVHlwZWRBcnJheSQxKHRoaXMpLCBnZXRTb3J0Q29tcGFyZShjb21wYXJlZm4pKTtcbn0sICFTVEFCTEVfU09SVCB8fCBBQ0NFUFRfSU5DT1JSRUNUX0FSR1VNRU5UUyk7XG5cbnZhciBnbG9iYWwkMSA9IGdsb2JhbCR0O1xudmFyIGFwcGx5JDEgPSBmdW5jdGlvbkFwcGx5O1xudmFyIEFycmF5QnVmZmVyVmlld0NvcmUgPSBhcnJheUJ1ZmZlclZpZXdDb3JlO1xudmFyIGZhaWxzJDIgPSBmYWlscyRzO1xudmFyIGFycmF5U2xpY2UkMSA9IGFycmF5U2xpY2UkNTtcblxudmFyIEludDhBcnJheSQxID0gZ2xvYmFsJDEuSW50OEFycmF5O1xudmFyIGFUeXBlZEFycmF5ID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5hVHlwZWRBcnJheTtcbnZhciBleHBvcnRUeXBlZEFycmF5TWV0aG9kID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRUeXBlZEFycmF5TWV0aG9kO1xudmFyICR0b0xvY2FsZVN0cmluZyA9IFtdLnRvTG9jYWxlU3RyaW5nO1xuXG4vLyBpT1MgU2FmYXJpIDYueCBmYWlscyBoZXJlXG52YXIgVE9fTE9DQUxFX1NUUklOR19CVUcgPSAhIUludDhBcnJheSQxICYmIGZhaWxzJDIoZnVuY3Rpb24gKCkge1xuICAkdG9Mb2NhbGVTdHJpbmcuY2FsbChuZXcgSW50OEFycmF5JDEoMSkpO1xufSk7XG5cbnZhciBGT1JDRUQgPSBmYWlscyQyKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIFsxLCAyXS50b0xvY2FsZVN0cmluZygpICE9IG5ldyBJbnQ4QXJyYXkkMShbMSwgMl0pLnRvTG9jYWxlU3RyaW5nKCk7XG59KSB8fCAhZmFpbHMkMihmdW5jdGlvbiAoKSB7XG4gIEludDhBcnJheSQxLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZy5jYWxsKFsxLCAyXSk7XG59KTtcblxuLy8gYCVUeXBlZEFycmF5JS5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmdgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0ldHlwZWRhcnJheSUucHJvdG90eXBlLnRvbG9jYWxlc3RyaW5nXG5leHBvcnRUeXBlZEFycmF5TWV0aG9kKCd0b0xvY2FsZVN0cmluZycsIGZ1bmN0aW9uIHRvTG9jYWxlU3RyaW5nKCkge1xuICByZXR1cm4gYXBwbHkkMShcbiAgICAkdG9Mb2NhbGVTdHJpbmcsXG4gICAgVE9fTE9DQUxFX1NUUklOR19CVUcgPyBhcnJheVNsaWNlJDEoYVR5cGVkQXJyYXkodGhpcykpIDogYVR5cGVkQXJyYXkodGhpcyksXG4gICAgYXJyYXlTbGljZSQxKGFyZ3VtZW50cylcbiAgKTtcbn0sIEZPUkNFRCk7XG5cbmNsYXNzIFBheWxvYWQge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgLy8gVGhlIHRhZydzIHZhbHVlIGlzIGEgaGFyZGNvZGVkIHZhbHVlIGFzIHBlclxuICAgIC8vIGRlZmluZWQgaW4gdGhlIE5FUCBbTkVQNDEzXShodHRwczovL2dpdGh1Yi5jb20vbmVhci9ORVBzL2Jsb2IvbWFzdGVyL25lcHMvbmVwLTA0MTMubWQpXG4gICAgdGhpcy50YWcgPSAyMTQ3NDg0MDYxO1xuICAgIHRoaXMubWVzc2FnZSA9IGRhdGEubWVzc2FnZTtcbiAgICB0aGlzLm5vbmNlID0gZGF0YS5ub25jZTtcbiAgICB0aGlzLnJlY2lwaWVudCA9IGRhdGEucmVjaXBpZW50O1xuICAgIGlmIChkYXRhLmNhbGxiYWNrVXJsKSB7XG4gICAgICB0aGlzLmNhbGxiYWNrVXJsID0gZGF0YS5jYWxsYmFja1VybDtcbiAgICB9XG4gIH1cbn1cbmNvbnN0IHBheWxvYWRTY2hlbWEgPSBuZXcgTWFwKFtbUGF5bG9hZCwge1xuICBraW5kOiBcInN0cnVjdFwiLFxuICBmaWVsZHM6IFtbXCJ0YWdcIiwgXCJ1MzJcIl0sIFtcIm1lc3NhZ2VcIiwgXCJzdHJpbmdcIl0sIFtcIm5vbmNlXCIsIFszMl1dLCBbXCJyZWNpcGllbnRcIiwgXCJzdHJpbmdcIl0sIFtcImNhbGxiYWNrVXJsXCIsIHtcbiAgICBraW5kOiBcIm9wdGlvblwiLFxuICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgfV1dXG59XV0pO1xuY29uc3Qgc2VyaWFsaXplTmVwNDEzID0gc2lnbk1lc3NhZ2VQYXJhbXMgPT4ge1xuICBjb25zdCBwYXlsb2FkID0gbmV3IFBheWxvYWQoT2JqZWN0LmFzc2lnbih7fSwgc2lnbk1lc3NhZ2VQYXJhbXMpKTtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlcmlhbGl6ZShwYXlsb2FkU2NoZW1hLCBwYXlsb2FkKSk7XG59O1xuXG5jb25zdCB2ZXJpZnlTaWduYXR1cmUgPSAoe1xuICBwdWJsaWNLZXksXG4gIHNpZ25hdHVyZSxcbiAgbWVzc2FnZSxcbiAgbm9uY2UsXG4gIHJlY2lwaWVudCxcbiAgY2FsbGJhY2tVcmxcbn0pID0+IHtcbiAgLy8gUmVjb25zdHJ1Y3QgdGhlIHBheWxvYWQgdGhhdCB3YXMgKiphY3R1YWxseSBzaWduZWQqKlxuICBjb25zdCBwYXlsb2FkID0gbmV3IFBheWxvYWQoe1xuICAgIG1lc3NhZ2UsXG4gICAgbm9uY2UsXG4gICAgcmVjaXBpZW50LFxuICAgIGNhbGxiYWNrVXJsXG4gIH0pO1xuICAvLyBTZXJpYWxpemUgcGF5bG9hZCBiYXNlZCBvbiBwYXlsb2FkU2NoZW1hXG4gIGNvbnN0IGJvcnNoUGF5bG9hZCA9IHNlcmlhbGl6ZShwYXlsb2FkU2NoZW1hLCBwYXlsb2FkKTtcbiAgLy8gSGFzaCB0aGUgcGF5bG9hZCBhcyBpbiB0aGUgTkVQMDQxMyByZWZlcmVuY2VkIGV4YW1wbGVcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25lYXIvTkVQcy9ibG9iL21hc3Rlci9uZXBzL25lcC0wNDEzLm1kI3JlZmVyZW5jZXNcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dhZ2RpZXovbmVhci1sb2dpbi9ibG9iL21haW4vYXV0aGVudGljYXRlL3dhbGxldC1hdXRoZW50aWNhdGUuanMjTDIxXG4gIGNvbnN0IGhhc2hlZFBheWxvYWQgPSBVaW50OEFycmF5LmZyb20oc2hhMjU2LmFycmF5KGJvcnNoUGF5bG9hZCkpO1xuICAvLyBDb252ZXJ0IHJlYWwgc2lnbmF0dXJlIHRvIGJ1ZmZlciBiYXNlNjRcbiAgY29uc3QgcmVhbFNpZ25hdHVyZSA9IEJ1ZmZlci5mcm9tKHNpZ25hdHVyZSwgXCJiYXNlNjRcIik7XG4gIGNvbnN0IHBrID0gdXRpbHMuUHVibGljS2V5LmZyb20ocHVibGljS2V5KTtcbiAgLy8gVmVyaWZ5IHRoZSBzaWduYXR1cmVcbiAgcmV0dXJuIHBrLnZlcmlmeShoYXNoZWRQYXlsb2FkLCByZWFsU2lnbmF0dXJlKTtcbn07XG5jb25zdCBmZXRjaEFsbFVzZXJLZXlzID0gKHtcbiAgYWNjb3VudElkLFxuICBuZXR3b3JrLFxuICBwdWJsaWNLZXlcbn0pID0+IF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICBjb25zdCBwcm92aWRlciA9IG5ldyBwcm92aWRlcnMuSnNvblJwY1Byb3ZpZGVyKHtcbiAgICB1cmw6IG5ldHdvcmsubm9kZVVybFxuICB9KTtcbiAgY29uc3Qga2V5ID0geWllbGQgcHJvdmlkZXIucXVlcnkoe1xuICAgIHJlcXVlc3RfdHlwZTogXCJ2aWV3X2FjY2Vzc19rZXlcIixcbiAgICBhY2NvdW50X2lkOiBhY2NvdW50SWQsXG4gICAgZmluYWxpdHk6IFwiZmluYWxcIixcbiAgICBwdWJsaWNfa2V5OiBwdWJsaWNLZXlcbiAgfSk7XG4gIHJldHVybiBrZXk7XG59KTtcbmNvbnN0IHZlcmlmeUZ1bGxLZXlCZWxvbmdzVG9Vc2VyID0gKHtcbiAgcHVibGljS2V5LFxuICBhY2NvdW50SWQsXG4gIG5ldHdvcmtcbn0pID0+IF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICBjb25zdCB7XG4gICAgcGVybWlzc2lvblxuICB9ID0geWllbGQgZmV0Y2hBbGxVc2VyS2V5cyh7XG4gICAgYWNjb3VudElkLFxuICAgIG5ldHdvcmssXG4gICAgcHVibGljS2V5XG4gIH0pO1xuICByZXR1cm4gcGVybWlzc2lvbiA9PT0gXCJGdWxsQWNjZXNzXCI7XG59KTtcblxuLy8gVE9ETzogUmVtb3ZlIGZyb20gYGNvcmUtanNANGAgc2luY2UgaXQncyBtb3ZlZCB0byBlbnRyeSBwb2ludHNcblxudmFyIHVuY3VycnlUaGlzJDIgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGRlZmluZUJ1aWx0SW4gPSBkZWZpbmVCdWlsdEluJDg7XG52YXIgcmVnZXhwRXhlYyQyID0gcmVnZXhwRXhlYyQzO1xudmFyIGZhaWxzJDEgPSBmYWlscyRzO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHdlbGxLbm93blN5bWJvbCRqO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ4O1xuXG52YXIgU1BFQ0lFUyA9IHdlbGxLbm93blN5bWJvbCgnc3BlY2llcycpO1xudmFyIFJlZ0V4cFByb3RvdHlwZSA9IFJlZ0V4cC5wcm90b3R5cGU7XG5cbnZhciBmaXhSZWdleHBXZWxsS25vd25TeW1ib2xMb2dpYyA9IGZ1bmN0aW9uIChLRVksIGV4ZWMsIEZPUkNFRCwgU0hBTSkge1xuICB2YXIgU1lNQk9MID0gd2VsbEtub3duU3ltYm9sKEtFWSk7XG5cbiAgdmFyIERFTEVHQVRFU19UT19TWU1CT0wgPSAhZmFpbHMkMShmdW5jdGlvbiAoKSB7XG4gICAgLy8gU3RyaW5nIG1ldGhvZHMgY2FsbCBzeW1ib2wtbmFtZWQgUmVnRXAgbWV0aG9kc1xuICAgIHZhciBPID0ge307XG4gICAgT1tTWU1CT0xdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfTtcbiAgICByZXR1cm4gJydbS0VZXShPKSAhPSA3O1xuICB9KTtcblxuICB2YXIgREVMRUdBVEVTX1RPX0VYRUMgPSBERUxFR0FURVNfVE9fU1lNQk9MICYmICFmYWlscyQxKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBTeW1ib2wtbmFtZWQgUmVnRXhwIG1ldGhvZHMgY2FsbCAuZXhlY1xuICAgIHZhciBleGVjQ2FsbGVkID0gZmFsc2U7XG4gICAgdmFyIHJlID0gL2EvO1xuXG4gICAgaWYgKEtFWSA9PT0gJ3NwbGl0Jykge1xuICAgICAgLy8gV2UgY2FuJ3QgdXNlIHJlYWwgcmVnZXggaGVyZSBzaW5jZSBpdCBjYXVzZXMgZGVvcHRpbWl6YXRpb25cbiAgICAgIC8vIGFuZCBzZXJpb3VzIHBlcmZvcm1hbmNlIGRlZ3JhZGF0aW9uIGluIFY4XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMzA2XG4gICAgICByZSA9IHt9O1xuICAgICAgLy8gUmVnRXhwW0BAc3BsaXRdIGRvZXNuJ3QgY2FsbCB0aGUgcmVnZXgncyBleGVjIG1ldGhvZCwgYnV0IGZpcnN0IGNyZWF0ZXNcbiAgICAgIC8vIGEgbmV3IG9uZS4gV2UgbmVlZCB0byByZXR1cm4gdGhlIHBhdGNoZWQgcmVnZXggd2hlbiBjcmVhdGluZyB0aGUgbmV3IG9uZS5cbiAgICAgIHJlLmNvbnN0cnVjdG9yID0ge307XG4gICAgICByZS5jb25zdHJ1Y3RvcltTUEVDSUVTXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlOyB9O1xuICAgICAgcmUuZmxhZ3MgPSAnJztcbiAgICAgIHJlW1NZTUJPTF0gPSAvLi9bU1lNQk9MXTtcbiAgICB9XG5cbiAgICByZS5leGVjID0gZnVuY3Rpb24gKCkgeyBleGVjQ2FsbGVkID0gdHJ1ZTsgcmV0dXJuIG51bGw7IH07XG5cbiAgICByZVtTWU1CT0xdKCcnKTtcbiAgICByZXR1cm4gIWV4ZWNDYWxsZWQ7XG4gIH0pO1xuXG4gIGlmIChcbiAgICAhREVMRUdBVEVTX1RPX1NZTUJPTCB8fFxuICAgICFERUxFR0FURVNfVE9fRVhFQyB8fFxuICAgIEZPUkNFRFxuICApIHtcbiAgICB2YXIgdW5jdXJyaWVkTmF0aXZlUmVnRXhwTWV0aG9kID0gdW5jdXJyeVRoaXMkMigvLi9bU1lNQk9MXSk7XG4gICAgdmFyIG1ldGhvZHMgPSBleGVjKFNZTUJPTCwgJydbS0VZXSwgZnVuY3Rpb24gKG5hdGl2ZU1ldGhvZCwgcmVnZXhwLCBzdHIsIGFyZzIsIGZvcmNlU3RyaW5nTWV0aG9kKSB7XG4gICAgICB2YXIgdW5jdXJyaWVkTmF0aXZlTWV0aG9kID0gdW5jdXJyeVRoaXMkMihuYXRpdmVNZXRob2QpO1xuICAgICAgdmFyICRleGVjID0gcmVnZXhwLmV4ZWM7XG4gICAgICBpZiAoJGV4ZWMgPT09IHJlZ2V4cEV4ZWMkMiB8fCAkZXhlYyA9PT0gUmVnRXhwUHJvdG90eXBlLmV4ZWMpIHtcbiAgICAgICAgaWYgKERFTEVHQVRFU19UT19TWU1CT0wgJiYgIWZvcmNlU3RyaW5nTWV0aG9kKSB7XG4gICAgICAgICAgLy8gVGhlIG5hdGl2ZSBTdHJpbmcgbWV0aG9kIGFscmVhZHkgZGVsZWdhdGVzIHRvIEBAbWV0aG9kICh0aGlzXG4gICAgICAgICAgLy8gcG9seWZpbGxlZCBmdW5jdGlvbiksIGxlYXNpbmcgdG8gaW5maW5pdGUgcmVjdXJzaW9uLlxuICAgICAgICAgIC8vIFdlIGF2b2lkIGl0IGJ5IGRpcmVjdGx5IGNhbGxpbmcgdGhlIG5hdGl2ZSBAQG1ldGhvZCBtZXRob2QuXG4gICAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IHVuY3VycmllZE5hdGl2ZVJlZ0V4cE1ldGhvZChyZWdleHAsIHN0ciwgYXJnMikgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogdW5jdXJyaWVkTmF0aXZlTWV0aG9kKHN0ciwgcmVnZXhwLCBhcmcyKSB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgZG9uZTogZmFsc2UgfTtcbiAgICB9KTtcblxuICAgIGRlZmluZUJ1aWx0SW4oU3RyaW5nLnByb3RvdHlwZSwgS0VZLCBtZXRob2RzWzBdKTtcbiAgICBkZWZpbmVCdWlsdEluKFJlZ0V4cFByb3RvdHlwZSwgU1lNQk9MLCBtZXRob2RzWzFdKTtcbiAgfVxuXG4gIGlmIChTSEFNKSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoUmVnRXhwUHJvdG90eXBlW1NZTUJPTF0sICdzaGFtJywgdHJ1ZSk7XG59O1xuXG52YXIgdW5jdXJyeVRoaXMkMSA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSA9IHRvSW50ZWdlck9ySW5maW5pdHkkNjtcbnZhciB0b1N0cmluZyQxID0gdG9TdHJpbmckNTtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDEgPSByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDY7XG5cbnZhciBjaGFyQXQkMSA9IHVuY3VycnlUaGlzJDEoJycuY2hhckF0KTtcbnZhciBjaGFyQ29kZUF0ID0gdW5jdXJyeVRoaXMkMSgnJy5jaGFyQ29kZUF0KTtcbnZhciBzdHJpbmdTbGljZSQxID0gdW5jdXJyeVRoaXMkMSgnJy5zbGljZSk7XG5cbnZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbiAoQ09OVkVSVF9UT19TVFJJTkcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgcG9zKSB7XG4gICAgdmFyIFMgPSB0b1N0cmluZyQxKHJlcXVpcmVPYmplY3RDb2VyY2libGUkMSgkdGhpcykpO1xuICAgIHZhciBwb3NpdGlvbiA9IHRvSW50ZWdlck9ySW5maW5pdHkocG9zKTtcbiAgICB2YXIgc2l6ZSA9IFMubGVuZ3RoO1xuICAgIHZhciBmaXJzdCwgc2Vjb25kO1xuICAgIGlmIChwb3NpdGlvbiA8IDAgfHwgcG9zaXRpb24gPj0gc2l6ZSkgcmV0dXJuIENPTlZFUlRfVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XG4gICAgZmlyc3QgPSBjaGFyQ29kZUF0KFMsIHBvc2l0aW9uKTtcbiAgICByZXR1cm4gZmlyc3QgPCAweEQ4MDAgfHwgZmlyc3QgPiAweERCRkYgfHwgcG9zaXRpb24gKyAxID09PSBzaXplXG4gICAgICB8fCAoc2Vjb25kID0gY2hhckNvZGVBdChTLCBwb3NpdGlvbiArIDEpKSA8IDB4REMwMCB8fCBzZWNvbmQgPiAweERGRkZcbiAgICAgICAgPyBDT05WRVJUX1RPX1NUUklOR1xuICAgICAgICAgID8gY2hhckF0JDEoUywgcG9zaXRpb24pXG4gICAgICAgICAgOiBmaXJzdFxuICAgICAgICA6IENPTlZFUlRfVE9fU1RSSU5HXG4gICAgICAgICAgPyBzdHJpbmdTbGljZSQxKFMsIHBvc2l0aW9uLCBwb3NpdGlvbiArIDIpXG4gICAgICAgICAgOiAoZmlyc3QgLSAweEQ4MDAgPDwgMTApICsgKHNlY29uZCAtIDB4REMwMCkgKyAweDEwMDAwO1xuICB9O1xufTtcblxudmFyIHN0cmluZ011bHRpYnl0ZSA9IHtcbiAgLy8gYFN0cmluZy5wcm90b3R5cGUuY29kZVBvaW50QXRgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUuY29kZXBvaW50YXRcbiAgY29kZUF0OiBjcmVhdGVNZXRob2QoZmFsc2UpLFxuICAvLyBgU3RyaW5nLnByb3RvdHlwZS5hdGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRoaWFzYnluZW5zL1N0cmluZy5wcm90b3R5cGUuYXRcbiAgY2hhckF0OiBjcmVhdGVNZXRob2QodHJ1ZSlcbn07XG5cbnZhciBjaGFyQXQgPSBzdHJpbmdNdWx0aWJ5dGUuY2hhckF0O1xuXG4vLyBgQWR2YW5jZVN0cmluZ0luZGV4YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYWR2YW5jZXN0cmluZ2luZGV4XG52YXIgYWR2YW5jZVN0cmluZ0luZGV4JDEgPSBmdW5jdGlvbiAoUywgaW5kZXgsIHVuaWNvZGUpIHtcbiAgcmV0dXJuIGluZGV4ICsgKHVuaWNvZGUgPyBjaGFyQXQoUywgaW5kZXgpLmxlbmd0aCA6IDEpO1xufTtcblxudmFyIGNhbGwkMSA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBhbk9iamVjdCQxID0gYW5PYmplY3QkZTtcbnZhciBpc0NhbGxhYmxlID0gaXNDYWxsYWJsZSRuO1xudmFyIGNsYXNzb2YgPSBjbGFzc29mUmF3JDE7XG52YXIgcmVnZXhwRXhlYyQxID0gcmVnZXhwRXhlYyQzO1xuXG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcblxuLy8gYFJlZ0V4cEV4ZWNgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1yZWdleHBleGVjXG52YXIgcmVnZXhwRXhlY0Fic3RyYWN0ID0gZnVuY3Rpb24gKFIsIFMpIHtcbiAgdmFyIGV4ZWMgPSBSLmV4ZWM7XG4gIGlmIChpc0NhbGxhYmxlKGV4ZWMpKSB7XG4gICAgdmFyIHJlc3VsdCA9IGNhbGwkMShleGVjLCBSLCBTKTtcbiAgICBpZiAocmVzdWx0ICE9PSBudWxsKSBhbk9iamVjdCQxKHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAoY2xhc3NvZihSKSA9PT0gJ1JlZ0V4cCcpIHJldHVybiBjYWxsJDEocmVnZXhwRXhlYyQxLCBSLCBTKTtcbiAgdGhyb3cgJFR5cGVFcnJvcignUmVnRXhwI2V4ZWMgY2FsbGVkIG9uIGluY29tcGF0aWJsZSByZWNlaXZlcicpO1xufTtcblxudmFyIGFwcGx5ID0gZnVuY3Rpb25BcHBseTtcbnZhciBjYWxsID0gZnVuY3Rpb25DYWxsO1xudmFyIHVuY3VycnlUaGlzID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBmaXhSZWdFeHBXZWxsS25vd25TeW1ib2xMb2dpYyA9IGZpeFJlZ2V4cFdlbGxLbm93blN5bWJvbExvZ2ljO1xudmFyIGlzUmVnRXhwID0gaXNSZWdleHA7XG52YXIgYW5PYmplY3QgPSBhbk9iamVjdCRlO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDY7XG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gc3BlY2llc0NvbnN0cnVjdG9yJDM7XG52YXIgYWR2YW5jZVN0cmluZ0luZGV4ID0gYWR2YW5jZVN0cmluZ0luZGV4JDE7XG52YXIgdG9MZW5ndGggPSB0b0xlbmd0aCQ2O1xudmFyIHRvU3RyaW5nID0gdG9TdHJpbmckNTtcbnZhciBnZXRNZXRob2QgPSBnZXRNZXRob2QkNDtcbnZhciBhcnJheVNsaWNlID0gYXJyYXlTbGljZVNpbXBsZTtcbnZhciBjYWxsUmVnRXhwRXhlYyA9IHJlZ2V4cEV4ZWNBYnN0cmFjdDtcbnZhciByZWdleHBFeGVjID0gcmVnZXhwRXhlYyQzO1xudmFyIHN0aWNreUhlbHBlcnMgPSByZWdleHBTdGlja3lIZWxwZXJzO1xudmFyIGZhaWxzID0gZmFpbHMkcztcblxudmFyIFVOU1VQUE9SVEVEX1kgPSBzdGlja3lIZWxwZXJzLlVOU1VQUE9SVEVEX1k7XG52YXIgTUFYX1VJTlQzMiA9IDB4RkZGRkZGRkY7XG52YXIgbWluID0gTWF0aC5taW47XG52YXIgJHB1c2ggPSBbXS5wdXNoO1xudmFyIGV4ZWMgPSB1bmN1cnJ5VGhpcygvLi8uZXhlYyk7XG52YXIgcHVzaCA9IHVuY3VycnlUaGlzKCRwdXNoKTtcbnZhciBzdHJpbmdTbGljZSA9IHVuY3VycnlUaGlzKCcnLnNsaWNlKTtcblxuLy8gQ2hyb21lIDUxIGhhcyBhIGJ1Z2d5IFwic3BsaXRcIiBpbXBsZW1lbnRhdGlvbiB3aGVuIFJlZ0V4cCNleGVjICE9PSBuYXRpdmVFeGVjXG4vLyBXZWV4IEpTIGhhcyBmcm96ZW4gYnVpbHQtaW4gcHJvdG90eXBlcywgc28gdXNlIHRyeSAvIGNhdGNoIHdyYXBwZXJcbnZhciBTUExJVF9XT1JLU19XSVRIX09WRVJXUklUVEVOX0VYRUMgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVnZXhwL25vLWVtcHR5LWdyb3VwIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIHZhciByZSA9IC8oPzopLztcbiAgdmFyIG9yaWdpbmFsRXhlYyA9IHJlLmV4ZWM7XG4gIHJlLmV4ZWMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBvcmlnaW5hbEV4ZWMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfTtcbiAgdmFyIHJlc3VsdCA9ICdhYicuc3BsaXQocmUpO1xuICByZXR1cm4gcmVzdWx0Lmxlbmd0aCAhPT0gMiB8fCByZXN1bHRbMF0gIT09ICdhJyB8fCByZXN1bHRbMV0gIT09ICdiJztcbn0pO1xuXG4vLyBAQHNwbGl0IGxvZ2ljXG5maXhSZWdFeHBXZWxsS25vd25TeW1ib2xMb2dpYygnc3BsaXQnLCBmdW5jdGlvbiAoU1BMSVQsIG5hdGl2ZVNwbGl0LCBtYXliZUNhbGxOYXRpdmUpIHtcbiAgdmFyIGludGVybmFsU3BsaXQ7XG4gIGlmIChcbiAgICAnYWJiYycuc3BsaXQoLyhiKSovKVsxXSA9PSAnYycgfHxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVnZXhwL25vLWVtcHR5LWdyb3VwIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gICAgJ3Rlc3QnLnNwbGl0KC8oPzopLywgLTEpLmxlbmd0aCAhPSA0IHx8XG4gICAgJ2FiJy5zcGxpdCgvKD86YWIpKi8pLmxlbmd0aCAhPSAyIHx8XG4gICAgJy4nLnNwbGl0KC8oLj8pKC4/KS8pLmxlbmd0aCAhPSA0IHx8XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlZ2V4cC9uby1lbXB0eS1jYXB0dXJpbmctZ3JvdXAsIHJlZ2V4cC9uby1lbXB0eS1ncm91cCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICAgICcuJy5zcGxpdCgvKCkoKS8pLmxlbmd0aCA+IDEgfHxcbiAgICAnJy5zcGxpdCgvLj8vKS5sZW5ndGhcbiAgKSB7XG4gICAgLy8gYmFzZWQgb24gZXM1LXNoaW0gaW1wbGVtZW50YXRpb24sIG5lZWQgdG8gcmV3b3JrIGl0XG4gICAgaW50ZXJuYWxTcGxpdCA9IGZ1bmN0aW9uIChzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICB2YXIgc3RyaW5nID0gdG9TdHJpbmcocmVxdWlyZU9iamVjdENvZXJjaWJsZSh0aGlzKSk7XG4gICAgICB2YXIgbGltID0gbGltaXQgPT09IHVuZGVmaW5lZCA/IE1BWF9VSU5UMzIgOiBsaW1pdCA+Pj4gMDtcbiAgICAgIGlmIChsaW0gPT09IDApIHJldHVybiBbXTtcbiAgICAgIGlmIChzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCkgcmV0dXJuIFtzdHJpbmddO1xuICAgICAgLy8gSWYgYHNlcGFyYXRvcmAgaXMgbm90IGEgcmVnZXgsIHVzZSBuYXRpdmUgc3BsaXRcbiAgICAgIGlmICghaXNSZWdFeHAoc2VwYXJhdG9yKSkge1xuICAgICAgICByZXR1cm4gY2FsbChuYXRpdmVTcGxpdCwgc3RyaW5nLCBzZXBhcmF0b3IsIGxpbSk7XG4gICAgICB9XG4gICAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgICB2YXIgZmxhZ3MgPSAoc2VwYXJhdG9yLmlnbm9yZUNhc2UgPyAnaScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5tdWx0aWxpbmUgPyAnbScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci51bmljb2RlID8gJ3UnIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3Iuc3RpY2t5ID8gJ3knIDogJycpO1xuICAgICAgdmFyIGxhc3RMYXN0SW5kZXggPSAwO1xuICAgICAgLy8gTWFrZSBgZ2xvYmFsYCBhbmQgYXZvaWQgYGxhc3RJbmRleGAgaXNzdWVzIGJ5IHdvcmtpbmcgd2l0aCBhIGNvcHlcbiAgICAgIHZhciBzZXBhcmF0b3JDb3B5ID0gbmV3IFJlZ0V4cChzZXBhcmF0b3Iuc291cmNlLCBmbGFncyArICdnJyk7XG4gICAgICB2YXIgbWF0Y2gsIGxhc3RJbmRleCwgbGFzdExlbmd0aDtcbiAgICAgIHdoaWxlIChtYXRjaCA9IGNhbGwocmVnZXhwRXhlYywgc2VwYXJhdG9yQ29weSwgc3RyaW5nKSkge1xuICAgICAgICBsYXN0SW5kZXggPSBzZXBhcmF0b3JDb3B5Lmxhc3RJbmRleDtcbiAgICAgICAgaWYgKGxhc3RJbmRleCA+IGxhc3RMYXN0SW5kZXgpIHtcbiAgICAgICAgICBwdXNoKG91dHB1dCwgc3RyaW5nU2xpY2Uoc3RyaW5nLCBsYXN0TGFzdEluZGV4LCBtYXRjaC5pbmRleCkpO1xuICAgICAgICAgIGlmIChtYXRjaC5sZW5ndGggPiAxICYmIG1hdGNoLmluZGV4IDwgc3RyaW5nLmxlbmd0aCkgYXBwbHkoJHB1c2gsIG91dHB1dCwgYXJyYXlTbGljZShtYXRjaCwgMSkpO1xuICAgICAgICAgIGxhc3RMZW5ndGggPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgbGFzdExhc3RJbmRleCA9IGxhc3RJbmRleDtcbiAgICAgICAgICBpZiAob3V0cHV0Lmxlbmd0aCA+PSBsaW0pIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXBhcmF0b3JDb3B5Lmxhc3RJbmRleCA9PT0gbWF0Y2guaW5kZXgpIHNlcGFyYXRvckNvcHkubGFzdEluZGV4Kys7IC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3BcbiAgICAgIH1cbiAgICAgIGlmIChsYXN0TGFzdEluZGV4ID09PSBzdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgIGlmIChsYXN0TGVuZ3RoIHx8ICFleGVjKHNlcGFyYXRvckNvcHksICcnKSkgcHVzaChvdXRwdXQsICcnKTtcbiAgICAgIH0gZWxzZSBwdXNoKG91dHB1dCwgc3RyaW5nU2xpY2Uoc3RyaW5nLCBsYXN0TGFzdEluZGV4KSk7XG4gICAgICByZXR1cm4gb3V0cHV0Lmxlbmd0aCA+IGxpbSA/IGFycmF5U2xpY2Uob3V0cHV0LCAwLCBsaW0pIDogb3V0cHV0O1xuICAgIH07XG4gIC8vIENoYWtyYSwgVjhcbiAgfSBlbHNlIGlmICgnMCcuc3BsaXQodW5kZWZpbmVkLCAwKS5sZW5ndGgpIHtcbiAgICBpbnRlcm5hbFNwbGl0ID0gZnVuY3Rpb24gKHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgIHJldHVybiBzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCAmJiBsaW1pdCA9PT0gMCA/IFtdIDogY2FsbChuYXRpdmVTcGxpdCwgdGhpcywgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgfTtcbiAgfSBlbHNlIGludGVybmFsU3BsaXQgPSBuYXRpdmVTcGxpdDtcblxuICByZXR1cm4gW1xuICAgIC8vIGBTdHJpbmcucHJvdG90eXBlLnNwbGl0YCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUuc3BsaXRcbiAgICBmdW5jdGlvbiBzcGxpdChzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICB2YXIgTyA9IHJlcXVpcmVPYmplY3RDb2VyY2libGUodGhpcyk7XG4gICAgICB2YXIgc3BsaXR0ZXIgPSBzZXBhcmF0b3IgPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogZ2V0TWV0aG9kKHNlcGFyYXRvciwgU1BMSVQpO1xuICAgICAgcmV0dXJuIHNwbGl0dGVyXG4gICAgICAgID8gY2FsbChzcGxpdHRlciwgc2VwYXJhdG9yLCBPLCBsaW1pdClcbiAgICAgICAgOiBjYWxsKGludGVybmFsU3BsaXQsIHRvU3RyaW5nKE8pLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICB9LFxuICAgIC8vIGBSZWdFeHAucHJvdG90eXBlW0BAc3BsaXRdYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXJlZ2V4cC5wcm90b3R5cGUtQEBzcGxpdFxuICAgIC8vXG4gICAgLy8gTk9URTogVGhpcyBjYW5ub3QgYmUgcHJvcGVybHkgcG9seWZpbGxlZCBpbiBlbmdpbmVzIHRoYXQgZG9uJ3Qgc3VwcG9ydFxuICAgIC8vIHRoZSAneScgZmxhZy5cbiAgICBmdW5jdGlvbiAoc3RyaW5nLCBsaW1pdCkge1xuICAgICAgdmFyIHJ4ID0gYW5PYmplY3QodGhpcyk7XG4gICAgICB2YXIgUyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICB2YXIgcmVzID0gbWF5YmVDYWxsTmF0aXZlKGludGVybmFsU3BsaXQsIHJ4LCBTLCBsaW1pdCwgaW50ZXJuYWxTcGxpdCAhPT0gbmF0aXZlU3BsaXQpO1xuXG4gICAgICBpZiAocmVzLmRvbmUpIHJldHVybiByZXMudmFsdWU7XG5cbiAgICAgIHZhciBDID0gc3BlY2llc0NvbnN0cnVjdG9yKHJ4LCBSZWdFeHApO1xuXG4gICAgICB2YXIgdW5pY29kZU1hdGNoaW5nID0gcngudW5pY29kZTtcbiAgICAgIHZhciBmbGFncyA9IChyeC5pZ25vcmVDYXNlID8gJ2knIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChyeC5tdWx0aWxpbmUgPyAnbScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHJ4LnVuaWNvZGUgPyAndScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKFVOU1VQUE9SVEVEX1kgPyAnZycgOiAneScpO1xuXG4gICAgICAvLyBeKD8gKyByeCArICkgaXMgbmVlZGVkLCBpbiBjb21iaW5hdGlvbiB3aXRoIHNvbWUgUyBzbGljaW5nLCB0b1xuICAgICAgLy8gc2ltdWxhdGUgdGhlICd5JyBmbGFnLlxuICAgICAgdmFyIHNwbGl0dGVyID0gbmV3IEMoVU5TVVBQT1JURURfWSA/ICdeKD86JyArIHJ4LnNvdXJjZSArICcpJyA6IHJ4LCBmbGFncyk7XG4gICAgICB2YXIgbGltID0gbGltaXQgPT09IHVuZGVmaW5lZCA/IE1BWF9VSU5UMzIgOiBsaW1pdCA+Pj4gMDtcbiAgICAgIGlmIChsaW0gPT09IDApIHJldHVybiBbXTtcbiAgICAgIGlmIChTLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGNhbGxSZWdFeHBFeGVjKHNwbGl0dGVyLCBTKSA9PT0gbnVsbCA/IFtTXSA6IFtdO1xuICAgICAgdmFyIHAgPSAwO1xuICAgICAgdmFyIHEgPSAwO1xuICAgICAgdmFyIEEgPSBbXTtcbiAgICAgIHdoaWxlIChxIDwgUy5sZW5ndGgpIHtcbiAgICAgICAgc3BsaXR0ZXIubGFzdEluZGV4ID0gVU5TVVBQT1JURURfWSA/IDAgOiBxO1xuICAgICAgICB2YXIgeiA9IGNhbGxSZWdFeHBFeGVjKHNwbGl0dGVyLCBVTlNVUFBPUlRFRF9ZID8gc3RyaW5nU2xpY2UoUywgcSkgOiBTKTtcbiAgICAgICAgdmFyIGU7XG4gICAgICAgIGlmIChcbiAgICAgICAgICB6ID09PSBudWxsIHx8XG4gICAgICAgICAgKGUgPSBtaW4odG9MZW5ndGgoc3BsaXR0ZXIubGFzdEluZGV4ICsgKFVOU1VQUE9SVEVEX1kgPyBxIDogMCkpLCBTLmxlbmd0aCkpID09PSBwXG4gICAgICAgICkge1xuICAgICAgICAgIHEgPSBhZHZhbmNlU3RyaW5nSW5kZXgoUywgcSwgdW5pY29kZU1hdGNoaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwdXNoKEEsIHN0cmluZ1NsaWNlKFMsIHAsIHEpKTtcbiAgICAgICAgICBpZiAoQS5sZW5ndGggPT09IGxpbSkgcmV0dXJuIEE7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gei5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIHB1c2goQSwgeltpXSk7XG4gICAgICAgICAgICBpZiAoQS5sZW5ndGggPT09IGxpbSkgcmV0dXJuIEE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHEgPSBwID0gZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcHVzaChBLCBzdHJpbmdTbGljZShTLCBwKSk7XG4gICAgICByZXR1cm4gQTtcbiAgICB9XG4gIF07XG59LCAhU1BMSVRfV09SS1NfV0lUSF9PVkVSV1JJVFRFTl9FWEVDLCBVTlNVUFBPUlRFRF9ZKTtcblxudmFyIG1vZGFsJGIgPSB7XG5cdHdhbGxldDoge1xuXHRcdGNvbm5lY3RZb3VyV2FsbGV0OiBcIkNvbm5lY3QgWW91ciBXYWxsZXRcIixcblx0XHR3aGF0SXNBV2FsbGV0OiBcIldoYXQgaXMgYSBXYWxsZXQ/XCIsXG5cdFx0c2VjdXJlQW5kTWFuYWdlOiBcIlNlY3VyZSAmIE1hbmFnZSBZb3VyIERpZ2l0YWwgQXNzZXRzXCIsXG5cdFx0c2FmZWx5U3RvcmU6IFwiU2FmZWx5IHN0b3JlIGFuZCB0cmFuc2ZlciB5b3VyIGNyeXB0byBhbmQgTkZUcy5cIixcblx0XHRsb2dJblRvQW55OiBcIkxvZyBJbiB0byBBbnkgTkVBUiBBcHBcIixcblx0XHRub05lZWRUb0NyZWF0ZTogXCJObyBuZWVkIHRvIGNyZWF0ZSBuZXcgYWNjb3VudHMgb3IgY3JlZGVudGlhbHMuIENvbm5lY3QgeW91ciB3YWxsZXQgYW5kIHlvdSBhcmUgZ29vZCB0byBnbyFcIixcblx0XHRnZXRBV2FsbGV0OiBcIkdldCBhIFdhbGxldFwiLFxuXHRcdHVzZUFXYWxsZXQ6IFwiVXNlIGEgd2FsbGV0IHRvIHNlY3VyZSBhbmQgbWFuYWdlIHlvdXIgTkVBUiBhc3NldHMsIGFuZCB0byBsb2cgaW4gdG8gYW55IE5FQVIgYXBwIHdpdGhvdXQgdGhlIG5lZWQgZm9yIHVzZXJuYW1lcyBhbmQgcGFzc3dvcmRzLlwiLFxuXHRcdGNvbm5lY3Rpb25GYWlsZWQ6IFwiQ29ubmVjdGlvbiBGYWlsZWRcIixcblx0XHRjb25uZWN0aW9uU3VjY2Vzc2Z1bDogXCJDb25uZWN0aW9uIFN1Y2Nlc3NmdWxcIixcblx0XHRjb25uZWN0ZWQ6IFwiQ29ubmVjdGVkXCIsXG5cdFx0Y29ubmVjdGluZ1RvOiBcIkNvbm5lY3RpbmcgdG9cIixcblx0XHRjb25uZWN0aW5nTWVzc2FnZToge1xuXHRcdFx0aW5qZWN0ZWQ6IFwiQ29uZmlybSB0aGUgY29ubmVjdGlvbiBpbiB0aGUgZXh0ZW5zaW9uIHdpbmRvd1wiLFxuXHRcdFx0YnJvd3NlcjogXCJDb25maXJtIHRoZSBjb25uZWN0aW9uIGluIHRoZSB3YWxsZXQgYWZ0ZXIgcmVkaXJlY3RcIixcblx0XHRcdGhhcmR3YXJlOiBcIkNvbmZpcm0gdGhlIGNvbm5lY3Rpb24gaW4gdGhlIGxlZGdlciBkZXZpY2VcIixcblx0XHRcdGJyaWRnZTogXCJDb25maXJtIHRoZSBjb25uZWN0aW9uIGluIHRoZSB3YWxsZXRcIlxuXHRcdH1cblx0fSxcblx0bGVkZ2VyOiB7XG5cdFx0Y29ubmVjdFdpdGhMZWRnZXI6IFwiQ29ubmVjdCB3aXRoIExlZGdlclwiLFxuXHRcdG1ha2VTdXJlWW91ckxlZGdlcjogXCJNYWtlIHN1cmUgeW91ciBMZWRnZXIgaXMgY29ubmVjdGVkIHNlY3VyZWx5LCBhbmQgdGhhdCB0aGUgTkVBUiBhcHAgaXMgb3BlbiBvbiB5b3VyIGRldmljZVwiLFxuXHRcdFwiY29udGludWVcIjogXCJDb250aW51ZVwiLFxuXHRcdHNwZWNpZnlIRFBhdGg6IFwiU3BlY2lmeSBIRCBQYXRoXCIsXG5cdFx0ZW50ZXJZb3VyUHJlZmVycmVkSERQYXRoOiBcIkVudGVyIHlvdXIgcHJlZmVycmVkIEhEIHBhdGgsIHRoZW4gc2NhbiBmb3IgYW55IGFjdGl2ZSBhY2NvdW50cy5cIixcblx0XHRzY2FuOiBcIlNjYW5cIixcblx0XHRyZXRyeTogXCJSZXRyeVwiLFxuXHRcdGxlZGdlcklzTm90QXZhaWxhYmxlOiBcIkxlZGdlciBpcyBub3QgYXZhaWxhYmxlXCIsXG5cdFx0YWNjZXNzRGVuaWVkVG9Vc2VMZWRnZXJEZXZpY2U6IFwiQWNjZXNzIGRlbmllZCB0byB1c2UgTGVkZ2VyIGRldmljZVwiLFxuXHRcdG5vQWNjb3VudHNGb3VuZDogXCJObyBBY2NvdW50cyBGb3VuZFwiLFxuXHRcdHNlbGVjdFlvdXJBY2NvdW50czogXCJTZWxlY3QgWW91ciBBY2NvdW50c1wiLFxuXHRcdGNvbm5lY3RpbmcxQWNjb3VudDogXCJDb25uZWN0aW5nIDEgQWNjb3VudFwiLFxuXHRcdGNhbnRGaW5kQW55QWNjb3VudDogXCJDYW4ndCBmaW5kIGFueSBhY2NvdW50IGFzc29jaWF0ZWQgd2l0aCB0aGlzIExlZGdlci4gUGxlYXNlIGNyZWF0ZSBhIG5ldyBORUFSIGFjY291bnQgb25cIixcblx0XHRvckNvbm5lY3RBbkFub3RoZXJMZWRnZXI6IFwib3IgY29ubmVjdCBhbiBhbm90aGVyIExlZGdlci5cIixcblx0XHRjb25uZWN0aW5nOiBcIkNvbm5lY3RpbmdcIixcblx0XHRvZkFjY291bnRzOiBcIm9mIEFjY291bnRzXCIsXG5cdFx0ZmFpbGVkVG9BdXRvbWF0aWNhbGx5OiBcIkZhaWxlZCB0byBhdXRvbWF0aWNhbGx5IGZpbmQgYWNjb3VudCBpZC4gUHJvdmlkZSBpdCBtYW51YWxseTpcIixcblx0XHRvdmVydmlld1RoZUxpc3RPZkF1dGhvcml6ZWQ6IFwiT3ZlcnZpZXcgdGhlIGxpc3Qgb2YgYXV0aG9yaXplZCBhY2NvdW50KHMpLCBjb21wbGV0ZSBzaWduIGluIGJ5IGNsaWNraW5nIHRoZSBidXR0b24gYmVsb3cuXCIsXG5cdFx0ZmluaXNoOiBcIkZpbmlzaFwiXG5cdH0sXG5cdGluc3RhbGw6IHtcblx0XHR5b3VsbE5lZWRUb0luc3RhbGw6IFwiWW91J2xsIG5lZWQgdG8gaW5zdGFsbFwiLFxuXHRcdHRvQ29udGludWVBZnRlckluc3RhbGxpbmc6IFwidG8gY29udGludWUuIEFmdGVyIGluc3RhbGxpbmdcIixcblx0XHRyZWZyZXNoVGhlUGFnZTogXCJyZWZyZXNoIHRoZSBwYWdlLlwiLFxuXHRcdG9wZW46IFwiT3BlblwiXG5cdH0sXG5cdHFyOiB7XG5cdFx0Y29waWVkVG9DbGlwYm9hcmQ6IFwiQ29waWVkIHRvIGNsaXBib2FyZFwiLFxuXHRcdGZhaWxlZFRvQ29weTogXCJGYWlsZWQgdG8gY29weSB0byBjbGlwYm9hcmRcIixcblx0XHRzY2FuV2l0aFlvdXJNb2JpbGU6IFwiU2NhbiB3aXRoIFlvdXIgTW9iaWxlIERldmljZVwiLFxuXHRcdGNvcHlUb0NsaXBib2FyZDogXCIgQ29weSB0byBjbGlwYm9hcmRcIixcblx0XHRwcmVmZXJUaGVPZmZpY2lhbDogXCJQcmVmZXIgdGhlIG9mZmljaWFsIGRpYWxvZ3VlIG9mXCIsXG5cdFx0b3BlbjogXCJPcGVuXCJcblx0fSxcblx0d2FsbGV0VHlwZXM6IHtcblx0XHRoYXJkd2FyZTogXCJIYXJkd2FyZSBXYWxsZXRcIixcblx0XHRicm93c2VyOiBcIkJyb3dzZXIgV2FsbGV0XCIsXG5cdFx0aW5qZWN0ZWQ6IFwiV2FsbGV0IEV4dGVuc2lvblwiLFxuXHRcdGJyaWRnZTogXCJCcmlkZ2UgV2FsbGV0XCIsXG5cdFx0bW9iaWxlOiBcIk1vYmlsZSBXYWxsZXRcIixcblx0XHRcImluc3RhbnQtbGlua1wiOiBcIkluc3RhbnQgV2FsbGV0XCJcblx0fSxcblx0ZXhwb3J0QWNjb3VudHM6IHtcblx0XHRjaG9vc2VBV2FsbGV0OiBcIkNob29zZSBhIFdhbGxldFwiLFxuXHRcdHRyYW5zZmVyWW91ckFjY291bnRzOiBcIlRyYW5zZmVyIFlvdXIgQWNjb3VudHNcIixcblx0XHRzZWxlY3RBV2FsbGV0OiBcIlNlbGVjdCBhIHdhbGxldCB0aGF0IGZpdHMgeW91ciBuZWVkcyBhbmQgc3VwcG9ydHMgeW91ciBjb25uZWN0ZWQgYWNjb3VudHMuXCIsXG5cdFx0c2VsZWN0WW91ckFjY291bnRzOiBcIlNlbGVjdCBZb3VyIEFjY291bnRzXCIsXG5cdFx0YWZ0ZXJEZWNpZGU6IFwiQWZ0ZXIgeW91IGRlY2lkZSBvbiBhIHdhbGxldCwgeW91IGNhbiBzZWxlY3Qgd2hpY2ggYWNjb3VudHMgeW91IHdhbnQgdG8gdHJhbnNmZXIuXCIsXG5cdFx0ZGlzY2xhaW1lcjogXCJZb3Ugd29u4oCZdCBiZSBhYmxlIHRvIHRyYW5zZmVyIGFjY291bnRzIHRoYXQgaGF2ZSBuZXZlciBiZWVuIGZ1bmRlZCBvciB1c2VkIG9uIE5FQVIuXCIsXG5cdFx0d2FybmluZzogXCJkb2VzIG5vdCBzdXBwb3J0IGFjY291bnQgZXhwb3J0IGF0IHRoaXMgdGltZS4gUGxlYXNlIHNlbGVjdCBhbm90aGVyIHdhbGxldC5cIixcblx0XHR3YWxsZXRUeXBlczoge1xuXHRcdFx0aGFyZHdhcmU6IFwiSGFyZHdhcmUgV2FsbGV0XCIsXG5cdFx0XHRicm93c2VyOiBcIkJyb3dzZXIgV2FsbGV0XCIsXG5cdFx0XHRpbmplY3RlZDogXCJXYWxsZXQgRXh0ZW5zaW9uXCIsXG5cdFx0XHRicmlkZ2U6IFwiQnJpZGdlIFdhbGxldFwiLFxuXHRcdFx0bW9iaWxlOiBcIk1vYmlsZSBXYWxsZXRcIlxuXHRcdH0sXG5cdFx0c2VsZWN0QWNjb3VudHM6IHtcblx0XHRcdHRpdGxlOiBcIlNlbGVjdCBBY2NvdW50cyB0byBUcmFuc2ZlclwiLFxuXHRcdFx0YnV0dG9uOiBcIkNvbnRpbnVlXCIsXG5cdFx0XHRkZXNlbGVjdEFsbDogXCJEZXNlbGVjdCBBbGxcIixcblx0XHRcdHNlbGVjdEFsbDogXCJTZWxlY3QgQWxsXCIsXG5cdFx0XHR1bmF2YWlsYWJsZTogXCJUcmFuc2ZlciBVbmF2YWlsYWJsZVwiLFxuXHRcdFx0ZXJyb3I6IFwiQWNjb3VudCBkb2VzIG5vdCBleGlzdFwiLFxuXHRcdFx0d2FybmluZ0xlZGdlcjogXCJMZWRnZXIgc3VwcG9ydCByZXF1aXJlZFwiLFxuXHRcdFx0bm9CYWxhbmNlOiBcIkFjY291bnQgbm90IGZ1bmRlZFwiXG5cdFx0fSxcblx0XHRnZXRQYXNzcGhyYXNlOiB7XG5cdFx0XHR0aXRsZTogXCJDb3B5IFRlbXBvcmFyeSBQYXNzd29yZFwiLFxuXHRcdFx0ZGVzYzogXCJZb3XigJlsbCBuZWVkIHRvIGVudGVyIHRoaXMgcGFzc3dvcmQgd2hlbiB5b3UgYmVnaW4gZXhwb3J0aW5nIHlvdXIgYWNjb3VudHMgdG8gYSBkaWZmZXJlbnQgd2FsbGV0LlwiLFxuXHRcdFx0YnV0dG9uOiBcIkNvbnRpbnVlXCIsXG5cdFx0XHR0cmFuc2ZlckJ1dHRvbjogXCJUcmFuc2ZlciBBY2NvdW50c1wiLFxuXHRcdFx0bGFiZWw6IFwiQ2xpY2sgdG8gQ29weVwiLFxuXHRcdFx0Y2hlY2tMYWJlbDogXCJJIGNvcGllZCBvciB3cm90ZSBkb3duIHRoZSBwYXNzd29yZFwiXG5cdFx0fSxcblx0XHRjb21wbGV0ZToge1xuXHRcdFx0dGl0bGU6IFwiQ29tcGxldGUgdGhlIFRyYW5zZmVyXCIsXG5cdFx0XHRkZXNjT25lOiBcIllvdSB3aWxsIG5vdyBiZSByZWRpcmVjdGVkIHRvIHRoZSB3YWxsZXQgeW91IHNlbGVjdGVkIHRvIGNvbXBsZXRlIHRoZSB0cmFuc2Zlci5cIixcblx0XHRcdGRlc2NUd286IFwiT25jZSBpbXBvcnQgcGFydCBvZiBwcm9jZXNzIGlzIGNvbXBsZXRlZCBmcm9tIHNlbGVjdGVkIHdhbGxldCwgcHJlc3MgYnV0dG9uIHRvIGNvbXBsZXRlIHRoZSB0cmFuc2ZlciBwcm9jZXNzLlwiLFxuXHRcdFx0c3RhcnRPdmVyQnV0dG9uOiBcIlN0YXJ0IE92ZXJcIixcblx0XHRcdGJ1dHRvbjogXCJDb21wbGV0ZVwiXG5cdFx0fVxuXHR9XG59O1xudmFyIGNvbXBvbmVudCQxID0ge1xuXHRjbGlja1RvQ29weToge1xuXHRcdGxhYmVsOiBcIkNvcGllZFwiLFxuXHRcdHRvb2x0aXA6IFwiQ2xpY2sgdG8gY29weVwiXG5cdH1cbn07XG52YXIgZW4gPSB7XG5cdG1vZGFsOiBtb2RhbCRiLFxuXHRjb21wb25lbnQ6IGNvbXBvbmVudCQxXG59O1xuXG52YXIgbW9kYWwkYSA9IHtcblx0d2FsbGV0OiB7XG5cdFx0Y29ubmVjdFlvdXJXYWxsZXQ6IFwiQ29uZWN0YSBUdSBCaWxsZXRlcmFcIixcblx0XHR3aGF0SXNBV2FsbGV0OiBcIsK/UXVlIGVzIHVuYSBCaWxsZXRlcmE/XCIsXG5cdFx0c2VjdXJlQW5kTWFuYWdlOiBcIlJlc2d1YXJkYSB5IEFkbWluaXN0cmFyIFR1cyBBY3Rpdm9zIERpZ2l0YWxlc1wiLFxuXHRcdHNhZmVseVN0b3JlOiBcIkFsbWFjZW5hIGRlIGZvcm1hIHNlZ3VyYSB5IHRyYW5zZmllcmUgdHVzIGNyeXB0b3MgeSBORlQnc1wiLFxuXHRcdGxvZ0luVG9Bbnk6IFwiSW5pY2llIHNlc2nDs24gZW4gQ3VhbHF1aWVyIEFwbGljYWNpb24gTkVBUlwiLFxuXHRcdG5vTmVlZFRvQ3JlYXRlOiBcIk5vIGVzIG5lY2VzYXJpbyBjcmVhciBudWV2YXMgY3VlbnRhcyBvIGNyZWRlbmNpYWxlcywgwqFDb25lY3RhIHR1IGJpbGxldGVyYSB5IGxpc3RvIVwiLFxuXHRcdGdldEFXYWxsZXQ6IFwiT2J0ZW4gdW5hIEJpbGxldGVyYVwiLFxuXHRcdHVzZUFXYWxsZXQ6IFwiVXNhIHR1IEJpbGxldGVyYSBwYXJhIHJlc2d1YXJkYXIgeSBhZG1pbmlzdHJhciB0dXMgYWN0aXZvcyBlbiBORUFSLCBlIEluaWNpYXIgc2VzacOzbiBlbiBjdWFscXVpZXIgYXBsaWNhY2lvbiBORUFSIHNpbiBsYSBuZWNlc2lkYWQgZGUgbm9tYnJlcyBkZSB1c3VhcmlvcyB5IGNvbnRyYXNlw7Fhc1wiLFxuXHRcdGNvbm5lY3Rpb25GYWlsZWQ6IFwiQ29uZXhpw7NuIEZhbGxpZGFcIixcblx0XHRjb25uZWN0aW9uU3VjY2Vzc2Z1bDogXCJDb25leGnDs24gRXhpc3Rvc2FcIixcblx0XHRjb25uZWN0ZWQ6IFwiQ29uZWN0YWRvXCIsXG5cdFx0Y29ubmVjdGluZ1RvOiBcIkNvbmVjdGFuZG8gYSBcIixcblx0XHRjb25uZWN0aW5nTWVzc2FnZToge1xuXHRcdFx0aW5qZWN0ZWQ6IFwiQ29uZmlybWUgbGEgY29uZXhpw7NuIGVuIGxhIHZlbnRhbmEgZGUgZXh0ZW5zacOzblwiLFxuXHRcdFx0YnJvd3NlcjogXCJDb25maXJtZSBsYSBjb25leGnDs24gZW4gbGEgYmlsbGV0ZXJhIGRlc3B1w6lzIGRlIGxhIHJlZGlyZWNjacOzblwiLFxuXHRcdFx0aGFyZHdhcmU6IFwiQ29uZmlybWUgbGEgY29uZXhpw7NuIGVuIGVsIGRpc3Bvc2l0aXZvIGRlIGxpYnJvIG1heW9yXCIsXG5cdFx0XHRicmlkZ2U6IFwiQ29uZmlybWFyIGxhIGNvbmV4acOzbiBlbiBsYSBiaWxsZXRlcmFcIlxuXHRcdH1cblx0fSxcblx0bGVkZ2VyOiB7XG5cdFx0Y29ubmVjdFdpdGhMZWRnZXI6IFwiQ29uZWN0YXIgY29uIExlZGdlclwiLFxuXHRcdG1ha2VTdXJlWW91ckxlZGdlcjogXCJBc2Vnw7pyZXNlIGRlIHF1ZSBzdSBsZWRnZXIgZXN0w6EgY29uZWN0YWRhIGRlIGZvcm1hIHNlZ3VyYSB5IHF1ZSBsYSBhcGxpY2FjaW9uIE5FQVIgZXN0w6kgYWJpZXJ0YSBlbiBzdSBkaXNwb3NpdGl2b1wiLFxuXHRcdFwiY29udGludWVcIjogXCJDb250aW51YXJcIixcblx0XHRzcGVjaWZ5SERQYXRoOiBcIkVzcGVjaWZpcXVlIGxhIHJ1dGEgSERcIixcblx0XHRlbnRlcllvdXJQcmVmZXJyZWRIRFBhdGg6IFwiSW5ncmVzZSBzdSBydXRhIEhEIHByZXJpZGEseSBsdWVnbyBidXNxdWUgY3VhbHF1aWVyIGN1ZW50YSBhY3RpdmEuXCIsXG5cdFx0c2NhbjogXCJFc2NhbmVhclwiLFxuXHRcdHJldHJ5OiBcIlJlaW50ZW50YXJcIixcblx0XHRsZWRnZXJJc05vdEF2YWlsYWJsZTogXCJFbCBMZWRnZXIgbm8gZXN0w6EgZGlzcG9uaWJsZVwiLFxuXHRcdGFjY2Vzc0RlbmllZFRvVXNlTGVkZ2VyRGV2aWNlOiBcIkFjY2VzbyBkZW5lZ2FkbyBwYXJhIHVzYXIgZWwgZGlzcG9zaXRpdm8gbGVkZ2VyXCIsXG5cdFx0bm9BY2NvdW50c0ZvdW5kOiBcIk5vIHNlIGVuY29udHJhcm9uIGN1ZW50YXNcIixcblx0XHRzZWxlY3RZb3VyQWNjb3VudHM6IFwiU2VsZWNjaW9uYSB0dXMgY3VlbnRhc1wiLFxuXHRcdGNvbm5lY3RpbmcxQWNjb3VudDogXCJDb25lY3RhbmRvIGEgMSBjdWVudGFcIixcblx0XHRjYW50RmluZEFueUFjY291bnQ6IFwiTm8gc2UgcHVkbyBlbmNvbnRyYXIgbmluZ3VuYSBjdWVudGEgYXNvY2lhZGEgY29uIGVzdGUgbGVkZ2VyLFBvciBmYXZvciBjcmVhIHVuYSBudWV2YSBjdWVudGEgZW4gTkVBUlwiLFxuXHRcdG9yQ29ubmVjdEFuQW5vdGhlckxlZGdlcjogXCJvIGNvbmVjdGEgb3RybyBsZWRnZXJcIixcblx0XHRjb25uZWN0aW5nOiBcIkNvbmVjdGFuZG9cIixcblx0XHRvZkFjY291bnRzOiBcImRlIEN1ZW50YXNcIixcblx0XHRmYWlsZWRUb0F1dG9tYXRpY2FsbHk6IFwiTm8gc2UgcHVkbyBlbmNvbnRyYXIgYXV0b21hdGljYW1lbnRlIGVsIGlkIGRlIGxhIGN1ZW50YSxJbmdyZXNhbG8gbWFudWFsbWVudGU6XCIsXG5cdFx0b3ZlcnZpZXdUaGVMaXN0T2ZBdXRob3JpemVkOiBcIlJldmlzZSBsYSBsaXN0YSBkZSBsYXMgY3VlbnRhcyBhdXRvcml6YWRhcyxDb21wbGV0ZSBlbCBpbmljaW8gZGUgc2VzacOzbiBoYWNpZWRvIGNsaWNrIGEgY291bnRpbnVhY2lvbi5cIixcblx0XHRmaW5pc2g6IFwiRmluYWxpemFyXCJcblx0fSxcblx0aW5zdGFsbDoge1xuXHRcdHlvdWxsTmVlZFRvSW5zdGFsbDogXCJUZW5kcsOhcyBxdWUgaW5zdGFsYXJcIixcblx0XHR0b0NvbnRpbnVlQWZ0ZXJJbnN0YWxsaW5nOiBcIlBhcmEgY29udGludWFyLCBEZXNwdWVzIGRlIGluc3RhbGFyXCIsXG5cdFx0cmVmcmVzaFRoZVBhZ2U6IFwiUmVjYXJnYSBsYSBwYWdpbmFcIixcblx0XHRvcGVuOiBcIkFicmlyXCJcblx0fSxcblx0cXI6IHtcblx0XHRjb3BpZWRUb0NsaXBib2FyZDogXCJDb3BpYWRvIGFsIFBvcnRhcGFwZWxlc1wiLFxuXHRcdGZhaWxlZFRvQ29weTogXCJGYWxsw7MgbGEgY29waWEgYWwgUG9ydGFwYXBlbGVzXCIsXG5cdFx0c2NhbldpdGhZb3VyTW9iaWxlOiBcIkJ1c2NhIGNvbiB0dSBkaXNwb3NpdGl2byBtb3ZpbFwiLFxuXHRcdGNvcHlUb0NsaXBib2FyZDogXCIgQ29waWFyIGFsIFBvcnRhcGFwZWxlc1wiLFxuXHRcdHByZWZlclRoZU9mZmljaWFsOiBcIsK/UHJlZmlyZXMgZWwgZGnDoWxvZ28gb2ZpY2lhbCBkZVwiLFxuXHRcdG9wZW46IFwiQWJyaXJcIlxuXHR9LFxuXHR3YWxsZXRUeXBlczoge1xuXHRcdGhhcmR3YXJlOiBcIkhhcmR3YXJlIFdhbGxldFwiLFxuXHRcdGJyb3dzZXI6IFwiQnJvd3NlciBXYWxsZXRcIixcblx0XHRpbmplY3RlZDogXCJXYWxsZXQgRXh0ZW5zaW9uXCIsXG5cdFx0YnJpZGdlOiBcIkJyaWRnZSBXYWxsZXRcIixcblx0XHRtb2JpbGU6IFwiTW9iaWxlIFdhbGxldFwiLFxuXHRcdFwiaW5zdGFudC1saW5rXCI6IFwiSW5zdGFudCBXYWxsZXRcIlxuXHR9XG59O1xudmFyIGVzID0ge1xuXHRtb2RhbDogbW9kYWwkYVxufTtcblxudmFyIG1vZGFsJDkgPSB7XG5cdHdhbGxldDoge1xuXHRcdGNvbm5lY3RZb3VyV2FsbGV0OiBcIui/nuaOpeS9oOeahOmSseWMhVwiLFxuXHRcdHdoYXRJc0FXYWxsZXQ6IFwi5LuA5LmI5piv6ZKx5YyF77yfXCIsXG5cdFx0c2VjdXJlQW5kTWFuYWdlOiBcIuS/neaKpOWSjOeuoeeQhuS9oOeahOaVsOWtl+i1hOS6p1wiLFxuXHRcdHNhZmVseVN0b3JlOiBcIuWuieWFqOWtmOWCqOWSjOi9rOenu+S9oOeahOWKoOWvhui0p+W4geWSjE5GVFwiLFxuXHRcdGxvZ0luVG9Bbnk6IFwi55m75b2V5Lu75L2VIE5FQVIg5bqU55SoXCIsXG5cdFx0bm9OZWVkVG9DcmVhdGU6IFwi5LiN6ZyA6KaB5Yib5bu65paw6LSm5oi35oiW5a+G56CB44CC6L+e5o6l5L2g55qE6ZKx5YyF77yM5Y2z5Y+v5byA5aeL5L2/55So77yBXCIsXG5cdFx0Z2V0QVdhbGxldDogXCLojrflj5bmlrDotKbmiLdcIixcblx0XHR1c2VBV2FsbGV0OiBcIuS9v+eUqOmSseWMheadpeS/neaKpOWSjOeuoeeQhuS9oOeahCBORUFSIOi1hOS6p++8jOaXoOmcgOeUqOaIt+WQjeWSjOWvhueggeWNs+WPr+eZu+W9leS7u+S9lSBORUFSIOW6lOeUqFwiLFxuXHRcdGNvbm5lY3Rpb25GYWlsZWQ6IFwi6L+e5o6l5aSx6LSlXCIsXG5cdFx0Y29ubmVjdGlvblN1Y2Nlc3NmdWw6IFwi6L+e5o6l5oiQ5YqfXCIsXG5cdFx0Y29ubmVjdGVkOiBcIuW3sui/nuaOpVwiLFxuXHRcdGNvbm5lY3RpbmdUbzogXCLmraPlnKjov57mjqVcIlxuXHR9LFxuXHRsZWRnZXI6IHtcblx0XHRjb25uZWN0V2l0aExlZGdlcjogXCLov57mjqUgTGVkZ2VyXCIsXG5cdFx0bWFrZVN1cmVZb3VyTGVkZ2VyOiBcIuehruS/neS9oOeahCBMZWRnZXIg5bey57uP5a6J5YWo6L+e5o6l77yM5bm25LiUIE5FQVIg5bqU55So5bey57uP5Zyo5L2g6K6+5aSH5LiK5omT5byAXCIsXG5cdFx0XCJjb250aW51ZVwiOiBcIue7p+e7rVwiLFxuXHRcdHNwZWNpZnlIRFBhdGg6IFwi5oyH5a6aIEhEIOi3r+W+hFwiLFxuXHRcdGVudGVyWW91clByZWZlcnJlZEhEUGF0aDogXCLovpPlhaXkvaDlgY/lpb3nmoQgSEQg6Lev5b6E77yM54S25ZCO5Li65Lu75oSP5rS76LeD6LSm5oi35omr56CBXCIsXG5cdFx0c2NhbjogXCLmiavnoIFcIixcblx0XHRyZXRyeTogXCLph43or5VcIixcblx0XHRsZWRnZXJJc05vdEF2YWlsYWJsZTogXCJMZWRnZXIg5LiN5Y+v55SoXCIsXG5cdFx0YWNjZXNzRGVuaWVkVG9Vc2VMZWRnZXJEZXZpY2U6IFwi6K6/6ZeuIExlZGdlciDorr7lpIfooqvmi5Lnu51cIixcblx0XHRub0FjY291bnRzRm91bmQ6IFwi5rKh5pyJ5om+5Yiw6LSm5oi3XCIsXG5cdFx0c2VsZWN0WW91ckFjY291bnRzOiBcIumAieaLqeS9oOeahOi0puaIt1wiLFxuXHRcdGNvbm5lY3RpbmcxQWNjb3VudDogXCLmraPlnKjov57mjqUx5Liq6LSm5oi3XCIsXG5cdFx0Y2FudEZpbmRBbnlBY2NvdW50OiBcIuayoeacieaJvuWIsOS7u+S9leS4jui/meS4qiBMZWRnZXIg55u45YWz6IGU55qE6LSm5oi344CC6K+35Yib5bu65paw6LSm5oi35LqOXCIsXG5cdFx0XCJvckNvbm5lY3RBbkFub3RoZXJMZWRnZXIuXCI6IFwi5oiW6L+e5o6l5Y+m5LiA5LiqIExlZGdlclwiLFxuXHRcdGNvbm5lY3Rpbmc6IFwi5q2j5Zyo6L+e5o6lXCIsXG5cdFx0b2ZBY2NvdW50czogXCLkuKrotKbmiLdcIixcblx0XHRmYWlsZWRUb0F1dG9tYXRpY2FsbHk6IFwi5peg5rOV6Ieq5Yqo5om+5Yiw6LSm5oi3SUTvvIzor7fkuLvliqjmj5DkvpvvvJpcIixcblx0XHRvdmVydmlld1RoZUxpc3RPZkF1dGhvcml6ZWQ6IFwi6K+35p+l55yL5bey5o6I5p2D55qE6LSm5oi35YiX6KGo77yM54K55Ye75Lul5LiL5oyJ6ZKu5a6M5oiQ55m75b2VXCIsXG5cdFx0ZmluaXNoOiBcIuWujOaIkFwiXG5cdH0sXG5cdGluc3RhbGw6IHtcblx0XHR5b3VsbE5lZWRUb0luc3RhbGw6IFwi5L2g5bCG6ZyA6KaB5a6J6KOFXCIsXG5cdFx0dG9Db250aW51ZUFmdGVySW5zdGFsbGluZzogXCLku6Xnu6fnu63jgILlronoo4XlroxcIixcblx0XHRyZWZyZXNoVGhlUGFnZTogXCLor7fliLfmlrDpobXpnaJcIixcblx0XHRvcGVuOiBcIuaJk+W8gFwiXG5cdH0sXG5cdHFyOiB7XG5cdFx0Y29waWVkVG9DbGlwYm9hcmQ6IFwi5aSN5Yi25Yiw5LqG5Ymq6LS05p2/XCIsXG5cdFx0ZmFpbGVkVG9Db3B5OiBcIuWkjeWItuWIsOWJqui0tOadv+Wksei0pVwiLFxuXHRcdHNjYW5XaXRoWW91ck1vYmlsZTogXCLnlKjkvaDnmoTnp7vliqjorr7lpIfmiavnoIFcIixcblx0XHRjb3B5VG9DbGlwYm9hcmQ6IFwiIOWkjeWItuWIsOWJqui0tOadv1wiLFxuXHRcdHByZWZlclRoZU9mZmljaWFsOiBcIuW4jOacm+S9v+eUqOWumOaWueWvueivneahhuS6jlwiLFxuXHRcdG9wZW46IFwi5omT5byAXCJcblx0fSxcblx0d2FsbGV0VHlwZXM6IHtcblx0XHRoYXJkd2FyZTogXCJIYXJkd2FyZSBXYWxsZXRcIixcblx0XHRicm93c2VyOiBcIkJyb3dzZXIgV2FsbGV0XCIsXG5cdFx0aW5qZWN0ZWQ6IFwiV2FsbGV0IEV4dGVuc2lvblwiLFxuXHRcdGJyaWRnZTogXCJCcmlkZ2UgV2FsbGV0XCIsXG5cdFx0bW9iaWxlOiBcIk1vYmlsZSBXYWxsZXRcIixcblx0XHRcImluc3RhbnQtbGlua1wiOiBcIkluc3RhbnQgV2FsbGV0XCJcblx0fVxufTtcbnZhciB6aCA9IHtcblx0bW9kYWw6IG1vZGFsJDlcbn07XG5cbnZhciBtb2RhbCQ4ID0ge1xuXHR3YWxsZXQ6IHtcblx0XHRjb25uZWN0WW91cldhbGxldDogXCLQodCy0YrRgNC20LXRgtC1INCy0LDRiNC40Y8g0J/QvtGA0YLRhNC10LnQu1wiLFxuXHRcdHdoYXRJc0FXYWxsZXQ6IFwi0JrQsNC60LLQviDQtSDQn9C+0YDRgtGE0LXQudC7P1wiLFxuXHRcdHNlY3VyZUFuZE1hbmFnZTogXCLQl9Cw0YnQuNGC0LXRgtC1INC4INGD0L/RgNCw0LLQu9GP0LLQsNC50YLQtSDQtNC40LPQuNGC0LDQu9C90LjRgtC1INGB0Lgg0LDQutGC0LjQstC4XCIsXG5cdFx0c2FmZWx5U3RvcmU6IFwi0KHRitGF0YDQsNC90Y/QstCw0LnRgtC1INC4INC/0YDQtdGF0LLRitGA0LvRj9C50YLQtSDQsdC10LfQvtC/0LDRgdC90L4g0LLQsNGI0LjRgtC1INC60YDQuNC/0YLQviDQuCBORlQuXCIsXG5cdFx0bG9nSW5Ub0FueTogXCLQmNC30L/QvtC70LfQstCw0LnRgtC1INCy0YHRj9C60L4g0L/RgNC40LvQvtC20LXQvdC40LUg0L3QsCBORUFSXCIsXG5cdFx0bm9OZWVkVG9DcmVhdGU6IFwi0J3Rj9C80LAg0L3Rg9C20LTQsCDQtNCwINGB0YrQt9C00LDQstCw0YLQtSDQvdC+0LLQuCDQv9GA0L7RhNC40LvQuC4g0KHQstGK0YDQttC10YLQtSDQv9C+0YDRgtGE0LXQudC70LAg0YHQuCDQuCDRgdGC0LUg0LPQvtGC0L7QstC4IVwiLFxuXHRcdGdldEFXYWxsZXQ6IFwi0KHRitC30LTQsNC50YLQtSDQn9C+0YDRgtGE0LXQudC7XCIsXG5cdFx0dXNlQVdhbGxldDogXCLQmNC30L/QvtC70LfQstCw0LnRgtC1INC/0L7RgNGC0YTQtdC50LvQsCwg0LfQsCDQtNCwINC30LDRidC40YLQuNGC0LUg0Lgg0YPQv9GA0LDQstC70Y/QstCw0YLQtSDQsNC60YLQuNCy0LjRgtC1INGB0Lgg0L3QsCBORUFSINC60LDQutGC0L4g0Lgg0LTQsCDQuNC30L/QvtC70LfQstCw0YLQtSDQstGB0Y/QutC+INC/0YDQuNC70L7QttC10L3QuNC1INC90LAgTkVBUiDQsdC10Lcg0L3Rg9C20LTQsCDQvtGCINC/0L7RgtGA0LXQsdC40YLQtdC70YHQutC4INC40LzQtdC90LAg0Lgg0L/QsNGA0L7Qu9C4LlwiLFxuXHRcdGNvbm5lY3Rpb25GYWlsZWQ6IFwi0KHQstGK0YDQt9Cy0LDQvdC10YLQviDQvdC10YPRgdC/0LXRiNC90L5cIixcblx0XHRjb25uZWN0aW9uU3VjY2Vzc2Z1bDogXCLQodCy0YrRgNC30LLQsNC90LXRgtC+INGD0YHQv9C10YjQvdC+XCIsXG5cdFx0Y29ubmVjdGVkOiBcItCh0LLRitGA0LfQsNC9XCIsXG5cdFx0Y29ubmVjdGluZ1RvOiBcItCh0LLRitGA0LfQstCw0L3QtSDQutGK0LxcIixcblx0XHRjb25uZWN0aW5nTWVzc2FnZToge1xuXHRcdFx0aW5qZWN0ZWQ6IFwi0J/QvtGC0LLRitGA0LTQtdGC0LUg0YHQstGK0YDQt9Cy0LDQvdC10YLQviDQsiDQv9GA0L7Qt9C+0YDQtdGG0LAg0L3QsCDRgNCw0LfRiNC40YDQtdC90LjQtdGC0L5cIixcblx0XHRcdGJyb3dzZXI6IFwi0J/QvtGC0LLRitGA0LTQtdGC0LUg0YHQstGK0YDQt9Cy0LDQvdC10YLQviDQsiDQv9C+0YDRgtGE0LXQudC70LAg0YHQu9C10LQg0L/RgNC10L3QsNGB0L7Rh9Cy0LDQvdC10YLQvlwiLFxuXHRcdFx0aGFyZHdhcmU6IFwi0J/QvtGC0LLRitGA0LTQtdGC0LUg0YHQstGK0YDQt9Cy0LDQvdC10YLQviDQsiDRhdCw0YDQtNGD0LXRgNC90LjRjyDQv9C+0YDRgtGE0LXQudC7XCIsXG5cdFx0XHRicmlkZ2U6IFwi0J/QvtGC0LLRitGA0LTQtdGC0LUg0LLRgNGK0LfQutCw0YLQsCDQsiDQv9C+0YDRgtGE0LXQudC70LBcIlxuXHRcdH1cblx0fSxcblx0bGVkZ2VyOiB7XG5cdFx0Y29ubmVjdFdpdGhMZWRnZXI6IFwi0KHQstGK0YDQttC10YLQtSDRgdC1INGBIExlZGdlclwiLFxuXHRcdG1ha2VTdXJlWW91ckxlZGdlcjogXCLQo9Cy0LXRgNC10YLQtSDRgdC1LCDRh9C1INCy0LDRiNC40Y/RgiBMZWRnZXIg0LUg0YHQstGK0YDQt9Cw0L0g0Lgg0YfQtSDQv9GA0LjQu9C+0LbQtdC90LjQtdGC0L4gTkVBUiDQtSDQvtGC0LLQvtGA0LXQvdC+INC9YSDQvdC10LPQvi5cIixcblx0XHRcImNvbnRpbnVlXCI6IFwi0J/RgNC+0LTRitC70LbQtdGC0LVcIixcblx0XHRzcGVjaWZ5SERQYXRoOiBcItCf0L7RgdC+0YfQtdGC0LUgSEQg0L/RitGCXCIsXG5cdFx0ZW50ZXJZb3VyUHJlZmVycmVkSERQYXRoOiBcItCS0YrQstC10LTQtdGC0LUg0L/RgNC10LTQv9C+0YfQuNGC0LDQvdC40Y8gSEQg0L/RitGCLCDRgdC70LXQtCDQutC+0LXRgtC+INGB0LrQsNC90LjRgNCw0LnRgtC1INC30LAg0LDQutGC0LjQstC90Lgg0LDQutCw0YPQvdGC0LguXCIsXG5cdFx0c2NhbjogXCLQodC60LDQvdC40YDQsNC50YLQtVwiLFxuXHRcdHJldHJ5OiBcItCe0L/QuNGC0LDQudGC0LUg0L7RgtC90L7QstC+XCIsXG5cdFx0bGVkZ2VySXNOb3RBdmFpbGFibGU6IFwiTGVkZ2VyINGD0YHRgtGA0L7QudGB0YLQstC+0YLQviDQvdC1INC1INC00L7RgdGC0YrQv9C90L5cIixcblx0XHRhY2Nlc3NEZW5pZWRUb1VzZUxlZGdlckRldmljZTogXCLQlNC+0YHRgtGK0L/RitGCINC30LAg0LjQt9C/0L7Qu9C30LLQsNC90LUg0L3QsCBMZWRnZXIg0LUg0L7RgtC60LDQt9Cw0L1cIixcblx0XHRub0FjY291bnRzRm91bmQ6IFwi0J3Rj9C80LAg0L3QsNC80LXRgNC10L3QuCDQv9GA0L7RhNC40LvQuFwiLFxuXHRcdHNlbGVjdFlvdXJBY2NvdW50czogXCLQmNC30LHQtdGA0LXRgtC1INCy0LDRiNC40YLQtSDQv9GA0L7RhNC40LvQuFwiLFxuXHRcdGNvbm5lY3RpbmcxQWNjb3VudDogXCLQodCy0YrRgNC30LLQsNC90LUg0L3QsCAxINC/0YDQvtGE0LjQu1wiLFxuXHRcdGNhbnRGaW5kQW55QWNjb3VudDogXCLQndGP0LzQsCDQvdCw0LzQtdGA0LXQvdC4INC/0YDQvtGE0LjQu9C4LCDRgdGK0LLRgNC30LDQvdC4INGBINGC0L7Qt9C4IExlZGdlci4g0JzQvtC70Y8sINGB0YrQt9C00LDQudGC0LUg0L3QvtCyIE5FQVIg0L/RgNC+0YTQuNC7INC90LBcIixcblx0XHRvckNvbm5lY3RBbkFub3RoZXJMZWRnZXI6IFwi0LjQu9C4INGB0LLRitGA0LbQtdGC0LUg0LTRgNGD0LMgTGVkZ2VyLlwiLFxuXHRcdGNvbm5lY3Rpbmc6IFwi0KHQstGK0YDQt9Cy0LDQvdC1XCIsXG5cdFx0b2ZBY2NvdW50czogXCLQvtGCINC/0YDQvtGE0LjQu9C4XCIsXG5cdFx0ZmFpbGVkVG9BdXRvbWF0aWNhbGx5OiBcItCQ0LLRgtC+0LzQsNGC0LjRh9C90L7RgtC+INC90LDQvNC40YDQsNC90LUg0L3QsCDQv9GA0L7RhNC40LvQsCDQvdC1INCx0LUg0YPRgdC/0LXRiNC90L4uINCS0YrQstC10LTQtdGC0LUg0LPQviDRgNGK0YfQvdC+OlwiLFxuXHRcdG92ZXJ2aWV3VGhlTGlzdE9mQXV0aG9yaXplZDogXCLQn9GA0LXQs9C70LXQtNCw0LnRgtC1INGB0L/QuNGB0YrQutCwINGBINGD0L/RitC70L3QvtC80L7RidC10L3QuCDQv9GA0L7RhNC40LvQuCwg0LfQsNCy0YrRgNGI0LXRgtC1INCy0LvQuNC30LDQvdC10YLQviwg0LrQsNGC0L4g0YnRgNCw0LrQvdC10YLQtSDQstGK0YDRhdGDINCx0YPRgtC+0L3QsCDQv9C+LdC00L7Qu9GDLi5cIixcblx0XHRmaW5pc2g6IFwi0JfQsNCy0YrRgNGI0LXRgtC1XCJcblx0fSxcblx0aW5zdGFsbDoge1xuXHRcdHlvdWxsTmVlZFRvSW5zdGFsbDogXCLQqdC1INGC0YDRj9Cx0LLQsCDQtNCwINC40L3RgdGC0LDQu9C40YDQsNGC0LVcIixcblx0XHR0b0NvbnRpbnVlQWZ0ZXJJbnN0YWxsaW5nOiBcItC30LAg0LTQsCDQv9GA0L7QtNGK0LvQttC40YLQtS4g0KHQu9C10LQg0LjQvdGB0YLQsNC70LjRgNCw0L3QtVwiLFxuXHRcdHJlZnJlc2hUaGVQYWdlOiBcItC/0YDQtdC30LDRgNC10LTQtdGC0LUg0YHRgtGA0LDQvdC40YbQsNGC0LAuXCIsXG5cdFx0b3BlbjogXCLQntGC0LLQvtGA0LXRgtC1XCJcblx0fSxcblx0cXI6IHtcblx0XHRjb3BpZWRUb0NsaXBib2FyZDogXCLQmtC+0L/QuNGA0LDQvdC+INCyINC60LvQuNC/0LHQvtGA0LTQsFwiLFxuXHRcdGZhaWxlZFRvQ29weTogXCLQndC10YPRgdC/0LXRiNC90L4g0LrQvtC/0LjRgNCw0L3QtSDQsiDQutC70LjQv9Cx0L7RgNC00LBcIixcblx0XHRzY2FuV2l0aFlvdXJNb2JpbGU6IFwiINCh0LrQsNC90LjRgNCw0LnRgtC1INGBINC80L7QsdC40LvQvdC+0YLQviDRgdC4INGD0YHRgtGA0L7QudGB0YLQstC+XCIsXG5cdFx0Y29weVRvQ2xpcGJvYXJkOiBcIiDQmtC+0L/QuNGA0LDQudGC0LUg0LIg0LrQu9C40L/QsdC+0YDQtNCwXCIsXG5cdFx0cHJlZmVyVGhlT2ZmaWNpYWw6IFwi0J/RgNC10LTQv9C+0YfQuNGC0LDQvSDQtdC30LjQuiDQt9CwINC60L7RgNC10YHQv9C+0L3QtNC10L3RhtC40Y9cIixcblx0XHRvcGVuOiBcItCe0YLQstC+0YDQtdGC0LVcIlxuXHR9LFxuXHR3YWxsZXRUeXBlczoge1xuXHRcdGhhcmR3YXJlOiBcIkhhcmR3YXJlIFdhbGxldFwiLFxuXHRcdGJyb3dzZXI6IFwiQnJvd3NlciBXYWxsZXRcIixcblx0XHRpbmplY3RlZDogXCJXYWxsZXQgRXh0ZW5zaW9uXCIsXG5cdFx0YnJpZGdlOiBcIkJyaWRnZSBXYWxsZXRcIixcblx0XHRtb2JpbGU6IFwiTW9iaWxlIFdhbGxldFwiLFxuXHRcdFwiaW5zdGFudC1saW5rXCI6IFwiSW5zdGFudCBXYWxsZXRcIlxuXHR9XG59O1xudmFyIGJnID0ge1xuXHRtb2RhbDogbW9kYWwkOFxufTtcblxudmFyIG1vZGFsJDcgPSB7XG5cdHdhbGxldDoge1xuXHRcdGNvbm5lY3RZb3VyV2FsbGV0OiBcIuyngOqwkSDsl7DqsrDtlZjquLBcIixcblx0XHR3aGF0SXNBV2FsbGV0OiBcIuyngOqwkeydgCDrrLTsiqgg7Jet7ZWg7J2EIO2VmOuCmOyalD9cIixcblx0XHRzZWN1cmVBbmRNYW5hZ2U6IFwi64u57Iug7J2YIOuUlOyngO2EuCDsnpDsgrDsnYQg67O07Zi47ZWY6rOgIOq0gOumrO2VqeuLiOuLpC5cIixcblx0XHRzYWZlbHlTdG9yZTogXCLslZTtmLjtmZTtj5DsmYAgTkZU66W8IOyViOyghO2VmOqyjCDsoIDsnqXtlZjqs6Ag7KCE7Iah7ZWgIOyImCDsnojsirXri4jri6QuXCIsXG5cdFx0bG9nSW5Ub0FueTogXCJORUFSIEFwcOyXkCDroZzqt7jsnbjtlanri4jri6QuXCIsXG5cdFx0bm9OZWVkVG9DcmVhdGU6IFwi7IOI66Gc7Jq0IOqzhOygleydtOuCmCDruYTrsIDrsojtmLjrpbwg66eM65OkIO2VhOyalCDsl4bsnbQg7KeA6rCR7J2EIOyXsOqysO2VnCDtm4Qg67CU66GcIOyCrOyaqe2VoCDsiJgg7J6I7Iq164uI64ukLlwiLFxuXHRcdGdldEFXYWxsZXQ6IFwi7KeA6rCRIOqwgOyguOyYpOq4sFwiLFxuXHRcdHVzZUFXYWxsZXQ6IFwi7KeA6rCR7J2EIOyCrOyaqe2VmOyXrCBORUFSIOyekOyCsOydhCDrs7TtmLjCt+q0gOumrO2VmOqzoCwg7JWE7J2065SU7JmAIOu5hOuwgOuyiO2YuCDsl4bsnbQgTkVBUiDslbHsl5Ag66Gc6re47J247ZWgIOyImCDsnojsirXri4jri6QuXCIsXG5cdFx0Y29ubmVjdGlvbkZhaWxlZDogXCLsl7DqsrAg7Iuk7YyoXCIsXG5cdFx0Y29ubmVjdGlvblN1Y2Nlc3NmdWw6IFwi7Jew6rKwIOyEseqztVwiLFxuXHRcdGNvbm5lY3RlZDogXCJDb25uZWN0ZWRcIixcblx0XHRjb25uZWN0aW5nVG86IFwi7Jew6rKwIOykkTogXCIsXG5cdFx0Y29ubmVjdGluZ01lc3NhZ2U6IHtcblx0XHRcdGluamVjdGVkOiBcIuydteyKpO2FkOyFmCDssL3sl5DshJwg7Jew6rKw7J2EIO2ZleyduO2VmOyEuOyalFwiLFxuXHRcdFx0YnJvd3NlcjogXCLrpqzri6TsnbTroIntirgg65CcIOyngOqwkeyXkOyEnCDsl7DqsrDsnYQg7ZmV7J247ZWY7IS47JqUXCIsXG5cdFx0XHRoYXJkd2FyZTogXCJMZWRnZXIg6riw6riw7JeQ7IScIOyXsOqysOydhCDtmZXsnbjtlZjshLjsmpRcIixcblx0XHRcdGJyaWRnZTogXCLsp4DqsJHsl5DshJwg7Jew6rKwIO2ZleyduFwiXG5cdFx0fVxuXHR9LFxuXHRsZWRnZXI6IHtcblx0XHRjb25uZWN0V2l0aExlZGdlcjogXCJMZWRnZXIg7Jew6rKw7ZWY6riwXCIsXG5cdFx0bWFrZVN1cmVZb3VyTGVkZ2VyOiBcIkxlZGdlcuqwgCDslYjsoITtlZjqsowg7Jew6rKw65CY7Ja0IOyeiOqzoCwgTkVBUiDslbHsnbQg7Je066CkIOyeiOuKlCDsp4Ag7ZmV7J247ZWY7IS47JqUXCIsXG5cdFx0XCJjb250aW51ZVwiOiBcIuqzhOyGje2VmOq4sFwiLFxuXHRcdHNwZWNpZnlIRFBhdGg6IFwiSEQgUGF0aCDsp4DsoJXtlZjquLBcIixcblx0XHRlbnRlcllvdXJQcmVmZXJyZWRIRFBhdGg6IFwi7JuQ7ZWY64qUIEhEIFBhdGjrpbwg7ISg7YOd7ZWY6rOgLCDtmZzshLHtmZTrkJwg6rOE7KCV7J20IOyeiOuKlCDsp4Ag6rKA7IOJ7ZWY7IS47JqUXCIsXG5cdFx0c2NhbjogXCLqsoDsg4lcIixcblx0XHRyZXRyeTogXCLri6Tsi5wg7Iuc64+EXCIsXG5cdFx0bGVkZ2VySXNOb3RBdmFpbGFibGU6IFwiTGVkZ2Vy66W8IOyCrOyaqe2VoCDsiJgg7JeG7Iq164uI64ukXCIsXG5cdFx0YWNjZXNzRGVuaWVkVG9Vc2VMZWRnZXJEZXZpY2U6IFwiTGVkZ2VyIOq4sOq4sCDsoJHqt7wg6raM7ZWc7J20IOqxsOu2gOuQmOyXiOyKteuLiOuLpFwiLFxuXHRcdG5vQWNjb3VudHNGb3VuZDogXCLqs4TsoJXsnYQg7LC+7J2EIOyImCDsl4bsirXri4jri6RcIixcblx0XHRzZWxlY3RZb3VyQWNjb3VudHM6IFwi6rOE7KCVIOyEoO2Dne2VmOq4sFwiLFxuXHRcdGNvbm5lY3RpbmcxQWNjb3VudDogXCLtlZjrgpjsnZgg6rOE7KCV7JeQIOyXsOqysFwiLFxuXHRcdGNhbnRGaW5kQW55QWNjb3VudDogXCJMZWRnZXLsmYAg7Jew6rKw65CcIOqzhOygleydhCDssL7snYQg7IiYIOyXhuyKteuLiOuLpC4g7IOI66Gc7Jq0IOqzhOygleydhCDsg53shLHtlZjqsbDrgpggXCIsXG5cdFx0b3JDb25uZWN0QW5Bbm90aGVyTGVkZ2VyOiBcIuuLpOuluCBMZWRnZXLrpbwg7Jew6rKw7ZWY7IS47JqUXCIsXG5cdFx0Y29ubmVjdGluZzogXCLqs4TsoJUg7Jew6rKw7ZWY6riwOiBcIixcblx0XHRvZkFjY291bnRzOiBcIuqwnCDqs4TsoJXsnYQg7LC+7JWY7Iq164uI64ukXCIsXG5cdFx0ZmFpbGVkVG9BdXRvbWF0aWNhbGx5OiBcIuqzhOyglSBJROulvCDssL7sp4Ag66q77ZaI7Iq164uI64ukLiDsiJjrj5nsnLzroZwg7J6F66Cl7ZW07KO87IS47JqULlwiLFxuXHRcdG92ZXJ2aWV3VGhlTGlzdE9mQXV0aG9yaXplZDogXCLsnbjspp3rkJwg6rOE7KCVIOuqqeuhneydhCDtmZXsnbjtlZwg7ZuEIOyVhOuemCDrsoTtirzsnYQg7YG066at7ZWY7JesIOuhnOq3uOyduOydhCDsmYTro4ztlZjshLjsmpRcIixcblx0XHRmaW5pc2g6IFwi7JmE66OMXCJcblx0fSxcblx0d2FsbGV0VHlwZXM6IHtcblx0XHRoYXJkd2FyZTogXCLtlZjrk5zsm6jslrQg7KeA6rCRXCIsXG5cdFx0YnJvd3NlcjogXCLruIzrnbzsmrDsoIAg7KeA6rCRXCIsXG5cdFx0aW5qZWN0ZWQ6IFwi7KeA6rCRIO2ZleyepVwiLFxuXHRcdGJyaWRnZTogXCLruIzrpqzsp4Ag7KeA6rCRXCIsXG5cdFx0bW9iaWxlOiBcIuuqqOuwlOydvCDsp4DqsJFcIixcblx0XHRcImluc3RhbnQtbGlua1wiOiBcIuyduOyKpO2EtO2KuCDsp4DqsJFcIlxuXHR9LFxuXHRpbnN0YWxsOiB7XG5cdFx0eW91bGxOZWVkVG9JbnN0YWxsOiBcIuuLpOydjCDtmZXsnqUg7ZSE66Gc6re4656o7J2EIOyEpOy5mO2VtOyjvOyEuOyalDpcIixcblx0XHR0b0NvbnRpbnVlQWZ0ZXJJbnN0YWxsaW5nOiBcIi4g7ISk7LmYIOyZhOujjCDtm4Qg7Y6Y7J207KeAIOyDiOuhnCDqs6DsuajsnbQg7ZWE7JqU7ZWp64uI64ukLiBcIixcblx0XHRyZWZyZXNoVGhlUGFnZTogXCLsg4jroZwg6rOg7LmoXCIsXG5cdFx0b3BlbjogXCJPcGVuXCJcblx0fSxcblx0cXI6IHtcblx0XHRjb3BpZWRUb0NsaXBib2FyZDogXCLtgbTrpr3rs7Trk5zsl5Ag67O17IKsIOyZhOujjFwiLFxuXHRcdGZhaWxlZFRvQ29weTogXCLtgbTrpr3rs7Trk5zsl5Ag67O17IKsIOyLpO2MqFwiLFxuXHRcdHNjYW5XaXRoWW91ck1vYmlsZTogXCLrqqjrsJTsnbwg7J6l7LmY66W8IOyCrOyaqe2VmOyXrCDsiqTsupTtlbTso7zshLjsmpRcIixcblx0XHRjb3B5VG9DbGlwYm9hcmQ6IFwiIO2BtOumveuztOuTnOyXkCDrs7XsgqztlZjquLBcIixcblx0XHRwcmVmZXJUaGVPZmZpY2lhbDogXCLri6TsnYwg7ZSE66Gc6re4656o7JeQ7IScIOygnOqzte2VmOuKlCDqs7Xsi50g7ZSE66Gc7IS47Iqk66W8IOyEoO2YuO2VmOyLreuLiOq5jDogXCIsXG5cdFx0b3BlbjogXCJPcGVuXCJcblx0fVxufTtcbnZhciBrbyA9IHtcblx0bW9kYWw6IG1vZGFsJDdcbn07XG5cbnZhciBtb2RhbCQ2ID0ge1xuXHR3YWxsZXQ6IHtcblx0XHRjb25uZWN0WW91cldhbGxldDogXCJL4bq/dCBu4buRaSB2w60gY+G7p2EgYuG6oW5cIixcblx0XHR3aGF0SXNBV2FsbGV0OiBcIlbDrSBsw6AgZ8OsP1wiLFxuXHRcdHNlY3VyZUFuZE1hbmFnZTogXCJC4bqjbyBt4bqtdCAmIFF14bqjbiBsw70gdMOgaSBz4bqjbiBz4buRIGPhu6dhIGLhuqFuXCIsXG5cdFx0c2FmZWx5U3RvcmU6IFwiTMawdSB0cuG7ryB2w6AgY2h1eeG7g24gdGnhu4FuIMSRaeG7h24gdOG7rSB2w6AgTkZUIGPhu6dhIGLhuqFuIG3hu5l0IGPDoWNoIGFuIHRvw6BuLlwiLFxuXHRcdGxvZ0luVG9Bbnk6IFwixJDEg25nIG5o4bqtcCB2w6BvIGLhuqV0IGvhu7Mg4bupbmcgZOG7pW5nIHRyw6puIE5FQVJcIixcblx0XHRub05lZWRUb0NyZWF0ZTogXCJLaMO0bmcgY+G6p24gdOG6oW8gdMOgaSBraG/huqNuIGhv4bq3YyB0aMO0bmcgdGluIMSRxINuZyBuaOG6rXAgbeG7m2kuIEvhur90IG7hu5FpIHbDrSBj4bunYSBi4bqhbiB2w6AgYuG6r3QgxJHhuqd1IVwiLFxuXHRcdGdldEFXYWxsZXQ6IFwiVOG6oW8gVsOtXCIsXG5cdFx0dXNlQVdhbGxldDogXCJT4butIGThu6VuZyB2w60gxJHhu4MgYuG6o28gbeG6rXQgdsOgIHF14bqjbiBsw70gdMOgaSBz4bqjbiB0csOqbiBORUFSIGPhu6dhIGLhuqFuIHbDoCDEkcSDbmcgbmjhuq1wIHbDoG8gYuG6pXQga+G7syDhu6luZyBk4bulbmcgTkVBUiBuw6BvLCBraMO0bmcgY+G6p24gdMOqbiBuZ8aw4budaSBkw7luZyB2w6AgbeG6rXQga2jhuql1LlwiLFxuXHRcdGNvbm5lY3Rpb25GYWlsZWQ6IFwiS+G6v3QgbuG7kWkgdGjhuqV0IGLhuqFpXCIsXG5cdFx0Y29ubmVjdGlvblN1Y2Nlc3NmdWw6IFwiS+G6v3QgbuG7kWkgdGjDoG5oIGPDtG5nXCIsXG5cdFx0Y29ubmVjdGVkOiBcIsSQw6Mga+G6v3QgbuG7kWlcIixcblx0XHRjb25uZWN0aW5nVG86IFwixJBhbmcga+G6v3QgbuG7kWkgdOG7m2lcIixcblx0XHRjb25uZWN0aW5nTWVzc2FnZToge1xuXHRcdFx0aW5qZWN0ZWQ6IFwiWMOhYyBuaOG6rW4ga+G6v3QgbuG7kWkgdHJvbmcgY+G7rWEgc+G7lSB0aeG7h24gw61jaCBt4bufIHLhu5luZ1wiLFxuXHRcdFx0YnJvd3NlcjogXCJYw6FjIG5o4bqtbiBr4bq/dCBu4buRaSB0cm9uZyB2w60gc2F1IGtoaSDEkcaw4bujYyBjaHV54buDbiBoxrDhu5tuZ1wiLFxuXHRcdFx0aGFyZHdhcmU6IFwiWMOhYyBuaOG6rW4ga+G6v3QgbuG7kWkgduG7m2kgdsOtIGzhuqFuaFwiLFxuXHRcdFx0YnJpZGdlOiBcIljDoWMgbmjhuq1uIGvhur90IG7hu5FpIHRyb25nIHbDrVwiXG5cdFx0fVxuXHR9LFxuXHRsZWRnZXI6IHtcblx0XHRjb25uZWN0V2l0aExlZGdlcjogXCJL4bq/dCBu4buRaSB2w60gTGVkZ2VyXCIsXG5cdFx0bWFrZVN1cmVZb3VyTGVkZ2VyOiBcIsSQ4bqjbSBi4bqjbyBMZWRnZXIgY+G7p2EgYuG6oW4gxJHGsOG7o2Mga+G6v3QgbuG7kWkgYW4gdG/DoG4gdsOgIOG7qW5nIGThu6VuZyBORUFSIMSRYW5nIG3hu58gc+G6tW4gdHLDqm4gdGhp4bq/dCBi4buLXCIsXG5cdFx0XCJjb250aW51ZVwiOiBcIlRp4bq/cCB04bulY1wiLFxuXHRcdHNwZWNpZnlIRFBhdGg6IFwiQ2jhu4kgxJHhu4tuaCBIRCBQYXRoXCIsXG5cdFx0ZW50ZXJZb3VyUHJlZmVycmVkSERQYXRoOiBcIk5o4bqtcCBIRCBQYXRoIGPhu6dhIGLhuqFuLCBzYXUgxJHDsyBxdcOpdCB0w6xtIGPDoWMgdMOgaSBraG/huqNuIGhv4bqhdCDEkeG7mW5nXCIsXG5cdFx0c2NhbjogXCJRdcOpdFwiLFxuXHRcdHJldHJ5OiBcIlRo4butIGzhuqFpXCIsXG5cdFx0bGVkZ2VySXNOb3RBdmFpbGFibGU6IFwiTGVkZ2VyIGtow7RuZyBraOG6oyBk4bulbmdcIixcblx0XHRhY2Nlc3NEZW5pZWRUb1VzZUxlZGdlckRldmljZTogXCJUcnV5IGPhuq1wIExlZGdlciBi4buLIHThu6sgY2jhu5FpXCIsXG5cdFx0bm9BY2NvdW50c0ZvdW5kOiBcIktow7RuZyB0w6xtIHRo4bqleSB0w6BpIGtob+G6o25cIixcblx0XHRzZWxlY3RZb3VyQWNjb3VudHM6IFwiQ2jhu41uIHTDoGkga2hv4bqjbiBj4bunYSBi4bqhblwiLFxuXHRcdGNvbm5lY3RpbmcxQWNjb3VudDogXCLEkGFuZyBr4bq/dCBu4buRaSAxIHTDoGkga2hv4bqjblwiLFxuXHRcdGNhbnRGaW5kQW55QWNjb3VudDogXCJLaMO0bmcgdGjhu4MgdMOsbSB0aOG6pXkgYuG6pXQga+G7syB0w6BpIGtob+G6o24gbsOgbyDEkcaw4bujYyBsacOqbiBr4bq/dCB24bubaSBMZWRnZXIgbsOgeS4gVnVpIGzDsm5nIHThuqFvIG3hu5l0IHTDoGkga2hv4bqjbiBORUFSIG3hu5tpXCIsXG5cdFx0b3JDb25uZWN0QW5Bbm90aGVyTGVkZ2VyOiBcImhv4bq3YyBr4bq/dCBu4buRaSB24bubaSB2w60gTGVkZ2VyIGtow6FjLlwiLFxuXHRcdGNvbm5lY3Rpbmc6IFwixJBhbmcga+G6v3QgbuG7kWlcIixcblx0XHRvZkFjY291bnRzOiBcImPhu6dhIHTDoGkga2hv4bqjblwiLFxuXHRcdGZhaWxlZFRvQXV0b21hdGljYWxseTogXCJLaMO0bmcgdGjhu4MgdOG7sSDEkeG7mW5nIHTDrG0gaWQgdMOgaSBraG/huqNuLiBOaOG6rXAgdGjhu6cgY8O0bmc6XCIsXG5cdFx0b3ZlcnZpZXdUaGVMaXN0T2ZBdXRob3JpemVkOiBcIlThu5VuZyBxdWFuIGRhbmggc8OhY2ggY8OhYyB0w6BpIGtob+G6o24gxJHGsOG7o2Mg4buneSBxdXnhu4FuLCBob8OgbiB04bqldCDEkcSDbmcgbmjhuq1wIGLhurFuZyBjw6FjaCBi4bqlbSB2w6BvIG7DunQgYsOqbiBkxrDhu5tpLlwiLFxuXHRcdGZpbmlzaDogXCJIb8OgbiB0aMOgbmhcIlxuXHR9LFxuXHRpbnN0YWxsOiB7XG5cdFx0eW91bGxOZWVkVG9JbnN0YWxsOiBcIkLhuqFuIHPhur0gY+G6p24gY8OgaSDEkeG6t3RcIixcblx0XHR0b0NvbnRpbnVlQWZ0ZXJJbnN0YWxsaW5nOiBcIsSR4buDIGLhuq90IMSR4bqndS4gU2F1IGtoaSBjw6BpIMSR4bq3dCB4b25nXCIsXG5cdFx0cmVmcmVzaFRoZVBhZ2U6IFwiVOG6o2kgbOG6oWkgdHJhbmcuXCIsXG5cdFx0b3BlbjogXCJN4bufXCJcblx0fSxcblx0cXI6IHtcblx0XHRjb3BpZWRUb0NsaXBib2FyZDogXCLEkMOjIHNhbyBjaMOpcCB2w6BvIGLhuqNuZyBnaGkgdOG6oW1cIixcblx0XHRmYWlsZWRUb0NvcHk6IFwiU2FvIGNow6lwIHbDoG8gYuG6o25nIGdoaSB04bqhbSB0aOG6pXQgYuG6oWlcIixcblx0XHRzY2FuV2l0aFlvdXJNb2JpbGU6IFwiUXXDqXQgduG7m2kgxJFp4buHbiB0aG/huqFpIGPhu6dhIGLhuqFuXCIsXG5cdFx0Y29weVRvQ2xpcGJvYXJkOiBcIiBTYW8gY2jDqXAgdsOgbyBi4bqjbmcgZ2hpIHThuqFtXCIsXG5cdFx0cHJlZmVyVGhlT2ZmaWNpYWw6IFwiRGlhbG9ndWUgY2jDrW5oIHRo4bupYyBj4bunYVwiLFxuXHRcdG9wZW46IFwiTeG7n1wiXG5cdH0sXG5cdHdhbGxldFR5cGVzOiB7XG5cdFx0aGFyZHdhcmU6IFwiVsOtIGzhuqFuaFwiLFxuXHRcdGJyb3dzZXI6IFwiVsOtIHRyw6xuaCBkdXnhu4d0XCIsXG5cdFx0aW5qZWN0ZWQ6IFwiVsOtIHRp4buHbiDDrWNoIG3hu58gcuG7mW5nXCIsXG5cdFx0YnJpZGdlOiBcIlbDrSBD4bqndVwiLFxuXHRcdG1vYmlsZTogXCJWw60gTW9iaWxlXCIsXG5cdFx0XCJpbnN0YW50LWxpbmtcIjogXCJWw60gdOG7qWMgdGjDrFwiXG5cdH0sXG5cdGV4cG9ydEFjY291bnRzOiB7XG5cdFx0Y2hvb3NlQVdhbGxldDogXCJDaOG7jW4gdsOtXCIsXG5cdFx0dHJhbnNmZXJZb3VyQWNjb3VudHM6IFwiQ2h1eeG7g24gdMOgaSBraG/huqNuXCIsXG5cdFx0c2VsZWN0QVdhbGxldDogXCJDaOG7jW4gdsOtIHBow7kgaOG7o3AgduG7m2kgbmh1IGPhuqd1IGPhu6dhIGLhuqFuLCB2w60gxJHGsOG7o2MgY2jhu41uIGPhuqduIGjhu5cgdHLhu6MgY8OhYyB0w6BpIGtob+G6o24gxJFhbmcgc+G7rSBk4bulbmcuXCIsXG5cdFx0c2VsZWN0WW91ckFjY291bnRzOiBcIkNo4buNbiB0w6BpIGtob+G6o25cIixcblx0XHRhZnRlckRlY2lkZTogXCJTYXUga2hpIGNo4buNbiDEkcaw4bujYyB0w6BpIGtob+G6o24gYuG6oW4gY8OzIGNodXnhu4NuLlwiLFxuXHRcdGRpc2NsYWltZXI6IFwiQuG6oW4ga2jDtG5nIHRo4buDIGNodXnhu4NuIHTDoGkga2hv4bqjbiBu4bq/dSB0w6BpIGtob+G6o24gxJHDsyBjaMawYSDEkcaw4bujYyBuaOG6rW4gdGnhu4FuIGhv4bq3YyBjaMawYSBwaMOhdCBzaW5oIGdpYW8gZOG7i2NoIHRyw6puIE5FQVIuXCIsXG5cdFx0d2FybmluZzogXCJraMO0bmcgaOG7lyB0cuG7oyB4deG6pXQgdMOgaSBraG/huqNuLiBWdWkgbMOybmcgY2jhu41uIHbDrSBraMOhYy5cIixcblx0XHR3YWxsZXRUeXBlczoge1xuXHRcdFx0aGFyZHdhcmU6IFwiVsOtIGzhuqFuaFwiLFxuXHRcdFx0YnJvd3NlcjogXCJWw60gdHLDrG5oIGR1eeG7h3RcIixcblx0XHRcdGluamVjdGVkOiBcIlbDrSB0aeG7h24gw61jaCBt4bufIHLhu5luZ1wiLFxuXHRcdFx0YnJpZGdlOiBcIlbDrSBD4bqndVwiLFxuXHRcdFx0bW9iaWxlOiBcIlbDrSBNb2JpbGVcIlxuXHRcdH0sXG5cdFx0c2VsZWN0QWNjb3VudHM6IHtcblx0XHRcdHRpdGxlOiBcIkNo4buNbiB0w6BpIGtob+G6o24gxJHhu4MgY2h1eeG7g25cIixcblx0XHRcdGJ1dHRvbjogXCJM4bqleSBj4bulbSBt4bqtdCBraOG6qXVcIixcblx0XHRcdGRlc2VsZWN0QWxsOiBcIkLhu48gY2jhu41uIHThuqV0IGPhuqNcIixcblx0XHRcdHNlbGVjdEFsbDogXCJDaOG7jW4gdOG6pXQgY+G6o1wiLFxuXHRcdFx0dW5hdmFpbGFibGU6IFwiQ2h1eeG7g24ga2jDtG5nIGto4bqjIGThu6VuZ1wiLFxuXHRcdFx0ZXJyb3I6IFwiVMOgaSBraG/huqNuIGtow7RuZyB04buTbiB04bqhaVwiLFxuXHRcdFx0d2FybmluZ0xlZGdlcjogXCJZw6p1IGPhuqd1IGjhu5cgdHLhu6MgTGVkZ2VyXCIsXG5cdFx0XHRub0JhbGFuY2U6IFwiVMOgaSBraG/huqNuIHRy4buRbmdcIlxuXHRcdH0sXG5cdFx0Z2V0UGFzc3BocmFzZToge1xuXHRcdFx0dGl0bGU6IFwiU2FvIGNow6lwIG3huq10IGto4bqpdSB04bqhbSB0aOG7nWlcIixcblx0XHRcdGRlc2M6IFwiQuG6oW4gc+G6vSBj4bqnbiBuaOG6rXAgbeG6rXQga2jhuql1IGtoaSBi4bqvdCDEkeG6p3UgeHXhuqV0IGPDoWMga2hv4bqjbiB04bubaSB2w60ga2jDoWMuXCIsXG5cdFx0XHRidXR0b246IFwiVGnhur9wIHThu6VjXCIsXG5cdFx0XHRsYWJlbDogXCJC4bqlbSDEkeG7gyBzYW8gY2jDqXBcIixcblx0XHRcdGNoZWNrTGFiZWw6IFwiVMO0aSDEkcOjIGNow6lwIGhv4bq3YyBnaGkgbOG6oWkgbeG6rXQga2jhuql1XCJcblx0XHR9LFxuXHRcdGNvbXBsZXRlOiB7XG5cdFx0XHR0aXRsZTogXCJIb8OgbiB0aMOgbmggY2h1eeG7g25cIixcblx0XHRcdGRlc2NPbmU6IFwiQuG6oW4gc+G6vSDEkcaw4bujYyBjaHV54buDbiBoxrDhu5tuZyB04bubaSB0w6BpIGtob+G6o24gxJHDoyBjaOG7jW4gxJHhu4MgaG/DoG4gdOG6pXQgcXXDoSB0csOsbmguXCIsXG5cdFx0XHRkZXNjVHdvOiBcIlNhdSBraGkgbmjhuq1wLCBuaOG6pW4gbsO6dCDEkeG7gyBob8OgbiB04bqldCBxdXkgdHLDrG5oIGNodXnhu4NuLlwiLFxuXHRcdFx0YnV0dG9uOiBcIkhvw6BuIHRow6BuaFwiXG5cdFx0fVxuXHR9XG59O1xudmFyIGNvbXBvbmVudCA9IHtcblx0Y2xpY2tUb0NvcHk6IHtcblx0XHRsYWJlbDogXCLEkMOjIHNhbyBjaMOpcFwiLFxuXHRcdHRvb2x0aXA6IFwiQuG6pW0gxJHhu4Mgc2FvIGNow6lwXCJcblx0fVxufTtcbnZhciB2aSA9IHtcblx0bW9kYWw6IG1vZGFsJDYsXG5cdGNvbXBvbmVudDogY29tcG9uZW50XG59O1xuXG52YXIgbW9kYWwkNSA9IHtcblx0d2FsbGV0OiB7XG5cdFx0Y29ubmVjdFlvdXJXYWxsZXQ6IFwi4KSF4KSq4KSo4KS+IOCkteClieCksuClh+CknyAoV2FsbGV0KSDgpJXgpKjgpYfgpJXgpY3gpJ8g4KSV4KSw4KWH4KSC4KWkXCIsXG5cdFx0d2hhdElzQVdhbGxldDogXCLgpLXgpYngpLLgpYfgpJ8g4KSV4KWN4KSv4KS+IOCkueCliD9cIixcblx0XHRzZWN1cmVBbmRNYW5hZ2U6IFwi4KS44KWB4KSw4KSV4KWN4KS34KS/4KSkIOCklOCksCDgpKrgpY3gpLDgpKzgpILgpKfgpL/gpKQg4KSV4KSw4KWH4KSC4KWkXCIsXG5cdFx0c2FmZWx5U3RvcmU6IFwi4KSF4KSq4KSo4KWAIOCkleCljeCksOCkv+CkquCljeCkn+Cli+CkleCksOClh+CkguCkuOClgCDgpJTgpLAg4KSP4KSo4KSP4KSr4KSf4KWAIOCkleCliyDgpLjgpYHgpLDgpJXgpY3gpLfgpL/gpKQg4KSw4KWC4KSqIOCkuOClhyDgpLjgpY3gpJ/gpYvgpLAg4KSU4KSwIOCkn+CljeCksOCkvuCkguCkuOCkq+CksCDgpJXgpLDgpYfgpILgpaRcIixcblx0XHRsb2dJblRvQW55OiBcIk5FQVIg4KSq4KSwIOCkleCkv+CkuOClgCDgpK3gpYAg4KSQ4KSqIOCkruClh+CkgiDgpLjgpL7gpIfgpKgg4KSH4KSoIOCkleCksOClh+CkguClpFwiLFxuXHRcdG5vTmVlZFRvQ3JlYXRlOiBcIuCkqOCkjyDgpJbgpL7gpKTgpYcg4KSv4KS+IOCksuClieCkl+Ckv+CkqCDgpKzgpKjgpL7gpKjgpYcg4KSV4KWAIOCkhuCkteCktuCljeCkr+CkleCkpOCkviDgpKjgpLngpYDgpIIg4KS54KWI4KWkIOCkheCkquCkqOCkviDgpLXgpYngpLLgpYfgpJ8oTkVBUiBXYWxsZXQp4KSV4KSo4KWH4KSV4KWN4KSfIOCkleCksOClh+CkgiDgpJTgpLAg4KSG4KSw4KSC4KStIOCkleCksOClh+CkguClpFwiLFxuXHRcdGdldEFXYWxsZXQ6IFwi4KSP4KSVIOCkteClieCksuClh+CknyDgpKzgpKjgpL7gpI/gpIHgpaRcIixcblx0XHR1c2VBV2FsbGV0OiBcIuCkheCkquCkqOClgCBORUFSIOCkuOCkguCkquCkpOCljeCkpOCkv+Ckr+Cli+CkgiDgpJXgpYsg4KS44KWB4KSw4KSV4KWN4KS34KS/4KSkIOCklOCksCDgpKrgpY3gpLDgpKzgpILgpKfgpL/gpKQg4KSV4KSw4KSo4KWHIOCkleClhyDgpLLgpL/gpI8g4KS14KWJ4KSy4KWH4KSfIOCkleCkviDgpIngpKrgpK/gpYvgpJcg4KSV4KSw4KWH4KSCIOCklOCksCDgpJXgpL/gpLjgpYAg4KSt4KWAIE5FQVIg4KSQ4KSqIChhcHApIOCkruClh+CkgiDgpLLgpYngpJcg4KSH4KSoIOCkleCksOClh+Ckgiwg4KSV4KS/4KS44KWAIOCkieCkquCkr+Cli+Ckl+CkleCksOCljeCkpOCkviAodXNlcikg4KSo4KS+4KSuIOCklOCksCDgpKrgpL7gpLjgpLXgpLDgpY3gpKEg4KSV4KWAIOCkhuCkteCktuCljeCkr+CkleCkpOCkviDgpKjgpLngpYDgpIIg4KS54KWI4KWkXCIsXG5cdFx0Y29ubmVjdGlvbkZhaWxlZDogXCLgpJXgpKjgpYfgpJXgpY3gpLbgpKgg4KS14KS/4KSr4KSyfFwiLFxuXHRcdGNvbm5lY3Rpb25TdWNjZXNzZnVsOiBcIuCkleCkqOClh+CkleCljeCktuCkqCDgpLjgpKvgpLJ8XCIsXG5cdFx0Y29ubmVjdGVkOiBcIuCkteClieCksuClh+CknyDgpJzgpYHgpZwg4KSX4KSv4KS+fFwiLFxuXHRcdGNvbm5lY3RpbmdUbzogXCLgpLXgpYngpLLgpYfgpJ8g4KSc4KWB4KWcIOCksOCkueCkviDgpLngpYd8XCIsXG5cdFx0Y29ubmVjdGluZ01lc3NhZ2U6IHtcblx0XHRcdGluamVjdGVkOiBcIuCkj+CkleCljeCkuOCkn+Clh+CkguCktuCkqCDgpLXgpL/gpILgpKHgpYsg4KSu4KWH4KSCIOCkleCkqOClh+CkleCljeCktuCkqCDgpJXgpYAg4KSq4KWB4KS34KWN4KSf4KS/IOCkleCksOClh+CkgnxcIixcblx0XHRcdGJyb3dzZXI6IFwi4KSw4KWA4KSh4KS+4KSv4KSw4KWH4KSV4KWN4KSfIOCkueCli+CkqOClhyDgpJXgpYcg4KSs4KS+4KSmIOCkteClieCksuClh+CknyDgpK7gpYfgpIIg4KSV4KSo4KWH4KSV4KWN4KS24KSoIOCkleClgCDgpKrgpYHgpLfgpY3gpJ/gpL8g4KSV4KSw4KWH4KSCfFwiLFxuXHRcdFx0aGFyZHdhcmU6IFwi4KSV4KWL4KSy4KWN4KShIOCkteClieCksuClh+CknyDgpJXgpYcg4KS44KS+4KSlIOCkleCkqOClh+CkleCljeCktuCkqCDgpJXgpYAg4KSq4KWB4KS34KWN4KSf4KS/IOCkleCksOClh+CkgnxcIlxuXHRcdH1cblx0fSxcblx0bGVkZ2VyOiB7XG5cdFx0Y29ubmVjdFdpdGhMZWRnZXI6IFwi4KSy4KWH4KSc4KSwKExlZGdlcingpLXgpYngpLLgpYfgpJ8g4KSV4KSo4KWH4KSV4KWN4KSfIOCkleCksOClh+CkgnxcIixcblx0XHRtYWtlU3VyZVlvdXJMZWRnZXI6IFwi4KS44KWB4KSo4KS/4KS24KWN4KSa4KS/4KSkIOCkleCksOClh+CkgiDgpJXgpL8g4KSG4KSq4KSV4KS+IOCksuClh+CknOCksCDgpLjgpYHgpLDgpJXgpY3gpLfgpL/gpKQg4KSw4KWC4KSqIOCkuOClhyDgpJzgpYHgpKHgpLzgpL4g4KS54KWB4KSGIOCkueCliCDgpJTgpLAgTkVBUiDgpJDgpKog4KSG4KSq4KSV4KWHIOCkoeCkv+CkteCkvuCkh+CkuCAoRGV2aWNlKeCkquCksCDgpKrgpLngpLLgpYcg4KS44KWHIOCkueClgCDgpJbgpYHgpLLgpL4g4KS54KWIfFwiLFxuXHRcdFwiY29udGludWVcIjogXCLgpJzgpL7gpLDgpYAg4KSw4KSW4KWHfFwiLFxuXHRcdHNwZWNpZnlIRFBhdGg6IFwi4KS54KS+4KSw4KWN4KShIOCkoeCkv+CkuOCljeCklShIYXJkIERpc2sp4KSq4KSlKFBhdGgp4KSo4KS/4KSw4KWN4KSn4KS+4KSw4KS/4KSkIOCkleCksOClh3xcIixcblx0XHRlbnRlcllvdXJQcmVmZXJyZWRIRFBhdGg6IFwi4KSF4KSq4KSo4KS+IOCkj+CkmuCkoeClgCDgpKrgpKUg4KSm4KSw4KWN4KScIOCkleCksOClh+Ckgiwg4KSr4KS/4KSwIOCkuOCkleCljeCksOCkv+CkryDgpJbgpL7gpKTgpYvgpIIg4KSV4KWHIOCksuCkv+CkjyDgpLjgpY3gpJXgpYjgpKgg4KSV4KSw4KWH4KSCfFwiLFxuXHRcdHNjYW46IFwi4KS44KWN4KSV4KWI4KSoIOCkleCksOClh3xcIixcblx0XHRyZXRyeTogXCLgpKbgpYvgpKzgpL7gpLDgpL4g4KSq4KWN4KSw4KSv4KS+4KS4IOCkleCksOClh3xcIixcblx0XHRsZWRnZXJJc05vdEF2YWlsYWJsZTogXCLgpLLgpYfgpJzgpLAg4KSJ4KSq4KSy4KSs4KWN4KSnIOCkqOCkueClgOCkgiDgpLngpYh8XCIsXG5cdFx0YWNjZXNzRGVuaWVkVG9Vc2VMZWRnZXJEZXZpY2U6IFwi4KSy4KWH4KSc4KSwIOCkoeCkv+CkteCkvuCkh+CkuCDgpJXgpL4g4KSJ4KSq4KSv4KWL4KSXIOCkleCksOCkqOClhyDgpJXgpYcg4KSy4KS/4KSPIOCkquCljeCksOCkteClh+CktiDgpKjgpL/gpLfgpYfgpKd8XCIsXG5cdFx0bm9BY2NvdW50c0ZvdW5kOiBcIuCkluCkvuCkpOCkviDgpKjgpLngpYDgpIIg4KSu4KS/4KSy4KS+fFwiLFxuXHRcdHNlbGVjdFlvdXJBY2NvdW50czogXCLgpIXgpKrgpKjgpYcg4KSW4KS+4KSk4KWHIOCkmuClgeCkqOClh+CkgnxcIixcblx0XHRjb25uZWN0aW5nMUFjY291bnQ6IFwi4KSP4KSVIOCkluCkvuCkpOCkviDgpJXgpKjgpYfgpJXgpY3gpJ8g4KS54KWLIOCksOCkueCkviDgpLngpYh8XCIsXG5cdFx0Y2FudEZpbmRBbnlBY2NvdW50OiBcIuCkh+CkuCDgpLLgpYfgpJzgpLAg4KS44KWHIOCknOClgeCkoeCkvOCkviDgpJXgpYvgpIgg4KSW4KS+4KSk4KS+IOCkqOCkueClgOCkgiDgpK7gpL/gpLLgpL7gpaQg4KSV4KWD4KSq4KSv4KS+IOCkj+CklSDgpKjgpK/gpL4gTkVBUiDgpJbgpL7gpKTgpL4g4KSs4KSo4KS+4KSP4KSBfFwiLFxuXHRcdG9yQ29ubmVjdEFuQW5vdGhlckxlZGdlcjogXCLgpIXgpKXgpLXgpL4g4KSm4KWC4KS44KSw4KWHIOCksuClh+CknOCksCDgpLXgpYngpLLgpYfgpJ8g4KS44KWHIOCkleCkqOClh+CkleCljeCknyDgpJXgpLDgpYfgpILgpaRcIixcblx0XHRjb25uZWN0aW5nOiBcIuCknOClgeClnCDgpLDgpLngpL4g4KS54KWHfFwiLFxuXHRcdG9mQWNjb3VudHM6IFwi4KSW4KS+4KSk4KS+IOCkheCkrCDgpJzgpYHgpZzgpL4g4KSo4KS54KWA4KSCIOCkueClh3xcIixcblx0XHRmYWlsZWRUb0F1dG9tYXRpY2FsbHk6IFwi4KSW4KS+4KSk4KS+IOCkhuCkiOCkoeClgCDgpLjgpY3gpLXgpJrgpL7gpLLgpL/gpKQg4KSw4KWC4KSqIOCkuOClhyDgpJbgpYvgpJzgpKjgpYcg4KSu4KWH4KSCIOCkheCkuOCkruCksOCljeCkpeClpCDgpK7gpYjgpKjgpY3gpK/gpYHgpIXgpLIgKE1hbnVhbGwpIOCksOClguCkqiDgpLjgpYcg4KSV4KWL4KS24KS/4KS2IOCkleCksOClh+CkgnxcIixcblx0XHRvdmVydmlld1RoZUxpc3RPZkF1dGhvcml6ZWQ6IFwi4KSF4KS14KSy4KWL4KSV4KSoIOCkheCkp+Ckv+CkleClg+CkpCDgpJXgpYAg4KS44KWC4KSa4KWALCDgpKjgpYDgpJrgpYcg4KSm4KS/4KSPIOCkl+CkjyDgpKzgpJ/gpKgg4KSq4KSwIOCkleCljeCksuCkv+CklSDgpJXgpLDgpJXgpYcg4KSy4KWJ4KSX4KS/4KSoIOCkquClguCksOCkviDgpJXgpLDgpYfgpILgpaRcIixcblx0XHRmaW5pc2g6IFwi4KS44KSu4KS+4KSq4KWN4KSkfFwiXG5cdH0sXG5cdGluc3RhbGw6IHtcblx0XHR5b3VsbE5lZWRUb0luc3RhbGw6IFwi4KSG4KSq4KSV4KWLIOCkh+CkguCkuOCljeCkn+ClieCksiDgpJXgpLDgpKjgpL4g4KS54KWL4KSX4KS+fFwiLFxuXHRcdHRvQ29udGludWVBZnRlckluc3RhbGxpbmc6IFwi4KSH4KSC4KS44KWN4KSf4KWJ4KSyIOCkleCksOCkqOClhyDgpJXgpYcg4KSs4KS+4KSmIOCknOCkvuCksOClgCDgpLDgpJbgpYd8XCIsXG5cdFx0cmVmcmVzaFRoZVBhZ2U6IFwi4KSq4KWB4KSoOiDgpLLgpYvgpKEg4KSV4KSw4KWH4KSC4KWkXCIsXG5cdFx0b3BlbjogXCLgpJbgpYvgpLLgpYd8XCJcblx0fSxcblx0cXI6IHtcblx0XHRjb3BpZWRUb0NsaXBib2FyZDogXCLgpJXgpY3gpLLgpL/gpKrgpKzgpYvgpLDgpY3gpKEoQ2xpcGJvYXJkKeCkquCksCDgpJXgpYngpKrgpYAg4KSV4KS/4KSv4KS+IOCkl+Ckr+CkvnxcIixcblx0XHRmYWlsZWRUb0NvcHk6IFwi4KSV4KWN4KSy4KS/4KSq4KSs4KWL4KSw4KWN4KShIOCkquCksCDgpJXgpYngpKrgpYAg4KSV4KSw4KSo4KS+IOCkteCkv+Ckq+CksiDgpLDgpLngpL58XCIsXG5cdFx0c2NhbldpdGhZb3VyTW9iaWxlOiBcIuCkheCkquCkqOClhyDgpKvgpYvgpKggKE1vYmlsZSngpLjgpYcg4KS44KWN4KSV4KWI4KSoIOCkleCksOClh+CkgnxcIixcblx0XHRjb3B5VG9DbGlwYm9hcmQ6IFwiIOCkleCljeCksuCkv+CkquCkrOCli+CksOCljeCkoSDgpKrgpLAg4KSV4KWJ4KSq4KWAIOCkleCksOClh+CkgnxcIixcblx0XHRwcmVmZXJUaGVPZmZpY2lhbDogXCLgpIbgpKfgpL/gpJXgpL7gpLDgpL/gpJUg4KS44KSC4KS14KS+4KSmIOCkleCliyDgpKrgpY3gpLDgpL7gpKXgpK7gpL/gpJXgpKTgpL4g4KSm4KWH4KSCfFwiLFxuXHRcdG9wZW46IFwi4KSW4KWL4KSy4KWHfFwiXG5cdH0sXG5cdHdhbGxldFR5cGVzOiB7XG5cdFx0aGFyZHdhcmU6IFwiSGFyZHdhcmUgV2FsbGV0XCIsXG5cdFx0YnJvd3NlcjogXCJCcm93c2VyIFdhbGxldFwiLFxuXHRcdGluamVjdGVkOiBcIldhbGxldCBFeHRlbnNpb25cIixcblx0XHRicmlkZ2U6IFwiQnJpZGdlIFdhbGxldFwiLFxuXHRcdG1vYmlsZTogXCJNb2JpbGUgV2FsbGV0XCIsXG5cdFx0XCJpbnN0YW50LWxpbmtcIjogXCJJbnN0YW50IFdhbGxldFwiXG5cdH1cbn07XG52YXIgaGkgPSB7XG5cdG1vZGFsOiBtb2RhbCQ1XG59O1xuXG52YXIgbW9kYWwkNCA9IHtcblx0d2FsbGV0OiB7XG5cdFx0Y29ubmVjdFlvdXJXYWxsZXQ6IFwi2LXZhCDZhdit2YHYuNiq2YNcIixcblx0XHR3aGF0SXNBV2FsbGV0OiBcItmF2Kcg2YfZiiDYp9mE2YXYrdmB2LjYqdifXCIsXG5cdFx0c2VjdXJlQW5kTWFuYWdlOiBcItiq2KPZhdmK2YYg2YjYpdiv2KfYsdipINin2YTZhdmF2KrZhNmD2KfYqiDYp9mE2LHZgtmF2YrYqSDYp9mE2K7Yp9i12Kkg2KjZg1wiLFxuXHRcdHNhZmVseVN0b3JlOiBcItmC2YUg2KjYqtiu2LLZitmGINmIINin2LHYs9in2YQg2LnZhdmE2KfYqtmDINmIINij2LXZiNmE2YMg2KfZhNix2YLZhdmK2Kkg2KjYo9mF2KfZhlwiLFxuXHRcdGxvZ0luVG9Bbnk6IFwi2LPYrNmEINin2YTYr9iu2YjZhCDYpdmE2Ykg2KPZiiDYqti32KjZitmCINmK2LPYqtiu2K/ZhSDZhtmK2LFcIixcblx0XHRub05lZWRUb0NyZWF0ZTogXCIu2YTYpyDYr9in2LnZiiDZhNil2YbYtNin2KEg2K3Ys9in2Kgg2KzYr9mK2K8uINmB2YLYtyDZgtmFINio2KrZiNi12YrZhCDZhdit2YHYuNiq2YMg2YjYp9mG2LfZhNmCXCIsXG5cdFx0Z2V0QVdhbGxldDogXCLYp9it2LXZhCDYudmE2Ykg2YXYrdmB2LjYqVwiLFxuXHRcdHVzZUFXYWxsZXQ6IFwi2KfYs9iq2K7Yr9mFINmF2K3Zgdi42Kkg2YTYqtij2YXZitmGINmI2KXYr9in2LHYqSDYo9i12YjZhCDZhtmK2LEg2KfZhNiu2KfYtdipINio2YPYjCDZiNin2K/YrtmEINmE2KPZiiDYqti32KjZitmCINmK2LPYqtiu2K/ZhSDZhtmK2LEg2K/ZiNmGINin2YTYrdin2KzYqSDYpdmE2Ykg2KfYs9mFINin2YTZhdiz2KrYrtiv2YUg2YjZg9mE2YXYqdin2YTZhdix2YjYsVwiLFxuXHRcdGNvbm5lY3Rpb25GYWlsZWQ6IFwi2KfYqti12KfZhCDZgdin2LTZhFwiLFxuXHRcdGNvbm5lY3Rpb25TdWNjZXNzZnVsOiBcItin2KrYtdin2YQg2YbYp9is2K1cIixcblx0XHRjb25uZWN0ZWQ6IFwi2YXYqti12YRcIixcblx0XHRjb25uZWN0aW5nVG86IFwi2KzYp9ix2Yog2KfZhNin2KrYtdin2YQg2KhcIixcblx0XHRjb25uZWN0aW5nTWVzc2FnZToge1xuXHRcdFx0aW5qZWN0ZWQ6IFwi2YjYp9mB2YIg2LnZhNmJINin2YTYp9iq2LXYp9mEINmB2Yog2YbYp9mB2LDYqSDYp9mE2KXYttin2YHYqVwiLFxuXHRcdFx0YnJvd3NlcjogXCLZiNin2YHZgiDYudmE2Ykg2KfZhNin2KrYtdin2YQg2YHZiiDYp9mE2YXYrdmB2LjYqSDYqNi52K8g2KXYudin2K/YqSDYqtmI2KzZitmHXCIsXG5cdFx0XHRoYXJkd2FyZTogXCLZiNin2YHZgiDYudmE2Ykg2KfZhNin2KrYtdin2YQg2YHZiiDYrNmH2KfYsiDZhNmK2K/YrNixXCIsXG5cdFx0XHRicmlkZ2U6IFwi2YjYp9mB2YIg2LnZhNmJINin2YTYp9iq2LXYp9mEINmB2Yog2KfZhNmF2K3Zgdi42KlcIlxuXHRcdH1cblx0fSxcblx0bGVkZ2VyOiB7XG5cdFx0Y29ubmVjdFdpdGhMZWRnZXI6IFwi2KfYqti12YQg2YXYuSDZhNmK2K/YrNixXCIsXG5cdFx0bWFrZVN1cmVZb3VyTGVkZ2VyOiBcItiq2KPZg9ivINij2YYg2YTZitiv2KzYsSDZhdiq2LXZhCDYqNij2YXYp9mGLCDZiCDYo9mGINiq2LfYqNmK2YIg2YbZitixINmF2YHYqtmI2K0g2YHZiiDYrNmH2KfYstmDXCIsXG5cdFx0XCJjb250aW51ZVwiOiBcItiq2KfYqNi5XCIsXG5cdFx0c3BlY2lmeUhEUGF0aDogXCLYrdiv2K8g2YXYs9in2LEg2KfZhNit2LPYp9ioXCIsXG5cdFx0ZW50ZXJZb3VyUHJlZmVycmVkSERQYXRoOiBcItij2K/YrtmEINmF2LPYp9ixINin2YTYrdiz2KfYqCDYp9mE2YXZgdi22YTYjCDYq9mFINin2KjYrdirINi52YYg2YPZhCDYp9mE2K3Ys9in2KjYp9iqINin2YTZhti02LfYqVwiLFxuXHRcdHNjYW46IFwi2YXYs9itXCIsXG5cdFx0cmV0cnk6IFwi2KPYudivINin2YTZhdit2KfZiNmE2KlcIixcblx0XHRsZWRnZXJJc05vdEF2YWlsYWJsZTogXCLZhNmK2K/YrNixINi62YrYsSDZhdiq2YjZgdixXCIsXG5cdFx0YWNjZXNzRGVuaWVkVG9Vc2VMZWRnZXJEZXZpY2U6IFwi2KrZhSDYsdmB2LYg2KfZhNin2KrYtdin2YQg2KjZhNmK2K/YrNixXCIsXG5cdFx0bm9BY2NvdW50c0ZvdW5kOiBcItmE2YUg2YrYqtmFINin2YTYudir2YjYsSDYudmE2Ykg2KPZiiDYrdiz2KfYqNin2KpcIixcblx0XHRzZWxlY3RZb3VyQWNjb3VudHM6IFwi2K3Yr9ivINit2LPYp9io2KfYqtmDXCIsXG5cdFx0Y29ubmVjdGluZzFBY2NvdW50OiBcItis2KfYsdmKINin2YTYp9iq2LXYp9mEINio2K3Ys9in2Kgg2YjYp9it2K9cIixcblx0XHRjYW50RmluZEFueUFjY291bnQ6IFwi2YTYpyDZitmF2YPZhiDYp9mE2LnYq9mI2LEg2LnZhNmJINij2Yog2K3Ys9in2Kgg2YXYsdiq2KjYtyDYqNmH2LDYpyDZhNmK2K/YrNixINin2YTYsdis2KfYoSDYpdmG2LTYp9ihINit2LPYp9ioINmG2YrYsSDYrNiv2YrYryDYudmE2YlcIixcblx0XHRvckNvbm5lY3RBbkFub3RoZXJMZWRnZXI6IFwi2KfZiCDYp9ix2KjYtyDYrNmH2KfYsiDZhNmK2K/YrNixINii2K7YsVwiLFxuXHRcdGNvbm5lY3Rpbmc6IFwi2KzYp9ix2Yog2KfZhNin2KrYtdin2YRcIixcblx0XHRvZkFjY291bnRzOiBcItmF2YYg2KfZhNit2LPYp9io2KfYqlwiLFxuXHRcdGZhaWxlZFRvQXV0b21hdGljYWxseTogXCLZgdi02YQg2YHZiiDYp9mE2KfYqti12KfZhCDYqNin2YTYrdiz2KfYqCDYqtmE2YLYp9im2YrYpy4g2YrYsdis2Ykg2KfZhNin2KrYtdin2YQg2KjYp9mE2K3Ys9in2Kgg2YrYr9mI2YrYp1wiLFxuXHRcdG92ZXJ2aWV3VGhlTGlzdE9mQXV0aG9yaXplZDogXCLZhNin2KbYrdipINin2YTYrdiz2KfYqNin2Kog2KfZhNmF2LXYsditINio2YfYpywg2KPZg9mF2YQg2KrYs9is2YrZhCDYp9mE2K/YrtmI2YQg2KjYp9mE2YbZgtixINi52YTZiSDYp9mE2LLYsSDYo9iv2YbYp9mHXCIsXG5cdFx0ZmluaXNoOiBcItil2YbZh9in2KFcIlxuXHR9LFxuXHRpbnN0YWxsOiB7XG5cdFx0eW91bGxOZWVkVG9JbnN0YWxsOiBcItiz2KrYrdiq2KfYrCDZhNiq2KvYqNmK2KpcIixcblx0XHR0b0NvbnRpbnVlQWZ0ZXJJbnN0YWxsaW5nOiBcItmE2YTYp9iz2KrZg9mF2KfZhC4g2KjYudivINin2YTYqtir2KjZitiqXCIsXG5cdFx0cmVmcmVzaFRoZVBhZ2U6IFwi2YLZhSDYqNiq2K3Yr9mK2Ksg2KfZhNi12YHYrdipXCIsXG5cdFx0b3BlbjogXCLYp9mB2KrYrVwiXG5cdH0sXG5cdHFyOiB7XG5cdFx0Y29waWVkVG9DbGlwYm9hcmQ6IFwi2KrZhSDYp9mE2YbYs9iuXCIsXG5cdFx0ZmFpbGVkVG9Db3B5OiBcItmB2LTZhCDYp9mE2YbYs9iuXCIsXG5cdFx0c2NhbldpdGhZb3VyTW9iaWxlOiBcItin2YXYs9itINio2KzZh9in2LLZgyDYp9mE2YXYrdmF2YjZhFwiLFxuXHRcdGNvcHlUb0NsaXBib2FyZDogXCLZhtiz2K5cIixcblx0XHRwcmVmZXJUaGVPZmZpY2lhbDogXCLYqtmB2LbZhCDYp9mE2K3ZiNin2LEg2KfZhNix2LPZhdmKINmEXCIsXG5cdFx0b3BlbjogXCLZgdiq2K1cIlxuXHR9LFxuXHR3YWxsZXRUeXBlczoge1xuXHRcdGhhcmR3YXJlOiBcIkhhcmR3YXJlIFdhbGxldFwiLFxuXHRcdGJyb3dzZXI6IFwiQnJvd3NlciBXYWxsZXRcIixcblx0XHRpbmplY3RlZDogXCJXYWxsZXQgRXh0ZW5zaW9uXCIsXG5cdFx0YnJpZGdlOiBcIkJyaWRnZSBXYWxsZXRcIixcblx0XHRtb2JpbGU6IFwiTW9iaWxlIFdhbGxldFwiLFxuXHRcdFwiaW5zdGFudC1saW5rXCI6IFwiSW5zdGFudCBXYWxsZXRcIlxuXHR9XG59O1xudmFyIGFyID0ge1xuXHRtb2RhbDogbW9kYWwkNFxufTtcblxudmFyIG1vZGFsJDMgPSB7XG5cdHdhbGxldDoge1xuXHRcdGNvbm5lY3RZb3VyV2FsbGV0OiBcIlNwb2ppdGUgY3J5cHRvIG5vdsSNYW5payFcIixcblx0XHR3aGF0SXNBV2FsbGV0OiBcIsWgdG8gamUgdG8gY3J5cHRvIG5vdsSNYW5paz9cIixcblx0XHRzZWN1cmVBbmRNYW5hZ2U6IFwiT3NpZ3VyYWp0ZSBpIHVwcmF2bGphanRlIHN2b2pvbSBkaWdpdGFsbm9tIGltb3Zpbm9tLlwiLFxuXHRcdHNhZmVseVN0b3JlOiBcIlNpZ3Vybm8gcG9ocmFuaXRlIGkgcHJlYmFjaXRlIHN2b2ogY3J5cHRvIGkgTkZULWV2ZS5cIixcblx0XHRsb2dJblRvQW55OiBcIiBQcmlqYXZpdGUgc2UgdSBiaWxvIGtvanUgTkVBUiBhcGxpa2FjaWp1XCIsXG5cdFx0bm9OZWVkVG9DcmVhdGU6IFwiTmVtYSBwb3RyZWJlIHphIHN0dmFyYW5qZW0gbm92aWggbmFsb2dhIGlsaSBrb3Jpc25pxI1raWggcG9kYXRha2EuIFNwb2ppdGUgc3ZvaiBjcnlwdG8gbm92xI1hbmlrIGkgc3ByZW1uaSBzdGUhXCIsXG5cdFx0Z2V0QVdhbGxldDogXCJPdHZvcml0ZSBjcnlwdG8gbm92xI1hbmlrXCIsXG5cdFx0dXNlQVdhbGxldDogXCJLb3Jpc3RpdGUgY3J5cHRvIG5vdsSNYW5payBkYSBiaXN0ZSBvc2lndXJhbGkgaSB1cHJhdmxqYWxpIHN2b2pvbSBORUFSIGltb3Zpbm9tLCB0ZSBzZSBwcmlqYXZpdGUgdSBiaWxvIGtvanUgTkVBUiBhcGxpa2FjaWp1IGJleiBrb3Jpc25pxI1rb2cgaW1lbmEgaSBsb3ppbmtlLlwiLFxuXHRcdGNvbm5lY3Rpb25GYWlsZWQ6IFwiTmV1c3BqZcWhbm8gcG92ZXppdmFuamUuXCIsXG5cdFx0Y29ubmVjdGlvblN1Y2Nlc3NmdWw6IFwiVXNwamXFoW5vIHBvdmV6aXZhbmplLlwiLFxuXHRcdGNvbm5lY3RlZDogXCJQb3ZlemFuby5cIixcblx0XHRjb25uZWN0aW5nVG86IFwiUG92ZXppdmFuamUgdSB0aWpla3VcIixcblx0XHRjb25uZWN0aW5nTWVzc2FnZToge1xuXHRcdFx0aW5qZWN0ZWQ6IFwiUG90dnJkaXRlIHZlenUgdSBla3N0ZXJub20gcHJvem9ydVwiLFxuXHRcdFx0YnJvd3NlcjogXCJOYWtvbiByZWRpcmVrY2lqZSwgcG90dnJkaXRlIHZlenUgdSBub3bEjWFuaWt1XCIsXG5cdFx0XHRoYXJkd2FyZTogXCJQb3R2cmRpdGUgdmV6dSBzYSBub3bEjWFuaWtvbVwiLFxuXHRcdFx0YnJpZGdlOiBcIlBvdHZyZGl0ZSB2ZXp1IHUgbm92xI1hbmlrdVwiXG5cdFx0fVxuXHR9LFxuXHRsZWRnZXI6IHtcblx0XHRjb25uZWN0V2l0aExlZGdlcjogXCJQb3Zlxb5pdGUgc2UgaGFyZHZlcnNraW0gbm92xI1hbmlrb21cIixcblx0XHRtYWtlU3VyZVlvdXJMZWRnZXI6IFwiT3NpZ3VyYWp0ZSBzaWd1cm51IHZlenUgcyBoYXJkdmVyc2tpbSBub3bEjWFuaWtvbSwgdGUgZGEgamUgTkVBUiBhcGxpa2FjaWphIG90dm9yZW5hIG5hIHZhxaFlbSB1cmXEkWFqdVwiLFxuXHRcdFwiY29udGludWVcIjogXCJOYXN0YXZpdGVcIixcblx0XHRzcGVjaWZ5SERQYXRoOiBcIlNwZWNpZmljaXJhanRlIEhEIHB1dGFuanVcIixcblx0XHRlbnRlcllvdXJQcmVmZXJyZWRIRFBhdGg6IFwiVXBpxaFpdGUgcHJlZmVyaXJhbnUgSEQgcHV0YW5qdSwgemF0aW0gc2tlbmlyYWp0ZSBha3Rpdm5lIG5hbG9nZVwiLFxuXHRcdHNjYW46IFwiU2tlbmlyYWp0ZVwiLFxuXHRcdHJldHJ5OiBcIlBva3XFoWFqdGUgcG9ub3Zub1wiLFxuXHRcdGxlZGdlcklzTm90QXZhaWxhYmxlOiBcIkhhcmR2ZXJza2kgbm92xI1hbmlrIG5pamUgZG9zdHVwYW4uXCIsXG5cdFx0YWNjZXNzRGVuaWVkVG9Vc2VMZWRnZXJEZXZpY2U6IFwiT2RiaWplbiBwcmlzdHVwIHphIGtvcmnFoXRlbmplbSBoYXJkdmVyc2tvZyBub3bEjWFuaWthXCIsXG5cdFx0bm9BY2NvdW50c0ZvdW5kOiBcIk5hbG96aSBuaXN1IHByb25hxJFlbmlcIixcblx0XHRzZWxlY3RZb3VyQWNjb3VudHM6IFwiT2RhYmVyaXRlIHN2b2plIG5hbG9nZVwiLFxuXHRcdGNvbm5lY3RpbmcxQWNjb3VudDogXCJQb3Zleml2YW5qZSAxIG5hbG9nYVwiLFxuXHRcdGNhbnRGaW5kQW55QWNjb3VudDogXCJOaWplIG1vZ3XEh2UgcHJvbmHEh2kgbml0aSBqZWRhbiBuYWxvZyBwb3ZlemFuIHMgb3ZpbSBoYXJkdmVyc2tpbSBub3bEjWFuaWtvbS4gTW9saW1vIHZhcywga3JlaXJhanRlIG5vdmkgTkVBUiBuYWxvZ1wiLFxuXHRcdG9yQ29ubmVjdEFuQW5vdGhlckxlZGdlcjogXCJJbGkgcG92ZcW+aXRlIGRydWdpIGhhcmR2ZXJza2kgbm92xI1hbmlrLlwiLFxuXHRcdGNvbm5lY3Rpbmc6IFwiUG92ZXppdmFuamVcIixcblx0XHRvZkFjY291bnRzOiBcIm5hbG9nYVwiLFxuXHRcdGZhaWxlZFRvQXV0b21hdGljYWxseTogXCJOZXVzcGplxaFubyBhdXRvbWF0c2tvIHByb25hbGHFvmVuamUgSUQgbmFsb2dhLiBVbmVzaXRlIHJ1xI1ubzpcIixcblx0XHRvdmVydmlld1RoZUxpc3RPZkF1dGhvcml6ZWQ6IFwiUHJlZ2xlZGFqdGUgcG9waXMgb2RvYnJlbmloIG5hbG9nYSwgemF2csWhaXRlIHByaWphdnUgcHJpdGlza29tIG5hIG5pxb5lIHByaWthemFuaSBndW1iLlwiLFxuXHRcdGZpbmlzaDogXCJaYXZyxaFpdGVcIlxuXHR9LFxuXHRpbnN0YWxsOiB7XG5cdFx0eW91bGxOZWVkVG9JbnN0YWxsOiBcIiBQb3RyZWJubyBqZSBpbnN0YWxpcmF0aSBtb2RhbFwiLFxuXHRcdHRvQ29udGludWVBZnRlckluc3RhbGxpbmc6IFwiemEgbmFzdGF2YWsuIE5ha29uIGluc3RhbGFjaWplXCIsXG5cdFx0cmVmcmVzaFRoZVBhZ2U6IFwib3N2amXFvml0ZSBzdHJhbmljdS5cIixcblx0XHRvcGVuOiBcIk90dm9yaXRlIFFSIG1vZGFsXCJcblx0fSxcblx0cXI6IHtcblx0XHRjb3BpZWRUb0NsaXBib2FyZDogXCJLb3BpcmFubyB1IG1lxJF1c3ByZW1uaWtcIixcblx0XHRmYWlsZWRUb0NvcHk6IFwiTmV1cHNqZcWhbm8ga29waXJhbmplIHUgbWXEkXVzcHJlbW5pa1wiLFxuXHRcdHNjYW5XaXRoWW91ck1vYmlsZTogXCJTa2VuaXJhanRlIHN2b2ppbSBtb2JpbG5pbSB1cmXEkWFqZW1cIixcblx0XHRjb3B5VG9DbGlwYm9hcmQ6IFwiIEtvcGlyYWp0ZSB1IG1lxJF1c3ByZW1uaWtcIixcblx0XHRwcmVmZXJUaGVPZmZpY2lhbDogXCJPZGFiZXJpdGUgc2x1xb5iZW5pIGRpamFsb2dcIixcblx0XHRvcGVuOiBcIk90dm9yaXRlXCJcblx0fSxcblx0d2FsbGV0VHlwZXM6IHtcblx0XHRoYXJkd2FyZTogXCJIYXJkd2FyZSBXYWxsZXRcIixcblx0XHRicm93c2VyOiBcIkJyb3dzZXIgV2FsbGV0XCIsXG5cdFx0aW5qZWN0ZWQ6IFwiV2FsbGV0IEV4dGVuc2lvblwiLFxuXHRcdGJyaWRnZTogXCJCcmlkZ2UgV2FsbGV0XCIsXG5cdFx0bW9iaWxlOiBcIk1vYmlsZSBXYWxsZXRcIixcblx0XHRcImluc3RhbnQtbGlua1wiOiBcIkluc3RhbnQgV2FsbGV0XCJcblx0fSxcblx0ZXhwb3J0QWNjb3VudHM6IHtcblx0XHRjaG9vc2VBV2FsbGV0OiBcIk9kYWJlcmkgV2FsbGV0XCIsXG5cdFx0dHJhbnNmZXJZb3VyQWNjb3VudHM6IFwiUHJlbmVzaSBzdm9qZSBuYWxvZ2VcIixcblx0XHRzZWxlY3RBV2FsbGV0OiBcIk9kYWJlcml0ZSB3YWxsZXQga29qaSBvZGdvdmFyYSB2YcWhaW0gcG90cmViYW1hIGkgcG9kcsW+YXZhIHZhxaFlIHBvdmV6YW5lIG5hbG9nZS5cIixcblx0XHRzZWxlY3RZb3VyQWNjb3VudHM6IFwiT2RhYmVyaSBzdm9qZSBuYWxvZ2VcIixcblx0XHRhZnRlckRlY2lkZTogXCJOYWtvbiDFoXRvIG9kbHXEjWl0ZSBrb2ppIHdhbGxldCBrb3Jpc3RpdGUsIG1vxb5ldGUgb2RhYnJhdGkga29qZSByYcSNdW5lIMW+ZWxpdGUgcHJlYmFjaXRpLlwiLFxuXHRcdGRpc2NsYWltZXI6IFwiTmXEh2V0ZSBtb8SHaSBwcmViYWNpdGkgbmFsb2dlIGtvamkgbmlzdSBuaWthZGEgYmlsaSBrb3JpxaF0ZW5pIG5hIE5FQVItdS5cIixcblx0XHR3YXJuaW5nOiBcIm5lIHBvZHLFvmF2YSBpenZveiBuYWxvZ2EgdSBvdm9tIHRyZW51dGt1LiBNb2xpbW8gb2RhYmVyaXRlIGRydWdpIHdhbGxldC5cIixcblx0XHR3YWxsZXRUeXBlczoge1xuXHRcdFx0aGFyZHdhcmU6IFwiSGFyZHdhcmUgV2FsbGV0XCIsXG5cdFx0XHRicm93c2VyOiBcIkJyb3dzZXIgV2FsbGV0XCIsXG5cdFx0XHRpbmplY3RlZDogXCJXYWxsZXQgRXh0ZW5zaW9uXCIsXG5cdFx0XHRicmlkZ2U6IFwiQnJpZGdlIFdhbGxldFwiLFxuXHRcdFx0bW9iaWxlOiBcIk1vYmlsZSBXYWxsZXRcIlxuXHRcdH0sXG5cdFx0c2VsZWN0QWNjb3VudHM6IHtcblx0XHRcdHRpdGxlOiBcIk9kYWJlcmkgbmFsb2dlIHphIHByaWplbm9zXCIsXG5cdFx0XHRidXR0b246IFwiR2VuZXJpcmFqIGxvemlua3VcIixcblx0XHRcdGRlc2VsZWN0QWxsOiBcIk1ha25pIG9kYWJpciBzYSBzdmloXCIsXG5cdFx0XHRzZWxlY3RBbGw6IFwiT2RhYmVyaSBzdmVcIixcblx0XHRcdHVuYXZhaWxhYmxlOiBcIlByaWplbm9zIG5pamUgZG9zdHVwYW5cIixcblx0XHRcdGVycm9yOiBcIk5hbG9nIG5lIHBvc3RvamlcIixcblx0XHRcdHdhcm5pbmdMZWRnZXI6IFwiUG90cmVibmEgbGVkZ2VyIHBvZHLFoWthXCIsXG5cdFx0XHRub0JhbGFuY2U6IFwiTmFsb2cgbmVtYSBzcmVkc3RhdmFcIlxuXHRcdH0sXG5cdFx0Z2V0UGFzc3BocmFzZToge1xuXHRcdFx0dGl0bGU6IFwiS29waXJhaiBwcml2cmVtZW51IGxvemlua3VcIixcblx0XHRcdGRlc2M6IFwiQml0IMSHZSBwb3RyZWJubyB1bmlqZXRpIG92dSBsb3ppbmt1IG5hIHBvxI1ldGt1IGl6dm96YSBuYWxvZ2EgbmEgZHJ1Z2kgd2FsbGV0LlwiLFxuXHRcdFx0YnV0dG9uOiBcIk5hc3RhdmlcIixcblx0XHRcdGxhYmVsOiBcIktsaWtuaSB6YSBrb3BpanVcIixcblx0XHRcdGNoZWNrTGFiZWw6IFwiS29waXJhbyBzYW0gaWxpIHphcGlzYW8gbG96aW5rdVwiXG5cdFx0fSxcblx0XHRjb21wbGV0ZToge1xuXHRcdFx0dGl0bGU6IFwiWmF2csWhaSBwcmlqZW5vc1wiLFxuXHRcdFx0ZGVzY09uZTogXCJZb3Ugd2lsbCBub3cgYmUgcmVkaXJlY3RlZCB0byB0aGUgd2FsbGV0IHlvdSBzZWxlY3RlZCB0byBjb21wbGV0ZSB0aGUgdHJhbnNmZXIuXCIsXG5cdFx0XHRkZXNjVHdvOiBcIkthZGEgamUgdW5vcyBzIG9kYWJyYW5vZyB3YWxsZXRhIHphdnLFoWVuLCBwcml0aXNuaXRlIGd1bWIgZGEgYmlzdGUgemF2csWhaWxpIHByaWplbm9zLlwiLFxuXHRcdFx0YnV0dG9uOiBcIlphdnLFoWlcIlxuXHRcdH1cblx0fVxufTtcbnZhciBociA9IHtcblx0bW9kYWw6IG1vZGFsJDNcbn07XG5cbnZhciBtb2RhbCQyID0ge1xuXHR3YWxsZXQ6IHtcblx0XHRjb25uZWN0WW91cldhbGxldDogXCLQn9C+0LLRgNC30LXRgtC1INCz0L4g0LLQsNGI0LjQvtGCINC90L7QstGH0LDQvdC40LohXCIsXG5cdFx0d2hhdElzQVdhbGxldDogXCLQqNGC0L4g0LUg0L3QvtCy0YfQsNC90LjQuj9cIixcblx0XHRzZWN1cmVBbmRNYW5hZ2U6IFwi0JfQsNGI0YLQuNGC0LXRgtC1INCz0Lgg0Lgg0YPQv9GA0LDQstGD0LLQsNGY0YLQtSDRgdC+INCy0LDRiNC40YLQtSDQtNC40LPQuNGC0LDQu9C90Lgg0YHRgNC10LTRgdGC0LLQsC5cIixcblx0XHRzYWZlbHlTdG9yZTogXCLQkdC10LfQsdC10LTQvdC+INGB0LrQu9Cw0LTQuNGA0LDRmNGC0LUg0Lgg0LjQt9Cy0YDRiNGD0LLQsNGY0YLQtSDRgtGA0LDQvdGB0LDQutGG0LjQuCDRgdC+INCy0LDRiNC40YLQtSDQutGA0LjQv9GC0L4g0LggTkZULlwiLFxuXHRcdGxvZ0luVG9Bbnk6IFwi0J3QsNGY0LDQstC10YLQtSDRgdC1INC90LAg0LrQvtGY0LAg0LHQuNC70L4gTkVBUiDQsNC/0LvQuNC60LDRhtC40ZjQsFwiLFxuXHRcdG5vTmVlZFRvQ3JlYXRlOiBcItCd0LXQvNCwINC/0L7RgtGA0LXQsdCwINC00LAg0LrRgNC10LjRgNCw0YLQtSDQvdC+0LLQuCDRgdC80LXRgtC60Lgg0LjQu9C4INC40L3Qs9C10YDQtdC90YbQuNC4LiDQn9C+0LLRgNC30LXRgtC1INCz0L4g0LLQsNGI0LjQvtGCINC/0LDRgNC40YfQvdC40Log0Lgg0YHRgtC1INC/0L7QtNCz0L7RgtCy0LXQvdC4IVwiLFxuXHRcdGdldEFXYWxsZXQ6IFwi0J3QsNC/0YDQsNCy0LXRgtC1INC90L7QstGH0LDQvdC40LpcIixcblx0XHR1c2VBV2FsbGV0OiBcItCa0L7RgNC40YHRgtC10YLQtSDQv9Cw0YDQuNGH0L3QuNC6INC30LAg0LTQsCDQs9C4INC30LDRiNGC0LjRgtC40YLQtSDQuCDRg9C/0YDQsNCy0YPQstCw0YLQtSDQstCw0YjQuNGC0LUgTkVBUiDRgdGA0LXQtNGB0YLQstCwINC4INC00LAg0YHQtSDQvdCw0ZjQsNCy0LjRgtC1INC90LAg0LrQvtGY0LAg0LHQuNC70L4gTkVBUiDQsNC/0LvQuNC60LDRhtC40ZjQsCDQsdC10Lcg0L/QvtGC0YDQtdCx0LAg0L7QtCDQutC+0YDQuNGB0L3QuNGH0LrQuCDQuNC80LjRmtCwINC4INC70L7Qt9C40L3QutC4LlwiLFxuXHRcdGNvbm5lY3Rpb25GYWlsZWQ6IFwi0J/QvtCy0YDQt9GD0LLQsNGa0LXRgtC+INC90LUg0LHQtdGI0LUg0YPRgdC/0LXRiNC90L4uXCIsXG5cdFx0Y29ubmVjdGlvblN1Y2Nlc3NmdWw6IFwi0KPRgdC/0LXRiNC90L4g0L/QvtCy0YDQt9GD0LLQsNGa0LUuXCIsXG5cdFx0Y29ubmVjdGVkOiBcItCf0L7QstGA0LfQsNC90L4uXCIsXG5cdFx0Y29ubmVjdGluZ1RvOiBcItCf0L7QstGA0LfRg9Cy0LDRmtC1INGB0L5cIixcblx0XHRjb25uZWN0aW5nTWVzc2FnZToge1xuXHRcdFx0aW5qZWN0ZWQ6IFwi0J/QvtGC0LLRgNC00LXRgtC1INCz0L4g0L/QvtCy0YDQt9GD0LLQsNGa0LXRgtC+INCy0L4g0LXQutGB0YLQtdGA0L3QuNC+0YIg0L/RgNC+0LfQvtGA0LXRhlwiLFxuXHRcdFx0YnJvd3NlcjogXCLQn9C+INC/0YDQtdGD0YHQvNC10YDRg9Cy0LDRmtC10YLQviwg0L/QvtGC0LLRgNC00LXRgtC1INCz0L4g0L/QvtCy0YDQt9GD0LLQsNGa0LXRgtC+INC+0LQg0L3QvtCy0YfQsNC90LjQvtC60YJcIixcblx0XHRcdGhhcmR3YXJlOiBcItCf0L7RgtCy0YDQtNC10YLQtSDQs9C+INC/0L7QstGA0LfRg9Cy0LDRmtC10YLQviDRgdC+INC70LDQtNC10L0g0L3QvtCy0YfQsNC90LjQulwiLFxuXHRcdFx0YnJpZGdlOiBcItCf0L7RgtCy0YDQtNC10YLQtSDRmNCwINCy0YDRgdC60LDRgtCwINCy0L4g0L3QvtCy0YfQsNC90LjQutC+0YJcIlxuXHRcdH1cblx0fSxcblx0bGVkZ2VyOiB7XG5cdFx0Y29ubmVjdFdpdGhMZWRnZXI6IFwi0J/QvtCy0YDQt9C10YLQtSDRgdC1INGB0L4g0JvQtdGf0LXRgFwiLFxuXHRcdG1ha2VTdXJlWW91ckxlZGdlcjogXCLQntGB0LjQs9GD0YDQsNGY0YLQtSDRgdC1INC00LXQutCwINCy0LDRiNC40L7RgiDQm9C10Z/QtdGAINC1INC/0L7QstGA0LfQsNC9INCx0LXQt9Cx0LXQtNC90L4sINC4INC00LXQutCwIE5FQVIg0LDQv9C70LjQutCw0YbQuNGY0LDRgtCwINC1INC+0YLQstC+0YDQtdC90LAg0L3QsCDQstCw0YjQuNC+0YIg0YPRgNC10LRcIixcblx0XHRcImNvbnRpbnVlXCI6IFwi0J/RgNC+0LTQvtC70LbQtdGC0LVcIixcblx0XHRzcGVjaWZ5SERQYXRoOiBcItCd0LDQstC10LTQtdGC0LUg0KXQlCDQu9C+0LrQsNGG0LjRmNCwXCIsXG5cdFx0ZW50ZXJZb3VyUHJlZmVycmVkSERQYXRoOiBcItCS0L3QtdGB0LXRgtC1INGY0LAg0LLQsNGI0LDRgtCwINC/0YDQtdGE0LXRgNC40YDQsNC90LAg0KXQlCDQu9C+0LrQsNGG0LjRmNCwLCDQsCDQv9C+0YLQvtCwINGB0LrQtdC90LjRgNCw0ZjRgtC1INC00LAg0LPQuCDQvdCw0ZjQtNC10YLQtSDQsNC60YLQuNCy0L3QuNGC0LUg0YHQvNC10YLQutC4LlwiLFxuXHRcdHNjYW46IFwi0KHQutC10L3QuNGA0LDRmNGC0LVcIixcblx0XHRyZXRyeTogXCLQntCx0LjQtNC10YLQtSDRgdC1INC/0L7QstGC0L7RgNC90L5cIixcblx0XHRsZWRnZXJJc05vdEF2YWlsYWJsZTogXCLQm9C10Z/QtdGA0L7RgiDQvdC1INC1INC00L7RgdGC0LDQv9C10L0uXCIsXG5cdFx0YWNjZXNzRGVuaWVkVG9Vc2VMZWRnZXJEZXZpY2U6IFwi0J/RgNC40YHRgtCw0L/QvtGCINC30LAg0LrQvtGA0LjRgdGC0LXRmtC1INC90LAg0JvQtdGf0LXRgCDRg9GA0LXQtCDQtSDQvtC00LHQuNC10L1cIixcblx0XHRub0FjY291bnRzRm91bmQ6IFwi0J3QtdC80LAg0L3QsNGY0LTQtdC90Lgg0YHQvNC10YLQutC4XCIsXG5cdFx0c2VsZWN0WW91ckFjY291bnRzOiBcItCY0LfQsdC10YDQtdGC0LUg0LPQuCDQstCw0YjQuNGC0LUg0YHQvNC10YLQutC4XCIsXG5cdFx0Y29ubmVjdGluZzFBY2NvdW50OiBcItCf0L7QstGA0LfRg9Cy0LDRmtC1INC90LAg0LXQtNC90LAg0YHQvNC10YLQutCwXCIsXG5cdFx0Y2FudEZpbmRBbnlBY2NvdW50OiBcItCd0LUg0YHQtSDQvdCw0ZjQtNC10L3QuCDRgdC80LXRgtC60Lgg0L/QvtCy0YDQt9Cw0L3QuCDRgdC+INC+0LLQvtGYINCb0LXRn9C10YAuINCS0LUg0LzQvtC70LjQvNC1INC60YDQtdC40YDQsNGY0YLQtSDQvdC+0LLQsCBORUFSINGB0LzQtdGC0LrQsCBcIixcblx0XHRvckNvbm5lY3RBbkFub3RoZXJMZWRnZXI6IFwi0LjQu9C4INC/0L7QstGA0LfQtdGC0LUg0LTRgNGD0LMg0JvQtdGf0LXRgC5cIixcblx0XHRjb25uZWN0aW5nOiBcItCf0L7QstGA0LfRg9Cy0LDRmtC1XCIsXG5cdFx0b2ZBY2NvdW50czogXCLQvdCwINGB0LzQtdGC0LrQuFwiLFxuXHRcdGZhaWxlZFRvQXV0b21hdGljYWxseTogXCLQndC10YPRgdC/0LXRiNC90L4g0LDQstGC0L7QvNCw0YLRgdC60L4g0LHQsNGA0LDRmtC1INC90LAg0JjQlCDQvdCwINGB0LzQtdGC0LrQsNGC0LAuINCS0L3QtdGB0LXRgtC1INCz0L4g0YDQsNGH0L3QvjpcIixcblx0XHRvdmVydmlld1RoZUxpc3RPZkF1dGhvcml6ZWQ6IFwi0J/RgNC10LPQu9C10LQg0L3QsCDQu9C40YHRgtCw0YLQsCDQvdCwINC+0LLQu9Cw0YHRgtC10L3QuCDRgdC80LXRgtC60LgsINC30LDQstGA0YjQtdGC0LUg0YHQtSDQvdCw0ZjQsNCy0LDRgtCwINGB0L4g0LrQu9C40LrQvdGD0LLQsNGa0LUg0L3QsCDQutC+0L/Rh9C10YLQviDQv9C+0LTQvtC70YMuXCIsXG5cdFx0ZmluaXNoOiBcItCX0LDQstGA0YjQtdGC0LVcIlxuXHR9LFxuXHRpbnN0YWxsOiB7XG5cdFx0eW91bGxOZWVkVG9JbnN0YWxsOiBcItCi0YDQtdCx0LAg0LTQsCDQuNC90YHRgtCw0LvQuNGA0LDRgtC1XCIsXG5cdFx0dG9Db250aW51ZUFmdGVySW5zdGFsbGluZzogXCLQt9CwINC00LAg0L/RgNC+0LTQvtC70LbQuNGC0LUuINCf0L4g0LjQvdGB0YLQsNC70LjRgNCw0ZrQtdGC0L5cIixcblx0XHRyZWZyZXNoVGhlUGFnZTogXCLQntGB0LLQtdC20LXRgtC1INGY0LAg0YHRgtGA0LDQvdCw0YLQsC5cIixcblx0XHRvcGVuOiBcItCe0YLQstC+0YDQtdGC0LVcIlxuXHR9LFxuXHRxcjoge1xuXHRcdGNvcGllZFRvQ2xpcGJvYXJkOiBcItCa0L7Qv9C40YDQsNC90L4g0L3QsCDQutC70LjQv9Cx0L7RgNC00L7RglwiLFxuXHRcdGZhaWxlZFRvQ29weTogXCLQndC10YPRgdC/0LXRiNC90L4g0LrQvtC/0LjRgNCw0ZrQtSDQvdCwINC60LvQuNC/0LHQvtGA0LRcIixcblx0XHRzY2FuV2l0aFlvdXJNb2JpbGU6IFwi0KHQutC10L3QuNGA0LDRmNGC0LUg0YHQviDQstCw0YjQuNC+0YIg0YLQtdC70LXRhNC+0L3RgdC60Lgg0YPRgNC10LRcIixcblx0XHRjb3B5VG9DbGlwYm9hcmQ6IFwi0JrQvtC/0LjRgNCw0ZjRgtC1INC90LAg0LrQu9C40L/QsdC+0YDQtFwiLFxuXHRcdHByZWZlclRoZU9mZmljaWFsOiBcItCf0YDQtdGE0LXRgNC40YDQsNGY0YLQtSDQvtGE0LjRhtC40ZjQsNC70LXQvSDQtNC40LDQu9C+0LMg0L3QsFwiLFxuXHRcdG9wZW46IFwi0J7RgtCy0L7RgNC10YLQtVwiXG5cdH0sXG5cdHdhbGxldFR5cGVzOiB7XG5cdFx0aGFyZHdhcmU6IFwi0KXQsNGA0LTQstC10YDRgdC60Lgg0L3QvtCy0YfQsNC90LjQulwiLFxuXHRcdGJyb3dzZXI6IFwi0J3QvtCy0YfQsNC90LjQuiDQvdCwINC40L3RgtC10YDQvdC10YIg0L/RgNC10LvQuNGB0YLRg9Cy0LDRh1wiLFxuXHRcdGluamVjdGVkOiBcItCV0LrRgdGC0LXQvdC30LjRmNCwINC30LAg0L3QvtCy0YfQsNC90LjQulwiLFxuXHRcdGJyaWRnZTogXCJCcmlkZ2Ug0L3QvtCy0YfQsNC90LjQulwiLFxuXHRcdG1vYmlsZTogXCLQnNC+0LHQuNC70LXQvSDQvdC+0LLRh9Cw0L3QuNC6XCIsXG5cdFx0XCJpbnN0YW50LWxpbmtcIjogXCLQmNC90YHRgtCw0L3RgiDQv9Cw0YDQuNGH0L3QuNC6XCJcblx0fSxcblx0ZXhwb3J0QWNjb3VudHM6IHtcblx0XHRjaG9vc2VBV2FsbGV0OiBcItCe0LTQsdC10YDQtdGC0LUg0L/QsNGA0LjRh9C90LjQulwiLFxuXHRcdHRyYW5zZmVyWW91ckFjY291bnRzOiBcItCf0YDQtdGE0YDQu9C10YLQtSDQs9C4INCy0LDRiNC40YLQtSDQutC+0YDQuNGB0L3QuNGH0LrQuCDRgdC80LXRgtC60LhcIixcblx0XHRzZWxlY3RBV2FsbGV0OiBcItCY0LfQsdC10YDQtdGC0LXQvSDQvdC+0LLRh9Cw0L3QuNC6INC60L7RmCDQs9C4INC30LDQtNC+0LLQvtC70YPQstCwINCy0LDRiNC40YLQtSDQsdCw0YDQsNC90ZrQsCDQuCDQs9C4INC/0L7QtNC00YDQttGD0LLQsCDQstCw0YjQuNGC0LUg0L/QvtCy0YDQt9Cw0L3QuCDQutC+0YDQuNGB0L3QuNGH0LrQuCDRgdC80LXRgtC60LguXCIsXG5cdFx0c2VsZWN0WW91ckFjY291bnRzOiBcItCY0LfQsdC10YDQtdGC0LUg0LPQuCDQstCw0YjQuNGC0LUg0LrQvtGA0LjRgdC90LjRh9C60Lgg0YHQvNC10YLQutC4XCIsXG5cdFx0YWZ0ZXJEZWNpZGU6IFwi0J7QtNC60LDQutC+INGc0LUg0LjQt9Cx0LXRgNC10YLQtSDQvdC+0LLRh9Cw0L3QuNC6LCDQvNC+0LbQtdGC0LUg0LTQsCDQuNC30LHQtdGA0LXRgtC1INC60L7QuCDQutC+0YDQuNGB0L3QuNGH0LrQuCDRgdC80LXRgtC60Lgg0YHQsNC60LDRgtC1INC00LAg0LPQuCDQv9GA0LXRhNGA0LvQuNGC0LUuXCIsXG5cdFx0ZGlzY2xhaW1lcjogXCLQndC1INC80L7QttC10YLQtSDQtNCwINC/0YDRhNGA0LvQsNGC0LUg0LrQvtGA0LjRgdC90LjRh9C60Lgg0YHQvNC10YLQutC4INC60L7QuCDQvdC40LrQvtCz0LDRiCDQvdC1INCx0LjQu9C1INC90LDQtNC+0L/QvtC70L3QsNGC0Lgg0LjQu9C4INC60L7RgNC40YHRgtC10L3QuCDQvdCwIE5FQVIuXCIsXG5cdFx0d2FybmluZzogXCLQvdC1INC/0L7QtNC00YDQttGD0LLQsCDQuNC30LLQtdC30YPQstCw0ZrQtSDQvdCwINC60L7RgNC40YHQvdC40YfQutC4INGB0LzQtdGC0LrQuCDQstC+INC+0LLQvtGYINC80L7QvNC10L3Rgi4g0JLQtSDQvNC+0LvQuNC80LUg0LjQt9Cx0LXRgNC10YLQtSDQtNGA0YPQsyDQvdC+0LLRh9Cw0L3QuNC6LlwiLFxuXHRcdHdhbGxldFR5cGVzOiB7XG5cdFx0XHRoYXJkd2FyZTogXCLQpdCw0YDQtNCy0LXRgNGB0LrQuCDQvdC+0LLRh9Cw0L3QuNC6XCIsXG5cdFx0XHRicm93c2VyOiBcItCd0L7QstGH0LDQvdC40Log0L3QsCDQuNC90YLQtdGA0L3QtdGCINC/0YDQtdC70LjRgdGC0YPQstCw0YdcIixcblx0XHRcdGluamVjdGVkOiBcItCV0LrRgdGC0LXQvdC30LjRmNCwINC30LAg0L3QvtCy0YfQsNC90LjQulwiLFxuXHRcdFx0YnJpZGdlOiBcIkJyaWRnZSDQvdC+0LLRh9Cw0L3QuNC6XCIsXG5cdFx0XHRtb2JpbGU6IFwi0JzQvtCx0LjQu9C10L0g0L3QvtCy0YfQsNC90LjQulwiXG5cdFx0fSxcblx0XHRzZWxlY3RBY2NvdW50czoge1xuXHRcdFx0dGl0bGU6IFwi0JjQt9Cx0LXRgNC10YLQtSDQs9C4INC60L7RgNC40YHQvdC40YfQutC40YLQtSDRgdC80LXRgtC60Lgg0LfQsCDQtNCwINCz0Lgg0L/RgNC10YTRgNC70LjRgtC1LlwiLFxuXHRcdFx0YnV0dG9uOiBcItCU0L7QsdC40ZjRgtC1INC70L7Qt9C40L3QutCwXCIsXG5cdFx0XHRkZXNlbGVjdEFsbDogXCLQntGC0YHQtdC70LXQutGC0LjRgNCw0ZjRgtC1INGB0LVcIixcblx0XHRcdHNlbGVjdEFsbDogXCLQmNC30LHQtdGA0LXRgtC1INGB0LVcIixcblx0XHRcdHVuYXZhaWxhYmxlOiBcItCi0YDQsNC90YHRhNC10YDQvtGCINC1INC90LXQtNC+0YHRgtCw0L/QtdC9XCIsXG5cdFx0XHRlcnJvcjogXCLQmtC+0YDQuNGB0L3QuNGH0LrQsNGC0LAg0YHQvNC10YLQutCwINC90LUg0L/QvtGB0YLQvtC4XCIsXG5cdFx0XHR3YXJuaW5nTGVkZ2VyOiBcItCf0L7RgtGA0LXQsdC90LAg0LUg0L/QvtC00LTRgNGI0LrQsCDQvtC0INCb0LXRn9C10YBcIixcblx0XHRcdG5vQmFsYW5jZTogXCLQodC80LXRgtC60LDRgtCwINC90LUg0LUg0YTQuNC90LDQvdGB0LjRgNCw0L3QsFwiXG5cdFx0fSxcblx0XHRnZXRQYXNzcGhyYXNlOiB7XG5cdFx0XHR0aXRsZTogXCLQmtC+0L/QuNGA0LDRmNGC0LUg0ZjQsCDQv9GA0LjQstGA0LXQvNC10L3QsNGC0LAg0LvQvtC30LjQvdC60LBcIixcblx0XHRcdGRlc2M6IFwi0IzQtSDRgtGA0LXQsdCwINC00LAg0ZjQsCDQstC90LXRgdC10YLQtSDQvtCy0LDQsCDQu9C+0LfQuNC90LrQsCDQutC+0LPQsCDRnNC1INC30LDQv9C+0YfQvdC10YLQtSDQtNCwINCz0Lgg0LjQt9Cy0LXQt9GD0LLQsNGC0LUg0LLQsNGI0LjRgtC1INGB0LzQtdGC0LrQuCDQvdCwINC00YDRg9CzINC90L7QstGH0LDQvdC40LouXCIsXG5cdFx0XHRidXR0b246IFwi0J/RgNC+0LTQvtC70LbQtdGC0LVcIixcblx0XHRcdGxhYmVsOiBcItCa0LvQuNC60L3QtdGC0LUg0LfQsCDQtNCwINC60L7Qv9C40YDQsNGC0LVcIixcblx0XHRcdGNoZWNrTGFiZWw6IFwi0IjQsCDQutC+0L/QuNGA0LDQsiDQuNC70Lgg0LfQsNC/0LjRiNCw0LIg0LvQvtC30LjQvdC60LDRgtCwXCJcblx0XHR9LFxuXHRcdGNvbXBsZXRlOiB7XG5cdFx0XHR0aXRsZTogXCLQl9Cw0LLRgNGI0LXRgtC1INCz0L4g0L/RgNC10L3QvtGB0L7RglwiLFxuXHRcdFx0ZGVzY09uZTogXCLQodC10LPQsCDRnNC1INCx0LjQtNC10YLQtSDQv9GA0LXQvdCw0YHQvtGH0LXQvdC4INC90LAg0LjQt9Cx0YDQsNC90LjQvtGCINC90L7QstGH0LDQvdC40Log0LfQsCDQt9Cw0LLRgNGI0YPQstCw0ZrQtSDQvdCwINC/0YDQtdC90L7RgdC+0YIuXCIsXG5cdFx0XHRkZXNjVHdvOiBcItCe0YLQutCw0LrQviDRnNC1INC30LDQstGA0YjQuCDRg9Cy0L7Qt9C+0YIg0L7QtCDQuNC30LHRgNCw0L3QuNC+0YIg0L3QvtCy0YfQsNC90LjQuiwg0L/RgNC40YLQuNGB0L3QtdGC0LUg0LPQviDQutC+0L/Rh9C10YLQviDQt9CwINC00LAg0LPQviDQt9Cw0LLRgNGI0LjRgtC1INC/0YDQtdC90L7RgdC+0YIuXCIsXG5cdFx0XHRidXR0b246IFwi0JfQsNCy0YDRiNC10YLQtVwiXG5cdFx0fVxuXHR9XG59O1xudmFyIG1rID0ge1xuXHRtb2RhbDogbW9kYWwkMlxufTtcblxudmFyIG1vZGFsJDEgPSB7XG5cdHdhbGxldDoge1xuXHRcdGNvbm5lY3RZb3VyV2FsbGV0OiBcIlBvdmXFvml0ZSBzdm9qbyBkZW5hcm5pY28hXCIsXG5cdFx0d2hhdElzQVdhbGxldDogXCJLYWogamUgZGVuYXJuaWNhP1wiLFxuXHRcdHNlY3VyZUFuZE1hbmFnZTogXCJaYXZhcnVqdGUgaW4gdXByYXZsamFqdGUgc3ZvamEgZGlnaXRhbG5hIHNyZWRzdHZhLlwiLFxuXHRcdHNhZmVseVN0b3JlOiBcIlZhcm5vIHNocmFuanVqdGUgaW4gcHJlbmHFoWFqdGUgc3ZvamUga3JpcHRvdmFsdXRlIGluIE5GVGplLlwiLFxuXHRcdGxvZ0luVG9Bbnk6IFwiUHJpamF2aXRlIHNlIHYga2F0ZXJvIGtvbGkgYXBsaWthY2lqbyBuYSBORUFSXCIsXG5cdFx0bm9OZWVkVG9DcmVhdGU6IFwiTmkgdmFtIHRyZWJhIHVzdHZhcmphdGkgbm92aWggcmHEjXVub3YuIFBvdmXFvml0ZSBzdm9qbyBkZW5hcm5pY28gaW4gemHEjW5pdGUhXCIsXG5cdFx0Z2V0QVdhbGxldDogXCJVc3R2YXJpdGUgZGVuYXJuaWNvXCIsXG5cdFx0dXNlQVdhbGxldDogXCJVcG9yYWJpdGUgZGVuYXJuaWNvLCBkYSBiaSB6YXZhcm92YWxpIGluIHVwcmF2bGphbGkgcyBzdm9qYSBORUFSIGRpZ2l0YWxuYSBzcmVkc3R2YSwgaW4gc2UgcHJpamF2aXRlIHYga2F0ZXJvIGtvbGkgYXBsaWthY2lqbyBla29zaXN0ZW1hIE5FQVJcIixcblx0XHRjb25uZWN0aW9uRmFpbGVkOiBcIlBvdmV6YXZhIG5pIGJpbGEgdXNwZcWhbmEuXCIsXG5cdFx0Y29ubmVjdGlvblN1Y2Nlc3NmdWw6IFwiUG92ZXphdmEgamUgYmlsYSB1c3BlxaFuYS5cIixcblx0XHRjb25uZWN0ZWQ6IFwiVmHFoWEgZGVuYXJuaWNhIGplIHBvdmV6YW5hLlwiLFxuXHRcdGNvbm5lY3RpbmdUbzogXCJQb3Zlem92YW5qZSB6XCIsXG5cdFx0Y29ubmVjdGluZ01lc3NhZ2U6IHtcblx0XHRcdGluamVjdGVkOiBcIlBvdHJkaXRlIHBvdmV6YXZvIHYgb2tudSByYXrFoWlyaXR2ZVwiLFxuXHRcdFx0YnJvd3NlcjogXCJQbyBwcmV1c21lcml0dmkgcG90cmRpdGUgcG92ZXphdm8gdiBkZW5hcm5pY2lcIixcblx0XHRcdGhhcmR3YXJlOiBcIlBvdHJkaXRlIHBvdmV6YXZvIHMgaGxhZG5vIGRlbmFybmljb1wiLFxuXHRcdFx0YnJpZGdlOiBcIlBvdHJkaXRlIHBvdmV6YXZvIHYgZGVuYXJuaWNpXCJcblx0XHR9XG5cdH0sXG5cdGxlZGdlcjoge1xuXHRcdGNvbm5lY3RXaXRoTGVkZ2VyOiBcIlBvdmXFvml0ZSBzZSB6IExlZGdlclwiLFxuXHRcdG1ha2VTdXJlWW91ckxlZGdlcjogXCJQcmVwcmnEjWFqdGUgc2UsIGRhIGplIHZhxaEgTGVkZ2VyIHZhcm5vIHBvdmV6YW4gaW4gZGEgamUgYXBsaWthY2lqYSBORUFSIG9kcHJ0YSB2IHZhxaFpIG5hcHJhdmlcIixcblx0XHRcImNvbnRpbnVlXCI6IFwiTmFkYWxqdWpcIixcblx0XHRzcGVjaWZ5SERQYXRoOiBcIkRvbG/EjWl0ZSBIRCBwb3RcIixcblx0XHRlbnRlcllvdXJQcmVmZXJyZWRIRFBhdGg6IFwiVm5lc2l0ZSDFvmVsZW5vIEhEIHBvdCwgbmF0byBwb2nFocSNaXRlIHZzZSBha3Rpdm5lIHJhxI11bmUuXCIsXG5cdFx0c2NhbjogXCJTa2VuaXJhanRlXCIsXG5cdFx0cmV0cnk6IFwiUG9za3VzaXRlIHpub3ZhXCIsXG5cdFx0bGVkZ2VySXNOb3RBdmFpbGFibGU6IFwiTGVkZ2VyIG5pIG5hIHZvbGpvXCIsXG5cdFx0YWNjZXNzRGVuaWVkVG9Vc2VMZWRnZXJEZXZpY2U6IFwiRG9zdG9wIHphIHVwb3JhYm8gbmFwcmF2ZSBMZWRnZXIgemF2cm5qZW5cIixcblx0XHRub0FjY291bnRzRm91bmQ6IFwiTmkgbmFqZGVuaWggcmHEjXVub3ZcIixcblx0XHRzZWxlY3RZb3VyQWNjb3VudHM6IFwiSXpiZXJpdGUgVmHFoWkgcmHEjXVuaVwiLFxuXHRcdGNvbm5lY3RpbmcxQWNjb3VudDogXCJQb3Zlem92YW5qZSBlbmVnYSByYcSNdW5hXCIsXG5cdFx0Y2FudEZpbmRBbnlBY2NvdW50OiBcIk5pIG1vZ2/EjWUgbmFqdGkgbm9iZW5lZ2EgcmHEjXVuYSwgcG92ZXphbmVnYSBzIHRlbSBMZWRnZXJqZW0uIFVzdHZhcml0ZSBub3YgTkVBUiByYcSNdW4gXCIsXG5cdFx0b3JDb25uZWN0QW5Bbm90aGVyTGVkZ2VyOiBcImFsaSBwb3Zlxb5pdGUgZHJ1ZyBMZWRnZXIuLlwiLFxuXHRcdGNvbm5lY3Rpbmc6IFwiUG92ZXpvdmFuamVcIixcblx0XHRvZkFjY291bnRzOiBcInJhxI11bm92XCIsXG5cdFx0ZmFpbGVkVG9BdXRvbWF0aWNhbGx5OiBcIklELWphIHJhxI11bmEgbmkgYmlsbyBtb2dvxI1lIHNhbW9kZWpubyBuYWp0aS4gWmFnb3Rvdml0ZSBnYSByb8SNbm86XCIsXG5cdFx0b3ZlcnZpZXdUaGVMaXN0T2ZBdXRob3JpemVkOiBcIk9nbGVqdGUgc2kgc2V6bmFtIHBvb2JsYcWhxI1lbmloIHJhxI11bm92LCBkb2tvbsSNYWp0ZSBwcmlqYXZvIHMga2xpa29tIG5hIHNwb2RuamkgZ3VtYi5cIixcblx0XHRmaW5pc2g6IFwiS29uxI1hanRlXCJcblx0fSxcblx0aW5zdGFsbDoge1xuXHRcdHlvdWxsTmVlZFRvSW5zdGFsbDogXCJNb3JhbGkgZ2EgYm9zdGUgbmFtZXN0aXRpXCIsXG5cdFx0dG9Db250aW51ZUFmdGVySW5zdGFsbGluZzogXCJuYWRhbGpldmF0aS4gUG8gbmFtZXN0aXR2aVwiLFxuXHRcdHJlZnJlc2hUaGVQYWdlOiBcIk9zdmXFvml0ZSBzdHJhbi5cIixcblx0XHRvcGVuOiBcIk9kcHJpdGVcIlxuXHR9LFxuXHRxcjoge1xuXHRcdGNvcGllZFRvQ2xpcGJvYXJkOiBcIktvcGlyYW5vIHYgcG9kbG/Fvm5pIG1hcGlcIixcblx0XHRmYWlsZWRUb0NvcHk6IFwiS29waXJhbmplIHYgcG9kbG/Fvm5pIG1hcGkgbmkgdXNwZWxvXCIsXG5cdFx0c2NhbldpdGhZb3VyTW9iaWxlOiBcIlNrZW5pcmFqdGUgcyBzdm9qbyBtb2JpbG5vIG5hcHJhdm9cIixcblx0XHRjb3B5VG9DbGlwYm9hcmQ6IFwiIEtvcGlyYWp0ZSB2IHBvZGxvxb5uaSBtYXBpXCIsXG5cdFx0cHJlZmVyVGhlT2ZmaWNpYWw6IFwiUHJlZmVyaXJhanRlIHVyYWRubyBwb2dvdm9ybm8gb2tub1wiLFxuXHRcdG9wZW46IFwiT2Rwcml0ZVwiXG5cdH0sXG5cdHdhbGxldFR5cGVzOiB7XG5cdFx0aGFyZHdhcmU6IFwiSGxhZG5hIGRlbmFybmljYVwiLFxuXHRcdGJyb3dzZXI6IFwiRGVuYXJuaWNhIGJyc2thbG5pa2FcIixcblx0XHRpbmplY3RlZDogXCJSYXrFoWlyaXRldiB6YSBkZW5hcm5pY29cIixcblx0XHRicmlkZ2U6IFwiQnJpZGdlIGRlbmFybmljYVwiLFxuXHRcdG1vYmlsZTogXCJNb2JpbG5hIGRlbmFybmljYVwiLFxuXHRcdFwiaW5zdGFudC1saW5rXCI6IFwiVGFrb2rFoW5qYSBkZW5hcm5pY2FcIlxuXHR9LFxuXHRleHBvcnRBY2NvdW50czoge1xuXHRcdGNob29zZUFXYWxsZXQ6IFwiSXpiZXJpdGUgZGVuYXJuaWNvXCIsXG5cdFx0dHJhbnNmZXJZb3VyQWNjb3VudHM6IFwiUHJlbmVzaXRlIHN2b2plIHJhxI11bmVcIixcblx0XHRzZWxlY3RBV2FsbGV0OiBcIkl6YmVyaXRlIGRlbmFybmljbywga2kgdXN0cmV6YSB2YcWhaW0gcG90cmViYW0gaW4gcG9kcGlyYSB2YcWhZSBwb3ZlemFuZSByYcSNdW5lLlwiLFxuXHRcdHNlbGVjdFlvdXJBY2NvdW50czogXCJJemJlcml0ZSB2YcWhaSByYcSNdW5pXCIsXG5cdFx0YWZ0ZXJEZWNpZGU6IFwiS28gc2Ugb2Rsb8SNaXRlIHphIGRlbmFybmljbywgbGFoa28gaXpiZXJldGUsIGthdGVyZSByYcSNdW5lIMW+ZWxpdGUgcHJlbmVzdGkuXCIsXG5cdFx0ZGlzY2xhaW1lcjogXCJOZSBib3N0ZSBtb2dsaSBwcmVuZXN0aSBSYcSNdW5vdiwga2kgbmlrb2xpIG5pc28gYmlsaSBmaW5hbmNpcmFuaSBhbGkgdXBvcmFibGplbmkgbmEgTkVBUi5cIixcblx0XHR3YXJuaW5nOiBcInRyZW51dG5vIG5lIHBvZHBpcmEgaXp2b3phIHJhxI11bmEuIEl6YmVyaXRlIGRydWdvIGRlbmFybmljb1wiLFxuXHRcdHdhbGxldFR5cGVzOiB7XG5cdFx0XHRoYXJkd2FyZTogXCJIbGFkbmEgZGVuYXJuaWNhXCIsXG5cdFx0XHRicm93c2VyOiBcIkRlbmFybmljYSBicnNrYWxuaWthXCIsXG5cdFx0XHRpbmplY3RlZDogXCJSYXrFoWlyaXRldiB6YSBkZW5hcm5pY29cIixcblx0XHRcdGJyaWRnZTogXCJCcmlkZ2UgZGVuYXJuaWNhXCIsXG5cdFx0XHRtb2JpbGU6IFwiTW9iaWxuYSBkZW5hcm5pY2FcIlxuXHRcdH0sXG5cdFx0c2VsZWN0QWNjb3VudHM6IHtcblx0XHRcdHRpdGxlOiBcIkl6YmVyaXRlIHJhxI11bmkgemEgcHJlbm9zLlwiLFxuXHRcdFx0YnV0dG9uOiBcIlByaWRvYml0ZSBnZXNsb1wiLFxuXHRcdFx0ZGVzZWxlY3RBbGw6IFwiUHJla2xpxI1pIGl6YmlybyB2c2VoXCIsXG5cdFx0XHRzZWxlY3RBbGw6IFwiSXpiZXJpIHZzZVwiLFxuXHRcdFx0dW5hdmFpbGFibGU6IFwiUHJlbm9zIG5pIG5hIHZvbGpvXCIsXG5cdFx0XHRlcnJvcjogXCJSYcSNdW4gbmUgb2JzdGFqYVwiLFxuXHRcdFx0d2FybmluZ0xlZGdlcjogXCJQb3RyZWJuYSBqZSBwb2Rwb3JhIHphIExlZGdlclwiLFxuXHRcdFx0bm9CYWxhbmNlOiBcIlJhxI11biBuaSBmaW5hbmNpcmFuXCJcblx0XHR9LFxuXHRcdGdldFBhc3NwaHJhc2U6IHtcblx0XHRcdHRpdGxlOiBcIktvcGlyYWogemHEjWFzbm8gZ2VzbG9cIixcblx0XHRcdGRlc2M6IFwiVG8gZ2VzbG8gYm9zdGUgbW9yYWxpIHZuZXN0aSwga28gYm9zdGUgemHEjWVsaSBpenZhxb5hdGkgc3ZvamUgcmHEjXVuZSB2IGRydWdvIGRlbmFybmljby5cIixcblx0XHRcdGJ1dHRvbjogXCJOYWRhbGp1anRlXCIsXG5cdFx0XHRsYWJlbDogXCJLbGlrbml0ZSB6YSBrb3BpcmFuamVcIixcblx0XHRcdGNoZWNrTGFiZWw6IFwiR2VzbG8gc2VtIGtvcGlyYWwgYWxpIHphcGlzYWxcIlxuXHRcdH0sXG5cdFx0Y29tcGxldGU6IHtcblx0XHRcdHRpdGxlOiBcIkRva29uxI1hanRlIHByZW5vc1wiLFxuXHRcdFx0ZGVzY09uZTogXCJaZGFqIGJvc3RlIHByZXVzbWVyamVuaSB2IGRlbmFybmljbywga2kgc3RlIGpvIGl6YnJhbGkgemEgZG9rb27EjWFuamUgcHJlbm9zYS5cIixcblx0XHRcdGRlc2NUd286IFwiS28gamUgdXZvem5pIGRlbCBwb3N0b3BrYSBrb27EjWFuIGl6IGl6YnJhbmUgZGVuYXJuaWNlLCBwcml0aXNuaXRlIGd1bWIgemEgZG9rb27EjWFuamUgcG9zdG9wa2EgcHJlbm9zYS5cIixcblx0XHRcdGJ1dHRvbjogXCJLb27EjWFqdGVcIlxuXHRcdH1cblx0fVxufTtcbnZhciBzbCA9IHtcblx0bW9kYWw6IG1vZGFsJDFcbn07XG5cbnZhciBtb2RhbCA9IHtcblx0d2FsbGV0OiB7XG5cdFx0Y29ubmVjdFlvdXJXYWxsZXQ6IFwi0J/QvtCy0LXQttC40YLQtSDRgdCy0L7RmCDQvdC+0LLRh9Cw0L3QuNC6IVwiLFxuXHRcdHdoYXRJc0FXYWxsZXQ6IFwi0KjRgtCwINGY0LUg0L3QvtCy0YfQsNC90LjQuj9cIixcblx0XHRzZWN1cmVBbmRNYW5hZ2U6IFwi0J7QsdC10LfQsdC10LTQuNGC0LUg0Lgg0YPQv9GA0LDQstGZ0LDRmNGC0LUg0YHQstC+0ZjQvtC8INC00LjQs9C40YLQsNC70L3QvtC8INC40LzQvtCy0LjQvdC+0LwuXCIsXG5cdFx0c2FmZWx5U3RvcmU6IFwi0JHQtdC30LHQtdC00L3QviDRh9GD0LLQsNGY0YLQtSDQuCDQv9GA0LXQvdC+0YHQuNGC0LUg0YHQstC+0ZjQtSDQutGA0LjQv9GC0L7QstCw0LvRg9GC0LUg0LggTkZULlwiLFxuXHRcdGxvZ0luVG9Bbnk6IFwi0J/RgNC40ZjQsNCy0LjRgtC1INGB0LUg0L3QsCDQsdC40LvQviDQutC+0ZjRgyDQsNC/0LvQuNC60LDRhtC40ZjRgyBORUFSXCIsXG5cdFx0bm9OZWVkVG9DcmVhdGU6IFwi0J3QtdC80LAg0L/QvtGC0YDQtdCx0LUg0LTQsCDQutGA0LXQuNGA0LDRgtC1INC90L7QstC1INC90LDQu9C+0LPQtSDQuNC70Lgg0LDQutGA0LXQtNC40YLQuNCy0LUuINCf0L7QstC10LbQuNGC0LUg0L3QvtCy0YfQsNC90LjQuiDQuCDRgdC/0YDQtdC80L3QuCDRgdGCZSFcIixcblx0XHRnZXRBV2FsbGV0OiBcItCd0LDQsdCw0LLQuNGC0LUg0L3QvtCy0YfQsNC90LjQulwiLFxuXHRcdHVzZUFXYWxsZXQ6IFwi0JrQvtGA0LjRgdGC0LjRgtC1INC90L7QstGH0LDQvdC40Log0LTQsCDQvtCx0LXQt9Cx0LXQtNC40YLQtSDQuCDRg9C/0YDQsNCy0ZnQsNGC0LUg0YHQstC+0ZjQuNC8IE5FQVIg0YHRgNC10LTRgdGC0LLQuNC80LAg0Lgg0LTQsCDRgdC1INC/0YDQuNGY0LDQstC40YLQtSDRgyDQsdC40LvQviDQutC+0ZjRgyDQsNC/0LvQuNC60LDRhtC40ZjRgyBORUFSINCx0LXQtyDQv9C+0YLRgNC10LHQtSDQt9CwINC60L7RgNC40YHQvdC40YfQutC40Lwg0LjQvNC10L3QuNC80LAg0Lgg0LvQvtC30LjQvdC60LDQvNCwLlwiLFxuXHRcdGNvbm5lY3Rpb25GYWlsZWQ6IFwi0JLQtdC30LAg0L3QuNGY0LUg0YPRgdC/0L7RgdGC0LDQstGZ0LXQvdCwLlwiLFxuXHRcdGNvbm5lY3Rpb25TdWNjZXNzZnVsOiBcItCS0LXQt9CwINGY0LUg0YPRgdC/0LXQu9CwLlwiLFxuXHRcdGNvbm5lY3RlZDogXCLQn9C+0LLQtdC30LDQvS5cIixcblx0XHRjb25uZWN0aW5nVG86IFwi0J/QvtCy0LXQt9C40LLQsNGa0LUg0L3QsFwiLFxuXHRcdGNvbm5lY3RpbmdNZXNzYWdlOiB7XG5cdFx0XHRpbmplY3RlZDogXCLQn9C+0YLQstGA0LTQuNGC0LUg0LLQtdC30YMg0YMg0YHQv9C+0ZnQvdC+0Lwg0L/RgNC+0LfQvtGA0YNcIixcblx0XHRcdGJyb3dzZXI6IFwi0J3QsNC60L7QvSDQv9GA0LXRg9GB0LzQtdGA0LDQstCw0ZrQsCwg0L/QvtGC0LLRgNC00LjRgtC1INCy0LXQt9GDINGDINC90L7QstGH0LDQvdC40LrRg1wiLFxuXHRcdFx0aGFyZHdhcmU6IFwi0J/QvtGC0LLRgNC00LjRgtC1INCy0LXQt9GDINGB0LAg0YXQu9Cw0LTQvdC40Lwg0L3QvtCy0YfQsNC90LjQutC+0LxcIixcblx0XHRcdGJyaWRnZTogXCLQn9C+0YLQstGA0LTQuNGC0LUg0LLQtdC30YMg0YHQsCDQvdC+0LLRh9Cw0L3QuNC60L7QvFwiXG5cdFx0fVxuXHR9LFxuXHRsZWRnZXI6IHtcblx0XHRjb25uZWN0V2l0aExlZGdlcjogXCLQn9C+0LLQtdC20LjRgtC1INGB0LUg0YHQsCBMZWRnZXJcIixcblx0XHRtYWtlU3VyZVlvdXJMZWRnZXI6IFwi0KPQstC10YDQuNGC0LUg0YHQtSDQtNCwINGY0LUg0LLQsNGIIExlZGdlciDQsdC10LfQsdC10LTQvdC+INC/0L7QstC10LfQsNC9INC4INC00LAg0ZjQtSDQsNC/0LvQuNC60LDRhtC40ZjQsCBORUFSINC+0YLQstC+0YDQtdC90LAg0L3QsCDQstCw0YjQtdC8INGD0YDQtdGS0LDRmNGDXCIsXG5cdFx0XCJjb250aW51ZVwiOiBcItCd0LDRgdGC0LDQstC4XCIsXG5cdFx0c3BlY2lmeUhEUGF0aDogXCLQndCw0LLQtdC00LjRgtC1INCl0JQg0L/Rg9GC0LDRmtGDXCIsXG5cdFx0ZW50ZXJZb3VyUHJlZmVycmVkSERQYXRoOiBcItCj0L3QtdGB0LjRgtC1INC20LXRmdC10L3RgyDQttC10ZnQtdC90YMg0KXQlCDQv9GD0YLQsNGa0YMsINCwINC30LDRgtC40Lwg0YHQutC10L3QuNGA0LDRmNGC0LUg0YHQstC1INCw0LrRgtC40LLQvdC1INC90LDQu9C+0LPQtS5cIixcblx0XHRzY2FuOiBcItCh0LrQtdC90LjRgNCw0ZjRgtC1XCIsXG5cdFx0cmV0cnk6IFwi0J/QvtC60YPRiNCw0Zgg0L/QvtC90L7QstC+XCIsXG5cdFx0bGVkZ2VySXNOb3RBdmFpbGFibGU6IFwiTGVkZ2VyINC90LjRmNC1INC00L7RgdGC0YPQv9Cw0L0uXCIsXG5cdFx0YWNjZXNzRGVuaWVkVG9Vc2VMZWRnZXJEZXZpY2U6IFwi0J/RgNC40YHRgtGD0L8g0ZjQtSDQvtC00LHQuNGY0LXQvSDQt9CwINC60L7RgNC40YjRm9C10ZrQtSBMZWRnZXIg0YPRgNC10ZLQsNGY0LBcIixcblx0XHRub0FjY291bnRzRm91bmQ6IFwi0J3QsGzQvtC30Lgg0L3QuNGB0YMg0L/RgNC+0L3QsNGS0LXQvdC4XCIsXG5cdFx0c2VsZWN0WW91ckFjY291bnRzOiBcItCY0LfQsNCx0LXRgNC40YLQtSDQktCw0Ygg0L3QsGzQvtCzXCIsXG5cdFx0Y29ubmVjdGluZzFBY2NvdW50OiBcItCf0L7QstC10LfQsNGC0LggMSDQvdCwbNC+0LNcIixcblx0XHRjYW50RmluZEFueUFjY291bnQ6IFwi0J3QuNGY0LUg0LzQvtCz0YPRm9C1INC/0YDQvtC90LDRm9C4INC90LjRmNC10LTQsNC9INC90LBs0L7QsyDQv9C+0LLQtdC30LDQvSDRgdCwINC+0LLQuNC8IExlZGdlci3QvtC8LiDQndCw0L/RgNCw0LLQuNGC0LUg0L3QvtCy0LggTkVBUiDQvdCwbNC+0LNcIixcblx0XHRvckNvbm5lY3RBbkFub3RoZXJMZWRnZXI6IFwi0LjQu9C4INC/0L7QstC10LbQuNGC0LUg0LTRgNGD0LPQuCBMZWRnZXIuXCIsXG5cdFx0Y29ubmVjdGluZzogXCLQn9C+0LLQtdC30LjQstCw0ZrQtVwiLFxuXHRcdG9mQWNjb3VudHM6IFwi0L3QsGzQvtCz0LBcIixcblx0XHRmYWlsZWRUb0F1dG9tYXRpY2FsbHk6IFwi0JDRg9GC0L7QvNCw0YLRgdC60L4g0L/RgNC+0L3QsNC70LDQttC10ZrQtSBJRC1hINC90LBs0L7Qs9CwINC90LjRmNC1INGD0YHQv9C10LvQvi4g0J3QsNCy0LXQtNC40YLQtSDQs9CwINGA0YPRh9C90L46XCIsXG5cdFx0b3ZlcnZpZXdUaGVMaXN0T2ZBdXRob3JpemVkOiBcItCf0YDQtdCz0LvQtdC00LDRmNGC0LUg0LvQuNGB0YLRgyDQvtCy0LvQsNGI0ZvQtdC90LjRhSDRgNCw0YfRg9C90LAsINC30LDQstGA0YjQuNGC0LUg0L/RgNC40ZjQsNCy0YMg0LrQu9C40LrQvtC8INC90LAg0LTRg9Cz0LzQtSDQuNGB0L/QvtC0LlwiLFxuXHRcdGZpbmlzaDogXCLQl9Cw0LLRgNGI0LhcIlxuXHR9LFxuXHRpbnN0YWxsOiB7XG5cdFx0eW91bGxOZWVkVG9JbnN0YWxsOiBcItCc0L7RgNCw0ZvQtdGC0LUg0LTQsCDQuNC90YHRgtCw0LvQuNGA0LDRgtC1XCIsXG5cdFx0dG9Db250aW51ZUFmdGVySW5zdGFsbGluZzogXCLQt9CwINC90LDRgdGC0LDQstCw0LouINCd0LDQutC+0L0g0LjQvdGB0YLQsNC70LjRgNCw0ZrQsFwiLFxuXHRcdHJlZnJlc2hUaGVQYWdlOiBcItC/0L7QvdC+0LLQviDRg9GH0LjRgtCw0YLQuCDRgdGC0YDQsNC90LjRhtGDLlwiLFxuXHRcdG9wZW46IFwi0J7RgtCy0L7RgNC4XCJcblx0fSxcblx0cXI6IHtcblx0XHRjb3BpZWRUb0NsaXBib2FyZDogXCLQmtC+0L/QuNGA0LDQvdC+INGDINC80LXRktGD0YHQv9GA0LXQvNC90LjQulwiLFxuXHRcdGZhaWxlZFRvQ29weTogXCLQmtC+0L/QuNGA0LDRmtC1INGDINC80LXRktGD0YHQv9GA0LXQvNC90LjQuiDQvdC40ZjQtSDRg9GB0L/QtdC70L5cIixcblx0XHRzY2FuV2l0aFlvdXJNb2JpbGU6IFwi0KHQutC10L3QuNGA0LDRmNGC0LUg0L/QvtC80L7Rm9GDINC80L7QsdC40LvQvdC+0LMg0YPRgNC10ZLQsNGY0LBcIixcblx0XHRjb3B5VG9DbGlwYm9hcmQ6IFwiINCa0L7Qv9C40YDQsNGYINGDINC80LXRktGD0YHQv9GA0LXQvNC90LjQulwiLFxuXHRcdHByZWZlclRoZU9mZmljaWFsOiBcItCf0YDQtdGE0LXRgNC40YDQsNGC0LUg0LfQstCw0L3QuNGH0L3QuCDQtNC40ZjQsNC70L7QsyDQvtC0XCIsXG5cdFx0b3BlbjogXCLQntGC0LLQvtGA0LhcIlxuXHR9LFxuXHR3YWxsZXRUeXBlczoge1xuXHRcdGhhcmR3YXJlOiBcItCl0LDRgNC00LLQtdGA0YHQutC4INC90L7QstGH0LDQvdC40LpcIixcblx0XHRicm93c2VyOiBcItCd0L7QstGH0LDQvdC40Log0L/RgNC10YLRgNCw0LbQuNCy0LDRh9CwLFwiLFxuXHRcdGluamVjdGVkOiBcItCU0L7QtNCw0YLQsNC6INC30LAg0L3QvtCy0YfQsNC90LjQuixcIixcblx0XHRicmlkZ2U6IFwiQnJpZGdlINC90L7QstGH0LDQvdC40LpcIixcblx0XHRtb2JpbGU6IFwi0JzQvtCx0LjQu9C90Lgg0L3QvtCy0YfQsNC90LjQulwiLFxuXHRcdFwiaW5zdGFudC1saW5rXCI6IFwi0JjQvdGB0YLQsNC90YIg0L3QvtCy0YfQsNC90LjQulwiXG5cdH0sXG5cdGV4cG9ydEFjY291bnRzOiB7XG5cdFx0Y2hvb3NlQVdhbGxldDogXCLQmNC30LDQsdC10YDQuNGC0LUg0L3QvtCy0YfQsNC90LjQulwiLFxuXHRcdHRyYW5zZmVyWW91ckFjY291bnRzOiBcItCf0YDQtdC90LXRgdC40YLQtSDRgdCy0L7RmNC1INC90LDQu9C+0LPQtVwiLFxuXHRcdHNlbGVjdEFXYWxsZXQ6IFwi0JjQt9Cw0LHQtdGA0LjRgtC1INC90L7QstGH0LDQvdC40Log0LrQvtGY0Lgg0L7QtNCz0L7QstCw0YDQsCDQstCw0YjQuNC8INC/0L7RgtGA0LXQsdCw0LzQsCDQuCDQutC+0ZjQuCDQv9C+0LTRgNC20LDQstCwINCy0LDRiNC1INC/0L7QstC10LfQsNC90LUg0L3QsNC70L7Qs9C1LlwiLFxuXHRcdHNlbGVjdFlvdXJBY2NvdW50czogXCLQmNC30LDQsdC10YDQuNGC0LUg0LLQsNGI0LUg0L3QsNC70L7Qs9C1XCIsXG5cdFx0YWZ0ZXJEZWNpZGU6IFwi0J3QsNC60L7QvSDRiNGC0L4g0YHQtSDQvtC00LvRg9GH0LjRgtC1INC30LAg0L3QvtCy0YfQsNC90LjQuiwg0LzQvtC20LXRgtC1INC40LfQsNCx0YDQsNGC0Lgg0LrQvtGY0LUg0L3QsNC70L7Qs9C1INC20LXQu9C40YLQtSDQtNCwINC/0YDQtdC90LXRgdC10YLQtS5cIixcblx0XHRkaXNjbGFpbWVyOiBcItCd0LXRm9C10YLQtSDQvNC+0ZvQuCDQtNCwINC/0YDQtdC90LXRgdC10YLQtSDQvdCw0LvQvtCz0LUg0LrQvtGY0Lgg0L3QuNC60LDQtNCwINC90LjRgdGDINCx0LjQu9C4INGE0LjQvdCw0L3RgdC40YDQsNC90Lgg0LjQu9C4INC60L7RgNC40YjRm9C10L3QuCDQvdCwICBORUFSLlwiLFxuXHRcdHdhcm5pbmc6IFwi0YLRgNC10L3Rg9GC0L3QviDQvdC1INC/0L7QtNGA0LbQsNCy0LAg0LjQt9Cy0L7QtyDQvdCw0LvQvtCz0LAuINCY0LfQsNCx0LXRgNC40YLQtSDQtNGA0YPQs9C4INC90L7QstGH0LDQvdC40LouXCIsXG5cdFx0d2FsbGV0VHlwZXM6IHtcblx0XHRcdGhhcmR3YXJlOiBcItCl0LDRgNC00LLQtdGA0YHQutC4INC90L7QstGH0LDQvdC40LpcIixcblx0XHRcdGJyb3dzZXI6IFwi0J3QvtCy0YfQsNC90LjQuiDQv9GA0LXRgtGA0LDQttC40LLQsNGH0LAsXCIsXG5cdFx0XHRpbmplY3RlZDogXCLQlNC+0LTQsNGC0LDQuiDQt9CwINC90L7QstGH0LDQvdC40LosXCIsXG5cdFx0XHRicmlkZ2U6IFwiQnJpZGdlINC90L7QstGH0LDQvdC40LpcIixcblx0XHRcdG1vYmlsZTogXCLQnNC+0LHQuNC70L3QuCDQvdC+0LLRh9Cw0L3QuNC6XCJcblx0XHR9LFxuXHRcdHNlbGVjdEFjY291bnRzOiB7XG5cdFx0XHR0aXRsZTogXCLQmNC30LDQsdC10YDQuNGC0LUg0L3QsNC70L7Qs9C1INC30LAg0L/RgNC10L3QvtGBLlwiLFxuXHRcdFx0YnV0dG9uOiBcItCU0L7QsdC40ZjRgtC1INC/0YDQuNGB0YLRg9C/0L3RgyDRhNGA0LDQt9GDXCIsXG5cdFx0XHRkZXNlbGVjdEFsbDogXCLQn9C+0L3QuNGI0YLQuNGC0LUg0LjQt9Cx0L7RgFwiLFxuXHRcdFx0c2VsZWN0QWxsOiBcItCY0LfQsNCx0LXRgNC40YLQtSDRgdCy0LVcIixcblx0XHRcdHVuYXZhaWxhYmxlOiBcItCi0YDQsNC90YHRhNC10YAg0L3QuNGY0LUg0LTQvtGB0YLRg9C/0LDQvVwiLFxuXHRcdFx0ZXJyb3I6IFwi0J3QsNC70L7QsyDQvdC1INC/0L7RgdGC0L7RmNC4XCIsXG5cdFx0XHR3YXJuaW5nTGVkZ2VyOiBcItCf0L7RgtGA0LXQsdC90LAg0L/QvtC00YDRiNC60LAg0LfQsCBMZWRnZXJcIixcblx0XHRcdG5vQmFsYW5jZTogXCLQndCw0LvQvtCzINC90LjRmNC1INGE0LjQvdCw0L3RgdC40YDQsNC9XCJcblx0XHR9LFxuXHRcdGdldFBhc3NwaHJhc2U6IHtcblx0XHRcdHRpdGxlOiBcItCa0L7Qv9C40YDQsNGYINC/0YDQuNCy0YDQtdC80LXQvdGDINC70L7Qt9C40L3QutGDXCIsXG5cdFx0XHRkZXNjOiBcItCc0L7RgNCw0ZvQtdGC0LUg0LTQsCDRg9C90LXRgdC10YLQtSDQvtCy0YMg0LvQvtC30LjQvdC60YMg0LrQsNC00LAg0L/QvtGH0L3QtdGC0LUg0LTQsCDQuNC30LLQvtC30LjRgtC1INGB0LLQvtGY0LUg0L3QsNC70L7Qs9C1INGDINC00YDRg9Cz0Lgg0L3QvtCy0YfQsNC90LjQui5cIixcblx0XHRcdGJ1dHRvbjogXCLQndCw0YHRgtCw0LLQuNGC0LVcIixcblx0XHRcdGxhYmVsOiBcItCa0LvQuNC60L3QuNGC0LUg0LTQsCDQsdC40YHRgtC1INC60L7Qv9C40YDQsNC70LhcIixcblx0XHRcdGNoZWNrTGFiZWw6IFwi0JrQvtC/0LjRgNCw0L4g0YHQsNC8INC40LvQuCDQt9Cw0L/QuNGB0LDQviDQu9C+0LfQuNC90LrRg1wiXG5cdFx0fSxcblx0XHRjb21wbGV0ZToge1xuXHRcdFx0dGl0bGU6IFwi0JTQvtCy0YDRiNC40YLQtSDRgtGA0LDQvdGB0YTQtdGAXCIsXG5cdFx0XHRkZXNjT25lOiBcItCh0LDQtNCwINGb0LXRgtC1INCx0LjRgtC4INC/0YDQtdGD0YHQvNC10YDQtdC90Lgg0L3QsCDQvdC+0LLRh9Cw0L3QuNC6INC60L7RmNC4INGB0YLQtSDQuNC30LDQsdGA0LDQu9C4INC00LAg0LfQsNCy0YDRiNC40YLQtSDRgtGA0LDQvdGB0YTQtdGALlwiLFxuXHRcdFx0ZGVzY1R3bzogXCLQmtCw0LTQsCDRgdC1INC00LXQviDQv9GA0L7RhtC10YHQsCDRg9Cy0L7Qt9CwINC30LDQstGA0YjQuCDQuNC3INC40LfQsNCx0YDQsNC90L7QsyDQvdC+0LLRh9Cw0L3QuNC60LAsINC/0YDQuNGC0LjRgdC90LjRgtC1INC00YPQs9C80LUg0LTQsCDQt9Cw0LLRgNGI0LjRgtC1INC/0YDQvtGG0LXRgSDQv9GA0LXQvdC+0YHQsC5cIixcblx0XHRcdGJ1dHRvbjogXCLQl9Cw0LLRgNGI0LjRgtC1XCJcblx0XHR9XG5cdH1cbn07XG52YXIgc3IgPSB7XG5cdG1vZGFsOiBtb2RhbFxufTtcblxuY29uc3QgZ2V0TGFuZ3VhZ2UgPSBsYW5ndWFnZUNvZGUgPT4ge1xuICBzd2l0Y2ggKGxhbmd1YWdlQ29kZSkge1xuICAgIGNhc2UgXCJlblwiOlxuICAgICAgcmV0dXJuIGVuO1xuICAgIGNhc2UgXCJlc1wiOlxuICAgICAgcmV0dXJuIGVzO1xuICAgIGNhc2UgXCJ6aFwiOlxuICAgICAgcmV0dXJuIHpoO1xuICAgIGNhc2UgXCJiZ1wiOlxuICAgICAgcmV0dXJuIGJnO1xuICAgIGNhc2UgXCJrb1wiOlxuICAgICAgcmV0dXJuIGtvO1xuICAgIGNhc2UgXCJ2aVwiOlxuICAgICAgcmV0dXJuIHZpO1xuICAgIGNhc2UgXCJoaVwiOlxuICAgICAgcmV0dXJuIGhpO1xuICAgIGNhc2UgXCJhclwiOlxuICAgICAgcmV0dXJuIGFyO1xuICAgIGNhc2UgXCJoclwiOlxuICAgICAgcmV0dXJuIGhyO1xuICAgIGNhc2UgXCJta1wiOlxuICAgICAgcmV0dXJuIG1rO1xuICAgIGNhc2UgXCJzbFwiOlxuICAgICAgcmV0dXJuIHNsO1xuICAgIGNhc2UgXCJzclwiOlxuICAgICAgcmV0dXJuIHNyO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZW47XG4gIH1cbn07XG5sZXQgY2hvc2VuTGFuZztcbmNvbnN0IGFsbG93T25seUxhbmd1YWdlID0gbGFuZ0NvZGUgPT4ge1xuICBjaG9zZW5MYW5nID0gbGFuZ0NvZGU7XG59O1xuLy8gKGkuZSBlbi1DQSByZXR1cm5zIGp1c3QgZW4pXG5jb25zdCBzaG9ydGVuTGFuZ3VhZ2VDb2RlID0gbGFuZyA9PiB7XG4gIHJldHVybiBsYW5nLmluZGV4T2YoXCItXCIpICE9PSAtMSA/IGxhbmcuc3BsaXQoXCItXCIpWzBdIDogbGFuZy5zcGxpdChcIl9cIilbMF07XG59O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmNvbnN0IGZpbmRPYmplY3RQcm9wQnlTdHJpbmdQYXRoID0gKG9iaiwgcHJvcCkgPT4ge1xuICBpZiAoIW9iaikge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG4gIGNvbnN0IF9pbmRleCA9IHByb3AuaW5kZXhPZihcIi5cIik7XG4gIGlmIChfaW5kZXggPiAtMSkge1xuICAgIGNvbnN0IGN1cnJlbnRQcm9wID0gcHJvcC5zdWJzdHJpbmcoMCwgX2luZGV4KTtcbiAgICBjb25zdCBuZXh0UHJvcCA9IHByb3Auc3Vic3RyaW5nKF9pbmRleCArIDEpO1xuICAgIHJldHVybiBmaW5kT2JqZWN0UHJvcEJ5U3RyaW5nUGF0aChvYmpbY3VycmVudFByb3BdLCBuZXh0UHJvcCk7XG4gIH1cbiAgcmV0dXJuIG9ialtwcm9wXTtcbn07XG5jb25zdCB0cmFuc2xhdGUgPSBwYXRoID0+IHtcbiAgbGV0IGJyb3dzZXJMYW5nID0gd2luZG93Lm5hdmlnYXRvci5sYW5ndWFnZXMgPyB3aW5kb3cubmF2aWdhdG9yLmxhbmd1YWdlc1swXSA6IG51bGw7XG4gIGJyb3dzZXJMYW5nID0gYnJvd3NlckxhbmcgfHwgd2luZG93Lm5hdmlnYXRvci5sYW5ndWFnZTtcbiAgY29uc3QgbGFuZ3VhZ2VDb2RlID0gc2hvcnRlbkxhbmd1YWdlQ29kZShjaG9zZW5MYW5nIHx8IGJyb3dzZXJMYW5nKTtcbiAgY29uc3Qgc2VsZWN0ZWRMYW5ndWFnZSA9IGdldExhbmd1YWdlKGxhbmd1YWdlQ29kZSk7XG4gIGNvbnN0IHRleHQgPSBmaW5kT2JqZWN0UHJvcEJ5U3RyaW5nUGF0aChzZWxlY3RlZExhbmd1YWdlLCBwYXRoKTtcbiAgcmV0dXJuIHRleHQgJiYgdHlwZW9mIHRleHQgPT09IFwic3RyaW5nXCIgPyB0ZXh0IDogcGF0aDtcbn07XG5cbmV4cG9ydCB7IEV2ZW50RW1pdHRlciwgYWxsb3dPbmx5TGFuZ3VhZ2UsIGdldEFjdGl2ZUFjY291bnQsIGlzQ3VycmVudEJyb3dzZXJTdXBwb3J0ZWQsIHNlcmlhbGl6ZU5lcDQxMywgc2V0dXBXYWxsZXRTZWxlY3RvciwgdHJhbnNsYXRlLCB2ZXJpZnlGdWxsS2V5QmVsb25nc1RvVXNlciwgdmVyaWZ5U2lnbmF0dXJlLCB3YWl0Rm9yIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@near-wallet-selector/core/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@near-wallet-selector/here-wallet/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@near-wallet-selector/here-wallet/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   setupHereWallet: () => (/* binding */ setupHereWallet)\n/* harmony export */ });\n/* harmony import */ var _here_wallet_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @here-wallet/core */ \"(ssr)/./node_modules/@here-wallet/core/build/index.js\");\n\n\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nvar check = function (it) {\n  return it && it.Math == Math && it;\n};\n\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global$a =\n  // eslint-disable-next-line es-x/no-global-this -- safe\n  check(typeof globalThis == 'object' && globalThis) ||\n  check(typeof window == 'object' && window) ||\n  // eslint-disable-next-line no-restricted-globals -- safe\n  check(typeof self == 'object' && self) ||\n  check(typeof commonjsGlobal == 'object' && commonjsGlobal) ||\n  // eslint-disable-next-line no-new-func -- fallback\n  (function () { return this; })() || Function('return this')();\n\nvar objectGetOwnPropertyDescriptor = {};\n\nvar fails$a = function (exec) {\n  try {\n    return !!exec();\n  } catch (error) {\n    return true;\n  }\n};\n\nvar fails$9 = fails$a;\n\n// Detect IE8's incomplete defineProperty implementation\nvar descriptors = !fails$9(function () {\n  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;\n});\n\nvar fails$8 = fails$a;\n\nvar functionBindNative = !fails$8(function () {\n  // eslint-disable-next-line es-x/no-function-prototype-bind -- safe\n  var test = (function () { /* empty */ }).bind();\n  // eslint-disable-next-line no-prototype-builtins -- safe\n  return typeof test != 'function' || test.hasOwnProperty('prototype');\n});\n\nvar NATIVE_BIND$1 = functionBindNative;\n\nvar call$6 = Function.prototype.call;\n\nvar functionCall = NATIVE_BIND$1 ? call$6.bind(call$6) : function () {\n  return call$6.apply(call$6, arguments);\n};\n\nvar objectPropertyIsEnumerable = {};\n\nvar $propertyIsEnumerable = {}.propertyIsEnumerable;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;\n\n// Nashorn ~ JDK8 bug\nvar NASHORN_BUG = getOwnPropertyDescriptor$1 && !$propertyIsEnumerable.call({ 1: 2 }, 1);\n\n// `Object.prototype.propertyIsEnumerable` method implementation\n// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable\nobjectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n  var descriptor = getOwnPropertyDescriptor$1(this, V);\n  return !!descriptor && descriptor.enumerable;\n} : $propertyIsEnumerable;\n\nvar createPropertyDescriptor$2 = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n\nvar NATIVE_BIND = functionBindNative;\n\nvar FunctionPrototype$1 = Function.prototype;\nvar bind = FunctionPrototype$1.bind;\nvar call$5 = FunctionPrototype$1.call;\nvar uncurryThis$a = NATIVE_BIND && bind.bind(call$5, call$5);\n\nvar functionUncurryThis = NATIVE_BIND ? function (fn) {\n  return fn && uncurryThis$a(fn);\n} : function (fn) {\n  return fn && function () {\n    return call$5.apply(fn, arguments);\n  };\n};\n\nvar uncurryThis$9 = functionUncurryThis;\n\nvar toString$2 = uncurryThis$9({}.toString);\nvar stringSlice = uncurryThis$9(''.slice);\n\nvar classofRaw$1 = function (it) {\n  return stringSlice(toString$2(it), 8, -1);\n};\n\nvar uncurryThis$8 = functionUncurryThis;\nvar fails$7 = fails$a;\nvar classof$2 = classofRaw$1;\n\nvar $Object$3 = Object;\nvar split = uncurryThis$8(''.split);\n\n// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar indexedObject = fails$7(function () {\n  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n  // eslint-disable-next-line no-prototype-builtins -- safe\n  return !$Object$3('z').propertyIsEnumerable(0);\n}) ? function (it) {\n  return classof$2(it) == 'String' ? split(it, '') : $Object$3(it);\n} : $Object$3;\n\nvar $TypeError$5 = TypeError;\n\n// `RequireObjectCoercible` abstract operation\n// https://tc39.es/ecma262/#sec-requireobjectcoercible\nvar requireObjectCoercible$2 = function (it) {\n  if (it == undefined) throw $TypeError$5(\"Can't call method on \" + it);\n  return it;\n};\n\n// toObject with fallback for non-array-like ES3 strings\nvar IndexedObject$1 = indexedObject;\nvar requireObjectCoercible$1 = requireObjectCoercible$2;\n\nvar toIndexedObject$3 = function (it) {\n  return IndexedObject$1(requireObjectCoercible$1(it));\n};\n\n// `IsCallable` abstract operation\n// https://tc39.es/ecma262/#sec-iscallable\nvar isCallable$b = function (argument) {\n  return typeof argument == 'function';\n};\n\nvar isCallable$a = isCallable$b;\n\nvar isObject$5 = function (it) {\n  return typeof it == 'object' ? it !== null : isCallable$a(it);\n};\n\nvar global$9 = global$a;\nvar isCallable$9 = isCallable$b;\n\nvar aFunction = function (argument) {\n  return isCallable$9(argument) ? argument : undefined;\n};\n\nvar getBuiltIn$3 = function (namespace, method) {\n  return arguments.length < 2 ? aFunction(global$9[namespace]) : global$9[namespace] && global$9[namespace][method];\n};\n\nvar uncurryThis$7 = functionUncurryThis;\n\nvar objectIsPrototypeOf = uncurryThis$7({}.isPrototypeOf);\n\nvar getBuiltIn$2 = getBuiltIn$3;\n\nvar engineUserAgent = getBuiltIn$2('navigator', 'userAgent') || '';\n\nvar global$8 = global$a;\nvar userAgent = engineUserAgent;\n\nvar process = global$8.process;\nvar Deno = global$8.Deno;\nvar versions = process && process.versions || Deno && Deno.version;\nvar v8 = versions && versions.v8;\nvar match, version;\n\nif (v8) {\n  match = v8.split('.');\n  // in old Chrome, versions of V8 isn't V8 = Chrome / 10\n  // but their correct versions are not interesting for us\n  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);\n}\n\n// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`\n// so check `userAgent` even if `.v8` exists, but 0\nif (!version && userAgent) {\n  match = userAgent.match(/Edge\\/(\\d+)/);\n  if (!match || match[1] >= 74) {\n    match = userAgent.match(/Chrome\\/(\\d+)/);\n    if (match) version = +match[1];\n  }\n}\n\nvar engineV8Version = version;\n\n/* eslint-disable es-x/no-symbol -- required for testing */\n\nvar V8_VERSION = engineV8Version;\nvar fails$6 = fails$a;\n\n// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- required for testing\nvar nativeSymbol = !!Object.getOwnPropertySymbols && !fails$6(function () {\n  var symbol = Symbol();\n  // Chrome 38 Symbol has incorrect toString conversion\n  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances\n  return !String(symbol) || !(Object(symbol) instanceof Symbol) ||\n    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances\n    !Symbol.sham && V8_VERSION && V8_VERSION < 41;\n});\n\n/* eslint-disable es-x/no-symbol -- required for testing */\n\nvar NATIVE_SYMBOL$1 = nativeSymbol;\n\nvar useSymbolAsUid = NATIVE_SYMBOL$1\n  && !Symbol.sham\n  && typeof Symbol.iterator == 'symbol';\n\nvar getBuiltIn$1 = getBuiltIn$3;\nvar isCallable$8 = isCallable$b;\nvar isPrototypeOf$1 = objectIsPrototypeOf;\nvar USE_SYMBOL_AS_UID$1 = useSymbolAsUid;\n\nvar $Object$2 = Object;\n\nvar isSymbol$2 = USE_SYMBOL_AS_UID$1 ? function (it) {\n  return typeof it == 'symbol';\n} : function (it) {\n  var $Symbol = getBuiltIn$1('Symbol');\n  return isCallable$8($Symbol) && isPrototypeOf$1($Symbol.prototype, $Object$2(it));\n};\n\nvar $String$2 = String;\n\nvar tryToString$1 = function (argument) {\n  try {\n    return $String$2(argument);\n  } catch (error) {\n    return 'Object';\n  }\n};\n\nvar isCallable$7 = isCallable$b;\nvar tryToString = tryToString$1;\n\nvar $TypeError$4 = TypeError;\n\n// `Assert: IsCallable(argument) is true`\nvar aCallable$1 = function (argument) {\n  if (isCallable$7(argument)) return argument;\n  throw $TypeError$4(tryToString(argument) + ' is not a function');\n};\n\nvar aCallable = aCallable$1;\n\n// `GetMethod` abstract operation\n// https://tc39.es/ecma262/#sec-getmethod\nvar getMethod$1 = function (V, P) {\n  var func = V[P];\n  return func == null ? undefined : aCallable(func);\n};\n\nvar call$4 = functionCall;\nvar isCallable$6 = isCallable$b;\nvar isObject$4 = isObject$5;\n\nvar $TypeError$3 = TypeError;\n\n// `OrdinaryToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-ordinarytoprimitive\nvar ordinaryToPrimitive$1 = function (input, pref) {\n  var fn, val;\n  if (pref === 'string' && isCallable$6(fn = input.toString) && !isObject$4(val = call$4(fn, input))) return val;\n  if (isCallable$6(fn = input.valueOf) && !isObject$4(val = call$4(fn, input))) return val;\n  if (pref !== 'string' && isCallable$6(fn = input.toString) && !isObject$4(val = call$4(fn, input))) return val;\n  throw $TypeError$3(\"Can't convert object to primitive value\");\n};\n\nvar shared$3 = {exports: {}};\n\nvar global$7 = global$a;\n\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar defineProperty$2 = Object.defineProperty;\n\nvar defineGlobalProperty$3 = function (key, value) {\n  try {\n    defineProperty$2(global$7, key, { value: value, configurable: true, writable: true });\n  } catch (error) {\n    global$7[key] = value;\n  } return value;\n};\n\nvar global$6 = global$a;\nvar defineGlobalProperty$2 = defineGlobalProperty$3;\n\nvar SHARED = '__core-js_shared__';\nvar store$3 = global$6[SHARED] || defineGlobalProperty$2(SHARED, {});\n\nvar sharedStore = store$3;\n\nvar store$2 = sharedStore;\n\n(shared$3.exports = function (key, value) {\n  return store$2[key] || (store$2[key] = value !== undefined ? value : {});\n})('versions', []).push({\n  version: '3.23.3',\n  mode: 'global',\n  copyright: '© 2014-2022 Denis Pushkarev (zloirock.ru)',\n  license: 'https://github.com/zloirock/core-js/blob/v3.23.3/LICENSE',\n  source: 'https://github.com/zloirock/core-js'\n});\n\nvar requireObjectCoercible = requireObjectCoercible$2;\n\nvar $Object$1 = Object;\n\n// `ToObject` abstract operation\n// https://tc39.es/ecma262/#sec-toobject\nvar toObject$2 = function (argument) {\n  return $Object$1(requireObjectCoercible(argument));\n};\n\nvar uncurryThis$6 = functionUncurryThis;\nvar toObject$1 = toObject$2;\n\nvar hasOwnProperty = uncurryThis$6({}.hasOwnProperty);\n\n// `HasOwnProperty` abstract operation\n// https://tc39.es/ecma262/#sec-hasownproperty\n// eslint-disable-next-line es-x/no-object-hasown -- safe\nvar hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {\n  return hasOwnProperty(toObject$1(it), key);\n};\n\nvar uncurryThis$5 = functionUncurryThis;\n\nvar id = 0;\nvar postfix = Math.random();\nvar toString$1 = uncurryThis$5(1.0.toString);\n\nvar uid$2 = function (key) {\n  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString$1(++id + postfix, 36);\n};\n\nvar global$5 = global$a;\nvar shared$2 = shared$3.exports;\nvar hasOwn$7 = hasOwnProperty_1;\nvar uid$1 = uid$2;\nvar NATIVE_SYMBOL = nativeSymbol;\nvar USE_SYMBOL_AS_UID = useSymbolAsUid;\n\nvar WellKnownSymbolsStore = shared$2('wks');\nvar Symbol$1 = global$5.Symbol;\nvar symbolFor = Symbol$1 && Symbol$1['for'];\nvar createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid$1;\n\nvar wellKnownSymbol$3 = function (name) {\n  if (!hasOwn$7(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == 'string')) {\n    var description = 'Symbol.' + name;\n    if (NATIVE_SYMBOL && hasOwn$7(Symbol$1, name)) {\n      WellKnownSymbolsStore[name] = Symbol$1[name];\n    } else if (USE_SYMBOL_AS_UID && symbolFor) {\n      WellKnownSymbolsStore[name] = symbolFor(description);\n    } else {\n      WellKnownSymbolsStore[name] = createWellKnownSymbol(description);\n    }\n  } return WellKnownSymbolsStore[name];\n};\n\nvar call$3 = functionCall;\nvar isObject$3 = isObject$5;\nvar isSymbol$1 = isSymbol$2;\nvar getMethod = getMethod$1;\nvar ordinaryToPrimitive = ordinaryToPrimitive$1;\nvar wellKnownSymbol$2 = wellKnownSymbol$3;\n\nvar $TypeError$2 = TypeError;\nvar TO_PRIMITIVE = wellKnownSymbol$2('toPrimitive');\n\n// `ToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-toprimitive\nvar toPrimitive$1 = function (input, pref) {\n  if (!isObject$3(input) || isSymbol$1(input)) return input;\n  var exoticToPrim = getMethod(input, TO_PRIMITIVE);\n  var result;\n  if (exoticToPrim) {\n    if (pref === undefined) pref = 'default';\n    result = call$3(exoticToPrim, input, pref);\n    if (!isObject$3(result) || isSymbol$1(result)) return result;\n    throw $TypeError$2(\"Can't convert object to primitive value\");\n  }\n  if (pref === undefined) pref = 'number';\n  return ordinaryToPrimitive(input, pref);\n};\n\nvar toPrimitive = toPrimitive$1;\nvar isSymbol = isSymbol$2;\n\n// `ToPropertyKey` abstract operation\n// https://tc39.es/ecma262/#sec-topropertykey\nvar toPropertyKey$2 = function (argument) {\n  var key = toPrimitive(argument, 'string');\n  return isSymbol(key) ? key : key + '';\n};\n\nvar global$4 = global$a;\nvar isObject$2 = isObject$5;\n\nvar document = global$4.document;\n// typeof document.createElement is 'object' in old IE\nvar EXISTS$1 = isObject$2(document) && isObject$2(document.createElement);\n\nvar documentCreateElement = function (it) {\n  return EXISTS$1 ? document.createElement(it) : {};\n};\n\nvar DESCRIPTORS$7 = descriptors;\nvar fails$5 = fails$a;\nvar createElement = documentCreateElement;\n\n// Thanks to IE8 for its funny defineProperty\nvar ie8DomDefine = !DESCRIPTORS$7 && !fails$5(function () {\n  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n  return Object.defineProperty(createElement('div'), 'a', {\n    get: function () { return 7; }\n  }).a != 7;\n});\n\nvar DESCRIPTORS$6 = descriptors;\nvar call$2 = functionCall;\nvar propertyIsEnumerableModule$1 = objectPropertyIsEnumerable;\nvar createPropertyDescriptor$1 = createPropertyDescriptor$2;\nvar toIndexedObject$2 = toIndexedObject$3;\nvar toPropertyKey$1 = toPropertyKey$2;\nvar hasOwn$6 = hasOwnProperty_1;\nvar IE8_DOM_DEFINE$1 = ie8DomDefine;\n\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;\n\n// `Object.getOwnPropertyDescriptor` method\n// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor\nobjectGetOwnPropertyDescriptor.f = DESCRIPTORS$6 ? $getOwnPropertyDescriptor$1 : function getOwnPropertyDescriptor(O, P) {\n  O = toIndexedObject$2(O);\n  P = toPropertyKey$1(P);\n  if (IE8_DOM_DEFINE$1) try {\n    return $getOwnPropertyDescriptor$1(O, P);\n  } catch (error) { /* empty */ }\n  if (hasOwn$6(O, P)) return createPropertyDescriptor$1(!call$2(propertyIsEnumerableModule$1.f, O, P), O[P]);\n};\n\nvar objectDefineProperty = {};\n\nvar DESCRIPTORS$5 = descriptors;\nvar fails$4 = fails$a;\n\n// V8 ~ Chrome 36-\n// https://bugs.chromium.org/p/v8/issues/detail?id=3334\nvar v8PrototypeDefineBug = DESCRIPTORS$5 && fails$4(function () {\n  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n  return Object.defineProperty(function () { /* empty */ }, 'prototype', {\n    value: 42,\n    writable: false\n  }).prototype != 42;\n});\n\nvar isObject$1 = isObject$5;\n\nvar $String$1 = String;\nvar $TypeError$1 = TypeError;\n\n// `Assert: Type(argument) is Object`\nvar anObject$4 = function (argument) {\n  if (isObject$1(argument)) return argument;\n  throw $TypeError$1($String$1(argument) + ' is not an object');\n};\n\nvar DESCRIPTORS$4 = descriptors;\nvar IE8_DOM_DEFINE = ie8DomDefine;\nvar V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;\nvar anObject$3 = anObject$4;\nvar toPropertyKey = toPropertyKey$2;\n\nvar $TypeError = TypeError;\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar $defineProperty = Object.defineProperty;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar ENUMERABLE = 'enumerable';\nvar CONFIGURABLE$1 = 'configurable';\nvar WRITABLE = 'writable';\n\n// `Object.defineProperty` method\n// https://tc39.es/ecma262/#sec-object.defineproperty\nobjectDefineProperty.f = DESCRIPTORS$4 ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {\n  anObject$3(O);\n  P = toPropertyKey(P);\n  anObject$3(Attributes);\n  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {\n    var current = $getOwnPropertyDescriptor(O, P);\n    if (current && current[WRITABLE]) {\n      O[P] = Attributes.value;\n      Attributes = {\n        configurable: CONFIGURABLE$1 in Attributes ? Attributes[CONFIGURABLE$1] : current[CONFIGURABLE$1],\n        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],\n        writable: false\n      };\n    }\n  } return $defineProperty(O, P, Attributes);\n} : $defineProperty : function defineProperty(O, P, Attributes) {\n  anObject$3(O);\n  P = toPropertyKey(P);\n  anObject$3(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return $defineProperty(O, P, Attributes);\n  } catch (error) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw $TypeError('Accessors not supported');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n\nvar DESCRIPTORS$3 = descriptors;\nvar definePropertyModule$2 = objectDefineProperty;\nvar createPropertyDescriptor = createPropertyDescriptor$2;\n\nvar createNonEnumerableProperty$2 = DESCRIPTORS$3 ? function (object, key, value) {\n  return definePropertyModule$2.f(object, key, createPropertyDescriptor(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n\nvar makeBuiltIn$2 = {exports: {}};\n\nvar DESCRIPTORS$2 = descriptors;\nvar hasOwn$5 = hasOwnProperty_1;\n\nvar FunctionPrototype = Function.prototype;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar getDescriptor = DESCRIPTORS$2 && Object.getOwnPropertyDescriptor;\n\nvar EXISTS = hasOwn$5(FunctionPrototype, 'name');\n// additional protection from minified / mangled / dropped function names\nvar PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';\nvar CONFIGURABLE = EXISTS && (!DESCRIPTORS$2 || (DESCRIPTORS$2 && getDescriptor(FunctionPrototype, 'name').configurable));\n\nvar functionName = {\n  EXISTS: EXISTS,\n  PROPER: PROPER,\n  CONFIGURABLE: CONFIGURABLE\n};\n\nvar uncurryThis$4 = functionUncurryThis;\nvar isCallable$5 = isCallable$b;\nvar store$1 = sharedStore;\n\nvar functionToString = uncurryThis$4(Function.toString);\n\n// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper\nif (!isCallable$5(store$1.inspectSource)) {\n  store$1.inspectSource = function (it) {\n    return functionToString(it);\n  };\n}\n\nvar inspectSource$2 = store$1.inspectSource;\n\nvar global$3 = global$a;\nvar isCallable$4 = isCallable$b;\nvar inspectSource$1 = inspectSource$2;\n\nvar WeakMap$1 = global$3.WeakMap;\n\nvar nativeWeakMap = isCallable$4(WeakMap$1) && /native code/.test(inspectSource$1(WeakMap$1));\n\nvar shared$1 = shared$3.exports;\nvar uid = uid$2;\n\nvar keys = shared$1('keys');\n\nvar sharedKey$1 = function (key) {\n  return keys[key] || (keys[key] = uid(key));\n};\n\nvar hiddenKeys$3 = {};\n\nvar NATIVE_WEAK_MAP = nativeWeakMap;\nvar global$2 = global$a;\nvar uncurryThis$3 = functionUncurryThis;\nvar isObject = isObject$5;\nvar createNonEnumerableProperty$1 = createNonEnumerableProperty$2;\nvar hasOwn$4 = hasOwnProperty_1;\nvar shared = sharedStore;\nvar sharedKey = sharedKey$1;\nvar hiddenKeys$2 = hiddenKeys$3;\n\nvar OBJECT_ALREADY_INITIALIZED = 'Object already initialized';\nvar TypeError$1 = global$2.TypeError;\nvar WeakMap = global$2.WeakMap;\nvar set, get, has;\n\nvar enforce = function (it) {\n  return has(it) ? get(it) : set(it, {});\n};\n\nvar getterFor = function (TYPE) {\n  return function (it) {\n    var state;\n    if (!isObject(it) || (state = get(it)).type !== TYPE) {\n      throw TypeError$1('Incompatible receiver, ' + TYPE + ' required');\n    } return state;\n  };\n};\n\nif (NATIVE_WEAK_MAP || shared.state) {\n  var store = shared.state || (shared.state = new WeakMap());\n  var wmget = uncurryThis$3(store.get);\n  var wmhas = uncurryThis$3(store.has);\n  var wmset = uncurryThis$3(store.set);\n  set = function (it, metadata) {\n    if (wmhas(store, it)) throw new TypeError$1(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    wmset(store, it, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return wmget(store, it) || {};\n  };\n  has = function (it) {\n    return wmhas(store, it);\n  };\n} else {\n  var STATE = sharedKey('state');\n  hiddenKeys$2[STATE] = true;\n  set = function (it, metadata) {\n    if (hasOwn$4(it, STATE)) throw new TypeError$1(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    createNonEnumerableProperty$1(it, STATE, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return hasOwn$4(it, STATE) ? it[STATE] : {};\n  };\n  has = function (it) {\n    return hasOwn$4(it, STATE);\n  };\n}\n\nvar internalState = {\n  set: set,\n  get: get,\n  has: has,\n  enforce: enforce,\n  getterFor: getterFor\n};\n\nvar fails$3 = fails$a;\nvar isCallable$3 = isCallable$b;\nvar hasOwn$3 = hasOwnProperty_1;\nvar DESCRIPTORS$1 = descriptors;\nvar CONFIGURABLE_FUNCTION_NAME = functionName.CONFIGURABLE;\nvar inspectSource = inspectSource$2;\nvar InternalStateModule = internalState;\n\nvar enforceInternalState = InternalStateModule.enforce;\nvar getInternalState = InternalStateModule.get;\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar defineProperty$1 = Object.defineProperty;\n\nvar CONFIGURABLE_LENGTH = DESCRIPTORS$1 && !fails$3(function () {\n  return defineProperty$1(function () { /* empty */ }, 'length', { value: 8 }).length !== 8;\n});\n\nvar TEMPLATE = String(String).split('String');\n\nvar makeBuiltIn$1 = makeBuiltIn$2.exports = function (value, name, options) {\n  if (String(name).slice(0, 7) === 'Symbol(') {\n    name = '[' + String(name).replace(/^Symbol\\(([^)]*)\\)/, '$1') + ']';\n  }\n  if (options && options.getter) name = 'get ' + name;\n  if (options && options.setter) name = 'set ' + name;\n  if (!hasOwn$3(value, 'name') || (CONFIGURABLE_FUNCTION_NAME && value.name !== name)) {\n    if (DESCRIPTORS$1) defineProperty$1(value, 'name', { value: name, configurable: true });\n    else value.name = name;\n  }\n  if (CONFIGURABLE_LENGTH && options && hasOwn$3(options, 'arity') && value.length !== options.arity) {\n    defineProperty$1(value, 'length', { value: options.arity });\n  }\n  try {\n    if (options && hasOwn$3(options, 'constructor') && options.constructor) {\n      if (DESCRIPTORS$1) defineProperty$1(value, 'prototype', { writable: false });\n    // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable\n    } else if (value.prototype) value.prototype = undefined;\n  } catch (error) { /* empty */ }\n  var state = enforceInternalState(value);\n  if (!hasOwn$3(state, 'source')) {\n    state.source = TEMPLATE.join(typeof name == 'string' ? name : '');\n  } return value;\n};\n\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n// eslint-disable-next-line no-extend-native -- required\nFunction.prototype.toString = makeBuiltIn$1(function toString() {\n  return isCallable$3(this) && getInternalState(this).source || inspectSource(this);\n}, 'toString');\n\nvar isCallable$2 = isCallable$b;\nvar definePropertyModule$1 = objectDefineProperty;\nvar makeBuiltIn = makeBuiltIn$2.exports;\nvar defineGlobalProperty$1 = defineGlobalProperty$3;\n\nvar defineBuiltIn$2 = function (O, key, value, options) {\n  if (!options) options = {};\n  var simple = options.enumerable;\n  var name = options.name !== undefined ? options.name : key;\n  if (isCallable$2(value)) makeBuiltIn(value, name, options);\n  if (options.global) {\n    if (simple) O[key] = value;\n    else defineGlobalProperty$1(key, value);\n  } else {\n    try {\n      if (!options.unsafe) delete O[key];\n      else if (O[key]) simple = true;\n    } catch (error) { /* empty */ }\n    if (simple) O[key] = value;\n    else definePropertyModule$1.f(O, key, {\n      value: value,\n      enumerable: false,\n      configurable: !options.nonConfigurable,\n      writable: !options.nonWritable\n    });\n  } return O;\n};\n\nvar objectGetOwnPropertyNames = {};\n\nvar ceil = Math.ceil;\nvar floor = Math.floor;\n\n// `Math.trunc` method\n// https://tc39.es/ecma262/#sec-math.trunc\n// eslint-disable-next-line es-x/no-math-trunc -- safe\nvar mathTrunc = Math.trunc || function trunc(x) {\n  var n = +x;\n  return (n > 0 ? floor : ceil)(n);\n};\n\nvar trunc = mathTrunc;\n\n// `ToIntegerOrInfinity` abstract operation\n// https://tc39.es/ecma262/#sec-tointegerorinfinity\nvar toIntegerOrInfinity$2 = function (argument) {\n  var number = +argument;\n  // eslint-disable-next-line no-self-compare -- NaN check\n  return number !== number || number === 0 ? 0 : trunc(number);\n};\n\nvar toIntegerOrInfinity$1 = toIntegerOrInfinity$2;\n\nvar max = Math.max;\nvar min$1 = Math.min;\n\n// Helper for a popular repeating case of the spec:\n// Let integer be ? ToInteger(index).\n// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).\nvar toAbsoluteIndex$1 = function (index, length) {\n  var integer = toIntegerOrInfinity$1(index);\n  return integer < 0 ? max(integer + length, 0) : min$1(integer, length);\n};\n\nvar toIntegerOrInfinity = toIntegerOrInfinity$2;\n\nvar min = Math.min;\n\n// `ToLength` abstract operation\n// https://tc39.es/ecma262/#sec-tolength\nvar toLength$1 = function (argument) {\n  return argument > 0 ? min(toIntegerOrInfinity(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n};\n\nvar toLength = toLength$1;\n\n// `LengthOfArrayLike` abstract operation\n// https://tc39.es/ecma262/#sec-lengthofarraylike\nvar lengthOfArrayLike$1 = function (obj) {\n  return toLength(obj.length);\n};\n\nvar toIndexedObject$1 = toIndexedObject$3;\nvar toAbsoluteIndex = toAbsoluteIndex$1;\nvar lengthOfArrayLike = lengthOfArrayLike$1;\n\n// `Array.prototype.{ indexOf, includes }` methods implementation\nvar createMethod = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIndexedObject$1($this);\n    var length = lengthOfArrayLike(O);\n    var index = toAbsoluteIndex(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare -- NaN check\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare -- NaN check\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) {\n      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\nvar arrayIncludes = {\n  // `Array.prototype.includes` method\n  // https://tc39.es/ecma262/#sec-array.prototype.includes\n  includes: createMethod(true),\n  // `Array.prototype.indexOf` method\n  // https://tc39.es/ecma262/#sec-array.prototype.indexof\n  indexOf: createMethod(false)\n};\n\nvar uncurryThis$2 = functionUncurryThis;\nvar hasOwn$2 = hasOwnProperty_1;\nvar toIndexedObject = toIndexedObject$3;\nvar indexOf = arrayIncludes.indexOf;\nvar hiddenKeys$1 = hiddenKeys$3;\n\nvar push = uncurryThis$2([].push);\n\nvar objectKeysInternal = function (object, names) {\n  var O = toIndexedObject(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) !hasOwn$2(hiddenKeys$1, key) && hasOwn$2(O, key) && push(result, key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (hasOwn$2(O, key = names[i++])) {\n    ~indexOf(result, key) || push(result, key);\n  }\n  return result;\n};\n\n// IE8- don't enum bug keys\nvar enumBugKeys$2 = [\n  'constructor',\n  'hasOwnProperty',\n  'isPrototypeOf',\n  'propertyIsEnumerable',\n  'toLocaleString',\n  'toString',\n  'valueOf'\n];\n\nvar internalObjectKeys$1 = objectKeysInternal;\nvar enumBugKeys$1 = enumBugKeys$2;\n\nvar hiddenKeys = enumBugKeys$1.concat('length', 'prototype');\n\n// `Object.getOwnPropertyNames` method\n// https://tc39.es/ecma262/#sec-object.getownpropertynames\n// eslint-disable-next-line es-x/no-object-getownpropertynames -- safe\nobjectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return internalObjectKeys$1(O, hiddenKeys);\n};\n\nvar objectGetOwnPropertySymbols = {};\n\n// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- safe\nobjectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;\n\nvar getBuiltIn = getBuiltIn$3;\nvar uncurryThis$1 = functionUncurryThis;\nvar getOwnPropertyNamesModule = objectGetOwnPropertyNames;\nvar getOwnPropertySymbolsModule$1 = objectGetOwnPropertySymbols;\nvar anObject$2 = anObject$4;\n\nvar concat$1 = uncurryThis$1([].concat);\n\n// all object keys, includes non-enumerable and symbols\nvar ownKeys$1 = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {\n  var keys = getOwnPropertyNamesModule.f(anObject$2(it));\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule$1.f;\n  return getOwnPropertySymbols ? concat$1(keys, getOwnPropertySymbols(it)) : keys;\n};\n\nvar hasOwn$1 = hasOwnProperty_1;\nvar ownKeys = ownKeys$1;\nvar getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;\nvar definePropertyModule = objectDefineProperty;\n\nvar copyConstructorProperties$1 = function (target, source, exceptions) {\n  var keys = ownKeys(source);\n  var defineProperty = definePropertyModule.f;\n  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    if (!hasOwn$1(target, key) && !(exceptions && hasOwn$1(exceptions, key))) {\n      defineProperty(target, key, getOwnPropertyDescriptor(source, key));\n    }\n  }\n};\n\nvar fails$2 = fails$a;\nvar isCallable$1 = isCallable$b;\n\nvar replacement = /#|\\.prototype\\./;\n\nvar isForced$1 = function (feature, detection) {\n  var value = data[normalize(feature)];\n  return value == POLYFILL ? true\n    : value == NATIVE ? false\n    : isCallable$1(detection) ? fails$2(detection)\n    : !!detection;\n};\n\nvar normalize = isForced$1.normalize = function (string) {\n  return String(string).replace(replacement, '.').toLowerCase();\n};\n\nvar data = isForced$1.data = {};\nvar NATIVE = isForced$1.NATIVE = 'N';\nvar POLYFILL = isForced$1.POLYFILL = 'P';\n\nvar isForced_1 = isForced$1;\n\nvar global$1 = global$a;\nvar getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;\nvar createNonEnumerableProperty = createNonEnumerableProperty$2;\nvar defineBuiltIn$1 = defineBuiltIn$2;\nvar defineGlobalProperty = defineGlobalProperty$3;\nvar copyConstructorProperties = copyConstructorProperties$1;\nvar isForced = isForced_1;\n\n/*\n  options.target         - name of the target object\n  options.global         - target is the global object\n  options.stat           - export as static methods of target\n  options.proto          - export as prototype methods of target\n  options.real           - real prototype method for the `pure` version\n  options.forced         - export even if the native feature is available\n  options.bind           - bind methods to the target, required for the `pure` version\n  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version\n  options.unsafe         - use the simple assignment of property instead of delete + defineProperty\n  options.sham           - add a flag to not completely full polyfills\n  options.enumerable     - export as enumerable property\n  options.dontCallGetSet - prevent calling a getter on target\n  options.name           - the .name of the function if it does not match the key\n*/\nvar _export = function (options, source) {\n  var TARGET = options.target;\n  var GLOBAL = options.global;\n  var STATIC = options.stat;\n  var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n  if (GLOBAL) {\n    target = global$1;\n  } else if (STATIC) {\n    target = global$1[TARGET] || defineGlobalProperty(TARGET, {});\n  } else {\n    target = (global$1[TARGET] || {}).prototype;\n  }\n  if (target) for (key in source) {\n    sourceProperty = source[key];\n    if (options.dontCallGetSet) {\n      descriptor = getOwnPropertyDescriptor(target, key);\n      targetProperty = descriptor && descriptor.value;\n    } else targetProperty = target[key];\n    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);\n    // contained in target\n    if (!FORCED && targetProperty !== undefined) {\n      if (typeof sourceProperty == typeof targetProperty) continue;\n      copyConstructorProperties(sourceProperty, targetProperty);\n    }\n    // add a flag to not completely full polyfills\n    if (options.sham || (targetProperty && targetProperty.sham)) {\n      createNonEnumerableProperty(sourceProperty, 'sham', true);\n    }\n    defineBuiltIn$1(target, key, sourceProperty, options);\n  }\n};\n\nvar internalObjectKeys = objectKeysInternal;\nvar enumBugKeys = enumBugKeys$2;\n\n// `Object.keys` method\n// https://tc39.es/ecma262/#sec-object.keys\n// eslint-disable-next-line es-x/no-object-keys -- safe\nvar objectKeys$1 = Object.keys || function keys(O) {\n  return internalObjectKeys(O, enumBugKeys);\n};\n\nvar DESCRIPTORS = descriptors;\nvar uncurryThis = functionUncurryThis;\nvar call$1 = functionCall;\nvar fails$1 = fails$a;\nvar objectKeys = objectKeys$1;\nvar getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;\nvar propertyIsEnumerableModule = objectPropertyIsEnumerable;\nvar toObject = toObject$2;\nvar IndexedObject = indexedObject;\n\n// eslint-disable-next-line es-x/no-object-assign -- safe\nvar $assign = Object.assign;\n// eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\nvar defineProperty = Object.defineProperty;\nvar concat = uncurryThis([].concat);\n\n// `Object.assign` method\n// https://tc39.es/ecma262/#sec-object.assign\nvar objectAssign = !$assign || fails$1(function () {\n  // should have correct order of operations (Edge bug)\n  if (DESCRIPTORS && $assign({ b: 1 }, $assign(defineProperty({}, 'a', {\n    enumerable: true,\n    get: function () {\n      defineProperty(this, 'b', {\n        value: 3,\n        enumerable: false\n      });\n    }\n  }), { b: 2 })).b !== 1) return true;\n  // should work with symbols and should have deterministic property order (V8 bug)\n  var A = {};\n  var B = {};\n  // eslint-disable-next-line es-x/no-symbol -- safe\n  var symbol = Symbol();\n  var alphabet = 'abcdefghijklmnopqrst';\n  A[symbol] = 7;\n  alphabet.split('').forEach(function (chr) { B[chr] = chr; });\n  return $assign({}, A)[symbol] != 7 || objectKeys($assign({}, B)).join('') != alphabet;\n}) ? function assign(target, source) { // eslint-disable-line no-unused-vars -- required for `.length`\n  var T = toObject(target);\n  var argumentsLength = arguments.length;\n  var index = 1;\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n  var propertyIsEnumerable = propertyIsEnumerableModule.f;\n  while (argumentsLength > index) {\n    var S = IndexedObject(arguments[index++]);\n    var keys = getOwnPropertySymbols ? concat(objectKeys(S), getOwnPropertySymbols(S)) : objectKeys(S);\n    var length = keys.length;\n    var j = 0;\n    var key;\n    while (length > j) {\n      key = keys[j++];\n      if (!DESCRIPTORS || call$1(propertyIsEnumerable, S, key)) T[key] = S[key];\n    }\n  } return T;\n} : $assign;\n\nvar $ = _export;\nvar assign = objectAssign;\n\n// `Object.assign` method\n// https://tc39.es/ecma262/#sec-object.assign\n// eslint-disable-next-line es-x/no-object-assign -- required for testing\n$({ target: 'Object', stat: true, arity: 2, forced: Object.assign !== assign }, {\n  assign: assign\n});\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\n\nvar wellKnownSymbol$1 = wellKnownSymbol$3;\n\nvar TO_STRING_TAG$1 = wellKnownSymbol$1('toStringTag');\nvar test = {};\n\ntest[TO_STRING_TAG$1] = 'z';\n\nvar toStringTagSupport = String(test) === '[object z]';\n\nvar TO_STRING_TAG_SUPPORT = toStringTagSupport;\nvar isCallable = isCallable$b;\nvar classofRaw = classofRaw$1;\nvar wellKnownSymbol = wellKnownSymbol$3;\n\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\nvar $Object = Object;\n\n// ES3 wrong here\nvar CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function (it, key) {\n  try {\n    return it[key];\n  } catch (error) { /* empty */ }\n};\n\n// getting tag from ES6+ `Object.prototype.toString`\nvar classof$1 = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {\n  var O, tag, result;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == 'string' ? tag\n    // builtinTag case\n    : CORRECT_ARGUMENTS ? classofRaw(O)\n    // ES3 arguments fallback\n    : (result = classofRaw(O)) == 'Object' && isCallable(O.callee) ? 'Arguments' : result;\n};\n\nvar classof = classof$1;\n\nvar $String = String;\n\nvar toString = function (argument) {\n  if (classof(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');\n  return $String(argument);\n};\n\nvar anObject$1 = anObject$4;\n\n// `RegExp.prototype.flags` getter implementation\n// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags\nvar regexpFlags = function () {\n  var that = anObject$1(this);\n  var result = '';\n  if (that.hasIndices) result += 'd';\n  if (that.global) result += 'g';\n  if (that.ignoreCase) result += 'i';\n  if (that.multiline) result += 'm';\n  if (that.dotAll) result += 's';\n  if (that.unicode) result += 'u';\n  if (that.unicodeSets) result += 'v';\n  if (that.sticky) result += 'y';\n  return result;\n};\n\nvar call = functionCall;\nvar hasOwn = hasOwnProperty_1;\nvar isPrototypeOf = objectIsPrototypeOf;\nvar regExpFlags = regexpFlags;\n\nvar RegExpPrototype$1 = RegExp.prototype;\n\nvar regexpGetFlags = function (R) {\n  var flags = R.flags;\n  return flags === undefined && !('flags' in RegExpPrototype$1) && !hasOwn(R, 'flags') && isPrototypeOf(RegExpPrototype$1, R)\n    ? call(regExpFlags, R) : flags;\n};\n\nvar PROPER_FUNCTION_NAME = functionName.PROPER;\nvar defineBuiltIn = defineBuiltIn$2;\nvar anObject = anObject$4;\nvar $toString = toString;\nvar fails = fails$a;\nvar getRegExpFlags = regexpGetFlags;\n\nvar TO_STRING = 'toString';\nvar RegExpPrototype = RegExp.prototype;\nvar n$ToString = RegExpPrototype[TO_STRING];\n\nvar NOT_GENERIC = fails(function () { return n$ToString.call({ source: 'a', flags: 'b' }) != '/a/b'; });\n// FF44- RegExp#toString has a wrong name\nvar INCORRECT_NAME = PROPER_FUNCTION_NAME && n$ToString.name != TO_STRING;\n\n// `RegExp.prototype.toString` method\n// https://tc39.es/ecma262/#sec-regexp.prototype.tostring\nif (NOT_GENERIC || INCORRECT_NAME) {\n  defineBuiltIn(RegExp.prototype, TO_STRING, function toString() {\n    var R = anObject(this);\n    var pattern = $toString(R.source);\n    var flags = $toString(getRegExpFlags(R));\n    return '/' + pattern + '/' + flags;\n  }, { unsafe: true });\n}\n\nconst initHereWallet = config => __awaiter(void 0, void 0, void 0, function* () {\n  const {\n    store,\n    logger,\n    emitter,\n    options,\n    defaultProvider,\n    defaultStrategy\n  } = config;\n  const here = new _here_wallet_core__WEBPACK_IMPORTED_MODULE_0__.HereWallet({\n    networkId: options.network.networkId,\n    nodeUrl: options.network.nodeUrl,\n    defaultProvider,\n    defaultStrategy\n  });\n  function getAccounts() {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.log(\"HereWallet:getAccounts\");\n      const accountIds = yield here.getAccounts();\n      const accounts = [];\n      for (let i = 0; i < accountIds.length; i++) {\n        accounts.push({\n          accountId: accountIds[i],\n          publicKey: (yield here.signer.getPublicKey(accountIds[i], options.network.networkId)).toString()\n        });\n      }\n      return accounts;\n    });\n  }\n  return {\n    get networkId() {\n      return here.networkId;\n    },\n    buildImportAccountsUrl() {\n      return `https://my.herewallet.app/import?network=${options.network.networkId}`;\n    },\n    account(id) {\n      return __awaiter(this, void 0, void 0, function* () {\n        logger.log(\"HereWallet:account\");\n        return yield here.account(id);\n      });\n    },\n    switchAccount(id) {\n      return __awaiter(this, void 0, void 0, function* () {\n        logger.log(\"HereWallet:switchAccount\");\n        yield here.switchAccount(id);\n      });\n    },\n    getAccountId() {\n      return __awaiter(this, void 0, void 0, function* () {\n        logger.log(\"HereWallet:getAccountId\");\n        return yield here.getAccountId();\n      });\n    },\n    isSignedIn() {\n      return __awaiter(this, void 0, void 0, function* () {\n        logger.log(\"HereWallet:isSignedIn\");\n        return yield here.isSignedIn();\n      });\n    },\n    signIn(data) {\n      var _a;\n      return __awaiter(this, void 0, void 0, function* () {\n        logger.log(\"HereWallet:signIn\");\n        const isInjected = yield _here_wallet_core__WEBPACK_IMPORTED_MODULE_0__.waitInjectedHereWallet;\n        if (!isInjected) {\n          const contractId = data.contractId !== \"\" ? data.contractId : undefined;\n          yield here.signIn(Object.assign(Object.assign({}, data), {\n            contractId: contractId\n          }));\n        }\n        emitter.emit(\"signedIn\", {\n          contractId: data.contractId,\n          methodNames: (_a = data.methodNames) !== null && _a !== void 0 ? _a : [],\n          accounts: yield getAccounts()\n        });\n        return yield getAccounts();\n      });\n    },\n    getHereBalance() {\n      return __awaiter(this, void 0, void 0, function* () {\n        logger.log(\"HereWallet:getHereBalance\");\n        return yield here.getHereBalance();\n      });\n    },\n    getAvailableBalance() {\n      return __awaiter(this, void 0, void 0, function* () {\n        logger.log(\"HereWallet:getAvailableBalance\");\n        return yield here.getAvailableBalance();\n      });\n    },\n    signOut() {\n      return __awaiter(this, void 0, void 0, function* () {\n        logger.log(\"HereWallet:signOut\");\n        yield here.signOut();\n      });\n    },\n    getAccounts() {\n      return __awaiter(this, void 0, void 0, function* () {\n        return getAccounts();\n      });\n    },\n    signAndSendTransaction(data) {\n      return __awaiter(this, void 0, void 0, function* () {\n        logger.log(\"HereWallet:signAndSendTransaction\", data);\n        const {\n          contract\n        } = store.getState();\n        return yield here.signAndSendTransaction(Object.assign({\n          receiverId: contract === null || contract === void 0 ? void 0 : contract.contractId\n        }, data));\n      });\n    },\n    verifyOwner() {\n      return __awaiter(this, void 0, void 0, function* () {\n        throw Error(\"HereWallet:verifyOwner is deprecated, use signMessage method with implementation NEP0413 Standard\");\n      });\n    },\n    signMessage(data) {\n      return __awaiter(this, void 0, void 0, function* () {\n        logger.log(\"HereWallet:signMessage\", data);\n        return yield here.signMessage(data);\n      });\n    },\n    signAndSendTransactions(data) {\n      return __awaiter(this, void 0, void 0, function* () {\n        logger.log(\"HereWallet:signAndSendTransactions\", data);\n        return yield here.signAndSendTransactions(data);\n      });\n    }\n  };\n});\n\nvar icon = \"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIHZpZXdCb3g9IjAgMCA0MCA0MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xOS43MzM1IDExLjY4MzFMMjEuNzA4OSA4TDI0LjI5ODMgMTYuNjc2NkwyMC40MTYgMTQuOTIxNUwxOS43MzM1IDExLjY4MzFaTTUuNzYzODggMTUuNTQwOUwzLjc1NTYyIDE5LjE2MjFMOS44OTYwNSAyMi4xNjYxTDE4LjM0NzMgMjEuNTgyOEw1Ljc2Mzg4IDE1LjU0MDlaTTQuNjQ0NjQgMjIuMzY5NEwyLjY0ODY1IDI1Ljk3MTNMMTQuOTA4MyAzMi4wNTc1TDM1LjMzODggMzAuODE3NEwzNy4zMzQ4IDI3LjIxNTRMMTYuOTA0MyAyOC40NTU3TDQuNjQ0NjQgMjIuMzY5NFoiIGZpbGw9IiMyQzMwMzQiLz4KPHBhdGggZD0iTTM3LjMzNTkgMjcuMjE1N0wxNi45MTEyIDI4LjQ1NjFMNC41NDYzMyAyMi4zNTU0TDE3LjkzNTggMjEuNTQ1M0w1Ljc2Mzg3IDE1LjU0MDlMMTEuNzQxIDEwLjQ3ODZMMjQuMTQwMSAxNi41NzYzTDIxLjcwOSA4TDMzLjU1NyAxMy44MUwzNy4zMzU5IDI3LjIxNTdaIiBmaWxsPSIjRkRCRjFDIi8+Cjwvc3ZnPgo=\";\n\nfunction setupHereWallet({\n  deprecated = false,\n  iconUrl = icon,\n  defaultStrategy,\n  defaultProvider\n} = {}) {\n  return () => __awaiter(this, void 0, void 0, function* () {\n    const isInjected = yield _here_wallet_core__WEBPACK_IMPORTED_MODULE_0__.waitInjectedHereWallet;\n    return {\n      id: \"here-wallet\",\n      type: \"injected\",\n      metadata: {\n        name: \"Here Wallet\",\n        description: \"Mobile wallet for NEAR Protocol\",\n        useUrlAccountImport: true,\n        downloadUrl: \"https://herewallet.app\",\n        topLevelInjected: isInjected != null,\n        iconUrl,\n        deprecated,\n        available: true\n      },\n      init: config => initHereWallet(Object.assign(Object.assign({}, config), {\n        defaultStrategy,\n        defaultProvider\n      }))\n    };\n  });\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5lYXItd2FsbGV0LXNlbGVjdG9yL2hlcmUtd2FsbGV0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXVFOztBQUV2RTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGNBQWM7O0FBRS9COztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLE9BQU8sbUJBQW1CLGFBQWE7QUFDeEUsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLGFBQWE7QUFDekM7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0EsOEVBQThFLE1BQU07O0FBRXBGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxpQ0FBaUM7QUFDakM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwwQ0FBMEM7O0FBRTFDOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQjs7QUFFaEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDLGtEQUFrRDtBQUN4RixJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1FQUFtRTs7QUFFbkU7O0FBRUE7O0FBRUE7QUFDQSx5RUFBeUU7QUFDekUsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNILENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnQkFBZ0I7QUFDcEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGFBQWE7QUFDMUQ7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdCQUFnQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCOztBQUVyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0NBQStDLGFBQWE7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Y2VzIjpbIndlYnBhY2s6Ly9udXJzZWJsb2MvLi9ub2RlX21vZHVsZXMvQG5lYXItd2FsbGV0LXNlbGVjdG9yL2hlcmUtd2FsbGV0L2luZGV4LmpzPzE4NDYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSGVyZVdhbGxldCwgd2FpdEluamVjdGVkSGVyZVdhbGxldCB9IGZyb20gJ0BoZXJlLXdhbGxldC9jb3JlJztcblxudmFyIGNvbW1vbmpzR2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge307XG5cbnZhciBjaGVjayA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgJiYgaXQuTWF0aCA9PSBNYXRoICYmIGl0O1xufTtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwkYSA9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLWdsb2JhbC10aGlzIC0tIHNhZmVcbiAgY2hlY2sodHlwZW9mIGdsb2JhbFRoaXMgPT0gJ29iamVjdCcgJiYgZ2xvYmFsVGhpcykgfHxcbiAgY2hlY2sodHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cpIHx8XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHMgLS0gc2FmZVxuICBjaGVjayh0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmKSB8fFxuICBjaGVjayh0eXBlb2YgY29tbW9uanNHbG9iYWwgPT0gJ29iamVjdCcgJiYgY29tbW9uanNHbG9iYWwpIHx8XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuYyAtLSBmYWxsYmFja1xuICAoZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSkoKSB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG52YXIgb2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0ge307XG5cbnZhciBmYWlscyRhID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cbnZhciBmYWlscyQ5ID0gZmFpbHMkYTtcblxuLy8gRGV0ZWN0IElFOCdzIGluY29tcGxldGUgZGVmaW5lUHJvcGVydHkgaW1wbGVtZW50YXRpb25cbnZhciBkZXNjcmlwdG9ycyA9ICFmYWlscyQ5KGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sIDEsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pWzFdICE9IDc7XG59KTtcblxudmFyIGZhaWxzJDggPSBmYWlscyRhO1xuXG52YXIgZnVuY3Rpb25CaW5kTmF0aXZlID0gIWZhaWxzJDgoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1mdW5jdGlvbi1wcm90b3R5cGUtYmluZCAtLSBzYWZlXG4gIHZhciB0ZXN0ID0gKGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSkuYmluZCgpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zIC0tIHNhZmVcbiAgcmV0dXJuIHR5cGVvZiB0ZXN0ICE9ICdmdW5jdGlvbicgfHwgdGVzdC5oYXNPd25Qcm9wZXJ0eSgncHJvdG90eXBlJyk7XG59KTtcblxudmFyIE5BVElWRV9CSU5EJDEgPSBmdW5jdGlvbkJpbmROYXRpdmU7XG5cbnZhciBjYWxsJDYgPSBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbDtcblxudmFyIGZ1bmN0aW9uQ2FsbCA9IE5BVElWRV9CSU5EJDEgPyBjYWxsJDYuYmluZChjYWxsJDYpIDogZnVuY3Rpb24gKCkge1xuICByZXR1cm4gY2FsbCQ2LmFwcGx5KGNhbGwkNiwgYXJndW1lbnRzKTtcbn07XG5cbnZhciBvYmplY3RQcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHt9O1xuXG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbi8vIE5hc2hvcm4gfiBKREs4IGJ1Z1xudmFyIE5BU0hPUk5fQlVHID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEgJiYgISRwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHsgMTogMiB9LCAxKTtcblxuLy8gYE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGVgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QucHJvdG90eXBlLnByb3BlcnR5aXNlbnVtZXJhYmxlXG5vYmplY3RQcm9wZXJ0eUlzRW51bWVyYWJsZS5mID0gTkFTSE9STl9CVUcgPyBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShWKSB7XG4gIHZhciBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEodGhpcywgVik7XG4gIHJldHVybiAhIWRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci5lbnVtZXJhYmxlO1xufSA6ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQyID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn07XG5cbnZhciBOQVRJVkVfQklORCA9IGZ1bmN0aW9uQmluZE5hdGl2ZTtcblxudmFyIEZ1bmN0aW9uUHJvdG90eXBlJDEgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG52YXIgYmluZCA9IEZ1bmN0aW9uUHJvdG90eXBlJDEuYmluZDtcbnZhciBjYWxsJDUgPSBGdW5jdGlvblByb3RvdHlwZSQxLmNhbGw7XG52YXIgdW5jdXJyeVRoaXMkYSA9IE5BVElWRV9CSU5EICYmIGJpbmQuYmluZChjYWxsJDUsIGNhbGwkNSk7XG5cbnZhciBmdW5jdGlvblVuY3VycnlUaGlzID0gTkFUSVZFX0JJTkQgPyBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIGZuICYmIHVuY3VycnlUaGlzJGEoZm4pO1xufSA6IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gZm4gJiYgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjYWxsJDUuYXBwbHkoZm4sIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuXG52YXIgdW5jdXJyeVRoaXMkOSA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG5cbnZhciB0b1N0cmluZyQyID0gdW5jdXJyeVRoaXMkOSh7fS50b1N0cmluZyk7XG52YXIgc3RyaW5nU2xpY2UgPSB1bmN1cnJ5VGhpcyQ5KCcnLnNsaWNlKTtcblxudmFyIGNsYXNzb2ZSYXckMSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gc3RyaW5nU2xpY2UodG9TdHJpbmckMihpdCksIDgsIC0xKTtcbn07XG5cbnZhciB1bmN1cnJ5VGhpcyQ4ID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBmYWlscyQ3ID0gZmFpbHMkYTtcbnZhciBjbGFzc29mJDIgPSBjbGFzc29mUmF3JDE7XG5cbnZhciAkT2JqZWN0JDMgPSBPYmplY3Q7XG52YXIgc3BsaXQgPSB1bmN1cnJ5VGhpcyQ4KCcnLnNwbGl0KTtcblxuLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcbnZhciBpbmRleGVkT2JqZWN0ID0gZmFpbHMkNyhmdW5jdGlvbiAoKSB7XG4gIC8vIHRocm93cyBhbiBlcnJvciBpbiByaGlubywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3JoaW5vL2lzc3Vlcy8zNDZcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGlucyAtLSBzYWZlXG4gIHJldHVybiAhJE9iamVjdCQzKCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCk7XG59KSA/IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gY2xhc3NvZiQyKGl0KSA9PSAnU3RyaW5nJyA/IHNwbGl0KGl0LCAnJykgOiAkT2JqZWN0JDMoaXQpO1xufSA6ICRPYmplY3QkMztcblxudmFyICRUeXBlRXJyb3IkNSA9IFR5cGVFcnJvcjtcblxuLy8gYFJlcXVpcmVPYmplY3RDb2VyY2libGVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1yZXF1aXJlb2JqZWN0Y29lcmNpYmxlXG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSQyID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCA9PSB1bmRlZmluZWQpIHRocm93ICRUeXBlRXJyb3IkNShcIkNhbid0IGNhbGwgbWV0aG9kIG9uIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuXG4vLyB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIEluZGV4ZWRPYmplY3QkMSA9IGluZGV4ZWRPYmplY3Q7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSQxID0gcmVxdWlyZU9iamVjdENvZXJjaWJsZSQyO1xuXG52YXIgdG9JbmRleGVkT2JqZWN0JDMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIEluZGV4ZWRPYmplY3QkMShyZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDEoaXQpKTtcbn07XG5cbi8vIGBJc0NhbGxhYmxlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaXNjYWxsYWJsZVxudmFyIGlzQ2FsbGFibGUkYiA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gdHlwZW9mIGFyZ3VtZW50ID09ICdmdW5jdGlvbic7XG59O1xuXG52YXIgaXNDYWxsYWJsZSRhID0gaXNDYWxsYWJsZSRiO1xuXG52YXIgaXNPYmplY3QkNSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiBpc0NhbGxhYmxlJGEoaXQpO1xufTtcblxudmFyIGdsb2JhbCQ5ID0gZ2xvYmFsJGE7XG52YXIgaXNDYWxsYWJsZSQ5ID0gaXNDYWxsYWJsZSRiO1xuXG52YXIgYUZ1bmN0aW9uID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiBpc0NhbGxhYmxlJDkoYXJndW1lbnQpID8gYXJndW1lbnQgOiB1bmRlZmluZWQ7XG59O1xuXG52YXIgZ2V0QnVpbHRJbiQzID0gZnVuY3Rpb24gKG5hbWVzcGFjZSwgbWV0aG9kKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGFGdW5jdGlvbihnbG9iYWwkOVtuYW1lc3BhY2VdKSA6IGdsb2JhbCQ5W25hbWVzcGFjZV0gJiYgZ2xvYmFsJDlbbmFtZXNwYWNlXVttZXRob2RdO1xufTtcblxudmFyIHVuY3VycnlUaGlzJDcgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xuXG52YXIgb2JqZWN0SXNQcm90b3R5cGVPZiA9IHVuY3VycnlUaGlzJDcoe30uaXNQcm90b3R5cGVPZik7XG5cbnZhciBnZXRCdWlsdEluJDIgPSBnZXRCdWlsdEluJDM7XG5cbnZhciBlbmdpbmVVc2VyQWdlbnQgPSBnZXRCdWlsdEluJDIoJ25hdmlnYXRvcicsICd1c2VyQWdlbnQnKSB8fCAnJztcblxudmFyIGdsb2JhbCQ4ID0gZ2xvYmFsJGE7XG52YXIgdXNlckFnZW50ID0gZW5naW5lVXNlckFnZW50O1xuXG52YXIgcHJvY2VzcyA9IGdsb2JhbCQ4LnByb2Nlc3M7XG52YXIgRGVubyA9IGdsb2JhbCQ4LkRlbm87XG52YXIgdmVyc2lvbnMgPSBwcm9jZXNzICYmIHByb2Nlc3MudmVyc2lvbnMgfHwgRGVubyAmJiBEZW5vLnZlcnNpb247XG52YXIgdjggPSB2ZXJzaW9ucyAmJiB2ZXJzaW9ucy52ODtcbnZhciBtYXRjaCwgdmVyc2lvbjtcblxuaWYgKHY4KSB7XG4gIG1hdGNoID0gdjguc3BsaXQoJy4nKTtcbiAgLy8gaW4gb2xkIENocm9tZSwgdmVyc2lvbnMgb2YgVjggaXNuJ3QgVjggPSBDaHJvbWUgLyAxMFxuICAvLyBidXQgdGhlaXIgY29ycmVjdCB2ZXJzaW9ucyBhcmUgbm90IGludGVyZXN0aW5nIGZvciB1c1xuICB2ZXJzaW9uID0gbWF0Y2hbMF0gPiAwICYmIG1hdGNoWzBdIDwgNCA/IDEgOiArKG1hdGNoWzBdICsgbWF0Y2hbMV0pO1xufVxuXG4vLyBCcm93c2VyRlMgTm9kZUpTIGBwcm9jZXNzYCBwb2x5ZmlsbCBpbmNvcnJlY3RseSBzZXQgYC52OGAgdG8gYDAuMGBcbi8vIHNvIGNoZWNrIGB1c2VyQWdlbnRgIGV2ZW4gaWYgYC52OGAgZXhpc3RzLCBidXQgMFxuaWYgKCF2ZXJzaW9uICYmIHVzZXJBZ2VudCkge1xuICBtYXRjaCA9IHVzZXJBZ2VudC5tYXRjaCgvRWRnZVxcLyhcXGQrKS8pO1xuICBpZiAoIW1hdGNoIHx8IG1hdGNoWzFdID49IDc0KSB7XG4gICAgbWF0Y2ggPSB1c2VyQWdlbnQubWF0Y2goL0Nocm9tZVxcLyhcXGQrKS8pO1xuICAgIGlmIChtYXRjaCkgdmVyc2lvbiA9ICttYXRjaFsxXTtcbiAgfVxufVxuXG52YXIgZW5naW5lVjhWZXJzaW9uID0gdmVyc2lvbjtcblxuLyogZXNsaW50LWRpc2FibGUgZXMteC9uby1zeW1ib2wgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmcgKi9cblxudmFyIFY4X1ZFUlNJT04gPSBlbmdpbmVWOFZlcnNpb247XG52YXIgZmFpbHMkNiA9IGZhaWxzJGE7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eXN5bWJvbHMgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbnZhciBuYXRpdmVTeW1ib2wgPSAhIU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgJiYgIWZhaWxzJDYoZnVuY3Rpb24gKCkge1xuICB2YXIgc3ltYm9sID0gU3ltYm9sKCk7XG4gIC8vIENocm9tZSAzOCBTeW1ib2wgaGFzIGluY29ycmVjdCB0b1N0cmluZyBjb252ZXJzaW9uXG4gIC8vIGBnZXQtb3duLXByb3BlcnR5LXN5bWJvbHNgIHBvbHlmaWxsIHN5bWJvbHMgY29udmVydGVkIHRvIG9iamVjdCBhcmUgbm90IFN5bWJvbCBpbnN0YW5jZXNcbiAgcmV0dXJuICFTdHJpbmcoc3ltYm9sKSB8fCAhKE9iamVjdChzeW1ib2wpIGluc3RhbmNlb2YgU3ltYm9sKSB8fFxuICAgIC8vIENocm9tZSAzOC00MCBzeW1ib2xzIGFyZSBub3QgaW5oZXJpdGVkIGZyb20gRE9NIGNvbGxlY3Rpb25zIHByb3RvdHlwZXMgdG8gaW5zdGFuY2VzXG4gICAgIVN5bWJvbC5zaGFtICYmIFY4X1ZFUlNJT04gJiYgVjhfVkVSU0lPTiA8IDQxO1xufSk7XG5cbi8qIGVzbGludC1kaXNhYmxlIGVzLXgvbm8tc3ltYm9sIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nICovXG5cbnZhciBOQVRJVkVfU1lNQk9MJDEgPSBuYXRpdmVTeW1ib2w7XG5cbnZhciB1c2VTeW1ib2xBc1VpZCA9IE5BVElWRV9TWU1CT0wkMVxuICAmJiAhU3ltYm9sLnNoYW1cbiAgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSAnc3ltYm9sJztcblxudmFyIGdldEJ1aWx0SW4kMSA9IGdldEJ1aWx0SW4kMztcbnZhciBpc0NhbGxhYmxlJDggPSBpc0NhbGxhYmxlJGI7XG52YXIgaXNQcm90b3R5cGVPZiQxID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbnZhciBVU0VfU1lNQk9MX0FTX1VJRCQxID0gdXNlU3ltYm9sQXNVaWQ7XG5cbnZhciAkT2JqZWN0JDIgPSBPYmplY3Q7XG5cbnZhciBpc1N5bWJvbCQyID0gVVNFX1NZTUJPTF9BU19VSUQkMSA/IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnO1xufSA6IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgJFN5bWJvbCA9IGdldEJ1aWx0SW4kMSgnU3ltYm9sJyk7XG4gIHJldHVybiBpc0NhbGxhYmxlJDgoJFN5bWJvbCkgJiYgaXNQcm90b3R5cGVPZiQxKCRTeW1ib2wucHJvdG90eXBlLCAkT2JqZWN0JDIoaXQpKTtcbn07XG5cbnZhciAkU3RyaW5nJDIgPSBTdHJpbmc7XG5cbnZhciB0cnlUb1N0cmluZyQxID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICRTdHJpbmckMihhcmd1bWVudCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuICdPYmplY3QnO1xuICB9XG59O1xuXG52YXIgaXNDYWxsYWJsZSQ3ID0gaXNDYWxsYWJsZSRiO1xudmFyIHRyeVRvU3RyaW5nID0gdHJ5VG9TdHJpbmckMTtcblxudmFyICRUeXBlRXJyb3IkNCA9IFR5cGVFcnJvcjtcblxuLy8gYEFzc2VydDogSXNDYWxsYWJsZShhcmd1bWVudCkgaXMgdHJ1ZWBcbnZhciBhQ2FsbGFibGUkMSA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAoaXNDYWxsYWJsZSQ3KGFyZ3VtZW50KSkgcmV0dXJuIGFyZ3VtZW50O1xuICB0aHJvdyAkVHlwZUVycm9yJDQodHJ5VG9TdHJpbmcoYXJndW1lbnQpICsgJyBpcyBub3QgYSBmdW5jdGlvbicpO1xufTtcblxudmFyIGFDYWxsYWJsZSA9IGFDYWxsYWJsZSQxO1xuXG4vLyBgR2V0TWV0aG9kYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtZ2V0bWV0aG9kXG52YXIgZ2V0TWV0aG9kJDEgPSBmdW5jdGlvbiAoViwgUCkge1xuICB2YXIgZnVuYyA9IFZbUF07XG4gIHJldHVybiBmdW5jID09IG51bGwgPyB1bmRlZmluZWQgOiBhQ2FsbGFibGUoZnVuYyk7XG59O1xuXG52YXIgY2FsbCQ0ID0gZnVuY3Rpb25DYWxsO1xudmFyIGlzQ2FsbGFibGUkNiA9IGlzQ2FsbGFibGUkYjtcbnZhciBpc09iamVjdCQ0ID0gaXNPYmplY3QkNTtcblxudmFyICRUeXBlRXJyb3IkMyA9IFR5cGVFcnJvcjtcblxuLy8gYE9yZGluYXJ5VG9QcmltaXRpdmVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vcmRpbmFyeXRvcHJpbWl0aXZlXG52YXIgb3JkaW5hcnlUb1ByaW1pdGl2ZSQxID0gZnVuY3Rpb24gKGlucHV0LCBwcmVmKSB7XG4gIHZhciBmbiwgdmFsO1xuICBpZiAocHJlZiA9PT0gJ3N0cmluZycgJiYgaXNDYWxsYWJsZSQ2KGZuID0gaW5wdXQudG9TdHJpbmcpICYmICFpc09iamVjdCQ0KHZhbCA9IGNhbGwkNChmbiwgaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKGlzQ2FsbGFibGUkNihmbiA9IGlucHV0LnZhbHVlT2YpICYmICFpc09iamVjdCQ0KHZhbCA9IGNhbGwkNChmbiwgaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKHByZWYgIT09ICdzdHJpbmcnICYmIGlzQ2FsbGFibGUkNihmbiA9IGlucHV0LnRvU3RyaW5nKSAmJiAhaXNPYmplY3QkNCh2YWwgPSBjYWxsJDQoZm4sIGlucHV0KSkpIHJldHVybiB2YWw7XG4gIHRocm93ICRUeXBlRXJyb3IkMyhcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07XG5cbnZhciBzaGFyZWQkMyA9IHtleHBvcnRzOiB7fX07XG5cbnZhciBnbG9iYWwkNyA9IGdsb2JhbCRhO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gc2FmZVxudmFyIGRlZmluZVByb3BlcnR5JDIgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbnZhciBkZWZpbmVHbG9iYWxQcm9wZXJ0eSQzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgdHJ5IHtcbiAgICBkZWZpbmVQcm9wZXJ0eSQyKGdsb2JhbCQ3LCBrZXksIHsgdmFsdWU6IHZhbHVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGdsb2JhbCQ3W2tleV0gPSB2YWx1ZTtcbiAgfSByZXR1cm4gdmFsdWU7XG59O1xuXG52YXIgZ2xvYmFsJDYgPSBnbG9iYWwkYTtcbnZhciBkZWZpbmVHbG9iYWxQcm9wZXJ0eSQyID0gZGVmaW5lR2xvYmFsUHJvcGVydHkkMztcblxudmFyIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nO1xudmFyIHN0b3JlJDMgPSBnbG9iYWwkNltTSEFSRURdIHx8IGRlZmluZUdsb2JhbFByb3BlcnR5JDIoU0hBUkVELCB7fSk7XG5cbnZhciBzaGFyZWRTdG9yZSA9IHN0b3JlJDM7XG5cbnZhciBzdG9yZSQyID0gc2hhcmVkU3RvcmU7XG5cbihzaGFyZWQkMy5leHBvcnRzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIHN0b3JlJDJba2V5XSB8fCAoc3RvcmUkMltrZXldID0gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoge30pO1xufSkoJ3ZlcnNpb25zJywgW10pLnB1c2goe1xuICB2ZXJzaW9uOiAnMy4yMy4zJyxcbiAgbW9kZTogJ2dsb2JhbCcsXG4gIGNvcHlyaWdodDogJ8KpIDIwMTQtMjAyMiBEZW5pcyBQdXNoa2FyZXYgKHpsb2lyb2NrLnJ1KScsXG4gIGxpY2Vuc2U6ICdodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9ibG9iL3YzLjIzLjMvTElDRU5TRScsXG4gIHNvdXJjZTogJ2h0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzJ1xufSk7XG5cbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZU9iamVjdENvZXJjaWJsZSQyO1xuXG52YXIgJE9iamVjdCQxID0gT2JqZWN0O1xuXG4vLyBgVG9PYmplY3RgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b29iamVjdFxudmFyIHRvT2JqZWN0JDIgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuICRPYmplY3QkMShyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KSk7XG59O1xuXG52YXIgdW5jdXJyeVRoaXMkNiA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgdG9PYmplY3QkMSA9IHRvT2JqZWN0JDI7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IHVuY3VycnlUaGlzJDYoe30uaGFzT3duUHJvcGVydHkpO1xuXG4vLyBgSGFzT3duUHJvcGVydHlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1oYXNvd25wcm9wZXJ0eVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWhhc293biAtLSBzYWZlXG52YXIgaGFzT3duUHJvcGVydHlfMSA9IE9iamVjdC5oYXNPd24gfHwgZnVuY3Rpb24gaGFzT3duKGl0LCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5KHRvT2JqZWN0JDEoaXQpLCBrZXkpO1xufTtcblxudmFyIHVuY3VycnlUaGlzJDUgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xuXG52YXIgaWQgPSAwO1xudmFyIHBvc3RmaXggPSBNYXRoLnJhbmRvbSgpO1xudmFyIHRvU3RyaW5nJDEgPSB1bmN1cnJ5VGhpcyQ1KDEuMC50b1N0cmluZyk7XG5cbnZhciB1aWQkMiA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuICdTeW1ib2woJyArIChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5KSArICcpXycgKyB0b1N0cmluZyQxKCsraWQgKyBwb3N0Zml4LCAzNik7XG59O1xuXG52YXIgZ2xvYmFsJDUgPSBnbG9iYWwkYTtcbnZhciBzaGFyZWQkMiA9IHNoYXJlZCQzLmV4cG9ydHM7XG52YXIgaGFzT3duJDcgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIHVpZCQxID0gdWlkJDI7XG52YXIgTkFUSVZFX1NZTUJPTCA9IG5hdGl2ZVN5bWJvbDtcbnZhciBVU0VfU1lNQk9MX0FTX1VJRCA9IHVzZVN5bWJvbEFzVWlkO1xuXG52YXIgV2VsbEtub3duU3ltYm9sc1N0b3JlID0gc2hhcmVkJDIoJ3drcycpO1xudmFyIFN5bWJvbCQxID0gZ2xvYmFsJDUuU3ltYm9sO1xudmFyIHN5bWJvbEZvciA9IFN5bWJvbCQxICYmIFN5bWJvbCQxWydmb3InXTtcbnZhciBjcmVhdGVXZWxsS25vd25TeW1ib2wgPSBVU0VfU1lNQk9MX0FTX1VJRCA/IFN5bWJvbCQxIDogU3ltYm9sJDEgJiYgU3ltYm9sJDEud2l0aG91dFNldHRlciB8fCB1aWQkMTtcblxudmFyIHdlbGxLbm93blN5bWJvbCQzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgaWYgKCFoYXNPd24kNyhXZWxsS25vd25TeW1ib2xzU3RvcmUsIG5hbWUpIHx8ICEoTkFUSVZFX1NZTUJPTCB8fCB0eXBlb2YgV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdID09ICdzdHJpbmcnKSkge1xuICAgIHZhciBkZXNjcmlwdGlvbiA9ICdTeW1ib2wuJyArIG5hbWU7XG4gICAgaWYgKE5BVElWRV9TWU1CT0wgJiYgaGFzT3duJDcoU3ltYm9sJDEsIG5hbWUpKSB7XG4gICAgICBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV0gPSBTeW1ib2wkMVtuYW1lXTtcbiAgICB9IGVsc2UgaWYgKFVTRV9TWU1CT0xfQVNfVUlEICYmIHN5bWJvbEZvcikge1xuICAgICAgV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdID0gc3ltYm9sRm9yKGRlc2NyaXB0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdID0gY3JlYXRlV2VsbEtub3duU3ltYm9sKGRlc2NyaXB0aW9uKTtcbiAgICB9XG4gIH0gcmV0dXJuIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXTtcbn07XG5cbnZhciBjYWxsJDMgPSBmdW5jdGlvbkNhbGw7XG52YXIgaXNPYmplY3QkMyA9IGlzT2JqZWN0JDU7XG52YXIgaXNTeW1ib2wkMSA9IGlzU3ltYm9sJDI7XG52YXIgZ2V0TWV0aG9kID0gZ2V0TWV0aG9kJDE7XG52YXIgb3JkaW5hcnlUb1ByaW1pdGl2ZSA9IG9yZGluYXJ5VG9QcmltaXRpdmUkMTtcbnZhciB3ZWxsS25vd25TeW1ib2wkMiA9IHdlbGxLbm93blN5bWJvbCQzO1xuXG52YXIgJFR5cGVFcnJvciQyID0gVHlwZUVycm9yO1xudmFyIFRPX1BSSU1JVElWRSA9IHdlbGxLbm93blN5bWJvbCQyKCd0b1ByaW1pdGl2ZScpO1xuXG4vLyBgVG9QcmltaXRpdmVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b3ByaW1pdGl2ZVxudmFyIHRvUHJpbWl0aXZlJDEgPSBmdW5jdGlvbiAoaW5wdXQsIHByZWYpIHtcbiAgaWYgKCFpc09iamVjdCQzKGlucHV0KSB8fCBpc1N5bWJvbCQxKGlucHV0KSkgcmV0dXJuIGlucHV0O1xuICB2YXIgZXhvdGljVG9QcmltID0gZ2V0TWV0aG9kKGlucHV0LCBUT19QUklNSVRJVkUpO1xuICB2YXIgcmVzdWx0O1xuICBpZiAoZXhvdGljVG9QcmltKSB7XG4gICAgaWYgKHByZWYgPT09IHVuZGVmaW5lZCkgcHJlZiA9ICdkZWZhdWx0JztcbiAgICByZXN1bHQgPSBjYWxsJDMoZXhvdGljVG9QcmltLCBpbnB1dCwgcHJlZik7XG4gICAgaWYgKCFpc09iamVjdCQzKHJlc3VsdCkgfHwgaXNTeW1ib2wkMShyZXN1bHQpKSByZXR1cm4gcmVzdWx0O1xuICAgIHRocm93ICRUeXBlRXJyb3IkMihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbiAgfVxuICBpZiAocHJlZiA9PT0gdW5kZWZpbmVkKSBwcmVmID0gJ251bWJlcic7XG4gIHJldHVybiBvcmRpbmFyeVRvUHJpbWl0aXZlKGlucHV0LCBwcmVmKTtcbn07XG5cbnZhciB0b1ByaW1pdGl2ZSA9IHRvUHJpbWl0aXZlJDE7XG52YXIgaXNTeW1ib2wgPSBpc1N5bWJvbCQyO1xuXG4vLyBgVG9Qcm9wZXJ0eUtleWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvcHJvcGVydHlrZXlcbnZhciB0b1Byb3BlcnR5S2V5JDIgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgdmFyIGtleSA9IHRvUHJpbWl0aXZlKGFyZ3VtZW50LCAnc3RyaW5nJyk7XG4gIHJldHVybiBpc1N5bWJvbChrZXkpID8ga2V5IDoga2V5ICsgJyc7XG59O1xuXG52YXIgZ2xvYmFsJDQgPSBnbG9iYWwkYTtcbnZhciBpc09iamVjdCQyID0gaXNPYmplY3QkNTtcblxudmFyIGRvY3VtZW50ID0gZ2xvYmFsJDQuZG9jdW1lbnQ7XG4vLyB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0JyBpbiBvbGQgSUVcbnZhciBFWElTVFMkMSA9IGlzT2JqZWN0JDIoZG9jdW1lbnQpICYmIGlzT2JqZWN0JDIoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5cbnZhciBkb2N1bWVudENyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIEVYSVNUUyQxID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG5cbnZhciBERVNDUklQVE9SUyQ3ID0gZGVzY3JpcHRvcnM7XG52YXIgZmFpbHMkNSA9IGZhaWxzJGE7XG52YXIgY3JlYXRlRWxlbWVudCA9IGRvY3VtZW50Q3JlYXRlRWxlbWVudDtcblxuLy8gVGhhbmtzIHRvIElFOCBmb3IgaXRzIGZ1bm55IGRlZmluZVByb3BlcnR5XG52YXIgaWU4RG9tRGVmaW5lID0gIURFU0NSSVBUT1JTJDcgJiYgIWZhaWxzJDUoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjcmVhdGVFbGVtZW50KCdkaXYnKSwgJ2EnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9XG4gIH0pLmEgIT0gNztcbn0pO1xuXG52YXIgREVTQ1JJUFRPUlMkNiA9IGRlc2NyaXB0b3JzO1xudmFyIGNhbGwkMiA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSQxID0gb2JqZWN0UHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDEgPSBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkMjtcbnZhciB0b0luZGV4ZWRPYmplY3QkMiA9IHRvSW5kZXhlZE9iamVjdCQzO1xudmFyIHRvUHJvcGVydHlLZXkkMSA9IHRvUHJvcGVydHlLZXkkMjtcbnZhciBoYXNPd24kNiA9IGhhc093blByb3BlcnR5XzE7XG52YXIgSUU4X0RPTV9ERUZJTkUkMSA9IGllOERvbURlZmluZTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciQxID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yXG5vYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IuZiA9IERFU0NSSVBUT1JTJDYgPyAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCkge1xuICBPID0gdG9JbmRleGVkT2JqZWN0JDIoTyk7XG4gIFAgPSB0b1Byb3BlcnR5S2V5JDEoUCk7XG4gIGlmIChJRThfRE9NX0RFRklORSQxKSB0cnkge1xuICAgIHJldHVybiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEoTywgUCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKGhhc093biQ2KE8sIFApKSByZXR1cm4gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDEoIWNhbGwkMihwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSQxLmYsIE8sIFApLCBPW1BdKTtcbn07XG5cbnZhciBvYmplY3REZWZpbmVQcm9wZXJ0eSA9IHt9O1xuXG52YXIgREVTQ1JJUFRPUlMkNSA9IGRlc2NyaXB0b3JzO1xudmFyIGZhaWxzJDQgPSBmYWlscyRhO1xuXG4vLyBWOCB+IENocm9tZSAzNi1cbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMzMzRcbnZhciB2OFByb3RvdHlwZURlZmluZUJ1ZyA9IERFU0NSSVBUT1JTJDUgJiYgZmFpbHMkNChmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSwgJ3Byb3RvdHlwZScsIHtcbiAgICB2YWx1ZTogNDIsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pLnByb3RvdHlwZSAhPSA0Mjtcbn0pO1xuXG52YXIgaXNPYmplY3QkMSA9IGlzT2JqZWN0JDU7XG5cbnZhciAkU3RyaW5nJDEgPSBTdHJpbmc7XG52YXIgJFR5cGVFcnJvciQxID0gVHlwZUVycm9yO1xuXG4vLyBgQXNzZXJ0OiBUeXBlKGFyZ3VtZW50KSBpcyBPYmplY3RgXG52YXIgYW5PYmplY3QkNCA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAoaXNPYmplY3QkMShhcmd1bWVudCkpIHJldHVybiBhcmd1bWVudDtcbiAgdGhyb3cgJFR5cGVFcnJvciQxKCRTdHJpbmckMShhcmd1bWVudCkgKyAnIGlzIG5vdCBhbiBvYmplY3QnKTtcbn07XG5cbnZhciBERVNDUklQVE9SUyQ0ID0gZGVzY3JpcHRvcnM7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSBpZThEb21EZWZpbmU7XG52YXIgVjhfUFJPVE9UWVBFX0RFRklORV9CVUcgPSB2OFByb3RvdHlwZURlZmluZUJ1ZztcbnZhciBhbk9iamVjdCQzID0gYW5PYmplY3QkNDtcbnZhciB0b1Byb3BlcnR5S2V5ID0gdG9Qcm9wZXJ0eUtleSQyO1xuXG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSBzYWZlXG52YXIgJGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgRU5VTUVSQUJMRSA9ICdlbnVtZXJhYmxlJztcbnZhciBDT05GSUdVUkFCTEUkMSA9ICdjb25maWd1cmFibGUnO1xudmFyIFdSSVRBQkxFID0gJ3dyaXRhYmxlJztcblxuLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0eWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0eVxub2JqZWN0RGVmaW5lUHJvcGVydHkuZiA9IERFU0NSSVBUT1JTJDQgPyBWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyA/IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgYW5PYmplY3QkMyhPKTtcbiAgUCA9IHRvUHJvcGVydHlLZXkoUCk7XG4gIGFuT2JqZWN0JDMoQXR0cmlidXRlcyk7XG4gIGlmICh0eXBlb2YgTyA9PT0gJ2Z1bmN0aW9uJyAmJiBQID09PSAncHJvdG90eXBlJyAmJiAndmFsdWUnIGluIEF0dHJpYnV0ZXMgJiYgV1JJVEFCTEUgaW4gQXR0cmlidXRlcyAmJiAhQXR0cmlidXRlc1tXUklUQUJMRV0pIHtcbiAgICB2YXIgY3VycmVudCA9ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCk7XG4gICAgaWYgKGN1cnJlbnQgJiYgY3VycmVudFtXUklUQUJMRV0pIHtcbiAgICAgIE9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICAgICAgQXR0cmlidXRlcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBDT05GSUdVUkFCTEUkMSBpbiBBdHRyaWJ1dGVzID8gQXR0cmlidXRlc1tDT05GSUdVUkFCTEUkMV0gOiBjdXJyZW50W0NPTkZJR1VSQUJMRSQxXSxcbiAgICAgICAgZW51bWVyYWJsZTogRU5VTUVSQUJMRSBpbiBBdHRyaWJ1dGVzID8gQXR0cmlidXRlc1tFTlVNRVJBQkxFXSA6IGN1cnJlbnRbRU5VTUVSQUJMRV0sXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gIH0gcmV0dXJuICRkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKTtcbn0gOiAkZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGFuT2JqZWN0JDMoTyk7XG4gIFAgPSB0b1Byb3BlcnR5S2V5KFApO1xuICBhbk9iamVjdCQzKEF0dHJpYnV0ZXMpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuICRkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKSB0aHJvdyAkVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCcpO1xuICBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKSBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuXG52YXIgREVTQ1JJUFRPUlMkMyA9IGRlc2NyaXB0b3JzO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlJDIgPSBvYmplY3REZWZpbmVQcm9wZXJ0eTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkMjtcblxudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQyID0gREVTQ1JJUFRPUlMkMyA/IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5TW9kdWxlJDIuZihvYmplY3QsIGtleSwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTtcblxudmFyIG1ha2VCdWlsdEluJDIgPSB7ZXhwb3J0czoge319O1xuXG52YXIgREVTQ1JJUFRPUlMkMiA9IGRlc2NyaXB0b3JzO1xudmFyIGhhc093biQ1ID0gaGFzT3duUHJvcGVydHlfMTtcblxudmFyIEZ1bmN0aW9uUHJvdG90eXBlID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG52YXIgZ2V0RGVzY3JpcHRvciA9IERFU0NSSVBUT1JTJDIgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxudmFyIEVYSVNUUyA9IGhhc093biQ1KEZ1bmN0aW9uUHJvdG90eXBlLCAnbmFtZScpO1xuLy8gYWRkaXRpb25hbCBwcm90ZWN0aW9uIGZyb20gbWluaWZpZWQgLyBtYW5nbGVkIC8gZHJvcHBlZCBmdW5jdGlvbiBuYW1lc1xudmFyIFBST1BFUiA9IEVYSVNUUyAmJiAoZnVuY3Rpb24gc29tZXRoaW5nKCkgeyAvKiBlbXB0eSAqLyB9KS5uYW1lID09PSAnc29tZXRoaW5nJztcbnZhciBDT05GSUdVUkFCTEUgPSBFWElTVFMgJiYgKCFERVNDUklQVE9SUyQyIHx8IChERVNDUklQVE9SUyQyICYmIGdldERlc2NyaXB0b3IoRnVuY3Rpb25Qcm90b3R5cGUsICduYW1lJykuY29uZmlndXJhYmxlKSk7XG5cbnZhciBmdW5jdGlvbk5hbWUgPSB7XG4gIEVYSVNUUzogRVhJU1RTLFxuICBQUk9QRVI6IFBST1BFUixcbiAgQ09ORklHVVJBQkxFOiBDT05GSUdVUkFCTEVcbn07XG5cbnZhciB1bmN1cnJ5VGhpcyQ0ID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBpc0NhbGxhYmxlJDUgPSBpc0NhbGxhYmxlJGI7XG52YXIgc3RvcmUkMSA9IHNoYXJlZFN0b3JlO1xuXG52YXIgZnVuY3Rpb25Ub1N0cmluZyA9IHVuY3VycnlUaGlzJDQoRnVuY3Rpb24udG9TdHJpbmcpO1xuXG4vLyB0aGlzIGhlbHBlciBicm9rZW4gaW4gYGNvcmUtanNAMy40LjEtMy40LjRgLCBzbyB3ZSBjYW4ndCB1c2UgYHNoYXJlZGAgaGVscGVyXG5pZiAoIWlzQ2FsbGFibGUkNShzdG9yZSQxLmluc3BlY3RTb3VyY2UpKSB7XG4gIHN0b3JlJDEuaW5zcGVjdFNvdXJjZSA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBmdW5jdGlvblRvU3RyaW5nKGl0KTtcbiAgfTtcbn1cblxudmFyIGluc3BlY3RTb3VyY2UkMiA9IHN0b3JlJDEuaW5zcGVjdFNvdXJjZTtcblxudmFyIGdsb2JhbCQzID0gZ2xvYmFsJGE7XG52YXIgaXNDYWxsYWJsZSQ0ID0gaXNDYWxsYWJsZSRiO1xudmFyIGluc3BlY3RTb3VyY2UkMSA9IGluc3BlY3RTb3VyY2UkMjtcblxudmFyIFdlYWtNYXAkMSA9IGdsb2JhbCQzLldlYWtNYXA7XG5cbnZhciBuYXRpdmVXZWFrTWFwID0gaXNDYWxsYWJsZSQ0KFdlYWtNYXAkMSkgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KGluc3BlY3RTb3VyY2UkMShXZWFrTWFwJDEpKTtcblxudmFyIHNoYXJlZCQxID0gc2hhcmVkJDMuZXhwb3J0cztcbnZhciB1aWQgPSB1aWQkMjtcblxudmFyIGtleXMgPSBzaGFyZWQkMSgna2V5cycpO1xuXG52YXIgc2hhcmVkS2V5JDEgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBrZXlzW2tleV0gfHwgKGtleXNba2V5XSA9IHVpZChrZXkpKTtcbn07XG5cbnZhciBoaWRkZW5LZXlzJDMgPSB7fTtcblxudmFyIE5BVElWRV9XRUFLX01BUCA9IG5hdGl2ZVdlYWtNYXA7XG52YXIgZ2xvYmFsJDIgPSBnbG9iYWwkYTtcbnZhciB1bmN1cnJ5VGhpcyQzID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBpc09iamVjdCA9IGlzT2JqZWN0JDU7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDEgPSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMjtcbnZhciBoYXNPd24kNCA9IGhhc093blByb3BlcnR5XzE7XG52YXIgc2hhcmVkID0gc2hhcmVkU3RvcmU7XG52YXIgc2hhcmVkS2V5ID0gc2hhcmVkS2V5JDE7XG52YXIgaGlkZGVuS2V5cyQyID0gaGlkZGVuS2V5cyQzO1xuXG52YXIgT0JKRUNUX0FMUkVBRFlfSU5JVElBTElaRUQgPSAnT2JqZWN0IGFscmVhZHkgaW5pdGlhbGl6ZWQnO1xudmFyIFR5cGVFcnJvciQxID0gZ2xvYmFsJDIuVHlwZUVycm9yO1xudmFyIFdlYWtNYXAgPSBnbG9iYWwkMi5XZWFrTWFwO1xudmFyIHNldCwgZ2V0LCBoYXM7XG5cbnZhciBlbmZvcmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBoYXMoaXQpID8gZ2V0KGl0KSA6IHNldChpdCwge30pO1xufTtcblxudmFyIGdldHRlckZvciA9IGZ1bmN0aW9uIChUWVBFKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoaXQpIHtcbiAgICB2YXIgc3RhdGU7XG4gICAgaWYgKCFpc09iamVjdChpdCkgfHwgKHN0YXRlID0gZ2V0KGl0KSkudHlwZSAhPT0gVFlQRSkge1xuICAgICAgdGhyb3cgVHlwZUVycm9yJDEoJ0luY29tcGF0aWJsZSByZWNlaXZlciwgJyArIFRZUEUgKyAnIHJlcXVpcmVkJyk7XG4gICAgfSByZXR1cm4gc3RhdGU7XG4gIH07XG59O1xuXG5pZiAoTkFUSVZFX1dFQUtfTUFQIHx8IHNoYXJlZC5zdGF0ZSkge1xuICB2YXIgc3RvcmUgPSBzaGFyZWQuc3RhdGUgfHwgKHNoYXJlZC5zdGF0ZSA9IG5ldyBXZWFrTWFwKCkpO1xuICB2YXIgd21nZXQgPSB1bmN1cnJ5VGhpcyQzKHN0b3JlLmdldCk7XG4gIHZhciB3bWhhcyA9IHVuY3VycnlUaGlzJDMoc3RvcmUuaGFzKTtcbiAgdmFyIHdtc2V0ID0gdW5jdXJyeVRoaXMkMyhzdG9yZS5zZXQpO1xuICBzZXQgPSBmdW5jdGlvbiAoaXQsIG1ldGFkYXRhKSB7XG4gICAgaWYgKHdtaGFzKHN0b3JlLCBpdCkpIHRocm93IG5ldyBUeXBlRXJyb3IkMShPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCk7XG4gICAgbWV0YWRhdGEuZmFjYWRlID0gaXQ7XG4gICAgd21zZXQoc3RvcmUsIGl0LCBtZXRhZGF0YSk7XG4gICAgcmV0dXJuIG1ldGFkYXRhO1xuICB9O1xuICBnZXQgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gd21nZXQoc3RvcmUsIGl0KSB8fCB7fTtcbiAgfTtcbiAgaGFzID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIHdtaGFzKHN0b3JlLCBpdCk7XG4gIH07XG59IGVsc2Uge1xuICB2YXIgU1RBVEUgPSBzaGFyZWRLZXkoJ3N0YXRlJyk7XG4gIGhpZGRlbktleXMkMltTVEFURV0gPSB0cnVlO1xuICBzZXQgPSBmdW5jdGlvbiAoaXQsIG1ldGFkYXRhKSB7XG4gICAgaWYgKGhhc093biQ0KGl0LCBTVEFURSkpIHRocm93IG5ldyBUeXBlRXJyb3IkMShPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCk7XG4gICAgbWV0YWRhdGEuZmFjYWRlID0gaXQ7XG4gICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDEoaXQsIFNUQVRFLCBtZXRhZGF0YSk7XG4gICAgcmV0dXJuIG1ldGFkYXRhO1xuICB9O1xuICBnZXQgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gaGFzT3duJDQoaXQsIFNUQVRFKSA/IGl0W1NUQVRFXSA6IHt9O1xuICB9O1xuICBoYXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gaGFzT3duJDQoaXQsIFNUQVRFKTtcbiAgfTtcbn1cblxudmFyIGludGVybmFsU3RhdGUgPSB7XG4gIHNldDogc2V0LFxuICBnZXQ6IGdldCxcbiAgaGFzOiBoYXMsXG4gIGVuZm9yY2U6IGVuZm9yY2UsXG4gIGdldHRlckZvcjogZ2V0dGVyRm9yXG59O1xuXG52YXIgZmFpbHMkMyA9IGZhaWxzJGE7XG52YXIgaXNDYWxsYWJsZSQzID0gaXNDYWxsYWJsZSRiO1xudmFyIGhhc093biQzID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBERVNDUklQVE9SUyQxID0gZGVzY3JpcHRvcnM7XG52YXIgQ09ORklHVVJBQkxFX0ZVTkNUSU9OX05BTUUgPSBmdW5jdGlvbk5hbWUuQ09ORklHVVJBQkxFO1xudmFyIGluc3BlY3RTb3VyY2UgPSBpbnNwZWN0U291cmNlJDI7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSA9IGludGVybmFsU3RhdGU7XG5cbnZhciBlbmZvcmNlSW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZW5mb3JjZTtcbnZhciBnZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXQ7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gc2FmZVxudmFyIGRlZmluZVByb3BlcnR5JDEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbnZhciBDT05GSUdVUkFCTEVfTEVOR1RIID0gREVTQ1JJUFRPUlMkMSAmJiAhZmFpbHMkMyhmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eSQxKGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSwgJ2xlbmd0aCcsIHsgdmFsdWU6IDggfSkubGVuZ3RoICE9PSA4O1xufSk7XG5cbnZhciBURU1QTEFURSA9IFN0cmluZyhTdHJpbmcpLnNwbGl0KCdTdHJpbmcnKTtcblxudmFyIG1ha2VCdWlsdEluJDEgPSBtYWtlQnVpbHRJbiQyLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUsIG5hbWUsIG9wdGlvbnMpIHtcbiAgaWYgKFN0cmluZyhuYW1lKS5zbGljZSgwLCA3KSA9PT0gJ1N5bWJvbCgnKSB7XG4gICAgbmFtZSA9ICdbJyArIFN0cmluZyhuYW1lKS5yZXBsYWNlKC9eU3ltYm9sXFwoKFteKV0qKVxcKS8sICckMScpICsgJ10nO1xuICB9XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZ2V0dGVyKSBuYW1lID0gJ2dldCAnICsgbmFtZTtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5zZXR0ZXIpIG5hbWUgPSAnc2V0ICcgKyBuYW1lO1xuICBpZiAoIWhhc093biQzKHZhbHVlLCAnbmFtZScpIHx8IChDT05GSUdVUkFCTEVfRlVOQ1RJT05fTkFNRSAmJiB2YWx1ZS5uYW1lICE9PSBuYW1lKSkge1xuICAgIGlmIChERVNDUklQVE9SUyQxKSBkZWZpbmVQcm9wZXJ0eSQxKHZhbHVlLCAnbmFtZScsIHsgdmFsdWU6IG5hbWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcbiAgICBlbHNlIHZhbHVlLm5hbWUgPSBuYW1lO1xuICB9XG4gIGlmIChDT05GSUdVUkFCTEVfTEVOR1RIICYmIG9wdGlvbnMgJiYgaGFzT3duJDMob3B0aW9ucywgJ2FyaXR5JykgJiYgdmFsdWUubGVuZ3RoICE9PSBvcHRpb25zLmFyaXR5KSB7XG4gICAgZGVmaW5lUHJvcGVydHkkMSh2YWx1ZSwgJ2xlbmd0aCcsIHsgdmFsdWU6IG9wdGlvbnMuYXJpdHkgfSk7XG4gIH1cbiAgdHJ5IHtcbiAgICBpZiAob3B0aW9ucyAmJiBoYXNPd24kMyhvcHRpb25zLCAnY29uc3RydWN0b3InKSAmJiBvcHRpb25zLmNvbnN0cnVjdG9yKSB7XG4gICAgICBpZiAoREVTQ1JJUFRPUlMkMSkgZGVmaW5lUHJvcGVydHkkMSh2YWx1ZSwgJ3Byb3RvdHlwZScsIHsgd3JpdGFibGU6IGZhbHNlIH0pO1xuICAgIC8vIGluIFY4IH4gQ2hyb21lIDUzLCBwcm90b3R5cGVzIG9mIHNvbWUgbWV0aG9kcywgbGlrZSBgQXJyYXkucHJvdG90eXBlLnZhbHVlc2AsIGFyZSBub24td3JpdGFibGVcbiAgICB9IGVsc2UgaWYgKHZhbHVlLnByb3RvdHlwZSkgdmFsdWUucHJvdG90eXBlID0gdW5kZWZpbmVkO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIHZhciBzdGF0ZSA9IGVuZm9yY2VJbnRlcm5hbFN0YXRlKHZhbHVlKTtcbiAgaWYgKCFoYXNPd24kMyhzdGF0ZSwgJ3NvdXJjZScpKSB7XG4gICAgc3RhdGUuc291cmNlID0gVEVNUExBVEUuam9pbih0eXBlb2YgbmFtZSA9PSAnc3RyaW5nJyA/IG5hbWUgOiAnJyk7XG4gIH0gcmV0dXJuIHZhbHVlO1xufTtcblxuLy8gYWRkIGZha2UgRnVuY3Rpb24jdG9TdHJpbmcgZm9yIGNvcnJlY3Qgd29yayB3cmFwcGVkIG1ldGhvZHMgLyBjb25zdHJ1Y3RvcnMgd2l0aCBtZXRob2RzIGxpa2UgTG9EYXNoIGlzTmF0aXZlXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXh0ZW5kLW5hdGl2ZSAtLSByZXF1aXJlZFxuRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gbWFrZUJ1aWx0SW4kMShmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuIGlzQ2FsbGFibGUkMyh0aGlzKSAmJiBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpLnNvdXJjZSB8fCBpbnNwZWN0U291cmNlKHRoaXMpO1xufSwgJ3RvU3RyaW5nJyk7XG5cbnZhciBpc0NhbGxhYmxlJDIgPSBpc0NhbGxhYmxlJGI7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUkMSA9IG9iamVjdERlZmluZVByb3BlcnR5O1xudmFyIG1ha2VCdWlsdEluID0gbWFrZUJ1aWx0SW4kMi5leHBvcnRzO1xudmFyIGRlZmluZUdsb2JhbFByb3BlcnR5JDEgPSBkZWZpbmVHbG9iYWxQcm9wZXJ0eSQzO1xuXG52YXIgZGVmaW5lQnVpbHRJbiQyID0gZnVuY3Rpb24gKE8sIGtleSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG4gIHZhciBzaW1wbGUgPSBvcHRpb25zLmVudW1lcmFibGU7XG4gIHZhciBuYW1lID0gb3B0aW9ucy5uYW1lICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm5hbWUgOiBrZXk7XG4gIGlmIChpc0NhbGxhYmxlJDIodmFsdWUpKSBtYWtlQnVpbHRJbih2YWx1ZSwgbmFtZSwgb3B0aW9ucyk7XG4gIGlmIChvcHRpb25zLmdsb2JhbCkge1xuICAgIGlmIChzaW1wbGUpIE9ba2V5XSA9IHZhbHVlO1xuICAgIGVsc2UgZGVmaW5lR2xvYmFsUHJvcGVydHkkMShrZXksIHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFvcHRpb25zLnVuc2FmZSkgZGVsZXRlIE9ba2V5XTtcbiAgICAgIGVsc2UgaWYgKE9ba2V5XSkgc2ltcGxlID0gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gICAgaWYgKHNpbXBsZSkgT1trZXldID0gdmFsdWU7XG4gICAgZWxzZSBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQxLmYoTywga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogIW9wdGlvbnMubm9uQ29uZmlndXJhYmxlLFxuICAgICAgd3JpdGFibGU6ICFvcHRpb25zLm5vbldyaXRhYmxlXG4gICAgfSk7XG4gIH0gcmV0dXJuIE87XG59O1xuXG52YXIgb2JqZWN0R2V0T3duUHJvcGVydHlOYW1lcyA9IHt9O1xuXG52YXIgY2VpbCA9IE1hdGguY2VpbDtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5cbi8vIGBNYXRoLnRydW5jYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbWF0aC50cnVuY1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tbWF0aC10cnVuYyAtLSBzYWZlXG52YXIgbWF0aFRydW5jID0gTWF0aC50cnVuYyB8fCBmdW5jdGlvbiB0cnVuYyh4KSB7XG4gIHZhciBuID0gK3g7XG4gIHJldHVybiAobiA+IDAgPyBmbG9vciA6IGNlaWwpKG4pO1xufTtcblxudmFyIHRydW5jID0gbWF0aFRydW5jO1xuXG4vLyBgVG9JbnRlZ2VyT3JJbmZpbml0eWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvaW50ZWdlcm9yaW5maW5pdHlcbnZhciB0b0ludGVnZXJPckluZmluaXR5JDIgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgdmFyIG51bWJlciA9ICthcmd1bWVudDtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcbiAgcmV0dXJuIG51bWJlciAhPT0gbnVtYmVyIHx8IG51bWJlciA9PT0gMCA/IDAgOiB0cnVuYyhudW1iZXIpO1xufTtcblxudmFyIHRvSW50ZWdlck9ySW5maW5pdHkkMSA9IHRvSW50ZWdlck9ySW5maW5pdHkkMjtcblxudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiQxID0gTWF0aC5taW47XG5cbi8vIEhlbHBlciBmb3IgYSBwb3B1bGFyIHJlcGVhdGluZyBjYXNlIG9mIHRoZSBzcGVjOlxuLy8gTGV0IGludGVnZXIgYmUgPyBUb0ludGVnZXIoaW5kZXgpLlxuLy8gSWYgaW50ZWdlciA8IDAsIGxldCByZXN1bHQgYmUgbWF4KChsZW5ndGggKyBpbnRlZ2VyKSwgMCk7IGVsc2UgbGV0IHJlc3VsdCBiZSBtaW4oaW50ZWdlciwgbGVuZ3RoKS5cbnZhciB0b0Fic29sdXRlSW5kZXgkMSA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XG4gIHZhciBpbnRlZ2VyID0gdG9JbnRlZ2VyT3JJbmZpbml0eSQxKGluZGV4KTtcbiAgcmV0dXJuIGludGVnZXIgPCAwID8gbWF4KGludGVnZXIgKyBsZW5ndGgsIDApIDogbWluJDEoaW50ZWdlciwgbGVuZ3RoKTtcbn07XG5cbnZhciB0b0ludGVnZXJPckluZmluaXR5ID0gdG9JbnRlZ2VyT3JJbmZpbml0eSQyO1xuXG52YXIgbWluID0gTWF0aC5taW47XG5cbi8vIGBUb0xlbmd0aGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvbGVuZ3RoXG52YXIgdG9MZW5ndGgkMSA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gYXJndW1lbnQgPiAwID8gbWluKHRvSW50ZWdlck9ySW5maW5pdHkoYXJndW1lbnQpLCAweDFGRkZGRkZGRkZGRkZGKSA6IDA7IC8vIDIgKiogNTMgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07XG5cbnZhciB0b0xlbmd0aCA9IHRvTGVuZ3RoJDE7XG5cbi8vIGBMZW5ndGhPZkFycmF5TGlrZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWxlbmd0aG9mYXJyYXlsaWtlXG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UkMSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIHRvTGVuZ3RoKG9iai5sZW5ndGgpO1xufTtcblxudmFyIHRvSW5kZXhlZE9iamVjdCQxID0gdG9JbmRleGVkT2JqZWN0JDM7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gdG9BYnNvbHV0ZUluZGV4JDE7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UgPSBsZW5ndGhPZkFycmF5TGlrZSQxO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLnsgaW5kZXhPZiwgaW5jbHVkZXMgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxudmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uIChJU19JTkNMVURFUykge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBlbCwgZnJvbUluZGV4KSB7XG4gICAgdmFyIE8gPSB0b0luZGV4ZWRPYmplY3QkMSgkdGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlKE8pO1xuICAgIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleChmcm9tSW5kZXgsIGxlbmd0aCk7XG4gICAgdmFyIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xuICAgIGlmIChJU19JTkNMVURFUyAmJiBlbCAhPSBlbCkgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSB7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xuICAgICAgaWYgKHZhbHVlICE9IHZhbHVlKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSNpbmRleE9mIGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgICBpZiAoKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pICYmIE9baW5kZXhdID09PSBlbCkgcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcblxudmFyIGFycmF5SW5jbHVkZXMgPSB7XG4gIC8vIGBBcnJheS5wcm90b3R5cGUuaW5jbHVkZXNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmNsdWRlc1xuICBpbmNsdWRlczogY3JlYXRlTWV0aG9kKHRydWUpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmluZGV4T2ZgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmRleG9mXG4gIGluZGV4T2Y6IGNyZWF0ZU1ldGhvZChmYWxzZSlcbn07XG5cbnZhciB1bmN1cnJ5VGhpcyQyID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBoYXNPd24kMiA9IGhhc093blByb3BlcnR5XzE7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gdG9JbmRleGVkT2JqZWN0JDM7XG52YXIgaW5kZXhPZiA9IGFycmF5SW5jbHVkZXMuaW5kZXhPZjtcbnZhciBoaWRkZW5LZXlzJDEgPSBoaWRkZW5LZXlzJDM7XG5cbnZhciBwdXNoID0gdW5jdXJyeVRoaXMkMihbXS5wdXNoKTtcblxudmFyIG9iamVjdEtleXNJbnRlcm5hbCA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWVzKSB7XG4gIHZhciBPID0gdG9JbmRleGVkT2JqZWN0KG9iamVjdCk7XG4gIHZhciBpID0gMDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBPKSAhaGFzT3duJDIoaGlkZGVuS2V5cyQxLCBrZXkpICYmIGhhc093biQyKE8sIGtleSkgJiYgcHVzaChyZXN1bHQsIGtleSk7XG4gIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIGlmIChoYXNPd24kMihPLCBrZXkgPSBuYW1lc1tpKytdKSkge1xuICAgIH5pbmRleE9mKHJlc3VsdCwga2V5KSB8fCBwdXNoKHJlc3VsdCwga2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gSUU4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG52YXIgZW51bUJ1Z0tleXMkMiA9IFtcbiAgJ2NvbnN0cnVjdG9yJyxcbiAgJ2hhc093blByb3BlcnR5JyxcbiAgJ2lzUHJvdG90eXBlT2YnLFxuICAncHJvcGVydHlJc0VudW1lcmFibGUnLFxuICAndG9Mb2NhbGVTdHJpbmcnLFxuICAndG9TdHJpbmcnLFxuICAndmFsdWVPZidcbl07XG5cbnZhciBpbnRlcm5hbE9iamVjdEtleXMkMSA9IG9iamVjdEtleXNJbnRlcm5hbDtcbnZhciBlbnVtQnVnS2V5cyQxID0gZW51bUJ1Z0tleXMkMjtcblxudmFyIGhpZGRlbktleXMgPSBlbnVtQnVnS2V5cyQxLmNvbmNhdCgnbGVuZ3RoJywgJ3Byb3RvdHlwZScpO1xuXG4vLyBgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHluYW1lc1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5bmFtZXMgLS0gc2FmZVxub2JqZWN0R2V0T3duUHJvcGVydHlOYW1lcy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKSB7XG4gIHJldHVybiBpbnRlcm5hbE9iamVjdEtleXMkMShPLCBoaWRkZW5LZXlzKTtcbn07XG5cbnZhciBvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSB7fTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5c3ltYm9scyAtLSBzYWZlXG5vYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbnZhciBnZXRCdWlsdEluID0gZ2V0QnVpbHRJbiQzO1xudmFyIHVuY3VycnlUaGlzJDEgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSQxID0gb2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGFuT2JqZWN0JDIgPSBhbk9iamVjdCQ0O1xuXG52YXIgY29uY2F0JDEgPSB1bmN1cnJ5VGhpcyQxKFtdLmNvbmNhdCk7XG5cbi8vIGFsbCBvYmplY3Qga2V5cywgaW5jbHVkZXMgbm9uLWVudW1lcmFibGUgYW5kIHN5bWJvbHNcbnZhciBvd25LZXlzJDEgPSBnZXRCdWlsdEluKCdSZWZsZWN0JywgJ293bktleXMnKSB8fCBmdW5jdGlvbiBvd25LZXlzKGl0KSB7XG4gIHZhciBrZXlzID0gZ2V0T3duUHJvcGVydHlOYW1lc01vZHVsZS5mKGFuT2JqZWN0JDIoaXQpKTtcbiAgdmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSQxLmY7XG4gIHJldHVybiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBjb25jYXQkMShrZXlzLCBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpKSA6IGtleXM7XG59O1xuXG52YXIgaGFzT3duJDEgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIG93bktleXMgPSBvd25LZXlzJDE7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlID0gb2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gb2JqZWN0RGVmaW5lUHJvcGVydHk7XG5cbnZhciBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzJDEgPSBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UsIGV4Y2VwdGlvbnMpIHtcbiAgdmFyIGtleXMgPSBvd25LZXlzKHNvdXJjZSk7XG4gIHZhciBkZWZpbmVQcm9wZXJ0eSA9IGRlZmluZVByb3BlcnR5TW9kdWxlLmY7XG4gIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUuZjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgaWYgKCFoYXNPd24kMSh0YXJnZXQsIGtleSkgJiYgIShleGNlcHRpb25zICYmIGhhc093biQxKGV4Y2VwdGlvbnMsIGtleSkpKSB7XG4gICAgICBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgZmFpbHMkMiA9IGZhaWxzJGE7XG52YXIgaXNDYWxsYWJsZSQxID0gaXNDYWxsYWJsZSRiO1xuXG52YXIgcmVwbGFjZW1lbnQgPSAvI3xcXC5wcm90b3R5cGVcXC4vO1xuXG52YXIgaXNGb3JjZWQkMSA9IGZ1bmN0aW9uIChmZWF0dXJlLCBkZXRlY3Rpb24pIHtcbiAgdmFyIHZhbHVlID0gZGF0YVtub3JtYWxpemUoZmVhdHVyZSldO1xuICByZXR1cm4gdmFsdWUgPT0gUE9MWUZJTEwgPyB0cnVlXG4gICAgOiB2YWx1ZSA9PSBOQVRJVkUgPyBmYWxzZVxuICAgIDogaXNDYWxsYWJsZSQxKGRldGVjdGlvbikgPyBmYWlscyQyKGRldGVjdGlvbilcbiAgICA6ICEhZGV0ZWN0aW9uO1xufTtcblxudmFyIG5vcm1hbGl6ZSA9IGlzRm9yY2VkJDEubm9ybWFsaXplID0gZnVuY3Rpb24gKHN0cmluZykge1xuICByZXR1cm4gU3RyaW5nKHN0cmluZykucmVwbGFjZShyZXBsYWNlbWVudCwgJy4nKS50b0xvd2VyQ2FzZSgpO1xufTtcblxudmFyIGRhdGEgPSBpc0ZvcmNlZCQxLmRhdGEgPSB7fTtcbnZhciBOQVRJVkUgPSBpc0ZvcmNlZCQxLk5BVElWRSA9ICdOJztcbnZhciBQT0xZRklMTCA9IGlzRm9yY2VkJDEuUE9MWUZJTEwgPSAnUCc7XG5cbnZhciBpc0ZvcmNlZF8xID0gaXNGb3JjZWQkMTtcblxudmFyIGdsb2JhbCQxID0gZ2xvYmFsJGE7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gb2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLmY7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDI7XG52YXIgZGVmaW5lQnVpbHRJbiQxID0gZGVmaW5lQnVpbHRJbiQyO1xudmFyIGRlZmluZUdsb2JhbFByb3BlcnR5ID0gZGVmaW5lR2xvYmFsUHJvcGVydHkkMztcbnZhciBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzID0gY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyQxO1xudmFyIGlzRm9yY2VkID0gaXNGb3JjZWRfMTtcblxuLypcbiAgb3B0aW9ucy50YXJnZXQgICAgICAgICAtIG5hbWUgb2YgdGhlIHRhcmdldCBvYmplY3RcbiAgb3B0aW9ucy5nbG9iYWwgICAgICAgICAtIHRhcmdldCBpcyB0aGUgZ2xvYmFsIG9iamVjdFxuICBvcHRpb25zLnN0YXQgICAgICAgICAgIC0gZXhwb3J0IGFzIHN0YXRpYyBtZXRob2RzIG9mIHRhcmdldFxuICBvcHRpb25zLnByb3RvICAgICAgICAgIC0gZXhwb3J0IGFzIHByb3RvdHlwZSBtZXRob2RzIG9mIHRhcmdldFxuICBvcHRpb25zLnJlYWwgICAgICAgICAgIC0gcmVhbCBwcm90b3R5cGUgbWV0aG9kIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cbiAgb3B0aW9ucy5mb3JjZWQgICAgICAgICAtIGV4cG9ydCBldmVuIGlmIHRoZSBuYXRpdmUgZmVhdHVyZSBpcyBhdmFpbGFibGVcbiAgb3B0aW9ucy5iaW5kICAgICAgICAgICAtIGJpbmQgbWV0aG9kcyB0byB0aGUgdGFyZ2V0LCByZXF1aXJlZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMud3JhcCAgICAgICAgICAgLSB3cmFwIGNvbnN0cnVjdG9ycyB0byBwcmV2ZW50aW5nIGdsb2JhbCBwb2xsdXRpb24sIHJlcXVpcmVkIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cbiAgb3B0aW9ucy51bnNhZmUgICAgICAgICAtIHVzZSB0aGUgc2ltcGxlIGFzc2lnbm1lbnQgb2YgcHJvcGVydHkgaW5zdGVhZCBvZiBkZWxldGUgKyBkZWZpbmVQcm9wZXJ0eVxuICBvcHRpb25zLnNoYW0gICAgICAgICAgIC0gYWRkIGEgZmxhZyB0byBub3QgY29tcGxldGVseSBmdWxsIHBvbHlmaWxsc1xuICBvcHRpb25zLmVudW1lcmFibGUgICAgIC0gZXhwb3J0IGFzIGVudW1lcmFibGUgcHJvcGVydHlcbiAgb3B0aW9ucy5kb250Q2FsbEdldFNldCAtIHByZXZlbnQgY2FsbGluZyBhIGdldHRlciBvbiB0YXJnZXRcbiAgb3B0aW9ucy5uYW1lICAgICAgICAgICAtIHRoZSAubmFtZSBvZiB0aGUgZnVuY3Rpb24gaWYgaXQgZG9lcyBub3QgbWF0Y2ggdGhlIGtleVxuKi9cbnZhciBfZXhwb3J0ID0gZnVuY3Rpb24gKG9wdGlvbnMsIHNvdXJjZSkge1xuICB2YXIgVEFSR0VUID0gb3B0aW9ucy50YXJnZXQ7XG4gIHZhciBHTE9CQUwgPSBvcHRpb25zLmdsb2JhbDtcbiAgdmFyIFNUQVRJQyA9IG9wdGlvbnMuc3RhdDtcbiAgdmFyIEZPUkNFRCwgdGFyZ2V0LCBrZXksIHRhcmdldFByb3BlcnR5LCBzb3VyY2VQcm9wZXJ0eSwgZGVzY3JpcHRvcjtcbiAgaWYgKEdMT0JBTCkge1xuICAgIHRhcmdldCA9IGdsb2JhbCQxO1xuICB9IGVsc2UgaWYgKFNUQVRJQykge1xuICAgIHRhcmdldCA9IGdsb2JhbCQxW1RBUkdFVF0gfHwgZGVmaW5lR2xvYmFsUHJvcGVydHkoVEFSR0VULCB7fSk7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0ID0gKGdsb2JhbCQxW1RBUkdFVF0gfHwge30pLnByb3RvdHlwZTtcbiAgfVxuICBpZiAodGFyZ2V0KSBmb3IgKGtleSBpbiBzb3VyY2UpIHtcbiAgICBzb3VyY2VQcm9wZXJ0eSA9IHNvdXJjZVtrZXldO1xuICAgIGlmIChvcHRpb25zLmRvbnRDYWxsR2V0U2V0KSB7XG4gICAgICBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KTtcbiAgICAgIHRhcmdldFByb3BlcnR5ID0gZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLnZhbHVlO1xuICAgIH0gZWxzZSB0YXJnZXRQcm9wZXJ0eSA9IHRhcmdldFtrZXldO1xuICAgIEZPUkNFRCA9IGlzRm9yY2VkKEdMT0JBTCA/IGtleSA6IFRBUkdFVCArIChTVEFUSUMgPyAnLicgOiAnIycpICsga2V5LCBvcHRpb25zLmZvcmNlZCk7XG4gICAgLy8gY29udGFpbmVkIGluIHRhcmdldFxuICAgIGlmICghRk9SQ0VEICYmIHRhcmdldFByb3BlcnR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0eXBlb2Ygc291cmNlUHJvcGVydHkgPT0gdHlwZW9mIHRhcmdldFByb3BlcnR5KSBjb250aW51ZTtcbiAgICAgIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMoc291cmNlUHJvcGVydHksIHRhcmdldFByb3BlcnR5KTtcbiAgICB9XG4gICAgLy8gYWRkIGEgZmxhZyB0byBub3QgY29tcGxldGVseSBmdWxsIHBvbHlmaWxsc1xuICAgIGlmIChvcHRpb25zLnNoYW0gfHwgKHRhcmdldFByb3BlcnR5ICYmIHRhcmdldFByb3BlcnR5LnNoYW0pKSB7XG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoc291cmNlUHJvcGVydHksICdzaGFtJywgdHJ1ZSk7XG4gICAgfVxuICAgIGRlZmluZUJ1aWx0SW4kMSh0YXJnZXQsIGtleSwgc291cmNlUHJvcGVydHksIG9wdGlvbnMpO1xuICB9XG59O1xuXG52YXIgaW50ZXJuYWxPYmplY3RLZXlzID0gb2JqZWN0S2V5c0ludGVybmFsO1xudmFyIGVudW1CdWdLZXlzID0gZW51bUJ1Z0tleXMkMjtcblxuLy8gYE9iamVjdC5rZXlzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmtleXNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1rZXlzIC0tIHNhZmVcbnZhciBvYmplY3RLZXlzJDEgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pIHtcbiAgcmV0dXJuIGludGVybmFsT2JqZWN0S2V5cyhPLCBlbnVtQnVnS2V5cyk7XG59O1xuXG52YXIgREVTQ1JJUFRPUlMgPSBkZXNjcmlwdG9ycztcbnZhciB1bmN1cnJ5VGhpcyA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgY2FsbCQxID0gZnVuY3Rpb25DYWxsO1xudmFyIGZhaWxzJDEgPSBmYWlscyRhO1xudmFyIG9iamVjdEtleXMgPSBvYmplY3RLZXlzJDE7XG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlID0gb2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlID0gb2JqZWN0UHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgdG9PYmplY3QgPSB0b09iamVjdCQyO1xudmFyIEluZGV4ZWRPYmplY3QgPSBpbmRleGVkT2JqZWN0O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtYXNzaWduIC0tIHNhZmVcbnZhciAkYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xudmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIGNvbmNhdCA9IHVuY3VycnlUaGlzKFtdLmNvbmNhdCk7XG5cbi8vIGBPYmplY3QuYXNzaWduYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmFzc2lnblxudmFyIG9iamVjdEFzc2lnbiA9ICEkYXNzaWduIHx8IGZhaWxzJDEoZnVuY3Rpb24gKCkge1xuICAvLyBzaG91bGQgaGF2ZSBjb3JyZWN0IG9yZGVyIG9mIG9wZXJhdGlvbnMgKEVkZ2UgYnVnKVxuICBpZiAoREVTQ1JJUFRPUlMgJiYgJGFzc2lnbih7IGI6IDEgfSwgJGFzc2lnbihkZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGRlZmluZVByb3BlcnR5KHRoaXMsICdiJywge1xuICAgICAgICB2YWx1ZTogMyxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfSksIHsgYjogMiB9KSkuYiAhPT0gMSkgcmV0dXJuIHRydWU7XG4gIC8vIHNob3VsZCB3b3JrIHdpdGggc3ltYm9scyBhbmQgc2hvdWxkIGhhdmUgZGV0ZXJtaW5pc3RpYyBwcm9wZXJ0eSBvcmRlciAoVjggYnVnKVxuICB2YXIgQSA9IHt9O1xuICB2YXIgQiA9IHt9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1zeW1ib2wgLS0gc2FmZVxuICB2YXIgc3ltYm9sID0gU3ltYm9sKCk7XG4gIHZhciBhbHBoYWJldCA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdCc7XG4gIEFbc3ltYm9sXSA9IDc7XG4gIGFscGhhYmV0LnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChjaHIpIHsgQltjaHJdID0gY2hyOyB9KTtcbiAgcmV0dXJuICRhc3NpZ24oe30sIEEpW3N5bWJvbF0gIT0gNyB8fCBvYmplY3RLZXlzKCRhc3NpZ24oe30sIEIpKS5qb2luKCcnKSAhPSBhbHBoYWJldDtcbn0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnMgLS0gcmVxdWlyZWQgZm9yIGAubGVuZ3RoYFxuICB2YXIgVCA9IHRvT2JqZWN0KHRhcmdldCk7XG4gIHZhciBhcmd1bWVudHNMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSAxO1xuICB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlLmY7XG4gIHZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlLmY7XG4gIHdoaWxlIChhcmd1bWVudHNMZW5ndGggPiBpbmRleCkge1xuICAgIHZhciBTID0gSW5kZXhlZE9iamVjdChhcmd1bWVudHNbaW5kZXgrK10pO1xuICAgIHZhciBrZXlzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzID8gY29uY2F0KG9iamVjdEtleXMoUyksIGdldE93blByb3BlcnR5U3ltYm9scyhTKSkgOiBvYmplY3RLZXlzKFMpO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgaiA9IDA7XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAobGVuZ3RoID4gaikge1xuICAgICAga2V5ID0ga2V5c1tqKytdO1xuICAgICAgaWYgKCFERVNDUklQVE9SUyB8fCBjYWxsJDEocHJvcGVydHlJc0VudW1lcmFibGUsIFMsIGtleSkpIFRba2V5XSA9IFNba2V5XTtcbiAgICB9XG4gIH0gcmV0dXJuIFQ7XG59IDogJGFzc2lnbjtcblxudmFyICQgPSBfZXhwb3J0O1xudmFyIGFzc2lnbiA9IG9iamVjdEFzc2lnbjtcblxuLy8gYE9iamVjdC5hc3NpZ25gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuYXNzaWduXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtYXNzaWduIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4kKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgYXJpdHk6IDIsIGZvcmNlZDogT2JqZWN0LmFzc2lnbiAhPT0gYXNzaWduIH0sIHtcbiAgYXNzaWduOiBhc3NpZ25cbn0pO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHJcbmZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbnR5cGVvZiBTdXBwcmVzc2VkRXJyb3IgPT09IFwiZnVuY3Rpb25cIiA/IFN1cHByZXNzZWRFcnJvciA6IGZ1bmN0aW9uIChlcnJvciwgc3VwcHJlc3NlZCwgbWVzc2FnZSkge1xyXG4gICAgdmFyIGUgPSBuZXcgRXJyb3IobWVzc2FnZSk7XHJcbiAgICByZXR1cm4gZS5uYW1lID0gXCJTdXBwcmVzc2VkRXJyb3JcIiwgZS5lcnJvciA9IGVycm9yLCBlLnN1cHByZXNzZWQgPSBzdXBwcmVzc2VkLCBlO1xyXG59O1xuXG52YXIgd2VsbEtub3duU3ltYm9sJDEgPSB3ZWxsS25vd25TeW1ib2wkMztcblxudmFyIFRPX1NUUklOR19UQUckMSA9IHdlbGxLbm93blN5bWJvbCQxKCd0b1N0cmluZ1RhZycpO1xudmFyIHRlc3QgPSB7fTtcblxudGVzdFtUT19TVFJJTkdfVEFHJDFdID0gJ3onO1xuXG52YXIgdG9TdHJpbmdUYWdTdXBwb3J0ID0gU3RyaW5nKHRlc3QpID09PSAnW29iamVjdCB6XSc7XG5cbnZhciBUT19TVFJJTkdfVEFHX1NVUFBPUlQgPSB0b1N0cmluZ1RhZ1N1cHBvcnQ7XG52YXIgaXNDYWxsYWJsZSA9IGlzQ2FsbGFibGUkYjtcbnZhciBjbGFzc29mUmF3ID0gY2xhc3NvZlJhdyQxO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHdlbGxLbm93blN5bWJvbCQzO1xuXG52YXIgVE9fU1RSSU5HX1RBRyA9IHdlbGxLbm93blN5bWJvbCgndG9TdHJpbmdUYWcnKTtcbnZhciAkT2JqZWN0ID0gT2JqZWN0O1xuXG4vLyBFUzMgd3JvbmcgaGVyZVxudmFyIENPUlJFQ1RfQVJHVU1FTlRTID0gY2xhc3NvZlJhdyhmdW5jdGlvbiAoKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPT0gJ0FyZ3VtZW50cyc7XG5cbi8vIGZhbGxiYWNrIGZvciBJRTExIFNjcmlwdCBBY2Nlc3MgRGVuaWVkIGVycm9yXG52YXIgdHJ5R2V0ID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaXRba2V5XTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxufTtcblxuLy8gZ2V0dGluZyB0YWcgZnJvbSBFUzYrIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYFxudmFyIGNsYXNzb2YkMSA9IFRPX1NUUklOR19UQUdfU1VQUE9SVCA/IGNsYXNzb2ZSYXcgOiBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIE8sIHRhZywgcmVzdWx0O1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCdcbiAgICAvLyBAQHRvU3RyaW5nVGFnIGNhc2VcbiAgICA6IHR5cGVvZiAodGFnID0gdHJ5R2V0KE8gPSAkT2JqZWN0KGl0KSwgVE9fU1RSSU5HX1RBRykpID09ICdzdHJpbmcnID8gdGFnXG4gICAgLy8gYnVpbHRpblRhZyBjYXNlXG4gICAgOiBDT1JSRUNUX0FSR1VNRU5UUyA/IGNsYXNzb2ZSYXcoTylcbiAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG4gICAgOiAocmVzdWx0ID0gY2xhc3NvZlJhdyhPKSkgPT0gJ09iamVjdCcgJiYgaXNDYWxsYWJsZShPLmNhbGxlZSkgPyAnQXJndW1lbnRzJyA6IHJlc3VsdDtcbn07XG5cbnZhciBjbGFzc29mID0gY2xhc3NvZiQxO1xuXG52YXIgJFN0cmluZyA9IFN0cmluZztcblxudmFyIHRvU3RyaW5nID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmIChjbGFzc29mKGFyZ3VtZW50KSA9PT0gJ1N5bWJvbCcpIHRocm93IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgYSBTeW1ib2wgdmFsdWUgdG8gYSBzdHJpbmcnKTtcbiAgcmV0dXJuICRTdHJpbmcoYXJndW1lbnQpO1xufTtcblxudmFyIGFuT2JqZWN0JDEgPSBhbk9iamVjdCQ0O1xuXG4vLyBgUmVnRXhwLnByb3RvdHlwZS5mbGFnc2AgZ2V0dGVyIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWdldC1yZWdleHAucHJvdG90eXBlLmZsYWdzXG52YXIgcmVnZXhwRmxhZ3MgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0aGF0ID0gYW5PYmplY3QkMSh0aGlzKTtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuICBpZiAodGhhdC5oYXNJbmRpY2VzKSByZXN1bHQgKz0gJ2QnO1xuICBpZiAodGhhdC5nbG9iYWwpIHJlc3VsdCArPSAnZyc7XG4gIGlmICh0aGF0Lmlnbm9yZUNhc2UpIHJlc3VsdCArPSAnaSc7XG4gIGlmICh0aGF0Lm11bHRpbGluZSkgcmVzdWx0ICs9ICdtJztcbiAgaWYgKHRoYXQuZG90QWxsKSByZXN1bHQgKz0gJ3MnO1xuICBpZiAodGhhdC51bmljb2RlKSByZXN1bHQgKz0gJ3UnO1xuICBpZiAodGhhdC51bmljb2RlU2V0cykgcmVzdWx0ICs9ICd2JztcbiAgaWYgKHRoYXQuc3RpY2t5KSByZXN1bHQgKz0gJ3knO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxudmFyIGNhbGwgPSBmdW5jdGlvbkNhbGw7XG52YXIgaGFzT3duID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBpc1Byb3RvdHlwZU9mID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbnZhciByZWdFeHBGbGFncyA9IHJlZ2V4cEZsYWdzO1xuXG52YXIgUmVnRXhwUHJvdG90eXBlJDEgPSBSZWdFeHAucHJvdG90eXBlO1xuXG52YXIgcmVnZXhwR2V0RmxhZ3MgPSBmdW5jdGlvbiAoUikge1xuICB2YXIgZmxhZ3MgPSBSLmZsYWdzO1xuICByZXR1cm4gZmxhZ3MgPT09IHVuZGVmaW5lZCAmJiAhKCdmbGFncycgaW4gUmVnRXhwUHJvdG90eXBlJDEpICYmICFoYXNPd24oUiwgJ2ZsYWdzJykgJiYgaXNQcm90b3R5cGVPZihSZWdFeHBQcm90b3R5cGUkMSwgUilcbiAgICA/IGNhbGwocmVnRXhwRmxhZ3MsIFIpIDogZmxhZ3M7XG59O1xuXG52YXIgUFJPUEVSX0ZVTkNUSU9OX05BTUUgPSBmdW5jdGlvbk5hbWUuUFJPUEVSO1xudmFyIGRlZmluZUJ1aWx0SW4gPSBkZWZpbmVCdWlsdEluJDI7XG52YXIgYW5PYmplY3QgPSBhbk9iamVjdCQ0O1xudmFyICR0b1N0cmluZyA9IHRvU3RyaW5nO1xudmFyIGZhaWxzID0gZmFpbHMkYTtcbnZhciBnZXRSZWdFeHBGbGFncyA9IHJlZ2V4cEdldEZsYWdzO1xuXG52YXIgVE9fU1RSSU5HID0gJ3RvU3RyaW5nJztcbnZhciBSZWdFeHBQcm90b3R5cGUgPSBSZWdFeHAucHJvdG90eXBlO1xudmFyIG4kVG9TdHJpbmcgPSBSZWdFeHBQcm90b3R5cGVbVE9fU1RSSU5HXTtcblxudmFyIE5PVF9HRU5FUklDID0gZmFpbHMoZnVuY3Rpb24gKCkgeyByZXR1cm4gbiRUb1N0cmluZy5jYWxsKHsgc291cmNlOiAnYScsIGZsYWdzOiAnYicgfSkgIT0gJy9hL2InOyB9KTtcbi8vIEZGNDQtIFJlZ0V4cCN0b1N0cmluZyBoYXMgYSB3cm9uZyBuYW1lXG52YXIgSU5DT1JSRUNUX05BTUUgPSBQUk9QRVJfRlVOQ1RJT05fTkFNRSAmJiBuJFRvU3RyaW5nLm5hbWUgIT0gVE9fU1RSSU5HO1xuXG4vLyBgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZ2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXJlZ2V4cC5wcm90b3R5cGUudG9zdHJpbmdcbmlmIChOT1RfR0VORVJJQyB8fCBJTkNPUlJFQ1RfTkFNRSkge1xuICBkZWZpbmVCdWlsdEluKFJlZ0V4cC5wcm90b3R5cGUsIFRPX1NUUklORywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgdmFyIFIgPSBhbk9iamVjdCh0aGlzKTtcbiAgICB2YXIgcGF0dGVybiA9ICR0b1N0cmluZyhSLnNvdXJjZSk7XG4gICAgdmFyIGZsYWdzID0gJHRvU3RyaW5nKGdldFJlZ0V4cEZsYWdzKFIpKTtcbiAgICByZXR1cm4gJy8nICsgcGF0dGVybiArICcvJyArIGZsYWdzO1xuICB9LCB7IHVuc2FmZTogdHJ1ZSB9KTtcbn1cblxuY29uc3QgaW5pdEhlcmVXYWxsZXQgPSBjb25maWcgPT4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gIGNvbnN0IHtcbiAgICBzdG9yZSxcbiAgICBsb2dnZXIsXG4gICAgZW1pdHRlcixcbiAgICBvcHRpb25zLFxuICAgIGRlZmF1bHRQcm92aWRlcixcbiAgICBkZWZhdWx0U3RyYXRlZ3lcbiAgfSA9IGNvbmZpZztcbiAgY29uc3QgaGVyZSA9IG5ldyBIZXJlV2FsbGV0KHtcbiAgICBuZXR3b3JrSWQ6IG9wdGlvbnMubmV0d29yay5uZXR3b3JrSWQsXG4gICAgbm9kZVVybDogb3B0aW9ucy5uZXR3b3JrLm5vZGVVcmwsXG4gICAgZGVmYXVsdFByb3ZpZGVyLFxuICAgIGRlZmF1bHRTdHJhdGVneVxuICB9KTtcbiAgZnVuY3Rpb24gZ2V0QWNjb3VudHMoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGxvZ2dlci5sb2coXCJIZXJlV2FsbGV0OmdldEFjY291bnRzXCIpO1xuICAgICAgY29uc3QgYWNjb3VudElkcyA9IHlpZWxkIGhlcmUuZ2V0QWNjb3VudHMoKTtcbiAgICAgIGNvbnN0IGFjY291bnRzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFjY291bnRJZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYWNjb3VudHMucHVzaCh7XG4gICAgICAgICAgYWNjb3VudElkOiBhY2NvdW50SWRzW2ldLFxuICAgICAgICAgIHB1YmxpY0tleTogKHlpZWxkIGhlcmUuc2lnbmVyLmdldFB1YmxpY0tleShhY2NvdW50SWRzW2ldLCBvcHRpb25zLm5ldHdvcmsubmV0d29ya0lkKSkudG9TdHJpbmcoKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2NvdW50cztcbiAgICB9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGdldCBuZXR3b3JrSWQoKSB7XG4gICAgICByZXR1cm4gaGVyZS5uZXR3b3JrSWQ7XG4gICAgfSxcbiAgICBidWlsZEltcG9ydEFjY291bnRzVXJsKCkge1xuICAgICAgcmV0dXJuIGBodHRwczovL215LmhlcmV3YWxsZXQuYXBwL2ltcG9ydD9uZXR3b3JrPSR7b3B0aW9ucy5uZXR3b3JrLm5ldHdvcmtJZH1gO1xuICAgIH0sXG4gICAgYWNjb3VudChpZCkge1xuICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhcIkhlcmVXYWxsZXQ6YWNjb3VudFwiKTtcbiAgICAgICAgcmV0dXJuIHlpZWxkIGhlcmUuYWNjb3VudChpZCk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHN3aXRjaEFjY291bnQoaWQpIHtcbiAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGxvZ2dlci5sb2coXCJIZXJlV2FsbGV0OnN3aXRjaEFjY291bnRcIik7XG4gICAgICAgIHlpZWxkIGhlcmUuc3dpdGNoQWNjb3VudChpZCk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGdldEFjY291bnRJZCgpIHtcbiAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGxvZ2dlci5sb2coXCJIZXJlV2FsbGV0OmdldEFjY291bnRJZFwiKTtcbiAgICAgICAgcmV0dXJuIHlpZWxkIGhlcmUuZ2V0QWNjb3VudElkKCk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGlzU2lnbmVkSW4oKSB7XG4gICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBsb2dnZXIubG9nKFwiSGVyZVdhbGxldDppc1NpZ25lZEluXCIpO1xuICAgICAgICByZXR1cm4geWllbGQgaGVyZS5pc1NpZ25lZEluKCk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHNpZ25JbihkYXRhKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBsb2dnZXIubG9nKFwiSGVyZVdhbGxldDpzaWduSW5cIik7XG4gICAgICAgIGNvbnN0IGlzSW5qZWN0ZWQgPSB5aWVsZCB3YWl0SW5qZWN0ZWRIZXJlV2FsbGV0O1xuICAgICAgICBpZiAoIWlzSW5qZWN0ZWQpIHtcbiAgICAgICAgICBjb25zdCBjb250cmFjdElkID0gZGF0YS5jb250cmFjdElkICE9PSBcIlwiID8gZGF0YS5jb250cmFjdElkIDogdW5kZWZpbmVkO1xuICAgICAgICAgIHlpZWxkIGhlcmUuc2lnbkluKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGF0YSksIHtcbiAgICAgICAgICAgIGNvbnRyYWN0SWQ6IGNvbnRyYWN0SWRcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZW1pdHRlci5lbWl0KFwic2lnbmVkSW5cIiwge1xuICAgICAgICAgIGNvbnRyYWN0SWQ6IGRhdGEuY29udHJhY3RJZCxcbiAgICAgICAgICBtZXRob2ROYW1lczogKF9hID0gZGF0YS5tZXRob2ROYW1lcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10sXG4gICAgICAgICAgYWNjb3VudHM6IHlpZWxkIGdldEFjY291bnRzKClcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB5aWVsZCBnZXRBY2NvdW50cygpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBnZXRIZXJlQmFsYW5jZSgpIHtcbiAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGxvZ2dlci5sb2coXCJIZXJlV2FsbGV0OmdldEhlcmVCYWxhbmNlXCIpO1xuICAgICAgICByZXR1cm4geWllbGQgaGVyZS5nZXRIZXJlQmFsYW5jZSgpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBnZXRBdmFpbGFibGVCYWxhbmNlKCkge1xuICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhcIkhlcmVXYWxsZXQ6Z2V0QXZhaWxhYmxlQmFsYW5jZVwiKTtcbiAgICAgICAgcmV0dXJuIHlpZWxkIGhlcmUuZ2V0QXZhaWxhYmxlQmFsYW5jZSgpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBzaWduT3V0KCkge1xuICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhcIkhlcmVXYWxsZXQ6c2lnbk91dFwiKTtcbiAgICAgICAgeWllbGQgaGVyZS5zaWduT3V0KCk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGdldEFjY291bnRzKCkge1xuICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgcmV0dXJuIGdldEFjY291bnRzKCk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHNpZ25BbmRTZW5kVHJhbnNhY3Rpb24oZGF0YSkge1xuICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhcIkhlcmVXYWxsZXQ6c2lnbkFuZFNlbmRUcmFuc2FjdGlvblwiLCBkYXRhKTtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGNvbnRyYWN0XG4gICAgICAgIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICByZXR1cm4geWllbGQgaGVyZS5zaWduQW5kU2VuZFRyYW5zYWN0aW9uKE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgIHJlY2VpdmVySWQ6IGNvbnRyYWN0ID09PSBudWxsIHx8IGNvbnRyYWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb250cmFjdC5jb250cmFjdElkXG4gICAgICAgIH0sIGRhdGEpKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgdmVyaWZ5T3duZXIoKSB7XG4gICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICB0aHJvdyBFcnJvcihcIkhlcmVXYWxsZXQ6dmVyaWZ5T3duZXIgaXMgZGVwcmVjYXRlZCwgdXNlIHNpZ25NZXNzYWdlIG1ldGhvZCB3aXRoIGltcGxlbWVudGF0aW9uIE5FUDA0MTMgU3RhbmRhcmRcIik7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHNpZ25NZXNzYWdlKGRhdGEpIHtcbiAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGxvZ2dlci5sb2coXCJIZXJlV2FsbGV0OnNpZ25NZXNzYWdlXCIsIGRhdGEpO1xuICAgICAgICByZXR1cm4geWllbGQgaGVyZS5zaWduTWVzc2FnZShkYXRhKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgc2lnbkFuZFNlbmRUcmFuc2FjdGlvbnMoZGF0YSkge1xuICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhcIkhlcmVXYWxsZXQ6c2lnbkFuZFNlbmRUcmFuc2FjdGlvbnNcIiwgZGF0YSk7XG4gICAgICAgIHJldHVybiB5aWVsZCBoZXJlLnNpZ25BbmRTZW5kVHJhbnNhY3Rpb25zKGRhdGEpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xufSk7XG5cbnZhciBpY29uID0gXCJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlOREFpSUdobGFXZG9kRDBpTkRBaUlIWnBaWGRDYjNnOUlqQWdNQ0EwTUNBME1DSWdabWxzYkQwaWJtOXVaU0lnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JajRLUEhCaGRHZ2dabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJqYkdsd0xYSjFiR1U5SW1WMlpXNXZaR1FpSUdROUlrMHhPUzQzTXpNMUlERXhMalk0TXpGTU1qRXVOekE0T1NBNFRESTBMakk1T0RNZ01UWXVOamMyTmt3eU1DNDBNVFlnTVRRdU9USXhOVXd4T1M0M016TTFJREV4TGpZNE16RmFUVFV1TnpZek9EZ2dNVFV1TlRRd09Vd3pMamMxTlRZeUlERTVMakUyTWpGTU9TNDRPVFl3TlNBeU1pNHhOall4VERFNExqTTBOek1nTWpFdU5UZ3lPRXcxTGpjMk16ZzRJREUxTGpVME1EbGFUVFF1TmpRME5qUWdNakl1TXpZNU5Fd3lMalkwT0RZMUlESTFMamszTVROTU1UUXVPVEE0TXlBek1pNHdOVGMxVERNMUxqTXpPRGdnTXpBdU9ERTNORXd6Tnk0ek16UTRJREkzTGpJeE5UUk1NVFl1T1RBME15QXlPQzQwTlRVM1REUXVOalEwTmpRZ01qSXVNelk1TkZvaUlHWnBiR3c5SWlNeVF6TXdNelFpTHo0S1BIQmhkR2dnWkQwaVRUTTNMak16TlRrZ01qY3VNakUxTjB3eE5pNDVNVEV5SURJNExqUTFOakZNTkM0MU5EWXpNeUF5TWk0ek5UVTBUREUzTGprek5UZ2dNakV1TlRRMU0wdzFMamMyTXpnM0lERTFMalUwTURsTU1URXVOelF4SURFd0xqUTNPRFpNTWpRdU1UUXdNU0F4Tmk0MU56WXpUREl4TGpjd09TQTRURE16TGpVMU55QXhNeTQ0TVV3ek55NHpNelU1SURJM0xqSXhOVGRhSWlCbWFXeHNQU0lqUmtSQ1JqRkRJaTgrQ2p3dmMzWm5QZ289XCI7XG5cbmZ1bmN0aW9uIHNldHVwSGVyZVdhbGxldCh7XG4gIGRlcHJlY2F0ZWQgPSBmYWxzZSxcbiAgaWNvblVybCA9IGljb24sXG4gIGRlZmF1bHRTdHJhdGVneSxcbiAgZGVmYXVsdFByb3ZpZGVyXG59ID0ge30pIHtcbiAgcmV0dXJuICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICBjb25zdCBpc0luamVjdGVkID0geWllbGQgd2FpdEluamVjdGVkSGVyZVdhbGxldDtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IFwiaGVyZS13YWxsZXRcIixcbiAgICAgIHR5cGU6IFwiaW5qZWN0ZWRcIixcbiAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgIG5hbWU6IFwiSGVyZSBXYWxsZXRcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiTW9iaWxlIHdhbGxldCBmb3IgTkVBUiBQcm90b2NvbFwiLFxuICAgICAgICB1c2VVcmxBY2NvdW50SW1wb3J0OiB0cnVlLFxuICAgICAgICBkb3dubG9hZFVybDogXCJodHRwczovL2hlcmV3YWxsZXQuYXBwXCIsXG4gICAgICAgIHRvcExldmVsSW5qZWN0ZWQ6IGlzSW5qZWN0ZWQgIT0gbnVsbCxcbiAgICAgICAgaWNvblVybCxcbiAgICAgICAgZGVwcmVjYXRlZCxcbiAgICAgICAgYXZhaWxhYmxlOiB0cnVlXG4gICAgICB9LFxuICAgICAgaW5pdDogY29uZmlnID0+IGluaXRIZXJlV2FsbGV0KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnKSwge1xuICAgICAgICBkZWZhdWx0U3RyYXRlZ3ksXG4gICAgICAgIGRlZmF1bHRQcm92aWRlclxuICAgICAgfSkpXG4gICAgfTtcbiAgfSk7XG59XG5cbmV4cG9ydCB7IHNldHVwSGVyZVdhbGxldCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@near-wallet-selector/here-wallet/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@near-wallet-selector/modal-ui/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@near-wallet-selector/modal-ui/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   setupModal: () => (/* binding */ setupModal)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react_dom_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom/client */ \"(ssr)/./node_modules/next/dist/compiled/react-dom/client.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @near-wallet-selector/core */ \"(ssr)/./node_modules/@near-wallet-selector/core/index.cjs\");\n/* harmony import */ var qrcode__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! qrcode */ \"(ssr)/./node_modules/qrcode/lib/index.js\");\n/* harmony import */ var copy_to_clipboard__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! copy-to-clipboard */ \"(ssr)/./node_modules/copy-to-clipboard/index.js\");\n\n\n\n\n\n\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\n\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nvar fails$h = function (exec) {\n  try {\n    return !!exec();\n  } catch (error) {\n    return true;\n  }\n};\n\nvar fails$g = fails$h;\n\nvar functionBindNative = !fails$g(function () {\n  // eslint-disable-next-line es-x/no-function-prototype-bind -- safe\n  var test = (function () { /* empty */ }).bind();\n  // eslint-disable-next-line no-prototype-builtins -- safe\n  return typeof test != 'function' || test.hasOwnProperty('prototype');\n});\n\nvar NATIVE_BIND$3 = functionBindNative;\n\nvar FunctionPrototype$2 = Function.prototype;\nvar bind$5 = FunctionPrototype$2.bind;\nvar call$f = FunctionPrototype$2.call;\nvar uncurryThis$h = NATIVE_BIND$3 && bind$5.bind(call$f, call$f);\n\nvar functionUncurryThis = NATIVE_BIND$3 ? function (fn) {\n  return fn && uncurryThis$h(fn);\n} : function (fn) {\n  return fn && function () {\n    return call$f.apply(fn, arguments);\n  };\n};\n\nvar uncurryThis$g = functionUncurryThis;\n\nvar toString$5 = uncurryThis$g({}.toString);\nvar stringSlice$1 = uncurryThis$g(''.slice);\n\nvar classofRaw$1 = function (it) {\n  return stringSlice$1(toString$5(it), 8, -1);\n};\n\nvar uncurryThis$f = functionUncurryThis;\nvar fails$f = fails$h;\nvar classof$6 = classofRaw$1;\n\nvar $Object$4 = Object;\nvar split = uncurryThis$f(''.split);\n\n// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar indexedObject = fails$f(function () {\n  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n  // eslint-disable-next-line no-prototype-builtins -- safe\n  return !$Object$4('z').propertyIsEnumerable(0);\n}) ? function (it) {\n  return classof$6(it) == 'String' ? split(it, '') : $Object$4(it);\n} : $Object$4;\n\nvar $TypeError$e = TypeError;\n\n// `RequireObjectCoercible` abstract operation\n// https://tc39.es/ecma262/#sec-requireobjectcoercible\nvar requireObjectCoercible$3 = function (it) {\n  if (it == undefined) throw $TypeError$e(\"Can't call method on \" + it);\n  return it;\n};\n\n// toObject with fallback for non-array-like ES3 strings\nvar IndexedObject$2 = indexedObject;\nvar requireObjectCoercible$2 = requireObjectCoercible$3;\n\nvar toIndexedObject$5 = function (it) {\n  return IndexedObject$2(requireObjectCoercible$2(it));\n};\n\nvar check = function (it) {\n  return it && it.Math == Math && it;\n};\n\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global$k =\n  // eslint-disable-next-line es-x/no-global-this -- safe\n  check(typeof globalThis == 'object' && globalThis) ||\n  check(typeof window == 'object' && window) ||\n  // eslint-disable-next-line no-restricted-globals -- safe\n  check(typeof self == 'object' && self) ||\n  check(typeof commonjsGlobal == 'object' && commonjsGlobal) ||\n  // eslint-disable-next-line no-new-func -- fallback\n  (function () { return this; })() || Function('return this')();\n\nvar shared$3 = {exports: {}};\n\nvar global$j = global$k;\n\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar defineProperty$6 = Object.defineProperty;\n\nvar defineGlobalProperty$3 = function (key, value) {\n  try {\n    defineProperty$6(global$j, key, { value: value, configurable: true, writable: true });\n  } catch (error) {\n    global$j[key] = value;\n  } return value;\n};\n\nvar global$i = global$k;\nvar defineGlobalProperty$2 = defineGlobalProperty$3;\n\nvar SHARED = '__core-js_shared__';\nvar store$3 = global$i[SHARED] || defineGlobalProperty$2(SHARED, {});\n\nvar sharedStore = store$3;\n\nvar store$2 = sharedStore;\n\n(shared$3.exports = function (key, value) {\n  return store$2[key] || (store$2[key] = value !== undefined ? value : {});\n})('versions', []).push({\n  version: '3.23.3',\n  mode: 'global',\n  copyright: '© 2014-2022 Denis Pushkarev (zloirock.ru)',\n  license: 'https://github.com/zloirock/core-js/blob/v3.23.3/LICENSE',\n  source: 'https://github.com/zloirock/core-js'\n});\n\nvar requireObjectCoercible$1 = requireObjectCoercible$3;\n\nvar $Object$3 = Object;\n\n// `ToObject` abstract operation\n// https://tc39.es/ecma262/#sec-toobject\nvar toObject$5 = function (argument) {\n  return $Object$3(requireObjectCoercible$1(argument));\n};\n\nvar uncurryThis$e = functionUncurryThis;\nvar toObject$4 = toObject$5;\n\nvar hasOwnProperty = uncurryThis$e({}.hasOwnProperty);\n\n// `HasOwnProperty` abstract operation\n// https://tc39.es/ecma262/#sec-hasownproperty\n// eslint-disable-next-line es-x/no-object-hasown -- safe\nvar hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {\n  return hasOwnProperty(toObject$4(it), key);\n};\n\nvar uncurryThis$d = functionUncurryThis;\n\nvar id = 0;\nvar postfix = Math.random();\nvar toString$4 = uncurryThis$d(1.0.toString);\n\nvar uid$2 = function (key) {\n  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString$4(++id + postfix, 36);\n};\n\n// `IsCallable` abstract operation\n// https://tc39.es/ecma262/#sec-iscallable\nvar isCallable$l = function (argument) {\n  return typeof argument == 'function';\n};\n\nvar global$h = global$k;\nvar isCallable$k = isCallable$l;\n\nvar aFunction = function (argument) {\n  return isCallable$k(argument) ? argument : undefined;\n};\n\nvar getBuiltIn$8 = function (namespace, method) {\n  return arguments.length < 2 ? aFunction(global$h[namespace]) : global$h[namespace] && global$h[namespace][method];\n};\n\nvar getBuiltIn$7 = getBuiltIn$8;\n\nvar engineUserAgent = getBuiltIn$7('navigator', 'userAgent') || '';\n\nvar global$g = global$k;\nvar userAgent$5 = engineUserAgent;\n\nvar process$3 = global$g.process;\nvar Deno$1 = global$g.Deno;\nvar versions = process$3 && process$3.versions || Deno$1 && Deno$1.version;\nvar v8 = versions && versions.v8;\nvar match, version;\n\nif (v8) {\n  match = v8.split('.');\n  // in old Chrome, versions of V8 isn't V8 = Chrome / 10\n  // but their correct versions are not interesting for us\n  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);\n}\n\n// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`\n// so check `userAgent` even if `.v8` exists, but 0\nif (!version && userAgent$5) {\n  match = userAgent$5.match(/Edge\\/(\\d+)/);\n  if (!match || match[1] >= 74) {\n    match = userAgent$5.match(/Chrome\\/(\\d+)/);\n    if (match) version = +match[1];\n  }\n}\n\nvar engineV8Version = version;\n\n/* eslint-disable es-x/no-symbol -- required for testing */\n\nvar V8_VERSION$1 = engineV8Version;\nvar fails$e = fails$h;\n\n// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- required for testing\nvar nativeSymbol = !!Object.getOwnPropertySymbols && !fails$e(function () {\n  var symbol = Symbol();\n  // Chrome 38 Symbol has incorrect toString conversion\n  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances\n  return !String(symbol) || !(Object(symbol) instanceof Symbol) ||\n    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances\n    !Symbol.sham && V8_VERSION$1 && V8_VERSION$1 < 41;\n});\n\n/* eslint-disable es-x/no-symbol -- required for testing */\n\nvar NATIVE_SYMBOL$2 = nativeSymbol;\n\nvar useSymbolAsUid = NATIVE_SYMBOL$2\n  && !Symbol.sham\n  && typeof Symbol.iterator == 'symbol';\n\nvar global$f = global$k;\nvar shared$2 = shared$3.exports;\nvar hasOwn$b = hasOwnProperty_1;\nvar uid$1 = uid$2;\nvar NATIVE_SYMBOL$1 = nativeSymbol;\nvar USE_SYMBOL_AS_UID$1 = useSymbolAsUid;\n\nvar WellKnownSymbolsStore = shared$2('wks');\nvar Symbol$1 = global$f.Symbol;\nvar symbolFor = Symbol$1 && Symbol$1['for'];\nvar createWellKnownSymbol = USE_SYMBOL_AS_UID$1 ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid$1;\n\nvar wellKnownSymbol$g = function (name) {\n  if (!hasOwn$b(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL$1 || typeof WellKnownSymbolsStore[name] == 'string')) {\n    var description = 'Symbol.' + name;\n    if (NATIVE_SYMBOL$1 && hasOwn$b(Symbol$1, name)) {\n      WellKnownSymbolsStore[name] = Symbol$1[name];\n    } else if (USE_SYMBOL_AS_UID$1 && symbolFor) {\n      WellKnownSymbolsStore[name] = symbolFor(description);\n    } else {\n      WellKnownSymbolsStore[name] = createWellKnownSymbol(description);\n    }\n  } return WellKnownSymbolsStore[name];\n};\n\nvar isCallable$j = isCallable$l;\n\nvar isObject$8 = function (it) {\n  return typeof it == 'object' ? it !== null : isCallable$j(it);\n};\n\nvar isObject$7 = isObject$8;\n\nvar $String$3 = String;\nvar $TypeError$d = TypeError;\n\n// `Assert: Type(argument) is Object`\nvar anObject$c = function (argument) {\n  if (isObject$7(argument)) return argument;\n  throw $TypeError$d($String$3(argument) + ' is not an object');\n};\n\nvar objectDefineProperties = {};\n\nvar fails$d = fails$h;\n\n// Detect IE8's incomplete defineProperty implementation\nvar descriptors = !fails$d(function () {\n  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;\n});\n\nvar DESCRIPTORS$b = descriptors;\nvar fails$c = fails$h;\n\n// V8 ~ Chrome 36-\n// https://bugs.chromium.org/p/v8/issues/detail?id=3334\nvar v8PrototypeDefineBug = DESCRIPTORS$b && fails$c(function () {\n  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n  return Object.defineProperty(function () { /* empty */ }, 'prototype', {\n    value: 42,\n    writable: false\n  }).prototype != 42;\n});\n\nvar objectDefineProperty = {};\n\nvar global$e = global$k;\nvar isObject$6 = isObject$8;\n\nvar document$3 = global$e.document;\n// typeof document.createElement is 'object' in old IE\nvar EXISTS$1 = isObject$6(document$3) && isObject$6(document$3.createElement);\n\nvar documentCreateElement$2 = function (it) {\n  return EXISTS$1 ? document$3.createElement(it) : {};\n};\n\nvar DESCRIPTORS$a = descriptors;\nvar fails$b = fails$h;\nvar createElement$1 = documentCreateElement$2;\n\n// Thanks to IE8 for its funny defineProperty\nvar ie8DomDefine = !DESCRIPTORS$a && !fails$b(function () {\n  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n  return Object.defineProperty(createElement$1('div'), 'a', {\n    get: function () { return 7; }\n  }).a != 7;\n});\n\nvar NATIVE_BIND$2 = functionBindNative;\n\nvar call$e = Function.prototype.call;\n\nvar functionCall = NATIVE_BIND$2 ? call$e.bind(call$e) : function () {\n  return call$e.apply(call$e, arguments);\n};\n\nvar uncurryThis$c = functionUncurryThis;\n\nvar objectIsPrototypeOf = uncurryThis$c({}.isPrototypeOf);\n\nvar getBuiltIn$6 = getBuiltIn$8;\nvar isCallable$i = isCallable$l;\nvar isPrototypeOf$4 = objectIsPrototypeOf;\nvar USE_SYMBOL_AS_UID = useSymbolAsUid;\n\nvar $Object$2 = Object;\n\nvar isSymbol$2 = USE_SYMBOL_AS_UID ? function (it) {\n  return typeof it == 'symbol';\n} : function (it) {\n  var $Symbol = getBuiltIn$6('Symbol');\n  return isCallable$i($Symbol) && isPrototypeOf$4($Symbol.prototype, $Object$2(it));\n};\n\nvar $String$2 = String;\n\nvar tryToString$5 = function (argument) {\n  try {\n    return $String$2(argument);\n  } catch (error) {\n    return 'Object';\n  }\n};\n\nvar isCallable$h = isCallable$l;\nvar tryToString$4 = tryToString$5;\n\nvar $TypeError$c = TypeError;\n\n// `Assert: IsCallable(argument) is true`\nvar aCallable$9 = function (argument) {\n  if (isCallable$h(argument)) return argument;\n  throw $TypeError$c(tryToString$4(argument) + ' is not a function');\n};\n\nvar aCallable$8 = aCallable$9;\n\n// `GetMethod` abstract operation\n// https://tc39.es/ecma262/#sec-getmethod\nvar getMethod$3 = function (V, P) {\n  var func = V[P];\n  return func == null ? undefined : aCallable$8(func);\n};\n\nvar call$d = functionCall;\nvar isCallable$g = isCallable$l;\nvar isObject$5 = isObject$8;\n\nvar $TypeError$b = TypeError;\n\n// `OrdinaryToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-ordinarytoprimitive\nvar ordinaryToPrimitive$1 = function (input, pref) {\n  var fn, val;\n  if (pref === 'string' && isCallable$g(fn = input.toString) && !isObject$5(val = call$d(fn, input))) return val;\n  if (isCallable$g(fn = input.valueOf) && !isObject$5(val = call$d(fn, input))) return val;\n  if (pref !== 'string' && isCallable$g(fn = input.toString) && !isObject$5(val = call$d(fn, input))) return val;\n  throw $TypeError$b(\"Can't convert object to primitive value\");\n};\n\nvar call$c = functionCall;\nvar isObject$4 = isObject$8;\nvar isSymbol$1 = isSymbol$2;\nvar getMethod$2 = getMethod$3;\nvar ordinaryToPrimitive = ordinaryToPrimitive$1;\nvar wellKnownSymbol$f = wellKnownSymbol$g;\n\nvar $TypeError$a = TypeError;\nvar TO_PRIMITIVE = wellKnownSymbol$f('toPrimitive');\n\n// `ToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-toprimitive\nvar toPrimitive$1 = function (input, pref) {\n  if (!isObject$4(input) || isSymbol$1(input)) return input;\n  var exoticToPrim = getMethod$2(input, TO_PRIMITIVE);\n  var result;\n  if (exoticToPrim) {\n    if (pref === undefined) pref = 'default';\n    result = call$c(exoticToPrim, input, pref);\n    if (!isObject$4(result) || isSymbol$1(result)) return result;\n    throw $TypeError$a(\"Can't convert object to primitive value\");\n  }\n  if (pref === undefined) pref = 'number';\n  return ordinaryToPrimitive(input, pref);\n};\n\nvar toPrimitive = toPrimitive$1;\nvar isSymbol = isSymbol$2;\n\n// `ToPropertyKey` abstract operation\n// https://tc39.es/ecma262/#sec-topropertykey\nvar toPropertyKey$3 = function (argument) {\n  var key = toPrimitive(argument, 'string');\n  return isSymbol(key) ? key : key + '';\n};\n\nvar DESCRIPTORS$9 = descriptors;\nvar IE8_DOM_DEFINE$1 = ie8DomDefine;\nvar V8_PROTOTYPE_DEFINE_BUG$1 = v8PrototypeDefineBug;\nvar anObject$b = anObject$c;\nvar toPropertyKey$2 = toPropertyKey$3;\n\nvar $TypeError$9 = TypeError;\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar $defineProperty = Object.defineProperty;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;\nvar ENUMERABLE = 'enumerable';\nvar CONFIGURABLE$1 = 'configurable';\nvar WRITABLE = 'writable';\n\n// `Object.defineProperty` method\n// https://tc39.es/ecma262/#sec-object.defineproperty\nobjectDefineProperty.f = DESCRIPTORS$9 ? V8_PROTOTYPE_DEFINE_BUG$1 ? function defineProperty(O, P, Attributes) {\n  anObject$b(O);\n  P = toPropertyKey$2(P);\n  anObject$b(Attributes);\n  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {\n    var current = $getOwnPropertyDescriptor$1(O, P);\n    if (current && current[WRITABLE]) {\n      O[P] = Attributes.value;\n      Attributes = {\n        configurable: CONFIGURABLE$1 in Attributes ? Attributes[CONFIGURABLE$1] : current[CONFIGURABLE$1],\n        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],\n        writable: false\n      };\n    }\n  } return $defineProperty(O, P, Attributes);\n} : $defineProperty : function defineProperty(O, P, Attributes) {\n  anObject$b(O);\n  P = toPropertyKey$2(P);\n  anObject$b(Attributes);\n  if (IE8_DOM_DEFINE$1) try {\n    return $defineProperty(O, P, Attributes);\n  } catch (error) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw $TypeError$9('Accessors not supported');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n\nvar ceil = Math.ceil;\nvar floor$1 = Math.floor;\n\n// `Math.trunc` method\n// https://tc39.es/ecma262/#sec-math.trunc\n// eslint-disable-next-line es-x/no-math-trunc -- safe\nvar mathTrunc = Math.trunc || function trunc(x) {\n  var n = +x;\n  return (n > 0 ? floor$1 : ceil)(n);\n};\n\nvar trunc = mathTrunc;\n\n// `ToIntegerOrInfinity` abstract operation\n// https://tc39.es/ecma262/#sec-tointegerorinfinity\nvar toIntegerOrInfinity$2 = function (argument) {\n  var number = +argument;\n  // eslint-disable-next-line no-self-compare -- NaN check\n  return number !== number || number === 0 ? 0 : trunc(number);\n};\n\nvar toIntegerOrInfinity$1 = toIntegerOrInfinity$2;\n\nvar max$1 = Math.max;\nvar min$1 = Math.min;\n\n// Helper for a popular repeating case of the spec:\n// Let integer be ? ToInteger(index).\n// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).\nvar toAbsoluteIndex$2 = function (index, length) {\n  var integer = toIntegerOrInfinity$1(index);\n  return integer < 0 ? max$1(integer + length, 0) : min$1(integer, length);\n};\n\nvar toIntegerOrInfinity = toIntegerOrInfinity$2;\n\nvar min = Math.min;\n\n// `ToLength` abstract operation\n// https://tc39.es/ecma262/#sec-tolength\nvar toLength$1 = function (argument) {\n  return argument > 0 ? min(toIntegerOrInfinity(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n};\n\nvar toLength = toLength$1;\n\n// `LengthOfArrayLike` abstract operation\n// https://tc39.es/ecma262/#sec-lengthofarraylike\nvar lengthOfArrayLike$5 = function (obj) {\n  return toLength(obj.length);\n};\n\nvar toIndexedObject$4 = toIndexedObject$5;\nvar toAbsoluteIndex$1 = toAbsoluteIndex$2;\nvar lengthOfArrayLike$4 = lengthOfArrayLike$5;\n\n// `Array.prototype.{ indexOf, includes }` methods implementation\nvar createMethod$1 = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIndexedObject$4($this);\n    var length = lengthOfArrayLike$4(O);\n    var index = toAbsoluteIndex$1(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare -- NaN check\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare -- NaN check\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) {\n      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\nvar arrayIncludes = {\n  // `Array.prototype.includes` method\n  // https://tc39.es/ecma262/#sec-array.prototype.includes\n  includes: createMethod$1(true),\n  // `Array.prototype.indexOf` method\n  // https://tc39.es/ecma262/#sec-array.prototype.indexof\n  indexOf: createMethod$1(false)\n};\n\nvar hiddenKeys$4 = {};\n\nvar uncurryThis$b = functionUncurryThis;\nvar hasOwn$a = hasOwnProperty_1;\nvar toIndexedObject$3 = toIndexedObject$5;\nvar indexOf = arrayIncludes.indexOf;\nvar hiddenKeys$3 = hiddenKeys$4;\n\nvar push$1 = uncurryThis$b([].push);\n\nvar objectKeysInternal = function (object, names) {\n  var O = toIndexedObject$3(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) !hasOwn$a(hiddenKeys$3, key) && hasOwn$a(O, key) && push$1(result, key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (hasOwn$a(O, key = names[i++])) {\n    ~indexOf(result, key) || push$1(result, key);\n  }\n  return result;\n};\n\n// IE8- don't enum bug keys\nvar enumBugKeys$3 = [\n  'constructor',\n  'hasOwnProperty',\n  'isPrototypeOf',\n  'propertyIsEnumerable',\n  'toLocaleString',\n  'toString',\n  'valueOf'\n];\n\nvar internalObjectKeys$1 = objectKeysInternal;\nvar enumBugKeys$2 = enumBugKeys$3;\n\n// `Object.keys` method\n// https://tc39.es/ecma262/#sec-object.keys\n// eslint-disable-next-line es-x/no-object-keys -- safe\nvar objectKeys$2 = Object.keys || function keys(O) {\n  return internalObjectKeys$1(O, enumBugKeys$2);\n};\n\nvar DESCRIPTORS$8 = descriptors;\nvar V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;\nvar definePropertyModule$5 = objectDefineProperty;\nvar anObject$a = anObject$c;\nvar toIndexedObject$2 = toIndexedObject$5;\nvar objectKeys$1 = objectKeys$2;\n\n// `Object.defineProperties` method\n// https://tc39.es/ecma262/#sec-object.defineproperties\n// eslint-disable-next-line es-x/no-object-defineproperties -- safe\nobjectDefineProperties.f = DESCRIPTORS$8 && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {\n  anObject$a(O);\n  var props = toIndexedObject$2(Properties);\n  var keys = objectKeys$1(Properties);\n  var length = keys.length;\n  var index = 0;\n  var key;\n  while (length > index) definePropertyModule$5.f(O, key = keys[index++], props[key]);\n  return O;\n};\n\nvar getBuiltIn$5 = getBuiltIn$8;\n\nvar html$2 = getBuiltIn$5('document', 'documentElement');\n\nvar shared$1 = shared$3.exports;\nvar uid = uid$2;\n\nvar keys = shared$1('keys');\n\nvar sharedKey$3 = function (key) {\n  return keys[key] || (keys[key] = uid(key));\n};\n\n/* global ActiveXObject -- old IE, WSH */\n\nvar anObject$9 = anObject$c;\nvar definePropertiesModule = objectDefineProperties;\nvar enumBugKeys$1 = enumBugKeys$3;\nvar hiddenKeys$2 = hiddenKeys$4;\nvar html$1 = html$2;\nvar documentCreateElement$1 = documentCreateElement$2;\nvar sharedKey$2 = sharedKey$3;\n\nvar GT = '>';\nvar LT = '<';\nvar PROTOTYPE = 'prototype';\nvar SCRIPT = 'script';\nvar IE_PROTO$1 = sharedKey$2('IE_PROTO');\n\nvar EmptyConstructor = function () { /* empty */ };\n\nvar scriptTag = function (content) {\n  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;\n};\n\n// Create object with fake `null` prototype: use ActiveX Object with cleared prototype\nvar NullProtoObjectViaActiveX = function (activeXDocument) {\n  activeXDocument.write(scriptTag(''));\n  activeXDocument.close();\n  var temp = activeXDocument.parentWindow.Object;\n  activeXDocument = null; // avoid memory leak\n  return temp;\n};\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar NullProtoObjectViaIFrame = function () {\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = documentCreateElement$1('iframe');\n  var JS = 'java' + SCRIPT + ':';\n  var iframeDocument;\n  iframe.style.display = 'none';\n  html$1.appendChild(iframe);\n  // https://github.com/zloirock/core-js/issues/475\n  iframe.src = String(JS);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(scriptTag('document.F=Object'));\n  iframeDocument.close();\n  return iframeDocument.F;\n};\n\n// Check for document.domain and active x support\n// No need to use active x approach when document.domain is not set\n// see https://github.com/es-shims/es5-shim/issues/150\n// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346\n// avoid IE GC bug\nvar activeXDocument;\nvar NullProtoObject = function () {\n  try {\n    activeXDocument = new ActiveXObject('htmlfile');\n  } catch (error) { /* ignore */ }\n  NullProtoObject = typeof document != 'undefined'\n    ? document.domain && activeXDocument\n      ? NullProtoObjectViaActiveX(activeXDocument) // old IE\n      : NullProtoObjectViaIFrame()\n    : NullProtoObjectViaActiveX(activeXDocument); // WSH\n  var length = enumBugKeys$1.length;\n  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys$1[length]];\n  return NullProtoObject();\n};\n\nhiddenKeys$2[IE_PROTO$1] = true;\n\n// `Object.create` method\n// https://tc39.es/ecma262/#sec-object.create\n// eslint-disable-next-line es-x/no-object-create -- safe\nvar objectCreate = Object.create || function create(O, Properties) {\n  var result;\n  if (O !== null) {\n    EmptyConstructor[PROTOTYPE] = anObject$9(O);\n    result = new EmptyConstructor();\n    EmptyConstructor[PROTOTYPE] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO$1] = O;\n  } else result = NullProtoObject();\n  return Properties === undefined ? result : definePropertiesModule.f(result, Properties);\n};\n\nvar wellKnownSymbol$e = wellKnownSymbol$g;\nvar create$1 = objectCreate;\nvar defineProperty$5 = objectDefineProperty.f;\n\nvar UNSCOPABLES = wellKnownSymbol$e('unscopables');\nvar ArrayPrototype$1 = Array.prototype;\n\n// Array.prototype[@@unscopables]\n// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\nif (ArrayPrototype$1[UNSCOPABLES] == undefined) {\n  defineProperty$5(ArrayPrototype$1, UNSCOPABLES, {\n    configurable: true,\n    value: create$1(null)\n  });\n}\n\n// add a key to Array.prototype[@@unscopables]\nvar addToUnscopables$2 = function (key) {\n  ArrayPrototype$1[UNSCOPABLES][key] = true;\n};\n\nvar iterators = {};\n\nvar uncurryThis$a = functionUncurryThis;\nvar isCallable$f = isCallable$l;\nvar store$1 = sharedStore;\n\nvar functionToString = uncurryThis$a(Function.toString);\n\n// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper\nif (!isCallable$f(store$1.inspectSource)) {\n  store$1.inspectSource = function (it) {\n    return functionToString(it);\n  };\n}\n\nvar inspectSource$4 = store$1.inspectSource;\n\nvar global$d = global$k;\nvar isCallable$e = isCallable$l;\nvar inspectSource$3 = inspectSource$4;\n\nvar WeakMap$1 = global$d.WeakMap;\n\nvar nativeWeakMap = isCallable$e(WeakMap$1) && /native code/.test(inspectSource$3(WeakMap$1));\n\nvar createPropertyDescriptor$4 = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n\nvar DESCRIPTORS$7 = descriptors;\nvar definePropertyModule$4 = objectDefineProperty;\nvar createPropertyDescriptor$3 = createPropertyDescriptor$4;\n\nvar createNonEnumerableProperty$4 = DESCRIPTORS$7 ? function (object, key, value) {\n  return definePropertyModule$4.f(object, key, createPropertyDescriptor$3(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n\nvar NATIVE_WEAK_MAP = nativeWeakMap;\nvar global$c = global$k;\nvar uncurryThis$9 = functionUncurryThis;\nvar isObject$3 = isObject$8;\nvar createNonEnumerableProperty$3 = createNonEnumerableProperty$4;\nvar hasOwn$9 = hasOwnProperty_1;\nvar shared = sharedStore;\nvar sharedKey$1 = sharedKey$3;\nvar hiddenKeys$1 = hiddenKeys$4;\n\nvar OBJECT_ALREADY_INITIALIZED = 'Object already initialized';\nvar TypeError$2 = global$c.TypeError;\nvar WeakMap = global$c.WeakMap;\nvar set$1, get, has;\n\nvar enforce = function (it) {\n  return has(it) ? get(it) : set$1(it, {});\n};\n\nvar getterFor = function (TYPE) {\n  return function (it) {\n    var state;\n    if (!isObject$3(it) || (state = get(it)).type !== TYPE) {\n      throw TypeError$2('Incompatible receiver, ' + TYPE + ' required');\n    } return state;\n  };\n};\n\nif (NATIVE_WEAK_MAP || shared.state) {\n  var store = shared.state || (shared.state = new WeakMap());\n  var wmget = uncurryThis$9(store.get);\n  var wmhas = uncurryThis$9(store.has);\n  var wmset = uncurryThis$9(store.set);\n  set$1 = function (it, metadata) {\n    if (wmhas(store, it)) throw new TypeError$2(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    wmset(store, it, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return wmget(store, it) || {};\n  };\n  has = function (it) {\n    return wmhas(store, it);\n  };\n} else {\n  var STATE = sharedKey$1('state');\n  hiddenKeys$1[STATE] = true;\n  set$1 = function (it, metadata) {\n    if (hasOwn$9(it, STATE)) throw new TypeError$2(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    createNonEnumerableProperty$3(it, STATE, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return hasOwn$9(it, STATE) ? it[STATE] : {};\n  };\n  has = function (it) {\n    return hasOwn$9(it, STATE);\n  };\n}\n\nvar internalState = {\n  set: set$1,\n  get: get,\n  has: has,\n  enforce: enforce,\n  getterFor: getterFor\n};\n\nvar objectGetOwnPropertyDescriptor = {};\n\nvar objectPropertyIsEnumerable = {};\n\nvar $propertyIsEnumerable = {}.propertyIsEnumerable;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar getOwnPropertyDescriptor$2 = Object.getOwnPropertyDescriptor;\n\n// Nashorn ~ JDK8 bug\nvar NASHORN_BUG = getOwnPropertyDescriptor$2 && !$propertyIsEnumerable.call({ 1: 2 }, 1);\n\n// `Object.prototype.propertyIsEnumerable` method implementation\n// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable\nobjectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n  var descriptor = getOwnPropertyDescriptor$2(this, V);\n  return !!descriptor && descriptor.enumerable;\n} : $propertyIsEnumerable;\n\nvar DESCRIPTORS$6 = descriptors;\nvar call$b = functionCall;\nvar propertyIsEnumerableModule$1 = objectPropertyIsEnumerable;\nvar createPropertyDescriptor$2 = createPropertyDescriptor$4;\nvar toIndexedObject$1 = toIndexedObject$5;\nvar toPropertyKey$1 = toPropertyKey$3;\nvar hasOwn$8 = hasOwnProperty_1;\nvar IE8_DOM_DEFINE = ie8DomDefine;\n\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n// `Object.getOwnPropertyDescriptor` method\n// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor\nobjectGetOwnPropertyDescriptor.f = DESCRIPTORS$6 ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {\n  O = toIndexedObject$1(O);\n  P = toPropertyKey$1(P);\n  if (IE8_DOM_DEFINE) try {\n    return $getOwnPropertyDescriptor(O, P);\n  } catch (error) { /* empty */ }\n  if (hasOwn$8(O, P)) return createPropertyDescriptor$2(!call$b(propertyIsEnumerableModule$1.f, O, P), O[P]);\n};\n\nvar makeBuiltIn$2 = {exports: {}};\n\nvar DESCRIPTORS$5 = descriptors;\nvar hasOwn$7 = hasOwnProperty_1;\n\nvar FunctionPrototype$1 = Function.prototype;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar getDescriptor = DESCRIPTORS$5 && Object.getOwnPropertyDescriptor;\n\nvar EXISTS = hasOwn$7(FunctionPrototype$1, 'name');\n// additional protection from minified / mangled / dropped function names\nvar PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';\nvar CONFIGURABLE = EXISTS && (!DESCRIPTORS$5 || (DESCRIPTORS$5 && getDescriptor(FunctionPrototype$1, 'name').configurable));\n\nvar functionName = {\n  EXISTS: EXISTS,\n  PROPER: PROPER,\n  CONFIGURABLE: CONFIGURABLE\n};\n\nvar fails$a = fails$h;\nvar isCallable$d = isCallable$l;\nvar hasOwn$6 = hasOwnProperty_1;\nvar DESCRIPTORS$4 = descriptors;\nvar CONFIGURABLE_FUNCTION_NAME$1 = functionName.CONFIGURABLE;\nvar inspectSource$2 = inspectSource$4;\nvar InternalStateModule$2 = internalState;\n\nvar enforceInternalState = InternalStateModule$2.enforce;\nvar getInternalState$1 = InternalStateModule$2.get;\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar defineProperty$4 = Object.defineProperty;\n\nvar CONFIGURABLE_LENGTH = DESCRIPTORS$4 && !fails$a(function () {\n  return defineProperty$4(function () { /* empty */ }, 'length', { value: 8 }).length !== 8;\n});\n\nvar TEMPLATE = String(String).split('String');\n\nvar makeBuiltIn$1 = makeBuiltIn$2.exports = function (value, name, options) {\n  if (String(name).slice(0, 7) === 'Symbol(') {\n    name = '[' + String(name).replace(/^Symbol\\(([^)]*)\\)/, '$1') + ']';\n  }\n  if (options && options.getter) name = 'get ' + name;\n  if (options && options.setter) name = 'set ' + name;\n  if (!hasOwn$6(value, 'name') || (CONFIGURABLE_FUNCTION_NAME$1 && value.name !== name)) {\n    if (DESCRIPTORS$4) defineProperty$4(value, 'name', { value: name, configurable: true });\n    else value.name = name;\n  }\n  if (CONFIGURABLE_LENGTH && options && hasOwn$6(options, 'arity') && value.length !== options.arity) {\n    defineProperty$4(value, 'length', { value: options.arity });\n  }\n  try {\n    if (options && hasOwn$6(options, 'constructor') && options.constructor) {\n      if (DESCRIPTORS$4) defineProperty$4(value, 'prototype', { writable: false });\n    // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable\n    } else if (value.prototype) value.prototype = undefined;\n  } catch (error) { /* empty */ }\n  var state = enforceInternalState(value);\n  if (!hasOwn$6(state, 'source')) {\n    state.source = TEMPLATE.join(typeof name == 'string' ? name : '');\n  } return value;\n};\n\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n// eslint-disable-next-line no-extend-native -- required\nFunction.prototype.toString = makeBuiltIn$1(function toString() {\n  return isCallable$d(this) && getInternalState$1(this).source || inspectSource$2(this);\n}, 'toString');\n\nvar isCallable$c = isCallable$l;\nvar definePropertyModule$3 = objectDefineProperty;\nvar makeBuiltIn = makeBuiltIn$2.exports;\nvar defineGlobalProperty$1 = defineGlobalProperty$3;\n\nvar defineBuiltIn$6 = function (O, key, value, options) {\n  if (!options) options = {};\n  var simple = options.enumerable;\n  var name = options.name !== undefined ? options.name : key;\n  if (isCallable$c(value)) makeBuiltIn(value, name, options);\n  if (options.global) {\n    if (simple) O[key] = value;\n    else defineGlobalProperty$1(key, value);\n  } else {\n    try {\n      if (!options.unsafe) delete O[key];\n      else if (O[key]) simple = true;\n    } catch (error) { /* empty */ }\n    if (simple) O[key] = value;\n    else definePropertyModule$3.f(O, key, {\n      value: value,\n      enumerable: false,\n      configurable: !options.nonConfigurable,\n      writable: !options.nonWritable\n    });\n  } return O;\n};\n\nvar objectGetOwnPropertyNames = {};\n\nvar internalObjectKeys = objectKeysInternal;\nvar enumBugKeys = enumBugKeys$3;\n\nvar hiddenKeys = enumBugKeys.concat('length', 'prototype');\n\n// `Object.getOwnPropertyNames` method\n// https://tc39.es/ecma262/#sec-object.getownpropertynames\n// eslint-disable-next-line es-x/no-object-getownpropertynames -- safe\nobjectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return internalObjectKeys(O, hiddenKeys);\n};\n\nvar objectGetOwnPropertySymbols = {};\n\n// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- safe\nobjectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;\n\nvar getBuiltIn$4 = getBuiltIn$8;\nvar uncurryThis$8 = functionUncurryThis;\nvar getOwnPropertyNamesModule = objectGetOwnPropertyNames;\nvar getOwnPropertySymbolsModule$1 = objectGetOwnPropertySymbols;\nvar anObject$8 = anObject$c;\n\nvar concat$1 = uncurryThis$8([].concat);\n\n// all object keys, includes non-enumerable and symbols\nvar ownKeys$1 = getBuiltIn$4('Reflect', 'ownKeys') || function ownKeys(it) {\n  var keys = getOwnPropertyNamesModule.f(anObject$8(it));\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule$1.f;\n  return getOwnPropertySymbols ? concat$1(keys, getOwnPropertySymbols(it)) : keys;\n};\n\nvar hasOwn$5 = hasOwnProperty_1;\nvar ownKeys = ownKeys$1;\nvar getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;\nvar definePropertyModule$2 = objectDefineProperty;\n\nvar copyConstructorProperties$2 = function (target, source, exceptions) {\n  var keys = ownKeys(source);\n  var defineProperty = definePropertyModule$2.f;\n  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    if (!hasOwn$5(target, key) && !(exceptions && hasOwn$5(exceptions, key))) {\n      defineProperty(target, key, getOwnPropertyDescriptor(source, key));\n    }\n  }\n};\n\nvar fails$9 = fails$h;\nvar isCallable$b = isCallable$l;\n\nvar replacement = /#|\\.prototype\\./;\n\nvar isForced$2 = function (feature, detection) {\n  var value = data[normalize(feature)];\n  return value == POLYFILL ? true\n    : value == NATIVE ? false\n    : isCallable$b(detection) ? fails$9(detection)\n    : !!detection;\n};\n\nvar normalize = isForced$2.normalize = function (string) {\n  return String(string).replace(replacement, '.').toLowerCase();\n};\n\nvar data = isForced$2.data = {};\nvar NATIVE = isForced$2.NATIVE = 'N';\nvar POLYFILL = isForced$2.POLYFILL = 'P';\n\nvar isForced_1 = isForced$2;\n\nvar global$b = global$k;\nvar getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;\nvar createNonEnumerableProperty$2 = createNonEnumerableProperty$4;\nvar defineBuiltIn$5 = defineBuiltIn$6;\nvar defineGlobalProperty = defineGlobalProperty$3;\nvar copyConstructorProperties$1 = copyConstructorProperties$2;\nvar isForced$1 = isForced_1;\n\n/*\n  options.target         - name of the target object\n  options.global         - target is the global object\n  options.stat           - export as static methods of target\n  options.proto          - export as prototype methods of target\n  options.real           - real prototype method for the `pure` version\n  options.forced         - export even if the native feature is available\n  options.bind           - bind methods to the target, required for the `pure` version\n  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version\n  options.unsafe         - use the simple assignment of property instead of delete + defineProperty\n  options.sham           - add a flag to not completely full polyfills\n  options.enumerable     - export as enumerable property\n  options.dontCallGetSet - prevent calling a getter on target\n  options.name           - the .name of the function if it does not match the key\n*/\nvar _export = function (options, source) {\n  var TARGET = options.target;\n  var GLOBAL = options.global;\n  var STATIC = options.stat;\n  var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n  if (GLOBAL) {\n    target = global$b;\n  } else if (STATIC) {\n    target = global$b[TARGET] || defineGlobalProperty(TARGET, {});\n  } else {\n    target = (global$b[TARGET] || {}).prototype;\n  }\n  if (target) for (key in source) {\n    sourceProperty = source[key];\n    if (options.dontCallGetSet) {\n      descriptor = getOwnPropertyDescriptor$1(target, key);\n      targetProperty = descriptor && descriptor.value;\n    } else targetProperty = target[key];\n    FORCED = isForced$1(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);\n    // contained in target\n    if (!FORCED && targetProperty !== undefined) {\n      if (typeof sourceProperty == typeof targetProperty) continue;\n      copyConstructorProperties$1(sourceProperty, targetProperty);\n    }\n    // add a flag to not completely full polyfills\n    if (options.sham || (targetProperty && targetProperty.sham)) {\n      createNonEnumerableProperty$2(sourceProperty, 'sham', true);\n    }\n    defineBuiltIn$5(target, key, sourceProperty, options);\n  }\n};\n\nvar fails$8 = fails$h;\n\nvar correctPrototypeGetter = !fails$8(function () {\n  function F() { /* empty */ }\n  F.prototype.constructor = null;\n  // eslint-disable-next-line es-x/no-object-getprototypeof -- required for testing\n  return Object.getPrototypeOf(new F()) !== F.prototype;\n});\n\nvar hasOwn$4 = hasOwnProperty_1;\nvar isCallable$a = isCallable$l;\nvar toObject$3 = toObject$5;\nvar sharedKey = sharedKey$3;\nvar CORRECT_PROTOTYPE_GETTER = correctPrototypeGetter;\n\nvar IE_PROTO = sharedKey('IE_PROTO');\nvar $Object$1 = Object;\nvar ObjectPrototype = $Object$1.prototype;\n\n// `Object.getPrototypeOf` method\n// https://tc39.es/ecma262/#sec-object.getprototypeof\n// eslint-disable-next-line es-x/no-object-getprototypeof -- safe\nvar objectGetPrototypeOf = CORRECT_PROTOTYPE_GETTER ? $Object$1.getPrototypeOf : function (O) {\n  var object = toObject$3(O);\n  if (hasOwn$4(object, IE_PROTO)) return object[IE_PROTO];\n  var constructor = object.constructor;\n  if (isCallable$a(constructor) && object instanceof constructor) {\n    return constructor.prototype;\n  } return object instanceof $Object$1 ? ObjectPrototype : null;\n};\n\nvar fails$7 = fails$h;\nvar isCallable$9 = isCallable$l;\nvar getPrototypeOf$1 = objectGetPrototypeOf;\nvar defineBuiltIn$4 = defineBuiltIn$6;\nvar wellKnownSymbol$d = wellKnownSymbol$g;\n\nvar ITERATOR$5 = wellKnownSymbol$d('iterator');\nvar BUGGY_SAFARI_ITERATORS$1 = false;\n\n// `%IteratorPrototype%` object\n// https://tc39.es/ecma262/#sec-%iteratorprototype%-object\nvar IteratorPrototype$2, PrototypeOfArrayIteratorPrototype, arrayIterator;\n\n/* eslint-disable es-x/no-array-prototype-keys -- safe */\nif ([].keys) {\n  arrayIterator = [].keys();\n  // Safari 8 has buggy iterators w/o `next`\n  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS$1 = true;\n  else {\n    PrototypeOfArrayIteratorPrototype = getPrototypeOf$1(getPrototypeOf$1(arrayIterator));\n    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype$2 = PrototypeOfArrayIteratorPrototype;\n  }\n}\n\nvar NEW_ITERATOR_PROTOTYPE = IteratorPrototype$2 == undefined || fails$7(function () {\n  var test = {};\n  // FF44- legacy iterators case\n  return IteratorPrototype$2[ITERATOR$5].call(test) !== test;\n});\n\nif (NEW_ITERATOR_PROTOTYPE) IteratorPrototype$2 = {};\n\n// `%IteratorPrototype%[@@iterator]()` method\n// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator\nif (!isCallable$9(IteratorPrototype$2[ITERATOR$5])) {\n  defineBuiltIn$4(IteratorPrototype$2, ITERATOR$5, function () {\n    return this;\n  });\n}\n\nvar iteratorsCore = {\n  IteratorPrototype: IteratorPrototype$2,\n  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1\n};\n\nvar defineProperty$3 = objectDefineProperty.f;\nvar hasOwn$3 = hasOwnProperty_1;\nvar wellKnownSymbol$c = wellKnownSymbol$g;\n\nvar TO_STRING_TAG$3 = wellKnownSymbol$c('toStringTag');\n\nvar setToStringTag$3 = function (target, TAG, STATIC) {\n  if (target && !STATIC) target = target.prototype;\n  if (target && !hasOwn$3(target, TO_STRING_TAG$3)) {\n    defineProperty$3(target, TO_STRING_TAG$3, { configurable: true, value: TAG });\n  }\n};\n\nvar IteratorPrototype$1 = iteratorsCore.IteratorPrototype;\nvar create = objectCreate;\nvar createPropertyDescriptor$1 = createPropertyDescriptor$4;\nvar setToStringTag$2 = setToStringTag$3;\nvar Iterators$4 = iterators;\n\nvar returnThis$1 = function () { return this; };\n\nvar createIteratorConstructor$1 = function (IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {\n  var TO_STRING_TAG = NAME + ' Iterator';\n  IteratorConstructor.prototype = create(IteratorPrototype$1, { next: createPropertyDescriptor$1(+!ENUMERABLE_NEXT, next) });\n  setToStringTag$2(IteratorConstructor, TO_STRING_TAG, false);\n  Iterators$4[TO_STRING_TAG] = returnThis$1;\n  return IteratorConstructor;\n};\n\nvar isCallable$8 = isCallable$l;\n\nvar $String$1 = String;\nvar $TypeError$8 = TypeError;\n\nvar aPossiblePrototype$1 = function (argument) {\n  if (typeof argument == 'object' || isCallable$8(argument)) return argument;\n  throw $TypeError$8(\"Can't set \" + $String$1(argument) + ' as a prototype');\n};\n\n/* eslint-disable no-proto -- safe */\n\nvar uncurryThis$7 = functionUncurryThis;\nvar anObject$7 = anObject$c;\nvar aPossiblePrototype = aPossiblePrototype$1;\n\n// `Object.setPrototypeOf` method\n// https://tc39.es/ecma262/#sec-object.setprototypeof\n// Works with __proto__ only. Old v8 can't work with null proto objects.\n// eslint-disable-next-line es-x/no-object-setprototypeof -- safe\nvar objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {\n  var CORRECT_SETTER = false;\n  var test = {};\n  var setter;\n  try {\n    // eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\n    setter = uncurryThis$7(Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set);\n    setter(test, []);\n    CORRECT_SETTER = test instanceof Array;\n  } catch (error) { /* empty */ }\n  return function setPrototypeOf(O, proto) {\n    anObject$7(O);\n    aPossiblePrototype(proto);\n    if (CORRECT_SETTER) setter(O, proto);\n    else O.__proto__ = proto;\n    return O;\n  };\n}() : undefined);\n\nvar $$c = _export;\nvar call$a = functionCall;\nvar FunctionName = functionName;\nvar isCallable$7 = isCallable$l;\nvar createIteratorConstructor = createIteratorConstructor$1;\nvar getPrototypeOf = objectGetPrototypeOf;\nvar setPrototypeOf$1 = objectSetPrototypeOf;\nvar setToStringTag$1 = setToStringTag$3;\nvar createNonEnumerableProperty$1 = createNonEnumerableProperty$4;\nvar defineBuiltIn$3 = defineBuiltIn$6;\nvar wellKnownSymbol$b = wellKnownSymbol$g;\nvar Iterators$3 = iterators;\nvar IteratorsCore = iteratorsCore;\n\nvar PROPER_FUNCTION_NAME$1 = FunctionName.PROPER;\nvar CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;\nvar IteratorPrototype = IteratorsCore.IteratorPrototype;\nvar BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;\nvar ITERATOR$4 = wellKnownSymbol$b('iterator');\nvar KEYS = 'keys';\nvar VALUES = 'values';\nvar ENTRIES = 'entries';\n\nvar returnThis = function () { return this; };\n\nvar defineIterator$1 = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {\n  createIteratorConstructor(IteratorConstructor, NAME, next);\n\n  var getIterationMethod = function (KIND) {\n    if (KIND === DEFAULT && defaultIterator) return defaultIterator;\n    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];\n    switch (KIND) {\n      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };\n      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };\n      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };\n    } return function () { return new IteratorConstructor(this); };\n  };\n\n  var TO_STRING_TAG = NAME + ' Iterator';\n  var INCORRECT_VALUES_NAME = false;\n  var IterablePrototype = Iterable.prototype;\n  var nativeIterator = IterablePrototype[ITERATOR$4]\n    || IterablePrototype['@@iterator']\n    || DEFAULT && IterablePrototype[DEFAULT];\n  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);\n  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;\n  var CurrentIteratorPrototype, methods, KEY;\n\n  // fix native\n  if (anyNativeIterator) {\n    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));\n    if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {\n      if (getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {\n        if (setPrototypeOf$1) {\n          setPrototypeOf$1(CurrentIteratorPrototype, IteratorPrototype);\n        } else if (!isCallable$7(CurrentIteratorPrototype[ITERATOR$4])) {\n          defineBuiltIn$3(CurrentIteratorPrototype, ITERATOR$4, returnThis);\n        }\n      }\n      // Set @@toStringTag to native iterators\n      setToStringTag$1(CurrentIteratorPrototype, TO_STRING_TAG, true);\n    }\n  }\n\n  // fix Array.prototype.{ values, @@iterator }.name in V8 / FF\n  if (PROPER_FUNCTION_NAME$1 && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {\n    if (CONFIGURABLE_FUNCTION_NAME) {\n      createNonEnumerableProperty$1(IterablePrototype, 'name', VALUES);\n    } else {\n      INCORRECT_VALUES_NAME = true;\n      defaultIterator = function values() { return call$a(nativeIterator, this); };\n    }\n  }\n\n  // export additional methods\n  if (DEFAULT) {\n    methods = {\n      values: getIterationMethod(VALUES),\n      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),\n      entries: getIterationMethod(ENTRIES)\n    };\n    if (FORCED) for (KEY in methods) {\n      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {\n        defineBuiltIn$3(IterablePrototype, KEY, methods[KEY]);\n      }\n    } else $$c({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);\n  }\n\n  // define iterator\n  if (IterablePrototype[ITERATOR$4] !== defaultIterator) {\n    defineBuiltIn$3(IterablePrototype, ITERATOR$4, defaultIterator, { name: DEFAULT });\n  }\n  Iterators$3[NAME] = defaultIterator;\n\n  return methods;\n};\n\nvar toIndexedObject = toIndexedObject$5;\nvar addToUnscopables$1 = addToUnscopables$2;\nvar Iterators$2 = iterators;\nvar InternalStateModule$1 = internalState;\nvar defineProperty$2 = objectDefineProperty.f;\nvar defineIterator = defineIterator$1;\nvar DESCRIPTORS$3 = descriptors;\n\nvar ARRAY_ITERATOR = 'Array Iterator';\nvar setInternalState$1 = InternalStateModule$1.set;\nvar getInternalState = InternalStateModule$1.getterFor(ARRAY_ITERATOR);\n\n// `Array.prototype.entries` method\n// https://tc39.es/ecma262/#sec-array.prototype.entries\n// `Array.prototype.keys` method\n// https://tc39.es/ecma262/#sec-array.prototype.keys\n// `Array.prototype.values` method\n// https://tc39.es/ecma262/#sec-array.prototype.values\n// `Array.prototype[@@iterator]` method\n// https://tc39.es/ecma262/#sec-array.prototype-@@iterator\n// `CreateArrayIterator` internal method\n// https://tc39.es/ecma262/#sec-createarrayiterator\nvar es_array_iterator = defineIterator(Array, 'Array', function (iterated, kind) {\n  setInternalState$1(this, {\n    type: ARRAY_ITERATOR,\n    target: toIndexedObject(iterated), // target\n    index: 0,                          // next index\n    kind: kind                         // kind\n  });\n// `%ArrayIteratorPrototype%.next` method\n// https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next\n}, function () {\n  var state = getInternalState(this);\n  var target = state.target;\n  var kind = state.kind;\n  var index = state.index++;\n  if (!target || index >= target.length) {\n    state.target = undefined;\n    return { value: undefined, done: true };\n  }\n  if (kind == 'keys') return { value: index, done: false };\n  if (kind == 'values') return { value: target[index], done: false };\n  return { value: [index, target[index]], done: false };\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values%\n// https://tc39.es/ecma262/#sec-createunmappedargumentsobject\n// https://tc39.es/ecma262/#sec-createmappedargumentsobject\nvar values = Iterators$2.Arguments = Iterators$2.Array;\n\n// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\naddToUnscopables$1('keys');\naddToUnscopables$1('values');\naddToUnscopables$1('entries');\n\n// V8 ~ Chrome 45- bug\nif (DESCRIPTORS$3 && values.name !== 'values') try {\n  defineProperty$2(values, 'name', { value: 'values' });\n} catch (error) { /* empty */ }\n\n// iterable DOM collections\n// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods\nvar domIterables = {\n  CSSRuleList: 0,\n  CSSStyleDeclaration: 0,\n  CSSValueList: 0,\n  ClientRectList: 0,\n  DOMRectList: 0,\n  DOMStringList: 0,\n  DOMTokenList: 1,\n  DataTransferItemList: 0,\n  FileList: 0,\n  HTMLAllCollection: 0,\n  HTMLCollection: 0,\n  HTMLFormElement: 0,\n  HTMLSelectElement: 0,\n  MediaList: 0,\n  MimeTypeArray: 0,\n  NamedNodeMap: 0,\n  NodeList: 1,\n  PaintRequestList: 0,\n  Plugin: 0,\n  PluginArray: 0,\n  SVGLengthList: 0,\n  SVGNumberList: 0,\n  SVGPathSegList: 0,\n  SVGPointList: 0,\n  SVGStringList: 0,\n  SVGTransformList: 0,\n  SourceBufferList: 0,\n  StyleSheetList: 0,\n  TextTrackCueList: 0,\n  TextTrackList: 0,\n  TouchList: 0\n};\n\n// in old WebKit versions, `element.classList` is not an instance of global `DOMTokenList`\nvar documentCreateElement = documentCreateElement$2;\n\nvar classList = documentCreateElement('span').classList;\nvar DOMTokenListPrototype$1 = classList && classList.constructor && classList.constructor.prototype;\n\nvar domTokenListPrototype = DOMTokenListPrototype$1 === Object.prototype ? undefined : DOMTokenListPrototype$1;\n\nvar global$a = global$k;\nvar DOMIterables = domIterables;\nvar DOMTokenListPrototype = domTokenListPrototype;\nvar ArrayIteratorMethods = es_array_iterator;\nvar createNonEnumerableProperty = createNonEnumerableProperty$4;\nvar wellKnownSymbol$a = wellKnownSymbol$g;\n\nvar ITERATOR$3 = wellKnownSymbol$a('iterator');\nvar TO_STRING_TAG$2 = wellKnownSymbol$a('toStringTag');\nvar ArrayValues = ArrayIteratorMethods.values;\n\nvar handlePrototype = function (CollectionPrototype, COLLECTION_NAME) {\n  if (CollectionPrototype) {\n    // some Chrome versions have non-configurable methods on DOMTokenList\n    if (CollectionPrototype[ITERATOR$3] !== ArrayValues) try {\n      createNonEnumerableProperty(CollectionPrototype, ITERATOR$3, ArrayValues);\n    } catch (error) {\n      CollectionPrototype[ITERATOR$3] = ArrayValues;\n    }\n    if (!CollectionPrototype[TO_STRING_TAG$2]) {\n      createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG$2, COLLECTION_NAME);\n    }\n    if (DOMIterables[COLLECTION_NAME]) for (var METHOD_NAME in ArrayIteratorMethods) {\n      // some Chrome versions have non-configurable methods on DOMTokenList\n      if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {\n        createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);\n      } catch (error) {\n        CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];\n      }\n    }\n  }\n};\n\nfor (var COLLECTION_NAME in DOMIterables) {\n  handlePrototype(global$a[COLLECTION_NAME] && global$a[COLLECTION_NAME].prototype, COLLECTION_NAME);\n}\n\nhandlePrototype(DOMTokenListPrototype, 'DOMTokenList');\n\nvar DESCRIPTORS$2 = descriptors;\nvar uncurryThis$6 = functionUncurryThis;\nvar call$9 = functionCall;\nvar fails$6 = fails$h;\nvar objectKeys = objectKeys$2;\nvar getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;\nvar propertyIsEnumerableModule = objectPropertyIsEnumerable;\nvar toObject$2 = toObject$5;\nvar IndexedObject$1 = indexedObject;\n\n// eslint-disable-next-line es-x/no-object-assign -- safe\nvar $assign = Object.assign;\n// eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\nvar defineProperty$1 = Object.defineProperty;\nvar concat = uncurryThis$6([].concat);\n\n// `Object.assign` method\n// https://tc39.es/ecma262/#sec-object.assign\nvar objectAssign = !$assign || fails$6(function () {\n  // should have correct order of operations (Edge bug)\n  if (DESCRIPTORS$2 && $assign({ b: 1 }, $assign(defineProperty$1({}, 'a', {\n    enumerable: true,\n    get: function () {\n      defineProperty$1(this, 'b', {\n        value: 3,\n        enumerable: false\n      });\n    }\n  }), { b: 2 })).b !== 1) return true;\n  // should work with symbols and should have deterministic property order (V8 bug)\n  var A = {};\n  var B = {};\n  // eslint-disable-next-line es-x/no-symbol -- safe\n  var symbol = Symbol();\n  var alphabet = 'abcdefghijklmnopqrst';\n  A[symbol] = 7;\n  alphabet.split('').forEach(function (chr) { B[chr] = chr; });\n  return $assign({}, A)[symbol] != 7 || objectKeys($assign({}, B)).join('') != alphabet;\n}) ? function assign(target, source) { // eslint-disable-line no-unused-vars -- required for `.length`\n  var T = toObject$2(target);\n  var argumentsLength = arguments.length;\n  var index = 1;\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n  var propertyIsEnumerable = propertyIsEnumerableModule.f;\n  while (argumentsLength > index) {\n    var S = IndexedObject$1(arguments[index++]);\n    var keys = getOwnPropertySymbols ? concat(objectKeys(S), getOwnPropertySymbols(S)) : objectKeys(S);\n    var length = keys.length;\n    var j = 0;\n    var key;\n    while (length > j) {\n      key = keys[j++];\n      if (!DESCRIPTORS$2 || call$9(propertyIsEnumerable, S, key)) T[key] = S[key];\n    }\n  } return T;\n} : $assign;\n\nvar $$b = _export;\nvar assign = objectAssign;\n\n// `Object.assign` method\n// https://tc39.es/ecma262/#sec-object.assign\n// eslint-disable-next-line es-x/no-object-assign -- required for testing\n$$b({ target: 'Object', stat: true, arity: 2, forced: Object.assign !== assign }, {\n  assign: assign\n});\n\nconst CloseIcon = () => {\n  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"svg\", Object.assign({\n    xmlns: \"http://www.w3.org/2000/svg\",\n    height: \"24\",\n    viewBox: \"0 0 24 24\",\n    width: \"24\",\n    fill: \"#C1C1C1\"\n  }, {\n    children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      d: \"M0 0h24v24H0z\",\n      fill: \"none\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      d: \"M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z\"\n    })]\n  }));\n};\n\nconst CloseButton = ({\n  onClick\n}) => {\n  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", Object.assign({\n    onClick: onClick,\n    className: \"close-button\"\n  }, {\n    children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(CloseIcon, {})\n  }));\n};\n\nconst ModalHeader = ({\n  title,\n  onCloseModal\n}) => {\n  const additionalClasses = title === \"Get a Wallet\" ? \" -open\" : \"\";\n  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n    className: \"nws-modal-header\"\n  }, {\n    children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h3\", Object.assign({\n      className: `middleTitle ${additionalClasses}`\n    }, {\n      children: title\n    })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(CloseButton, {\n      onClick: onCloseModal\n    })]\n  }));\n};\n\nconst BackArrowIcon = () => {\n  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({\n    width: \"8\",\n    height: \"14\",\n    viewBox: \"0 0 8 14\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, {\n    children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      d: \"M7 13L1 7L7 1\",\n      stroke: \"#6494EE\",\n      strokeWidth: \"1.5\",\n      strokeLinecap: \"round\",\n      strokeLinejoin: \"round\"\n    })\n  }));\n};\n\nconst BackArrow = ({\n  onClick\n}) => {\n  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", Object.assign({\n    onClick: onClick,\n    className: \"back-button\"\n  }, {\n    children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BackArrowIcon, {})\n  }));\n};\n\nconst WalletNetworkChanged = ({\n  selector,\n  onBack,\n  onCloseModal\n}) => {\n  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react__WEBPACK_IMPORTED_MODULE_2__.Fragment, {\n    children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n      className: \"nws-modal-header-wrapper\"\n    }, {\n      children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BackArrow, {\n        onClick: onBack\n      }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ModalHeader, {\n        title: \"You Must Change the Network\",\n        onCloseModal: onCloseModal\n      })]\n    })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n      className: \"switch-network-message-wrapper\"\n    }, {\n      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n        className: \"content\"\n      }, {\n        children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"p\", {\n          children: [\"We've detected that you need to change your wallet's network to\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"strong\", Object.assign({\n            className: \"network-id\"\n          }, {\n            children: ` ${selector.options.network.networkId}`\n          })), \" \", \"for this dApp.\"]\n        }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", {\n          children: \"Some wallets may not support changing networks. If you can not change networks you may consider switching to another wallet.\"\n        })]\n      }))\n    }))]\n  });\n};\n\nvar tryToString$3 = tryToString$5;\n\nvar $TypeError$7 = TypeError;\n\nvar deletePropertyOrThrow$1 = function (O, P) {\n  if (!delete O[P]) throw $TypeError$7('Cannot delete property ' + tryToString$3(P) + ' of ' + tryToString$3(O));\n};\n\nvar wellKnownSymbol$9 = wellKnownSymbol$g;\n\nvar TO_STRING_TAG$1 = wellKnownSymbol$9('toStringTag');\nvar test$1 = {};\n\ntest$1[TO_STRING_TAG$1] = 'z';\n\nvar toStringTagSupport = String(test$1) === '[object z]';\n\nvar TO_STRING_TAG_SUPPORT = toStringTagSupport;\nvar isCallable$6 = isCallable$l;\nvar classofRaw = classofRaw$1;\nvar wellKnownSymbol$8 = wellKnownSymbol$g;\n\nvar TO_STRING_TAG = wellKnownSymbol$8('toStringTag');\nvar $Object = Object;\n\n// ES3 wrong here\nvar CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function (it, key) {\n  try {\n    return it[key];\n  } catch (error) { /* empty */ }\n};\n\n// getting tag from ES6+ `Object.prototype.toString`\nvar classof$5 = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {\n  var O, tag, result;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == 'string' ? tag\n    // builtinTag case\n    : CORRECT_ARGUMENTS ? classofRaw(O)\n    // ES3 arguments fallback\n    : (result = classofRaw(O)) == 'Object' && isCallable$6(O.callee) ? 'Arguments' : result;\n};\n\nvar classof$4 = classof$5;\n\nvar $String = String;\n\nvar toString$3 = function (argument) {\n  if (classof$4(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');\n  return $String(argument);\n};\n\nvar toPropertyKey = toPropertyKey$3;\nvar definePropertyModule$1 = objectDefineProperty;\nvar createPropertyDescriptor = createPropertyDescriptor$4;\n\nvar createProperty$1 = function (object, key, value) {\n  var propertyKey = toPropertyKey(key);\n  if (propertyKey in object) definePropertyModule$1.f(object, propertyKey, createPropertyDescriptor(0, value));\n  else object[propertyKey] = value;\n};\n\nvar toAbsoluteIndex = toAbsoluteIndex$2;\nvar lengthOfArrayLike$3 = lengthOfArrayLike$5;\nvar createProperty = createProperty$1;\n\nvar $Array = Array;\nvar max = Math.max;\n\nvar arraySliceSimple = function (O, start, end) {\n  var length = lengthOfArrayLike$3(O);\n  var k = toAbsoluteIndex(start, length);\n  var fin = toAbsoluteIndex(end === undefined ? length : end, length);\n  var result = $Array(max(fin - k, 0));\n  for (var n = 0; k < fin; k++, n++) createProperty(result, n, O[k]);\n  result.length = n;\n  return result;\n};\n\nvar arraySlice$2 = arraySliceSimple;\n\nvar floor = Math.floor;\n\nvar mergeSort = function (array, comparefn) {\n  var length = array.length;\n  var middle = floor(length / 2);\n  return length < 8 ? insertionSort(array, comparefn) : merge(\n    array,\n    mergeSort(arraySlice$2(array, 0, middle), comparefn),\n    mergeSort(arraySlice$2(array, middle), comparefn),\n    comparefn\n  );\n};\n\nvar insertionSort = function (array, comparefn) {\n  var length = array.length;\n  var i = 1;\n  var element, j;\n\n  while (i < length) {\n    j = i;\n    element = array[i];\n    while (j && comparefn(array[j - 1], element) > 0) {\n      array[j] = array[--j];\n    }\n    if (j !== i++) array[j] = element;\n  } return array;\n};\n\nvar merge = function (array, left, right, comparefn) {\n  var llength = left.length;\n  var rlength = right.length;\n  var lindex = 0;\n  var rindex = 0;\n\n  while (lindex < llength || rindex < rlength) {\n    array[lindex + rindex] = (lindex < llength && rindex < rlength)\n      ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++]\n      : lindex < llength ? left[lindex++] : right[rindex++];\n  } return array;\n};\n\nvar arraySort = mergeSort;\n\nvar fails$5 = fails$h;\n\nvar arrayMethodIsStrict$2 = function (METHOD_NAME, argument) {\n  var method = [][METHOD_NAME];\n  return !!method && fails$5(function () {\n    // eslint-disable-next-line no-useless-call -- required for testing\n    method.call(null, argument || function () { return 1; }, 1);\n  });\n};\n\nvar userAgent$4 = engineUserAgent;\n\nvar firefox = userAgent$4.match(/firefox\\/(\\d+)/i);\n\nvar engineFfVersion = !!firefox && +firefox[1];\n\nvar UA = engineUserAgent;\n\nvar engineIsIeOrEdge = /MSIE|Trident/.test(UA);\n\nvar userAgent$3 = engineUserAgent;\n\nvar webkit = userAgent$3.match(/AppleWebKit\\/(\\d+)\\./);\n\nvar engineWebkitVersion = !!webkit && +webkit[1];\n\nvar $$a = _export;\nvar uncurryThis$5 = functionUncurryThis;\nvar aCallable$7 = aCallable$9;\nvar toObject$1 = toObject$5;\nvar lengthOfArrayLike$2 = lengthOfArrayLike$5;\nvar deletePropertyOrThrow = deletePropertyOrThrow$1;\nvar toString$2 = toString$3;\nvar fails$4 = fails$h;\nvar internalSort = arraySort;\nvar arrayMethodIsStrict$1 = arrayMethodIsStrict$2;\nvar FF = engineFfVersion;\nvar IE_OR_EDGE = engineIsIeOrEdge;\nvar V8 = engineV8Version;\nvar WEBKIT = engineWebkitVersion;\n\nvar test = [];\nvar un$Sort = uncurryThis$5(test.sort);\nvar push = uncurryThis$5(test.push);\n\n// IE8-\nvar FAILS_ON_UNDEFINED = fails$4(function () {\n  test.sort(undefined);\n});\n// V8 bug\nvar FAILS_ON_NULL = fails$4(function () {\n  test.sort(null);\n});\n// Old WebKit\nvar STRICT_METHOD$1 = arrayMethodIsStrict$1('sort');\n\nvar STABLE_SORT = !fails$4(function () {\n  // feature detection can be too slow, so check engines versions\n  if (V8) return V8 < 70;\n  if (FF && FF > 3) return;\n  if (IE_OR_EDGE) return true;\n  if (WEBKIT) return WEBKIT < 603;\n\n  var result = '';\n  var code, chr, value, index;\n\n  // generate an array with more 512 elements (Chakra and old V8 fails only in this case)\n  for (code = 65; code < 76; code++) {\n    chr = String.fromCharCode(code);\n\n    switch (code) {\n      case 66: case 69: case 70: case 72: value = 3; break;\n      case 68: case 71: value = 4; break;\n      default: value = 2;\n    }\n\n    for (index = 0; index < 47; index++) {\n      test.push({ k: chr + index, v: value });\n    }\n  }\n\n  test.sort(function (a, b) { return b.v - a.v; });\n\n  for (index = 0; index < test.length; index++) {\n    chr = test[index].k.charAt(0);\n    if (result.charAt(result.length - 1) !== chr) result += chr;\n  }\n\n  return result !== 'DGBEFHACIJK';\n});\n\nvar FORCED = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD$1 || !STABLE_SORT;\n\nvar getSortCompare = function (comparefn) {\n  return function (x, y) {\n    if (y === undefined) return -1;\n    if (x === undefined) return 1;\n    if (comparefn !== undefined) return +comparefn(x, y) || 0;\n    return toString$2(x) > toString$2(y) ? 1 : -1;\n  };\n};\n\n// `Array.prototype.sort` method\n// https://tc39.es/ecma262/#sec-array.prototype.sort\n$$a({ target: 'Array', proto: true, forced: FORCED }, {\n  sort: function sort(comparefn) {\n    if (comparefn !== undefined) aCallable$7(comparefn);\n\n    var array = toObject$1(this);\n\n    if (STABLE_SORT) return comparefn === undefined ? un$Sort(array) : un$Sort(array, comparefn);\n\n    var items = [];\n    var arrayLength = lengthOfArrayLike$2(array);\n    var itemsLength, index;\n\n    for (index = 0; index < arrayLength; index++) {\n      if (index in array) push(items, array[index]);\n    }\n\n    internalSort(items, getSortCompare(comparefn));\n\n    itemsLength = items.length;\n    index = 0;\n\n    while (index < itemsLength) array[index] = items[index++];\n    while (index < arrayLength) deletePropertyOrThrow(array, index++);\n\n    return array;\n  }\n});\n\nvar $$9 = _export;\nvar $includes = arrayIncludes.includes;\nvar fails$3 = fails$h;\nvar addToUnscopables = addToUnscopables$2;\n\n// FF99+ bug\nvar BROKEN_ON_SPARSE = fails$3(function () {\n  return !Array(1).includes();\n});\n\n// `Array.prototype.includes` method\n// https://tc39.es/ecma262/#sec-array.prototype.includes\n$$9({ target: 'Array', proto: true, forced: BROKEN_ON_SPARSE }, {\n  includes: function includes(el /* , fromIndex = 0 */) {\n    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n\n// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\naddToUnscopables('includes');\n\nvar isObject$2 = isObject$8;\nvar classof$3 = classofRaw$1;\nvar wellKnownSymbol$7 = wellKnownSymbol$g;\n\nvar MATCH$1 = wellKnownSymbol$7('match');\n\n// `IsRegExp` abstract operation\n// https://tc39.es/ecma262/#sec-isregexp\nvar isRegexp = function (it) {\n  var isRegExp;\n  return isObject$2(it) && ((isRegExp = it[MATCH$1]) !== undefined ? !!isRegExp : classof$3(it) == 'RegExp');\n};\n\nvar isRegExp = isRegexp;\n\nvar $TypeError$6 = TypeError;\n\nvar notARegexp = function (it) {\n  if (isRegExp(it)) {\n    throw $TypeError$6(\"The method doesn't accept regular expressions\");\n  } return it;\n};\n\nvar wellKnownSymbol$6 = wellKnownSymbol$g;\n\nvar MATCH = wellKnownSymbol$6('match');\n\nvar correctIsRegexpLogic = function (METHOD_NAME) {\n  var regexp = /./;\n  try {\n    '/./'[METHOD_NAME](regexp);\n  } catch (error1) {\n    try {\n      regexp[MATCH] = false;\n      return '/./'[METHOD_NAME](regexp);\n    } catch (error2) { /* empty */ }\n  } return false;\n};\n\nvar $$8 = _export;\nvar uncurryThis$4 = functionUncurryThis;\nvar notARegExp = notARegexp;\nvar requireObjectCoercible = requireObjectCoercible$3;\nvar toString$1 = toString$3;\nvar correctIsRegExpLogic = correctIsRegexpLogic;\n\nvar stringIndexOf = uncurryThis$4(''.indexOf);\n\n// `String.prototype.includes` method\n// https://tc39.es/ecma262/#sec-string.prototype.includes\n$$8({ target: 'String', proto: true, forced: !correctIsRegExpLogic('includes') }, {\n  includes: function includes(searchString /* , position = 0 */) {\n    return !!~stringIndexOf(\n      toString$1(requireObjectCoercible(this)),\n      toString$1(notARegExp(searchString)),\n      arguments.length > 1 ? arguments[1] : undefined\n    );\n  }\n});\n\nvar aCallable$6 = aCallable$9;\nvar toObject = toObject$5;\nvar IndexedObject = indexedObject;\nvar lengthOfArrayLike$1 = lengthOfArrayLike$5;\n\nvar $TypeError$5 = TypeError;\n\n// `Array.prototype.{ reduce, reduceRight }` methods implementation\nvar createMethod = function (IS_RIGHT) {\n  return function (that, callbackfn, argumentsLength, memo) {\n    aCallable$6(callbackfn);\n    var O = toObject(that);\n    var self = IndexedObject(O);\n    var length = lengthOfArrayLike$1(O);\n    var index = IS_RIGHT ? length - 1 : 0;\n    var i = IS_RIGHT ? -1 : 1;\n    if (argumentsLength < 2) while (true) {\n      if (index in self) {\n        memo = self[index];\n        index += i;\n        break;\n      }\n      index += i;\n      if (IS_RIGHT ? index < 0 : length <= index) {\n        throw $TypeError$5('Reduce of empty array with no initial value');\n      }\n    }\n    for (;IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {\n      memo = callbackfn(memo, self[index], index, O);\n    }\n    return memo;\n  };\n};\n\nvar arrayReduce = {\n  // `Array.prototype.reduce` method\n  // https://tc39.es/ecma262/#sec-array.prototype.reduce\n  left: createMethod(false),\n  // `Array.prototype.reduceRight` method\n  // https://tc39.es/ecma262/#sec-array.prototype.reduceright\n  right: createMethod(true)\n};\n\nvar classof$2 = classofRaw$1;\nvar global$9 = global$k;\n\nvar engineIsNode = classof$2(global$9.process) == 'process';\n\nvar $$7 = _export;\nvar $reduce = arrayReduce.left;\nvar arrayMethodIsStrict = arrayMethodIsStrict$2;\nvar CHROME_VERSION = engineV8Version;\nvar IS_NODE$3 = engineIsNode;\n\nvar STRICT_METHOD = arrayMethodIsStrict('reduce');\n// Chrome 80-82 has a critical bug\n// https://bugs.chromium.org/p/chromium/issues/detail?id=1049982\nvar CHROME_BUG = !IS_NODE$3 && CHROME_VERSION > 79 && CHROME_VERSION < 83;\n\n// `Array.prototype.reduce` method\n// https://tc39.es/ecma262/#sec-array.prototype.reduce\n$$7({ target: 'Array', proto: true, forced: !STRICT_METHOD || CHROME_BUG }, {\n  reduce: function reduce(callbackfn /* , initialValue */) {\n    var length = arguments.length;\n    return $reduce(this, callbackfn, length, length > 1 ? arguments[1] : undefined);\n  }\n});\n\nvar $$6 = _export;\nvar DESCRIPTORS$1 = descriptors;\nvar global$8 = global$k;\nvar uncurryThis$3 = functionUncurryThis;\nvar hasOwn$2 = hasOwnProperty_1;\nvar isCallable$5 = isCallable$l;\nvar isPrototypeOf$3 = objectIsPrototypeOf;\nvar toString = toString$3;\nvar defineProperty = objectDefineProperty.f;\nvar copyConstructorProperties = copyConstructorProperties$2;\n\nvar NativeSymbol = global$8.Symbol;\nvar SymbolPrototype = NativeSymbol && NativeSymbol.prototype;\n\nif (DESCRIPTORS$1 && isCallable$5(NativeSymbol) && (!('description' in SymbolPrototype) ||\n  // Safari 12 bug\n  NativeSymbol().description !== undefined\n)) {\n  var EmptyStringDescriptionStore = {};\n  // wrap Symbol constructor for correct work with undefined description\n  var SymbolWrapper = function Symbol() {\n    var description = arguments.length < 1 || arguments[0] === undefined ? undefined : toString(arguments[0]);\n    var result = isPrototypeOf$3(SymbolPrototype, this)\n      ? new NativeSymbol(description)\n      // in Edge 13, String(Symbol(undefined)) === 'Symbol(undefined)'\n      : description === undefined ? NativeSymbol() : NativeSymbol(description);\n    if (description === '') EmptyStringDescriptionStore[result] = true;\n    return result;\n  };\n\n  copyConstructorProperties(SymbolWrapper, NativeSymbol);\n  SymbolWrapper.prototype = SymbolPrototype;\n  SymbolPrototype.constructor = SymbolWrapper;\n\n  var NATIVE_SYMBOL = String(NativeSymbol('test')) == 'Symbol(test)';\n  var symbolToString = uncurryThis$3(SymbolPrototype.toString);\n  var symbolValueOf = uncurryThis$3(SymbolPrototype.valueOf);\n  var regexp = /^Symbol\\((.*)\\)[^)]+$/;\n  var replace = uncurryThis$3(''.replace);\n  var stringSlice = uncurryThis$3(''.slice);\n\n  defineProperty(SymbolPrototype, 'description', {\n    configurable: true,\n    get: function description() {\n      var symbol = symbolValueOf(this);\n      var string = symbolToString(symbol);\n      if (hasOwn$2(EmptyStringDescriptionStore, symbol)) return '';\n      var desc = NATIVE_SYMBOL ? stringSlice(string, 7, -1) : replace(string, regexp, '$1');\n      return desc === '' ? undefined : desc;\n    }\n  });\n\n  $$6({ global: true, constructor: true, forced: true }, {\n    Symbol: SymbolWrapper\n  });\n}\n\nconst WarningIcon = () => {\n  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"svg\", Object.assign({\n    width: \"18\",\n    height: \"18\",\n    viewBox: \"0 0 24 24\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, {\n    children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      d: \"M4.95215 16.3536L10.2152 5.85657C10.9531 4.38481 13.0538 4.38519 13.7912 5.85723L19.0494 16.3543C19.7156 17.6841 18.7486 19.25 17.2612 19.25H6.74001C5.25228 19.25 4.28535 17.6835 4.95215 16.3536Z\",\n      stroke: \"#E6B73E\",\n      strokeWidth: \"1.5\",\n      strokeLinecap: \"round\",\n      strokeLinejoin: \"round\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      d: \"M12 10V12\",\n      stroke: \"#E6B73E\",\n      strokeWidth: \"2\",\n      strokeLinecap: \"round\",\n      strokeLinejoin: \"round\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      d: \"M12.5 16C12.5 16.2761 12.2761 16.5 12 16.5C11.7239 16.5 11.5 16.2761 11.5 16C11.5 15.7239 11.7239 15.5 12 15.5C12.2761 15.5 12.5 15.7239 12.5 16Z\",\n      stroke: \"#E6B73E\"\n    })]\n  }));\n};\n\nconst WalletOptions = ({\n  selector,\n  handleWalletClick\n}) => {\n  const [modules, setModules] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)([]);\n  const [recentModules, setRecentModules] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)([]);\n  const [moreModules, setMoreModules] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)([]);\n  const [activeWalletId, setActiveWalletId] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(\"\");\n  (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(() => {\n    const subscription = selector.store.observable.subscribe(state => {\n      const {\n        selectedWalletId\n      } = selector.store.getState();\n      if (selectedWalletId) {\n        setActiveWalletId(selectedWalletId);\n      }\n      const wallets = state.modules.filter(module => !(module.type === \"instant-link\" && selectedWalletId !== module.id));\n      if (selector.options.optimizeWalletOrder) {\n        state.modules.sort((current, next) => {\n          if (current.metadata.deprecated === next.metadata.deprecated) {\n            return 0;\n          }\n          return current.metadata.deprecated ? 1 : -1;\n        });\n        state.modules.sort((current, next) => {\n          if (next.metadata.available === current.metadata.available) {\n            return 0;\n          }\n          return next.metadata.available ? 1 : -1;\n        });\n        const moreWallets = [];\n        const recentlySignedInWallets = [];\n        wallets.forEach(module => {\n          if (selector.store.getState().recentlySignedInWallets.includes(module.id)) {\n            recentlySignedInWallets.push(module);\n          } else {\n            moreWallets.push(module);\n          }\n        });\n        setRecentModules(recentlySignedInWallets);\n        setMoreModules(moreWallets);\n      }\n      if (selector.options.randomizeWalletOrder) {\n        setModules(wallets.sort(() => Math.random() - 0.5));\n      } else {\n        setModules(wallets);\n      }\n    });\n    return () => subscription.unsubscribe();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  function renderOptionsList(modulesToRender) {\n    return modulesToRender.reduce((result, module, index) => {\n      const {\n        selectedWalletId\n      } = selector.store.getState();\n      const {\n        name,\n        description,\n        iconUrl,\n        deprecated\n      } = module.metadata;\n      const selected = module.id === selectedWalletId;\n      result.push((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"li\", Object.assign({\n        tabIndex: 0,\n        className: `single-wallet ${activeWalletId === module.id ? \"selected-wallet\" : \"\"} ${selected ? \"connected-wallet\" : \"\"} ${deprecated ? \"deprecated-wallet\" : \"\"} sidebar ${module.id}`,\n        onClick: () => {\n          if (module.id === modulesToRender[index].id) {\n            setActiveWalletId(module.id);\n          }\n          return handleWalletClick(module);\n        }\n      }, {\n        children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n          className: \"icon\"\n        }, {\n          children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"img\", {\n            src: iconUrl,\n            alt: name\n          })\n        })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n          className: \"content\"\n        }, {\n          children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n            className: \"title\"\n          }, {\n            children: name\n          })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n            className: \"description\"\n          }, {\n            children: description\n          }))]\n        })), deprecated && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n          className: \"warning-triangle\"\n        }, {\n          children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(WarningIcon, {})\n        }))]\n      }), module.id));\n      return result;\n    }, []);\n  }\n  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n    children: selector.options.optimizeWalletOrder && selector.store.getState().recentlySignedInWallets.length > 0 ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n      className: \"wallet-options-wrapper\"\n    }, {\n      children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n        className: \"options-list-section\"\n      }, {\n        children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n          className: \"options-list-section-header\"\n        }, {\n          children: \"Recent\"\n        })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n          className: \"options-list more-options-list-content\"\n        }, {\n          children: renderOptionsList(recentModules)\n        }))]\n      })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n        className: \"options-list-section\"\n      }, {\n        children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n          className: \"options-list-section-header\"\n        }, {\n          children: \"More\"\n        })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n          className: \"options-list more-options-list-content\"\n        }, {\n          children: renderOptionsList(moreModules)\n        }))]\n      }))]\n    })) : (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n      className: \"wallet-options-wrapper\"\n    }, {\n      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n        className: \"options-list\"\n      }, {\n        children: renderOptionsList(modules)\n      }))\n    }))\n  });\n};\n\nconst ConnectionErrorIcon = () => {\n  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"svg\", Object.assign({\n    width: \"21\",\n    height: \"20\",\n    viewBox: \"0 0 21 20\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, {\n    children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      d: \"M10.5001 18.3333C15.1025 18.3333 18.8334 14.6023 18.8334 9.99996C18.8334 5.39759 15.1025 1.66663 10.5001 1.66663C5.89771 1.66663 2.16675 5.39759 2.16675 9.99996C2.16675 14.6023 5.89771 18.3333 10.5001 18.3333Z\",\n      stroke: \"#CE5A6F\",\n      strokeWidth: \"2\",\n      strokeLinecap: \"round\",\n      strokeLinejoin: \"round\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      d: \"M13 7.5L8 12.5\",\n      stroke: \"#CE5A6F\",\n      strokeWidth: \"2\",\n      strokeLinecap: \"round\",\n      strokeLinejoin: \"round\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      d: \"M8 7.5L13 12.5\",\n      stroke: \"#CE5A6F\",\n      strokeWidth: \"2\",\n      strokeLinecap: \"round\",\n      strokeLinejoin: \"round\"\n    })]\n  }));\n};\n\nconst ConnectionSuccessIcon = () => {\n  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"svg\", Object.assign({\n    width: \"21\",\n    height: \"20\",\n    viewBox: \"0 0 21 20\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, {\n    children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      d: \"M18.8333 9.2333V9.99997C18.8323 11.797 18.2504 13.5455 17.1744 14.9848C16.0984 16.4241 14.586 17.477 12.8628 17.9866C11.1395 18.4961 9.29768 18.4349 7.61202 17.8121C5.92636 17.1894 4.48717 16.0384 3.50909 14.5309C2.53101 13.0233 2.06645 11.24 2.18469 9.4469C2.30293 7.65377 2.99763 5.94691 4.16519 4.58086C5.33275 3.21482 6.91061 2.26279 8.66345 1.86676C10.4163 1.47073 12.2502 1.65192 13.8916 2.3833\",\n      stroke: \"#4FD98F\",\n      strokeWidth: \"2\",\n      strokeLinecap: \"round\",\n      strokeLinejoin: \"round\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      d: \"M18.8333 3.33337L10.5 11.675L8 9.17504\",\n      stroke: \"#4FD98F\",\n      strokeWidth: \"2\",\n      strokeLinecap: \"round\",\n      strokeLinejoin: \"round\"\n    })]\n  }));\n};\n\nconst ConnectionResult = ({\n  module,\n  message,\n  err,\n  onRetry\n}) => {\n  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n    className: \"connection connecting-details\"\n  }, {\n    children: err ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n      className: \"error-wrapper\"\n    }, {\n      children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n        className: \"error\"\n      }, {\n        children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ConnectionErrorIcon, {}), (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.wallet.connectionFailed\")]\n      })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", {\n        children: message\n      }), (module === null || module === void 0 ? void 0 : module.metadata.available) && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", Object.assign({\n        onClick: onRetry\n      }, {\n        children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.ledger.retry\")\n      }))]\n    })) : (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n      className: \"success\"\n    }, {\n      children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ConnectionSuccessIcon, {}), (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.wallet.connectionSuccessful\")]\n    }))\n  }));\n};\n\nconst AlertMessage = ({\n  message,\n  module,\n  onBack,\n  onCloseModal\n}) => {\n  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react__WEBPACK_IMPORTED_MODULE_2__.Fragment, {\n    children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ModalHeader, {\n      title: \"\",\n      onCloseModal: onCloseModal\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n      className: \"alert-message connecting-wrapper connecting-wrapper-err\"\n    }, {\n      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n        className: \"content\"\n      }, {\n        children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n          className: \"icon\"\n        }, {\n          children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"img\", {\n            src: module === null || module === void 0 ? void 0 : module.metadata.iconUrl,\n            alt: module === null || module === void 0 ? void 0 : module.metadata.name\n          })\n        })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h3\", Object.assign({\n          className: \"connecting-name\"\n        }, {\n          children: module === null || module === void 0 ? void 0 : module.metadata.name\n        })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ConnectionResult, {\n          module: module,\n          message: message,\n          err: message !== null,\n          onRetry: () => {\n            onBack(true);\n          }\n        })]\n      }))\n    }))]\n  });\n};\n\nvar getBuiltIn$3 = getBuiltIn$8;\nvar definePropertyModule = objectDefineProperty;\nvar wellKnownSymbol$5 = wellKnownSymbol$g;\nvar DESCRIPTORS = descriptors;\n\nvar SPECIES$2 = wellKnownSymbol$5('species');\n\nvar setSpecies$1 = function (CONSTRUCTOR_NAME) {\n  var Constructor = getBuiltIn$3(CONSTRUCTOR_NAME);\n  var defineProperty = definePropertyModule.f;\n\n  if (DESCRIPTORS && Constructor && !Constructor[SPECIES$2]) {\n    defineProperty(Constructor, SPECIES$2, {\n      configurable: true,\n      get: function () { return this; }\n    });\n  }\n};\n\nvar isPrototypeOf$2 = objectIsPrototypeOf;\n\nvar $TypeError$4 = TypeError;\n\nvar anInstance$1 = function (it, Prototype) {\n  if (isPrototypeOf$2(Prototype, it)) return it;\n  throw $TypeError$4('Incorrect invocation');\n};\n\nvar uncurryThis$2 = functionUncurryThis;\nvar fails$2 = fails$h;\nvar isCallable$4 = isCallable$l;\nvar classof$1 = classof$5;\nvar getBuiltIn$2 = getBuiltIn$8;\nvar inspectSource$1 = inspectSource$4;\n\nvar noop = function () { /* empty */ };\nvar empty = [];\nvar construct = getBuiltIn$2('Reflect', 'construct');\nvar constructorRegExp = /^\\s*(?:class|function)\\b/;\nvar exec = uncurryThis$2(constructorRegExp.exec);\nvar INCORRECT_TO_STRING = !constructorRegExp.exec(noop);\n\nvar isConstructorModern = function isConstructor(argument) {\n  if (!isCallable$4(argument)) return false;\n  try {\n    construct(noop, empty, argument);\n    return true;\n  } catch (error) {\n    return false;\n  }\n};\n\nvar isConstructorLegacy = function isConstructor(argument) {\n  if (!isCallable$4(argument)) return false;\n  switch (classof$1(argument)) {\n    case 'AsyncFunction':\n    case 'GeneratorFunction':\n    case 'AsyncGeneratorFunction': return false;\n  }\n  try {\n    // we can't check .prototype since constructors produced by .bind haven't it\n    // `Function#toString` throws on some built-it function in some legacy engines\n    // (for example, `DOMQuad` and similar in FF41-)\n    return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource$1(argument));\n  } catch (error) {\n    return true;\n  }\n};\n\nisConstructorLegacy.sham = true;\n\n// `IsConstructor` abstract operation\n// https://tc39.es/ecma262/#sec-isconstructor\nvar isConstructor$1 = !construct || fails$2(function () {\n  var called;\n  return isConstructorModern(isConstructorModern.call)\n    || !isConstructorModern(Object)\n    || !isConstructorModern(function () { called = true; })\n    || called;\n}) ? isConstructorLegacy : isConstructorModern;\n\nvar isConstructor = isConstructor$1;\nvar tryToString$2 = tryToString$5;\n\nvar $TypeError$3 = TypeError;\n\n// `Assert: IsConstructor(argument) is true`\nvar aConstructor$1 = function (argument) {\n  if (isConstructor(argument)) return argument;\n  throw $TypeError$3(tryToString$2(argument) + ' is not a constructor');\n};\n\nvar anObject$6 = anObject$c;\nvar aConstructor = aConstructor$1;\nvar wellKnownSymbol$4 = wellKnownSymbol$g;\n\nvar SPECIES$1 = wellKnownSymbol$4('species');\n\n// `SpeciesConstructor` abstract operation\n// https://tc39.es/ecma262/#sec-speciesconstructor\nvar speciesConstructor$1 = function (O, defaultConstructor) {\n  var C = anObject$6(O).constructor;\n  var S;\n  return C === undefined || (S = anObject$6(C)[SPECIES$1]) == undefined ? defaultConstructor : aConstructor(S);\n};\n\nvar NATIVE_BIND$1 = functionBindNative;\n\nvar FunctionPrototype = Function.prototype;\nvar apply$1 = FunctionPrototype.apply;\nvar call$8 = FunctionPrototype.call;\n\n// eslint-disable-next-line es-x/no-reflect -- safe\nvar functionApply = typeof Reflect == 'object' && Reflect.apply || (NATIVE_BIND$1 ? call$8.bind(apply$1) : function () {\n  return call$8.apply(apply$1, arguments);\n});\n\nvar uncurryThis$1 = functionUncurryThis;\nvar aCallable$5 = aCallable$9;\nvar NATIVE_BIND = functionBindNative;\n\nvar bind$4 = uncurryThis$1(uncurryThis$1.bind);\n\n// optional / simple context binding\nvar functionBindContext = function (fn, that) {\n  aCallable$5(fn);\n  return that === undefined ? fn : NATIVE_BIND ? bind$4(fn, that) : function (/* ...args */) {\n    return fn.apply(that, arguments);\n  };\n};\n\nvar uncurryThis = functionUncurryThis;\n\nvar arraySlice$1 = uncurryThis([].slice);\n\nvar $TypeError$2 = TypeError;\n\nvar validateArgumentsLength$1 = function (passed, required) {\n  if (passed < required) throw $TypeError$2('Not enough arguments');\n  return passed;\n};\n\nvar userAgent$2 = engineUserAgent;\n\nvar engineIsIos = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent$2);\n\nvar global$7 = global$k;\nvar apply = functionApply;\nvar bind$3 = functionBindContext;\nvar isCallable$3 = isCallable$l;\nvar hasOwn$1 = hasOwnProperty_1;\nvar fails$1 = fails$h;\nvar html = html$2;\nvar arraySlice = arraySlice$1;\nvar createElement = documentCreateElement$2;\nvar validateArgumentsLength = validateArgumentsLength$1;\nvar IS_IOS$1 = engineIsIos;\nvar IS_NODE$2 = engineIsNode;\n\nvar set = global$7.setImmediate;\nvar clear = global$7.clearImmediate;\nvar process$2 = global$7.process;\nvar Dispatch = global$7.Dispatch;\nvar Function$1 = global$7.Function;\nvar MessageChannel = global$7.MessageChannel;\nvar String$1 = global$7.String;\nvar counter = 0;\nvar queue$1 = {};\nvar ONREADYSTATECHANGE = 'onreadystatechange';\nvar location, defer, channel, port;\n\ntry {\n  // Deno throws a ReferenceError on `location` access without `--location` flag\n  location = global$7.location;\n} catch (error) { /* empty */ }\n\nvar run = function (id) {\n  if (hasOwn$1(queue$1, id)) {\n    var fn = queue$1[id];\n    delete queue$1[id];\n    fn();\n  }\n};\n\nvar runner = function (id) {\n  return function () {\n    run(id);\n  };\n};\n\nvar listener = function (event) {\n  run(event.data);\n};\n\nvar post = function (id) {\n  // old engines have not location.origin\n  global$7.postMessage(String$1(id), location.protocol + '//' + location.host);\n};\n\n// Node.js 0.9+ & IE10+ has setImmediate, otherwise:\nif (!set || !clear) {\n  set = function setImmediate(handler) {\n    validateArgumentsLength(arguments.length, 1);\n    var fn = isCallable$3(handler) ? handler : Function$1(handler);\n    var args = arraySlice(arguments, 1);\n    queue$1[++counter] = function () {\n      apply(fn, undefined, args);\n    };\n    defer(counter);\n    return counter;\n  };\n  clear = function clearImmediate(id) {\n    delete queue$1[id];\n  };\n  // Node.js 0.8-\n  if (IS_NODE$2) {\n    defer = function (id) {\n      process$2.nextTick(runner(id));\n    };\n  // Sphere (JS game engine) Dispatch API\n  } else if (Dispatch && Dispatch.now) {\n    defer = function (id) {\n      Dispatch.now(runner(id));\n    };\n  // Browsers with MessageChannel, includes WebWorkers\n  // except iOS - https://github.com/zloirock/core-js/issues/624\n  } else if (MessageChannel && !IS_IOS$1) {\n    channel = new MessageChannel();\n    port = channel.port2;\n    channel.port1.onmessage = listener;\n    defer = bind$3(port.postMessage, port);\n  // Browsers with postMessage, skip WebWorkers\n  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'\n  } else if (\n    global$7.addEventListener &&\n    isCallable$3(global$7.postMessage) &&\n    !global$7.importScripts &&\n    location && location.protocol !== 'file:' &&\n    !fails$1(post)\n  ) {\n    defer = post;\n    global$7.addEventListener('message', listener, false);\n  // IE8-\n  } else if (ONREADYSTATECHANGE in createElement('script')) {\n    defer = function (id) {\n      html.appendChild(createElement('script'))[ONREADYSTATECHANGE] = function () {\n        html.removeChild(this);\n        run(id);\n      };\n    };\n  // Rest old browsers\n  } else {\n    defer = function (id) {\n      setTimeout(runner(id), 0);\n    };\n  }\n}\n\nvar task$1 = {\n  set: set,\n  clear: clear\n};\n\nvar userAgent$1 = engineUserAgent;\nvar global$6 = global$k;\n\nvar engineIsIosPebble = /ipad|iphone|ipod/i.test(userAgent$1) && global$6.Pebble !== undefined;\n\nvar userAgent = engineUserAgent;\n\nvar engineIsWebosWebkit = /web0s(?!.*chrome)/i.test(userAgent);\n\nvar global$5 = global$k;\nvar bind$2 = functionBindContext;\nvar getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;\nvar macrotask = task$1.set;\nvar IS_IOS = engineIsIos;\nvar IS_IOS_PEBBLE = engineIsIosPebble;\nvar IS_WEBOS_WEBKIT = engineIsWebosWebkit;\nvar IS_NODE$1 = engineIsNode;\n\nvar MutationObserver = global$5.MutationObserver || global$5.WebKitMutationObserver;\nvar document$2 = global$5.document;\nvar process$1 = global$5.process;\nvar Promise$1 = global$5.Promise;\n// Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`\nvar queueMicrotaskDescriptor = getOwnPropertyDescriptor(global$5, 'queueMicrotask');\nvar queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;\n\nvar flush, head, last, notify$1, toggle, node, promise, then;\n\n// modern engines have queueMicrotask method\nif (!queueMicrotask) {\n  flush = function () {\n    var parent, fn;\n    if (IS_NODE$1 && (parent = process$1.domain)) parent.exit();\n    while (head) {\n      fn = head.fn;\n      head = head.next;\n      try {\n        fn();\n      } catch (error) {\n        if (head) notify$1();\n        else last = undefined;\n        throw error;\n      }\n    } last = undefined;\n    if (parent) parent.enter();\n  };\n\n  // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339\n  // also except WebOS Webkit https://github.com/zloirock/core-js/issues/898\n  if (!IS_IOS && !IS_NODE$1 && !IS_WEBOS_WEBKIT && MutationObserver && document$2) {\n    toggle = true;\n    node = document$2.createTextNode('');\n    new MutationObserver(flush).observe(node, { characterData: true });\n    notify$1 = function () {\n      node.data = toggle = !toggle;\n    };\n  // environments with maybe non-completely correct, but existent Promise\n  } else if (!IS_IOS_PEBBLE && Promise$1 && Promise$1.resolve) {\n    // Promise.resolve without an argument throws an error in LG WebOS 2\n    promise = Promise$1.resolve(undefined);\n    // workaround of WebKit ~ iOS Safari 10.1 bug\n    promise.constructor = Promise$1;\n    then = bind$2(promise.then, promise);\n    notify$1 = function () {\n      then(flush);\n    };\n  // Node.js without promises\n  } else if (IS_NODE$1) {\n    notify$1 = function () {\n      process$1.nextTick(flush);\n    };\n  // for other environments - macrotask based on:\n  // - setImmediate\n  // - MessageChannel\n  // - window.postMessage\n  // - onreadystatechange\n  // - setTimeout\n  } else {\n    // strange IE + webpack dev server bug - use .bind(global)\n    macrotask = bind$2(macrotask, global$5);\n    notify$1 = function () {\n      macrotask(flush);\n    };\n  }\n}\n\nvar microtask$1 = queueMicrotask || function (fn) {\n  var task = { fn: fn, next: undefined };\n  if (last) last.next = task;\n  if (!head) {\n    head = task;\n    notify$1();\n  } last = task;\n};\n\nvar global$4 = global$k;\n\nvar hostReportErrors$1 = function (a, b) {\n  var console = global$4.console;\n  if (console && console.error) {\n    arguments.length == 1 ? console.error(a) : console.error(a, b);\n  }\n};\n\nvar perform$3 = function (exec) {\n  try {\n    return { error: false, value: exec() };\n  } catch (error) {\n    return { error: true, value: error };\n  }\n};\n\nvar Queue$1 = function () {\n  this.head = null;\n  this.tail = null;\n};\n\nQueue$1.prototype = {\n  add: function (item) {\n    var entry = { item: item, next: null };\n    if (this.head) this.tail.next = entry;\n    else this.head = entry;\n    this.tail = entry;\n  },\n  get: function () {\n    var entry = this.head;\n    if (entry) {\n      this.head = entry.next;\n      if (this.tail === entry) this.tail = null;\n      return entry.item;\n    }\n  }\n};\n\nvar queue = Queue$1;\n\nvar global$3 = global$k;\n\nvar promiseNativeConstructor = global$3.Promise;\n\nvar engineIsBrowser = typeof window == 'object' && typeof Deno != 'object';\n\nvar global$2 = global$k;\nvar NativePromiseConstructor$3 = promiseNativeConstructor;\nvar isCallable$2 = isCallable$l;\nvar isForced = isForced_1;\nvar inspectSource = inspectSource$4;\nvar wellKnownSymbol$3 = wellKnownSymbol$g;\nvar IS_BROWSER = engineIsBrowser;\nvar V8_VERSION = engineV8Version;\n\nNativePromiseConstructor$3 && NativePromiseConstructor$3.prototype;\nvar SPECIES = wellKnownSymbol$3('species');\nvar SUBCLASSING = false;\nvar NATIVE_PROMISE_REJECTION_EVENT$1 = isCallable$2(global$2.PromiseRejectionEvent);\n\nvar FORCED_PROMISE_CONSTRUCTOR$5 = isForced('Promise', function () {\n  var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(NativePromiseConstructor$3);\n  var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(NativePromiseConstructor$3);\n  // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=830565\n  // We can't detect it synchronously, so just check versions\n  if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66) return true;\n  // We can't use @@species feature detection in V8 since it causes\n  // deoptimization and performance degradation\n  // https://github.com/zloirock/core-js/issues/679\n  if (V8_VERSION >= 51 && /native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) return false;\n  // Detect correctness of subclassing with @@species support\n  var promise = new NativePromiseConstructor$3(function (resolve) { resolve(1); });\n  var FakePromise = function (exec) {\n    exec(function () { /* empty */ }, function () { /* empty */ });\n  };\n  var constructor = promise.constructor = {};\n  constructor[SPECIES] = FakePromise;\n  SUBCLASSING = promise.then(function () { /* empty */ }) instanceof FakePromise;\n  if (!SUBCLASSING) return true;\n  // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test\n  return !GLOBAL_CORE_JS_PROMISE && IS_BROWSER && !NATIVE_PROMISE_REJECTION_EVENT$1;\n});\n\nvar promiseConstructorDetection = {\n  CONSTRUCTOR: FORCED_PROMISE_CONSTRUCTOR$5,\n  REJECTION_EVENT: NATIVE_PROMISE_REJECTION_EVENT$1,\n  SUBCLASSING: SUBCLASSING\n};\n\nvar newPromiseCapability$2 = {};\n\nvar aCallable$4 = aCallable$9;\n\nvar PromiseCapability = function (C) {\n  var resolve, reject;\n  this.promise = new C(function ($$resolve, $$reject) {\n    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');\n    resolve = $$resolve;\n    reject = $$reject;\n  });\n  this.resolve = aCallable$4(resolve);\n  this.reject = aCallable$4(reject);\n};\n\n// `NewPromiseCapability` abstract operation\n// https://tc39.es/ecma262/#sec-newpromisecapability\nnewPromiseCapability$2.f = function (C) {\n  return new PromiseCapability(C);\n};\n\nvar $$5 = _export;\nvar IS_NODE = engineIsNode;\nvar global$1 = global$k;\nvar call$7 = functionCall;\nvar defineBuiltIn$2 = defineBuiltIn$6;\nvar setPrototypeOf = objectSetPrototypeOf;\nvar setToStringTag = setToStringTag$3;\nvar setSpecies = setSpecies$1;\nvar aCallable$3 = aCallable$9;\nvar isCallable$1 = isCallable$l;\nvar isObject$1 = isObject$8;\nvar anInstance = anInstance$1;\nvar speciesConstructor = speciesConstructor$1;\nvar task = task$1.set;\nvar microtask = microtask$1;\nvar hostReportErrors = hostReportErrors$1;\nvar perform$2 = perform$3;\nvar Queue = queue;\nvar InternalStateModule = internalState;\nvar NativePromiseConstructor$2 = promiseNativeConstructor;\nvar PromiseConstructorDetection = promiseConstructorDetection;\nvar newPromiseCapabilityModule$3 = newPromiseCapability$2;\n\nvar PROMISE = 'Promise';\nvar FORCED_PROMISE_CONSTRUCTOR$4 = PromiseConstructorDetection.CONSTRUCTOR;\nvar NATIVE_PROMISE_REJECTION_EVENT = PromiseConstructorDetection.REJECTION_EVENT;\nvar NATIVE_PROMISE_SUBCLASSING = PromiseConstructorDetection.SUBCLASSING;\nvar getInternalPromiseState = InternalStateModule.getterFor(PROMISE);\nvar setInternalState = InternalStateModule.set;\nvar NativePromisePrototype$1 = NativePromiseConstructor$2 && NativePromiseConstructor$2.prototype;\nvar PromiseConstructor = NativePromiseConstructor$2;\nvar PromisePrototype = NativePromisePrototype$1;\nvar TypeError$1 = global$1.TypeError;\nvar document$1 = global$1.document;\nvar process = global$1.process;\nvar newPromiseCapability$1 = newPromiseCapabilityModule$3.f;\nvar newGenericPromiseCapability = newPromiseCapability$1;\n\nvar DISPATCH_EVENT = !!(document$1 && document$1.createEvent && global$1.dispatchEvent);\nvar UNHANDLED_REJECTION = 'unhandledrejection';\nvar REJECTION_HANDLED = 'rejectionhandled';\nvar PENDING = 0;\nvar FULFILLED = 1;\nvar REJECTED = 2;\nvar HANDLED = 1;\nvar UNHANDLED = 2;\n\nvar Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;\n\n// helpers\nvar isThenable = function (it) {\n  var then;\n  return isObject$1(it) && isCallable$1(then = it.then) ? then : false;\n};\n\nvar callReaction = function (reaction, state) {\n  var value = state.value;\n  var ok = state.state == FULFILLED;\n  var handler = ok ? reaction.ok : reaction.fail;\n  var resolve = reaction.resolve;\n  var reject = reaction.reject;\n  var domain = reaction.domain;\n  var result, then, exited;\n  try {\n    if (handler) {\n      if (!ok) {\n        if (state.rejection === UNHANDLED) onHandleUnhandled(state);\n        state.rejection = HANDLED;\n      }\n      if (handler === true) result = value;\n      else {\n        if (domain) domain.enter();\n        result = handler(value); // can throw\n        if (domain) {\n          domain.exit();\n          exited = true;\n        }\n      }\n      if (result === reaction.promise) {\n        reject(TypeError$1('Promise-chain cycle'));\n      } else if (then = isThenable(result)) {\n        call$7(then, result, resolve, reject);\n      } else resolve(result);\n    } else reject(value);\n  } catch (error) {\n    if (domain && !exited) domain.exit();\n    reject(error);\n  }\n};\n\nvar notify = function (state, isReject) {\n  if (state.notified) return;\n  state.notified = true;\n  microtask(function () {\n    var reactions = state.reactions;\n    var reaction;\n    while (reaction = reactions.get()) {\n      callReaction(reaction, state);\n    }\n    state.notified = false;\n    if (isReject && !state.rejection) onUnhandled(state);\n  });\n};\n\nvar dispatchEvent = function (name, promise, reason) {\n  var event, handler;\n  if (DISPATCH_EVENT) {\n    event = document$1.createEvent('Event');\n    event.promise = promise;\n    event.reason = reason;\n    event.initEvent(name, false, true);\n    global$1.dispatchEvent(event);\n  } else event = { promise: promise, reason: reason };\n  if (!NATIVE_PROMISE_REJECTION_EVENT && (handler = global$1['on' + name])) handler(event);\n  else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);\n};\n\nvar onUnhandled = function (state) {\n  call$7(task, global$1, function () {\n    var promise = state.facade;\n    var value = state.value;\n    var IS_UNHANDLED = isUnhandled(state);\n    var result;\n    if (IS_UNHANDLED) {\n      result = perform$2(function () {\n        if (IS_NODE) {\n          process.emit('unhandledRejection', value, promise);\n        } else dispatchEvent(UNHANDLED_REJECTION, promise, value);\n      });\n      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should\n      state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;\n      if (result.error) throw result.value;\n    }\n  });\n};\n\nvar isUnhandled = function (state) {\n  return state.rejection !== HANDLED && !state.parent;\n};\n\nvar onHandleUnhandled = function (state) {\n  call$7(task, global$1, function () {\n    var promise = state.facade;\n    if (IS_NODE) {\n      process.emit('rejectionHandled', promise);\n    } else dispatchEvent(REJECTION_HANDLED, promise, state.value);\n  });\n};\n\nvar bind$1 = function (fn, state, unwrap) {\n  return function (value) {\n    fn(state, value, unwrap);\n  };\n};\n\nvar internalReject = function (state, value, unwrap) {\n  if (state.done) return;\n  state.done = true;\n  if (unwrap) state = unwrap;\n  state.value = value;\n  state.state = REJECTED;\n  notify(state, true);\n};\n\nvar internalResolve = function (state, value, unwrap) {\n  if (state.done) return;\n  state.done = true;\n  if (unwrap) state = unwrap;\n  try {\n    if (state.facade === value) throw TypeError$1(\"Promise can't be resolved itself\");\n    var then = isThenable(value);\n    if (then) {\n      microtask(function () {\n        var wrapper = { done: false };\n        try {\n          call$7(then, value,\n            bind$1(internalResolve, wrapper, state),\n            bind$1(internalReject, wrapper, state)\n          );\n        } catch (error) {\n          internalReject(wrapper, error, state);\n        }\n      });\n    } else {\n      state.value = value;\n      state.state = FULFILLED;\n      notify(state, false);\n    }\n  } catch (error) {\n    internalReject({ done: false }, error, state);\n  }\n};\n\n// constructor polyfill\nif (FORCED_PROMISE_CONSTRUCTOR$4) {\n  // 25.4.3.1 Promise(executor)\n  PromiseConstructor = function Promise(executor) {\n    anInstance(this, PromisePrototype);\n    aCallable$3(executor);\n    call$7(Internal, this);\n    var state = getInternalPromiseState(this);\n    try {\n      executor(bind$1(internalResolve, state), bind$1(internalReject, state));\n    } catch (error) {\n      internalReject(state, error);\n    }\n  };\n\n  PromisePrototype = PromiseConstructor.prototype;\n\n  // eslint-disable-next-line no-unused-vars -- required for `.length`\n  Internal = function Promise(executor) {\n    setInternalState(this, {\n      type: PROMISE,\n      done: false,\n      notified: false,\n      parent: false,\n      reactions: new Queue(),\n      rejection: false,\n      state: PENDING,\n      value: undefined\n    });\n  };\n\n  // `Promise.prototype.then` method\n  // https://tc39.es/ecma262/#sec-promise.prototype.then\n  Internal.prototype = defineBuiltIn$2(PromisePrototype, 'then', function then(onFulfilled, onRejected) {\n    var state = getInternalPromiseState(this);\n    var reaction = newPromiseCapability$1(speciesConstructor(this, PromiseConstructor));\n    state.parent = true;\n    reaction.ok = isCallable$1(onFulfilled) ? onFulfilled : true;\n    reaction.fail = isCallable$1(onRejected) && onRejected;\n    reaction.domain = IS_NODE ? process.domain : undefined;\n    if (state.state == PENDING) state.reactions.add(reaction);\n    else microtask(function () {\n      callReaction(reaction, state);\n    });\n    return reaction.promise;\n  });\n\n  OwnPromiseCapability = function () {\n    var promise = new Internal();\n    var state = getInternalPromiseState(promise);\n    this.promise = promise;\n    this.resolve = bind$1(internalResolve, state);\n    this.reject = bind$1(internalReject, state);\n  };\n\n  newPromiseCapabilityModule$3.f = newPromiseCapability$1 = function (C) {\n    return C === PromiseConstructor || C === PromiseWrapper\n      ? new OwnPromiseCapability(C)\n      : newGenericPromiseCapability(C);\n  };\n\n  if (isCallable$1(NativePromiseConstructor$2) && NativePromisePrototype$1 !== Object.prototype) {\n    nativeThen = NativePromisePrototype$1.then;\n\n    if (!NATIVE_PROMISE_SUBCLASSING) {\n      // make `Promise#then` return a polyfilled `Promise` for native promise-based APIs\n      defineBuiltIn$2(NativePromisePrototype$1, 'then', function then(onFulfilled, onRejected) {\n        var that = this;\n        return new PromiseConstructor(function (resolve, reject) {\n          call$7(nativeThen, that, resolve, reject);\n        }).then(onFulfilled, onRejected);\n      // https://github.com/zloirock/core-js/issues/640\n      }, { unsafe: true });\n    }\n\n    // make `.constructor === Promise` work for native promise-based APIs\n    try {\n      delete NativePromisePrototype$1.constructor;\n    } catch (error) { /* empty */ }\n\n    // make `instanceof Promise` work for native promise-based APIs\n    if (setPrototypeOf) {\n      setPrototypeOf(NativePromisePrototype$1, PromisePrototype);\n    }\n  }\n}\n\n$$5({ global: true, constructor: true, wrap: true, forced: FORCED_PROMISE_CONSTRUCTOR$4 }, {\n  Promise: PromiseConstructor\n});\n\nsetToStringTag(PromiseConstructor, PROMISE, false);\nsetSpecies(PROMISE);\n\nvar wellKnownSymbol$2 = wellKnownSymbol$g;\nvar Iterators$1 = iterators;\n\nvar ITERATOR$2 = wellKnownSymbol$2('iterator');\nvar ArrayPrototype = Array.prototype;\n\n// check on default Array iterator\nvar isArrayIteratorMethod$1 = function (it) {\n  return it !== undefined && (Iterators$1.Array === it || ArrayPrototype[ITERATOR$2] === it);\n};\n\nvar classof = classof$5;\nvar getMethod$1 = getMethod$3;\nvar Iterators = iterators;\nvar wellKnownSymbol$1 = wellKnownSymbol$g;\n\nvar ITERATOR$1 = wellKnownSymbol$1('iterator');\n\nvar getIteratorMethod$2 = function (it) {\n  if (it != undefined) return getMethod$1(it, ITERATOR$1)\n    || getMethod$1(it, '@@iterator')\n    || Iterators[classof(it)];\n};\n\nvar call$6 = functionCall;\nvar aCallable$2 = aCallable$9;\nvar anObject$5 = anObject$c;\nvar tryToString$1 = tryToString$5;\nvar getIteratorMethod$1 = getIteratorMethod$2;\n\nvar $TypeError$1 = TypeError;\n\nvar getIterator$1 = function (argument, usingIterator) {\n  var iteratorMethod = arguments.length < 2 ? getIteratorMethod$1(argument) : usingIterator;\n  if (aCallable$2(iteratorMethod)) return anObject$5(call$6(iteratorMethod, argument));\n  throw $TypeError$1(tryToString$1(argument) + ' is not iterable');\n};\n\nvar call$5 = functionCall;\nvar anObject$4 = anObject$c;\nvar getMethod = getMethod$3;\n\nvar iteratorClose$1 = function (iterator, kind, value) {\n  var innerResult, innerError;\n  anObject$4(iterator);\n  try {\n    innerResult = getMethod(iterator, 'return');\n    if (!innerResult) {\n      if (kind === 'throw') throw value;\n      return value;\n    }\n    innerResult = call$5(innerResult, iterator);\n  } catch (error) {\n    innerError = true;\n    innerResult = error;\n  }\n  if (kind === 'throw') throw value;\n  if (innerError) throw innerResult;\n  anObject$4(innerResult);\n  return value;\n};\n\nvar bind = functionBindContext;\nvar call$4 = functionCall;\nvar anObject$3 = anObject$c;\nvar tryToString = tryToString$5;\nvar isArrayIteratorMethod = isArrayIteratorMethod$1;\nvar lengthOfArrayLike = lengthOfArrayLike$5;\nvar isPrototypeOf$1 = objectIsPrototypeOf;\nvar getIterator = getIterator$1;\nvar getIteratorMethod = getIteratorMethod$2;\nvar iteratorClose = iteratorClose$1;\n\nvar $TypeError = TypeError;\n\nvar Result = function (stopped, result) {\n  this.stopped = stopped;\n  this.result = result;\n};\n\nvar ResultPrototype = Result.prototype;\n\nvar iterate$2 = function (iterable, unboundFunction, options) {\n  var that = options && options.that;\n  var AS_ENTRIES = !!(options && options.AS_ENTRIES);\n  var IS_ITERATOR = !!(options && options.IS_ITERATOR);\n  var INTERRUPTED = !!(options && options.INTERRUPTED);\n  var fn = bind(unboundFunction, that);\n  var iterator, iterFn, index, length, result, next, step;\n\n  var stop = function (condition) {\n    if (iterator) iteratorClose(iterator, 'normal', condition);\n    return new Result(true, condition);\n  };\n\n  var callFn = function (value) {\n    if (AS_ENTRIES) {\n      anObject$3(value);\n      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);\n    } return INTERRUPTED ? fn(value, stop) : fn(value);\n  };\n\n  if (IS_ITERATOR) {\n    iterator = iterable;\n  } else {\n    iterFn = getIteratorMethod(iterable);\n    if (!iterFn) throw $TypeError(tryToString(iterable) + ' is not iterable');\n    // optimisation for array iterators\n    if (isArrayIteratorMethod(iterFn)) {\n      for (index = 0, length = lengthOfArrayLike(iterable); length > index; index++) {\n        result = callFn(iterable[index]);\n        if (result && isPrototypeOf$1(ResultPrototype, result)) return result;\n      } return new Result(false);\n    }\n    iterator = getIterator(iterable, iterFn);\n  }\n\n  next = iterator.next;\n  while (!(step = call$4(next, iterator)).done) {\n    try {\n      result = callFn(step.value);\n    } catch (error) {\n      iteratorClose(iterator, 'throw', error);\n    }\n    if (typeof result == 'object' && result && isPrototypeOf$1(ResultPrototype, result)) return result;\n  } return new Result(false);\n};\n\nvar wellKnownSymbol = wellKnownSymbol$g;\n\nvar ITERATOR = wellKnownSymbol('iterator');\nvar SAFE_CLOSING = false;\n\ntry {\n  var called = 0;\n  var iteratorWithReturn = {\n    next: function () {\n      return { done: !!called++ };\n    },\n    'return': function () {\n      SAFE_CLOSING = true;\n    }\n  };\n  iteratorWithReturn[ITERATOR] = function () {\n    return this;\n  };\n  // eslint-disable-next-line es-x/no-array-from, no-throw-literal -- required for testing\n  Array.from(iteratorWithReturn, function () { throw 2; });\n} catch (error) { /* empty */ }\n\nvar checkCorrectnessOfIteration$1 = function (exec, SKIP_CLOSING) {\n  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;\n  var ITERATION_SUPPORT = false;\n  try {\n    var object = {};\n    object[ITERATOR] = function () {\n      return {\n        next: function () {\n          return { done: ITERATION_SUPPORT = true };\n        }\n      };\n    };\n    exec(object);\n  } catch (error) { /* empty */ }\n  return ITERATION_SUPPORT;\n};\n\nvar NativePromiseConstructor$1 = promiseNativeConstructor;\nvar checkCorrectnessOfIteration = checkCorrectnessOfIteration$1;\nvar FORCED_PROMISE_CONSTRUCTOR$3 = promiseConstructorDetection.CONSTRUCTOR;\n\nvar promiseStaticsIncorrectIteration = FORCED_PROMISE_CONSTRUCTOR$3 || !checkCorrectnessOfIteration(function (iterable) {\n  NativePromiseConstructor$1.all(iterable).then(undefined, function () { /* empty */ });\n});\n\nvar $$4 = _export;\nvar call$3 = functionCall;\nvar aCallable$1 = aCallable$9;\nvar newPromiseCapabilityModule$2 = newPromiseCapability$2;\nvar perform$1 = perform$3;\nvar iterate$1 = iterate$2;\nvar PROMISE_STATICS_INCORRECT_ITERATION$1 = promiseStaticsIncorrectIteration;\n\n// `Promise.all` method\n// https://tc39.es/ecma262/#sec-promise.all\n$$4({ target: 'Promise', stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION$1 }, {\n  all: function all(iterable) {\n    var C = this;\n    var capability = newPromiseCapabilityModule$2.f(C);\n    var resolve = capability.resolve;\n    var reject = capability.reject;\n    var result = perform$1(function () {\n      var $promiseResolve = aCallable$1(C.resolve);\n      var values = [];\n      var counter = 0;\n      var remaining = 1;\n      iterate$1(iterable, function (promise) {\n        var index = counter++;\n        var alreadyCalled = false;\n        remaining++;\n        call$3($promiseResolve, C, promise).then(function (value) {\n          if (alreadyCalled) return;\n          alreadyCalled = true;\n          values[index] = value;\n          --remaining || resolve(values);\n        }, reject);\n      });\n      --remaining || resolve(values);\n    });\n    if (result.error) reject(result.value);\n    return capability.promise;\n  }\n});\n\nvar $$3 = _export;\nvar FORCED_PROMISE_CONSTRUCTOR$2 = promiseConstructorDetection.CONSTRUCTOR;\nvar NativePromiseConstructor = promiseNativeConstructor;\nvar getBuiltIn$1 = getBuiltIn$8;\nvar isCallable = isCallable$l;\nvar defineBuiltIn$1 = defineBuiltIn$6;\n\nvar NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;\n\n// `Promise.prototype.catch` method\n// https://tc39.es/ecma262/#sec-promise.prototype.catch\n$$3({ target: 'Promise', proto: true, forced: FORCED_PROMISE_CONSTRUCTOR$2, real: true }, {\n  'catch': function (onRejected) {\n    return this.then(undefined, onRejected);\n  }\n});\n\n// makes sure that native promise-based APIs `Promise#catch` properly works with patched `Promise#then`\nif (isCallable(NativePromiseConstructor)) {\n  var method = getBuiltIn$1('Promise').prototype['catch'];\n  if (NativePromisePrototype['catch'] !== method) {\n    defineBuiltIn$1(NativePromisePrototype, 'catch', method, { unsafe: true });\n  }\n}\n\nvar $$2 = _export;\nvar call$2 = functionCall;\nvar aCallable = aCallable$9;\nvar newPromiseCapabilityModule$1 = newPromiseCapability$2;\nvar perform = perform$3;\nvar iterate = iterate$2;\nvar PROMISE_STATICS_INCORRECT_ITERATION = promiseStaticsIncorrectIteration;\n\n// `Promise.race` method\n// https://tc39.es/ecma262/#sec-promise.race\n$$2({ target: 'Promise', stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {\n  race: function race(iterable) {\n    var C = this;\n    var capability = newPromiseCapabilityModule$1.f(C);\n    var reject = capability.reject;\n    var result = perform(function () {\n      var $promiseResolve = aCallable(C.resolve);\n      iterate(iterable, function (promise) {\n        call$2($promiseResolve, C, promise).then(capability.resolve, reject);\n      });\n    });\n    if (result.error) reject(result.value);\n    return capability.promise;\n  }\n});\n\nvar $$1 = _export;\nvar call$1 = functionCall;\nvar newPromiseCapabilityModule = newPromiseCapability$2;\nvar FORCED_PROMISE_CONSTRUCTOR$1 = promiseConstructorDetection.CONSTRUCTOR;\n\n// `Promise.reject` method\n// https://tc39.es/ecma262/#sec-promise.reject\n$$1({ target: 'Promise', stat: true, forced: FORCED_PROMISE_CONSTRUCTOR$1 }, {\n  reject: function reject(r) {\n    var capability = newPromiseCapabilityModule.f(this);\n    call$1(capability.reject, undefined, r);\n    return capability.promise;\n  }\n});\n\nvar anObject$2 = anObject$c;\nvar isObject = isObject$8;\nvar newPromiseCapability = newPromiseCapability$2;\n\nvar promiseResolve$1 = function (C, x) {\n  anObject$2(C);\n  if (isObject(x) && x.constructor === C) return x;\n  var promiseCapability = newPromiseCapability.f(C);\n  var resolve = promiseCapability.resolve;\n  resolve(x);\n  return promiseCapability.promise;\n};\n\nvar $ = _export;\nvar getBuiltIn = getBuiltIn$8;\nvar FORCED_PROMISE_CONSTRUCTOR = promiseConstructorDetection.CONSTRUCTOR;\nvar promiseResolve = promiseResolve$1;\n\ngetBuiltIn('Promise');\n\n// `Promise.resolve` method\n// https://tc39.es/ecma262/#sec-promise.resolve\n$({ target: 'Promise', stat: true, forced: FORCED_PROMISE_CONSTRUCTOR }, {\n  resolve: function resolve(x) {\n    return promiseResolve(this, x);\n  }\n});\n\nconst HardwareWalletAccountsForm = ({\n  accounts,\n  onSelectedChanged,\n  onSubmit,\n  onChangeRoute\n}) => {\n  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n    className: \"choose-ledger-account-form-wrapper\"\n  }, {\n    children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"p\", {\n      children: [\"We found \", accounts.length, \" accounts on your device. Select the account(s) you wish to connect.\"]\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n      className: \"button-wrapper\"\n    }, {\n      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", Object.assign({\n        onClick: () => {\n          onChangeRoute(\"SpecifyHDPath\");\n        }\n      }, {\n        children: \"HD.../0\"\n      }))\n    })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"form\", Object.assign({\n      className: \"form\",\n      onSubmit: e => {\n        onSubmit(accounts, e);\n      }\n    }, {\n      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", {\n        children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n          className: \"nws-form-control\"\n        }, {\n          children: accounts.map((account, index) => (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n            className: \"account\"\n          }, {\n            children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"input\", {\n              onChange: e => {\n                onSelectedChanged(index, e.target.checked);\n              },\n              checked: account.selected,\n              type: \"checkbox\",\n              id: account.accountId,\n              name: account.accountId,\n              value: account.accountId\n            }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"label\", Object.assign({\n              htmlFor: account.accountId\n            }, {\n              children: [\" \", account.accountId]\n            })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"br\", {})]\n          }), index))\n        })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n          className: \"action-buttons\"\n        }, {\n          children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", Object.assign({\n            className: \"middleButton\",\n            type: \"submit\",\n            disabled: !accounts.some(x => x.selected)\n          }, {\n            children: \"Connect\"\n          }))\n        }))]\n      })\n    }))]\n  }));\n};\n\nvar img = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAZCAYAAADE6YVjAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAR3SURBVHgBpVZ9aJVVGH+e55z33bi7zY9hMz+yMAeNoEIq6A9ZRKQWEsQNFIIpsf5Y9E+GsD9iBEEDMUkDa6ShRKKZYIWiRkaKaUGUGCKOTGMF84PNO99773vOefq9720yK5ZzD/dwPt/nd37P17lEk5Qnuz9roUkKT7T5bNe+QjTNLCHv24h1Xgh+OmtwQYPH2jUXwlnW9NRooqePfLS6MmmQ59cdeEGJlkJZA5MGVecoAwghBYZTVY9ftuaDSy8x8w9fbFl95JZAXuw9dmelkvRAyXxS7wMFryG4bIyWZiqzPgMhaFfGfn3NY3AZG9sPf/Dy8HidZvxkZc/h1pqnPlKey6yspMqUd9jVAEYY6RCGDQTwjGDwGTgAlbwRijV1C9vanz577tT+6r+YrOz5rlXFrQ/qZ+FbDxCfXS5oOgxln4v473f3rbgwdn7FK5/MCaH2eAg6X8g3K2iBMTiBkNJVKbod+ze9mgPZsY/UaicYzCE1HgpZc558olCTjTvWLxv9p1n3bV45iO7T5zq3TU9j9xTOLwQ5D9t48aEYrtGj2P/2BpNS78nZJoRdlDsYd8vphz273lqyhW5Rnlnz3hOe6SEwghvxPUMTVfYe2rpuUOqOkZeIxdSbsSJ8eTIAmXy5tftrMPkzi0C4B2ZDNHp+INvLQURkhYiJ6gDGko376DbEJ8k3mcnYBSeSM2ptL/XGsurNnxfnDIQNwCKADO1845Ef6Tbk0M51g4joMgncDyBmkrtsNEMQovcDxGYsGL2yDNAUxPv0VySs4yxhfeYbabJg0Awg+ILylEB6nKMpSOp0WCR1+QSuD4ELljNDEfyRrdXPCU1BTEgD7pyOzVmC2iBm0KgYAMCEeXovoClIjdKiVdQ3FYbzmatxWRqMPcNsDHyfNWskWk5TkJhNEwVyxA6hLL5clLJsW7voFxa6LiR5CCOeWzo3XFxKtyEdy3tnp7VahAoDp6PEVGvJye09l3P7K9k9WQijXBv4B6WG+0pvD0ybFEBHZ6OPh+/OGaBsIvNRAGp/ZHv1jJeon+omszBkFsr3FhsLB7rev3JLQKVSyfjmaW2BJSavDlqR7c5VrR+4AbLttbkXMehH7gjA8gZiD/tq+Or/ABZ3dUW/J62LcPUGcrW8pKSVFAg6cHz3O0l25qZHa/XGwWPg9aAwwzdZAaDX+7tbNsMYf5+bpaUS0dDQEF8rtsUxCbI5e5KRzGhBMiqNxllKju7d8NOYXjseRBytQngcVDL3wD9H+7vf3YS7mnnzqrZpwSxrwkh04cpM5NTMyJdHbIgaESyxJ6tZ5cDbw3qd0tqVCp25Se/4yYdr5/zm/ehjwvpxZHgN0Wlub0/Yt7awdykqRYFHy6NUQVrBd4o6p6ngrVL2Bo8ksuJqoXzq9Ln9m6rj9U74b6Wjo8OeP082aY5NUxRsYzwDkeFsU+MdUU3U4PG0QtbahqhadDMuHTy4fvS/9EwIUpdeuW/ZiShOipFxURRbNdWETFMRZrCFlEZGkuPHdycTafgLExNiI6YfUpcAAAAASUVORK5CYII=\";\n\nconst WalletConnecting = ({\n  wallet,\n  onCloseModal\n}) => {\n  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react__WEBPACK_IMPORTED_MODULE_2__.Fragment, {\n    children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ModalHeader, {\n      title: \"\",\n      onCloseModal: onCloseModal\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n      className: \"connecting-wrapper\"\n    }, {\n      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n        className: \"content\"\n      }, {\n        children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n          className: \"icon\"\n        }, {\n          children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"img\", {\n            src: wallet === null || wallet === void 0 ? void 0 : wallet.metadata.iconUrl,\n            alt: wallet === null || wallet === void 0 ? void 0 : wallet.metadata.name\n          })\n        })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h3\", Object.assign({\n          className: \"connecting-name\"\n        }, {\n          children: wallet === null || wallet === void 0 ? void 0 : wallet.metadata.name\n        })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n          className: \"connecting-details\"\n        }, {\n          children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n            className: \"spinner\"\n          }, {\n            children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"img\", {\n              src: img,\n              alt: \"loading-icon\"\n            })\n          })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"span\", {\n            children: [(0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.wallet.connectingTo\"), \" \", wallet === null || wallet === void 0 ? void 0 : wallet.metadata.name, \"...\"]\n          })]\n        })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n          className: \"connecting-message\"\n        }, {\n          children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n            children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(`modal.wallet.connectingMessage.${wallet === null || wallet === void 0 ? void 0 : wallet.type}`)\n          })\n        }))]\n      }))\n    }))]\n  });\n};\n\nconst LedgerDeviceIcon = () => {\n  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"svg\", Object.assign({\n    width: \"317\",\n    height: \"157\",\n    viewBox: \"0 0 317 157\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, {\n    children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M249.99 16.0994C270.063 -0.864155 289.788 1.58873 301.497 10.7365C307.402 15.3499 311.278 21.6575 312.267 28.1258C313.247 34.5412 311.413 41.2233 305.692 46.8044C297.366 54.9273 286.343 55.3362 273.015 51.5109C261.654 48.25 249.058 42.0377 235.726 35.4627L235.726 35.4626L235.717 35.458C233.367 34.2992 230.995 33.129 228.602 31.9618C212.742 24.2253 196.067 16.6575 179.842 13.8595C163.538 11.0479 147.552 13.0313 133.266 24.522C128.032 28.732 123.478 35.2086 121.716 44.8205C119.961 54.3947 120.992 66.9771 126.703 83.4311C135.432 108.583 132.899 126.677 123.575 138.063C114.217 149.491 97.5614 154.733 76.7887 153.121C55.0043 151.43 29.0621 142.206 3.29867 125.227L0.887817 127.942C27.2472 145.405 53.9251 154.952 76.5105 156.705C97.9028 158.365 115.96 153.035 126.356 140.341C136.785 127.606 139.045 108.029 130.099 82.2524C124.521 66.1801 123.642 54.2493 125.252 45.4687C126.854 36.7258 130.94 31.006 135.519 27.3232C148.794 16.6458 163.649 14.715 179.231 17.4021C194.891 20.1027 211.146 27.4463 227.026 35.1928C229.381 36.3415 231.729 37.5001 234.066 38.6531L234.073 38.6568C247.382 45.223 260.324 51.608 272.024 54.9662C285.819 58.9258 298.493 58.8501 308.202 49.3776C314.764 42.9759 316.974 35.1288 315.82 27.5826C314.675 20.0893 310.237 13.0029 303.71 7.90363C290.555 -2.37382 268.938 -4.62038 247.67 13.3537L249.99 16.0994Z\",\n      fill: \"url(#paint0_linear_3_672)\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      d: \"M260.264 17.8767L177.605 89.4649L157.679 73.9664L239.23 3.85423L260.264 17.8767Z\",\n      fill: \"#6A7075\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      d: \"M205.939 54.4577L199.764 50.2636L233.316 20.9053L239.907 25.8395L205.939 54.4577Z\",\n      fill: \"#494E52\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      d: \"M260.264 17.8757L177.605 89.4639L182.033 98.3202L264.323 26.363L260.264 17.8757Z\",\n      fill: \"#494E52\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      d: \"M177.236 89.4646L181.295 98.3209L165.059 85.7745L170.963 85.0365L177.236 89.4646Z\",\n      fill: \"black\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      d: \"M93.4708 99.6384L91.9948 110.13L174.653 92.894L164.69 85.7749L93.4708 99.6384Z\",\n      fill: \"#DCDADA\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      d: \"M93.1157 104.323L94.314 100.129L165.613 86.3483L169.208 89.344L93.1157 104.323Z\",\n      fill: \"#C1C1C1\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      d: \"M94.2086 99.7963L86.0903 101.272L92.3635 110.129L94.2086 99.7963Z\",\n      fill: \"#B3AAAA\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M86.0903 100.907L89.0027 74.1304L178.455 55.2416C184.695 53.9962 195.766 54.7675 197.177 63.7058C198.284 70.717 195.506 73.9943 191.628 77.3592C188.495 80.0671 180.152 82.4646 178.343 82.8944C178.293 82.9064 178.241 82.9188 178.186 82.9319C177.38 83.1245 176.007 83.4525 170.644 84.5088C169.085 84.8158 167.382 85.1501 165.557 85.5078L164.933 85.63C146.312 89.2764 115.528 95.2297 93.9844 99.3849C91.1808 99.9257 88.5337 100.436 86.0903 100.907ZM185.076 75.554C190.748 73.3535 193.99 68.0745 192.318 63.7631C190.645 59.4517 184.691 57.7405 179.019 59.941C173.347 62.1416 170.105 67.4206 171.778 71.732C173.45 76.0434 179.404 77.7546 185.076 75.554Z\",\n      fill: \"#F4F1E8\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      d: \"M199.764 50.3994L196.768 48.3043L232.194 18.0454L233.316 21.6403L199.764 50.3994Z\",\n      fill: \"black\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      d: \"M239.968 25.9943L232.588 20.4592V17.5071L241.813 24.5183L239.968 25.9943Z\",\n      fill: \"black\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"ellipse\", {\n      cx: \"182.084\",\n      cy: \"68.0811\",\n      rx: \"10.242\",\n      ry: \"7.46772\",\n      transform: \"rotate(-23.7949 182.084 68.0811)\",\n      fill: \"#494E52\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"ellipse\", {\n      cx: \"182.084\",\n      cy: \"68.0816\",\n      rx: \"6.68462\",\n      ry: \"4.87394\",\n      transform: \"rotate(-23.7949 182.084 68.0816)\",\n      fill: \"#494E52\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M238.725 2.93094L260.368 17.2564L264.865 26.4556L181.615 99.0341L175.16 94.311L92.0028 110.947L85.3267 101.399L88.3269 73.8157L178.118 54.8553L238.725 2.93094ZM178.599 56.2622L89.6786 75.0388L86.9321 100.29C89.0979 99.8725 91.4124 99.4263 93.8446 98.9572C115.388 94.8019 146.171 88.8488 164.791 85.2026L165.415 85.0804C167.24 84.7228 168.943 84.3885 170.501 84.0816C175.853 83.0275 177.219 82.701 178.015 82.5107C178.07 82.4976 178.122 82.4852 178.173 82.4732C179.048 82.2652 181.558 81.5669 184.235 80.5851C186.742 79.6655 189.286 78.5354 190.802 77.3758L191.151 77.0922L191.644 76.6595C193.341 75.147 194.723 73.6739 195.61 71.871C196.571 69.916 196.982 67.5029 196.448 64.1178C195.8 60.0131 192.959 57.7574 189.408 56.6566C185.833 55.5483 181.637 55.6566 178.603 56.2615C178.601 56.2617 178.6 56.262 178.599 56.2622ZM192.631 77.7565L259.555 18.9531L263.042 26.0869L181.808 96.9078L178.132 89.5713L191.724 78.529C191.859 78.4249 191.988 78.32 192.11 78.2144L192.111 78.2136C192.286 78.0617 192.46 77.9094 192.631 77.7565ZM185.491 81.6908C185.24 81.7868 184.99 81.8802 184.743 81.9709C182.013 82.9723 179.447 83.6875 178.514 83.9093C178.463 83.9213 178.411 83.9338 178.356 83.9468C177.635 84.1192 176.472 84.3971 172.491 85.1919L177.172 88.4492L185.491 81.6908ZM176.631 89.8707L170.479 85.5903C169.306 85.8213 168.054 86.0673 166.731 86.3265L175.769 92.9276L179.548 95.6924L176.631 89.8707ZM164.758 86.7132C146.252 90.3362 116.027 96.1817 94.6324 100.308L93.2258 109.197L173.543 93.1293L164.758 86.7132ZM91.888 108.207L93.0909 100.606C91.0848 100.993 89.1642 101.363 87.3471 101.713L91.888 108.207ZM258.581 17.8436L197.306 71.6841C198.142 69.5779 198.41 67.0795 197.906 63.8876C197.143 59.0539 193.743 56.4549 189.845 55.2467C186.921 54.3402 183.662 54.1916 180.861 54.449L238.84 4.77668L258.581 17.8436ZM232.505 16.82L243.089 24.5643L205.915 56.5106L196.042 48.0665L232.505 16.82ZM232.118 19.096L198.312 48.0654L199.744 49.29L232.584 20.9424L232.118 19.096ZM233.456 22.1396L200.878 50.2604L205.913 54.5664L239.041 26.0969L233.456 22.1396ZM240.195 25.1054L240.717 24.6571L233.759 19.5663L234.06 20.7586L240.195 25.1054Z\",\n      fill: \"black\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M190.194 69.9744C191.32 68.1409 191.576 66.2271 190.942 64.5937C190.308 62.9603 188.829 61.7198 186.761 61.1254C184.691 60.5307 182.116 60.6196 179.553 61.6139C176.991 62.6081 175.029 64.2794 173.902 66.1141C172.776 67.9477 172.52 69.8614 173.154 71.4948C173.788 73.1282 175.267 74.3687 177.335 74.9631C179.405 75.5578 181.98 75.4689 184.543 74.4746C187.105 73.4804 189.067 71.8091 190.194 69.9744ZM185.077 75.8508C190.749 73.6502 193.991 68.3712 192.318 64.0598C190.645 59.7484 184.691 58.0372 179.019 60.2378C173.347 62.4383 170.105 67.7173 171.778 72.0287C173.451 76.3401 179.405 78.0513 185.077 75.8508Z\",\n      fill: \"black\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M187.391 69.169C188.127 67.9713 188.266 66.7721 187.881 65.7812C187.497 64.7903 186.586 63.9984 185.235 63.6102C183.883 63.2216 182.173 63.2741 180.456 63.9404C178.738 64.6068 177.441 65.7208 176.705 66.9196C175.969 68.1172 175.83 69.3165 176.215 70.3074C176.599 71.2983 177.511 72.0901 178.861 72.4783C180.214 72.8669 181.923 72.8144 183.64 72.1481C185.358 71.4818 186.655 70.3678 187.391 69.169ZM184.174 73.5242C188.156 71.9795 190.432 68.2738 189.257 65.2473C188.083 62.2208 183.904 61.0196 179.922 62.5643C175.94 64.1091 173.665 67.8148 174.839 70.8412C176.013 73.8677 180.193 75.0689 184.174 73.5242Z\",\n      fill: \"black\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      d: \"M240.499 41.2441C239.744 40.3649 239.844 39.04 240.724 38.285L249.781 30.5067C250.66 29.7516 251.985 29.8523 252.74 30.7315V30.7315C253.495 31.6108 253.395 32.9356 252.516 33.6907L243.458 41.469C242.579 42.224 241.254 42.1234 240.499 41.2441V41.2441Z\",\n      fill: \"black\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M250.743 31.6265L241.685 39.4048C241.424 39.6287 241.395 40.0217 241.619 40.2825C241.842 40.5433 242.235 40.5731 242.496 40.3492L251.554 32.5709C251.815 32.3469 251.845 31.954 251.621 31.6932C251.397 31.4324 251.004 31.4025 250.743 31.6265ZM240.724 38.285C239.844 39.04 239.744 40.3649 240.499 41.2441C241.254 42.1234 242.579 42.224 243.458 41.469L252.516 33.6907C253.395 32.9356 253.495 31.6108 252.74 30.7315C251.985 29.8523 250.66 29.7516 249.781 30.5067L240.724 38.285Z\",\n      fill: \"black\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      d: \"M205.779 71.4647C205.005 70.5642 205.108 69.2073 206.009 68.4339L214.989 60.7218C215.89 59.9485 217.247 60.0516 218.02 60.9521V60.9521C218.793 61.8526 218.69 63.2095 217.79 63.9829L208.809 71.695C207.909 72.4683 206.552 72.3652 205.779 71.4647V71.4647Z\",\n      fill: \"black\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M215.951 61.8416L206.97 69.5537C206.688 69.796 206.656 70.221 206.898 70.5031C207.141 70.7851 207.566 70.8174 207.848 70.5752L216.828 62.863C217.11 62.6208 217.143 62.1958 216.9 61.9137C216.658 61.6317 216.233 61.5994 215.951 61.8416ZM206.009 68.4339C205.108 69.2073 205.005 70.5642 205.779 71.4647C206.552 72.3652 207.909 72.4683 208.809 71.695L217.79 63.9829C218.69 63.2095 218.793 61.8526 218.02 60.9521C217.247 60.0516 215.89 59.9485 214.989 60.7218L206.009 68.4339Z\",\n      fill: \"black\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", {\n      cx: \"141.356\",\n      cy: \"19.525\",\n      r: \"10.1855\",\n      fill: \"#FE89B4\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"ellipse\", {\n      cx: \"139.062\",\n      cy: \"14.7094\",\n      rx: \"2.42519\",\n      ry: \"1.94015\",\n      transform: \"rotate(-34.544 139.062 14.7094)\",\n      fill: \"#FDF7FF\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", {\n      cx: \"252.489\",\n      cy: \"79.7577\",\n      r: \"7.78893\",\n      fill: \"#EC5236\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"ellipse\", {\n      cx: \"250.434\",\n      cy: \"76.3701\",\n      rx: \"2.61272\",\n      ry: \"2.09018\",\n      transform: \"rotate(-34.544 250.434 76.3701)\",\n      fill: \"#EDB69D\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M100.436 79.9254C100.461 79.6567 100.732 79.3897 101.042 79.329L106.657 78.2299C107.587 78.0478 108.281 78.5536 108.207 79.3596L107.759 84.2243C107.734 84.493 107.463 84.76 107.153 84.8207L100.416 86.1396C100.106 86.2003 99.8742 86.0317 99.899 85.7631L100.436 79.9254Z\",\n      fill: \"#B3AAAA\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M95.8553 81.7775C95.9294 80.9715 96.7437 80.1704 97.6739 79.9883L98.7968 79.7685C99.1069 79.7078 99.3382 79.8764 99.3135 80.1451L99.1344 82.091C99.1096 82.3597 98.8382 82.6267 98.5282 82.6874L96.2824 83.127C95.9723 83.1877 95.741 83.0191 95.7657 82.7505L95.8553 81.7775Z\",\n      fill: \"#B3AAAA\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M95.5865 84.6965C95.6112 84.4278 95.8826 84.1608 96.1927 84.1001L98.4385 83.6605C98.7486 83.5998 98.9799 83.7684 98.9552 84.037L98.7761 85.9829C98.7513 86.2516 98.4799 86.5186 98.1699 86.5793L95.9241 87.019C95.614 87.0797 95.3827 86.9111 95.4074 86.6424L95.5865 84.6965Z\",\n      fill: \"#B3AAAA\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M95.2282 88.5884C95.2529 88.3197 95.5244 88.0527 95.8344 87.992L98.0802 87.5524C98.3903 87.4917 98.6216 87.6603 98.5969 87.929L98.4178 89.8749C98.3931 90.1435 98.1216 90.4105 97.8116 90.4712L96.6887 90.6911C95.7584 90.8732 95.0645 90.3674 95.1387 89.5614L95.2282 88.5884Z\",\n      fill: \"#B3AAAA\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M99.7197 87.709C99.7444 87.4403 100.016 87.1733 100.326 87.1126L102.572 86.673C102.882 86.6123 103.113 86.7809 103.088 87.0496L102.909 88.9955C102.885 89.2641 102.613 89.5312 102.303 89.5919L100.057 90.0315C99.7472 90.0922 99.5159 89.9236 99.5406 89.6549L99.7197 87.709Z\",\n      fill: \"#B3AAAA\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M104.211 86.8298C104.236 86.5611 104.507 86.2941 104.817 86.2334L107.063 85.7938C107.373 85.7331 107.605 85.9017 107.58 86.1704L107.49 87.1433C107.416 87.9493 106.602 88.7504 105.672 88.9325L104.549 89.1523C104.239 89.213 104.007 89.0444 104.032 88.7757L104.211 86.8298Z\",\n      fill: \"#B3AAAA\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"defs\", {\n      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"linearGradient\", Object.assign({\n        id: \"paint0_linear_3_672\",\n        x1: \"-44.5195\",\n        y1: \"122.42\",\n        x2: \"263.357\",\n        y2: \"-8.65023\",\n        gradientUnits: \"userSpaceOnUse\"\n      }, {\n        children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"stop\", {\n          offset: \"0.110697\",\n          stopColor: \"#232323\"\n        }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"stop\", {\n          offset: \"1\",\n          stopColor: \"#3D3D3D\"\n        })]\n      }))\n    })]\n  }));\n};\n\nconst UpArrowIcon = () => {\n  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({\n    width: \"10\",\n    height: \"7\",\n    viewBox: \"0 0 10 7\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, {\n    children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      d: \"M9 5.4762L5 1.4762L1 5.4762\",\n      stroke: \"#4F7CD1\",\n      strokeWidth: \"1.5\",\n      strokeLinecap: \"round\",\n      strokeLinejoin: \"round\"\n    })\n  }));\n};\n\nconst DownArrowIcon = () => {\n  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({\n    width: \"10\",\n    height: \"7\",\n    viewBox: \"0 0 10 7\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, {\n    children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      d: \"M1 1.52382L5 5.52382L9 1.52382\",\n      stroke: \"#4F7CD1\",\n      strokeWidth: \"1.5\",\n      strokeLinecap: \"round\",\n      strokeLinejoin: \"round\"\n    })\n  }));\n};\n\nconst DEFAULT_DERIVATION_PATH = \"44'/397'/0'/0'/1'\";\nconst DerivationPath = ({\n  selector,\n  options,\n  onBack,\n  onConnected,\n  params,\n  onError,\n  onCloseModal\n}) => {\n  const [route, setRoute] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(\"EnterDerivationPath\");\n  const [derivationPath, setDerivationPath] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(DEFAULT_DERIVATION_PATH);\n  const [customDerivationPath, setCustomDerivationPath] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(1);\n  const [accounts, setAccounts] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)([]);\n  const [selectedAccounts, setSelectedAccounts] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)([]);\n  const [hardwareWallet, setHardwareWallet] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)();\n  const [customAccountId, setCustomAccountId] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(\"\");\n  const [connecting, setConnecting] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(false);\n  const initalHeaderTitle = (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.ledger.connectWithLedger\");\n  const [headerTitle, setHeaderTitle] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(initalHeaderTitle);\n  const getAccountIds = publicKey => __awaiter(void 0, void 0, void 0, function* () {\n    const response = yield fetch(`${selector.options.network.indexerUrl}/publicKey/ed25519:${publicKey}/accounts`);\n    if (!response.ok) {\n      throw new Error(\"Failed to get account id from public key\");\n    }\n    const accountIds = yield response.json();\n    if (!Array.isArray(accountIds) || !accountIds.length) {\n      return [];\n    }\n    return accountIds;\n  });\n  const resolveAccounts = wallet => __awaiter(void 0, void 0, void 0, function* () {\n    const publicKey = yield wallet.getPublicKey(derivationPath);\n    try {\n      const accountIds = yield getAccountIds(publicKey);\n      return accountIds.map((accountId, index) => {\n        return {\n          derivationPath,\n          publicKey,\n          accountId,\n          selected: index === 0\n        };\n      });\n    } catch (e) {\n      return null;\n    }\n  });\n  const handleValidateAccount = () => __awaiter(void 0, void 0, void 0, function* () {\n    const wallet = yield selector.wallet(params.walletId);\n    if (wallet.type !== \"hardware\") {\n      return;\n    }\n    setConnecting(true);\n    setHardwareWallet(wallet);\n    try {\n      const resolvedAccounts = yield resolveAccounts(wallet);\n      if (!resolvedAccounts) {\n        setRoute(\"AddCustomAccountId\");\n        return;\n      }\n      const noAccounts = resolvedAccounts.length === 0;\n      const multipleAccounts = resolvedAccounts.length > 1;\n      if (noAccounts) {\n        setHeaderTitle((0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.ledger.noAccountsFound\"));\n        setRoute(\"NoAccountsFound\");\n        return;\n      }\n      setAccounts(resolvedAccounts);\n      if (!multipleAccounts) {\n        setSelectedAccounts(resolvedAccounts);\n        setRoute(\"OverviewAccounts\");\n      } else {\n        setHeaderTitle((0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.ledger.selectYourAccounts\"));\n        setRoute(\"ChooseAccount\");\n      }\n    } catch (err) {\n      setConnecting(false);\n      const message = err && typeof err === \"object\" && \"message\" in err ? err.message : \"Something went wrong\";\n      onError(message, wallet);\n    } finally {\n      setConnecting(false);\n    }\n  });\n  const handleAddCustomAccountId = () => __awaiter(void 0, void 0, void 0, function* () {\n    try {\n      setConnecting(true);\n      const publicKey = yield hardwareWallet.getPublicKey(derivationPath);\n      const accountList = [{\n        derivationPath: derivationPath,\n        publicKey,\n        accountId: customAccountId,\n        selected: true\n      }];\n      setAccounts(accountList);\n      setSelectedAccounts(accountList);\n      setHeaderTitle((0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.ledger.connecting1Account\"));\n      setRoute(\"OverviewAccounts\");\n    } catch (err) {\n      setConnecting(false);\n      const message = err && typeof err === \"object\" && \"message\" in err ? err.message : \"Something went wrong\";\n      onError(message, hardwareWallet);\n    } finally {\n      setConnecting(false);\n    }\n  });\n  const handleSignIn = () => {\n    const mapAccounts = selectedAccounts.map(account => {\n      return {\n        derivationPath: account.derivationPath,\n        publicKey: account.publicKey,\n        accountId: account.accountId\n      };\n    });\n    return hardwareWallet.signIn({\n      contractId: options.contractId,\n      methodNames: options.methodNames,\n      accounts: mapAccounts\n    }).then(() => onConnected()).catch(err => {\n      onError(`Error: ${err.message}`, hardwareWallet);\n    });\n  };\n  const handleOnBackButtonClick = () => {\n    if (route === \"SpecifyHDPath\" || route === \"NoAccountsFound\" || route === \"ChooseAccount\") {\n      setHeaderTitle((0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.ledger.connectWithLedger\"));\n      setRoute(\"EnterDerivationPath\");\n    }\n    if (route === \"OverviewAccounts\") {\n      setHeaderTitle((0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.ledger.selectYourAccounts\"));\n      setRoute(\"ChooseAccount\");\n    }\n  };\n  if (connecting) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n      className: \"derivation-path-wrapper\"\n    }, {\n      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(WalletConnecting, {\n        wallet: hardwareWallet,\n        onBack: () => {\n          setConnecting(false);\n        },\n        onCloseModal: onCloseModal\n      })\n    }));\n  }\n  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react__WEBPACK_IMPORTED_MODULE_2__.Fragment, {\n    children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n      className: \"nws-modal-header-wrapper\"\n    }, {\n      children: [(route === \"SpecifyHDPath\" || route === \"NoAccountsFound\" || route === \"ChooseAccount\" || route === \"OverviewAccounts\") && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BackArrow, {\n        onClick: handleOnBackButtonClick\n      }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ModalHeader, {\n        title: headerTitle,\n        onCloseModal: onCloseModal\n      })]\n    })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n      className: \"derivation-path-wrapper\"\n    }, {\n      children: [route === \"EnterDerivationPath\" && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n        className: \"enter-derivation-path\"\n      }, {\n        children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n          className: \"ledger-image\"\n        }, {\n          children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(LedgerDeviceIcon, {})\n        })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n          className: \"ledger-description\"\n        }, {\n          children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", {\n            children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.ledger.makeSureYourLedger\")\n          }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", Object.assign({\n            className: \"specify-path\",\n            onClick: () => {\n              setHeaderTitle((0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.ledger.specifyHDPath\"));\n              setRoute(\"SpecifyHDPath\");\n            }\n          }, {\n            children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.ledger.specifyHDPath\")\n          }))]\n        })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n          className: \"action-buttons\"\n        }, {\n          children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", Object.assign({\n            className: \"middleButton\",\n            onClick: handleValidateAccount\n          }, {\n            children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.ledger.continue\")\n          }))\n        }))]\n      })), route === \"SpecifyHDPath\" && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n        className: \"specify-path-wrapper\"\n      }, {\n        children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n          className: \"change-path-wrapper\"\n        }, {\n          children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n            className: \"display-path\"\n          }, {\n            children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n              children: derivationPath.slice(0, -2)\n            })\n          })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n            className: \"change-path\"\n          }, {\n            children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n              className: \"path-value\"\n            }, {\n              children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n                children: customDerivationPath\n              })\n            })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n              className: \"buttons-wrapper\"\n            }, {\n              children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", Object.assign({\n                onClick: () => {\n                  const newValue = customDerivationPath + 1;\n                  const path = derivationPath.slice(0, -2);\n                  setDerivationPath(`${path}${newValue}'`);\n                  setCustomDerivationPath(newValue);\n                }\n              }, {\n                children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(UpArrowIcon, {})\n              })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", Object.assign({\n                onClick: () => {\n                  const newValue = customDerivationPath - 1;\n                  if (newValue < 0) {\n                    return;\n                  }\n                  const path = derivationPath.slice(0, -2);\n                  setDerivationPath(`${path}${newValue}'`);\n                  setCustomDerivationPath(newValue);\n                }\n              }, {\n                children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DownArrowIcon, {})\n              }))]\n            }))]\n          }))]\n        })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", Object.assign({\n          className: \"path-description\"\n        }, {\n          children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.ledger.enterYourPreferredHDPath\")\n        })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", Object.assign({\n          className: \"what-link\"\n        }, {\n          children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", Object.assign({\n            href: \"https://www.ledger.com/academy/crypto/what-are-hierarchical-deterministic-hd-wallets\",\n            target: \"_blank\"\n          }, {\n            children: \"What's this?\"\n          }))\n        })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n          className: \"action-buttons\"\n        }, {\n          children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", Object.assign({\n            className: \"middleButton\",\n            onClick: handleValidateAccount\n          }, {\n            children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.ledger.scan\")\n          }))\n        }))]\n      })), route === \"NoAccountsFound\" && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n        className: \"no-accounts-found-wrapper\"\n      }, {\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"p\", {\n          children: [(0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.ledger.cantFindAnyAccount\"), \" \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", Object.assign({\n            href: `https://${selector.options.network.networkId === \"testnet\" ? \"testnet\" : \"app\"}.mynearwallet.com/create`,\n            target: \"_blank\"\n          }, {\n            children: \"MyNearWallet\"\n          })), \" \", (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.ledger.orConnectAnAnotherLedger\")]\n        })\n      })), route === \"ChooseAccount\" && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(HardwareWalletAccountsForm, {\n        accounts: accounts,\n        onSelectedChanged: (index, selected) => {\n          setAccounts(prevAccounts => {\n            const updateAccounts = prevAccounts.map((account, idx) => {\n              const selectedValue = index === idx ? selected : account.selected;\n              return Object.assign(Object.assign({}, account), {\n                selected: selectedValue\n              });\n            });\n            return [...updateAccounts];\n          });\n        },\n        onSubmit: (acc, e) => {\n          e.preventDefault();\n          const selectedAcc = acc.filter(account => account.selected);\n          setSelectedAccounts(selectedAcc);\n          const numberOfAccounts = selectedAcc.length;\n          setHeaderTitle(`${(0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.ledger.connecting\")} ${numberOfAccounts} ${(0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.ledger.ofAccounts\")}`);\n          setRoute(\"OverviewAccounts\");\n        },\n        onChangeRoute: newRoute => {\n          if (newRoute === \"SpecifyHDPath\") {\n            setHeaderTitle((0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.ledger.specifyHDPath\"));\n          }\n          setRoute(newRoute);\n        }\n      }), route === \"AddCustomAccountId\" && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n        className: \"enter-custom-account\"\n      }, {\n        children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", {\n          children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.ledger.failedToAutomatically\")\n        }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n          className: \"input-wrapper\"\n        }, {\n          children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"input\", {\n            type: \"text\",\n            placeholder: \"Account ID\",\n            value: customAccountId,\n            onChange: e => {\n              setCustomAccountId(e.target.value);\n            }\n          })\n        })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n          className: \"action-buttons\"\n        }, {\n          children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", Object.assign({\n            className: \"middleButton\",\n            onClick: handleAddCustomAccountId\n          }, {\n            children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"ledger.Continue\")\n          }))\n        }))]\n      })), route === \"OverviewAccounts\" && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n        className: \"overview-wrapper\"\n      }, {\n        children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", {\n          children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.ledger.overviewTheListOfAuthorized\")\n        }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n          className: \"accounts\"\n        }, {\n          children: selectedAccounts.map((account, index) => (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n            children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n              className: \"account\"\n            }, {\n              children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n                children: account.accountId\n              })\n            }))\n          }, account.accountId))\n        })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n          className: \"action-buttons\"\n        }, {\n          children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", Object.assign({\n            className: \"middleButton\",\n            onClick: handleSignIn,\n            disabled: accounts.length === 0\n          }, {\n            children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.ledger.finish\")\n          }))\n        }))]\n      }))]\n    }))]\n  });\n};\n\nconst WalletNotInstalled = ({\n  module,\n  onBack,\n  onCloseModal\n}) => {\n  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react__WEBPACK_IMPORTED_MODULE_2__.Fragment, {\n    children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n      className: \"nws-modal-header-wrapper\"\n    }, {\n      children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BackArrow, {\n        onClick: onBack\n      }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ModalHeader, {\n        title: \"\",\n        onCloseModal: onCloseModal\n      })]\n    })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n      className: \"wallet-not-installed-wrapper\"\n    }, {\n      children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n        className: \"wallet-data\"\n      }, {\n        children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n          className: `wallet-icon-box ${module.id}`\n        }, {\n          children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"img\", {\n            src: module.metadata.iconUrl,\n            alt: module.metadata.name\n          })\n        })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", {\n          children: module.metadata.name\n        })]\n      })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"p\", {\n        children: [(0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.install.youllNeedToInstall\"), \" \", module.metadata.name, \" \", (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.install.toContinueAfterInstalling\"), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"span\", Object.assign({\n          className: \"refresh-link\",\n          onClick: () => window.location.reload()\n        }, {\n          children: [\" \", (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.install.refreshThePage\")]\n        }))]\n      }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n        className: \"action-buttons\"\n      }, {\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"button\", Object.assign({\n          className: \"middleButton\",\n          onClick: () => {\n            if (module.type !== \"injected\") {\n              return;\n            }\n            window.open(module.metadata.downloadUrl, \"_blank\");\n          }\n        }, {\n          children: [(0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.install.open\"), \" \", module.metadata.name]\n        }))\n      }))]\n    }))]\n  });\n};\n\nconst QRIcon = () => (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"svg\", Object.assign({\n  width: \"18\",\n  height: \"16\",\n  viewBox: \"0 0 18 16\",\n  fill: \"none\",\n  xmlns: \"http://www.w3.org/2000/svg\"\n}, {\n  children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n    d: \"M7.22224 1.33334H1.44446V6.66668H7.22224V1.33334Z\",\n    stroke: \"currentColor\",\n    strokeLinecap: \"round\",\n    strokeLinejoin: \"round\"\n  }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n    d: \"M15.8889 1.33334H10.1111V6.66668H15.8889V1.33334Z\",\n    stroke: \"currentColor\",\n    strokeLinecap: \"round\",\n    strokeLinejoin: \"round\"\n  }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n    d: \"M7.22224 9.33334H1.44446V14.6667H7.22224V9.33334Z\",\n    stroke: \"currentColor\",\n    strokeLinecap: \"round\",\n    strokeLinejoin: \"round\"\n  }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n    d: \"M10.1111 13.1429V14.6667H15.8889M10.1111 9.33334V10.8572H12.5873V9.33334H15.8889V12.381\",\n    stroke: \"#4C5155\",\n    strokeLinecap: \"round\",\n    strokeLinejoin: \"round\"\n  }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"rect\", {\n    x: \"3.61108\",\n    y: \"3.33334\",\n    width: \"1.44444\",\n    height: \"1.33333\",\n    fill: \"#4C5155\"\n  }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"rect\", {\n    x: \"3.61108\",\n    y: \"11.3333\",\n    width: \"1.44444\",\n    height: \"1.33333\",\n    fill: \"#4C5155\"\n  }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"rect\", {\n    x: \"12.2778\",\n    y: \"3.33334\",\n    width: \"1.44445\",\n    height: \"1.33333\",\n    fill: \"#4C5155\"\n  })]\n}));\n\nconst LinkIcon = () => (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"svg\", Object.assign({\n  width: \"18\",\n  height: \"16\",\n  viewBox: \"0 0 18 16\",\n  fill: \"none\",\n  xmlns: \"http://www.w3.org/2000/svg\"\n}, {\n  children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n    d: \"M13 8.66667V12.6667C13 13.0203 12.8478 13.3594 12.577 13.6095C12.3061 13.8595 11.9387 14 11.5556 14H3.61113C3.22804 14 2.86064 13.8595 2.58975 13.6095C2.31887 13.3594 2.16669 13.0203 2.16669 12.6667V5.33333C2.16669 4.97971 2.31887 4.64057 2.58975 4.39052C2.86064 4.14048 3.22804 4 3.61113 4H7.94447\",\n    stroke: \"currentColor\",\n    strokeLinecap: \"round\",\n    strokeLinejoin: \"round\"\n  }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n    d: \"M10.8333 2H15.1666V6\",\n    stroke: \"currentColor\",\n    strokeLinecap: \"round\",\n    strokeLinejoin: \"round\"\n  }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n    d: \"M7.22223 9.33333L15.1667 2\",\n    stroke: \"currentColor\",\n    strokeLinecap: \"round\",\n    strokeLinejoin: \"round\"\n  })]\n}));\n\nconst KeyIcon = () => (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({\n  width: \"40\",\n  height: \"40\",\n  viewBox: \"0 0 40 40\",\n  fill: \"none\",\n  xmlns: \"http://www.w3.org/2000/svg\"\n}, {\n  children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n    d: \"M33.5 1.83325L30.1666 5.16658M17.4818 17.8514C19.1406 19.5103 20.1666 21.8019 20.1666 24.3333C20.1666 29.3959 16.0626 33.4999 11 33.4999C5.93735 33.4999 1.8333 29.3959 1.8333 24.3333C1.8333 19.2706 5.93735 15.1666 11 15.1666C13.5313 15.1666 15.8229 16.1926 17.4818 17.8514ZM17.4818 17.8514L24.3333 10.9999M24.3333 10.9999L29.3333 15.9999L35.1666 10.1666L30.1666 5.16658M24.3333 10.9999L30.1666 5.16658\",\n    stroke: \"currentColor\",\n    strokeWidth: \"3\",\n    strokeLinecap: \"round\",\n    strokeLinejoin: \"round\"\n  })\n}));\n\nconst FolderIcon = () => (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"svg\", Object.assign({\n  width: \"40\",\n  height: \"41\",\n  viewBox: \"0 0 40 41\",\n  fill: \"none\",\n  xmlns: \"http://www.w3.org/2000/svg\"\n}, {\n  children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", {\n    cx: \"28.3333\",\n    cy: \"23.8333\",\n    r: \"1.66667\",\n    fill: \"currentColor\"\n  }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n    d: \"M35 12.1667H7C5.89543 12.1667 5 11.2712 5 10.1667V7.5C5 6.39543 5.89543 5.5 7 5.5H31.6667\",\n    stroke: \"currentColor\",\n    strokeWidth: \"3\",\n    strokeLinecap: \"round\",\n    strokeLinejoin: \"round\"\n  }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n    d: \"M35 12.1667V35.5H7C5.89543 35.5 5 34.6046 5 33.5V8.83334\",\n    stroke: \"currentColor\",\n    strokeWidth: \"3\",\n    strokeLinecap: \"round\",\n    strokeLinejoin: \"round\"\n  })]\n}));\n\nconst WalletHome = ({\n  selector,\n  onCloseModal\n}) => {\n  const [modules, setModules] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)([]);\n  const [route, setRoute] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(\"WalletInfo\");\n  (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(() => {\n    const subscription = selector.store.observable.subscribe(state => {\n      const filterByType = item => {\n        return item.type !== \"bridge\" && item.type !== \"hardware\" && item.type !== \"instant-link\";\n      };\n      const filteredModules = state.modules.filter(filterByType);\n      setModules(filteredModules);\n    });\n    return () => subscription.unsubscribe();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  const getWalletUrl = module => {\n    let url = \"\";\n    if (module.type === \"injected\") {\n      url = module.metadata.downloadUrl;\n    }\n    if (module.type === \"browser\") {\n      url = module.metadata.walletUrl;\n    }\n    return url;\n  };\n  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n    className: \"wallet-home-wrapper\"\n  }, {\n    children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n      className: \"nws-modal-header-wrapper\"\n    }, {\n      children: [route === \"GetWallets\" && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BackArrow, {\n        onClick: () => {\n          setRoute(\"WalletInfo\");\n        }\n      }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ModalHeader, {\n        title: route === \"GetWallets\" ? (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.wallet.getAWallet\") : (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.wallet.whatIsAWallet\"),\n        onCloseModal: onCloseModal\n      })]\n    })), route === \"GetWallets\" && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n      className: \"get-wallet-wrapper\"\n    }, {\n      children: modules.map(module => {\n        const {\n          iconUrl,\n          name\n        } = module.metadata;\n        const qrIcon = [\"nearfi\", \"here-wallet\"].includes(module.id);\n        const hereWalletType = module.id === \"here-wallet\" ? \"mobile\" : \"\";\n        const walletUrl = getWalletUrl(module);\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n          tabIndex: 0,\n          className: `single-wallet-get ${module.id}`,\n          onClick: () => {\n            if (walletUrl) {\n              window.open(walletUrl, \"_blank\");\n            }\n          }\n        }, {\n          children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n            className: \"small-icon\"\n          }, {\n            children: [qrIcon && walletUrl && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(QRIcon, {}), !qrIcon && walletUrl && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(LinkIcon, {})]\n          })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n            className: \"icon\"\n          }, {\n            children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"img\", {\n              src: iconUrl,\n              alt: name\n            })\n          })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n            className: \"content\"\n          }, {\n            children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n              className: \"title\"\n            }, {\n              children: name\n            })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n              className: \"type\"\n            }, {\n              children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(`modal.walletTypes.${hereWalletType || module.type}`)\n            }))]\n          }))]\n        }), module.id);\n      })\n    })), route === \"WalletInfo\" && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n      children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n        className: \"wallet-info-wrapper what-wallet-hide\"\n      }, {\n        children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n          className: \"wallet-what\"\n        }, {\n          children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n            className: \"icon-side\"\n          }, {\n            children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(KeyIcon, {})\n          })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n            className: \"content-side\"\n          }, {\n            children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h3\", {\n              children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.wallet.secureAndManage\")\n            }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", {\n              children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.wallet.safelyStore\")\n            })]\n          }))]\n        })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n          className: \"wallet-what\"\n        }, {\n          children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n            className: \"icon-side\"\n          }, {\n            children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(FolderIcon, {})\n          })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n            className: \"content-side\"\n          }, {\n            children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h3\", {\n              children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.wallet.logInToAny\")\n            }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", {\n              children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.wallet.noNeedToCreate\")\n            })]\n          }))]\n        })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n          className: \"button-spacing\"\n        }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", Object.assign({\n          className: \"middleButton\",\n          onClick: () => {\n            setRoute(\"GetWallets\");\n          }\n        }, {\n          children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.wallet.getAWallet\")\n        }))]\n      })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n        className: \"what-wallet-mobile\"\n      }, {\n        children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", {\n          children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.wallet.useAWallet\")\n        }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", Object.assign({\n          className: \"middleButton\",\n          onClick: () => {\n            setRoute(\"GetWallets\");\n          }\n        }, {\n          children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.wallet.getAWallet\")\n        }))]\n      })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n        className: \"lang-selector-wrapper\"\n      }, {\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"select\", Object.assign({\n          className: \"lang-selector\",\n          name: \"lang\"\n        }, {\n          children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"option\", Object.assign({\n            value: \"en\"\n          }, {\n            children: \"English\"\n          })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"option\", Object.assign({\n            value: \"es\"\n          }, {\n            children: \"Spanish\"\n          }))]\n        }))\n      }))]\n    })]\n  }));\n};\n\nconst WalletConnected = ({\n  module,\n  onCloseModal\n}) => {\n  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react__WEBPACK_IMPORTED_MODULE_2__.Fragment, {\n    children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n      className: \"nws-modal-header\"\n    }, {\n      children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h3\", Object.assign({\n        className: \"middleTitle\"\n      }, {\n        children: ``\n      })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(CloseButton, {\n        onClick: onCloseModal\n      })]\n    })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n      className: \"connecting-wrapper\"\n    }, {\n      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n        className: \"content\"\n      }, {\n        children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n          className: \"icon\"\n        }, {\n          children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n            className: \"green-dot\"\n          }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"img\", {\n            src: module === null || module === void 0 ? void 0 : module.metadata.iconUrl,\n            alt: module === null || module === void 0 ? void 0 : module.metadata.name\n          })]\n        })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h3\", Object.assign({\n          className: \"connecting-name\"\n        }, {\n          children: module === null || module === void 0 ? void 0 : module.metadata.name\n        })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n          className: \"wallet-connected-success\"\n        }, {\n          children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ConnectionSuccessIcon, {}), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n            children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.wallet.connectionSuccessful\")\n          })]\n        }))]\n      }))\n    }))]\n  });\n};\n\nvar anObject$1 = anObject$c;\n\n// `RegExp.prototype.flags` getter implementation\n// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags\nvar regexpFlags = function () {\n  var that = anObject$1(this);\n  var result = '';\n  if (that.hasIndices) result += 'd';\n  if (that.global) result += 'g';\n  if (that.ignoreCase) result += 'i';\n  if (that.multiline) result += 'm';\n  if (that.dotAll) result += 's';\n  if (that.unicode) result += 'u';\n  if (that.unicodeSets) result += 'v';\n  if (that.sticky) result += 'y';\n  return result;\n};\n\nvar call = functionCall;\nvar hasOwn = hasOwnProperty_1;\nvar isPrototypeOf = objectIsPrototypeOf;\nvar regExpFlags = regexpFlags;\n\nvar RegExpPrototype$1 = RegExp.prototype;\n\nvar regexpGetFlags = function (R) {\n  var flags = R.flags;\n  return flags === undefined && !('flags' in RegExpPrototype$1) && !hasOwn(R, 'flags') && isPrototypeOf(RegExpPrototype$1, R)\n    ? call(regExpFlags, R) : flags;\n};\n\nvar PROPER_FUNCTION_NAME = functionName.PROPER;\nvar defineBuiltIn = defineBuiltIn$6;\nvar anObject = anObject$c;\nvar $toString = toString$3;\nvar fails = fails$h;\nvar getRegExpFlags = regexpGetFlags;\n\nvar TO_STRING = 'toString';\nvar RegExpPrototype = RegExp.prototype;\nvar n$ToString = RegExpPrototype[TO_STRING];\n\nvar NOT_GENERIC = fails(function () { return n$ToString.call({ source: 'a', flags: 'b' }) != '/a/b'; });\n// FF44- RegExp#toString has a wrong name\nvar INCORRECT_NAME = PROPER_FUNCTION_NAME && n$ToString.name != TO_STRING;\n\n// `RegExp.prototype.toString` method\n// https://tc39.es/ecma262/#sec-regexp.prototype.tostring\nif (NOT_GENERIC || INCORRECT_NAME) {\n  defineBuiltIn(RegExp.prototype, TO_STRING, function toString() {\n    var R = anObject(this);\n    var pattern = $toString(R.source);\n    var flags = $toString(getRegExpFlags(R));\n    return '/' + pattern + '/' + flags;\n  }, { unsafe: true });\n}\n\nconst CopyIcon = () => (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"svg\", Object.assign({\n  width: 24,\n  height: 24,\n  viewBox: \"0 0 24 24\",\n  fill: \"none\",\n  xmlns: \"http://www.w3.org/2000/svg\"\n}, {\n  children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n    d: \"M6.5 15.25a1.75 1.75 0 0 1-1.75-1.75V6.75a2 2 0 0 1 2-2h6.75c.966 0 1.75.784 1.75 1.75\",\n    stroke: \"#4F7CD1\",\n    strokeWidth: 1.5,\n    strokeLinecap: \"round\",\n    strokeLinejoin: \"round\"\n  }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n    d: \"M8.75 10.75a2 2 0 0 1 2-2h6.5a2 2 0 0 1 2 2v6.5a2 2 0 0 1-2 2h-6.5a2 2 0 0 1-2-2v-6.5Z\",\n    stroke: \"#4F7CD1\",\n    strokeWidth: 1.5,\n    strokeLinecap: \"round\",\n    strokeLinejoin: \"round\"\n  })]\n}));\n\nfunction formatQRCodeImage(data) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return yield qrcode__WEBPACK_IMPORTED_MODULE_4__.toString(data, {\n      margin: 0,\n      type: \"svg\"\n    });\n  });\n}\nconst ScanQRCode = ({\n  wallet,\n  uri,\n  onCloseModal,\n  handleOpenDefaultModal\n}) => {\n  const [notification, setNotification] = react__WEBPACK_IMPORTED_MODULE_2__.useState(\"\");\n  const [svg, setSvg] = react__WEBPACK_IMPORTED_MODULE_2__.useState(\"\");\n  const copyToClipboard = () => {\n    if (!uri) {\n      return;\n    }\n    const success = copy_to_clipboard__WEBPACK_IMPORTED_MODULE_5__(uri);\n    if (success) {\n      setNotification((0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.qr.copiedToClipboard\"));\n      setTimeout(() => setNotification(\"\"), 1200);\n    } else {\n      setNotification((0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.qr.failedToCopy\"));\n      setTimeout(() => setNotification(\"\"), 1200);\n    }\n  };\n  react__WEBPACK_IMPORTED_MODULE_2__.useEffect(() => {\n    (() => __awaiter(void 0, void 0, void 0, function* () {\n      if (uri) {\n        setSvg(yield formatQRCodeImage(uri));\n      }\n    }))();\n  }, [uri]);\n  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"section\", Object.assign({\n    className: \"scan-qr-code\"\n  }, {\n    children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ModalHeader, {\n      title: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.qr.scanWithYourMobile\"),\n      onCloseModal: onCloseModal\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"section\", Object.assign({\n      className: \"qr-code\"\n    }, {\n      children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        dangerouslySetInnerHTML: {\n          __html: svg\n        }\n      }), notification ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n        className: \"notification\"\n      }, {\n        children: notification\n      })) : (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n        className: \"copy-btn\",\n        onClick: copyToClipboard\n      }, {\n        children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(CopyIcon, {}), (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.qr.copyToClipboard\")]\n      }))]\n    })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"footer\", Object.assign({\n      className: \"footer\"\n    }, {\n      children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"p\", {\n        children: [(0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.qr.preferTheOfficial\"), \" \", wallet.metadata.name, \"?\"]\n      }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", Object.assign({\n        className: \"btn\",\n        onClick: handleOpenDefaultModal\n      }, {\n        children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.qr.open\")\n      }))]\n    }))]\n  }));\n};\n\nconst getThemeClass = theme => {\n  switch (theme) {\n    case \"dark\":\n      return \"dark-theme\";\n    case \"light\":\n      return \"light-theme\";\n    default:\n      return \"\";\n  }\n};\nconst Modal = ({\n  selector,\n  options,\n  visible,\n  hide,\n  emitter\n}) => {\n  var _a, _b, _c;\n  const [route, setRoute] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)({\n    name: \"WalletHome\"\n  });\n  const [alertMessage, setAlertMessage] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(null);\n  const [selectedWallet, setSelectedWallet] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)();\n  const [bridgeWalletUri, setBridgeWalletUri] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)();\n  (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(() => {\n    setRoute({\n      name: \"WalletHome\"\n    });\n    (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.allowOnlyLanguage)(selector.options.languageCode);\n    const {\n      selectedWalletId,\n      modules\n    } = selector.store.getState();\n    if (selectedWalletId) {\n      const module = modules.find(m => m.id === selectedWalletId);\n      setSelectedWallet(module);\n      setRoute({\n        name: \"WalletConnected\",\n        params: {\n          module\n        }\n      });\n    }\n    setBridgeWalletUri(\"\");\n    // eslint-disable-next-line\n  }, [visible]);\n  (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(() => {\n    const subscription = selector.on(\"networkChanged\", ({\n      networkId\n    }) => {\n      // Switched back to the correct network.\n      if (networkId === selector.options.network.networkId) {\n        return handleDismissClick({});\n      }\n      setRoute({\n        name: \"WalletNetworkChanged\"\n      });\n    });\n    return () => subscription.remove();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  const handleDismissClick = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)(({\n    hideReason\n  }) => {\n    setAlertMessage(null);\n    setRoute({\n      name: \"WalletHome\"\n    });\n    if (hideReason === \"user-triggered\") {\n      emitter.emit(\"onHide\", {\n        hideReason\n      });\n    }\n    if (hideReason === \"wallet-navigation\") {\n      emitter.emit(\"onHide\", {\n        hideReason\n      });\n    }\n    hide();\n  }, [hide, emitter]);\n  (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(() => {\n    const close = e => {\n      if (e.key === \"Escape\") {\n        handleDismissClick({\n          hideReason: \"user-triggered\"\n        });\n      }\n    };\n    window.addEventListener(\"keydown\", close);\n    return () => window.removeEventListener(\"keydown\", close);\n  }, [handleDismissClick]);\n  const handleWalletClick = (module, qrCodeModal) => __awaiter(void 0, void 0, void 0, function* () {\n    setSelectedWallet(module);\n    const {\n      selectedWalletId\n    } = selector.store.getState();\n    if (selectedWalletId === module.id) {\n      setRoute({\n        name: \"WalletConnected\",\n        params: {\n          module\n        }\n      });\n      return;\n    }\n    try {\n      const {\n        deprecated,\n        available\n      } = module.metadata;\n      if (module.type === \"injected\" && !available) {\n        setRoute({\n          name: \"WalletNotInstalled\",\n          params: {\n            module: module\n          }\n        });\n        return;\n      }\n      const wallet = yield module.wallet();\n      if (deprecated) {\n        setAlertMessage(`${module.metadata.name} is deprecated. Please select another wallet.`);\n        setRoute({\n          name: \"AlertMessage\",\n          params: {\n            module: module\n          }\n        });\n        return;\n      }\n      if (wallet.type === \"hardware\") {\n        setRoute({\n          name: \"DerivationPath\",\n          params: {\n            walletId: wallet.id || \"ledger\"\n          }\n        });\n        return;\n      }\n      setRoute({\n        name: \"WalletConnecting\",\n        params: {\n          wallet: wallet\n        }\n      });\n      if (wallet.type === \"bridge\") {\n        const subscription = selector.on(\"uriChanged\", ({\n          uri\n        }) => {\n          setBridgeWalletUri(uri);\n          setRoute({\n            name: \"ScanQRCode\",\n            params: {\n              uri,\n              wallet\n            }\n          });\n        });\n        yield wallet.signIn({\n          contractId: options.contractId,\n          methodNames: options.methodNames,\n          qrCodeModal\n        });\n        subscription.remove();\n        handleDismissClick({\n          hideReason: \"wallet-navigation\"\n        });\n        return;\n      }\n      if (wallet.type === \"browser\") {\n        yield wallet.signIn({\n          contractId: options.contractId,\n          methodNames: options.methodNames,\n          successUrl: wallet.metadata.successUrl,\n          failureUrl: wallet.metadata.failureUrl\n        });\n        handleDismissClick({\n          hideReason: \"wallet-navigation\"\n        });\n        return;\n      }\n      yield wallet.signIn({\n        contractId: options.contractId,\n        methodNames: options.methodNames\n      });\n      handleDismissClick({\n        hideReason: \"wallet-navigation\"\n      });\n    } catch (err) {\n      const {\n        name\n      } = module.metadata;\n      const message = err && typeof err === \"object\" && \"message\" in err ? err.message : \"Something went wrong\";\n      setAlertMessage(`Failed to sign in with ${name}: ${message}`);\n      setRoute({\n        name: \"AlertMessage\",\n        params: {\n          module: module\n        }\n      });\n    }\n  });\n  if (!visible) {\n    return null;\n  }\n  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n    className: `nws-modal-wrapper ${getThemeClass(options === null || options === void 0 ? void 0 : options.theme)} ${visible ? \"open\" : \"\"}`\n  }, {\n    children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n      className: \"nws-modal-overlay\",\n      onClick: () => {\n        handleDismissClick({\n          hideReason: \"user-triggered\"\n        });\n      }\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n      className: \"nws-modal\"\n    }, {\n      children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n        className: \"modal-left\"\n      }, {\n        children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n          className: \"modal-left-title\"\n        }, {\n          children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h2\", {\n            children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.wallet.connectYourWallet\")\n          })\n        })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(WalletOptions, {\n          handleWalletClick: module => {\n            handleWalletClick(module, false);\n          },\n          selector: selector\n        })]\n      })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n        className: \"modal-right\"\n      }, {\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n          className: \"nws-modal-body\"\n        }, {\n          children: [route.name === \"AlertMessage\" && alertMessage && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(AlertMessage, {\n            message: alertMessage,\n            module: (_a = route.params) === null || _a === void 0 ? void 0 : _a.module,\n            onBack: retry => {\n              if (retry) {\n                handleWalletClick(selectedWallet, false);\n              }\n              setAlertMessage(null);\n              setRoute({\n                name: \"WalletHome\"\n              });\n            },\n            onCloseModal: () => handleDismissClick({\n              hideReason: \"user-triggered\"\n            })\n          }), route.name === \"DerivationPath\" && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DerivationPath, {\n            selector: selector,\n            options: options,\n            onConnected: () => {\n              handleDismissClick({\n                hideReason: \"wallet-navigation\"\n              });\n            },\n            params: route.params,\n            onBack: () => setRoute({\n              name: \"WalletHome\"\n            }),\n            onError: (message, wallet) => {\n              const {\n                modules\n              } = selector.store.getState();\n              const findModule = modules.find(module => module.id === wallet.id);\n              setAlertMessage(message);\n              setRoute({\n                name: \"AlertMessage\",\n                params: {\n                  module: findModule\n                }\n              });\n            },\n            onCloseModal: () => handleDismissClick({\n              hideReason: \"user-triggered\"\n            })\n          }), route.name === \"WalletNetworkChanged\" && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(WalletNetworkChanged, {\n            selector: selector,\n            onBack: () => setRoute({\n              name: \"WalletHome\"\n            }),\n            onCloseModal: () => handleDismissClick({\n              hideReason: \"user-triggered\"\n            })\n          }), route.name === \"WalletNotInstalled\" && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(WalletNotInstalled, {\n            module: (_b = route.params) === null || _b === void 0 ? void 0 : _b.module,\n            onBack: () => {\n              setRoute({\n                name: \"WalletHome\"\n              });\n            },\n            onCloseModal: () => handleDismissClick({\n              hideReason: \"user-triggered\"\n            })\n          }), route.name === \"WalletConnecting\" && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(WalletConnecting, {\n            wallet: (_c = route.params) === null || _c === void 0 ? void 0 : _c.wallet,\n            onBack: () => {\n              setRoute({\n                name: \"WalletHome\"\n              });\n            },\n            onCloseModal: () => handleDismissClick({\n              hideReason: \"user-triggered\"\n            })\n          }), route.name === \"WalletHome\" && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(WalletHome, {\n            selector: selector,\n            onCloseModal: () => handleDismissClick({\n              hideReason: \"user-triggered\"\n            })\n          }), route.name === \"WalletConnected\" && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(WalletConnected, {\n            module: selectedWallet,\n            onCloseModal: () => handleDismissClick({\n              hideReason: \"user-triggered\"\n            })\n          }), route.name === \"ScanQRCode\" && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ScanQRCode, {\n            handleOpenDefaultModal: () => {\n              handleWalletClick(selectedWallet, true);\n            },\n            onCloseModal: () => handleDismissClick({\n              hideReason: \"user-triggered\"\n            }),\n            uri: bridgeWalletUri,\n            wallet: selectedWallet\n          })]\n        }))\n      }))]\n    }))]\n  }));\n};\n\nconst MODAL_ELEMENT_ID = \"near-wallet-selector-modal\";\nlet modalInstance = null;\nlet root = null;\n/**\r\n * Initiates a modal instance\r\n * @param {WalletSelector} selector Selector\r\n * @param {ModalOptions} options Modal options\r\n * @returns {WalletSelectorModal} Returns a WalletSelectorModal object\r\n */\nconst setupModal = (selector, options) => {\n  if (!root) {\n    const body = document.body;\n    const container = document.createElement(\"div\");\n    container.id = MODAL_ELEMENT_ID;\n    body.appendChild(container);\n    root = (0,react_dom_client__WEBPACK_IMPORTED_MODULE_1__.createRoot)(container);\n  }\n  const emitter = new _near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.EventEmitter();\n  selector.store.getState().modules.forEach(module => __awaiter(void 0, void 0, void 0, function* () {\n    if (\"topLevelInjected\" in module.metadata) {\n      if (!module.metadata.topLevelInjected) {\n        return;\n      }\n      const wallet = yield module.wallet();\n      if (wallet.type !== \"injected\") {\n        return;\n      }\n      yield wallet.signIn({\n        contractId: options.contractId,\n        methodNames: options.methodNames\n      });\n    }\n  }));\n  const render = (visible = false) => {\n    root.render((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Modal, {\n      selector: selector,\n      options: options,\n      visible: visible,\n      hide: () => render(false),\n      emitter: emitter\n    }));\n  };\n  if (!modalInstance) {\n    modalInstance = {\n      show: () => {\n        render(true);\n      },\n      hide: () => {\n        render(false);\n      },\n      on: (eventName, callback) => {\n        return emitter.on(eventName, callback);\n      },\n      off: (eventName, callback) => {\n        emitter.off(eventName, callback);\n      }\n    };\n  }\n  return modalInstance;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5lYXItd2FsbGV0LXNlbGVjdG9yL21vZGFsLXVpL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBc0U7QUFDeEI7QUFDNEI7QUFDYztBQUM1RDtBQUNTOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsYUFBYTtBQUN6QztBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlDQUFpQztBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixjQUFjOztBQUUvQixnQkFBZ0I7O0FBRWhCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyxrREFBa0Q7QUFDeEYsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtRUFBbUU7O0FBRW5FOztBQUVBOztBQUVBO0FBQ0EseUVBQXlFO0FBQ3pFLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLE9BQU8sbUJBQW1CLGFBQWE7QUFDeEUsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGFBQWE7QUFDMUQ7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNILENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0JBQWdCO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxnQkFBZ0I7QUFDMUQ7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsZ0JBQWdCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxxQkFBcUI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYixJQUFJO0FBQ0osYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFzQixxRUFBUyxtQ0FBbUMsNERBQTREO0FBQzlILFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxTQUFTLHVEQUFJO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxlQUFlLHNEQUFHO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHLHNEQUFHO0FBQ1g7QUFDQTtBQUNBLEtBQUssR0FBRyxzREFBRztBQUNYO0FBQ0E7QUFDQSxLQUFLLEdBQUcsc0RBQUc7QUFDWDtBQUNBO0FBQ0EsS0FBSyxHQUFHLHNEQUFHO0FBQ1g7QUFDQTtBQUNBLEtBQUssR0FBRyxzREFBRztBQUNYO0FBQ0E7QUFDQSxLQUFLLEdBQUcsc0RBQUc7QUFDWDtBQUNBO0FBQ0EsS0FBSyxHQUFHLHNEQUFHO0FBQ1g7QUFDQTtBQUNBLEtBQUssR0FBRyxzREFBRztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHLHNEQUFHO0FBQ1g7QUFDQTtBQUNBLEtBQUssR0FBRyxzREFBRztBQUNYO0FBQ0E7QUFDQSxLQUFLLEdBQUcsc0RBQUc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEdBQUcsc0RBQUc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEdBQUcsc0RBQUc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssR0FBRyxzREFBRztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHLHNEQUFHO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEdBQUcsc0RBQUc7QUFDWDtBQUNBO0FBQ0EsS0FBSyxHQUFHLHNEQUFHO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEdBQUcsc0RBQUc7QUFDWDtBQUNBO0FBQ0EsS0FBSyxHQUFHLHNEQUFHO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEdBQUcsc0RBQUc7QUFDWDtBQUNBO0FBQ0E7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Q0E7QUFDQSxlQUFlO0FBQ2YsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVyxrQ0FBa0Msc0RBQUc7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVcsdUNBQXVDLHNEQUFHO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXLGtDQUFrQyxzREFBRztBQUNoRDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCLFdBQVcsY0FBYztBQUN6QixhQUFhLHFCQUFxQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNERBQVU7QUFDckI7QUFDQSxzQkFBc0Isb0VBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0EsZ0JBQWdCLHNEQUFHO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbnVyc2VibG9jLy4vbm9kZV9tb2R1bGVzL0BuZWFyLXdhbGxldC1zZWxlY3Rvci9tb2RhbC11aS9pbmRleC5qcz83ZTVlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGpzeHMsIGpzeCwgRnJhZ21lbnQgYXMgRnJhZ21lbnQkMSB9IGZyb20gJ3JlYWN0L2pzeC1ydW50aW1lJztcbmltcG9ydCB7IGNyZWF0ZVJvb3QgfSBmcm9tICdyZWFjdC1kb20vY2xpZW50JztcbmltcG9ydCBSZWFjdCwgeyBGcmFnbWVudCwgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB0cmFuc2xhdGUsIGFsbG93T25seUxhbmd1YWdlLCBFdmVudEVtaXR0ZXIgfSBmcm9tICdAbmVhci13YWxsZXQtc2VsZWN0b3IvY29yZSc7XG5pbXBvcnQgUVJDb2RlIGZyb20gJ3FyY29kZSc7XG5pbXBvcnQgY29weSBmcm9tICdjb3B5LXRvLWNsaXBib2FyZCc7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG5cclxuZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxudHlwZW9mIFN1cHByZXNzZWRFcnJvciA9PT0gXCJmdW5jdGlvblwiID8gU3VwcHJlc3NlZEVycm9yIDogZnVuY3Rpb24gKGVycm9yLCBzdXBwcmVzc2VkLCBtZXNzYWdlKSB7XHJcbiAgICB2YXIgZSA9IG5ldyBFcnJvcihtZXNzYWdlKTtcclxuICAgIHJldHVybiBlLm5hbWUgPSBcIlN1cHByZXNzZWRFcnJvclwiLCBlLmVycm9yID0gZXJyb3IsIGUuc3VwcHJlc3NlZCA9IHN1cHByZXNzZWQsIGU7XHJcbn07XG5cbnZhciBjb21tb25qc0dsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9O1xuXG52YXIgZmFpbHMkaCA9IGZ1bmN0aW9uIChleGVjKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhZXhlYygpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG52YXIgZmFpbHMkZyA9IGZhaWxzJGg7XG5cbnZhciBmdW5jdGlvbkJpbmROYXRpdmUgPSAhZmFpbHMkZyhmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLWZ1bmN0aW9uLXByb3RvdHlwZS1iaW5kIC0tIHNhZmVcbiAgdmFyIHRlc3QgPSAoZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9KS5iaW5kKCk7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnMgLS0gc2FmZVxuICByZXR1cm4gdHlwZW9mIHRlc3QgIT0gJ2Z1bmN0aW9uJyB8fCB0ZXN0Lmhhc093blByb3BlcnR5KCdwcm90b3R5cGUnKTtcbn0pO1xuXG52YXIgTkFUSVZFX0JJTkQkMyA9IGZ1bmN0aW9uQmluZE5hdGl2ZTtcblxudmFyIEZ1bmN0aW9uUHJvdG90eXBlJDIgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG52YXIgYmluZCQ1ID0gRnVuY3Rpb25Qcm90b3R5cGUkMi5iaW5kO1xudmFyIGNhbGwkZiA9IEZ1bmN0aW9uUHJvdG90eXBlJDIuY2FsbDtcbnZhciB1bmN1cnJ5VGhpcyRoID0gTkFUSVZFX0JJTkQkMyAmJiBiaW5kJDUuYmluZChjYWxsJGYsIGNhbGwkZik7XG5cbnZhciBmdW5jdGlvblVuY3VycnlUaGlzID0gTkFUSVZFX0JJTkQkMyA/IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gZm4gJiYgdW5jdXJyeVRoaXMkaChmbik7XG59IDogZnVuY3Rpb24gKGZuKSB7XG4gIHJldHVybiBmbiAmJiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNhbGwkZi5hcHBseShmbiwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG5cbnZhciB1bmN1cnJ5VGhpcyRnID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcblxudmFyIHRvU3RyaW5nJDUgPSB1bmN1cnJ5VGhpcyRnKHt9LnRvU3RyaW5nKTtcbnZhciBzdHJpbmdTbGljZSQxID0gdW5jdXJyeVRoaXMkZygnJy5zbGljZSk7XG5cbnZhciBjbGFzc29mUmF3JDEgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHN0cmluZ1NsaWNlJDEodG9TdHJpbmckNShpdCksIDgsIC0xKTtcbn07XG5cbnZhciB1bmN1cnJ5VGhpcyRmID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBmYWlscyRmID0gZmFpbHMkaDtcbnZhciBjbGFzc29mJDYgPSBjbGFzc29mUmF3JDE7XG5cbnZhciAkT2JqZWN0JDQgPSBPYmplY3Q7XG52YXIgc3BsaXQgPSB1bmN1cnJ5VGhpcyRmKCcnLnNwbGl0KTtcblxuLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcbnZhciBpbmRleGVkT2JqZWN0ID0gZmFpbHMkZihmdW5jdGlvbiAoKSB7XG4gIC8vIHRocm93cyBhbiBlcnJvciBpbiByaGlubywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3JoaW5vL2lzc3Vlcy8zNDZcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGlucyAtLSBzYWZlXG4gIHJldHVybiAhJE9iamVjdCQ0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCk7XG59KSA/IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gY2xhc3NvZiQ2KGl0KSA9PSAnU3RyaW5nJyA/IHNwbGl0KGl0LCAnJykgOiAkT2JqZWN0JDQoaXQpO1xufSA6ICRPYmplY3QkNDtcblxudmFyICRUeXBlRXJyb3IkZSA9IFR5cGVFcnJvcjtcblxuLy8gYFJlcXVpcmVPYmplY3RDb2VyY2libGVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1yZXF1aXJlb2JqZWN0Y29lcmNpYmxlXG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSQzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCA9PSB1bmRlZmluZWQpIHRocm93ICRUeXBlRXJyb3IkZShcIkNhbid0IGNhbGwgbWV0aG9kIG9uIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuXG4vLyB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIEluZGV4ZWRPYmplY3QkMiA9IGluZGV4ZWRPYmplY3Q7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSQyID0gcmVxdWlyZU9iamVjdENvZXJjaWJsZSQzO1xuXG52YXIgdG9JbmRleGVkT2JqZWN0JDUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIEluZGV4ZWRPYmplY3QkMihyZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDIoaXQpKTtcbn07XG5cbnZhciBjaGVjayA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgJiYgaXQuTWF0aCA9PSBNYXRoICYmIGl0O1xufTtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwkayA9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLWdsb2JhbC10aGlzIC0tIHNhZmVcbiAgY2hlY2sodHlwZW9mIGdsb2JhbFRoaXMgPT0gJ29iamVjdCcgJiYgZ2xvYmFsVGhpcykgfHxcbiAgY2hlY2sodHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cpIHx8XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHMgLS0gc2FmZVxuICBjaGVjayh0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmKSB8fFxuICBjaGVjayh0eXBlb2YgY29tbW9uanNHbG9iYWwgPT0gJ29iamVjdCcgJiYgY29tbW9uanNHbG9iYWwpIHx8XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuYyAtLSBmYWxsYmFja1xuICAoZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSkoKSB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG52YXIgc2hhcmVkJDMgPSB7ZXhwb3J0czoge319O1xuXG52YXIgZ2xvYmFsJGogPSBnbG9iYWwkaztcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcbnZhciBkZWZpbmVQcm9wZXJ0eSQ2ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG52YXIgZGVmaW5lR2xvYmFsUHJvcGVydHkkMyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgZGVmaW5lUHJvcGVydHkkNihnbG9iYWwkaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBnbG9iYWwkaltrZXldID0gdmFsdWU7XG4gIH0gcmV0dXJuIHZhbHVlO1xufTtcblxudmFyIGdsb2JhbCRpID0gZ2xvYmFsJGs7XG52YXIgZGVmaW5lR2xvYmFsUHJvcGVydHkkMiA9IGRlZmluZUdsb2JhbFByb3BlcnR5JDM7XG5cbnZhciBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJztcbnZhciBzdG9yZSQzID0gZ2xvYmFsJGlbU0hBUkVEXSB8fCBkZWZpbmVHbG9iYWxQcm9wZXJ0eSQyKFNIQVJFRCwge30pO1xuXG52YXIgc2hhcmVkU3RvcmUgPSBzdG9yZSQzO1xuXG52YXIgc3RvcmUkMiA9IHNoYXJlZFN0b3JlO1xuXG4oc2hhcmVkJDMuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHJldHVybiBzdG9yZSQyW2tleV0gfHwgKHN0b3JlJDJba2V5XSA9IHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IHt9KTtcbn0pKCd2ZXJzaW9ucycsIFtdKS5wdXNoKHtcbiAgdmVyc2lvbjogJzMuMjMuMycsXG4gIG1vZGU6ICdnbG9iYWwnLFxuICBjb3B5cmlnaHQ6ICfCqSAyMDE0LTIwMjIgRGVuaXMgUHVzaGthcmV2ICh6bG9pcm9jay5ydSknLFxuICBsaWNlbnNlOiAnaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvYmxvYi92My4yMy4zL0xJQ0VOU0UnLFxuICBzb3VyY2U6ICdodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcydcbn0pO1xuXG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSQxID0gcmVxdWlyZU9iamVjdENvZXJjaWJsZSQzO1xuXG52YXIgJE9iamVjdCQzID0gT2JqZWN0O1xuXG4vLyBgVG9PYmplY3RgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b29iamVjdFxudmFyIHRvT2JqZWN0JDUgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuICRPYmplY3QkMyhyZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDEoYXJndW1lbnQpKTtcbn07XG5cbnZhciB1bmN1cnJ5VGhpcyRlID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciB0b09iamVjdCQ0ID0gdG9PYmplY3QkNTtcblxudmFyIGhhc093blByb3BlcnR5ID0gdW5jdXJyeVRoaXMkZSh7fS5oYXNPd25Qcm9wZXJ0eSk7XG5cbi8vIGBIYXNPd25Qcm9wZXJ0eWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWhhc293bnByb3BlcnR5XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtaGFzb3duIC0tIHNhZmVcbnZhciBoYXNPd25Qcm9wZXJ0eV8xID0gT2JqZWN0Lmhhc093biB8fCBmdW5jdGlvbiBoYXNPd24oaXQsIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkodG9PYmplY3QkNChpdCksIGtleSk7XG59O1xuXG52YXIgdW5jdXJyeVRoaXMkZCA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG5cbnZhciBpZCA9IDA7XG52YXIgcG9zdGZpeCA9IE1hdGgucmFuZG9tKCk7XG52YXIgdG9TdHJpbmckNCA9IHVuY3VycnlUaGlzJGQoMS4wLnRvU3RyaW5nKTtcblxudmFyIHVpZCQyID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gJ1N5bWJvbCgnICsgKGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXkpICsgJylfJyArIHRvU3RyaW5nJDQoKytpZCArIHBvc3RmaXgsIDM2KTtcbn07XG5cbi8vIGBJc0NhbGxhYmxlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaXNjYWxsYWJsZVxudmFyIGlzQ2FsbGFibGUkbCA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gdHlwZW9mIGFyZ3VtZW50ID09ICdmdW5jdGlvbic7XG59O1xuXG52YXIgZ2xvYmFsJGggPSBnbG9iYWwkaztcbnZhciBpc0NhbGxhYmxlJGsgPSBpc0NhbGxhYmxlJGw7XG5cbnZhciBhRnVuY3Rpb24gPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIGlzQ2FsbGFibGUkayhhcmd1bWVudCkgPyBhcmd1bWVudCA6IHVuZGVmaW5lZDtcbn07XG5cbnZhciBnZXRCdWlsdEluJDggPSBmdW5jdGlvbiAobmFtZXNwYWNlLCBtZXRob2QpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPCAyID8gYUZ1bmN0aW9uKGdsb2JhbCRoW25hbWVzcGFjZV0pIDogZ2xvYmFsJGhbbmFtZXNwYWNlXSAmJiBnbG9iYWwkaFtuYW1lc3BhY2VdW21ldGhvZF07XG59O1xuXG52YXIgZ2V0QnVpbHRJbiQ3ID0gZ2V0QnVpbHRJbiQ4O1xuXG52YXIgZW5naW5lVXNlckFnZW50ID0gZ2V0QnVpbHRJbiQ3KCduYXZpZ2F0b3InLCAndXNlckFnZW50JykgfHwgJyc7XG5cbnZhciBnbG9iYWwkZyA9IGdsb2JhbCRrO1xudmFyIHVzZXJBZ2VudCQ1ID0gZW5naW5lVXNlckFnZW50O1xuXG52YXIgcHJvY2VzcyQzID0gZ2xvYmFsJGcucHJvY2VzcztcbnZhciBEZW5vJDEgPSBnbG9iYWwkZy5EZW5vO1xudmFyIHZlcnNpb25zID0gcHJvY2VzcyQzICYmIHByb2Nlc3MkMy52ZXJzaW9ucyB8fCBEZW5vJDEgJiYgRGVubyQxLnZlcnNpb247XG52YXIgdjggPSB2ZXJzaW9ucyAmJiB2ZXJzaW9ucy52ODtcbnZhciBtYXRjaCwgdmVyc2lvbjtcblxuaWYgKHY4KSB7XG4gIG1hdGNoID0gdjguc3BsaXQoJy4nKTtcbiAgLy8gaW4gb2xkIENocm9tZSwgdmVyc2lvbnMgb2YgVjggaXNuJ3QgVjggPSBDaHJvbWUgLyAxMFxuICAvLyBidXQgdGhlaXIgY29ycmVjdCB2ZXJzaW9ucyBhcmUgbm90IGludGVyZXN0aW5nIGZvciB1c1xuICB2ZXJzaW9uID0gbWF0Y2hbMF0gPiAwICYmIG1hdGNoWzBdIDwgNCA/IDEgOiArKG1hdGNoWzBdICsgbWF0Y2hbMV0pO1xufVxuXG4vLyBCcm93c2VyRlMgTm9kZUpTIGBwcm9jZXNzYCBwb2x5ZmlsbCBpbmNvcnJlY3RseSBzZXQgYC52OGAgdG8gYDAuMGBcbi8vIHNvIGNoZWNrIGB1c2VyQWdlbnRgIGV2ZW4gaWYgYC52OGAgZXhpc3RzLCBidXQgMFxuaWYgKCF2ZXJzaW9uICYmIHVzZXJBZ2VudCQ1KSB7XG4gIG1hdGNoID0gdXNlckFnZW50JDUubWF0Y2goL0VkZ2VcXC8oXFxkKykvKTtcbiAgaWYgKCFtYXRjaCB8fCBtYXRjaFsxXSA+PSA3NCkge1xuICAgIG1hdGNoID0gdXNlckFnZW50JDUubWF0Y2goL0Nocm9tZVxcLyhcXGQrKS8pO1xuICAgIGlmIChtYXRjaCkgdmVyc2lvbiA9ICttYXRjaFsxXTtcbiAgfVxufVxuXG52YXIgZW5naW5lVjhWZXJzaW9uID0gdmVyc2lvbjtcblxuLyogZXNsaW50LWRpc2FibGUgZXMteC9uby1zeW1ib2wgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmcgKi9cblxudmFyIFY4X1ZFUlNJT04kMSA9IGVuZ2luZVY4VmVyc2lvbjtcbnZhciBmYWlscyRlID0gZmFpbHMkaDtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5c3ltYm9scyAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xudmFyIG5hdGl2ZVN5bWJvbCA9ICEhT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyAmJiAhZmFpbHMkZShmdW5jdGlvbiAoKSB7XG4gIHZhciBzeW1ib2wgPSBTeW1ib2woKTtcbiAgLy8gQ2hyb21lIDM4IFN5bWJvbCBoYXMgaW5jb3JyZWN0IHRvU3RyaW5nIGNvbnZlcnNpb25cbiAgLy8gYGdldC1vd24tcHJvcGVydHktc3ltYm9sc2AgcG9seWZpbGwgc3ltYm9scyBjb252ZXJ0ZWQgdG8gb2JqZWN0IGFyZSBub3QgU3ltYm9sIGluc3RhbmNlc1xuICByZXR1cm4gIVN0cmluZyhzeW1ib2wpIHx8ICEoT2JqZWN0KHN5bWJvbCkgaW5zdGFuY2VvZiBTeW1ib2wpIHx8XG4gICAgLy8gQ2hyb21lIDM4LTQwIHN5bWJvbHMgYXJlIG5vdCBpbmhlcml0ZWQgZnJvbSBET00gY29sbGVjdGlvbnMgcHJvdG90eXBlcyB0byBpbnN0YW5jZXNcbiAgICAhU3ltYm9sLnNoYW0gJiYgVjhfVkVSU0lPTiQxICYmIFY4X1ZFUlNJT04kMSA8IDQxO1xufSk7XG5cbi8qIGVzbGludC1kaXNhYmxlIGVzLXgvbm8tc3ltYm9sIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nICovXG5cbnZhciBOQVRJVkVfU1lNQk9MJDIgPSBuYXRpdmVTeW1ib2w7XG5cbnZhciB1c2VTeW1ib2xBc1VpZCA9IE5BVElWRV9TWU1CT0wkMlxuICAmJiAhU3ltYm9sLnNoYW1cbiAgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSAnc3ltYm9sJztcblxudmFyIGdsb2JhbCRmID0gZ2xvYmFsJGs7XG52YXIgc2hhcmVkJDIgPSBzaGFyZWQkMy5leHBvcnRzO1xudmFyIGhhc093biRiID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciB1aWQkMSA9IHVpZCQyO1xudmFyIE5BVElWRV9TWU1CT0wkMSA9IG5hdGl2ZVN5bWJvbDtcbnZhciBVU0VfU1lNQk9MX0FTX1VJRCQxID0gdXNlU3ltYm9sQXNVaWQ7XG5cbnZhciBXZWxsS25vd25TeW1ib2xzU3RvcmUgPSBzaGFyZWQkMignd2tzJyk7XG52YXIgU3ltYm9sJDEgPSBnbG9iYWwkZi5TeW1ib2w7XG52YXIgc3ltYm9sRm9yID0gU3ltYm9sJDEgJiYgU3ltYm9sJDFbJ2ZvciddO1xudmFyIGNyZWF0ZVdlbGxLbm93blN5bWJvbCA9IFVTRV9TWU1CT0xfQVNfVUlEJDEgPyBTeW1ib2wkMSA6IFN5bWJvbCQxICYmIFN5bWJvbCQxLndpdGhvdXRTZXR0ZXIgfHwgdWlkJDE7XG5cbnZhciB3ZWxsS25vd25TeW1ib2wkZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGlmICghaGFzT3duJGIoV2VsbEtub3duU3ltYm9sc1N0b3JlLCBuYW1lKSB8fCAhKE5BVElWRV9TWU1CT0wkMSB8fCB0eXBlb2YgV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdID09ICdzdHJpbmcnKSkge1xuICAgIHZhciBkZXNjcmlwdGlvbiA9ICdTeW1ib2wuJyArIG5hbWU7XG4gICAgaWYgKE5BVElWRV9TWU1CT0wkMSAmJiBoYXNPd24kYihTeW1ib2wkMSwgbmFtZSkpIHtcbiAgICAgIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9IFN5bWJvbCQxW25hbWVdO1xuICAgIH0gZWxzZSBpZiAoVVNFX1NZTUJPTF9BU19VSUQkMSAmJiBzeW1ib2xGb3IpIHtcbiAgICAgIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9IHN5bWJvbEZvcihkZXNjcmlwdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9IGNyZWF0ZVdlbGxLbm93blN5bWJvbChkZXNjcmlwdGlvbik7XG4gICAgfVxuICB9IHJldHVybiBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV07XG59O1xuXG52YXIgaXNDYWxsYWJsZSRqID0gaXNDYWxsYWJsZSRsO1xuXG52YXIgaXNPYmplY3QkOCA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiBpc0NhbGxhYmxlJGooaXQpO1xufTtcblxudmFyIGlzT2JqZWN0JDcgPSBpc09iamVjdCQ4O1xuXG52YXIgJFN0cmluZyQzID0gU3RyaW5nO1xudmFyICRUeXBlRXJyb3IkZCA9IFR5cGVFcnJvcjtcblxuLy8gYEFzc2VydDogVHlwZShhcmd1bWVudCkgaXMgT2JqZWN0YFxudmFyIGFuT2JqZWN0JGMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgaWYgKGlzT2JqZWN0JDcoYXJndW1lbnQpKSByZXR1cm4gYXJndW1lbnQ7XG4gIHRocm93ICRUeXBlRXJyb3IkZCgkU3RyaW5nJDMoYXJndW1lbnQpICsgJyBpcyBub3QgYW4gb2JqZWN0Jyk7XG59O1xuXG52YXIgb2JqZWN0RGVmaW5lUHJvcGVydGllcyA9IHt9O1xuXG52YXIgZmFpbHMkZCA9IGZhaWxzJGg7XG5cbi8vIERldGVjdCBJRTgncyBpbmNvbXBsZXRlIGRlZmluZVByb3BlcnR5IGltcGxlbWVudGF0aW9uXG52YXIgZGVzY3JpcHRvcnMgPSAhZmFpbHMkZChmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAxLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KVsxXSAhPSA3O1xufSk7XG5cbnZhciBERVNDUklQVE9SUyRiID0gZGVzY3JpcHRvcnM7XG52YXIgZmFpbHMkYyA9IGZhaWxzJGg7XG5cbi8vIFY4IH4gQ2hyb21lIDM2LVxuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzMzNFxudmFyIHY4UHJvdG90eXBlRGVmaW5lQnVnID0gREVTQ1JJUFRPUlMkYiAmJiBmYWlscyRjKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9LCAncHJvdG90eXBlJywge1xuICAgIHZhbHVlOiA0MixcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSkucHJvdG90eXBlICE9IDQyO1xufSk7XG5cbnZhciBvYmplY3REZWZpbmVQcm9wZXJ0eSA9IHt9O1xuXG52YXIgZ2xvYmFsJGUgPSBnbG9iYWwkaztcbnZhciBpc09iamVjdCQ2ID0gaXNPYmplY3QkODtcblxudmFyIGRvY3VtZW50JDMgPSBnbG9iYWwkZS5kb2N1bWVudDtcbi8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxudmFyIEVYSVNUUyQxID0gaXNPYmplY3QkNihkb2N1bWVudCQzKSAmJiBpc09iamVjdCQ2KGRvY3VtZW50JDMuY3JlYXRlRWxlbWVudCk7XG5cbnZhciBkb2N1bWVudENyZWF0ZUVsZW1lbnQkMiA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gRVhJU1RTJDEgPyBkb2N1bWVudCQzLmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59O1xuXG52YXIgREVTQ1JJUFRPUlMkYSA9IGRlc2NyaXB0b3JzO1xudmFyIGZhaWxzJGIgPSBmYWlscyRoO1xudmFyIGNyZWF0ZUVsZW1lbnQkMSA9IGRvY3VtZW50Q3JlYXRlRWxlbWVudCQyO1xuXG4vLyBUaGFua3MgdG8gSUU4IGZvciBpdHMgZnVubnkgZGVmaW5lUHJvcGVydHlcbnZhciBpZThEb21EZWZpbmUgPSAhREVTQ1JJUFRPUlMkYSAmJiAhZmFpbHMkYihmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGNyZWF0ZUVsZW1lbnQkMSgnZGl2JyksICdhJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfVxuICB9KS5hICE9IDc7XG59KTtcblxudmFyIE5BVElWRV9CSU5EJDIgPSBmdW5jdGlvbkJpbmROYXRpdmU7XG5cbnZhciBjYWxsJGUgPSBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbDtcblxudmFyIGZ1bmN0aW9uQ2FsbCA9IE5BVElWRV9CSU5EJDIgPyBjYWxsJGUuYmluZChjYWxsJGUpIDogZnVuY3Rpb24gKCkge1xuICByZXR1cm4gY2FsbCRlLmFwcGx5KGNhbGwkZSwgYXJndW1lbnRzKTtcbn07XG5cbnZhciB1bmN1cnJ5VGhpcyRjID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcblxudmFyIG9iamVjdElzUHJvdG90eXBlT2YgPSB1bmN1cnJ5VGhpcyRjKHt9LmlzUHJvdG90eXBlT2YpO1xuXG52YXIgZ2V0QnVpbHRJbiQ2ID0gZ2V0QnVpbHRJbiQ4O1xudmFyIGlzQ2FsbGFibGUkaSA9IGlzQ2FsbGFibGUkbDtcbnZhciBpc1Byb3RvdHlwZU9mJDQgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xudmFyIFVTRV9TWU1CT0xfQVNfVUlEID0gdXNlU3ltYm9sQXNVaWQ7XG5cbnZhciAkT2JqZWN0JDIgPSBPYmplY3Q7XG5cbnZhciBpc1N5bWJvbCQyID0gVVNFX1NZTUJPTF9BU19VSUQgPyBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJztcbn0gOiBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyICRTeW1ib2wgPSBnZXRCdWlsdEluJDYoJ1N5bWJvbCcpO1xuICByZXR1cm4gaXNDYWxsYWJsZSRpKCRTeW1ib2wpICYmIGlzUHJvdG90eXBlT2YkNCgkU3ltYm9sLnByb3RvdHlwZSwgJE9iamVjdCQyKGl0KSk7XG59O1xuXG52YXIgJFN0cmluZyQyID0gU3RyaW5nO1xuXG52YXIgdHJ5VG9TdHJpbmckNSA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICB0cnkge1xuICAgIHJldHVybiAkU3RyaW5nJDIoYXJndW1lbnQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiAnT2JqZWN0JztcbiAgfVxufTtcblxudmFyIGlzQ2FsbGFibGUkaCA9IGlzQ2FsbGFibGUkbDtcbnZhciB0cnlUb1N0cmluZyQ0ID0gdHJ5VG9TdHJpbmckNTtcblxudmFyICRUeXBlRXJyb3IkYyA9IFR5cGVFcnJvcjtcblxuLy8gYEFzc2VydDogSXNDYWxsYWJsZShhcmd1bWVudCkgaXMgdHJ1ZWBcbnZhciBhQ2FsbGFibGUkOSA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAoaXNDYWxsYWJsZSRoKGFyZ3VtZW50KSkgcmV0dXJuIGFyZ3VtZW50O1xuICB0aHJvdyAkVHlwZUVycm9yJGModHJ5VG9TdHJpbmckNChhcmd1bWVudCkgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG59O1xuXG52YXIgYUNhbGxhYmxlJDggPSBhQ2FsbGFibGUkOTtcblxuLy8gYEdldE1ldGhvZGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWdldG1ldGhvZFxudmFyIGdldE1ldGhvZCQzID0gZnVuY3Rpb24gKFYsIFApIHtcbiAgdmFyIGZ1bmMgPSBWW1BdO1xuICByZXR1cm4gZnVuYyA9PSBudWxsID8gdW5kZWZpbmVkIDogYUNhbGxhYmxlJDgoZnVuYyk7XG59O1xuXG52YXIgY2FsbCRkID0gZnVuY3Rpb25DYWxsO1xudmFyIGlzQ2FsbGFibGUkZyA9IGlzQ2FsbGFibGUkbDtcbnZhciBpc09iamVjdCQ1ID0gaXNPYmplY3QkODtcblxudmFyICRUeXBlRXJyb3IkYiA9IFR5cGVFcnJvcjtcblxuLy8gYE9yZGluYXJ5VG9QcmltaXRpdmVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vcmRpbmFyeXRvcHJpbWl0aXZlXG52YXIgb3JkaW5hcnlUb1ByaW1pdGl2ZSQxID0gZnVuY3Rpb24gKGlucHV0LCBwcmVmKSB7XG4gIHZhciBmbiwgdmFsO1xuICBpZiAocHJlZiA9PT0gJ3N0cmluZycgJiYgaXNDYWxsYWJsZSRnKGZuID0gaW5wdXQudG9TdHJpbmcpICYmICFpc09iamVjdCQ1KHZhbCA9IGNhbGwkZChmbiwgaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKGlzQ2FsbGFibGUkZyhmbiA9IGlucHV0LnZhbHVlT2YpICYmICFpc09iamVjdCQ1KHZhbCA9IGNhbGwkZChmbiwgaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKHByZWYgIT09ICdzdHJpbmcnICYmIGlzQ2FsbGFibGUkZyhmbiA9IGlucHV0LnRvU3RyaW5nKSAmJiAhaXNPYmplY3QkNSh2YWwgPSBjYWxsJGQoZm4sIGlucHV0KSkpIHJldHVybiB2YWw7XG4gIHRocm93ICRUeXBlRXJyb3IkYihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07XG5cbnZhciBjYWxsJGMgPSBmdW5jdGlvbkNhbGw7XG52YXIgaXNPYmplY3QkNCA9IGlzT2JqZWN0JDg7XG52YXIgaXNTeW1ib2wkMSA9IGlzU3ltYm9sJDI7XG52YXIgZ2V0TWV0aG9kJDIgPSBnZXRNZXRob2QkMztcbnZhciBvcmRpbmFyeVRvUHJpbWl0aXZlID0gb3JkaW5hcnlUb1ByaW1pdGl2ZSQxO1xudmFyIHdlbGxLbm93blN5bWJvbCRmID0gd2VsbEtub3duU3ltYm9sJGc7XG5cbnZhciAkVHlwZUVycm9yJGEgPSBUeXBlRXJyb3I7XG52YXIgVE9fUFJJTUlUSVZFID0gd2VsbEtub3duU3ltYm9sJGYoJ3RvUHJpbWl0aXZlJyk7XG5cbi8vIGBUb1ByaW1pdGl2ZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvcHJpbWl0aXZlXG52YXIgdG9QcmltaXRpdmUkMSA9IGZ1bmN0aW9uIChpbnB1dCwgcHJlZikge1xuICBpZiAoIWlzT2JqZWN0JDQoaW5wdXQpIHx8IGlzU3ltYm9sJDEoaW5wdXQpKSByZXR1cm4gaW5wdXQ7XG4gIHZhciBleG90aWNUb1ByaW0gPSBnZXRNZXRob2QkMihpbnB1dCwgVE9fUFJJTUlUSVZFKTtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKGV4b3RpY1RvUHJpbSkge1xuICAgIGlmIChwcmVmID09PSB1bmRlZmluZWQpIHByZWYgPSAnZGVmYXVsdCc7XG4gICAgcmVzdWx0ID0gY2FsbCRjKGV4b3RpY1RvUHJpbSwgaW5wdXQsIHByZWYpO1xuICAgIGlmICghaXNPYmplY3QkNChyZXN1bHQpIHx8IGlzU3ltYm9sJDEocmVzdWx0KSkgcmV0dXJuIHJlc3VsdDtcbiAgICB0aHJvdyAkVHlwZUVycm9yJGEoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG4gIH1cbiAgaWYgKHByZWYgPT09IHVuZGVmaW5lZCkgcHJlZiA9ICdudW1iZXInO1xuICByZXR1cm4gb3JkaW5hcnlUb1ByaW1pdGl2ZShpbnB1dCwgcHJlZik7XG59O1xuXG52YXIgdG9QcmltaXRpdmUgPSB0b1ByaW1pdGl2ZSQxO1xudmFyIGlzU3ltYm9sID0gaXNTeW1ib2wkMjtcblxuLy8gYFRvUHJvcGVydHlLZXlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b3Byb3BlcnR5a2V5XG52YXIgdG9Qcm9wZXJ0eUtleSQzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHZhciBrZXkgPSB0b1ByaW1pdGl2ZShhcmd1bWVudCwgJ3N0cmluZycpO1xuICByZXR1cm4gaXNTeW1ib2woa2V5KSA/IGtleSA6IGtleSArICcnO1xufTtcblxudmFyIERFU0NSSVBUT1JTJDkgPSBkZXNjcmlwdG9ycztcbnZhciBJRThfRE9NX0RFRklORSQxID0gaWU4RG9tRGVmaW5lO1xudmFyIFY4X1BST1RPVFlQRV9ERUZJTkVfQlVHJDEgPSB2OFByb3RvdHlwZURlZmluZUJ1ZztcbnZhciBhbk9iamVjdCRiID0gYW5PYmplY3QkYztcbnZhciB0b1Byb3BlcnR5S2V5JDIgPSB0b1Byb3BlcnR5S2V5JDM7XG5cbnZhciAkVHlwZUVycm9yJDkgPSBUeXBlRXJyb3I7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gc2FmZVxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgRU5VTUVSQUJMRSA9ICdlbnVtZXJhYmxlJztcbnZhciBDT05GSUdVUkFCTEUkMSA9ICdjb25maWd1cmFibGUnO1xudmFyIFdSSVRBQkxFID0gJ3dyaXRhYmxlJztcblxuLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0eWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0eVxub2JqZWN0RGVmaW5lUHJvcGVydHkuZiA9IERFU0NSSVBUT1JTJDkgPyBWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyQxID8gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICBhbk9iamVjdCRiKE8pO1xuICBQID0gdG9Qcm9wZXJ0eUtleSQyKFApO1xuICBhbk9iamVjdCRiKEF0dHJpYnV0ZXMpO1xuICBpZiAodHlwZW9mIE8gPT09ICdmdW5jdGlvbicgJiYgUCA9PT0gJ3Byb3RvdHlwZScgJiYgJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzICYmIFdSSVRBQkxFIGluIEF0dHJpYnV0ZXMgJiYgIUF0dHJpYnV0ZXNbV1JJVEFCTEVdKSB7XG4gICAgdmFyIGN1cnJlbnQgPSAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEoTywgUCk7XG4gICAgaWYgKGN1cnJlbnQgJiYgY3VycmVudFtXUklUQUJMRV0pIHtcbiAgICAgIE9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICAgICAgQXR0cmlidXRlcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBDT05GSUdVUkFCTEUkMSBpbiBBdHRyaWJ1dGVzID8gQXR0cmlidXRlc1tDT05GSUdVUkFCTEUkMV0gOiBjdXJyZW50W0NPTkZJR1VSQUJMRSQxXSxcbiAgICAgICAgZW51bWVyYWJsZTogRU5VTUVSQUJMRSBpbiBBdHRyaWJ1dGVzID8gQXR0cmlidXRlc1tFTlVNRVJBQkxFXSA6IGN1cnJlbnRbRU5VTUVSQUJMRV0sXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gIH0gcmV0dXJuICRkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKTtcbn0gOiAkZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGFuT2JqZWN0JGIoTyk7XG4gIFAgPSB0b1Byb3BlcnR5S2V5JDIoUCk7XG4gIGFuT2JqZWN0JGIoQXR0cmlidXRlcyk7XG4gIGlmIChJRThfRE9NX0RFRklORSQxKSB0cnkge1xuICAgIHJldHVybiAkZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcykgdGhyb3cgJFR5cGVFcnJvciQ5KCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCcpO1xuICBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKSBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuXG52YXIgY2VpbCA9IE1hdGguY2VpbDtcbnZhciBmbG9vciQxID0gTWF0aC5mbG9vcjtcblxuLy8gYE1hdGgudHJ1bmNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXRoLnRydW5jXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1tYXRoLXRydW5jIC0tIHNhZmVcbnZhciBtYXRoVHJ1bmMgPSBNYXRoLnRydW5jIHx8IGZ1bmN0aW9uIHRydW5jKHgpIHtcbiAgdmFyIG4gPSAreDtcbiAgcmV0dXJuIChuID4gMCA/IGZsb29yJDEgOiBjZWlsKShuKTtcbn07XG5cbnZhciB0cnVuYyA9IG1hdGhUcnVuYztcblxuLy8gYFRvSW50ZWdlck9ySW5maW5pdHlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b2ludGVnZXJvcmluZmluaXR5XG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSQyID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHZhciBudW1iZXIgPSArYXJndW1lbnQ7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG4gIHJldHVybiBudW1iZXIgIT09IG51bWJlciB8fCBudW1iZXIgPT09IDAgPyAwIDogdHJ1bmMobnVtYmVyKTtcbn07XG5cbnZhciB0b0ludGVnZXJPckluZmluaXR5JDEgPSB0b0ludGVnZXJPckluZmluaXR5JDI7XG5cbnZhciBtYXgkMSA9IE1hdGgubWF4O1xudmFyIG1pbiQxID0gTWF0aC5taW47XG5cbi8vIEhlbHBlciBmb3IgYSBwb3B1bGFyIHJlcGVhdGluZyBjYXNlIG9mIHRoZSBzcGVjOlxuLy8gTGV0IGludGVnZXIgYmUgPyBUb0ludGVnZXIoaW5kZXgpLlxuLy8gSWYgaW50ZWdlciA8IDAsIGxldCByZXN1bHQgYmUgbWF4KChsZW5ndGggKyBpbnRlZ2VyKSwgMCk7IGVsc2UgbGV0IHJlc3VsdCBiZSBtaW4oaW50ZWdlciwgbGVuZ3RoKS5cbnZhciB0b0Fic29sdXRlSW5kZXgkMiA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XG4gIHZhciBpbnRlZ2VyID0gdG9JbnRlZ2VyT3JJbmZpbml0eSQxKGluZGV4KTtcbiAgcmV0dXJuIGludGVnZXIgPCAwID8gbWF4JDEoaW50ZWdlciArIGxlbmd0aCwgMCkgOiBtaW4kMShpbnRlZ2VyLCBsZW5ndGgpO1xufTtcblxudmFyIHRvSW50ZWdlck9ySW5maW5pdHkgPSB0b0ludGVnZXJPckluZmluaXR5JDI7XG5cbnZhciBtaW4gPSBNYXRoLm1pbjtcblxuLy8gYFRvTGVuZ3RoYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9sZW5ndGhcbnZhciB0b0xlbmd0aCQxID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiBhcmd1bWVudCA+IDAgPyBtaW4odG9JbnRlZ2VyT3JJbmZpbml0eShhcmd1bWVudCksIDB4MUZGRkZGRkZGRkZGRkYpIDogMDsgLy8gMiAqKiA1MyAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTtcblxudmFyIHRvTGVuZ3RoID0gdG9MZW5ndGgkMTtcblxuLy8gYExlbmd0aE9mQXJyYXlMaWtlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbGVuZ3Rob2ZhcnJheWxpa2VcbnZhciBsZW5ndGhPZkFycmF5TGlrZSQ1ID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gdG9MZW5ndGgob2JqLmxlbmd0aCk7XG59O1xuXG52YXIgdG9JbmRleGVkT2JqZWN0JDQgPSB0b0luZGV4ZWRPYmplY3QkNTtcbnZhciB0b0Fic29sdXRlSW5kZXgkMSA9IHRvQWJzb2x1dGVJbmRleCQyO1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlJDQgPSBsZW5ndGhPZkFycmF5TGlrZSQ1O1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLnsgaW5kZXhPZiwgaW5jbHVkZXMgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxudmFyIGNyZWF0ZU1ldGhvZCQxID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdCQ0KCR0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UkNChPKTtcbiAgICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgkMShmcm9tSW5kZXgsIGxlbmd0aCk7XG4gICAgdmFyIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xuICAgIGlmIChJU19JTkNMVURFUyAmJiBlbCAhPSBlbCkgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSB7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xuICAgICAgaWYgKHZhbHVlICE9IHZhbHVlKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSNpbmRleE9mIGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgICBpZiAoKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pICYmIE9baW5kZXhdID09PSBlbCkgcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcblxudmFyIGFycmF5SW5jbHVkZXMgPSB7XG4gIC8vIGBBcnJheS5wcm90b3R5cGUuaW5jbHVkZXNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmNsdWRlc1xuICBpbmNsdWRlczogY3JlYXRlTWV0aG9kJDEodHJ1ZSksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuaW5kZXhPZmAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmluZGV4b2ZcbiAgaW5kZXhPZjogY3JlYXRlTWV0aG9kJDEoZmFsc2UpXG59O1xuXG52YXIgaGlkZGVuS2V5cyQ0ID0ge307XG5cbnZhciB1bmN1cnJ5VGhpcyRiID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBoYXNPd24kYSA9IGhhc093blByb3BlcnR5XzE7XG52YXIgdG9JbmRleGVkT2JqZWN0JDMgPSB0b0luZGV4ZWRPYmplY3QkNTtcbnZhciBpbmRleE9mID0gYXJyYXlJbmNsdWRlcy5pbmRleE9mO1xudmFyIGhpZGRlbktleXMkMyA9IGhpZGRlbktleXMkNDtcblxudmFyIHB1c2gkMSA9IHVuY3VycnlUaGlzJGIoW10ucHVzaCk7XG5cbnZhciBvYmplY3RLZXlzSW50ZXJuYWwgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xuICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdCQzKG9iamVjdCk7XG4gIHZhciBpID0gMDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBPKSAhaGFzT3duJGEoaGlkZGVuS2V5cyQzLCBrZXkpICYmIGhhc093biRhKE8sIGtleSkgJiYgcHVzaCQxKHJlc3VsdCwga2V5KTtcbiAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkgaWYgKGhhc093biRhKE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICAgfmluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHB1c2gkMShyZXN1bHQsIGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIElFOC0gZG9uJ3QgZW51bSBidWcga2V5c1xudmFyIGVudW1CdWdLZXlzJDMgPSBbXG4gICdjb25zdHJ1Y3RvcicsXG4gICdoYXNPd25Qcm9wZXJ0eScsXG4gICdpc1Byb3RvdHlwZU9mJyxcbiAgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJyxcbiAgJ3RvTG9jYWxlU3RyaW5nJyxcbiAgJ3RvU3RyaW5nJyxcbiAgJ3ZhbHVlT2YnXG5dO1xuXG52YXIgaW50ZXJuYWxPYmplY3RLZXlzJDEgPSBvYmplY3RLZXlzSW50ZXJuYWw7XG52YXIgZW51bUJ1Z0tleXMkMiA9IGVudW1CdWdLZXlzJDM7XG5cbi8vIGBPYmplY3Qua2V5c2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5rZXlzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3Qta2V5cyAtLSBzYWZlXG52YXIgb2JqZWN0S2V5cyQyID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKSB7XG4gIHJldHVybiBpbnRlcm5hbE9iamVjdEtleXMkMShPLCBlbnVtQnVnS2V5cyQyKTtcbn07XG5cbnZhciBERVNDUklQVE9SUyQ4ID0gZGVzY3JpcHRvcnM7XG52YXIgVjhfUFJPVE9UWVBFX0RFRklORV9CVUcgPSB2OFByb3RvdHlwZURlZmluZUJ1ZztcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQ1ID0gb2JqZWN0RGVmaW5lUHJvcGVydHk7XG52YXIgYW5PYmplY3QkYSA9IGFuT2JqZWN0JGM7XG52YXIgdG9JbmRleGVkT2JqZWN0JDIgPSB0b0luZGV4ZWRPYmplY3QkNTtcbnZhciBvYmplY3RLZXlzJDEgPSBvYmplY3RLZXlzJDI7XG5cbi8vIGBPYmplY3QuZGVmaW5lUHJvcGVydGllc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0aWVzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZGVmaW5lcHJvcGVydGllcyAtLSBzYWZlXG5vYmplY3REZWZpbmVQcm9wZXJ0aWVzLmYgPSBERVNDUklQVE9SUyQ4ICYmICFWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XG4gIGFuT2JqZWN0JGEoTyk7XG4gIHZhciBwcm9wcyA9IHRvSW5kZXhlZE9iamVjdCQyKFByb3BlcnRpZXMpO1xuICB2YXIga2V5cyA9IG9iamVjdEtleXMkMShQcm9wZXJ0aWVzKTtcbiAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIga2V5O1xuICB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIGRlZmluZVByb3BlcnR5TW9kdWxlJDUuZihPLCBrZXkgPSBrZXlzW2luZGV4KytdLCBwcm9wc1trZXldKTtcbiAgcmV0dXJuIE87XG59O1xuXG52YXIgZ2V0QnVpbHRJbiQ1ID0gZ2V0QnVpbHRJbiQ4O1xuXG52YXIgaHRtbCQyID0gZ2V0QnVpbHRJbiQ1KCdkb2N1bWVudCcsICdkb2N1bWVudEVsZW1lbnQnKTtcblxudmFyIHNoYXJlZCQxID0gc2hhcmVkJDMuZXhwb3J0cztcbnZhciB1aWQgPSB1aWQkMjtcblxudmFyIGtleXMgPSBzaGFyZWQkMSgna2V5cycpO1xuXG52YXIgc2hhcmVkS2V5JDMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBrZXlzW2tleV0gfHwgKGtleXNba2V5XSA9IHVpZChrZXkpKTtcbn07XG5cbi8qIGdsb2JhbCBBY3RpdmVYT2JqZWN0IC0tIG9sZCBJRSwgV1NIICovXG5cbnZhciBhbk9iamVjdCQ5ID0gYW5PYmplY3QkYztcbnZhciBkZWZpbmVQcm9wZXJ0aWVzTW9kdWxlID0gb2JqZWN0RGVmaW5lUHJvcGVydGllcztcbnZhciBlbnVtQnVnS2V5cyQxID0gZW51bUJ1Z0tleXMkMztcbnZhciBoaWRkZW5LZXlzJDIgPSBoaWRkZW5LZXlzJDQ7XG52YXIgaHRtbCQxID0gaHRtbCQyO1xudmFyIGRvY3VtZW50Q3JlYXRlRWxlbWVudCQxID0gZG9jdW1lbnRDcmVhdGVFbGVtZW50JDI7XG52YXIgc2hhcmVkS2V5JDIgPSBzaGFyZWRLZXkkMztcblxudmFyIEdUID0gJz4nO1xudmFyIExUID0gJzwnO1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xudmFyIFNDUklQVCA9ICdzY3JpcHQnO1xudmFyIElFX1BST1RPJDEgPSBzaGFyZWRLZXkkMignSUVfUFJPVE8nKTtcblxudmFyIEVtcHR5Q29uc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG5cbnZhciBzY3JpcHRUYWcgPSBmdW5jdGlvbiAoY29udGVudCkge1xuICByZXR1cm4gTFQgKyBTQ1JJUFQgKyBHVCArIGNvbnRlbnQgKyBMVCArICcvJyArIFNDUklQVCArIEdUO1xufTtcblxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIEFjdGl2ZVggT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBOdWxsUHJvdG9PYmplY3RWaWFBY3RpdmVYID0gZnVuY3Rpb24gKGFjdGl2ZVhEb2N1bWVudCkge1xuICBhY3RpdmVYRG9jdW1lbnQud3JpdGUoc2NyaXB0VGFnKCcnKSk7XG4gIGFjdGl2ZVhEb2N1bWVudC5jbG9zZSgpO1xuICB2YXIgdGVtcCA9IGFjdGl2ZVhEb2N1bWVudC5wYXJlbnRXaW5kb3cuT2JqZWN0O1xuICBhY3RpdmVYRG9jdW1lbnQgPSBudWxsOyAvLyBhdm9pZCBtZW1vcnkgbGVha1xuICByZXR1cm4gdGVtcDtcbn07XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBOdWxsUHJvdG9PYmplY3RWaWFJRnJhbWUgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSBkb2N1bWVudENyZWF0ZUVsZW1lbnQkMSgnaWZyYW1lJyk7XG4gIHZhciBKUyA9ICdqYXZhJyArIFNDUklQVCArICc6JztcbiAgdmFyIGlmcmFtZURvY3VtZW50O1xuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgaHRtbCQxLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy80NzVcbiAgaWZyYW1lLnNyYyA9IFN0cmluZyhKUyk7XG4gIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcbiAgaWZyYW1lRG9jdW1lbnQud3JpdGUoc2NyaXB0VGFnKCdkb2N1bWVudC5GPU9iamVjdCcpKTtcbiAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcbiAgcmV0dXJuIGlmcmFtZURvY3VtZW50LkY7XG59O1xuXG4vLyBDaGVjayBmb3IgZG9jdW1lbnQuZG9tYWluIGFuZCBhY3RpdmUgeCBzdXBwb3J0XG4vLyBObyBuZWVkIHRvIHVzZSBhY3RpdmUgeCBhcHByb2FjaCB3aGVuIGRvY3VtZW50LmRvbWFpbiBpcyBub3Qgc2V0XG4vLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltL2lzc3Vlcy8xNTBcbi8vIHZhcmlhdGlvbiBvZiBodHRwczovL2dpdGh1Yi5jb20va2l0Y2FtYnJpZGdlL2VzNS1zaGltL2NvbW1pdC80ZjczOGFjMDY2MzQ2XG4vLyBhdm9pZCBJRSBHQyBidWdcbnZhciBhY3RpdmVYRG9jdW1lbnQ7XG52YXIgTnVsbFByb3RvT2JqZWN0ID0gZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIGFjdGl2ZVhEb2N1bWVudCA9IG5ldyBBY3RpdmVYT2JqZWN0KCdodG1sZmlsZScpO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBpZ25vcmUgKi8gfVxuICBOdWxsUHJvdG9PYmplY3QgPSB0eXBlb2YgZG9jdW1lbnQgIT0gJ3VuZGVmaW5lZCdcbiAgICA/IGRvY3VtZW50LmRvbWFpbiAmJiBhY3RpdmVYRG9jdW1lbnRcbiAgICAgID8gTnVsbFByb3RvT2JqZWN0VmlhQWN0aXZlWChhY3RpdmVYRG9jdW1lbnQpIC8vIG9sZCBJRVxuICAgICAgOiBOdWxsUHJvdG9PYmplY3RWaWFJRnJhbWUoKVxuICAgIDogTnVsbFByb3RvT2JqZWN0VmlhQWN0aXZlWChhY3RpdmVYRG9jdW1lbnQpOyAvLyBXU0hcbiAgdmFyIGxlbmd0aCA9IGVudW1CdWdLZXlzJDEubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIGRlbGV0ZSBOdWxsUHJvdG9PYmplY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5cyQxW2xlbmd0aF1dO1xuICByZXR1cm4gTnVsbFByb3RvT2JqZWN0KCk7XG59O1xuXG5oaWRkZW5LZXlzJDJbSUVfUFJPVE8kMV0gPSB0cnVlO1xuXG4vLyBgT2JqZWN0LmNyZWF0ZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5jcmVhdGVcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1jcmVhdGUgLS0gc2FmZVxudmFyIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKE8gIT09IG51bGwpIHtcbiAgICBFbXB0eUNvbnN0cnVjdG9yW1BST1RPVFlQRV0gPSBhbk9iamVjdCQ5KE8pO1xuICAgIHJlc3VsdCA9IG5ldyBFbXB0eUNvbnN0cnVjdG9yKCk7XG4gICAgRW1wdHlDb25zdHJ1Y3RvcltQUk9UT1RZUEVdID0gbnVsbDtcbiAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXG4gICAgcmVzdWx0W0lFX1BST1RPJDFdID0gTztcbiAgfSBlbHNlIHJlc3VsdCA9IE51bGxQcm90b09iamVjdCgpO1xuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZGVmaW5lUHJvcGVydGllc01vZHVsZS5mKHJlc3VsdCwgUHJvcGVydGllcyk7XG59O1xuXG52YXIgd2VsbEtub3duU3ltYm9sJGUgPSB3ZWxsS25vd25TeW1ib2wkZztcbnZhciBjcmVhdGUkMSA9IG9iamVjdENyZWF0ZTtcbnZhciBkZWZpbmVQcm9wZXJ0eSQ1ID0gb2JqZWN0RGVmaW5lUHJvcGVydHkuZjtcblxudmFyIFVOU0NPUEFCTEVTID0gd2VsbEtub3duU3ltYm9sJGUoJ3Vuc2NvcGFibGVzJyk7XG52YXIgQXJyYXlQcm90b3R5cGUkMSA9IEFycmF5LnByb3RvdHlwZTtcblxuLy8gQXJyYXkucHJvdG90eXBlW0BAdW5zY29wYWJsZXNdXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQHVuc2NvcGFibGVzXG5pZiAoQXJyYXlQcm90b3R5cGUkMVtVTlNDT1BBQkxFU10gPT0gdW5kZWZpbmVkKSB7XG4gIGRlZmluZVByb3BlcnR5JDUoQXJyYXlQcm90b3R5cGUkMSwgVU5TQ09QQUJMRVMsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgdmFsdWU6IGNyZWF0ZSQxKG51bGwpXG4gIH0pO1xufVxuXG4vLyBhZGQgYSBrZXkgdG8gQXJyYXkucHJvdG90eXBlW0BAdW5zY29wYWJsZXNdXG52YXIgYWRkVG9VbnNjb3BhYmxlcyQyID0gZnVuY3Rpb24gKGtleSkge1xuICBBcnJheVByb3RvdHlwZSQxW1VOU0NPUEFCTEVTXVtrZXldID0gdHJ1ZTtcbn07XG5cbnZhciBpdGVyYXRvcnMgPSB7fTtcblxudmFyIHVuY3VycnlUaGlzJGEgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGlzQ2FsbGFibGUkZiA9IGlzQ2FsbGFibGUkbDtcbnZhciBzdG9yZSQxID0gc2hhcmVkU3RvcmU7XG5cbnZhciBmdW5jdGlvblRvU3RyaW5nID0gdW5jdXJyeVRoaXMkYShGdW5jdGlvbi50b1N0cmluZyk7XG5cbi8vIHRoaXMgaGVscGVyIGJyb2tlbiBpbiBgY29yZS1qc0AzLjQuMS0zLjQuNGAsIHNvIHdlIGNhbid0IHVzZSBgc2hhcmVkYCBoZWxwZXJcbmlmICghaXNDYWxsYWJsZSRmKHN0b3JlJDEuaW5zcGVjdFNvdXJjZSkpIHtcbiAgc3RvcmUkMS5pbnNwZWN0U291cmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uVG9TdHJpbmcoaXQpO1xuICB9O1xufVxuXG52YXIgaW5zcGVjdFNvdXJjZSQ0ID0gc3RvcmUkMS5pbnNwZWN0U291cmNlO1xuXG52YXIgZ2xvYmFsJGQgPSBnbG9iYWwkaztcbnZhciBpc0NhbGxhYmxlJGUgPSBpc0NhbGxhYmxlJGw7XG52YXIgaW5zcGVjdFNvdXJjZSQzID0gaW5zcGVjdFNvdXJjZSQ0O1xuXG52YXIgV2Vha01hcCQxID0gZ2xvYmFsJGQuV2Vha01hcDtcblxudmFyIG5hdGl2ZVdlYWtNYXAgPSBpc0NhbGxhYmxlJGUoV2Vha01hcCQxKSAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoaW5zcGVjdFNvdXJjZSQzKFdlYWtNYXAkMSkpO1xuXG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDQgPSBmdW5jdGlvbiAoYml0bWFwLCB2YWx1ZSkge1xuICByZXR1cm4ge1xuICAgIGVudW1lcmFibGU6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlOiAhKGJpdG1hcCAmIDQpLFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9O1xufTtcblxudmFyIERFU0NSSVBUT1JTJDcgPSBkZXNjcmlwdG9ycztcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQ0ID0gb2JqZWN0RGVmaW5lUHJvcGVydHk7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDMgPSBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkNDtcblxudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ0ID0gREVTQ1JJUFRPUlMkNyA/IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5TW9kdWxlJDQuZihvYmplY3QsIGtleSwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDMoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59O1xuXG52YXIgTkFUSVZFX1dFQUtfTUFQID0gbmF0aXZlV2Vha01hcDtcbnZhciBnbG9iYWwkYyA9IGdsb2JhbCRrO1xudmFyIHVuY3VycnlUaGlzJDkgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGlzT2JqZWN0JDMgPSBpc09iamVjdCQ4O1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQzID0gY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDQ7XG52YXIgaGFzT3duJDkgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIHNoYXJlZCA9IHNoYXJlZFN0b3JlO1xudmFyIHNoYXJlZEtleSQxID0gc2hhcmVkS2V5JDM7XG52YXIgaGlkZGVuS2V5cyQxID0gaGlkZGVuS2V5cyQ0O1xuXG52YXIgT0JKRUNUX0FMUkVBRFlfSU5JVElBTElaRUQgPSAnT2JqZWN0IGFscmVhZHkgaW5pdGlhbGl6ZWQnO1xudmFyIFR5cGVFcnJvciQyID0gZ2xvYmFsJGMuVHlwZUVycm9yO1xudmFyIFdlYWtNYXAgPSBnbG9iYWwkYy5XZWFrTWFwO1xudmFyIHNldCQxLCBnZXQsIGhhcztcblxudmFyIGVuZm9yY2UgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGhhcyhpdCkgPyBnZXQoaXQpIDogc2V0JDEoaXQsIHt9KTtcbn07XG5cbnZhciBnZXR0ZXJGb3IgPSBmdW5jdGlvbiAoVFlQRSkge1xuICByZXR1cm4gZnVuY3Rpb24gKGl0KSB7XG4gICAgdmFyIHN0YXRlO1xuICAgIGlmICghaXNPYmplY3QkMyhpdCkgfHwgKHN0YXRlID0gZ2V0KGl0KSkudHlwZSAhPT0gVFlQRSkge1xuICAgICAgdGhyb3cgVHlwZUVycm9yJDIoJ0luY29tcGF0aWJsZSByZWNlaXZlciwgJyArIFRZUEUgKyAnIHJlcXVpcmVkJyk7XG4gICAgfSByZXR1cm4gc3RhdGU7XG4gIH07XG59O1xuXG5pZiAoTkFUSVZFX1dFQUtfTUFQIHx8IHNoYXJlZC5zdGF0ZSkge1xuICB2YXIgc3RvcmUgPSBzaGFyZWQuc3RhdGUgfHwgKHNoYXJlZC5zdGF0ZSA9IG5ldyBXZWFrTWFwKCkpO1xuICB2YXIgd21nZXQgPSB1bmN1cnJ5VGhpcyQ5KHN0b3JlLmdldCk7XG4gIHZhciB3bWhhcyA9IHVuY3VycnlUaGlzJDkoc3RvcmUuaGFzKTtcbiAgdmFyIHdtc2V0ID0gdW5jdXJyeVRoaXMkOShzdG9yZS5zZXQpO1xuICBzZXQkMSA9IGZ1bmN0aW9uIChpdCwgbWV0YWRhdGEpIHtcbiAgICBpZiAod21oYXMoc3RvcmUsIGl0KSkgdGhyb3cgbmV3IFR5cGVFcnJvciQyKE9CSkVDVF9BTFJFQURZX0lOSVRJQUxJWkVEKTtcbiAgICBtZXRhZGF0YS5mYWNhZGUgPSBpdDtcbiAgICB3bXNldChzdG9yZSwgaXQsIG1ldGFkYXRhKTtcbiAgICByZXR1cm4gbWV0YWRhdGE7XG4gIH07XG4gIGdldCA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiB3bWdldChzdG9yZSwgaXQpIHx8IHt9O1xuICB9O1xuICBoYXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gd21oYXMoc3RvcmUsIGl0KTtcbiAgfTtcbn0gZWxzZSB7XG4gIHZhciBTVEFURSA9IHNoYXJlZEtleSQxKCdzdGF0ZScpO1xuICBoaWRkZW5LZXlzJDFbU1RBVEVdID0gdHJ1ZTtcbiAgc2V0JDEgPSBmdW5jdGlvbiAoaXQsIG1ldGFkYXRhKSB7XG4gICAgaWYgKGhhc093biQ5KGl0LCBTVEFURSkpIHRocm93IG5ldyBUeXBlRXJyb3IkMihPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCk7XG4gICAgbWV0YWRhdGEuZmFjYWRlID0gaXQ7XG4gICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDMoaXQsIFNUQVRFLCBtZXRhZGF0YSk7XG4gICAgcmV0dXJuIG1ldGFkYXRhO1xuICB9O1xuICBnZXQgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gaGFzT3duJDkoaXQsIFNUQVRFKSA/IGl0W1NUQVRFXSA6IHt9O1xuICB9O1xuICBoYXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gaGFzT3duJDkoaXQsIFNUQVRFKTtcbiAgfTtcbn1cblxudmFyIGludGVybmFsU3RhdGUgPSB7XG4gIHNldDogc2V0JDEsXG4gIGdldDogZ2V0LFxuICBoYXM6IGhhcyxcbiAgZW5mb3JjZTogZW5mb3JjZSxcbiAgZ2V0dGVyRm9yOiBnZXR0ZXJGb3Jcbn07XG5cbnZhciBvYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSB7fTtcblxudmFyIG9iamVjdFByb3BlcnR5SXNFbnVtZXJhYmxlID0ge307XG5cbnZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciQyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuLy8gTmFzaG9ybiB+IEpESzggYnVnXG52YXIgTkFTSE9STl9CVUcgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMiAmJiAhJHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoeyAxOiAyIH0sIDEpO1xuXG4vLyBgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZWAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5wcm90b3R5cGUucHJvcGVydHlpc2VudW1lcmFibGVcbm9iamVjdFByb3BlcnR5SXNFbnVtZXJhYmxlLmYgPSBOQVNIT1JOX0JVRyA/IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKFYpIHtcbiAgdmFyIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMih0aGlzLCBWKTtcbiAgcmV0dXJuICEhZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLmVudW1lcmFibGU7XG59IDogJHByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG52YXIgREVTQ1JJUFRPUlMkNiA9IGRlc2NyaXB0b3JzO1xudmFyIGNhbGwkYiA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSQxID0gb2JqZWN0UHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDIgPSBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkNDtcbnZhciB0b0luZGV4ZWRPYmplY3QkMSA9IHRvSW5kZXhlZE9iamVjdCQ1O1xudmFyIHRvUHJvcGVydHlLZXkkMSA9IHRvUHJvcGVydHlLZXkkMztcbnZhciBoYXNPd24kOCA9IGhhc093blByb3BlcnR5XzE7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSBpZThEb21EZWZpbmU7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG4vLyBgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3Jcbm9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvci5mID0gREVTQ1JJUFRPUlMkNiA/ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCkge1xuICBPID0gdG9JbmRleGVkT2JqZWN0JDEoTyk7XG4gIFAgPSB0b1Byb3BlcnR5S2V5JDEoUCk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoaGFzT3duJDgoTywgUCkpIHJldHVybiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkMighY2FsbCRiKHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlJDEuZiwgTywgUCksIE9bUF0pO1xufTtcblxudmFyIG1ha2VCdWlsdEluJDIgPSB7ZXhwb3J0czoge319O1xuXG52YXIgREVTQ1JJUFRPUlMkNSA9IGRlc2NyaXB0b3JzO1xudmFyIGhhc093biQ3ID0gaGFzT3duUHJvcGVydHlfMTtcblxudmFyIEZ1bmN0aW9uUHJvdG90eXBlJDEgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciBnZXREZXNjcmlwdG9yID0gREVTQ1JJUFRPUlMkNSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG52YXIgRVhJU1RTID0gaGFzT3duJDcoRnVuY3Rpb25Qcm90b3R5cGUkMSwgJ25hbWUnKTtcbi8vIGFkZGl0aW9uYWwgcHJvdGVjdGlvbiBmcm9tIG1pbmlmaWVkIC8gbWFuZ2xlZCAvIGRyb3BwZWQgZnVuY3Rpb24gbmFtZXNcbnZhciBQUk9QRVIgPSBFWElTVFMgJiYgKGZ1bmN0aW9uIHNvbWV0aGluZygpIHsgLyogZW1wdHkgKi8gfSkubmFtZSA9PT0gJ3NvbWV0aGluZyc7XG52YXIgQ09ORklHVVJBQkxFID0gRVhJU1RTICYmICghREVTQ1JJUFRPUlMkNSB8fCAoREVTQ1JJUFRPUlMkNSAmJiBnZXREZXNjcmlwdG9yKEZ1bmN0aW9uUHJvdG90eXBlJDEsICduYW1lJykuY29uZmlndXJhYmxlKSk7XG5cbnZhciBmdW5jdGlvbk5hbWUgPSB7XG4gIEVYSVNUUzogRVhJU1RTLFxuICBQUk9QRVI6IFBST1BFUixcbiAgQ09ORklHVVJBQkxFOiBDT05GSUdVUkFCTEVcbn07XG5cbnZhciBmYWlscyRhID0gZmFpbHMkaDtcbnZhciBpc0NhbGxhYmxlJGQgPSBpc0NhbGxhYmxlJGw7XG52YXIgaGFzT3duJDYgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIERFU0NSSVBUT1JTJDQgPSBkZXNjcmlwdG9ycztcbnZhciBDT05GSUdVUkFCTEVfRlVOQ1RJT05fTkFNRSQxID0gZnVuY3Rpb25OYW1lLkNPTkZJR1VSQUJMRTtcbnZhciBpbnNwZWN0U291cmNlJDIgPSBpbnNwZWN0U291cmNlJDQ7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSQyID0gaW50ZXJuYWxTdGF0ZTtcblxudmFyIGVuZm9yY2VJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQyLmVuZm9yY2U7XG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSQxID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQyLmdldDtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSBzYWZlXG52YXIgZGVmaW5lUHJvcGVydHkkNCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxudmFyIENPTkZJR1VSQUJMRV9MRU5HVEggPSBERVNDUklQVE9SUyQ0ICYmICFmYWlscyRhKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5JDQoZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9LCAnbGVuZ3RoJywgeyB2YWx1ZTogOCB9KS5sZW5ndGggIT09IDg7XG59KTtcblxudmFyIFRFTVBMQVRFID0gU3RyaW5nKFN0cmluZykuc3BsaXQoJ1N0cmluZycpO1xuXG52YXIgbWFrZUJ1aWx0SW4kMSA9IG1ha2VCdWlsdEluJDIuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSwgb3B0aW9ucykge1xuICBpZiAoU3RyaW5nKG5hbWUpLnNsaWNlKDAsIDcpID09PSAnU3ltYm9sKCcpIHtcbiAgICBuYW1lID0gJ1snICsgU3RyaW5nKG5hbWUpLnJlcGxhY2UoL15TeW1ib2xcXCgoW14pXSopXFwpLywgJyQxJykgKyAnXSc7XG4gIH1cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5nZXR0ZXIpIG5hbWUgPSAnZ2V0ICcgKyBuYW1lO1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnNldHRlcikgbmFtZSA9ICdzZXQgJyArIG5hbWU7XG4gIGlmICghaGFzT3duJDYodmFsdWUsICduYW1lJykgfHwgKENPTkZJR1VSQUJMRV9GVU5DVElPTl9OQU1FJDEgJiYgdmFsdWUubmFtZSAhPT0gbmFtZSkpIHtcbiAgICBpZiAoREVTQ1JJUFRPUlMkNCkgZGVmaW5lUHJvcGVydHkkNCh2YWx1ZSwgJ25hbWUnLCB7IHZhbHVlOiBuYW1lLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG4gICAgZWxzZSB2YWx1ZS5uYW1lID0gbmFtZTtcbiAgfVxuICBpZiAoQ09ORklHVVJBQkxFX0xFTkdUSCAmJiBvcHRpb25zICYmIGhhc093biQ2KG9wdGlvbnMsICdhcml0eScpICYmIHZhbHVlLmxlbmd0aCAhPT0gb3B0aW9ucy5hcml0eSkge1xuICAgIGRlZmluZVByb3BlcnR5JDQodmFsdWUsICdsZW5ndGgnLCB7IHZhbHVlOiBvcHRpb25zLmFyaXR5IH0pO1xuICB9XG4gIHRyeSB7XG4gICAgaWYgKG9wdGlvbnMgJiYgaGFzT3duJDYob3B0aW9ucywgJ2NvbnN0cnVjdG9yJykgJiYgb3B0aW9ucy5jb25zdHJ1Y3Rvcikge1xuICAgICAgaWYgKERFU0NSSVBUT1JTJDQpIGRlZmluZVByb3BlcnR5JDQodmFsdWUsICdwcm90b3R5cGUnLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTtcbiAgICAvLyBpbiBWOCB+IENocm9tZSA1MywgcHJvdG90eXBlcyBvZiBzb21lIG1ldGhvZHMsIGxpa2UgYEFycmF5LnByb3RvdHlwZS52YWx1ZXNgLCBhcmUgbm9uLXdyaXRhYmxlXG4gICAgfSBlbHNlIGlmICh2YWx1ZS5wcm90b3R5cGUpIHZhbHVlLnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICB2YXIgc3RhdGUgPSBlbmZvcmNlSW50ZXJuYWxTdGF0ZSh2YWx1ZSk7XG4gIGlmICghaGFzT3duJDYoc3RhdGUsICdzb3VyY2UnKSkge1xuICAgIHN0YXRlLnNvdXJjZSA9IFRFTVBMQVRFLmpvaW4odHlwZW9mIG5hbWUgPT0gJ3N0cmluZycgPyBuYW1lIDogJycpO1xuICB9IHJldHVybiB2YWx1ZTtcbn07XG5cbi8vIGFkZCBmYWtlIEZ1bmN0aW9uI3RvU3RyaW5nIGZvciBjb3JyZWN0IHdvcmsgd3JhcHBlZCBtZXRob2RzIC8gY29uc3RydWN0b3JzIHdpdGggbWV0aG9kcyBsaWtlIExvRGFzaCBpc05hdGl2ZVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWV4dGVuZC1uYXRpdmUgLS0gcmVxdWlyZWRcbkZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IG1ha2VCdWlsdEluJDEoZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiBpc0NhbGxhYmxlJGQodGhpcykgJiYgZ2V0SW50ZXJuYWxTdGF0ZSQxKHRoaXMpLnNvdXJjZSB8fCBpbnNwZWN0U291cmNlJDIodGhpcyk7XG59LCAndG9TdHJpbmcnKTtcblxudmFyIGlzQ2FsbGFibGUkYyA9IGlzQ2FsbGFibGUkbDtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQzID0gb2JqZWN0RGVmaW5lUHJvcGVydHk7XG52YXIgbWFrZUJ1aWx0SW4gPSBtYWtlQnVpbHRJbiQyLmV4cG9ydHM7XG52YXIgZGVmaW5lR2xvYmFsUHJvcGVydHkkMSA9IGRlZmluZUdsb2JhbFByb3BlcnR5JDM7XG5cbnZhciBkZWZpbmVCdWlsdEluJDYgPSBmdW5jdGlvbiAoTywga2V5LCB2YWx1ZSwgb3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcbiAgdmFyIHNpbXBsZSA9IG9wdGlvbnMuZW51bWVyYWJsZTtcbiAgdmFyIG5hbWUgPSBvcHRpb25zLm5hbWUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubmFtZSA6IGtleTtcbiAgaWYgKGlzQ2FsbGFibGUkYyh2YWx1ZSkpIG1ha2VCdWlsdEluKHZhbHVlLCBuYW1lLCBvcHRpb25zKTtcbiAgaWYgKG9wdGlvbnMuZ2xvYmFsKSB7XG4gICAgaWYgKHNpbXBsZSkgT1trZXldID0gdmFsdWU7XG4gICAgZWxzZSBkZWZpbmVHbG9iYWxQcm9wZXJ0eSQxKGtleSwgdmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIW9wdGlvbnMudW5zYWZlKSBkZWxldGUgT1trZXldO1xuICAgICAgZWxzZSBpZiAoT1trZXldKSBzaW1wbGUgPSB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgICBpZiAoc2ltcGxlKSBPW2tleV0gPSB2YWx1ZTtcbiAgICBlbHNlIGRlZmluZVByb3BlcnR5TW9kdWxlJDMuZihPLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiAhb3B0aW9ucy5ub25Db25maWd1cmFibGUsXG4gICAgICB3cml0YWJsZTogIW9wdGlvbnMubm9uV3JpdGFibGVcbiAgICB9KTtcbiAgfSByZXR1cm4gTztcbn07XG5cbnZhciBvYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzID0ge307XG5cbnZhciBpbnRlcm5hbE9iamVjdEtleXMgPSBvYmplY3RLZXlzSW50ZXJuYWw7XG52YXIgZW51bUJ1Z0tleXMgPSBlbnVtQnVnS2V5cyQzO1xuXG52YXIgaGlkZGVuS2V5cyA9IGVudW1CdWdLZXlzLmNvbmNhdCgnbGVuZ3RoJywgJ3Byb3RvdHlwZScpO1xuXG4vLyBgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHluYW1lc1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5bmFtZXMgLS0gc2FmZVxub2JqZWN0R2V0T3duUHJvcGVydHlOYW1lcy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKSB7XG4gIHJldHVybiBpbnRlcm5hbE9iamVjdEtleXMoTywgaGlkZGVuS2V5cyk7XG59O1xuXG52YXIgb2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzID0ge307XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eXN5bWJvbHMgLS0gc2FmZVxub2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG52YXIgZ2V0QnVpbHRJbiQ0ID0gZ2V0QnVpbHRJbiQ4O1xudmFyIHVuY3VycnlUaGlzJDggPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSQxID0gb2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGFuT2JqZWN0JDggPSBhbk9iamVjdCRjO1xuXG52YXIgY29uY2F0JDEgPSB1bmN1cnJ5VGhpcyQ4KFtdLmNvbmNhdCk7XG5cbi8vIGFsbCBvYmplY3Qga2V5cywgaW5jbHVkZXMgbm9uLWVudW1lcmFibGUgYW5kIHN5bWJvbHNcbnZhciBvd25LZXlzJDEgPSBnZXRCdWlsdEluJDQoJ1JlZmxlY3QnLCAnb3duS2V5cycpIHx8IGZ1bmN0aW9uIG93bktleXMoaXQpIHtcbiAgdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlLmYoYW5PYmplY3QkOChpdCkpO1xuICB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlJDEuZjtcbiAgcmV0dXJuIGdldE93blByb3BlcnR5U3ltYm9scyA/IGNvbmNhdCQxKGtleXMsIGdldE93blByb3BlcnR5U3ltYm9scyhpdCkpIDoga2V5cztcbn07XG5cbnZhciBoYXNPd24kNSA9IGhhc093blByb3BlcnR5XzE7XG52YXIgb3duS2V5cyA9IG93bktleXMkMTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUkMiA9IG9iamVjdERlZmluZVByb3BlcnR5O1xuXG52YXIgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyQyID0gZnVuY3Rpb24gKHRhcmdldCwgc291cmNlLCBleGNlcHRpb25zKSB7XG4gIHZhciBrZXlzID0gb3duS2V5cyhzb3VyY2UpO1xuICB2YXIgZGVmaW5lUHJvcGVydHkgPSBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQyLmY7XG4gIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUuZjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgaWYgKCFoYXNPd24kNSh0YXJnZXQsIGtleSkgJiYgIShleGNlcHRpb25zICYmIGhhc093biQ1KGV4Y2VwdGlvbnMsIGtleSkpKSB7XG4gICAgICBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgZmFpbHMkOSA9IGZhaWxzJGg7XG52YXIgaXNDYWxsYWJsZSRiID0gaXNDYWxsYWJsZSRsO1xuXG52YXIgcmVwbGFjZW1lbnQgPSAvI3xcXC5wcm90b3R5cGVcXC4vO1xuXG52YXIgaXNGb3JjZWQkMiA9IGZ1bmN0aW9uIChmZWF0dXJlLCBkZXRlY3Rpb24pIHtcbiAgdmFyIHZhbHVlID0gZGF0YVtub3JtYWxpemUoZmVhdHVyZSldO1xuICByZXR1cm4gdmFsdWUgPT0gUE9MWUZJTEwgPyB0cnVlXG4gICAgOiB2YWx1ZSA9PSBOQVRJVkUgPyBmYWxzZVxuICAgIDogaXNDYWxsYWJsZSRiKGRldGVjdGlvbikgPyBmYWlscyQ5KGRldGVjdGlvbilcbiAgICA6ICEhZGV0ZWN0aW9uO1xufTtcblxudmFyIG5vcm1hbGl6ZSA9IGlzRm9yY2VkJDIubm9ybWFsaXplID0gZnVuY3Rpb24gKHN0cmluZykge1xuICByZXR1cm4gU3RyaW5nKHN0cmluZykucmVwbGFjZShyZXBsYWNlbWVudCwgJy4nKS50b0xvd2VyQ2FzZSgpO1xufTtcblxudmFyIGRhdGEgPSBpc0ZvcmNlZCQyLmRhdGEgPSB7fTtcbnZhciBOQVRJVkUgPSBpc0ZvcmNlZCQyLk5BVElWRSA9ICdOJztcbnZhciBQT0xZRklMTCA9IGlzRm9yY2VkJDIuUE9MWUZJTEwgPSAnUCc7XG5cbnZhciBpc0ZvcmNlZF8xID0gaXNGb3JjZWQkMjtcblxudmFyIGdsb2JhbCRiID0gZ2xvYmFsJGs7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IuZjtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMiA9IGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ0O1xudmFyIGRlZmluZUJ1aWx0SW4kNSA9IGRlZmluZUJ1aWx0SW4kNjtcbnZhciBkZWZpbmVHbG9iYWxQcm9wZXJ0eSA9IGRlZmluZUdsb2JhbFByb3BlcnR5JDM7XG52YXIgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyQxID0gY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyQyO1xudmFyIGlzRm9yY2VkJDEgPSBpc0ZvcmNlZF8xO1xuXG4vKlxuICBvcHRpb25zLnRhcmdldCAgICAgICAgIC0gbmFtZSBvZiB0aGUgdGFyZ2V0IG9iamVjdFxuICBvcHRpb25zLmdsb2JhbCAgICAgICAgIC0gdGFyZ2V0IGlzIHRoZSBnbG9iYWwgb2JqZWN0XG4gIG9wdGlvbnMuc3RhdCAgICAgICAgICAgLSBleHBvcnQgYXMgc3RhdGljIG1ldGhvZHMgb2YgdGFyZ2V0XG4gIG9wdGlvbnMucHJvdG8gICAgICAgICAgLSBleHBvcnQgYXMgcHJvdG90eXBlIG1ldGhvZHMgb2YgdGFyZ2V0XG4gIG9wdGlvbnMucmVhbCAgICAgICAgICAgLSByZWFsIHByb3RvdHlwZSBtZXRob2QgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuICBvcHRpb25zLmZvcmNlZCAgICAgICAgIC0gZXhwb3J0IGV2ZW4gaWYgdGhlIG5hdGl2ZSBmZWF0dXJlIGlzIGF2YWlsYWJsZVxuICBvcHRpb25zLmJpbmQgICAgICAgICAgIC0gYmluZCBtZXRob2RzIHRvIHRoZSB0YXJnZXQsIHJlcXVpcmVkIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cbiAgb3B0aW9ucy53cmFwICAgICAgICAgICAtIHdyYXAgY29uc3RydWN0b3JzIHRvIHByZXZlbnRpbmcgZ2xvYmFsIHBvbGx1dGlvbiwgcmVxdWlyZWQgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuICBvcHRpb25zLnVuc2FmZSAgICAgICAgIC0gdXNlIHRoZSBzaW1wbGUgYXNzaWdubWVudCBvZiBwcm9wZXJ0eSBpbnN0ZWFkIG9mIGRlbGV0ZSArIGRlZmluZVByb3BlcnR5XG4gIG9wdGlvbnMuc2hhbSAgICAgICAgICAgLSBhZGQgYSBmbGFnIHRvIG5vdCBjb21wbGV0ZWx5IGZ1bGwgcG9seWZpbGxzXG4gIG9wdGlvbnMuZW51bWVyYWJsZSAgICAgLSBleHBvcnQgYXMgZW51bWVyYWJsZSBwcm9wZXJ0eVxuICBvcHRpb25zLmRvbnRDYWxsR2V0U2V0IC0gcHJldmVudCBjYWxsaW5nIGEgZ2V0dGVyIG9uIHRhcmdldFxuICBvcHRpb25zLm5hbWUgICAgICAgICAgIC0gdGhlIC5uYW1lIG9mIHRoZSBmdW5jdGlvbiBpZiBpdCBkb2VzIG5vdCBtYXRjaCB0aGUga2V5XG4qL1xudmFyIF9leHBvcnQgPSBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XG4gIHZhciBUQVJHRVQgPSBvcHRpb25zLnRhcmdldDtcbiAgdmFyIEdMT0JBTCA9IG9wdGlvbnMuZ2xvYmFsO1xuICB2YXIgU1RBVElDID0gb3B0aW9ucy5zdGF0O1xuICB2YXIgRk9SQ0VELCB0YXJnZXQsIGtleSwgdGFyZ2V0UHJvcGVydHksIHNvdXJjZVByb3BlcnR5LCBkZXNjcmlwdG9yO1xuICBpZiAoR0xPQkFMKSB7XG4gICAgdGFyZ2V0ID0gZ2xvYmFsJGI7XG4gIH0gZWxzZSBpZiAoU1RBVElDKSB7XG4gICAgdGFyZ2V0ID0gZ2xvYmFsJGJbVEFSR0VUXSB8fCBkZWZpbmVHbG9iYWxQcm9wZXJ0eShUQVJHRVQsIHt9KTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQgPSAoZ2xvYmFsJGJbVEFSR0VUXSB8fCB7fSkucHJvdG90eXBlO1xuICB9XG4gIGlmICh0YXJnZXQpIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgIHNvdXJjZVByb3BlcnR5ID0gc291cmNlW2tleV07XG4gICAgaWYgKG9wdGlvbnMuZG9udENhbGxHZXRTZXQpIHtcbiAgICAgIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMSh0YXJnZXQsIGtleSk7XG4gICAgICB0YXJnZXRQcm9wZXJ0eSA9IGRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci52YWx1ZTtcbiAgICB9IGVsc2UgdGFyZ2V0UHJvcGVydHkgPSB0YXJnZXRba2V5XTtcbiAgICBGT1JDRUQgPSBpc0ZvcmNlZCQxKEdMT0JBTCA/IGtleSA6IFRBUkdFVCArIChTVEFUSUMgPyAnLicgOiAnIycpICsga2V5LCBvcHRpb25zLmZvcmNlZCk7XG4gICAgLy8gY29udGFpbmVkIGluIHRhcmdldFxuICAgIGlmICghRk9SQ0VEICYmIHRhcmdldFByb3BlcnR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0eXBlb2Ygc291cmNlUHJvcGVydHkgPT0gdHlwZW9mIHRhcmdldFByb3BlcnR5KSBjb250aW51ZTtcbiAgICAgIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMkMShzb3VyY2VQcm9wZXJ0eSwgdGFyZ2V0UHJvcGVydHkpO1xuICAgIH1cbiAgICAvLyBhZGQgYSBmbGFnIHRvIG5vdCBjb21wbGV0ZWx5IGZ1bGwgcG9seWZpbGxzXG4gICAgaWYgKG9wdGlvbnMuc2hhbSB8fCAodGFyZ2V0UHJvcGVydHkgJiYgdGFyZ2V0UHJvcGVydHkuc2hhbSkpIHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQyKHNvdXJjZVByb3BlcnR5LCAnc2hhbScsIHRydWUpO1xuICAgIH1cbiAgICBkZWZpbmVCdWlsdEluJDUodGFyZ2V0LCBrZXksIHNvdXJjZVByb3BlcnR5LCBvcHRpb25zKTtcbiAgfVxufTtcblxudmFyIGZhaWxzJDggPSBmYWlscyRoO1xuXG52YXIgY29ycmVjdFByb3RvdHlwZUdldHRlciA9ICFmYWlscyQ4KGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRigpIHsgLyogZW1wdHkgKi8gfVxuICBGLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IG51bGw7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRwcm90b3R5cGVvZiAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKG5ldyBGKCkpICE9PSBGLnByb3RvdHlwZTtcbn0pO1xuXG52YXIgaGFzT3duJDQgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIGlzQ2FsbGFibGUkYSA9IGlzQ2FsbGFibGUkbDtcbnZhciB0b09iamVjdCQzID0gdG9PYmplY3QkNTtcbnZhciBzaGFyZWRLZXkgPSBzaGFyZWRLZXkkMztcbnZhciBDT1JSRUNUX1BST1RPVFlQRV9HRVRURVIgPSBjb3JyZWN0UHJvdG90eXBlR2V0dGVyO1xuXG52YXIgSUVfUFJPVE8gPSBzaGFyZWRLZXkoJ0lFX1BST1RPJyk7XG52YXIgJE9iamVjdCQxID0gT2JqZWN0O1xudmFyIE9iamVjdFByb3RvdHlwZSA9ICRPYmplY3QkMS5wcm90b3R5cGU7XG5cbi8vIGBPYmplY3QuZ2V0UHJvdG90eXBlT2ZgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0cHJvdG90eXBlb2Zcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRwcm90b3R5cGVvZiAtLSBzYWZlXG52YXIgb2JqZWN0R2V0UHJvdG90eXBlT2YgPSBDT1JSRUNUX1BST1RPVFlQRV9HRVRURVIgPyAkT2JqZWN0JDEuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiAoTykge1xuICB2YXIgb2JqZWN0ID0gdG9PYmplY3QkMyhPKTtcbiAgaWYgKGhhc093biQ0KG9iamVjdCwgSUVfUFJPVE8pKSByZXR1cm4gb2JqZWN0W0lFX1BST1RPXTtcbiAgdmFyIGNvbnN0cnVjdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuICBpZiAoaXNDYWxsYWJsZSRhKGNvbnN0cnVjdG9yKSAmJiBvYmplY3QgaW5zdGFuY2VvZiBjb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBjb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIH0gcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mICRPYmplY3QkMSA/IE9iamVjdFByb3RvdHlwZSA6IG51bGw7XG59O1xuXG52YXIgZmFpbHMkNyA9IGZhaWxzJGg7XG52YXIgaXNDYWxsYWJsZSQ5ID0gaXNDYWxsYWJsZSRsO1xudmFyIGdldFByb3RvdHlwZU9mJDEgPSBvYmplY3RHZXRQcm90b3R5cGVPZjtcbnZhciBkZWZpbmVCdWlsdEluJDQgPSBkZWZpbmVCdWlsdEluJDY7XG52YXIgd2VsbEtub3duU3ltYm9sJGQgPSB3ZWxsS25vd25TeW1ib2wkZztcblxudmFyIElURVJBVE9SJDUgPSB3ZWxsS25vd25TeW1ib2wkZCgnaXRlcmF0b3InKTtcbnZhciBCVUdHWV9TQUZBUklfSVRFUkFUT1JTJDEgPSBmYWxzZTtcblxuLy8gYCVJdGVyYXRvclByb3RvdHlwZSVgIG9iamVjdFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0laXRlcmF0b3Jwcm90b3R5cGUlLW9iamVjdFxudmFyIEl0ZXJhdG9yUHJvdG90eXBlJDIsIFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZSwgYXJyYXlJdGVyYXRvcjtcblxuLyogZXNsaW50LWRpc2FibGUgZXMteC9uby1hcnJheS1wcm90b3R5cGUta2V5cyAtLSBzYWZlICovXG5pZiAoW10ua2V5cykge1xuICBhcnJheUl0ZXJhdG9yID0gW10ua2V5cygpO1xuICAvLyBTYWZhcmkgOCBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbiAgaWYgKCEoJ25leHQnIGluIGFycmF5SXRlcmF0b3IpKSBCVUdHWV9TQUZBUklfSVRFUkFUT1JTJDEgPSB0cnVlO1xuICBlbHNlIHtcbiAgICBQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZiQxKGdldFByb3RvdHlwZU9mJDEoYXJyYXlJdGVyYXRvcikpO1xuICAgIGlmIChQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUpIEl0ZXJhdG9yUHJvdG90eXBlJDIgPSBQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cbn1cblxudmFyIE5FV19JVEVSQVRPUl9QUk9UT1RZUEUgPSBJdGVyYXRvclByb3RvdHlwZSQyID09IHVuZGVmaW5lZCB8fCBmYWlscyQ3KGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRlc3QgPSB7fTtcbiAgLy8gRkY0NC0gbGVnYWN5IGl0ZXJhdG9ycyBjYXNlXG4gIHJldHVybiBJdGVyYXRvclByb3RvdHlwZSQyW0lURVJBVE9SJDVdLmNhbGwodGVzdCkgIT09IHRlc3Q7XG59KTtcblxuaWYgKE5FV19JVEVSQVRPUl9QUk9UT1RZUEUpIEl0ZXJhdG9yUHJvdG90eXBlJDIgPSB7fTtcblxuLy8gYCVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSVpdGVyYXRvcnByb3RvdHlwZSUtQEBpdGVyYXRvclxuaWYgKCFpc0NhbGxhYmxlJDkoSXRlcmF0b3JQcm90b3R5cGUkMltJVEVSQVRPUiQ1XSkpIHtcbiAgZGVmaW5lQnVpbHRJbiQ0KEl0ZXJhdG9yUHJvdG90eXBlJDIsIElURVJBVE9SJDUsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG59XG5cbnZhciBpdGVyYXRvcnNDb3JlID0ge1xuICBJdGVyYXRvclByb3RvdHlwZTogSXRlcmF0b3JQcm90b3R5cGUkMixcbiAgQlVHR1lfU0FGQVJJX0lURVJBVE9SUzogQlVHR1lfU0FGQVJJX0lURVJBVE9SUyQxXG59O1xuXG52YXIgZGVmaW5lUHJvcGVydHkkMyA9IG9iamVjdERlZmluZVByb3BlcnR5LmY7XG52YXIgaGFzT3duJDMgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIHdlbGxLbm93blN5bWJvbCRjID0gd2VsbEtub3duU3ltYm9sJGc7XG5cbnZhciBUT19TVFJJTkdfVEFHJDMgPSB3ZWxsS25vd25TeW1ib2wkYygndG9TdHJpbmdUYWcnKTtcblxudmFyIHNldFRvU3RyaW5nVGFnJDMgPSBmdW5jdGlvbiAodGFyZ2V0LCBUQUcsIFNUQVRJQykge1xuICBpZiAodGFyZ2V0ICYmICFTVEFUSUMpIHRhcmdldCA9IHRhcmdldC5wcm90b3R5cGU7XG4gIGlmICh0YXJnZXQgJiYgIWhhc093biQzKHRhcmdldCwgVE9fU1RSSU5HX1RBRyQzKSkge1xuICAgIGRlZmluZVByb3BlcnR5JDModGFyZ2V0LCBUT19TVFJJTkdfVEFHJDMsIHsgY29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogVEFHIH0pO1xuICB9XG59O1xuXG52YXIgSXRlcmF0b3JQcm90b3R5cGUkMSA9IGl0ZXJhdG9yc0NvcmUuSXRlcmF0b3JQcm90b3R5cGU7XG52YXIgY3JlYXRlID0gb2JqZWN0Q3JlYXRlO1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQxID0gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDQ7XG52YXIgc2V0VG9TdHJpbmdUYWckMiA9IHNldFRvU3RyaW5nVGFnJDM7XG52YXIgSXRlcmF0b3JzJDQgPSBpdGVyYXRvcnM7XG5cbnZhciByZXR1cm5UaGlzJDEgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuXG52YXIgY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvciQxID0gZnVuY3Rpb24gKEl0ZXJhdG9yQ29uc3RydWN0b3IsIE5BTUUsIG5leHQsIEVOVU1FUkFCTEVfTkVYVCkge1xuICB2YXIgVE9fU1RSSU5HX1RBRyA9IE5BTUUgKyAnIEl0ZXJhdG9yJztcbiAgSXRlcmF0b3JDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUkMSwgeyBuZXh0OiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkMSgrIUVOVU1FUkFCTEVfTkVYVCwgbmV4dCkgfSk7XG4gIHNldFRvU3RyaW5nVGFnJDIoSXRlcmF0b3JDb25zdHJ1Y3RvciwgVE9fU1RSSU5HX1RBRywgZmFsc2UpO1xuICBJdGVyYXRvcnMkNFtUT19TVFJJTkdfVEFHXSA9IHJldHVyblRoaXMkMTtcbiAgcmV0dXJuIEl0ZXJhdG9yQ29uc3RydWN0b3I7XG59O1xuXG52YXIgaXNDYWxsYWJsZSQ4ID0gaXNDYWxsYWJsZSRsO1xuXG52YXIgJFN0cmluZyQxID0gU3RyaW5nO1xudmFyICRUeXBlRXJyb3IkOCA9IFR5cGVFcnJvcjtcblxudmFyIGFQb3NzaWJsZVByb3RvdHlwZSQxID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmICh0eXBlb2YgYXJndW1lbnQgPT0gJ29iamVjdCcgfHwgaXNDYWxsYWJsZSQ4KGFyZ3VtZW50KSkgcmV0dXJuIGFyZ3VtZW50O1xuICB0aHJvdyAkVHlwZUVycm9yJDgoXCJDYW4ndCBzZXQgXCIgKyAkU3RyaW5nJDEoYXJndW1lbnQpICsgJyBhcyBhIHByb3RvdHlwZScpO1xufTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gLS0gc2FmZSAqL1xuXG52YXIgdW5jdXJyeVRoaXMkNyA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgYW5PYmplY3QkNyA9IGFuT2JqZWN0JGM7XG52YXIgYVBvc3NpYmxlUHJvdG90eXBlID0gYVBvc3NpYmxlUHJvdG90eXBlJDE7XG5cbi8vIGBPYmplY3Quc2V0UHJvdG90eXBlT2ZgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3Quc2V0cHJvdG90eXBlb2Zcbi8vIFdvcmtzIHdpdGggX19wcm90b19fIG9ubHkuIE9sZCB2OCBjYW4ndCB3b3JrIHdpdGggbnVsbCBwcm90byBvYmplY3RzLlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LXNldHByb3RvdHlwZW9mIC0tIHNhZmVcbnZhciBvYmplY3RTZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCAoJ19fcHJvdG9fXycgaW4ge30gPyBmdW5jdGlvbiAoKSB7XG4gIHZhciBDT1JSRUNUX1NFVFRFUiA9IGZhbHNlO1xuICB2YXIgdGVzdCA9IHt9O1xuICB2YXIgc2V0dGVyO1xuICB0cnkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxuICAgIHNldHRlciA9IHVuY3VycnlUaGlzJDcoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPYmplY3QucHJvdG90eXBlLCAnX19wcm90b19fJykuc2V0KTtcbiAgICBzZXR0ZXIodGVzdCwgW10pO1xuICAgIENPUlJFQ1RfU0VUVEVSID0gdGVzdCBpbnN0YW5jZW9mIEFycmF5O1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihPLCBwcm90bykge1xuICAgIGFuT2JqZWN0JDcoTyk7XG4gICAgYVBvc3NpYmxlUHJvdG90eXBlKHByb3RvKTtcbiAgICBpZiAoQ09SUkVDVF9TRVRURVIpIHNldHRlcihPLCBwcm90byk7XG4gICAgZWxzZSBPLl9fcHJvdG9fXyA9IHByb3RvO1xuICAgIHJldHVybiBPO1xuICB9O1xufSgpIDogdW5kZWZpbmVkKTtcblxudmFyICQkYyA9IF9leHBvcnQ7XG52YXIgY2FsbCRhID0gZnVuY3Rpb25DYWxsO1xudmFyIEZ1bmN0aW9uTmFtZSA9IGZ1bmN0aW9uTmFtZTtcbnZhciBpc0NhbGxhYmxlJDcgPSBpc0NhbGxhYmxlJGw7XG52YXIgY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvciA9IGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IkMTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IG9iamVjdEdldFByb3RvdHlwZU9mO1xudmFyIHNldFByb3RvdHlwZU9mJDEgPSBvYmplY3RTZXRQcm90b3R5cGVPZjtcbnZhciBzZXRUb1N0cmluZ1RhZyQxID0gc2V0VG9TdHJpbmdUYWckMztcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMSA9IGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ0O1xudmFyIGRlZmluZUJ1aWx0SW4kMyA9IGRlZmluZUJ1aWx0SW4kNjtcbnZhciB3ZWxsS25vd25TeW1ib2wkYiA9IHdlbGxLbm93blN5bWJvbCRnO1xudmFyIEl0ZXJhdG9ycyQzID0gaXRlcmF0b3JzO1xudmFyIEl0ZXJhdG9yc0NvcmUgPSBpdGVyYXRvcnNDb3JlO1xuXG52YXIgUFJPUEVSX0ZVTkNUSU9OX05BTUUkMSA9IEZ1bmN0aW9uTmFtZS5QUk9QRVI7XG52YXIgQ09ORklHVVJBQkxFX0ZVTkNUSU9OX05BTUUgPSBGdW5jdGlvbk5hbWUuQ09ORklHVVJBQkxFO1xudmFyIEl0ZXJhdG9yUHJvdG90eXBlID0gSXRlcmF0b3JzQ29yZS5JdGVyYXRvclByb3RvdHlwZTtcbnZhciBCVUdHWV9TQUZBUklfSVRFUkFUT1JTID0gSXRlcmF0b3JzQ29yZS5CVUdHWV9TQUZBUklfSVRFUkFUT1JTO1xudmFyIElURVJBVE9SJDQgPSB3ZWxsS25vd25TeW1ib2wkYignaXRlcmF0b3InKTtcbnZhciBLRVlTID0gJ2tleXMnO1xudmFyIFZBTFVFUyA9ICd2YWx1ZXMnO1xudmFyIEVOVFJJRVMgPSAnZW50cmllcyc7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxudmFyIGRlZmluZUl0ZXJhdG9yJDEgPSBmdW5jdGlvbiAoSXRlcmFibGUsIE5BTUUsIEl0ZXJhdG9yQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKSB7XG4gIGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IoSXRlcmF0b3JDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG5cbiAgdmFyIGdldEl0ZXJhdGlvbk1ldGhvZCA9IGZ1bmN0aW9uIChLSU5EKSB7XG4gICAgaWYgKEtJTkQgPT09IERFRkFVTFQgJiYgZGVmYXVsdEl0ZXJhdG9yKSByZXR1cm4gZGVmYXVsdEl0ZXJhdG9yO1xuICAgIGlmICghQlVHR1lfU0FGQVJJX0lURVJBVE9SUyAmJiBLSU5EIGluIEl0ZXJhYmxlUHJvdG90eXBlKSByZXR1cm4gSXRlcmFibGVQcm90b3R5cGVbS0lORF07XG4gICAgc3dpdGNoIChLSU5EKSB7XG4gICAgICBjYXNlIEtFWVM6IHJldHVybiBmdW5jdGlvbiBrZXlzKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcywgS0lORCk7IH07XG4gICAgICBjYXNlIFZBTFVFUzogcmV0dXJuIGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMsIEtJTkQpOyB9O1xuICAgICAgY2FzZSBFTlRSSUVTOiByZXR1cm4gZnVuY3Rpb24gZW50cmllcygpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMsIEtJTkQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMpOyB9O1xuICB9O1xuXG4gIHZhciBUT19TVFJJTkdfVEFHID0gTkFNRSArICcgSXRlcmF0b3InO1xuICB2YXIgSU5DT1JSRUNUX1ZBTFVFU19OQU1FID0gZmFsc2U7XG4gIHZhciBJdGVyYWJsZVByb3RvdHlwZSA9IEl0ZXJhYmxlLnByb3RvdHlwZTtcbiAgdmFyIG5hdGl2ZUl0ZXJhdG9yID0gSXRlcmFibGVQcm90b3R5cGVbSVRFUkFUT1IkNF1cbiAgICB8fCBJdGVyYWJsZVByb3RvdHlwZVsnQEBpdGVyYXRvciddXG4gICAgfHwgREVGQVVMVCAmJiBJdGVyYWJsZVByb3RvdHlwZVtERUZBVUxUXTtcbiAgdmFyIGRlZmF1bHRJdGVyYXRvciA9ICFCVUdHWV9TQUZBUklfSVRFUkFUT1JTICYmIG5hdGl2ZUl0ZXJhdG9yIHx8IGdldEl0ZXJhdGlvbk1ldGhvZChERUZBVUxUKTtcbiAgdmFyIGFueU5hdGl2ZUl0ZXJhdG9yID0gTkFNRSA9PSAnQXJyYXknID8gSXRlcmFibGVQcm90b3R5cGUuZW50cmllcyB8fCBuYXRpdmVJdGVyYXRvciA6IG5hdGl2ZUl0ZXJhdG9yO1xuICB2YXIgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBtZXRob2RzLCBLRVk7XG5cbiAgLy8gZml4IG5hdGl2ZVxuICBpZiAoYW55TmF0aXZlSXRlcmF0b3IpIHtcbiAgICBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZihhbnlOYXRpdmVJdGVyYXRvci5jYWxsKG5ldyBJdGVyYWJsZSgpKSk7XG4gICAgaWYgKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSAmJiBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUubmV4dCkge1xuICAgICAgaWYgKGdldFByb3RvdHlwZU9mKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSkgIT09IEl0ZXJhdG9yUHJvdG90eXBlKSB7XG4gICAgICAgIGlmIChzZXRQcm90b3R5cGVPZiQxKSB7XG4gICAgICAgICAgc2V0UHJvdG90eXBlT2YkMShDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUsIEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgICAgICAgfSBlbHNlIGlmICghaXNDYWxsYWJsZSQ3KEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZVtJVEVSQVRPUiQ0XSkpIHtcbiAgICAgICAgICBkZWZpbmVCdWlsdEluJDMoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiQ0LCByZXR1cm5UaGlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9yc1xuICAgICAgc2V0VG9TdHJpbmdUYWckMShDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUsIFRPX1NUUklOR19UQUcsIHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGZpeCBBcnJheS5wcm90b3R5cGUueyB2YWx1ZXMsIEBAaXRlcmF0b3IgfS5uYW1lIGluIFY4IC8gRkZcbiAgaWYgKFBST1BFUl9GVU5DVElPTl9OQU1FJDEgJiYgREVGQVVMVCA9PSBWQUxVRVMgJiYgbmF0aXZlSXRlcmF0b3IgJiYgbmF0aXZlSXRlcmF0b3IubmFtZSAhPT0gVkFMVUVTKSB7XG4gICAgaWYgKENPTkZJR1VSQUJMRV9GVU5DVElPTl9OQU1FKSB7XG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMShJdGVyYWJsZVByb3RvdHlwZSwgJ25hbWUnLCBWQUxVRVMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgPSB0cnVlO1xuICAgICAgZGVmYXVsdEl0ZXJhdG9yID0gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gY2FsbCRhKG5hdGl2ZUl0ZXJhdG9yLCB0aGlzKTsgfTtcbiAgICB9XG4gIH1cblxuICAvLyBleHBvcnQgYWRkaXRpb25hbCBtZXRob2RzXG4gIGlmIChERUZBVUxUKSB7XG4gICAgbWV0aG9kcyA9IHtcbiAgICAgIHZhbHVlczogZ2V0SXRlcmF0aW9uTWV0aG9kKFZBTFVFUyksXG4gICAgICBrZXlzOiBJU19TRVQgPyBkZWZhdWx0SXRlcmF0b3IgOiBnZXRJdGVyYXRpb25NZXRob2QoS0VZUyksXG4gICAgICBlbnRyaWVzOiBnZXRJdGVyYXRpb25NZXRob2QoRU5UUklFUylcbiAgICB9O1xuICAgIGlmIChGT1JDRUQpIGZvciAoS0VZIGluIG1ldGhvZHMpIHtcbiAgICAgIGlmIChCVUdHWV9TQUZBUklfSVRFUkFUT1JTIHx8IElOQ09SUkVDVF9WQUxVRVNfTkFNRSB8fCAhKEtFWSBpbiBJdGVyYWJsZVByb3RvdHlwZSkpIHtcbiAgICAgICAgZGVmaW5lQnVpbHRJbiQzKEl0ZXJhYmxlUHJvdG90eXBlLCBLRVksIG1ldGhvZHNbS0VZXSk7XG4gICAgICB9XG4gICAgfSBlbHNlICQkYyh7IHRhcmdldDogTkFNRSwgcHJvdG86IHRydWUsIGZvcmNlZDogQlVHR1lfU0FGQVJJX0lURVJBVE9SUyB8fCBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgfSwgbWV0aG9kcyk7XG4gIH1cblxuICAvLyBkZWZpbmUgaXRlcmF0b3JcbiAgaWYgKEl0ZXJhYmxlUHJvdG90eXBlW0lURVJBVE9SJDRdICE9PSBkZWZhdWx0SXRlcmF0b3IpIHtcbiAgICBkZWZpbmVCdWlsdEluJDMoSXRlcmFibGVQcm90b3R5cGUsIElURVJBVE9SJDQsIGRlZmF1bHRJdGVyYXRvciwgeyBuYW1lOiBERUZBVUxUIH0pO1xuICB9XG4gIEl0ZXJhdG9ycyQzW05BTUVdID0gZGVmYXVsdEl0ZXJhdG9yO1xuXG4gIHJldHVybiBtZXRob2RzO1xufTtcblxudmFyIHRvSW5kZXhlZE9iamVjdCA9IHRvSW5kZXhlZE9iamVjdCQ1O1xudmFyIGFkZFRvVW5zY29wYWJsZXMkMSA9IGFkZFRvVW5zY29wYWJsZXMkMjtcbnZhciBJdGVyYXRvcnMkMiA9IGl0ZXJhdG9ycztcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlJDEgPSBpbnRlcm5hbFN0YXRlO1xudmFyIGRlZmluZVByb3BlcnR5JDIgPSBvYmplY3REZWZpbmVQcm9wZXJ0eS5mO1xudmFyIGRlZmluZUl0ZXJhdG9yID0gZGVmaW5lSXRlcmF0b3IkMTtcbnZhciBERVNDUklQVE9SUyQzID0gZGVzY3JpcHRvcnM7XG5cbnZhciBBUlJBWV9JVEVSQVRPUiA9ICdBcnJheSBJdGVyYXRvcic7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSQxID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQxLnNldDtcbnZhciBnZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQxLmdldHRlckZvcihBUlJBWV9JVEVSQVRPUik7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuZW50cmllc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5lbnRyaWVzXG4vLyBgQXJyYXkucHJvdG90eXBlLmtleXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUua2V5c1xuLy8gYEFycmF5LnByb3RvdHlwZS52YWx1ZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUudmFsdWVzXG4vLyBgQXJyYXkucHJvdG90eXBlW0BAaXRlcmF0b3JdYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAaXRlcmF0b3Jcbi8vIGBDcmVhdGVBcnJheUl0ZXJhdG9yYCBpbnRlcm5hbCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtY3JlYXRlYXJyYXlpdGVyYXRvclxudmFyIGVzX2FycmF5X2l0ZXJhdG9yID0gZGVmaW5lSXRlcmF0b3IoQXJyYXksICdBcnJheScsIGZ1bmN0aW9uIChpdGVyYXRlZCwga2luZCkge1xuICBzZXRJbnRlcm5hbFN0YXRlJDEodGhpcywge1xuICAgIHR5cGU6IEFSUkFZX0lURVJBVE9SLFxuICAgIHRhcmdldDogdG9JbmRleGVkT2JqZWN0KGl0ZXJhdGVkKSwgLy8gdGFyZ2V0XG4gICAgaW5kZXg6IDAsICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4gICAga2luZDoga2luZCAgICAgICAgICAgICAgICAgICAgICAgICAvLyBraW5kXG4gIH0pO1xuLy8gYCVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJWFycmF5aXRlcmF0b3Jwcm90b3R5cGUlLm5leHRcbn0sIGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKTtcbiAgdmFyIHRhcmdldCA9IHN0YXRlLnRhcmdldDtcbiAgdmFyIGtpbmQgPSBzdGF0ZS5raW5kO1xuICB2YXIgaW5kZXggPSBzdGF0ZS5pbmRleCsrO1xuICBpZiAoIXRhcmdldCB8fCBpbmRleCA+PSB0YXJnZXQubGVuZ3RoKSB7XG4gICAgc3RhdGUudGFyZ2V0ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuICBpZiAoa2luZCA9PSAna2V5cycpIHJldHVybiB7IHZhbHVlOiBpbmRleCwgZG9uZTogZmFsc2UgfTtcbiAgaWYgKGtpbmQgPT0gJ3ZhbHVlcycpIHJldHVybiB7IHZhbHVlOiB0YXJnZXRbaW5kZXhdLCBkb25lOiBmYWxzZSB9O1xuICByZXR1cm4geyB2YWx1ZTogW2luZGV4LCB0YXJnZXRbaW5kZXhdXSwgZG9uZTogZmFsc2UgfTtcbn0sICd2YWx1ZXMnKTtcblxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWNyZWF0ZXVubWFwcGVkYXJndW1lbnRzb2JqZWN0XG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWNyZWF0ZW1hcHBlZGFyZ3VtZW50c29iamVjdFxudmFyIHZhbHVlcyA9IEl0ZXJhdG9ycyQyLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycyQyLkFycmF5O1xuXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQHVuc2NvcGFibGVzXG5hZGRUb1Vuc2NvcGFibGVzJDEoJ2tleXMnKTtcbmFkZFRvVW5zY29wYWJsZXMkMSgndmFsdWVzJyk7XG5hZGRUb1Vuc2NvcGFibGVzJDEoJ2VudHJpZXMnKTtcblxuLy8gVjggfiBDaHJvbWUgNDUtIGJ1Z1xuaWYgKERFU0NSSVBUT1JTJDMgJiYgdmFsdWVzLm5hbWUgIT09ICd2YWx1ZXMnKSB0cnkge1xuICBkZWZpbmVQcm9wZXJ0eSQyKHZhbHVlcywgJ25hbWUnLCB7IHZhbHVlOiAndmFsdWVzJyB9KTtcbn0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cblxuLy8gaXRlcmFibGUgRE9NIGNvbGxlY3Rpb25zXG4vLyBmbGFnIC0gYGl0ZXJhYmxlYCBpbnRlcmZhY2UgLSAnZW50cmllcycsICdrZXlzJywgJ3ZhbHVlcycsICdmb3JFYWNoJyBtZXRob2RzXG52YXIgZG9tSXRlcmFibGVzID0ge1xuICBDU1NSdWxlTGlzdDogMCxcbiAgQ1NTU3R5bGVEZWNsYXJhdGlvbjogMCxcbiAgQ1NTVmFsdWVMaXN0OiAwLFxuICBDbGllbnRSZWN0TGlzdDogMCxcbiAgRE9NUmVjdExpc3Q6IDAsXG4gIERPTVN0cmluZ0xpc3Q6IDAsXG4gIERPTVRva2VuTGlzdDogMSxcbiAgRGF0YVRyYW5zZmVySXRlbUxpc3Q6IDAsXG4gIEZpbGVMaXN0OiAwLFxuICBIVE1MQWxsQ29sbGVjdGlvbjogMCxcbiAgSFRNTENvbGxlY3Rpb246IDAsXG4gIEhUTUxGb3JtRWxlbWVudDogMCxcbiAgSFRNTFNlbGVjdEVsZW1lbnQ6IDAsXG4gIE1lZGlhTGlzdDogMCxcbiAgTWltZVR5cGVBcnJheTogMCxcbiAgTmFtZWROb2RlTWFwOiAwLFxuICBOb2RlTGlzdDogMSxcbiAgUGFpbnRSZXF1ZXN0TGlzdDogMCxcbiAgUGx1Z2luOiAwLFxuICBQbHVnaW5BcnJheTogMCxcbiAgU1ZHTGVuZ3RoTGlzdDogMCxcbiAgU1ZHTnVtYmVyTGlzdDogMCxcbiAgU1ZHUGF0aFNlZ0xpc3Q6IDAsXG4gIFNWR1BvaW50TGlzdDogMCxcbiAgU1ZHU3RyaW5nTGlzdDogMCxcbiAgU1ZHVHJhbnNmb3JtTGlzdDogMCxcbiAgU291cmNlQnVmZmVyTGlzdDogMCxcbiAgU3R5bGVTaGVldExpc3Q6IDAsXG4gIFRleHRUcmFja0N1ZUxpc3Q6IDAsXG4gIFRleHRUcmFja0xpc3Q6IDAsXG4gIFRvdWNoTGlzdDogMFxufTtcblxuLy8gaW4gb2xkIFdlYktpdCB2ZXJzaW9ucywgYGVsZW1lbnQuY2xhc3NMaXN0YCBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgZ2xvYmFsIGBET01Ub2tlbkxpc3RgXG52YXIgZG9jdW1lbnRDcmVhdGVFbGVtZW50ID0gZG9jdW1lbnRDcmVhdGVFbGVtZW50JDI7XG5cbnZhciBjbGFzc0xpc3QgPSBkb2N1bWVudENyZWF0ZUVsZW1lbnQoJ3NwYW4nKS5jbGFzc0xpc3Q7XG52YXIgRE9NVG9rZW5MaXN0UHJvdG90eXBlJDEgPSBjbGFzc0xpc3QgJiYgY2xhc3NMaXN0LmNvbnN0cnVjdG9yICYmIGNsYXNzTGlzdC5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG5cbnZhciBkb21Ub2tlbkxpc3RQcm90b3R5cGUgPSBET01Ub2tlbkxpc3RQcm90b3R5cGUkMSA9PT0gT2JqZWN0LnByb3RvdHlwZSA/IHVuZGVmaW5lZCA6IERPTVRva2VuTGlzdFByb3RvdHlwZSQxO1xuXG52YXIgZ2xvYmFsJGEgPSBnbG9iYWwkaztcbnZhciBET01JdGVyYWJsZXMgPSBkb21JdGVyYWJsZXM7XG52YXIgRE9NVG9rZW5MaXN0UHJvdG90eXBlID0gZG9tVG9rZW5MaXN0UHJvdG90eXBlO1xudmFyIEFycmF5SXRlcmF0b3JNZXRob2RzID0gZXNfYXJyYXlfaXRlcmF0b3I7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDQ7XG52YXIgd2VsbEtub3duU3ltYm9sJGEgPSB3ZWxsS25vd25TeW1ib2wkZztcblxudmFyIElURVJBVE9SJDMgPSB3ZWxsS25vd25TeW1ib2wkYSgnaXRlcmF0b3InKTtcbnZhciBUT19TVFJJTkdfVEFHJDIgPSB3ZWxsS25vd25TeW1ib2wkYSgndG9TdHJpbmdUYWcnKTtcbnZhciBBcnJheVZhbHVlcyA9IEFycmF5SXRlcmF0b3JNZXRob2RzLnZhbHVlcztcblxudmFyIGhhbmRsZVByb3RvdHlwZSA9IGZ1bmN0aW9uIChDb2xsZWN0aW9uUHJvdG90eXBlLCBDT0xMRUNUSU9OX05BTUUpIHtcbiAgaWYgKENvbGxlY3Rpb25Qcm90b3R5cGUpIHtcbiAgICAvLyBzb21lIENocm9tZSB2ZXJzaW9ucyBoYXZlIG5vbi1jb25maWd1cmFibGUgbWV0aG9kcyBvbiBET01Ub2tlbkxpc3RcbiAgICBpZiAoQ29sbGVjdGlvblByb3RvdHlwZVtJVEVSQVRPUiQzXSAhPT0gQXJyYXlWYWx1ZXMpIHRyeSB7XG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoQ29sbGVjdGlvblByb3RvdHlwZSwgSVRFUkFUT1IkMywgQXJyYXlWYWx1ZXMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBDb2xsZWN0aW9uUHJvdG90eXBlW0lURVJBVE9SJDNdID0gQXJyYXlWYWx1ZXM7XG4gICAgfVxuICAgIGlmICghQ29sbGVjdGlvblByb3RvdHlwZVtUT19TVFJJTkdfVEFHJDJdKSB7XG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoQ29sbGVjdGlvblByb3RvdHlwZSwgVE9fU1RSSU5HX1RBRyQyLCBDT0xMRUNUSU9OX05BTUUpO1xuICAgIH1cbiAgICBpZiAoRE9NSXRlcmFibGVzW0NPTExFQ1RJT05fTkFNRV0pIGZvciAodmFyIE1FVEhPRF9OQU1FIGluIEFycmF5SXRlcmF0b3JNZXRob2RzKSB7XG4gICAgICAvLyBzb21lIENocm9tZSB2ZXJzaW9ucyBoYXZlIG5vbi1jb25maWd1cmFibGUgbWV0aG9kcyBvbiBET01Ub2tlbkxpc3RcbiAgICAgIGlmIChDb2xsZWN0aW9uUHJvdG90eXBlW01FVEhPRF9OQU1FXSAhPT0gQXJyYXlJdGVyYXRvck1ldGhvZHNbTUVUSE9EX05BTUVdKSB0cnkge1xuICAgICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoQ29sbGVjdGlvblByb3RvdHlwZSwgTUVUSE9EX05BTUUsIEFycmF5SXRlcmF0b3JNZXRob2RzW01FVEhPRF9OQU1FXSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBDb2xsZWN0aW9uUHJvdG90eXBlW01FVEhPRF9OQU1FXSA9IEFycmF5SXRlcmF0b3JNZXRob2RzW01FVEhPRF9OQU1FXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmZvciAodmFyIENPTExFQ1RJT05fTkFNRSBpbiBET01JdGVyYWJsZXMpIHtcbiAgaGFuZGxlUHJvdG90eXBlKGdsb2JhbCRhW0NPTExFQ1RJT05fTkFNRV0gJiYgZ2xvYmFsJGFbQ09MTEVDVElPTl9OQU1FXS5wcm90b3R5cGUsIENPTExFQ1RJT05fTkFNRSk7XG59XG5cbmhhbmRsZVByb3RvdHlwZShET01Ub2tlbkxpc3RQcm90b3R5cGUsICdET01Ub2tlbkxpc3QnKTtcblxudmFyIERFU0NSSVBUT1JTJDIgPSBkZXNjcmlwdG9ycztcbnZhciB1bmN1cnJ5VGhpcyQ2ID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBjYWxsJDkgPSBmdW5jdGlvbkNhbGw7XG52YXIgZmFpbHMkNiA9IGZhaWxzJGg7XG52YXIgb2JqZWN0S2V5cyA9IG9iamVjdEtleXMkMjtcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUgPSBvYmplY3RQcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciB0b09iamVjdCQyID0gdG9PYmplY3QkNTtcbnZhciBJbmRleGVkT2JqZWN0JDEgPSBpbmRleGVkT2JqZWN0O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtYXNzaWduIC0tIHNhZmVcbnZhciAkYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xudmFyIGRlZmluZVByb3BlcnR5JDEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgY29uY2F0ID0gdW5jdXJyeVRoaXMkNihbXS5jb25jYXQpO1xuXG4vLyBgT2JqZWN0LmFzc2lnbmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5hc3NpZ25cbnZhciBvYmplY3RBc3NpZ24gPSAhJGFzc2lnbiB8fCBmYWlscyQ2KGZ1bmN0aW9uICgpIHtcbiAgLy8gc2hvdWxkIGhhdmUgY29ycmVjdCBvcmRlciBvZiBvcGVyYXRpb25zIChFZGdlIGJ1ZylcbiAgaWYgKERFU0NSSVBUT1JTJDIgJiYgJGFzc2lnbih7IGI6IDEgfSwgJGFzc2lnbihkZWZpbmVQcm9wZXJ0eSQxKHt9LCAnYScsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgZGVmaW5lUHJvcGVydHkkMSh0aGlzLCAnYicsIHtcbiAgICAgICAgdmFsdWU6IDMsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gIH0pLCB7IGI6IDIgfSkpLmIgIT09IDEpIHJldHVybiB0cnVlO1xuICAvLyBzaG91bGQgd29yayB3aXRoIHN5bWJvbHMgYW5kIHNob3VsZCBoYXZlIGRldGVybWluaXN0aWMgcHJvcGVydHkgb3JkZXIgKFY4IGJ1ZylcbiAgdmFyIEEgPSB7fTtcbiAgdmFyIEIgPSB7fTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tc3ltYm9sIC0tIHNhZmVcbiAgdmFyIHN5bWJvbCA9IFN5bWJvbCgpO1xuICB2YXIgYWxwaGFiZXQgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3QnO1xuICBBW3N5bWJvbF0gPSA3O1xuICBhbHBoYWJldC5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAoY2hyKSB7IEJbY2hyXSA9IGNocjsgfSk7XG4gIHJldHVybiAkYXNzaWduKHt9LCBBKVtzeW1ib2xdICE9IDcgfHwgb2JqZWN0S2V5cygkYXNzaWduKHt9LCBCKSkuam9pbignJykgIT0gYWxwaGFiZXQ7XG59KSA/IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzIC0tIHJlcXVpcmVkIGZvciBgLmxlbmd0aGBcbiAgdmFyIFQgPSB0b09iamVjdCQyKHRhcmdldCk7XG4gIHZhciBhcmd1bWVudHNMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSAxO1xuICB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlLmY7XG4gIHZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlLmY7XG4gIHdoaWxlIChhcmd1bWVudHNMZW5ndGggPiBpbmRleCkge1xuICAgIHZhciBTID0gSW5kZXhlZE9iamVjdCQxKGFyZ3VtZW50c1tpbmRleCsrXSk7XG4gICAgdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBjb25jYXQob2JqZWN0S2V5cyhTKSwgZ2V0T3duUHJvcGVydHlTeW1ib2xzKFMpKSA6IG9iamVjdEtleXMoUyk7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBqID0gMDtcbiAgICB2YXIga2V5O1xuICAgIHdoaWxlIChsZW5ndGggPiBqKSB7XG4gICAgICBrZXkgPSBrZXlzW2orK107XG4gICAgICBpZiAoIURFU0NSSVBUT1JTJDIgfHwgY2FsbCQ5KHByb3BlcnR5SXNFbnVtZXJhYmxlLCBTLCBrZXkpKSBUW2tleV0gPSBTW2tleV07XG4gICAgfVxuICB9IHJldHVybiBUO1xufSA6ICRhc3NpZ247XG5cbnZhciAkJGIgPSBfZXhwb3J0O1xudmFyIGFzc2lnbiA9IG9iamVjdEFzc2lnbjtcblxuLy8gYE9iamVjdC5hc3NpZ25gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuYXNzaWduXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtYXNzaWduIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4kJGIoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBhcml0eTogMiwgZm9yY2VkOiBPYmplY3QuYXNzaWduICE9PSBhc3NpZ24gfSwge1xuICBhc3NpZ246IGFzc2lnblxufSk7XG5cbmNvbnN0IENsb3NlSWNvbiA9ICgpID0+IHtcbiAgcmV0dXJuIGpzeHMoXCJzdmdcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICBoZWlnaHQ6IFwiMjRcIixcbiAgICB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiLFxuICAgIHdpZHRoOiBcIjI0XCIsXG4gICAgZmlsbDogXCIjQzFDMUMxXCJcbiAgfSwge1xuICAgIGNoaWxkcmVuOiBbanN4KFwicGF0aFwiLCB7XG4gICAgICBkOiBcIk0wIDBoMjR2MjRIMHpcIixcbiAgICAgIGZpbGw6IFwibm9uZVwiXG4gICAgfSksIGpzeChcInBhdGhcIiwge1xuICAgICAgZDogXCJNMTkgNi40MUwxNy41OSA1IDEyIDEwLjU5IDYuNDEgNSA1IDYuNDEgMTAuNTkgMTIgNSAxNy41OSA2LjQxIDE5IDEyIDEzLjQxIDE3LjU5IDE5IDE5IDE3LjU5IDEzLjQxIDEyelwiXG4gICAgfSldXG4gIH0pKTtcbn07XG5cbmNvbnN0IENsb3NlQnV0dG9uID0gKHtcbiAgb25DbGlja1xufSkgPT4ge1xuICByZXR1cm4ganN4KFwiYnV0dG9uXCIsIE9iamVjdC5hc3NpZ24oe1xuICAgIG9uQ2xpY2s6IG9uQ2xpY2ssXG4gICAgY2xhc3NOYW1lOiBcImNsb3NlLWJ1dHRvblwiXG4gIH0sIHtcbiAgICBjaGlsZHJlbjoganN4KENsb3NlSWNvbiwge30pXG4gIH0pKTtcbn07XG5cbmNvbnN0IE1vZGFsSGVhZGVyID0gKHtcbiAgdGl0bGUsXG4gIG9uQ2xvc2VNb2RhbFxufSkgPT4ge1xuICBjb25zdCBhZGRpdGlvbmFsQ2xhc3NlcyA9IHRpdGxlID09PSBcIkdldCBhIFdhbGxldFwiID8gXCIgLW9wZW5cIiA6IFwiXCI7XG4gIHJldHVybiBqc3hzKFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgIGNsYXNzTmFtZTogXCJud3MtbW9kYWwtaGVhZGVyXCJcbiAgfSwge1xuICAgIGNoaWxkcmVuOiBbanN4KFwiaDNcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICBjbGFzc05hbWU6IGBtaWRkbGVUaXRsZSAke2FkZGl0aW9uYWxDbGFzc2VzfWBcbiAgICB9LCB7XG4gICAgICBjaGlsZHJlbjogdGl0bGVcbiAgICB9KSksIGpzeChDbG9zZUJ1dHRvbiwge1xuICAgICAgb25DbGljazogb25DbG9zZU1vZGFsXG4gICAgfSldXG4gIH0pKTtcbn07XG5cbmNvbnN0IEJhY2tBcnJvd0ljb24gPSAoKSA9PiB7XG4gIHJldHVybiBqc3goXCJzdmdcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgd2lkdGg6IFwiOFwiLFxuICAgIGhlaWdodDogXCIxNFwiLFxuICAgIHZpZXdCb3g6IFwiMCAwIDggMTRcIixcbiAgICBmaWxsOiBcIm5vbmVcIixcbiAgICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gIH0sIHtcbiAgICBjaGlsZHJlbjoganN4KFwicGF0aFwiLCB7XG4gICAgICBkOiBcIk03IDEzTDEgN0w3IDFcIixcbiAgICAgIHN0cm9rZTogXCIjNjQ5NEVFXCIsXG4gICAgICBzdHJva2VXaWR0aDogXCIxLjVcIixcbiAgICAgIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIixcbiAgICAgIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCJcbiAgICB9KVxuICB9KSk7XG59O1xuXG5jb25zdCBCYWNrQXJyb3cgPSAoe1xuICBvbkNsaWNrXG59KSA9PiB7XG4gIHJldHVybiBqc3goXCJidXR0b25cIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgb25DbGljazogb25DbGljayxcbiAgICBjbGFzc05hbWU6IFwiYmFjay1idXR0b25cIlxuICB9LCB7XG4gICAgY2hpbGRyZW46IGpzeChCYWNrQXJyb3dJY29uLCB7fSlcbiAgfSkpO1xufTtcblxuY29uc3QgV2FsbGV0TmV0d29ya0NoYW5nZWQgPSAoe1xuICBzZWxlY3RvcixcbiAgb25CYWNrLFxuICBvbkNsb3NlTW9kYWxcbn0pID0+IHtcbiAgcmV0dXJuIGpzeHMoRnJhZ21lbnQsIHtcbiAgICBjaGlsZHJlbjogW2pzeHMoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICBjbGFzc05hbWU6IFwibndzLW1vZGFsLWhlYWRlci13cmFwcGVyXCJcbiAgICB9LCB7XG4gICAgICBjaGlsZHJlbjogW2pzeChCYWNrQXJyb3csIHtcbiAgICAgICAgb25DbGljazogb25CYWNrXG4gICAgICB9KSwganN4KE1vZGFsSGVhZGVyLCB7XG4gICAgICAgIHRpdGxlOiBcIllvdSBNdXN0IENoYW5nZSB0aGUgTmV0d29ya1wiLFxuICAgICAgICBvbkNsb3NlTW9kYWw6IG9uQ2xvc2VNb2RhbFxuICAgICAgfSldXG4gICAgfSkpLCBqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICBjbGFzc05hbWU6IFwic3dpdGNoLW5ldHdvcmstbWVzc2FnZS13cmFwcGVyXCJcbiAgICB9LCB7XG4gICAgICBjaGlsZHJlbjoganN4cyhcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImNvbnRlbnRcIlxuICAgICAgfSwge1xuICAgICAgICBjaGlsZHJlbjogW2pzeHMoXCJwXCIsIHtcbiAgICAgICAgICBjaGlsZHJlbjogW1wiV2UndmUgZGV0ZWN0ZWQgdGhhdCB5b3UgbmVlZCB0byBjaGFuZ2UgeW91ciB3YWxsZXQncyBuZXR3b3JrIHRvXCIsIGpzeChcInN0cm9uZ1wiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJuZXR3b3JrLWlkXCJcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogYCAke3NlbGVjdG9yLm9wdGlvbnMubmV0d29yay5uZXR3b3JrSWR9YFxuICAgICAgICAgIH0pKSwgXCIgXCIsIFwiZm9yIHRoaXMgZEFwcC5cIl1cbiAgICAgICAgfSksIGpzeChcInBcIiwge1xuICAgICAgICAgIGNoaWxkcmVuOiBcIlNvbWUgd2FsbGV0cyBtYXkgbm90IHN1cHBvcnQgY2hhbmdpbmcgbmV0d29ya3MuIElmIHlvdSBjYW4gbm90IGNoYW5nZSBuZXR3b3JrcyB5b3UgbWF5IGNvbnNpZGVyIHN3aXRjaGluZyB0byBhbm90aGVyIHdhbGxldC5cIlxuICAgICAgICB9KV1cbiAgICAgIH0pKVxuICAgIH0pKV1cbiAgfSk7XG59O1xuXG52YXIgdHJ5VG9TdHJpbmckMyA9IHRyeVRvU3RyaW5nJDU7XG5cbnZhciAkVHlwZUVycm9yJDcgPSBUeXBlRXJyb3I7XG5cbnZhciBkZWxldGVQcm9wZXJ0eU9yVGhyb3ckMSA9IGZ1bmN0aW9uIChPLCBQKSB7XG4gIGlmICghZGVsZXRlIE9bUF0pIHRocm93ICRUeXBlRXJyb3IkNygnQ2Fubm90IGRlbGV0ZSBwcm9wZXJ0eSAnICsgdHJ5VG9TdHJpbmckMyhQKSArICcgb2YgJyArIHRyeVRvU3RyaW5nJDMoTykpO1xufTtcblxudmFyIHdlbGxLbm93blN5bWJvbCQ5ID0gd2VsbEtub3duU3ltYm9sJGc7XG5cbnZhciBUT19TVFJJTkdfVEFHJDEgPSB3ZWxsS25vd25TeW1ib2wkOSgndG9TdHJpbmdUYWcnKTtcbnZhciB0ZXN0JDEgPSB7fTtcblxudGVzdCQxW1RPX1NUUklOR19UQUckMV0gPSAneic7XG5cbnZhciB0b1N0cmluZ1RhZ1N1cHBvcnQgPSBTdHJpbmcodGVzdCQxKSA9PT0gJ1tvYmplY3Qgel0nO1xuXG52YXIgVE9fU1RSSU5HX1RBR19TVVBQT1JUID0gdG9TdHJpbmdUYWdTdXBwb3J0O1xudmFyIGlzQ2FsbGFibGUkNiA9IGlzQ2FsbGFibGUkbDtcbnZhciBjbGFzc29mUmF3ID0gY2xhc3NvZlJhdyQxO1xudmFyIHdlbGxLbm93blN5bWJvbCQ4ID0gd2VsbEtub3duU3ltYm9sJGc7XG5cbnZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sJDgoJ3RvU3RyaW5nVGFnJyk7XG52YXIgJE9iamVjdCA9IE9iamVjdDtcblxuLy8gRVMzIHdyb25nIGhlcmVcbnZhciBDT1JSRUNUX0FSR1VNRU5UUyA9IGNsYXNzb2ZSYXcoZnVuY3Rpb24gKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID09ICdBcmd1bWVudHMnO1xuXG4vLyBmYWxsYmFjayBmb3IgSUUxMSBTY3JpcHQgQWNjZXNzIERlbmllZCBlcnJvclxudmFyIHRyeUdldCA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGl0W2tleV07XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbn07XG5cbi8vIGdldHRpbmcgdGFnIGZyb20gRVM2KyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2BcbnZhciBjbGFzc29mJDUgPSBUT19TVFJJTkdfVEFHX1NVUFBPUlQgPyBjbGFzc29mUmF3IDogZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBPLCB0YWcsIHJlc3VsdDtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXG4gICAgLy8gQEB0b1N0cmluZ1RhZyBjYXNlXG4gICAgOiB0eXBlb2YgKHRhZyA9IHRyeUdldChPID0gJE9iamVjdChpdCksIFRPX1NUUklOR19UQUcpKSA9PSAnc3RyaW5nJyA/IHRhZ1xuICAgIC8vIGJ1aWx0aW5UYWcgY2FzZVxuICAgIDogQ09SUkVDVF9BUkdVTUVOVFMgPyBjbGFzc29mUmF3KE8pXG4gICAgLy8gRVMzIGFyZ3VtZW50cyBmYWxsYmFja1xuICAgIDogKHJlc3VsdCA9IGNsYXNzb2ZSYXcoTykpID09ICdPYmplY3QnICYmIGlzQ2FsbGFibGUkNihPLmNhbGxlZSkgPyAnQXJndW1lbnRzJyA6IHJlc3VsdDtcbn07XG5cbnZhciBjbGFzc29mJDQgPSBjbGFzc29mJDU7XG5cbnZhciAkU3RyaW5nID0gU3RyaW5nO1xuXG52YXIgdG9TdHJpbmckMyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAoY2xhc3NvZiQ0KGFyZ3VtZW50KSA9PT0gJ1N5bWJvbCcpIHRocm93IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgYSBTeW1ib2wgdmFsdWUgdG8gYSBzdHJpbmcnKTtcbiAgcmV0dXJuICRTdHJpbmcoYXJndW1lbnQpO1xufTtcblxudmFyIHRvUHJvcGVydHlLZXkgPSB0b1Byb3BlcnR5S2V5JDM7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUkMSA9IG9iamVjdERlZmluZVByb3BlcnR5O1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQ0O1xuXG52YXIgY3JlYXRlUHJvcGVydHkkMSA9IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgdmFyIHByb3BlcnR5S2V5ID0gdG9Qcm9wZXJ0eUtleShrZXkpO1xuICBpZiAocHJvcGVydHlLZXkgaW4gb2JqZWN0KSBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQxLmYob2JqZWN0LCBwcm9wZXJ0eUtleSwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDAsIHZhbHVlKSk7XG4gIGVsc2Ugb2JqZWN0W3Byb3BlcnR5S2V5XSA9IHZhbHVlO1xufTtcblxudmFyIHRvQWJzb2x1dGVJbmRleCA9IHRvQWJzb2x1dGVJbmRleCQyO1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlJDMgPSBsZW5ndGhPZkFycmF5TGlrZSQ1O1xudmFyIGNyZWF0ZVByb3BlcnR5ID0gY3JlYXRlUHJvcGVydHkkMTtcblxudmFyICRBcnJheSA9IEFycmF5O1xudmFyIG1heCA9IE1hdGgubWF4O1xuXG52YXIgYXJyYXlTbGljZVNpbXBsZSA9IGZ1bmN0aW9uIChPLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW5ndGggPSBsZW5ndGhPZkFycmF5TGlrZSQzKE8pO1xuICB2YXIgayA9IHRvQWJzb2x1dGVJbmRleChzdGFydCwgbGVuZ3RoKTtcbiAgdmFyIGZpbiA9IHRvQWJzb2x1dGVJbmRleChlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IGVuZCwgbGVuZ3RoKTtcbiAgdmFyIHJlc3VsdCA9ICRBcnJheShtYXgoZmluIC0gaywgMCkpO1xuICBmb3IgKHZhciBuID0gMDsgayA8IGZpbjsgaysrLCBuKyspIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgbiwgT1trXSk7XG4gIHJlc3VsdC5sZW5ndGggPSBuO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxudmFyIGFycmF5U2xpY2UkMiA9IGFycmF5U2xpY2VTaW1wbGU7XG5cbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5cbnZhciBtZXJnZVNvcnQgPSBmdW5jdGlvbiAoYXJyYXksIGNvbXBhcmVmbikge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB2YXIgbWlkZGxlID0gZmxvb3IobGVuZ3RoIC8gMik7XG4gIHJldHVybiBsZW5ndGggPCA4ID8gaW5zZXJ0aW9uU29ydChhcnJheSwgY29tcGFyZWZuKSA6IG1lcmdlKFxuICAgIGFycmF5LFxuICAgIG1lcmdlU29ydChhcnJheVNsaWNlJDIoYXJyYXksIDAsIG1pZGRsZSksIGNvbXBhcmVmbiksXG4gICAgbWVyZ2VTb3J0KGFycmF5U2xpY2UkMihhcnJheSwgbWlkZGxlKSwgY29tcGFyZWZuKSxcbiAgICBjb21wYXJlZm5cbiAgKTtcbn07XG5cbnZhciBpbnNlcnRpb25Tb3J0ID0gZnVuY3Rpb24gKGFycmF5LCBjb21wYXJlZm4pIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgdmFyIGkgPSAxO1xuICB2YXIgZWxlbWVudCwgajtcblxuICB3aGlsZSAoaSA8IGxlbmd0aCkge1xuICAgIGogPSBpO1xuICAgIGVsZW1lbnQgPSBhcnJheVtpXTtcbiAgICB3aGlsZSAoaiAmJiBjb21wYXJlZm4oYXJyYXlbaiAtIDFdLCBlbGVtZW50KSA+IDApIHtcbiAgICAgIGFycmF5W2pdID0gYXJyYXlbLS1qXTtcbiAgICB9XG4gICAgaWYgKGogIT09IGkrKykgYXJyYXlbal0gPSBlbGVtZW50O1xuICB9IHJldHVybiBhcnJheTtcbn07XG5cbnZhciBtZXJnZSA9IGZ1bmN0aW9uIChhcnJheSwgbGVmdCwgcmlnaHQsIGNvbXBhcmVmbikge1xuICB2YXIgbGxlbmd0aCA9IGxlZnQubGVuZ3RoO1xuICB2YXIgcmxlbmd0aCA9IHJpZ2h0Lmxlbmd0aDtcbiAgdmFyIGxpbmRleCA9IDA7XG4gIHZhciByaW5kZXggPSAwO1xuXG4gIHdoaWxlIChsaW5kZXggPCBsbGVuZ3RoIHx8IHJpbmRleCA8IHJsZW5ndGgpIHtcbiAgICBhcnJheVtsaW5kZXggKyByaW5kZXhdID0gKGxpbmRleCA8IGxsZW5ndGggJiYgcmluZGV4IDwgcmxlbmd0aClcbiAgICAgID8gY29tcGFyZWZuKGxlZnRbbGluZGV4XSwgcmlnaHRbcmluZGV4XSkgPD0gMCA/IGxlZnRbbGluZGV4KytdIDogcmlnaHRbcmluZGV4KytdXG4gICAgICA6IGxpbmRleCA8IGxsZW5ndGggPyBsZWZ0W2xpbmRleCsrXSA6IHJpZ2h0W3JpbmRleCsrXTtcbiAgfSByZXR1cm4gYXJyYXk7XG59O1xuXG52YXIgYXJyYXlTb3J0ID0gbWVyZ2VTb3J0O1xuXG52YXIgZmFpbHMkNSA9IGZhaWxzJGg7XG5cbnZhciBhcnJheU1ldGhvZElzU3RyaWN0JDIgPSBmdW5jdGlvbiAoTUVUSE9EX05BTUUsIGFyZ3VtZW50KSB7XG4gIHZhciBtZXRob2QgPSBbXVtNRVRIT0RfTkFNRV07XG4gIHJldHVybiAhIW1ldGhvZCAmJiBmYWlscyQ1KGZ1bmN0aW9uICgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1jYWxsIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gICAgbWV0aG9kLmNhbGwobnVsbCwgYXJndW1lbnQgfHwgZnVuY3Rpb24gKCkgeyByZXR1cm4gMTsgfSwgMSk7XG4gIH0pO1xufTtcblxudmFyIHVzZXJBZ2VudCQ0ID0gZW5naW5lVXNlckFnZW50O1xuXG52YXIgZmlyZWZveCA9IHVzZXJBZ2VudCQ0Lm1hdGNoKC9maXJlZm94XFwvKFxcZCspL2kpO1xuXG52YXIgZW5naW5lRmZWZXJzaW9uID0gISFmaXJlZm94ICYmICtmaXJlZm94WzFdO1xuXG52YXIgVUEgPSBlbmdpbmVVc2VyQWdlbnQ7XG5cbnZhciBlbmdpbmVJc0llT3JFZGdlID0gL01TSUV8VHJpZGVudC8udGVzdChVQSk7XG5cbnZhciB1c2VyQWdlbnQkMyA9IGVuZ2luZVVzZXJBZ2VudDtcblxudmFyIHdlYmtpdCA9IHVzZXJBZ2VudCQzLm1hdGNoKC9BcHBsZVdlYktpdFxcLyhcXGQrKVxcLi8pO1xuXG52YXIgZW5naW5lV2Via2l0VmVyc2lvbiA9ICEhd2Via2l0ICYmICt3ZWJraXRbMV07XG5cbnZhciAkJGEgPSBfZXhwb3J0O1xudmFyIHVuY3VycnlUaGlzJDUgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGFDYWxsYWJsZSQ3ID0gYUNhbGxhYmxlJDk7XG52YXIgdG9PYmplY3QkMSA9IHRvT2JqZWN0JDU7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UkMiA9IGxlbmd0aE9mQXJyYXlMaWtlJDU7XG52YXIgZGVsZXRlUHJvcGVydHlPclRocm93ID0gZGVsZXRlUHJvcGVydHlPclRocm93JDE7XG52YXIgdG9TdHJpbmckMiA9IHRvU3RyaW5nJDM7XG52YXIgZmFpbHMkNCA9IGZhaWxzJGg7XG52YXIgaW50ZXJuYWxTb3J0ID0gYXJyYXlTb3J0O1xudmFyIGFycmF5TWV0aG9kSXNTdHJpY3QkMSA9IGFycmF5TWV0aG9kSXNTdHJpY3QkMjtcbnZhciBGRiA9IGVuZ2luZUZmVmVyc2lvbjtcbnZhciBJRV9PUl9FREdFID0gZW5naW5lSXNJZU9yRWRnZTtcbnZhciBWOCA9IGVuZ2luZVY4VmVyc2lvbjtcbnZhciBXRUJLSVQgPSBlbmdpbmVXZWJraXRWZXJzaW9uO1xuXG52YXIgdGVzdCA9IFtdO1xudmFyIHVuJFNvcnQgPSB1bmN1cnJ5VGhpcyQ1KHRlc3Quc29ydCk7XG52YXIgcHVzaCA9IHVuY3VycnlUaGlzJDUodGVzdC5wdXNoKTtcblxuLy8gSUU4LVxudmFyIEZBSUxTX09OX1VOREVGSU5FRCA9IGZhaWxzJDQoZnVuY3Rpb24gKCkge1xuICB0ZXN0LnNvcnQodW5kZWZpbmVkKTtcbn0pO1xuLy8gVjggYnVnXG52YXIgRkFJTFNfT05fTlVMTCA9IGZhaWxzJDQoZnVuY3Rpb24gKCkge1xuICB0ZXN0LnNvcnQobnVsbCk7XG59KTtcbi8vIE9sZCBXZWJLaXRcbnZhciBTVFJJQ1RfTUVUSE9EJDEgPSBhcnJheU1ldGhvZElzU3RyaWN0JDEoJ3NvcnQnKTtcblxudmFyIFNUQUJMRV9TT1JUID0gIWZhaWxzJDQoZnVuY3Rpb24gKCkge1xuICAvLyBmZWF0dXJlIGRldGVjdGlvbiBjYW4gYmUgdG9vIHNsb3csIHNvIGNoZWNrIGVuZ2luZXMgdmVyc2lvbnNcbiAgaWYgKFY4KSByZXR1cm4gVjggPCA3MDtcbiAgaWYgKEZGICYmIEZGID4gMykgcmV0dXJuO1xuICBpZiAoSUVfT1JfRURHRSkgcmV0dXJuIHRydWU7XG4gIGlmIChXRUJLSVQpIHJldHVybiBXRUJLSVQgPCA2MDM7XG5cbiAgdmFyIHJlc3VsdCA9ICcnO1xuICB2YXIgY29kZSwgY2hyLCB2YWx1ZSwgaW5kZXg7XG5cbiAgLy8gZ2VuZXJhdGUgYW4gYXJyYXkgd2l0aCBtb3JlIDUxMiBlbGVtZW50cyAoQ2hha3JhIGFuZCBvbGQgVjggZmFpbHMgb25seSBpbiB0aGlzIGNhc2UpXG4gIGZvciAoY29kZSA9IDY1OyBjb2RlIDwgNzY7IGNvZGUrKykge1xuICAgIGNociA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG5cbiAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgIGNhc2UgNjY6IGNhc2UgNjk6IGNhc2UgNzA6IGNhc2UgNzI6IHZhbHVlID0gMzsgYnJlYWs7XG4gICAgICBjYXNlIDY4OiBjYXNlIDcxOiB2YWx1ZSA9IDQ7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogdmFsdWUgPSAyO1xuICAgIH1cblxuICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IDQ3OyBpbmRleCsrKSB7XG4gICAgICB0ZXN0LnB1c2goeyBrOiBjaHIgKyBpbmRleCwgdjogdmFsdWUgfSk7XG4gICAgfVxuICB9XG5cbiAgdGVzdC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBiLnYgLSBhLnY7IH0pO1xuXG4gIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHRlc3QubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgY2hyID0gdGVzdFtpbmRleF0uay5jaGFyQXQoMCk7XG4gICAgaWYgKHJlc3VsdC5jaGFyQXQocmVzdWx0Lmxlbmd0aCAtIDEpICE9PSBjaHIpIHJlc3VsdCArPSBjaHI7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0ICE9PSAnREdCRUZIQUNJSksnO1xufSk7XG5cbnZhciBGT1JDRUQgPSBGQUlMU19PTl9VTkRFRklORUQgfHwgIUZBSUxTX09OX05VTEwgfHwgIVNUUklDVF9NRVRIT0QkMSB8fCAhU1RBQkxFX1NPUlQ7XG5cbnZhciBnZXRTb3J0Q29tcGFyZSA9IGZ1bmN0aW9uIChjb21wYXJlZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgaWYgKHkgPT09IHVuZGVmaW5lZCkgcmV0dXJuIC0xO1xuICAgIGlmICh4ID09PSB1bmRlZmluZWQpIHJldHVybiAxO1xuICAgIGlmIChjb21wYXJlZm4gIT09IHVuZGVmaW5lZCkgcmV0dXJuICtjb21wYXJlZm4oeCwgeSkgfHwgMDtcbiAgICByZXR1cm4gdG9TdHJpbmckMih4KSA+IHRvU3RyaW5nJDIoeSkgPyAxIDogLTE7XG4gIH07XG59O1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLnNvcnRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuc29ydFxuJCRhKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBGT1JDRUQgfSwge1xuICBzb3J0OiBmdW5jdGlvbiBzb3J0KGNvbXBhcmVmbikge1xuICAgIGlmIChjb21wYXJlZm4gIT09IHVuZGVmaW5lZCkgYUNhbGxhYmxlJDcoY29tcGFyZWZuKTtcblxuICAgIHZhciBhcnJheSA9IHRvT2JqZWN0JDEodGhpcyk7XG5cbiAgICBpZiAoU1RBQkxFX1NPUlQpIHJldHVybiBjb21wYXJlZm4gPT09IHVuZGVmaW5lZCA/IHVuJFNvcnQoYXJyYXkpIDogdW4kU29ydChhcnJheSwgY29tcGFyZWZuKTtcblxuICAgIHZhciBpdGVtcyA9IFtdO1xuICAgIHZhciBhcnJheUxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlJDIoYXJyYXkpO1xuICAgIHZhciBpdGVtc0xlbmd0aCwgaW5kZXg7XG5cbiAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBhcnJheUxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgaWYgKGluZGV4IGluIGFycmF5KSBwdXNoKGl0ZW1zLCBhcnJheVtpbmRleF0pO1xuICAgIH1cblxuICAgIGludGVybmFsU29ydChpdGVtcywgZ2V0U29ydENvbXBhcmUoY29tcGFyZWZuKSk7XG5cbiAgICBpdGVtc0xlbmd0aCA9IGl0ZW1zLmxlbmd0aDtcbiAgICBpbmRleCA9IDA7XG5cbiAgICB3aGlsZSAoaW5kZXggPCBpdGVtc0xlbmd0aCkgYXJyYXlbaW5kZXhdID0gaXRlbXNbaW5kZXgrK107XG4gICAgd2hpbGUgKGluZGV4IDwgYXJyYXlMZW5ndGgpIGRlbGV0ZVByb3BlcnR5T3JUaHJvdyhhcnJheSwgaW5kZXgrKyk7XG5cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cbn0pO1xuXG52YXIgJCQ5ID0gX2V4cG9ydDtcbnZhciAkaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzLmluY2x1ZGVzO1xudmFyIGZhaWxzJDMgPSBmYWlscyRoO1xudmFyIGFkZFRvVW5zY29wYWJsZXMgPSBhZGRUb1Vuc2NvcGFibGVzJDI7XG5cbi8vIEZGOTkrIGJ1Z1xudmFyIEJST0tFTl9PTl9TUEFSU0UgPSBmYWlscyQzKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICFBcnJheSgxKS5pbmNsdWRlcygpO1xufSk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuaW5jbHVkZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuaW5jbHVkZXNcbiQkOSh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogQlJPS0VOX09OX1NQQVJTRSB9LCB7XG4gIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhlbCAvKiAsIGZyb21JbmRleCA9IDAgKi8pIHtcbiAgICByZXR1cm4gJGluY2x1ZGVzKHRoaXMsIGVsLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQHVuc2NvcGFibGVzXG5hZGRUb1Vuc2NvcGFibGVzKCdpbmNsdWRlcycpO1xuXG52YXIgaXNPYmplY3QkMiA9IGlzT2JqZWN0JDg7XG52YXIgY2xhc3NvZiQzID0gY2xhc3NvZlJhdyQxO1xudmFyIHdlbGxLbm93blN5bWJvbCQ3ID0gd2VsbEtub3duU3ltYm9sJGc7XG5cbnZhciBNQVRDSCQxID0gd2VsbEtub3duU3ltYm9sJDcoJ21hdGNoJyk7XG5cbi8vIGBJc1JlZ0V4cGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWlzcmVnZXhwXG52YXIgaXNSZWdleHAgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIGlzUmVnRXhwO1xuICByZXR1cm4gaXNPYmplY3QkMihpdCkgJiYgKChpc1JlZ0V4cCA9IGl0W01BVENIJDFdKSAhPT0gdW5kZWZpbmVkID8gISFpc1JlZ0V4cCA6IGNsYXNzb2YkMyhpdCkgPT0gJ1JlZ0V4cCcpO1xufTtcblxudmFyIGlzUmVnRXhwID0gaXNSZWdleHA7XG5cbnZhciAkVHlwZUVycm9yJDYgPSBUeXBlRXJyb3I7XG5cbnZhciBub3RBUmVnZXhwID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpc1JlZ0V4cChpdCkpIHtcbiAgICB0aHJvdyAkVHlwZUVycm9yJDYoXCJUaGUgbWV0aG9kIGRvZXNuJ3QgYWNjZXB0IHJlZ3VsYXIgZXhwcmVzc2lvbnNcIik7XG4gIH0gcmV0dXJuIGl0O1xufTtcblxudmFyIHdlbGxLbm93blN5bWJvbCQ2ID0gd2VsbEtub3duU3ltYm9sJGc7XG5cbnZhciBNQVRDSCA9IHdlbGxLbm93blN5bWJvbCQ2KCdtYXRjaCcpO1xuXG52YXIgY29ycmVjdElzUmVnZXhwTG9naWMgPSBmdW5jdGlvbiAoTUVUSE9EX05BTUUpIHtcbiAgdmFyIHJlZ2V4cCA9IC8uLztcbiAgdHJ5IHtcbiAgICAnLy4vJ1tNRVRIT0RfTkFNRV0ocmVnZXhwKTtcbiAgfSBjYXRjaCAoZXJyb3IxKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJlZ2V4cFtNQVRDSF0gPSBmYWxzZTtcbiAgICAgIHJldHVybiAnLy4vJ1tNRVRIT0RfTkFNRV0ocmVnZXhwKTtcbiAgICB9IGNhdGNoIChlcnJvcjIpIHsgLyogZW1wdHkgKi8gfVxuICB9IHJldHVybiBmYWxzZTtcbn07XG5cbnZhciAkJDggPSBfZXhwb3J0O1xudmFyIHVuY3VycnlUaGlzJDQgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIG5vdEFSZWdFeHAgPSBub3RBUmVnZXhwO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDM7XG52YXIgdG9TdHJpbmckMSA9IHRvU3RyaW5nJDM7XG52YXIgY29ycmVjdElzUmVnRXhwTG9naWMgPSBjb3JyZWN0SXNSZWdleHBMb2dpYztcblxudmFyIHN0cmluZ0luZGV4T2YgPSB1bmN1cnJ5VGhpcyQ0KCcnLmluZGV4T2YpO1xuXG4vLyBgU3RyaW5nLnByb3RvdHlwZS5pbmNsdWRlc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUuaW5jbHVkZXNcbiQkOCh7IHRhcmdldDogJ1N0cmluZycsIHByb3RvOiB0cnVlLCBmb3JjZWQ6ICFjb3JyZWN0SXNSZWdFeHBMb2dpYygnaW5jbHVkZXMnKSB9LCB7XG4gIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhzZWFyY2hTdHJpbmcgLyogLCBwb3NpdGlvbiA9IDAgKi8pIHtcbiAgICByZXR1cm4gISF+c3RyaW5nSW5kZXhPZihcbiAgICAgIHRvU3RyaW5nJDEocmVxdWlyZU9iamVjdENvZXJjaWJsZSh0aGlzKSksXG4gICAgICB0b1N0cmluZyQxKG5vdEFSZWdFeHAoc2VhcmNoU3RyaW5nKSksXG4gICAgICBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZFxuICAgICk7XG4gIH1cbn0pO1xuXG52YXIgYUNhbGxhYmxlJDYgPSBhQ2FsbGFibGUkOTtcbnZhciB0b09iamVjdCA9IHRvT2JqZWN0JDU7XG52YXIgSW5kZXhlZE9iamVjdCA9IGluZGV4ZWRPYmplY3Q7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UkMSA9IGxlbmd0aE9mQXJyYXlMaWtlJDU7XG5cbnZhciAkVHlwZUVycm9yJDUgPSBUeXBlRXJyb3I7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUueyByZWR1Y2UsIHJlZHVjZVJpZ2h0IH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cbnZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbiAoSVNfUklHSFQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0aGF0LCBjYWxsYmFja2ZuLCBhcmd1bWVudHNMZW5ndGgsIG1lbW8pIHtcbiAgICBhQ2FsbGFibGUkNihjYWxsYmFja2ZuKTtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KHRoYXQpO1xuICAgIHZhciBzZWxmID0gSW5kZXhlZE9iamVjdChPKTtcbiAgICB2YXIgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UkMShPKTtcbiAgICB2YXIgaW5kZXggPSBJU19SSUdIVCA/IGxlbmd0aCAtIDEgOiAwO1xuICAgIHZhciBpID0gSVNfUklHSFQgPyAtMSA6IDE7XG4gICAgaWYgKGFyZ3VtZW50c0xlbmd0aCA8IDIpIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAoaW5kZXggaW4gc2VsZikge1xuICAgICAgICBtZW1vID0gc2VsZltpbmRleF07XG4gICAgICAgIGluZGV4ICs9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaW5kZXggKz0gaTtcbiAgICAgIGlmIChJU19SSUdIVCA/IGluZGV4IDwgMCA6IGxlbmd0aCA8PSBpbmRleCkge1xuICAgICAgICB0aHJvdyAkVHlwZUVycm9yJDUoJ1JlZHVjZSBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yICg7SVNfUklHSFQgPyBpbmRleCA+PSAwIDogbGVuZ3RoID4gaW5kZXg7IGluZGV4ICs9IGkpIGlmIChpbmRleCBpbiBzZWxmKSB7XG4gICAgICBtZW1vID0gY2FsbGJhY2tmbihtZW1vLCBzZWxmW2luZGV4XSwgaW5kZXgsIE8pO1xuICAgIH1cbiAgICByZXR1cm4gbWVtbztcbiAgfTtcbn07XG5cbnZhciBhcnJheVJlZHVjZSA9IHtcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5yZWR1Y2VgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5yZWR1Y2VcbiAgbGVmdDogY3JlYXRlTWV0aG9kKGZhbHNlKSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5yZWR1Y2VSaWdodGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnJlZHVjZXJpZ2h0XG4gIHJpZ2h0OiBjcmVhdGVNZXRob2QodHJ1ZSlcbn07XG5cbnZhciBjbGFzc29mJDIgPSBjbGFzc29mUmF3JDE7XG52YXIgZ2xvYmFsJDkgPSBnbG9iYWwkaztcblxudmFyIGVuZ2luZUlzTm9kZSA9IGNsYXNzb2YkMihnbG9iYWwkOS5wcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG5cbnZhciAkJDcgPSBfZXhwb3J0O1xudmFyICRyZWR1Y2UgPSBhcnJheVJlZHVjZS5sZWZ0O1xudmFyIGFycmF5TWV0aG9kSXNTdHJpY3QgPSBhcnJheU1ldGhvZElzU3RyaWN0JDI7XG52YXIgQ0hST01FX1ZFUlNJT04gPSBlbmdpbmVWOFZlcnNpb247XG52YXIgSVNfTk9ERSQzID0gZW5naW5lSXNOb2RlO1xuXG52YXIgU1RSSUNUX01FVEhPRCA9IGFycmF5TWV0aG9kSXNTdHJpY3QoJ3JlZHVjZScpO1xuLy8gQ2hyb21lIDgwLTgyIGhhcyBhIGNyaXRpY2FsIGJ1Z1xuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MTA0OTk4MlxudmFyIENIUk9NRV9CVUcgPSAhSVNfTk9ERSQzICYmIENIUk9NRV9WRVJTSU9OID4gNzkgJiYgQ0hST01FX1ZFUlNJT04gPCA4MztcblxuLy8gYEFycmF5LnByb3RvdHlwZS5yZWR1Y2VgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUucmVkdWNlXG4kJDcoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6ICFTVFJJQ1RfTUVUSE9EIHx8IENIUk9NRV9CVUcgfSwge1xuICByZWR1Y2U6IGZ1bmN0aW9uIHJlZHVjZShjYWxsYmFja2ZuIC8qICwgaW5pdGlhbFZhbHVlICovKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgcmV0dXJuICRyZWR1Y2UodGhpcywgY2FsbGJhY2tmbiwgbGVuZ3RoLCBsZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG5cbnZhciAkJDYgPSBfZXhwb3J0O1xudmFyIERFU0NSSVBUT1JTJDEgPSBkZXNjcmlwdG9ycztcbnZhciBnbG9iYWwkOCA9IGdsb2JhbCRrO1xudmFyIHVuY3VycnlUaGlzJDMgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGhhc093biQyID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBpc0NhbGxhYmxlJDUgPSBpc0NhbGxhYmxlJGw7XG52YXIgaXNQcm90b3R5cGVPZiQzID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbnZhciB0b1N0cmluZyA9IHRvU3RyaW5nJDM7XG52YXIgZGVmaW5lUHJvcGVydHkgPSBvYmplY3REZWZpbmVQcm9wZXJ0eS5mO1xudmFyIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMgPSBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzJDI7XG5cbnZhciBOYXRpdmVTeW1ib2wgPSBnbG9iYWwkOC5TeW1ib2w7XG52YXIgU3ltYm9sUHJvdG90eXBlID0gTmF0aXZlU3ltYm9sICYmIE5hdGl2ZVN5bWJvbC5wcm90b3R5cGU7XG5cbmlmIChERVNDUklQVE9SUyQxICYmIGlzQ2FsbGFibGUkNShOYXRpdmVTeW1ib2wpICYmICghKCdkZXNjcmlwdGlvbicgaW4gU3ltYm9sUHJvdG90eXBlKSB8fFxuICAvLyBTYWZhcmkgMTIgYnVnXG4gIE5hdGl2ZVN5bWJvbCgpLmRlc2NyaXB0aW9uICE9PSB1bmRlZmluZWRcbikpIHtcbiAgdmFyIEVtcHR5U3RyaW5nRGVzY3JpcHRpb25TdG9yZSA9IHt9O1xuICAvLyB3cmFwIFN5bWJvbCBjb25zdHJ1Y3RvciBmb3IgY29ycmVjdCB3b3JrIHdpdGggdW5kZWZpbmVkIGRlc2NyaXB0aW9uXG4gIHZhciBTeW1ib2xXcmFwcGVyID0gZnVuY3Rpb24gU3ltYm9sKCkge1xuICAgIHZhciBkZXNjcmlwdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPCAxIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogdG9TdHJpbmcoYXJndW1lbnRzWzBdKTtcbiAgICB2YXIgcmVzdWx0ID0gaXNQcm90b3R5cGVPZiQzKFN5bWJvbFByb3RvdHlwZSwgdGhpcylcbiAgICAgID8gbmV3IE5hdGl2ZVN5bWJvbChkZXNjcmlwdGlvbilcbiAgICAgIC8vIGluIEVkZ2UgMTMsIFN0cmluZyhTeW1ib2wodW5kZWZpbmVkKSkgPT09ICdTeW1ib2wodW5kZWZpbmVkKSdcbiAgICAgIDogZGVzY3JpcHRpb24gPT09IHVuZGVmaW5lZCA/IE5hdGl2ZVN5bWJvbCgpIDogTmF0aXZlU3ltYm9sKGRlc2NyaXB0aW9uKTtcbiAgICBpZiAoZGVzY3JpcHRpb24gPT09ICcnKSBFbXB0eVN0cmluZ0Rlc2NyaXB0aW9uU3RvcmVbcmVzdWx0XSA9IHRydWU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzKFN5bWJvbFdyYXBwZXIsIE5hdGl2ZVN5bWJvbCk7XG4gIFN5bWJvbFdyYXBwZXIucHJvdG90eXBlID0gU3ltYm9sUHJvdG90eXBlO1xuICBTeW1ib2xQcm90b3R5cGUuY29uc3RydWN0b3IgPSBTeW1ib2xXcmFwcGVyO1xuXG4gIHZhciBOQVRJVkVfU1lNQk9MID0gU3RyaW5nKE5hdGl2ZVN5bWJvbCgndGVzdCcpKSA9PSAnU3ltYm9sKHRlc3QpJztcbiAgdmFyIHN5bWJvbFRvU3RyaW5nID0gdW5jdXJyeVRoaXMkMyhTeW1ib2xQcm90b3R5cGUudG9TdHJpbmcpO1xuICB2YXIgc3ltYm9sVmFsdWVPZiA9IHVuY3VycnlUaGlzJDMoU3ltYm9sUHJvdG90eXBlLnZhbHVlT2YpO1xuICB2YXIgcmVnZXhwID0gL15TeW1ib2xcXCgoLiopXFwpW14pXSskLztcbiAgdmFyIHJlcGxhY2UgPSB1bmN1cnJ5VGhpcyQzKCcnLnJlcGxhY2UpO1xuICB2YXIgc3RyaW5nU2xpY2UgPSB1bmN1cnJ5VGhpcyQzKCcnLnNsaWNlKTtcblxuICBkZWZpbmVQcm9wZXJ0eShTeW1ib2xQcm90b3R5cGUsICdkZXNjcmlwdGlvbicsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiBkZXNjcmlwdGlvbigpIHtcbiAgICAgIHZhciBzeW1ib2wgPSBzeW1ib2xWYWx1ZU9mKHRoaXMpO1xuICAgICAgdmFyIHN0cmluZyA9IHN5bWJvbFRvU3RyaW5nKHN5bWJvbCk7XG4gICAgICBpZiAoaGFzT3duJDIoRW1wdHlTdHJpbmdEZXNjcmlwdGlvblN0b3JlLCBzeW1ib2wpKSByZXR1cm4gJyc7XG4gICAgICB2YXIgZGVzYyA9IE5BVElWRV9TWU1CT0wgPyBzdHJpbmdTbGljZShzdHJpbmcsIDcsIC0xKSA6IHJlcGxhY2Uoc3RyaW5nLCByZWdleHAsICckMScpO1xuICAgICAgcmV0dXJuIGRlc2MgPT09ICcnID8gdW5kZWZpbmVkIDogZGVzYztcbiAgICB9XG4gIH0pO1xuXG4gICQkNih7IGdsb2JhbDogdHJ1ZSwgY29uc3RydWN0b3I6IHRydWUsIGZvcmNlZDogdHJ1ZSB9LCB7XG4gICAgU3ltYm9sOiBTeW1ib2xXcmFwcGVyXG4gIH0pO1xufVxuXG5jb25zdCBXYXJuaW5nSWNvbiA9ICgpID0+IHtcbiAgcmV0dXJuIGpzeHMoXCJzdmdcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgd2lkdGg6IFwiMThcIixcbiAgICBoZWlnaHQ6IFwiMThcIixcbiAgICB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiLFxuICAgIGZpbGw6IFwibm9uZVwiLFxuICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbiAgfSwge1xuICAgIGNoaWxkcmVuOiBbanN4KFwicGF0aFwiLCB7XG4gICAgICBkOiBcIk00Ljk1MjE1IDE2LjM1MzZMMTAuMjE1MiA1Ljg1NjU3QzEwLjk1MzEgNC4zODQ4MSAxMy4wNTM4IDQuMzg1MTkgMTMuNzkxMiA1Ljg1NzIzTDE5LjA0OTQgMTYuMzU0M0MxOS43MTU2IDE3LjY4NDEgMTguNzQ4NiAxOS4yNSAxNy4yNjEyIDE5LjI1SDYuNzQwMDFDNS4yNTIyOCAxOS4yNSA0LjI4NTM1IDE3LjY4MzUgNC45NTIxNSAxNi4zNTM2WlwiLFxuICAgICAgc3Ryb2tlOiBcIiNFNkI3M0VcIixcbiAgICAgIHN0cm9rZVdpZHRoOiBcIjEuNVwiLFxuICAgICAgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLFxuICAgICAgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIlxuICAgIH0pLCBqc3goXCJwYXRoXCIsIHtcbiAgICAgIGQ6IFwiTTEyIDEwVjEyXCIsXG4gICAgICBzdHJva2U6IFwiI0U2QjczRVwiLFxuICAgICAgc3Ryb2tlV2lkdGg6IFwiMlwiLFxuICAgICAgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLFxuICAgICAgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIlxuICAgIH0pLCBqc3goXCJwYXRoXCIsIHtcbiAgICAgIGQ6IFwiTTEyLjUgMTZDMTIuNSAxNi4yNzYxIDEyLjI3NjEgMTYuNSAxMiAxNi41QzExLjcyMzkgMTYuNSAxMS41IDE2LjI3NjEgMTEuNSAxNkMxMS41IDE1LjcyMzkgMTEuNzIzOSAxNS41IDEyIDE1LjVDMTIuMjc2MSAxNS41IDEyLjUgMTUuNzIzOSAxMi41IDE2WlwiLFxuICAgICAgc3Ryb2tlOiBcIiNFNkI3M0VcIlxuICAgIH0pXVxuICB9KSk7XG59O1xuXG5jb25zdCBXYWxsZXRPcHRpb25zID0gKHtcbiAgc2VsZWN0b3IsXG4gIGhhbmRsZVdhbGxldENsaWNrXG59KSA9PiB7XG4gIGNvbnN0IFttb2R1bGVzLCBzZXRNb2R1bGVzXSA9IHVzZVN0YXRlKFtdKTtcbiAgY29uc3QgW3JlY2VudE1vZHVsZXMsIHNldFJlY2VudE1vZHVsZXNdID0gdXNlU3RhdGUoW10pO1xuICBjb25zdCBbbW9yZU1vZHVsZXMsIHNldE1vcmVNb2R1bGVzXSA9IHVzZVN0YXRlKFtdKTtcbiAgY29uc3QgW2FjdGl2ZVdhbGxldElkLCBzZXRBY3RpdmVXYWxsZXRJZF0gPSB1c2VTdGF0ZShcIlwiKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBzZWxlY3Rvci5zdG9yZS5vYnNlcnZhYmxlLnN1YnNjcmliZShzdGF0ZSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNlbGVjdGVkV2FsbGV0SWRcbiAgICAgIH0gPSBzZWxlY3Rvci5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgaWYgKHNlbGVjdGVkV2FsbGV0SWQpIHtcbiAgICAgICAgc2V0QWN0aXZlV2FsbGV0SWQoc2VsZWN0ZWRXYWxsZXRJZCk7XG4gICAgICB9XG4gICAgICBjb25zdCB3YWxsZXRzID0gc3RhdGUubW9kdWxlcy5maWx0ZXIobW9kdWxlID0+ICEobW9kdWxlLnR5cGUgPT09IFwiaW5zdGFudC1saW5rXCIgJiYgc2VsZWN0ZWRXYWxsZXRJZCAhPT0gbW9kdWxlLmlkKSk7XG4gICAgICBpZiAoc2VsZWN0b3Iub3B0aW9ucy5vcHRpbWl6ZVdhbGxldE9yZGVyKSB7XG4gICAgICAgIHN0YXRlLm1vZHVsZXMuc29ydCgoY3VycmVudCwgbmV4dCkgPT4ge1xuICAgICAgICAgIGlmIChjdXJyZW50Lm1ldGFkYXRhLmRlcHJlY2F0ZWQgPT09IG5leHQubWV0YWRhdGEuZGVwcmVjYXRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjdXJyZW50Lm1ldGFkYXRhLmRlcHJlY2F0ZWQgPyAxIDogLTE7XG4gICAgICAgIH0pO1xuICAgICAgICBzdGF0ZS5tb2R1bGVzLnNvcnQoKGN1cnJlbnQsIG5leHQpID0+IHtcbiAgICAgICAgICBpZiAobmV4dC5tZXRhZGF0YS5hdmFpbGFibGUgPT09IGN1cnJlbnQubWV0YWRhdGEuYXZhaWxhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5leHQubWV0YWRhdGEuYXZhaWxhYmxlID8gMSA6IC0xO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgbW9yZVdhbGxldHMgPSBbXTtcbiAgICAgICAgY29uc3QgcmVjZW50bHlTaWduZWRJbldhbGxldHMgPSBbXTtcbiAgICAgICAgd2FsbGV0cy5mb3JFYWNoKG1vZHVsZSA9PiB7XG4gICAgICAgICAgaWYgKHNlbGVjdG9yLnN0b3JlLmdldFN0YXRlKCkucmVjZW50bHlTaWduZWRJbldhbGxldHMuaW5jbHVkZXMobW9kdWxlLmlkKSkge1xuICAgICAgICAgICAgcmVjZW50bHlTaWduZWRJbldhbGxldHMucHVzaChtb2R1bGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtb3JlV2FsbGV0cy5wdXNoKG1vZHVsZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgc2V0UmVjZW50TW9kdWxlcyhyZWNlbnRseVNpZ25lZEluV2FsbGV0cyk7XG4gICAgICAgIHNldE1vcmVNb2R1bGVzKG1vcmVXYWxsZXRzKTtcbiAgICAgIH1cbiAgICAgIGlmIChzZWxlY3Rvci5vcHRpb25zLnJhbmRvbWl6ZVdhbGxldE9yZGVyKSB7XG4gICAgICAgIHNldE1vZHVsZXMod2FsbGV0cy5zb3J0KCgpID0+IE1hdGgucmFuZG9tKCkgLSAwLjUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldE1vZHVsZXMod2FsbGV0cyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgW10pO1xuICBmdW5jdGlvbiByZW5kZXJPcHRpb25zTGlzdChtb2R1bGVzVG9SZW5kZXIpIHtcbiAgICByZXR1cm4gbW9kdWxlc1RvUmVuZGVyLnJlZHVjZSgocmVzdWx0LCBtb2R1bGUsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNlbGVjdGVkV2FsbGV0SWRcbiAgICAgIH0gPSBzZWxlY3Rvci5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBuYW1lLFxuICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgaWNvblVybCxcbiAgICAgICAgZGVwcmVjYXRlZFxuICAgICAgfSA9IG1vZHVsZS5tZXRhZGF0YTtcbiAgICAgIGNvbnN0IHNlbGVjdGVkID0gbW9kdWxlLmlkID09PSBzZWxlY3RlZFdhbGxldElkO1xuICAgICAgcmVzdWx0LnB1c2goanN4cyhcImxpXCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICB0YWJJbmRleDogMCxcbiAgICAgICAgY2xhc3NOYW1lOiBgc2luZ2xlLXdhbGxldCAke2FjdGl2ZVdhbGxldElkID09PSBtb2R1bGUuaWQgPyBcInNlbGVjdGVkLXdhbGxldFwiIDogXCJcIn0gJHtzZWxlY3RlZCA/IFwiY29ubmVjdGVkLXdhbGxldFwiIDogXCJcIn0gJHtkZXByZWNhdGVkID8gXCJkZXByZWNhdGVkLXdhbGxldFwiIDogXCJcIn0gc2lkZWJhciAke21vZHVsZS5pZH1gLFxuICAgICAgICBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICAgICAgaWYgKG1vZHVsZS5pZCA9PT0gbW9kdWxlc1RvUmVuZGVyW2luZGV4XS5pZCkge1xuICAgICAgICAgICAgc2V0QWN0aXZlV2FsbGV0SWQobW9kdWxlLmlkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGhhbmRsZVdhbGxldENsaWNrKG1vZHVsZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAgY2hpbGRyZW46IFtqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcImljb25cIlxuICAgICAgICB9LCB7XG4gICAgICAgICAgY2hpbGRyZW46IGpzeChcImltZ1wiLCB7XG4gICAgICAgICAgICBzcmM6IGljb25VcmwsXG4gICAgICAgICAgICBhbHQ6IG5hbWVcbiAgICAgICAgICB9KVxuICAgICAgICB9KSksIGpzeHMoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcImNvbnRlbnRcIlxuICAgICAgICB9LCB7XG4gICAgICAgICAgY2hpbGRyZW46IFtqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwidGl0bGVcIlxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBuYW1lXG4gICAgICAgICAgfSkpLCBqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwiZGVzY3JpcHRpb25cIlxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBkZXNjcmlwdGlvblxuICAgICAgICAgIH0pKV1cbiAgICAgICAgfSkpLCBkZXByZWNhdGVkICYmIGpzeChcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICBjbGFzc05hbWU6IFwid2FybmluZy10cmlhbmdsZVwiXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBjaGlsZHJlbjoganN4KFdhcm5pbmdJY29uLCB7fSlcbiAgICAgICAgfSkpXVxuICAgICAgfSksIG1vZHVsZS5pZCkpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCBbXSk7XG4gIH1cbiAgcmV0dXJuIGpzeChcImRpdlwiLCB7XG4gICAgY2hpbGRyZW46IHNlbGVjdG9yLm9wdGlvbnMub3B0aW1pemVXYWxsZXRPcmRlciAmJiBzZWxlY3Rvci5zdG9yZS5nZXRTdGF0ZSgpLnJlY2VudGx5U2lnbmVkSW5XYWxsZXRzLmxlbmd0aCA+IDAgPyBqc3hzKFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgY2xhc3NOYW1lOiBcIndhbGxldC1vcHRpb25zLXdyYXBwZXJcIlxuICAgIH0sIHtcbiAgICAgIGNoaWxkcmVuOiBbanN4cyhcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgY2xhc3NOYW1lOiBcIm9wdGlvbnMtbGlzdC1zZWN0aW9uXCJcbiAgICAgIH0sIHtcbiAgICAgICAgY2hpbGRyZW46IFtqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcIm9wdGlvbnMtbGlzdC1zZWN0aW9uLWhlYWRlclwiXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBjaGlsZHJlbjogXCJSZWNlbnRcIlxuICAgICAgICB9KSksIGpzeChcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICBjbGFzc05hbWU6IFwib3B0aW9ucy1saXN0IG1vcmUtb3B0aW9ucy1saXN0LWNvbnRlbnRcIlxuICAgICAgICB9LCB7XG4gICAgICAgICAgY2hpbGRyZW46IHJlbmRlck9wdGlvbnNMaXN0KHJlY2VudE1vZHVsZXMpXG4gICAgICAgIH0pKV1cbiAgICAgIH0pKSwganN4cyhcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgY2xhc3NOYW1lOiBcIm9wdGlvbnMtbGlzdC1zZWN0aW9uXCJcbiAgICAgIH0sIHtcbiAgICAgICAgY2hpbGRyZW46IFtqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcIm9wdGlvbnMtbGlzdC1zZWN0aW9uLWhlYWRlclwiXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBjaGlsZHJlbjogXCJNb3JlXCJcbiAgICAgICAgfSkpLCBqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcIm9wdGlvbnMtbGlzdCBtb3JlLW9wdGlvbnMtbGlzdC1jb250ZW50XCJcbiAgICAgICAgfSwge1xuICAgICAgICAgIGNoaWxkcmVuOiByZW5kZXJPcHRpb25zTGlzdChtb3JlTW9kdWxlcylcbiAgICAgICAgfSkpXVxuICAgICAgfSkpXVxuICAgIH0pKSA6IGpzeChcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgIGNsYXNzTmFtZTogXCJ3YWxsZXQtb3B0aW9ucy13cmFwcGVyXCJcbiAgICB9LCB7XG4gICAgICBjaGlsZHJlbjoganN4KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBjbGFzc05hbWU6IFwib3B0aW9ucy1saXN0XCJcbiAgICAgIH0sIHtcbiAgICAgICAgY2hpbGRyZW46IHJlbmRlck9wdGlvbnNMaXN0KG1vZHVsZXMpXG4gICAgICB9KSlcbiAgICB9KSlcbiAgfSk7XG59O1xuXG5jb25zdCBDb25uZWN0aW9uRXJyb3JJY29uID0gKCkgPT4ge1xuICByZXR1cm4ganN4cyhcInN2Z1wiLCBPYmplY3QuYXNzaWduKHtcbiAgICB3aWR0aDogXCIyMVwiLFxuICAgIGhlaWdodDogXCIyMFwiLFxuICAgIHZpZXdCb3g6IFwiMCAwIDIxIDIwXCIsXG4gICAgZmlsbDogXCJub25lXCIsXG4gICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICB9LCB7XG4gICAgY2hpbGRyZW46IFtqc3goXCJwYXRoXCIsIHtcbiAgICAgIGQ6IFwiTTEwLjUwMDEgMTguMzMzM0MxNS4xMDI1IDE4LjMzMzMgMTguODMzNCAxNC42MDIzIDE4LjgzMzQgOS45OTk5NkMxOC44MzM0IDUuMzk3NTkgMTUuMTAyNSAxLjY2NjYzIDEwLjUwMDEgMS42NjY2M0M1Ljg5NzcxIDEuNjY2NjMgMi4xNjY3NSA1LjM5NzU5IDIuMTY2NzUgOS45OTk5NkMyLjE2Njc1IDE0LjYwMjMgNS44OTc3MSAxOC4zMzMzIDEwLjUwMDEgMTguMzMzM1pcIixcbiAgICAgIHN0cm9rZTogXCIjQ0U1QTZGXCIsXG4gICAgICBzdHJva2VXaWR0aDogXCIyXCIsXG4gICAgICBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsXG4gICAgICBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiXG4gICAgfSksIGpzeChcInBhdGhcIiwge1xuICAgICAgZDogXCJNMTMgNy41TDggMTIuNVwiLFxuICAgICAgc3Ryb2tlOiBcIiNDRTVBNkZcIixcbiAgICAgIHN0cm9rZVdpZHRoOiBcIjJcIixcbiAgICAgIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIixcbiAgICAgIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCJcbiAgICB9KSwganN4KFwicGF0aFwiLCB7XG4gICAgICBkOiBcIk04IDcuNUwxMyAxMi41XCIsXG4gICAgICBzdHJva2U6IFwiI0NFNUE2RlwiLFxuICAgICAgc3Ryb2tlV2lkdGg6IFwiMlwiLFxuICAgICAgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLFxuICAgICAgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIlxuICAgIH0pXVxuICB9KSk7XG59O1xuXG5jb25zdCBDb25uZWN0aW9uU3VjY2Vzc0ljb24gPSAoKSA9PiB7XG4gIHJldHVybiBqc3hzKFwic3ZnXCIsIE9iamVjdC5hc3NpZ24oe1xuICAgIHdpZHRoOiBcIjIxXCIsXG4gICAgaGVpZ2h0OiBcIjIwXCIsXG4gICAgdmlld0JveDogXCIwIDAgMjEgMjBcIixcbiAgICBmaWxsOiBcIm5vbmVcIixcbiAgICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gIH0sIHtcbiAgICBjaGlsZHJlbjogW2pzeChcInBhdGhcIiwge1xuICAgICAgZDogXCJNMTguODMzMyA5LjIzMzNWOS45OTk5N0MxOC44MzIzIDExLjc5NyAxOC4yNTA0IDEzLjU0NTUgMTcuMTc0NCAxNC45ODQ4QzE2LjA5ODQgMTYuNDI0MSAxNC41ODYgMTcuNDc3IDEyLjg2MjggMTcuOTg2NkMxMS4xMzk1IDE4LjQ5NjEgOS4yOTc2OCAxOC40MzQ5IDcuNjEyMDIgMTcuODEyMUM1LjkyNjM2IDE3LjE4OTQgNC40ODcxNyAxNi4wMzg0IDMuNTA5MDkgMTQuNTMwOUMyLjUzMTAxIDEzLjAyMzMgMi4wNjY0NSAxMS4yNCAyLjE4NDY5IDkuNDQ2OUMyLjMwMjkzIDcuNjUzNzcgMi45OTc2MyA1Ljk0NjkxIDQuMTY1MTkgNC41ODA4NkM1LjMzMjc1IDMuMjE0ODIgNi45MTA2MSAyLjI2Mjc5IDguNjYzNDUgMS44NjY3NkMxMC40MTYzIDEuNDcwNzMgMTIuMjUwMiAxLjY1MTkyIDEzLjg5MTYgMi4zODMzXCIsXG4gICAgICBzdHJva2U6IFwiIzRGRDk4RlwiLFxuICAgICAgc3Ryb2tlV2lkdGg6IFwiMlwiLFxuICAgICAgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLFxuICAgICAgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIlxuICAgIH0pLCBqc3goXCJwYXRoXCIsIHtcbiAgICAgIGQ6IFwiTTE4LjgzMzMgMy4zMzMzN0wxMC41IDExLjY3NUw4IDkuMTc1MDRcIixcbiAgICAgIHN0cm9rZTogXCIjNEZEOThGXCIsXG4gICAgICBzdHJva2VXaWR0aDogXCIyXCIsXG4gICAgICBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsXG4gICAgICBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiXG4gICAgfSldXG4gIH0pKTtcbn07XG5cbmNvbnN0IENvbm5lY3Rpb25SZXN1bHQgPSAoe1xuICBtb2R1bGUsXG4gIG1lc3NhZ2UsXG4gIGVycixcbiAgb25SZXRyeVxufSkgPT4ge1xuICByZXR1cm4ganN4KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgIGNsYXNzTmFtZTogXCJjb25uZWN0aW9uIGNvbm5lY3RpbmctZGV0YWlsc1wiXG4gIH0sIHtcbiAgICBjaGlsZHJlbjogZXJyID8ganN4cyhcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgIGNsYXNzTmFtZTogXCJlcnJvci13cmFwcGVyXCJcbiAgICB9LCB7XG4gICAgICBjaGlsZHJlbjogW2pzeHMoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGNsYXNzTmFtZTogXCJlcnJvclwiXG4gICAgICB9LCB7XG4gICAgICAgIGNoaWxkcmVuOiBbanN4KENvbm5lY3Rpb25FcnJvckljb24sIHt9KSwgdHJhbnNsYXRlKFwibW9kYWwud2FsbGV0LmNvbm5lY3Rpb25GYWlsZWRcIildXG4gICAgICB9KSksIGpzeChcInBcIiwge1xuICAgICAgICBjaGlsZHJlbjogbWVzc2FnZVxuICAgICAgfSksIChtb2R1bGUgPT09IG51bGwgfHwgbW9kdWxlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtb2R1bGUubWV0YWRhdGEuYXZhaWxhYmxlKSAmJiBqc3goXCJidXR0b25cIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIG9uQ2xpY2s6IG9uUmV0cnlcbiAgICAgIH0sIHtcbiAgICAgICAgY2hpbGRyZW46IHRyYW5zbGF0ZShcIm1vZGFsLmxlZGdlci5yZXRyeVwiKVxuICAgICAgfSkpXVxuICAgIH0pKSA6IGpzeHMoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICBjbGFzc05hbWU6IFwic3VjY2Vzc1wiXG4gICAgfSwge1xuICAgICAgY2hpbGRyZW46IFtqc3goQ29ubmVjdGlvblN1Y2Nlc3NJY29uLCB7fSksIHRyYW5zbGF0ZShcIm1vZGFsLndhbGxldC5jb25uZWN0aW9uU3VjY2Vzc2Z1bFwiKV1cbiAgICB9KSlcbiAgfSkpO1xufTtcblxuY29uc3QgQWxlcnRNZXNzYWdlID0gKHtcbiAgbWVzc2FnZSxcbiAgbW9kdWxlLFxuICBvbkJhY2ssXG4gIG9uQ2xvc2VNb2RhbFxufSkgPT4ge1xuICByZXR1cm4ganN4cyhGcmFnbWVudCwge1xuICAgIGNoaWxkcmVuOiBbanN4KE1vZGFsSGVhZGVyLCB7XG4gICAgICB0aXRsZTogXCJcIixcbiAgICAgIG9uQ2xvc2VNb2RhbDogb25DbG9zZU1vZGFsXG4gICAgfSksIGpzeChcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgIGNsYXNzTmFtZTogXCJhbGVydC1tZXNzYWdlIGNvbm5lY3Rpbmctd3JhcHBlciBjb25uZWN0aW5nLXdyYXBwZXItZXJyXCJcbiAgICB9LCB7XG4gICAgICBjaGlsZHJlbjoganN4cyhcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImNvbnRlbnRcIlxuICAgICAgfSwge1xuICAgICAgICBjaGlsZHJlbjogW2pzeChcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICBjbGFzc05hbWU6IFwiaWNvblwiXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBjaGlsZHJlbjoganN4KFwiaW1nXCIsIHtcbiAgICAgICAgICAgIHNyYzogbW9kdWxlID09PSBudWxsIHx8IG1vZHVsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbW9kdWxlLm1ldGFkYXRhLmljb25VcmwsXG4gICAgICAgICAgICBhbHQ6IG1vZHVsZSA9PT0gbnVsbCB8fCBtb2R1bGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1vZHVsZS5tZXRhZGF0YS5uYW1lXG4gICAgICAgICAgfSlcbiAgICAgICAgfSkpLCBqc3goXCJoM1wiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICBjbGFzc05hbWU6IFwiY29ubmVjdGluZy1uYW1lXCJcbiAgICAgICAgfSwge1xuICAgICAgICAgIGNoaWxkcmVuOiBtb2R1bGUgPT09IG51bGwgfHwgbW9kdWxlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtb2R1bGUubWV0YWRhdGEubmFtZVxuICAgICAgICB9KSksIGpzeChDb25uZWN0aW9uUmVzdWx0LCB7XG4gICAgICAgICAgbW9kdWxlOiBtb2R1bGUsXG4gICAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICBlcnI6IG1lc3NhZ2UgIT09IG51bGwsXG4gICAgICAgICAgb25SZXRyeTogKCkgPT4ge1xuICAgICAgICAgICAgb25CYWNrKHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSldXG4gICAgICB9KSlcbiAgICB9KSldXG4gIH0pO1xufTtcblxudmFyIGdldEJ1aWx0SW4kMyA9IGdldEJ1aWx0SW4kODtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IG9iamVjdERlZmluZVByb3BlcnR5O1xudmFyIHdlbGxLbm93blN5bWJvbCQ1ID0gd2VsbEtub3duU3ltYm9sJGc7XG52YXIgREVTQ1JJUFRPUlMgPSBkZXNjcmlwdG9ycztcblxudmFyIFNQRUNJRVMkMiA9IHdlbGxLbm93blN5bWJvbCQ1KCdzcGVjaWVzJyk7XG5cbnZhciBzZXRTcGVjaWVzJDEgPSBmdW5jdGlvbiAoQ09OU1RSVUNUT1JfTkFNRSkge1xuICB2YXIgQ29uc3RydWN0b3IgPSBnZXRCdWlsdEluJDMoQ09OU1RSVUNUT1JfTkFNRSk7XG4gIHZhciBkZWZpbmVQcm9wZXJ0eSA9IGRlZmluZVByb3BlcnR5TW9kdWxlLmY7XG5cbiAgaWYgKERFU0NSSVBUT1JTICYmIENvbnN0cnVjdG9yICYmICFDb25zdHJ1Y3RvcltTUEVDSUVTJDJdKSB7XG4gICAgZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFNQRUNJRVMkMiwge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9XG4gICAgfSk7XG4gIH1cbn07XG5cbnZhciBpc1Byb3RvdHlwZU9mJDIgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xuXG52YXIgJFR5cGVFcnJvciQ0ID0gVHlwZUVycm9yO1xuXG52YXIgYW5JbnN0YW5jZSQxID0gZnVuY3Rpb24gKGl0LCBQcm90b3R5cGUpIHtcbiAgaWYgKGlzUHJvdG90eXBlT2YkMihQcm90b3R5cGUsIGl0KSkgcmV0dXJuIGl0O1xuICB0aHJvdyAkVHlwZUVycm9yJDQoJ0luY29ycmVjdCBpbnZvY2F0aW9uJyk7XG59O1xuXG52YXIgdW5jdXJyeVRoaXMkMiA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgZmFpbHMkMiA9IGZhaWxzJGg7XG52YXIgaXNDYWxsYWJsZSQ0ID0gaXNDYWxsYWJsZSRsO1xudmFyIGNsYXNzb2YkMSA9IGNsYXNzb2YkNTtcbnZhciBnZXRCdWlsdEluJDIgPSBnZXRCdWlsdEluJDg7XG52YXIgaW5zcGVjdFNvdXJjZSQxID0gaW5zcGVjdFNvdXJjZSQ0O1xuXG52YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbnZhciBlbXB0eSA9IFtdO1xudmFyIGNvbnN0cnVjdCA9IGdldEJ1aWx0SW4kMignUmVmbGVjdCcsICdjb25zdHJ1Y3QnKTtcbnZhciBjb25zdHJ1Y3RvclJlZ0V4cCA9IC9eXFxzKig/OmNsYXNzfGZ1bmN0aW9uKVxcYi87XG52YXIgZXhlYyA9IHVuY3VycnlUaGlzJDIoY29uc3RydWN0b3JSZWdFeHAuZXhlYyk7XG52YXIgSU5DT1JSRUNUX1RPX1NUUklORyA9ICFjb25zdHJ1Y3RvclJlZ0V4cC5leGVjKG5vb3ApO1xuXG52YXIgaXNDb25zdHJ1Y3Rvck1vZGVybiA9IGZ1bmN0aW9uIGlzQ29uc3RydWN0b3IoYXJndW1lbnQpIHtcbiAgaWYgKCFpc0NhbGxhYmxlJDQoYXJndW1lbnQpKSByZXR1cm4gZmFsc2U7XG4gIHRyeSB7XG4gICAgY29uc3RydWN0KG5vb3AsIGVtcHR5LCBhcmd1bWVudCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG52YXIgaXNDb25zdHJ1Y3RvckxlZ2FjeSA9IGZ1bmN0aW9uIGlzQ29uc3RydWN0b3IoYXJndW1lbnQpIHtcbiAgaWYgKCFpc0NhbGxhYmxlJDQoYXJndW1lbnQpKSByZXR1cm4gZmFsc2U7XG4gIHN3aXRjaCAoY2xhc3NvZiQxKGFyZ3VtZW50KSkge1xuICAgIGNhc2UgJ0FzeW5jRnVuY3Rpb24nOlxuICAgIGNhc2UgJ0dlbmVyYXRvckZ1bmN0aW9uJzpcbiAgICBjYXNlICdBc3luY0dlbmVyYXRvckZ1bmN0aW9uJzogcmV0dXJuIGZhbHNlO1xuICB9XG4gIHRyeSB7XG4gICAgLy8gd2UgY2FuJ3QgY2hlY2sgLnByb3RvdHlwZSBzaW5jZSBjb25zdHJ1Y3RvcnMgcHJvZHVjZWQgYnkgLmJpbmQgaGF2ZW4ndCBpdFxuICAgIC8vIGBGdW5jdGlvbiN0b1N0cmluZ2AgdGhyb3dzIG9uIHNvbWUgYnVpbHQtaXQgZnVuY3Rpb24gaW4gc29tZSBsZWdhY3kgZW5naW5lc1xuICAgIC8vIChmb3IgZXhhbXBsZSwgYERPTVF1YWRgIGFuZCBzaW1pbGFyIGluIEZGNDEtKVxuICAgIHJldHVybiBJTkNPUlJFQ1RfVE9fU1RSSU5HIHx8ICEhZXhlYyhjb25zdHJ1Y3RvclJlZ0V4cCwgaW5zcGVjdFNvdXJjZSQxKGFyZ3VtZW50KSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cbmlzQ29uc3RydWN0b3JMZWdhY3kuc2hhbSA9IHRydWU7XG5cbi8vIGBJc0NvbnN0cnVjdG9yYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaXNjb25zdHJ1Y3RvclxudmFyIGlzQ29uc3RydWN0b3IkMSA9ICFjb25zdHJ1Y3QgfHwgZmFpbHMkMihmdW5jdGlvbiAoKSB7XG4gIHZhciBjYWxsZWQ7XG4gIHJldHVybiBpc0NvbnN0cnVjdG9yTW9kZXJuKGlzQ29uc3RydWN0b3JNb2Rlcm4uY2FsbClcbiAgICB8fCAhaXNDb25zdHJ1Y3Rvck1vZGVybihPYmplY3QpXG4gICAgfHwgIWlzQ29uc3RydWN0b3JNb2Rlcm4oZnVuY3Rpb24gKCkgeyBjYWxsZWQgPSB0cnVlOyB9KVxuICAgIHx8IGNhbGxlZDtcbn0pID8gaXNDb25zdHJ1Y3RvckxlZ2FjeSA6IGlzQ29uc3RydWN0b3JNb2Rlcm47XG5cbnZhciBpc0NvbnN0cnVjdG9yID0gaXNDb25zdHJ1Y3RvciQxO1xudmFyIHRyeVRvU3RyaW5nJDIgPSB0cnlUb1N0cmluZyQ1O1xuXG52YXIgJFR5cGVFcnJvciQzID0gVHlwZUVycm9yO1xuXG4vLyBgQXNzZXJ0OiBJc0NvbnN0cnVjdG9yKGFyZ3VtZW50KSBpcyB0cnVlYFxudmFyIGFDb25zdHJ1Y3RvciQxID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmIChpc0NvbnN0cnVjdG9yKGFyZ3VtZW50KSkgcmV0dXJuIGFyZ3VtZW50O1xuICB0aHJvdyAkVHlwZUVycm9yJDModHJ5VG9TdHJpbmckMihhcmd1bWVudCkgKyAnIGlzIG5vdCBhIGNvbnN0cnVjdG9yJyk7XG59O1xuXG52YXIgYW5PYmplY3QkNiA9IGFuT2JqZWN0JGM7XG52YXIgYUNvbnN0cnVjdG9yID0gYUNvbnN0cnVjdG9yJDE7XG52YXIgd2VsbEtub3duU3ltYm9sJDQgPSB3ZWxsS25vd25TeW1ib2wkZztcblxudmFyIFNQRUNJRVMkMSA9IHdlbGxLbm93blN5bWJvbCQ0KCdzcGVjaWVzJyk7XG5cbi8vIGBTcGVjaWVzQ29uc3RydWN0b3JgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zcGVjaWVzY29uc3RydWN0b3JcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IkMSA9IGZ1bmN0aW9uIChPLCBkZWZhdWx0Q29uc3RydWN0b3IpIHtcbiAgdmFyIEMgPSBhbk9iamVjdCQ2KE8pLmNvbnN0cnVjdG9yO1xuICB2YXIgUztcbiAgcmV0dXJuIEMgPT09IHVuZGVmaW5lZCB8fCAoUyA9IGFuT2JqZWN0JDYoQylbU1BFQ0lFUyQxXSkgPT0gdW5kZWZpbmVkID8gZGVmYXVsdENvbnN0cnVjdG9yIDogYUNvbnN0cnVjdG9yKFMpO1xufTtcblxudmFyIE5BVElWRV9CSU5EJDEgPSBmdW5jdGlvbkJpbmROYXRpdmU7XG5cbnZhciBGdW5jdGlvblByb3RvdHlwZSA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbnZhciBhcHBseSQxID0gRnVuY3Rpb25Qcm90b3R5cGUuYXBwbHk7XG52YXIgY2FsbCQ4ID0gRnVuY3Rpb25Qcm90b3R5cGUuY2FsbDtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tcmVmbGVjdCAtLSBzYWZlXG52YXIgZnVuY3Rpb25BcHBseSA9IHR5cGVvZiBSZWZsZWN0ID09ICdvYmplY3QnICYmIFJlZmxlY3QuYXBwbHkgfHwgKE5BVElWRV9CSU5EJDEgPyBjYWxsJDguYmluZChhcHBseSQxKSA6IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGNhbGwkOC5hcHBseShhcHBseSQxLCBhcmd1bWVudHMpO1xufSk7XG5cbnZhciB1bmN1cnJ5VGhpcyQxID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBhQ2FsbGFibGUkNSA9IGFDYWxsYWJsZSQ5O1xudmFyIE5BVElWRV9CSU5EID0gZnVuY3Rpb25CaW5kTmF0aXZlO1xuXG52YXIgYmluZCQ0ID0gdW5jdXJyeVRoaXMkMSh1bmN1cnJ5VGhpcyQxLmJpbmQpO1xuXG4vLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBmdW5jdGlvbkJpbmRDb250ZXh0ID0gZnVuY3Rpb24gKGZuLCB0aGF0KSB7XG4gIGFDYWxsYWJsZSQ1KGZuKTtcbiAgcmV0dXJuIHRoYXQgPT09IHVuZGVmaW5lZCA/IGZuIDogTkFUSVZFX0JJTkQgPyBiaW5kJDQoZm4sIHRoYXQpIDogZnVuY3Rpb24gKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG5cbnZhciB1bmN1cnJ5VGhpcyA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG5cbnZhciBhcnJheVNsaWNlJDEgPSB1bmN1cnJ5VGhpcyhbXS5zbGljZSk7XG5cbnZhciAkVHlwZUVycm9yJDIgPSBUeXBlRXJyb3I7XG5cbnZhciB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aCQxID0gZnVuY3Rpb24gKHBhc3NlZCwgcmVxdWlyZWQpIHtcbiAgaWYgKHBhc3NlZCA8IHJlcXVpcmVkKSB0aHJvdyAkVHlwZUVycm9yJDIoJ05vdCBlbm91Z2ggYXJndW1lbnRzJyk7XG4gIHJldHVybiBwYXNzZWQ7XG59O1xuXG52YXIgdXNlckFnZW50JDIgPSBlbmdpbmVVc2VyQWdlbnQ7XG5cbnZhciBlbmdpbmVJc0lvcyA9IC8oPzppcGFkfGlwaG9uZXxpcG9kKS4qYXBwbGV3ZWJraXQvaS50ZXN0KHVzZXJBZ2VudCQyKTtcblxudmFyIGdsb2JhbCQ3ID0gZ2xvYmFsJGs7XG52YXIgYXBwbHkgPSBmdW5jdGlvbkFwcGx5O1xudmFyIGJpbmQkMyA9IGZ1bmN0aW9uQmluZENvbnRleHQ7XG52YXIgaXNDYWxsYWJsZSQzID0gaXNDYWxsYWJsZSRsO1xudmFyIGhhc093biQxID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBmYWlscyQxID0gZmFpbHMkaDtcbnZhciBodG1sID0gaHRtbCQyO1xudmFyIGFycmF5U2xpY2UgPSBhcnJheVNsaWNlJDE7XG52YXIgY3JlYXRlRWxlbWVudCA9IGRvY3VtZW50Q3JlYXRlRWxlbWVudCQyO1xudmFyIHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoID0gdmFsaWRhdGVBcmd1bWVudHNMZW5ndGgkMTtcbnZhciBJU19JT1MkMSA9IGVuZ2luZUlzSW9zO1xudmFyIElTX05PREUkMiA9IGVuZ2luZUlzTm9kZTtcblxudmFyIHNldCA9IGdsb2JhbCQ3LnNldEltbWVkaWF0ZTtcbnZhciBjbGVhciA9IGdsb2JhbCQ3LmNsZWFySW1tZWRpYXRlO1xudmFyIHByb2Nlc3MkMiA9IGdsb2JhbCQ3LnByb2Nlc3M7XG52YXIgRGlzcGF0Y2ggPSBnbG9iYWwkNy5EaXNwYXRjaDtcbnZhciBGdW5jdGlvbiQxID0gZ2xvYmFsJDcuRnVuY3Rpb247XG52YXIgTWVzc2FnZUNoYW5uZWwgPSBnbG9iYWwkNy5NZXNzYWdlQ2hhbm5lbDtcbnZhciBTdHJpbmckMSA9IGdsb2JhbCQ3LlN0cmluZztcbnZhciBjb3VudGVyID0gMDtcbnZhciBxdWV1ZSQxID0ge307XG52YXIgT05SRUFEWVNUQVRFQ0hBTkdFID0gJ29ucmVhZHlzdGF0ZWNoYW5nZSc7XG52YXIgbG9jYXRpb24sIGRlZmVyLCBjaGFubmVsLCBwb3J0O1xuXG50cnkge1xuICAvLyBEZW5vIHRocm93cyBhIFJlZmVyZW5jZUVycm9yIG9uIGBsb2NhdGlvbmAgYWNjZXNzIHdpdGhvdXQgYC0tbG9jYXRpb25gIGZsYWdcbiAgbG9jYXRpb24gPSBnbG9iYWwkNy5sb2NhdGlvbjtcbn0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cblxudmFyIHJ1biA9IGZ1bmN0aW9uIChpZCkge1xuICBpZiAoaGFzT3duJDEocXVldWUkMSwgaWQpKSB7XG4gICAgdmFyIGZuID0gcXVldWUkMVtpZF07XG4gICAgZGVsZXRlIHF1ZXVlJDFbaWRdO1xuICAgIGZuKCk7XG4gIH1cbn07XG5cbnZhciBydW5uZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBydW4oaWQpO1xuICB9O1xufTtcblxudmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHJ1bihldmVudC5kYXRhKTtcbn07XG5cbnZhciBwb3N0ID0gZnVuY3Rpb24gKGlkKSB7XG4gIC8vIG9sZCBlbmdpbmVzIGhhdmUgbm90IGxvY2F0aW9uLm9yaWdpblxuICBnbG9iYWwkNy5wb3N0TWVzc2FnZShTdHJpbmckMShpZCksIGxvY2F0aW9uLnByb3RvY29sICsgJy8vJyArIGxvY2F0aW9uLmhvc3QpO1xufTtcblxuLy8gTm9kZS5qcyAwLjkrICYgSUUxMCsgaGFzIHNldEltbWVkaWF0ZSwgb3RoZXJ3aXNlOlxuaWYgKCFzZXQgfHwgIWNsZWFyKSB7XG4gIHNldCA9IGZ1bmN0aW9uIHNldEltbWVkaWF0ZShoYW5kbGVyKSB7XG4gICAgdmFsaWRhdGVBcmd1bWVudHNMZW5ndGgoYXJndW1lbnRzLmxlbmd0aCwgMSk7XG4gICAgdmFyIGZuID0gaXNDYWxsYWJsZSQzKGhhbmRsZXIpID8gaGFuZGxlciA6IEZ1bmN0aW9uJDEoaGFuZGxlcik7XG4gICAgdmFyIGFyZ3MgPSBhcnJheVNsaWNlKGFyZ3VtZW50cywgMSk7XG4gICAgcXVldWUkMVsrK2NvdW50ZXJdID0gZnVuY3Rpb24gKCkge1xuICAgICAgYXBwbHkoZm4sIHVuZGVmaW5lZCwgYXJncyk7XG4gICAgfTtcbiAgICBkZWZlcihjb3VudGVyKTtcbiAgICByZXR1cm4gY291bnRlcjtcbiAgfTtcbiAgY2xlYXIgPSBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShpZCkge1xuICAgIGRlbGV0ZSBxdWV1ZSQxW2lkXTtcbiAgfTtcbiAgLy8gTm9kZS5qcyAwLjgtXG4gIGlmIChJU19OT0RFJDIpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgcHJvY2VzcyQyLm5leHRUaWNrKHJ1bm5lcihpZCkpO1xuICAgIH07XG4gIC8vIFNwaGVyZSAoSlMgZ2FtZSBlbmdpbmUpIERpc3BhdGNoIEFQSVxuICB9IGVsc2UgaWYgKERpc3BhdGNoICYmIERpc3BhdGNoLm5vdykge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBEaXNwYXRjaC5ub3cocnVubmVyKGlkKSk7XG4gICAgfTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBNZXNzYWdlQ2hhbm5lbCwgaW5jbHVkZXMgV2ViV29ya2Vyc1xuICAvLyBleGNlcHQgaU9TIC0gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzYyNFxuICB9IGVsc2UgaWYgKE1lc3NhZ2VDaGFubmVsICYmICFJU19JT1MkMSkge1xuICAgIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICBwb3J0ID0gY2hhbm5lbC5wb3J0MjtcbiAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGxpc3RlbmVyO1xuICAgIGRlZmVyID0gYmluZCQzKHBvcnQucG9zdE1lc3NhZ2UsIHBvcnQpO1xuICAvLyBCcm93c2VycyB3aXRoIHBvc3RNZXNzYWdlLCBza2lwIFdlYldvcmtlcnNcbiAgLy8gSUU4IGhhcyBwb3N0TWVzc2FnZSwgYnV0IGl0J3Mgc3luYyAmIHR5cGVvZiBpdHMgcG9zdE1lc3NhZ2UgaXMgJ29iamVjdCdcbiAgfSBlbHNlIGlmIChcbiAgICBnbG9iYWwkNy5hZGRFdmVudExpc3RlbmVyICYmXG4gICAgaXNDYWxsYWJsZSQzKGdsb2JhbCQ3LnBvc3RNZXNzYWdlKSAmJlxuICAgICFnbG9iYWwkNy5pbXBvcnRTY3JpcHRzICYmXG4gICAgbG9jYXRpb24gJiYgbG9jYXRpb24ucHJvdG9jb2wgIT09ICdmaWxlOicgJiZcbiAgICAhZmFpbHMkMShwb3N0KVxuICApIHtcbiAgICBkZWZlciA9IHBvc3Q7XG4gICAgZ2xvYmFsJDcuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGxpc3RlbmVyLCBmYWxzZSk7XG4gIC8vIElFOC1cbiAgfSBlbHNlIGlmIChPTlJFQURZU1RBVEVDSEFOR0UgaW4gY3JlYXRlRWxlbWVudCgnc2NyaXB0JykpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgaHRtbC5hcHBlbmRDaGlsZChjcmVhdGVFbGVtZW50KCdzY3JpcHQnKSlbT05SRUFEWVNUQVRFQ0hBTkdFXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaHRtbC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICAgICAgcnVuKGlkKTtcbiAgICAgIH07XG4gICAgfTtcbiAgLy8gUmVzdCBvbGQgYnJvd3NlcnNcbiAgfSBlbHNlIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgc2V0VGltZW91dChydW5uZXIoaWQpLCAwKTtcbiAgICB9O1xuICB9XG59XG5cbnZhciB0YXNrJDEgPSB7XG4gIHNldDogc2V0LFxuICBjbGVhcjogY2xlYXJcbn07XG5cbnZhciB1c2VyQWdlbnQkMSA9IGVuZ2luZVVzZXJBZ2VudDtcbnZhciBnbG9iYWwkNiA9IGdsb2JhbCRrO1xuXG52YXIgZW5naW5lSXNJb3NQZWJibGUgPSAvaXBhZHxpcGhvbmV8aXBvZC9pLnRlc3QodXNlckFnZW50JDEpICYmIGdsb2JhbCQ2LlBlYmJsZSAhPT0gdW5kZWZpbmVkO1xuXG52YXIgdXNlckFnZW50ID0gZW5naW5lVXNlckFnZW50O1xuXG52YXIgZW5naW5lSXNXZWJvc1dlYmtpdCA9IC93ZWIwcyg/IS4qY2hyb21lKS9pLnRlc3QodXNlckFnZW50KTtcblxudmFyIGdsb2JhbCQ1ID0gZ2xvYmFsJGs7XG52YXIgYmluZCQyID0gZnVuY3Rpb25CaW5kQ29udGV4dDtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IuZjtcbnZhciBtYWNyb3Rhc2sgPSB0YXNrJDEuc2V0O1xudmFyIElTX0lPUyA9IGVuZ2luZUlzSW9zO1xudmFyIElTX0lPU19QRUJCTEUgPSBlbmdpbmVJc0lvc1BlYmJsZTtcbnZhciBJU19XRUJPU19XRUJLSVQgPSBlbmdpbmVJc1dlYm9zV2Via2l0O1xudmFyIElTX05PREUkMSA9IGVuZ2luZUlzTm9kZTtcblxudmFyIE11dGF0aW9uT2JzZXJ2ZXIgPSBnbG9iYWwkNS5NdXRhdGlvbk9ic2VydmVyIHx8IGdsb2JhbCQ1LldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XG52YXIgZG9jdW1lbnQkMiA9IGdsb2JhbCQ1LmRvY3VtZW50O1xudmFyIHByb2Nlc3MkMSA9IGdsb2JhbCQ1LnByb2Nlc3M7XG52YXIgUHJvbWlzZSQxID0gZ2xvYmFsJDUuUHJvbWlzZTtcbi8vIE5vZGUuanMgMTEgc2hvd3MgRXhwZXJpbWVudGFsV2FybmluZyBvbiBnZXR0aW5nIGBxdWV1ZU1pY3JvdGFza2BcbnZhciBxdWV1ZU1pY3JvdGFza0Rlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZ2xvYmFsJDUsICdxdWV1ZU1pY3JvdGFzaycpO1xudmFyIHF1ZXVlTWljcm90YXNrID0gcXVldWVNaWNyb3Rhc2tEZXNjcmlwdG9yICYmIHF1ZXVlTWljcm90YXNrRGVzY3JpcHRvci52YWx1ZTtcblxudmFyIGZsdXNoLCBoZWFkLCBsYXN0LCBub3RpZnkkMSwgdG9nZ2xlLCBub2RlLCBwcm9taXNlLCB0aGVuO1xuXG4vLyBtb2Rlcm4gZW5naW5lcyBoYXZlIHF1ZXVlTWljcm90YXNrIG1ldGhvZFxuaWYgKCFxdWV1ZU1pY3JvdGFzaykge1xuICBmbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGFyZW50LCBmbjtcbiAgICBpZiAoSVNfTk9ERSQxICYmIChwYXJlbnQgPSBwcm9jZXNzJDEuZG9tYWluKSkgcGFyZW50LmV4aXQoKTtcbiAgICB3aGlsZSAoaGVhZCkge1xuICAgICAgZm4gPSBoZWFkLmZuO1xuICAgICAgaGVhZCA9IGhlYWQubmV4dDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZuKCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoaGVhZCkgbm90aWZ5JDEoKTtcbiAgICAgICAgZWxzZSBsYXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9IGxhc3QgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHBhcmVudCkgcGFyZW50LmVudGVyKCk7XG4gIH07XG5cbiAgLy8gYnJvd3NlcnMgd2l0aCBNdXRhdGlvbk9ic2VydmVyLCBleGNlcHQgaU9TIC0gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzMzOVxuICAvLyBhbHNvIGV4Y2VwdCBXZWJPUyBXZWJraXQgaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg5OFxuICBpZiAoIUlTX0lPUyAmJiAhSVNfTk9ERSQxICYmICFJU19XRUJPU19XRUJLSVQgJiYgTXV0YXRpb25PYnNlcnZlciAmJiBkb2N1bWVudCQyKSB7XG4gICAgdG9nZ2xlID0gdHJ1ZTtcbiAgICBub2RlID0gZG9jdW1lbnQkMi5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZmx1c2gpLm9ic2VydmUobm9kZSwgeyBjaGFyYWN0ZXJEYXRhOiB0cnVlIH0pO1xuICAgIG5vdGlmeSQxID0gZnVuY3Rpb24gKCkge1xuICAgICAgbm9kZS5kYXRhID0gdG9nZ2xlID0gIXRvZ2dsZTtcbiAgICB9O1xuICAvLyBlbnZpcm9ubWVudHMgd2l0aCBtYXliZSBub24tY29tcGxldGVseSBjb3JyZWN0LCBidXQgZXhpc3RlbnQgUHJvbWlzZVxuICB9IGVsc2UgaWYgKCFJU19JT1NfUEVCQkxFICYmIFByb21pc2UkMSAmJiBQcm9taXNlJDEucmVzb2x2ZSkge1xuICAgIC8vIFByb21pc2UucmVzb2x2ZSB3aXRob3V0IGFuIGFyZ3VtZW50IHRocm93cyBhbiBlcnJvciBpbiBMRyBXZWJPUyAyXG4gICAgcHJvbWlzZSA9IFByb21pc2UkMS5yZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgLy8gd29ya2Fyb3VuZCBvZiBXZWJLaXQgfiBpT1MgU2FmYXJpIDEwLjEgYnVnXG4gICAgcHJvbWlzZS5jb25zdHJ1Y3RvciA9IFByb21pc2UkMTtcbiAgICB0aGVuID0gYmluZCQyKHByb21pc2UudGhlbiwgcHJvbWlzZSk7XG4gICAgbm90aWZ5JDEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGVuKGZsdXNoKTtcbiAgICB9O1xuICAvLyBOb2RlLmpzIHdpdGhvdXQgcHJvbWlzZXNcbiAgfSBlbHNlIGlmIChJU19OT0RFJDEpIHtcbiAgICBub3RpZnkkMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHByb2Nlc3MkMS5uZXh0VGljayhmbHVzaCk7XG4gICAgfTtcbiAgLy8gZm9yIG90aGVyIGVudmlyb25tZW50cyAtIG1hY3JvdGFzayBiYXNlZCBvbjpcbiAgLy8gLSBzZXRJbW1lZGlhdGVcbiAgLy8gLSBNZXNzYWdlQ2hhbm5lbFxuICAvLyAtIHdpbmRvdy5wb3N0TWVzc2FnZVxuICAvLyAtIG9ucmVhZHlzdGF0ZWNoYW5nZVxuICAvLyAtIHNldFRpbWVvdXRcbiAgfSBlbHNlIHtcbiAgICAvLyBzdHJhbmdlIElFICsgd2VicGFjayBkZXYgc2VydmVyIGJ1ZyAtIHVzZSAuYmluZChnbG9iYWwpXG4gICAgbWFjcm90YXNrID0gYmluZCQyKG1hY3JvdGFzaywgZ2xvYmFsJDUpO1xuICAgIG5vdGlmeSQxID0gZnVuY3Rpb24gKCkge1xuICAgICAgbWFjcm90YXNrKGZsdXNoKTtcbiAgICB9O1xuICB9XG59XG5cbnZhciBtaWNyb3Rhc2skMSA9IHF1ZXVlTWljcm90YXNrIHx8IGZ1bmN0aW9uIChmbikge1xuICB2YXIgdGFzayA9IHsgZm46IGZuLCBuZXh0OiB1bmRlZmluZWQgfTtcbiAgaWYgKGxhc3QpIGxhc3QubmV4dCA9IHRhc2s7XG4gIGlmICghaGVhZCkge1xuICAgIGhlYWQgPSB0YXNrO1xuICAgIG5vdGlmeSQxKCk7XG4gIH0gbGFzdCA9IHRhc2s7XG59O1xuXG52YXIgZ2xvYmFsJDQgPSBnbG9iYWwkaztcblxudmFyIGhvc3RSZXBvcnRFcnJvcnMkMSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gIHZhciBjb25zb2xlID0gZ2xvYmFsJDQuY29uc29sZTtcbiAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS5lcnJvcikge1xuICAgIGFyZ3VtZW50cy5sZW5ndGggPT0gMSA/IGNvbnNvbGUuZXJyb3IoYSkgOiBjb25zb2xlLmVycm9yKGEsIGIpO1xuICB9XG59O1xuXG52YXIgcGVyZm9ybSQzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4geyBlcnJvcjogZmFsc2UsIHZhbHVlOiBleGVjKCkgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4geyBlcnJvcjogdHJ1ZSwgdmFsdWU6IGVycm9yIH07XG4gIH1cbn07XG5cbnZhciBRdWV1ZSQxID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmhlYWQgPSBudWxsO1xuICB0aGlzLnRhaWwgPSBudWxsO1xufTtcblxuUXVldWUkMS5wcm90b3R5cGUgPSB7XG4gIGFkZDogZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICB2YXIgZW50cnkgPSB7IGl0ZW06IGl0ZW0sIG5leHQ6IG51bGwgfTtcbiAgICBpZiAodGhpcy5oZWFkKSB0aGlzLnRhaWwubmV4dCA9IGVudHJ5O1xuICAgIGVsc2UgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgdGhpcy50YWlsID0gZW50cnk7XG4gIH0sXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbnRyeSA9IHRoaXMuaGVhZDtcbiAgICBpZiAoZW50cnkpIHtcbiAgICAgIHRoaXMuaGVhZCA9IGVudHJ5Lm5leHQ7XG4gICAgICBpZiAodGhpcy50YWlsID09PSBlbnRyeSkgdGhpcy50YWlsID0gbnVsbDtcbiAgICAgIHJldHVybiBlbnRyeS5pdGVtO1xuICAgIH1cbiAgfVxufTtcblxudmFyIHF1ZXVlID0gUXVldWUkMTtcblxudmFyIGdsb2JhbCQzID0gZ2xvYmFsJGs7XG5cbnZhciBwcm9taXNlTmF0aXZlQ29uc3RydWN0b3IgPSBnbG9iYWwkMy5Qcm9taXNlO1xuXG52YXIgZW5naW5lSXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgRGVubyAhPSAnb2JqZWN0JztcblxudmFyIGdsb2JhbCQyID0gZ2xvYmFsJGs7XG52YXIgTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yJDMgPSBwcm9taXNlTmF0aXZlQ29uc3RydWN0b3I7XG52YXIgaXNDYWxsYWJsZSQyID0gaXNDYWxsYWJsZSRsO1xudmFyIGlzRm9yY2VkID0gaXNGb3JjZWRfMTtcbnZhciBpbnNwZWN0U291cmNlID0gaW5zcGVjdFNvdXJjZSQ0O1xudmFyIHdlbGxLbm93blN5bWJvbCQzID0gd2VsbEtub3duU3ltYm9sJGc7XG52YXIgSVNfQlJPV1NFUiA9IGVuZ2luZUlzQnJvd3NlcjtcbnZhciBWOF9WRVJTSU9OID0gZW5naW5lVjhWZXJzaW9uO1xuXG5OYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMyAmJiBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMy5wcm90b3R5cGU7XG52YXIgU1BFQ0lFUyA9IHdlbGxLbm93blN5bWJvbCQzKCdzcGVjaWVzJyk7XG52YXIgU1VCQ0xBU1NJTkcgPSBmYWxzZTtcbnZhciBOQVRJVkVfUFJPTUlTRV9SRUpFQ1RJT05fRVZFTlQkMSA9IGlzQ2FsbGFibGUkMihnbG9iYWwkMi5Qcm9taXNlUmVqZWN0aW9uRXZlbnQpO1xuXG52YXIgRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkNSA9IGlzRm9yY2VkKCdQcm9taXNlJywgZnVuY3Rpb24gKCkge1xuICB2YXIgUFJPTUlTRV9DT05TVFJVQ1RPUl9TT1VSQ0UgPSBpbnNwZWN0U291cmNlKE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQzKTtcbiAgdmFyIEdMT0JBTF9DT1JFX0pTX1BST01JU0UgPSBQUk9NSVNFX0NPTlNUUlVDVE9SX1NPVVJDRSAhPT0gU3RyaW5nKE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQzKTtcbiAgLy8gVjggNi42IChOb2RlIDEwIGFuZCBDaHJvbWUgNjYpIGhhdmUgYSBidWcgd2l0aCByZXNvbHZpbmcgY3VzdG9tIHRoZW5hYmxlc1xuICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD04MzA1NjVcbiAgLy8gV2UgY2FuJ3QgZGV0ZWN0IGl0IHN5bmNocm9ub3VzbHksIHNvIGp1c3QgY2hlY2sgdmVyc2lvbnNcbiAgaWYgKCFHTE9CQUxfQ09SRV9KU19QUk9NSVNFICYmIFY4X1ZFUlNJT04gPT09IDY2KSByZXR1cm4gdHJ1ZTtcbiAgLy8gV2UgY2FuJ3QgdXNlIEBAc3BlY2llcyBmZWF0dXJlIGRldGVjdGlvbiBpbiBWOCBzaW5jZSBpdCBjYXVzZXNcbiAgLy8gZGVvcHRpbWl6YXRpb24gYW5kIHBlcmZvcm1hbmNlIGRlZ3JhZGF0aW9uXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy82NzlcbiAgaWYgKFY4X1ZFUlNJT04gPj0gNTEgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KFBST01JU0VfQ09OU1RSVUNUT1JfU09VUkNFKSkgcmV0dXJuIGZhbHNlO1xuICAvLyBEZXRlY3QgY29ycmVjdG5lc3Mgb2Ygc3ViY2xhc3Npbmcgd2l0aCBAQHNwZWNpZXMgc3VwcG9ydFxuICB2YXIgcHJvbWlzZSA9IG5ldyBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMyhmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKDEpOyB9KTtcbiAgdmFyIEZha2VQcm9taXNlID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgICBleGVjKGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSwgZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9KTtcbiAgfTtcbiAgdmFyIGNvbnN0cnVjdG9yID0gcHJvbWlzZS5jb25zdHJ1Y3RvciA9IHt9O1xuICBjb25zdHJ1Y3RvcltTUEVDSUVTXSA9IEZha2VQcm9taXNlO1xuICBTVUJDTEFTU0lORyA9IHByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0pIGluc3RhbmNlb2YgRmFrZVByb21pc2U7XG4gIGlmICghU1VCQ0xBU1NJTkcpIHJldHVybiB0cnVlO1xuICAvLyBVbmhhbmRsZWQgcmVqZWN0aW9ucyB0cmFja2luZyBzdXBwb3J0LCBOb2RlSlMgUHJvbWlzZSB3aXRob3V0IGl0IGZhaWxzIEBAc3BlY2llcyB0ZXN0XG4gIHJldHVybiAhR0xPQkFMX0NPUkVfSlNfUFJPTUlTRSAmJiBJU19CUk9XU0VSICYmICFOQVRJVkVfUFJPTUlTRV9SRUpFQ1RJT05fRVZFTlQkMTtcbn0pO1xuXG52YXIgcHJvbWlzZUNvbnN0cnVjdG9yRGV0ZWN0aW9uID0ge1xuICBDT05TVFJVQ1RPUjogRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkNSxcbiAgUkVKRUNUSU9OX0VWRU5UOiBOQVRJVkVfUFJPTUlTRV9SRUpFQ1RJT05fRVZFTlQkMSxcbiAgU1VCQ0xBU1NJTkc6IFNVQkNMQVNTSU5HXG59O1xuXG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkkMiA9IHt9O1xuXG52YXIgYUNhbGxhYmxlJDQgPSBhQ2FsbGFibGUkOTtcblxudmFyIFByb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24gKEMpIHtcbiAgdmFyIHJlc29sdmUsIHJlamVjdDtcbiAgdGhpcy5wcm9taXNlID0gbmV3IEMoZnVuY3Rpb24gKCQkcmVzb2x2ZSwgJCRyZWplY3QpIHtcbiAgICBpZiAocmVzb2x2ZSAhPT0gdW5kZWZpbmVkIHx8IHJlamVjdCAhPT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoJ0JhZCBQcm9taXNlIGNvbnN0cnVjdG9yJyk7XG4gICAgcmVzb2x2ZSA9ICQkcmVzb2x2ZTtcbiAgICByZWplY3QgPSAkJHJlamVjdDtcbiAgfSk7XG4gIHRoaXMucmVzb2x2ZSA9IGFDYWxsYWJsZSQ0KHJlc29sdmUpO1xuICB0aGlzLnJlamVjdCA9IGFDYWxsYWJsZSQ0KHJlamVjdCk7XG59O1xuXG4vLyBgTmV3UHJvbWlzZUNhcGFiaWxpdHlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1uZXdwcm9taXNlY2FwYWJpbGl0eVxubmV3UHJvbWlzZUNhcGFiaWxpdHkkMi5mID0gZnVuY3Rpb24gKEMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlQ2FwYWJpbGl0eShDKTtcbn07XG5cbnZhciAkJDUgPSBfZXhwb3J0O1xudmFyIElTX05PREUgPSBlbmdpbmVJc05vZGU7XG52YXIgZ2xvYmFsJDEgPSBnbG9iYWwkaztcbnZhciBjYWxsJDcgPSBmdW5jdGlvbkNhbGw7XG52YXIgZGVmaW5lQnVpbHRJbiQyID0gZGVmaW5lQnVpbHRJbiQ2O1xudmFyIHNldFByb3RvdHlwZU9mID0gb2JqZWN0U2V0UHJvdG90eXBlT2Y7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSBzZXRUb1N0cmluZ1RhZyQzO1xudmFyIHNldFNwZWNpZXMgPSBzZXRTcGVjaWVzJDE7XG52YXIgYUNhbGxhYmxlJDMgPSBhQ2FsbGFibGUkOTtcbnZhciBpc0NhbGxhYmxlJDEgPSBpc0NhbGxhYmxlJGw7XG52YXIgaXNPYmplY3QkMSA9IGlzT2JqZWN0JDg7XG52YXIgYW5JbnN0YW5jZSA9IGFuSW5zdGFuY2UkMTtcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSBzcGVjaWVzQ29uc3RydWN0b3IkMTtcbnZhciB0YXNrID0gdGFzayQxLnNldDtcbnZhciBtaWNyb3Rhc2sgPSBtaWNyb3Rhc2skMTtcbnZhciBob3N0UmVwb3J0RXJyb3JzID0gaG9zdFJlcG9ydEVycm9ycyQxO1xudmFyIHBlcmZvcm0kMiA9IHBlcmZvcm0kMztcbnZhciBRdWV1ZSA9IHF1ZXVlO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSBpbnRlcm5hbFN0YXRlO1xudmFyIE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQyID0gcHJvbWlzZU5hdGl2ZUNvbnN0cnVjdG9yO1xudmFyIFByb21pc2VDb25zdHJ1Y3RvckRldGVjdGlvbiA9IHByb21pc2VDb25zdHJ1Y3RvckRldGVjdGlvbjtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSQzID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkkMjtcblxudmFyIFBST01JU0UgPSAnUHJvbWlzZSc7XG52YXIgRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkNCA9IFByb21pc2VDb25zdHJ1Y3RvckRldGVjdGlvbi5DT05TVFJVQ1RPUjtcbnZhciBOQVRJVkVfUFJPTUlTRV9SRUpFQ1RJT05fRVZFTlQgPSBQcm9taXNlQ29uc3RydWN0b3JEZXRlY3Rpb24uUkVKRUNUSU9OX0VWRU5UO1xudmFyIE5BVElWRV9QUk9NSVNFX1NVQkNMQVNTSU5HID0gUHJvbWlzZUNvbnN0cnVjdG9yRGV0ZWN0aW9uLlNVQkNMQVNTSU5HO1xudmFyIGdldEludGVybmFsUHJvbWlzZVN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXR0ZXJGb3IoUFJPTUlTRSk7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuc2V0O1xudmFyIE5hdGl2ZVByb21pc2VQcm90b3R5cGUkMSA9IE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQyICYmIE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQyLnByb3RvdHlwZTtcbnZhciBQcm9taXNlQ29uc3RydWN0b3IgPSBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMjtcbnZhciBQcm9taXNlUHJvdG90eXBlID0gTmF0aXZlUHJvbWlzZVByb3RvdHlwZSQxO1xudmFyIFR5cGVFcnJvciQxID0gZ2xvYmFsJDEuVHlwZUVycm9yO1xudmFyIGRvY3VtZW50JDEgPSBnbG9iYWwkMS5kb2N1bWVudDtcbnZhciBwcm9jZXNzID0gZ2xvYmFsJDEucHJvY2VzcztcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSQxID0gbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUkMy5mO1xudmFyIG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5JDE7XG5cbnZhciBESVNQQVRDSF9FVkVOVCA9ICEhKGRvY3VtZW50JDEgJiYgZG9jdW1lbnQkMS5jcmVhdGVFdmVudCAmJiBnbG9iYWwkMS5kaXNwYXRjaEV2ZW50KTtcbnZhciBVTkhBTkRMRURfUkVKRUNUSU9OID0gJ3VuaGFuZGxlZHJlamVjdGlvbic7XG52YXIgUkVKRUNUSU9OX0hBTkRMRUQgPSAncmVqZWN0aW9uaGFuZGxlZCc7XG52YXIgUEVORElORyA9IDA7XG52YXIgRlVMRklMTEVEID0gMTtcbnZhciBSRUpFQ1RFRCA9IDI7XG52YXIgSEFORExFRCA9IDE7XG52YXIgVU5IQU5ETEVEID0gMjtcblxudmFyIEludGVybmFsLCBPd25Qcm9taXNlQ2FwYWJpbGl0eSwgUHJvbWlzZVdyYXBwZXIsIG5hdGl2ZVRoZW47XG5cbi8vIGhlbHBlcnNcbnZhciBpc1RoZW5hYmxlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciB0aGVuO1xuICByZXR1cm4gaXNPYmplY3QkMShpdCkgJiYgaXNDYWxsYWJsZSQxKHRoZW4gPSBpdC50aGVuKSA/IHRoZW4gOiBmYWxzZTtcbn07XG5cbnZhciBjYWxsUmVhY3Rpb24gPSBmdW5jdGlvbiAocmVhY3Rpb24sIHN0YXRlKSB7XG4gIHZhciB2YWx1ZSA9IHN0YXRlLnZhbHVlO1xuICB2YXIgb2sgPSBzdGF0ZS5zdGF0ZSA9PSBGVUxGSUxMRUQ7XG4gIHZhciBoYW5kbGVyID0gb2sgPyByZWFjdGlvbi5vayA6IHJlYWN0aW9uLmZhaWw7XG4gIHZhciByZXNvbHZlID0gcmVhY3Rpb24ucmVzb2x2ZTtcbiAgdmFyIHJlamVjdCA9IHJlYWN0aW9uLnJlamVjdDtcbiAgdmFyIGRvbWFpbiA9IHJlYWN0aW9uLmRvbWFpbjtcbiAgdmFyIHJlc3VsdCwgdGhlbiwgZXhpdGVkO1xuICB0cnkge1xuICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICBpZiAoIW9rKSB7XG4gICAgICAgIGlmIChzdGF0ZS5yZWplY3Rpb24gPT09IFVOSEFORExFRCkgb25IYW5kbGVVbmhhbmRsZWQoc3RhdGUpO1xuICAgICAgICBzdGF0ZS5yZWplY3Rpb24gPSBIQU5ETEVEO1xuICAgICAgfVxuICAgICAgaWYgKGhhbmRsZXIgPT09IHRydWUpIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChkb21haW4pIGRvbWFpbi5lbnRlcigpO1xuICAgICAgICByZXN1bHQgPSBoYW5kbGVyKHZhbHVlKTsgLy8gY2FuIHRocm93XG4gICAgICAgIGlmIChkb21haW4pIHtcbiAgICAgICAgICBkb21haW4uZXhpdCgpO1xuICAgICAgICAgIGV4aXRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQgPT09IHJlYWN0aW9uLnByb21pc2UpIHtcbiAgICAgICAgcmVqZWN0KFR5cGVFcnJvciQxKCdQcm9taXNlLWNoYWluIGN5Y2xlJykpO1xuICAgICAgfSBlbHNlIGlmICh0aGVuID0gaXNUaGVuYWJsZShyZXN1bHQpKSB7XG4gICAgICAgIGNhbGwkNyh0aGVuLCByZXN1bHQsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9IGVsc2UgcmVzb2x2ZShyZXN1bHQpO1xuICAgIH0gZWxzZSByZWplY3QodmFsdWUpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChkb21haW4gJiYgIWV4aXRlZCkgZG9tYWluLmV4aXQoKTtcbiAgICByZWplY3QoZXJyb3IpO1xuICB9XG59O1xuXG52YXIgbm90aWZ5ID0gZnVuY3Rpb24gKHN0YXRlLCBpc1JlamVjdCkge1xuICBpZiAoc3RhdGUubm90aWZpZWQpIHJldHVybjtcbiAgc3RhdGUubm90aWZpZWQgPSB0cnVlO1xuICBtaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgIHZhciByZWFjdGlvbnMgPSBzdGF0ZS5yZWFjdGlvbnM7XG4gICAgdmFyIHJlYWN0aW9uO1xuICAgIHdoaWxlIChyZWFjdGlvbiA9IHJlYWN0aW9ucy5nZXQoKSkge1xuICAgICAgY2FsbFJlYWN0aW9uKHJlYWN0aW9uLCBzdGF0ZSk7XG4gICAgfVxuICAgIHN0YXRlLm5vdGlmaWVkID0gZmFsc2U7XG4gICAgaWYgKGlzUmVqZWN0ICYmICFzdGF0ZS5yZWplY3Rpb24pIG9uVW5oYW5kbGVkKHN0YXRlKTtcbiAgfSk7XG59O1xuXG52YXIgZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uIChuYW1lLCBwcm9taXNlLCByZWFzb24pIHtcbiAgdmFyIGV2ZW50LCBoYW5kbGVyO1xuICBpZiAoRElTUEFUQ0hfRVZFTlQpIHtcbiAgICBldmVudCA9IGRvY3VtZW50JDEuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgZXZlbnQucHJvbWlzZSA9IHByb21pc2U7XG4gICAgZXZlbnQucmVhc29uID0gcmVhc29uO1xuICAgIGV2ZW50LmluaXRFdmVudChuYW1lLCBmYWxzZSwgdHJ1ZSk7XG4gICAgZ2xvYmFsJDEuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gIH0gZWxzZSBldmVudCA9IHsgcHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiByZWFzb24gfTtcbiAgaWYgKCFOQVRJVkVfUFJPTUlTRV9SRUpFQ1RJT05fRVZFTlQgJiYgKGhhbmRsZXIgPSBnbG9iYWwkMVsnb24nICsgbmFtZV0pKSBoYW5kbGVyKGV2ZW50KTtcbiAgZWxzZSBpZiAobmFtZSA9PT0gVU5IQU5ETEVEX1JFSkVDVElPTikgaG9zdFJlcG9ydEVycm9ycygnVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uJywgcmVhc29uKTtcbn07XG5cbnZhciBvblVuaGFuZGxlZCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICBjYWxsJDcodGFzaywgZ2xvYmFsJDEsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvbWlzZSA9IHN0YXRlLmZhY2FkZTtcbiAgICB2YXIgdmFsdWUgPSBzdGF0ZS52YWx1ZTtcbiAgICB2YXIgSVNfVU5IQU5ETEVEID0gaXNVbmhhbmRsZWQoc3RhdGUpO1xuICAgIHZhciByZXN1bHQ7XG4gICAgaWYgKElTX1VOSEFORExFRCkge1xuICAgICAgcmVzdWx0ID0gcGVyZm9ybSQyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKElTX05PREUpIHtcbiAgICAgICAgICBwcm9jZXNzLmVtaXQoJ3VuaGFuZGxlZFJlamVjdGlvbicsIHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgfSBlbHNlIGRpc3BhdGNoRXZlbnQoVU5IQU5ETEVEX1JFSkVDVElPTiwgcHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgICAvLyBCcm93c2VycyBzaG91bGQgbm90IHRyaWdnZXIgYHJlamVjdGlvbkhhbmRsZWRgIGV2ZW50IGlmIGl0IHdhcyBoYW5kbGVkIGhlcmUsIE5vZGVKUyAtIHNob3VsZFxuICAgICAgc3RhdGUucmVqZWN0aW9uID0gSVNfTk9ERSB8fCBpc1VuaGFuZGxlZChzdGF0ZSkgPyBVTkhBTkRMRUQgOiBIQU5ETEVEO1xuICAgICAgaWYgKHJlc3VsdC5lcnJvcikgdGhyb3cgcmVzdWx0LnZhbHVlO1xuICAgIH1cbiAgfSk7XG59O1xuXG52YXIgaXNVbmhhbmRsZWQgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLnJlamVjdGlvbiAhPT0gSEFORExFRCAmJiAhc3RhdGUucGFyZW50O1xufTtcblxudmFyIG9uSGFuZGxlVW5oYW5kbGVkID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gIGNhbGwkNyh0YXNrLCBnbG9iYWwkMSwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9taXNlID0gc3RhdGUuZmFjYWRlO1xuICAgIGlmIChJU19OT0RFKSB7XG4gICAgICBwcm9jZXNzLmVtaXQoJ3JlamVjdGlvbkhhbmRsZWQnLCBwcm9taXNlKTtcbiAgICB9IGVsc2UgZGlzcGF0Y2hFdmVudChSRUpFQ1RJT05fSEFORExFRCwgcHJvbWlzZSwgc3RhdGUudmFsdWUpO1xuICB9KTtcbn07XG5cbnZhciBiaW5kJDEgPSBmdW5jdGlvbiAoZm4sIHN0YXRlLCB1bndyYXApIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGZuKHN0YXRlLCB2YWx1ZSwgdW53cmFwKTtcbiAgfTtcbn07XG5cbnZhciBpbnRlcm5hbFJlamVjdCA9IGZ1bmN0aW9uIChzdGF0ZSwgdmFsdWUsIHVud3JhcCkge1xuICBpZiAoc3RhdGUuZG9uZSkgcmV0dXJuO1xuICBzdGF0ZS5kb25lID0gdHJ1ZTtcbiAgaWYgKHVud3JhcCkgc3RhdGUgPSB1bndyYXA7XG4gIHN0YXRlLnZhbHVlID0gdmFsdWU7XG4gIHN0YXRlLnN0YXRlID0gUkVKRUNURUQ7XG4gIG5vdGlmeShzdGF0ZSwgdHJ1ZSk7XG59O1xuXG52YXIgaW50ZXJuYWxSZXNvbHZlID0gZnVuY3Rpb24gKHN0YXRlLCB2YWx1ZSwgdW53cmFwKSB7XG4gIGlmIChzdGF0ZS5kb25lKSByZXR1cm47XG4gIHN0YXRlLmRvbmUgPSB0cnVlO1xuICBpZiAodW53cmFwKSBzdGF0ZSA9IHVud3JhcDtcbiAgdHJ5IHtcbiAgICBpZiAoc3RhdGUuZmFjYWRlID09PSB2YWx1ZSkgdGhyb3cgVHlwZUVycm9yJDEoXCJQcm9taXNlIGNhbid0IGJlIHJlc29sdmVkIGl0c2VsZlwiKTtcbiAgICB2YXIgdGhlbiA9IGlzVGhlbmFibGUodmFsdWUpO1xuICAgIGlmICh0aGVuKSB7XG4gICAgICBtaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgd3JhcHBlciA9IHsgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjYWxsJDcodGhlbiwgdmFsdWUsXG4gICAgICAgICAgICBiaW5kJDEoaW50ZXJuYWxSZXNvbHZlLCB3cmFwcGVyLCBzdGF0ZSksXG4gICAgICAgICAgICBiaW5kJDEoaW50ZXJuYWxSZWplY3QsIHdyYXBwZXIsIHN0YXRlKVxuICAgICAgICAgICk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgaW50ZXJuYWxSZWplY3Qod3JhcHBlciwgZXJyb3IsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnZhbHVlID0gdmFsdWU7XG4gICAgICBzdGF0ZS5zdGF0ZSA9IEZVTEZJTExFRDtcbiAgICAgIG5vdGlmeShzdGF0ZSwgZmFsc2UpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpbnRlcm5hbFJlamVjdCh7IGRvbmU6IGZhbHNlIH0sIGVycm9yLCBzdGF0ZSk7XG4gIH1cbn07XG5cbi8vIGNvbnN0cnVjdG9yIHBvbHlmaWxsXG5pZiAoRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkNCkge1xuICAvLyAyNS40LjMuMSBQcm9taXNlKGV4ZWN1dG9yKVxuICBQcm9taXNlQ29uc3RydWN0b3IgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XG4gICAgYW5JbnN0YW5jZSh0aGlzLCBQcm9taXNlUHJvdG90eXBlKTtcbiAgICBhQ2FsbGFibGUkMyhleGVjdXRvcik7XG4gICAgY2FsbCQ3KEludGVybmFsLCB0aGlzKTtcbiAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFByb21pc2VTdGF0ZSh0aGlzKTtcbiAgICB0cnkge1xuICAgICAgZXhlY3V0b3IoYmluZCQxKGludGVybmFsUmVzb2x2ZSwgc3RhdGUpLCBiaW5kJDEoaW50ZXJuYWxSZWplY3QsIHN0YXRlKSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGludGVybmFsUmVqZWN0KHN0YXRlLCBlcnJvcik7XG4gICAgfVxuICB9O1xuXG4gIFByb21pc2VQcm90b3R5cGUgPSBQcm9taXNlQ29uc3RydWN0b3IucHJvdG90eXBlO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFycyAtLSByZXF1aXJlZCBmb3IgYC5sZW5ndGhgXG4gIEludGVybmFsID0gZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcikge1xuICAgIHNldEludGVybmFsU3RhdGUodGhpcywge1xuICAgICAgdHlwZTogUFJPTUlTRSxcbiAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgbm90aWZpZWQ6IGZhbHNlLFxuICAgICAgcGFyZW50OiBmYWxzZSxcbiAgICAgIHJlYWN0aW9uczogbmV3IFF1ZXVlKCksXG4gICAgICByZWplY3Rpb246IGZhbHNlLFxuICAgICAgc3RhdGU6IFBFTkRJTkcsXG4gICAgICB2YWx1ZTogdW5kZWZpbmVkXG4gICAgfSk7XG4gIH07XG5cbiAgLy8gYFByb21pc2UucHJvdG90eXBlLnRoZW5gIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXByb21pc2UucHJvdG90eXBlLnRoZW5cbiAgSW50ZXJuYWwucHJvdG90eXBlID0gZGVmaW5lQnVpbHRJbiQyKFByb21pc2VQcm90b3R5cGUsICd0aGVuJywgZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsUHJvbWlzZVN0YXRlKHRoaXMpO1xuICAgIHZhciByZWFjdGlvbiA9IG5ld1Byb21pc2VDYXBhYmlsaXR5JDEoc3BlY2llc0NvbnN0cnVjdG9yKHRoaXMsIFByb21pc2VDb25zdHJ1Y3RvcikpO1xuICAgIHN0YXRlLnBhcmVudCA9IHRydWU7XG4gICAgcmVhY3Rpb24ub2sgPSBpc0NhbGxhYmxlJDEob25GdWxmaWxsZWQpID8gb25GdWxmaWxsZWQgOiB0cnVlO1xuICAgIHJlYWN0aW9uLmZhaWwgPSBpc0NhbGxhYmxlJDEob25SZWplY3RlZCkgJiYgb25SZWplY3RlZDtcbiAgICByZWFjdGlvbi5kb21haW4gPSBJU19OT0RFID8gcHJvY2Vzcy5kb21haW4gOiB1bmRlZmluZWQ7XG4gICAgaWYgKHN0YXRlLnN0YXRlID09IFBFTkRJTkcpIHN0YXRlLnJlYWN0aW9ucy5hZGQocmVhY3Rpb24pO1xuICAgIGVsc2UgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxSZWFjdGlvbihyZWFjdGlvbiwgc3RhdGUpO1xuICAgIH0pO1xuICAgIHJldHVybiByZWFjdGlvbi5wcm9taXNlO1xuICB9KTtcblxuICBPd25Qcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBJbnRlcm5hbCgpO1xuICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsUHJvbWlzZVN0YXRlKHByb21pc2UpO1xuICAgIHRoaXMucHJvbWlzZSA9IHByb21pc2U7XG4gICAgdGhpcy5yZXNvbHZlID0gYmluZCQxKGludGVybmFsUmVzb2x2ZSwgc3RhdGUpO1xuICAgIHRoaXMucmVqZWN0ID0gYmluZCQxKGludGVybmFsUmVqZWN0LCBzdGF0ZSk7XG4gIH07XG5cbiAgbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUkMy5mID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkkMSA9IGZ1bmN0aW9uIChDKSB7XG4gICAgcmV0dXJuIEMgPT09IFByb21pc2VDb25zdHJ1Y3RvciB8fCBDID09PSBQcm9taXNlV3JhcHBlclxuICAgICAgPyBuZXcgT3duUHJvbWlzZUNhcGFiaWxpdHkoQylcbiAgICAgIDogbmV3R2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5KEMpO1xuICB9O1xuXG4gIGlmIChpc0NhbGxhYmxlJDEoTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yJDIpICYmIE5hdGl2ZVByb21pc2VQcm90b3R5cGUkMSAhPT0gT2JqZWN0LnByb3RvdHlwZSkge1xuICAgIG5hdGl2ZVRoZW4gPSBOYXRpdmVQcm9taXNlUHJvdG90eXBlJDEudGhlbjtcblxuICAgIGlmICghTkFUSVZFX1BST01JU0VfU1VCQ0xBU1NJTkcpIHtcbiAgICAgIC8vIG1ha2UgYFByb21pc2UjdGhlbmAgcmV0dXJuIGEgcG9seWZpbGxlZCBgUHJvbWlzZWAgZm9yIG5hdGl2ZSBwcm9taXNlLWJhc2VkIEFQSXNcbiAgICAgIGRlZmluZUJ1aWx0SW4kMihOYXRpdmVQcm9taXNlUHJvdG90eXBlJDEsICd0aGVuJywgZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZUNvbnN0cnVjdG9yKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBjYWxsJDcobmF0aXZlVGhlbiwgdGhhdCwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSkudGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCk7XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNjQwXG4gICAgICB9LCB7IHVuc2FmZTogdHJ1ZSB9KTtcbiAgICB9XG5cbiAgICAvLyBtYWtlIGAuY29uc3RydWN0b3IgPT09IFByb21pc2VgIHdvcmsgZm9yIG5hdGl2ZSBwcm9taXNlLWJhc2VkIEFQSXNcbiAgICB0cnkge1xuICAgICAgZGVsZXRlIE5hdGl2ZVByb21pc2VQcm90b3R5cGUkMS5jb25zdHJ1Y3RvcjtcbiAgICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG5cbiAgICAvLyBtYWtlIGBpbnN0YW5jZW9mIFByb21pc2VgIHdvcmsgZm9yIG5hdGl2ZSBwcm9taXNlLWJhc2VkIEFQSXNcbiAgICBpZiAoc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIHNldFByb3RvdHlwZU9mKE5hdGl2ZVByb21pc2VQcm90b3R5cGUkMSwgUHJvbWlzZVByb3RvdHlwZSk7XG4gICAgfVxuICB9XG59XG5cbiQkNSh7IGdsb2JhbDogdHJ1ZSwgY29uc3RydWN0b3I6IHRydWUsIHdyYXA6IHRydWUsIGZvcmNlZDogRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkNCB9LCB7XG4gIFByb21pc2U6IFByb21pc2VDb25zdHJ1Y3RvclxufSk7XG5cbnNldFRvU3RyaW5nVGFnKFByb21pc2VDb25zdHJ1Y3RvciwgUFJPTUlTRSwgZmFsc2UpO1xuc2V0U3BlY2llcyhQUk9NSVNFKTtcblxudmFyIHdlbGxLbm93blN5bWJvbCQyID0gd2VsbEtub3duU3ltYm9sJGc7XG52YXIgSXRlcmF0b3JzJDEgPSBpdGVyYXRvcnM7XG5cbnZhciBJVEVSQVRPUiQyID0gd2VsbEtub3duU3ltYm9sJDIoJ2l0ZXJhdG9yJyk7XG52YXIgQXJyYXlQcm90b3R5cGUgPSBBcnJheS5wcm90b3R5cGU7XG5cbi8vIGNoZWNrIG9uIGRlZmF1bHQgQXJyYXkgaXRlcmF0b3JcbnZhciBpc0FycmF5SXRlcmF0b3JNZXRob2QkMSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJiAoSXRlcmF0b3JzJDEuQXJyYXkgPT09IGl0IHx8IEFycmF5UHJvdG90eXBlW0lURVJBVE9SJDJdID09PSBpdCk7XG59O1xuXG52YXIgY2xhc3NvZiA9IGNsYXNzb2YkNTtcbnZhciBnZXRNZXRob2QkMSA9IGdldE1ldGhvZCQzO1xudmFyIEl0ZXJhdG9ycyA9IGl0ZXJhdG9ycztcbnZhciB3ZWxsS25vd25TeW1ib2wkMSA9IHdlbGxLbm93blN5bWJvbCRnO1xuXG52YXIgSVRFUkFUT1IkMSA9IHdlbGxLbm93blN5bWJvbCQxKCdpdGVyYXRvcicpO1xuXG52YXIgZ2V0SXRlcmF0b3JNZXRob2QkMiA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgIT0gdW5kZWZpbmVkKSByZXR1cm4gZ2V0TWV0aG9kJDEoaXQsIElURVJBVE9SJDEpXG4gICAgfHwgZ2V0TWV0aG9kJDEoaXQsICdAQGl0ZXJhdG9yJylcbiAgICB8fCBJdGVyYXRvcnNbY2xhc3NvZihpdCldO1xufTtcblxudmFyIGNhbGwkNiA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBhQ2FsbGFibGUkMiA9IGFDYWxsYWJsZSQ5O1xudmFyIGFuT2JqZWN0JDUgPSBhbk9iamVjdCRjO1xudmFyIHRyeVRvU3RyaW5nJDEgPSB0cnlUb1N0cmluZyQ1O1xudmFyIGdldEl0ZXJhdG9yTWV0aG9kJDEgPSBnZXRJdGVyYXRvck1ldGhvZCQyO1xuXG52YXIgJFR5cGVFcnJvciQxID0gVHlwZUVycm9yO1xuXG52YXIgZ2V0SXRlcmF0b3IkMSA9IGZ1bmN0aW9uIChhcmd1bWVudCwgdXNpbmdJdGVyYXRvcikge1xuICB2YXIgaXRlcmF0b3JNZXRob2QgPSBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGdldEl0ZXJhdG9yTWV0aG9kJDEoYXJndW1lbnQpIDogdXNpbmdJdGVyYXRvcjtcbiAgaWYgKGFDYWxsYWJsZSQyKGl0ZXJhdG9yTWV0aG9kKSkgcmV0dXJuIGFuT2JqZWN0JDUoY2FsbCQ2KGl0ZXJhdG9yTWV0aG9kLCBhcmd1bWVudCkpO1xuICB0aHJvdyAkVHlwZUVycm9yJDEodHJ5VG9TdHJpbmckMShhcmd1bWVudCkgKyAnIGlzIG5vdCBpdGVyYWJsZScpO1xufTtcblxudmFyIGNhbGwkNSA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBhbk9iamVjdCQ0ID0gYW5PYmplY3QkYztcbnZhciBnZXRNZXRob2QgPSBnZXRNZXRob2QkMztcblxudmFyIGl0ZXJhdG9yQ2xvc2UkMSA9IGZ1bmN0aW9uIChpdGVyYXRvciwga2luZCwgdmFsdWUpIHtcbiAgdmFyIGlubmVyUmVzdWx0LCBpbm5lckVycm9yO1xuICBhbk9iamVjdCQ0KGl0ZXJhdG9yKTtcbiAgdHJ5IHtcbiAgICBpbm5lclJlc3VsdCA9IGdldE1ldGhvZChpdGVyYXRvciwgJ3JldHVybicpO1xuICAgIGlmICghaW5uZXJSZXN1bHQpIHtcbiAgICAgIGlmIChraW5kID09PSAndGhyb3cnKSB0aHJvdyB2YWx1ZTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaW5uZXJSZXN1bHQgPSBjYWxsJDUoaW5uZXJSZXN1bHQsIGl0ZXJhdG9yKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpbm5lckVycm9yID0gdHJ1ZTtcbiAgICBpbm5lclJlc3VsdCA9IGVycm9yO1xuICB9XG4gIGlmIChraW5kID09PSAndGhyb3cnKSB0aHJvdyB2YWx1ZTtcbiAgaWYgKGlubmVyRXJyb3IpIHRocm93IGlubmVyUmVzdWx0O1xuICBhbk9iamVjdCQ0KGlubmVyUmVzdWx0KTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcblxudmFyIGJpbmQgPSBmdW5jdGlvbkJpbmRDb250ZXh0O1xudmFyIGNhbGwkNCA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBhbk9iamVjdCQzID0gYW5PYmplY3QkYztcbnZhciB0cnlUb1N0cmluZyA9IHRyeVRvU3RyaW5nJDU7XG52YXIgaXNBcnJheUl0ZXJhdG9yTWV0aG9kID0gaXNBcnJheUl0ZXJhdG9yTWV0aG9kJDE7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UgPSBsZW5ndGhPZkFycmF5TGlrZSQ1O1xudmFyIGlzUHJvdG90eXBlT2YkMSA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG52YXIgZ2V0SXRlcmF0b3IgPSBnZXRJdGVyYXRvciQxO1xudmFyIGdldEl0ZXJhdG9yTWV0aG9kID0gZ2V0SXRlcmF0b3JNZXRob2QkMjtcbnZhciBpdGVyYXRvckNsb3NlID0gaXRlcmF0b3JDbG9zZSQxO1xuXG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcblxudmFyIFJlc3VsdCA9IGZ1bmN0aW9uIChzdG9wcGVkLCByZXN1bHQpIHtcbiAgdGhpcy5zdG9wcGVkID0gc3RvcHBlZDtcbiAgdGhpcy5yZXN1bHQgPSByZXN1bHQ7XG59O1xuXG52YXIgUmVzdWx0UHJvdG90eXBlID0gUmVzdWx0LnByb3RvdHlwZTtcblxudmFyIGl0ZXJhdGUkMiA9IGZ1bmN0aW9uIChpdGVyYWJsZSwgdW5ib3VuZEZ1bmN0aW9uLCBvcHRpb25zKSB7XG4gIHZhciB0aGF0ID0gb3B0aW9ucyAmJiBvcHRpb25zLnRoYXQ7XG4gIHZhciBBU19FTlRSSUVTID0gISEob3B0aW9ucyAmJiBvcHRpb25zLkFTX0VOVFJJRVMpO1xuICB2YXIgSVNfSVRFUkFUT1IgPSAhIShvcHRpb25zICYmIG9wdGlvbnMuSVNfSVRFUkFUT1IpO1xuICB2YXIgSU5URVJSVVBURUQgPSAhIShvcHRpb25zICYmIG9wdGlvbnMuSU5URVJSVVBURUQpO1xuICB2YXIgZm4gPSBiaW5kKHVuYm91bmRGdW5jdGlvbiwgdGhhdCk7XG4gIHZhciBpdGVyYXRvciwgaXRlckZuLCBpbmRleCwgbGVuZ3RoLCByZXN1bHQsIG5leHQsIHN0ZXA7XG5cbiAgdmFyIHN0b3AgPSBmdW5jdGlvbiAoY29uZGl0aW9uKSB7XG4gICAgaWYgKGl0ZXJhdG9yKSBpdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCAnbm9ybWFsJywgY29uZGl0aW9uKTtcbiAgICByZXR1cm4gbmV3IFJlc3VsdCh0cnVlLCBjb25kaXRpb24pO1xuICB9O1xuXG4gIHZhciBjYWxsRm4gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAoQVNfRU5UUklFUykge1xuICAgICAgYW5PYmplY3QkMyh2YWx1ZSk7XG4gICAgICByZXR1cm4gSU5URVJSVVBURUQgPyBmbih2YWx1ZVswXSwgdmFsdWVbMV0sIHN0b3ApIDogZm4odmFsdWVbMF0sIHZhbHVlWzFdKTtcbiAgICB9IHJldHVybiBJTlRFUlJVUFRFRCA/IGZuKHZhbHVlLCBzdG9wKSA6IGZuKHZhbHVlKTtcbiAgfTtcblxuICBpZiAoSVNfSVRFUkFUT1IpIHtcbiAgICBpdGVyYXRvciA9IGl0ZXJhYmxlO1xuICB9IGVsc2Uge1xuICAgIGl0ZXJGbiA9IGdldEl0ZXJhdG9yTWV0aG9kKGl0ZXJhYmxlKTtcbiAgICBpZiAoIWl0ZXJGbikgdGhyb3cgJFR5cGVFcnJvcih0cnlUb1N0cmluZyhpdGVyYWJsZSkgKyAnIGlzIG5vdCBpdGVyYWJsZScpO1xuICAgIC8vIG9wdGltaXNhdGlvbiBmb3IgYXJyYXkgaXRlcmF0b3JzXG4gICAgaWYgKGlzQXJyYXlJdGVyYXRvck1ldGhvZChpdGVyRm4pKSB7XG4gICAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UoaXRlcmFibGUpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgICByZXN1bHQgPSBjYWxsRm4oaXRlcmFibGVbaW5kZXhdKTtcbiAgICAgICAgaWYgKHJlc3VsdCAmJiBpc1Byb3RvdHlwZU9mJDEoUmVzdWx0UHJvdG90eXBlLCByZXN1bHQpKSByZXR1cm4gcmVzdWx0O1xuICAgICAgfSByZXR1cm4gbmV3IFJlc3VsdChmYWxzZSk7XG4gICAgfVxuICAgIGl0ZXJhdG9yID0gZ2V0SXRlcmF0b3IoaXRlcmFibGUsIGl0ZXJGbik7XG4gIH1cblxuICBuZXh0ID0gaXRlcmF0b3IubmV4dDtcbiAgd2hpbGUgKCEoc3RlcCA9IGNhbGwkNChuZXh0LCBpdGVyYXRvcikpLmRvbmUpIHtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gY2FsbEZuKHN0ZXAudmFsdWUpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCAndGhyb3cnLCBlcnJvcik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcmVzdWx0ID09ICdvYmplY3QnICYmIHJlc3VsdCAmJiBpc1Byb3RvdHlwZU9mJDEoUmVzdWx0UHJvdG90eXBlLCByZXN1bHQpKSByZXR1cm4gcmVzdWx0O1xuICB9IHJldHVybiBuZXcgUmVzdWx0KGZhbHNlKTtcbn07XG5cbnZhciB3ZWxsS25vd25TeW1ib2wgPSB3ZWxsS25vd25TeW1ib2wkZztcblxudmFyIElURVJBVE9SID0gd2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xudmFyIFNBRkVfQ0xPU0lORyA9IGZhbHNlO1xuXG50cnkge1xuICB2YXIgY2FsbGVkID0gMDtcbiAgdmFyIGl0ZXJhdG9yV2l0aFJldHVybiA9IHtcbiAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4geyBkb25lOiAhIWNhbGxlZCsrIH07XG4gICAgfSxcbiAgICAncmV0dXJuJzogZnVuY3Rpb24gKCkge1xuICAgICAgU0FGRV9DTE9TSU5HID0gdHJ1ZTtcbiAgICB9XG4gIH07XG4gIGl0ZXJhdG9yV2l0aFJldHVybltJVEVSQVRPUl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLWFycmF5LWZyb20sIG5vLXRocm93LWxpdGVyYWwgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgQXJyYXkuZnJvbShpdGVyYXRvcldpdGhSZXR1cm4sIGZ1bmN0aW9uICgpIHsgdGhyb3cgMjsgfSk7XG59IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG5cbnZhciBjaGVja0NvcnJlY3RuZXNzT2ZJdGVyYXRpb24kMSA9IGZ1bmN0aW9uIChleGVjLCBTS0lQX0NMT1NJTkcpIHtcbiAgaWYgKCFTS0lQX0NMT1NJTkcgJiYgIVNBRkVfQ0xPU0lORykgcmV0dXJuIGZhbHNlO1xuICB2YXIgSVRFUkFUSU9OX1NVUFBPUlQgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgb2JqZWN0W0lURVJBVE9SXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4geyBkb25lOiBJVEVSQVRJT05fU1VQUE9SVCA9IHRydWUgfTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuICAgIGV4ZWMob2JqZWN0KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gSVRFUkFUSU9OX1NVUFBPUlQ7XG59O1xuXG52YXIgTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yJDEgPSBwcm9taXNlTmF0aXZlQ29uc3RydWN0b3I7XG52YXIgY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uID0gY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uJDE7XG52YXIgRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkMyA9IHByb21pc2VDb25zdHJ1Y3RvckRldGVjdGlvbi5DT05TVFJVQ1RPUjtcblxudmFyIHByb21pc2VTdGF0aWNzSW5jb3JyZWN0SXRlcmF0aW9uID0gRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkMyB8fCAhY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uKGZ1bmN0aW9uIChpdGVyYWJsZSkge1xuICBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMS5hbGwoaXRlcmFibGUpLnRoZW4odW5kZWZpbmVkLCBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0pO1xufSk7XG5cbnZhciAkJDQgPSBfZXhwb3J0O1xudmFyIGNhbGwkMyA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBhQ2FsbGFibGUkMSA9IGFDYWxsYWJsZSQ5O1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlJDIgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSQyO1xudmFyIHBlcmZvcm0kMSA9IHBlcmZvcm0kMztcbnZhciBpdGVyYXRlJDEgPSBpdGVyYXRlJDI7XG52YXIgUFJPTUlTRV9TVEFUSUNTX0lOQ09SUkVDVF9JVEVSQVRJT04kMSA9IHByb21pc2VTdGF0aWNzSW5jb3JyZWN0SXRlcmF0aW9uO1xuXG4vLyBgUHJvbWlzZS5hbGxgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1wcm9taXNlLmFsbFxuJCQ0KHsgdGFyZ2V0OiAnUHJvbWlzZScsIHN0YXQ6IHRydWUsIGZvcmNlZDogUFJPTUlTRV9TVEFUSUNTX0lOQ09SUkVDVF9JVEVSQVRJT04kMSB9LCB7XG4gIGFsbDogZnVuY3Rpb24gYWxsKGl0ZXJhYmxlKSB7XG4gICAgdmFyIEMgPSB0aGlzO1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUkMi5mKEMpO1xuICAgIHZhciByZXNvbHZlID0gY2FwYWJpbGl0eS5yZXNvbHZlO1xuICAgIHZhciByZWplY3QgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICB2YXIgcmVzdWx0ID0gcGVyZm9ybSQxKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkcHJvbWlzZVJlc29sdmUgPSBhQ2FsbGFibGUkMShDLnJlc29sdmUpO1xuICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgdmFyIGNvdW50ZXIgPSAwO1xuICAgICAgdmFyIHJlbWFpbmluZyA9IDE7XG4gICAgICBpdGVyYXRlJDEoaXRlcmFibGUsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGNvdW50ZXIrKztcbiAgICAgICAgdmFyIGFscmVhZHlDYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgcmVtYWluaW5nKys7XG4gICAgICAgIGNhbGwkMygkcHJvbWlzZVJlc29sdmUsIEMsIHByb21pc2UpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKGFscmVhZHlDYWxsZWQpIHJldHVybjtcbiAgICAgICAgICBhbHJlYWR5Q2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICB2YWx1ZXNbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG4gICAgfSk7XG4gICAgaWYgKHJlc3VsdC5lcnJvcikgcmVqZWN0KHJlc3VsdC52YWx1ZSk7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG5cbnZhciAkJDMgPSBfZXhwb3J0O1xudmFyIEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SJDIgPSBwcm9taXNlQ29uc3RydWN0b3JEZXRlY3Rpb24uQ09OU1RSVUNUT1I7XG52YXIgTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yID0gcHJvbWlzZU5hdGl2ZUNvbnN0cnVjdG9yO1xudmFyIGdldEJ1aWx0SW4kMSA9IGdldEJ1aWx0SW4kODtcbnZhciBpc0NhbGxhYmxlID0gaXNDYWxsYWJsZSRsO1xudmFyIGRlZmluZUJ1aWx0SW4kMSA9IGRlZmluZUJ1aWx0SW4kNjtcblxudmFyIE5hdGl2ZVByb21pc2VQcm90b3R5cGUgPSBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IgJiYgTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yLnByb3RvdHlwZTtcblxuLy8gYFByb21pc2UucHJvdG90eXBlLmNhdGNoYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcHJvbWlzZS5wcm90b3R5cGUuY2F0Y2hcbiQkMyh7IHRhcmdldDogJ1Byb21pc2UnLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBGT1JDRURfUFJPTUlTRV9DT05TVFJVQ1RPUiQyLCByZWFsOiB0cnVlIH0sIHtcbiAgJ2NhdGNoJzogZnVuY3Rpb24gKG9uUmVqZWN0ZWQpIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgb25SZWplY3RlZCk7XG4gIH1cbn0pO1xuXG4vLyBtYWtlcyBzdXJlIHRoYXQgbmF0aXZlIHByb21pc2UtYmFzZWQgQVBJcyBgUHJvbWlzZSNjYXRjaGAgcHJvcGVybHkgd29ya3Mgd2l0aCBwYXRjaGVkIGBQcm9taXNlI3RoZW5gXG5pZiAoaXNDYWxsYWJsZShOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IpKSB7XG4gIHZhciBtZXRob2QgPSBnZXRCdWlsdEluJDEoJ1Byb21pc2UnKS5wcm90b3R5cGVbJ2NhdGNoJ107XG4gIGlmIChOYXRpdmVQcm9taXNlUHJvdG90eXBlWydjYXRjaCddICE9PSBtZXRob2QpIHtcbiAgICBkZWZpbmVCdWlsdEluJDEoTmF0aXZlUHJvbWlzZVByb3RvdHlwZSwgJ2NhdGNoJywgbWV0aG9kLCB7IHVuc2FmZTogdHJ1ZSB9KTtcbiAgfVxufVxuXG52YXIgJCQyID0gX2V4cG9ydDtcbnZhciBjYWxsJDIgPSBmdW5jdGlvbkNhbGw7XG52YXIgYUNhbGxhYmxlID0gYUNhbGxhYmxlJDk7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUkMSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5JDI7XG52YXIgcGVyZm9ybSA9IHBlcmZvcm0kMztcbnZhciBpdGVyYXRlID0gaXRlcmF0ZSQyO1xudmFyIFBST01JU0VfU1RBVElDU19JTkNPUlJFQ1RfSVRFUkFUSU9OID0gcHJvbWlzZVN0YXRpY3NJbmNvcnJlY3RJdGVyYXRpb247XG5cbi8vIGBQcm9taXNlLnJhY2VgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1wcm9taXNlLnJhY2VcbiQkMih7IHRhcmdldDogJ1Byb21pc2UnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IFBST01JU0VfU1RBVElDU19JTkNPUlJFQ1RfSVRFUkFUSU9OIH0sIHtcbiAgcmFjZTogZnVuY3Rpb24gcmFjZShpdGVyYWJsZSkge1xuICAgIHZhciBDID0gdGhpcztcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlJDEuZihDKTtcbiAgICB2YXIgcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgdmFyIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICRwcm9taXNlUmVzb2x2ZSA9IGFDYWxsYWJsZShDLnJlc29sdmUpO1xuICAgICAgaXRlcmF0ZShpdGVyYWJsZSwgZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgY2FsbCQyKCRwcm9taXNlUmVzb2x2ZSwgQywgcHJvbWlzZSkudGhlbihjYXBhYmlsaXR5LnJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBpZiAocmVzdWx0LmVycm9yKSByZWplY3QocmVzdWx0LnZhbHVlKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcblxudmFyICQkMSA9IF9leHBvcnQ7XG52YXIgY2FsbCQxID0gZnVuY3Rpb25DYWxsO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkkMjtcbnZhciBGT1JDRURfUFJPTUlTRV9DT05TVFJVQ1RPUiQxID0gcHJvbWlzZUNvbnN0cnVjdG9yRGV0ZWN0aW9uLkNPTlNUUlVDVE9SO1xuXG4vLyBgUHJvbWlzZS5yZWplY3RgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1wcm9taXNlLnJlamVjdFxuJCQxKHsgdGFyZ2V0OiAnUHJvbWlzZScsIHN0YXQ6IHRydWUsIGZvcmNlZDogRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkMSB9LCB7XG4gIHJlamVjdDogZnVuY3Rpb24gcmVqZWN0KHIpIHtcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlLmYodGhpcyk7XG4gICAgY2FsbCQxKGNhcGFiaWxpdHkucmVqZWN0LCB1bmRlZmluZWQsIHIpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuXG52YXIgYW5PYmplY3QkMiA9IGFuT2JqZWN0JGM7XG52YXIgaXNPYmplY3QgPSBpc09iamVjdCQ4O1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkkMjtcblxudmFyIHByb21pc2VSZXNvbHZlJDEgPSBmdW5jdGlvbiAoQywgeCkge1xuICBhbk9iamVjdCQyKEMpO1xuICBpZiAoaXNPYmplY3QoeCkgJiYgeC5jb25zdHJ1Y3RvciA9PT0gQykgcmV0dXJuIHg7XG4gIHZhciBwcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5LmYoQyk7XG4gIHZhciByZXNvbHZlID0gcHJvbWlzZUNhcGFiaWxpdHkucmVzb2x2ZTtcbiAgcmVzb2x2ZSh4KTtcbiAgcmV0dXJuIHByb21pc2VDYXBhYmlsaXR5LnByb21pc2U7XG59O1xuXG52YXIgJCA9IF9leHBvcnQ7XG52YXIgZ2V0QnVpbHRJbiA9IGdldEJ1aWx0SW4kODtcbnZhciBGT1JDRURfUFJPTUlTRV9DT05TVFJVQ1RPUiA9IHByb21pc2VDb25zdHJ1Y3RvckRldGVjdGlvbi5DT05TVFJVQ1RPUjtcbnZhciBwcm9taXNlUmVzb2x2ZSA9IHByb21pc2VSZXNvbHZlJDE7XG5cbmdldEJ1aWx0SW4oJ1Byb21pc2UnKTtcblxuLy8gYFByb21pc2UucmVzb2x2ZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXByb21pc2UucmVzb2x2ZVxuJCh7IHRhcmdldDogJ1Byb21pc2UnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SIH0sIHtcbiAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZSh4KSB7XG4gICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKHRoaXMsIHgpO1xuICB9XG59KTtcblxuY29uc3QgSGFyZHdhcmVXYWxsZXRBY2NvdW50c0Zvcm0gPSAoe1xuICBhY2NvdW50cyxcbiAgb25TZWxlY3RlZENoYW5nZWQsXG4gIG9uU3VibWl0LFxuICBvbkNoYW5nZVJvdXRlXG59KSA9PiB7XG4gIHJldHVybiBqc3hzKFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgIGNsYXNzTmFtZTogXCJjaG9vc2UtbGVkZ2VyLWFjY291bnQtZm9ybS13cmFwcGVyXCJcbiAgfSwge1xuICAgIGNoaWxkcmVuOiBbanN4cyhcInBcIiwge1xuICAgICAgY2hpbGRyZW46IFtcIldlIGZvdW5kIFwiLCBhY2NvdW50cy5sZW5ndGgsIFwiIGFjY291bnRzIG9uIHlvdXIgZGV2aWNlLiBTZWxlY3QgdGhlIGFjY291bnQocykgeW91IHdpc2ggdG8gY29ubmVjdC5cIl1cbiAgICB9KSwganN4KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgY2xhc3NOYW1lOiBcImJ1dHRvbi13cmFwcGVyXCJcbiAgICB9LCB7XG4gICAgICBjaGlsZHJlbjoganN4KFwiYnV0dG9uXCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICAgICAgb25DaGFuZ2VSb3V0ZShcIlNwZWNpZnlIRFBhdGhcIik7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAgY2hpbGRyZW46IFwiSEQuLi4vMFwiXG4gICAgICB9KSlcbiAgICB9KSksIGpzeChcImZvcm1cIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICBjbGFzc05hbWU6IFwiZm9ybVwiLFxuICAgICAgb25TdWJtaXQ6IGUgPT4ge1xuICAgICAgICBvblN1Ym1pdChhY2NvdW50cywgZSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgY2hpbGRyZW46IGpzeHMoXCJkaXZcIiwge1xuICAgICAgICBjaGlsZHJlbjogW2pzeChcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICBjbGFzc05hbWU6IFwibndzLWZvcm0tY29udHJvbFwiXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBjaGlsZHJlbjogYWNjb3VudHMubWFwKChhY2NvdW50LCBpbmRleCkgPT4ganN4cyhcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJhY2NvdW50XCJcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogW2pzeChcImlucHV0XCIsIHtcbiAgICAgICAgICAgICAgb25DaGFuZ2U6IGUgPT4ge1xuICAgICAgICAgICAgICAgIG9uU2VsZWN0ZWRDaGFuZ2VkKGluZGV4LCBlLnRhcmdldC5jaGVja2VkKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgY2hlY2tlZDogYWNjb3VudC5zZWxlY3RlZCxcbiAgICAgICAgICAgICAgdHlwZTogXCJjaGVja2JveFwiLFxuICAgICAgICAgICAgICBpZDogYWNjb3VudC5hY2NvdW50SWQsXG4gICAgICAgICAgICAgIG5hbWU6IGFjY291bnQuYWNjb3VudElkLFxuICAgICAgICAgICAgICB2YWx1ZTogYWNjb3VudC5hY2NvdW50SWRcbiAgICAgICAgICAgIH0pLCBqc3hzKFwibGFiZWxcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICAgIGh0bWxGb3I6IGFjY291bnQuYWNjb3VudElkXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGNoaWxkcmVuOiBbXCIgXCIsIGFjY291bnQuYWNjb3VudElkXVxuICAgICAgICAgICAgfSkpLCBqc3goXCJiclwiLCB7fSldXG4gICAgICAgICAgfSksIGluZGV4KSlcbiAgICAgICAgfSkpLCBqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcImFjdGlvbi1idXR0b25zXCJcbiAgICAgICAgfSwge1xuICAgICAgICAgIGNoaWxkcmVuOiBqc3goXCJidXR0b25cIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwibWlkZGxlQnV0dG9uXCIsXG4gICAgICAgICAgICB0eXBlOiBcInN1Ym1pdFwiLFxuICAgICAgICAgICAgZGlzYWJsZWQ6ICFhY2NvdW50cy5zb21lKHggPT4geC5zZWxlY3RlZClcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogXCJDb25uZWN0XCJcbiAgICAgICAgICB9KSlcbiAgICAgICAgfSkpXVxuICAgICAgfSlcbiAgICB9KSldXG4gIH0pKTtcbn07XG5cbnZhciBpbWcgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQmtBQUFBWkNBWUFBQURFNllWakFBQUFDWEJJV1hNQUFBc1RBQUFMRXdFQW1wd1lBQUFBQVhOU1IwSUFyczRjNlFBQUFBUm5RVTFCQUFDeGp3djhZUVVBQUFSM1NVUkJWSGdCcFZaOWFKVlZHSCtlNTV6MzNiaTd6WTloTXoreU1BZU5vRUlxNkE5WlJLUVdFc1FORklJcHNmNVk5RStHc0Q5aUJFRURNVWtEYTZTaFJLS1pZSVdpUmthS2FVR1VHQ0tPVEdNRjg0UE5POTk3NzN2T2VmcTk3MjB5SzVaekQvZHdQdC9uZDM3UDE3bEVrNVFudXo5cm9Va0tUN1Q1Yk5lK1FqVE5MQ0h2MjRoMVhnaCtPbXR3UVlQSDJqVVh3bG5XOU5Sb29xZVBmTFM2TW1tUTU5Y2RlRUdKbGtKWkE1TUdWZWNvQXdnaEJZWlRWWTlmdHVhRFN5OHg4dzlmYkZsOTVKWkFYdXc5ZG1lbGt2UkF5WHhTN3dNRnJ5RzRiSXlXWmlxelBnTWhhRmZHZm4zTlkzQVpHOXNQZi9EeThIaWRadnhrWmMvaDFwcW5QbEtleTZ5c3BNcVVkOWpWQUVZWTZSQ0dEUVR3akdEd0dUZ0FsYndSaWpWMUM5dmFuejU3N3RUKzZyK1lyT3o1cmxYRnJRL3FaK0ZiRHhDZlhTNW9PZ3hsbjR2NDczZjNyYmd3ZG43Rks1L01DYUgyZUFnNlg4ZzNLMmlCTVRpQmtOSlZLYm9kK3plOW1nUFpzWS9VYWljWXpDRTFIZ3BaYzU1OG9sQ1RqVHZXTHh2OXAxbjNiVjQ1aU83VDV6cTNUVTlqOXhUT0x3UTVEOXQ0OGFFWXJ0R2oyUC8yQnBOUzc4blpKb1JkbERzWWQ4dnBoejI3M2xxeWhXNVJubG56M2hPZTZTRXdnaHZ4UFVNVFZmWWUycnB1VU9xT2taZUl4ZFNic1NKOGVUSUFtWHk1dGZ0ck1Qa3ppMEM0QjJaRE5IcCtJTnZMUVVSa2hZaUo2Z0RHa28zNzZEYkVKOGszbWNuWUJTZVNNMnB0TC9YR3N1ck5ueGZuRElRTndDS0FETzE4NDVFZjZUYmswTTUxZzRqb01nbmNEeUJta3J0c05FTVFvdmNEeEdZc0dMMnlETkFVeFB2MFZ5U3M0eXhoZmVZYmFiSmcwQXdnK0lMeWxFQjZuS01wU09wMFdDUjErUVN1RDRFTGxqTkRFZnlScmRYUENVMUJURWdEN3B5T3pWbUMyaUJtMEtnWUFNQ0VlWG92b0NsSWpkS2lWZFEzRlliem1hdHhXUnFNUGNOc0RIeWZOV3NrV2s1VGtKaE5Fd1Z5eEE2aExMNWNsTEpzVzd2b0Z4YTZMaVI1Q0NPZVd6bzNYRnhLdHlFZHkzdG5wN1ZhaEFvRHA2UEVWR3ZKeWUwOWwzUDdLOWs5V1FpalhCdjRCNldHKzBwdkQweWJGRUJIWjZPUGgrL09HYUJzSXZOUkFHcC9aSHYxakplb24rb21zekJrRnNyM0Zoc0xCN3JldjNKTFFLVlN5ZmptYVcyQkpTYXZEbHFSN2M1VnJSKzRBYkx0dGJrWE1laEg3Z2pBOGdaaUQvdHErT3IvQUJaM2RVVy9KNjJMY1BVR2NyVzhwS1NWRkFnNmNIejNPMGwyNXFaSGEvWEd3V1BnOWFBd3d6ZFpBYURYKzd0Yk5zTVlmNSticGFVUzBkRFFFRjhydHNVeENiSTVlNUtSekdoQk1pcU54bGxLanU3ZDhOT1lYanNlUkJ5dFFuZ2NWREwzd0Q5SCs3dmYzWVM3bW5uenFyWnB3U3hyd2toMDRjcE01TlRNeUpkSGJJZ2FFU3l4SjZ0WjVjRGJ3M3FkMHRxVkNwMjVTZS80eVlkcjUvem0vZWhqd3ZweFpIZ04wV2x1YjAvWXQ3YXdkeWtxUllGSHk2TlVRVnJCZDRvNnA2bmdyVkwyQm84a3N1SnFvWHpxOUxuOW02cmo5VTc0YjZXam84T2VQMDgyYVk1TlV4UnNZendEa2VGc1UrTWRVVTNVNFBHMFF0YmFocWhhZERNdUhUeTRmdlMvOUV3SVVwZGV1Vy9aaVNoT2lwRnhVUlJiTmRXRVRGTVJackNGbEVaR2t1UEhkeWNUYWZnTEV4TmlJNllmVXBjQUFBQUFTVVZPUks1Q1lJST1cIjtcblxuY29uc3QgV2FsbGV0Q29ubmVjdGluZyA9ICh7XG4gIHdhbGxldCxcbiAgb25DbG9zZU1vZGFsXG59KSA9PiB7XG4gIHJldHVybiBqc3hzKEZyYWdtZW50LCB7XG4gICAgY2hpbGRyZW46IFtqc3goTW9kYWxIZWFkZXIsIHtcbiAgICAgIHRpdGxlOiBcIlwiLFxuICAgICAgb25DbG9zZU1vZGFsOiBvbkNsb3NlTW9kYWxcbiAgICB9KSwganN4KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgY2xhc3NOYW1lOiBcImNvbm5lY3Rpbmctd3JhcHBlclwiXG4gICAgfSwge1xuICAgICAgY2hpbGRyZW46IGpzeHMoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGNsYXNzTmFtZTogXCJjb250ZW50XCJcbiAgICAgIH0sIHtcbiAgICAgICAgY2hpbGRyZW46IFtqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcImljb25cIlxuICAgICAgICB9LCB7XG4gICAgICAgICAgY2hpbGRyZW46IGpzeChcImltZ1wiLCB7XG4gICAgICAgICAgICBzcmM6IHdhbGxldCA9PT0gbnVsbCB8fCB3YWxsZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdhbGxldC5tZXRhZGF0YS5pY29uVXJsLFxuICAgICAgICAgICAgYWx0OiB3YWxsZXQgPT09IG51bGwgfHwgd2FsbGV0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3YWxsZXQubWV0YWRhdGEubmFtZVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pKSwganN4KFwiaDNcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcImNvbm5lY3RpbmctbmFtZVwiXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBjaGlsZHJlbjogd2FsbGV0ID09PSBudWxsIHx8IHdhbGxldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2FsbGV0Lm1ldGFkYXRhLm5hbWVcbiAgICAgICAgfSkpLCBqc3hzKFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgIGNsYXNzTmFtZTogXCJjb25uZWN0aW5nLWRldGFpbHNcIlxuICAgICAgICB9LCB7XG4gICAgICAgICAgY2hpbGRyZW46IFtqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwic3Bpbm5lclwiXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgY2hpbGRyZW46IGpzeChcImltZ1wiLCB7XG4gICAgICAgICAgICAgIHNyYzogaW1nLFxuICAgICAgICAgICAgICBhbHQ6IFwibG9hZGluZy1pY29uXCJcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSkpLCBqc3hzKFwic3BhblwiLCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogW3RyYW5zbGF0ZShcIm1vZGFsLndhbGxldC5jb25uZWN0aW5nVG9cIiksIFwiIFwiLCB3YWxsZXQgPT09IG51bGwgfHwgd2FsbGV0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3YWxsZXQubWV0YWRhdGEubmFtZSwgXCIuLi5cIl1cbiAgICAgICAgICB9KV1cbiAgICAgICAgfSkpLCBqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcImNvbm5lY3RpbmctbWVzc2FnZVwiXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBjaGlsZHJlbjoganN4KFwic3BhblwiLCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogdHJhbnNsYXRlKGBtb2RhbC53YWxsZXQuY29ubmVjdGluZ01lc3NhZ2UuJHt3YWxsZXQgPT09IG51bGwgfHwgd2FsbGV0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3YWxsZXQudHlwZX1gKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pKV1cbiAgICAgIH0pKVxuICAgIH0pKV1cbiAgfSk7XG59O1xuXG5jb25zdCBMZWRnZXJEZXZpY2VJY29uID0gKCkgPT4ge1xuICByZXR1cm4ganN4cyhcInN2Z1wiLCBPYmplY3QuYXNzaWduKHtcbiAgICB3aWR0aDogXCIzMTdcIixcbiAgICBoZWlnaHQ6IFwiMTU3XCIsXG4gICAgdmlld0JveDogXCIwIDAgMzE3IDE1N1wiLFxuICAgIGZpbGw6IFwibm9uZVwiLFxuICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbiAgfSwge1xuICAgIGNoaWxkcmVuOiBbanN4KFwicGF0aFwiLCB7XG4gICAgICBmaWxsUnVsZTogXCJldmVub2RkXCIsXG4gICAgICBjbGlwUnVsZTogXCJldmVub2RkXCIsXG4gICAgICBkOiBcIk0yNDkuOTkgMTYuMDk5NEMyNzAuMDYzIC0wLjg2NDE1NSAyODkuNzg4IDEuNTg4NzMgMzAxLjQ5NyAxMC43MzY1QzMwNy40MDIgMTUuMzQ5OSAzMTEuMjc4IDIxLjY1NzUgMzEyLjI2NyAyOC4xMjU4QzMxMy4yNDcgMzQuNTQxMiAzMTEuNDEzIDQxLjIyMzMgMzA1LjY5MiA0Ni44MDQ0QzI5Ny4zNjYgNTQuOTI3MyAyODYuMzQzIDU1LjMzNjIgMjczLjAxNSA1MS41MTA5QzI2MS42NTQgNDguMjUgMjQ5LjA1OCA0Mi4wMzc3IDIzNS43MjYgMzUuNDYyN0wyMzUuNzI2IDM1LjQ2MjZMMjM1LjcxNyAzNS40NThDMjMzLjM2NyAzNC4yOTkyIDIzMC45OTUgMzMuMTI5IDIyOC42MDIgMzEuOTYxOEMyMTIuNzQyIDI0LjIyNTMgMTk2LjA2NyAxNi42NTc1IDE3OS44NDIgMTMuODU5NUMxNjMuNTM4IDExLjA0NzkgMTQ3LjU1MiAxMy4wMzEzIDEzMy4yNjYgMjQuNTIyQzEyOC4wMzIgMjguNzMyIDEyMy40NzggMzUuMjA4NiAxMjEuNzE2IDQ0LjgyMDVDMTE5Ljk2MSA1NC4zOTQ3IDEyMC45OTIgNjYuOTc3MSAxMjYuNzAzIDgzLjQzMTFDMTM1LjQzMiAxMDguNTgzIDEzMi44OTkgMTI2LjY3NyAxMjMuNTc1IDEzOC4wNjNDMTE0LjIxNyAxNDkuNDkxIDk3LjU2MTQgMTU0LjczMyA3Ni43ODg3IDE1My4xMjFDNTUuMDA0MyAxNTEuNDMgMjkuMDYyMSAxNDIuMjA2IDMuMjk4NjcgMTI1LjIyN0wwLjg4NzgxNyAxMjcuOTQyQzI3LjI0NzIgMTQ1LjQwNSA1My45MjUxIDE1NC45NTIgNzYuNTEwNSAxNTYuNzA1Qzk3LjkwMjggMTU4LjM2NSAxMTUuOTYgMTUzLjAzNSAxMjYuMzU2IDE0MC4zNDFDMTM2Ljc4NSAxMjcuNjA2IDEzOS4wNDUgMTA4LjAyOSAxMzAuMDk5IDgyLjI1MjRDMTI0LjUyMSA2Ni4xODAxIDEyMy42NDIgNTQuMjQ5MyAxMjUuMjUyIDQ1LjQ2ODdDMTI2Ljg1NCAzNi43MjU4IDEzMC45NCAzMS4wMDYgMTM1LjUxOSAyNy4zMjMyQzE0OC43OTQgMTYuNjQ1OCAxNjMuNjQ5IDE0LjcxNSAxNzkuMjMxIDE3LjQwMjFDMTk0Ljg5MSAyMC4xMDI3IDIxMS4xNDYgMjcuNDQ2MyAyMjcuMDI2IDM1LjE5MjhDMjI5LjM4MSAzNi4zNDE1IDIzMS43MjkgMzcuNTAwMSAyMzQuMDY2IDM4LjY1MzFMMjM0LjA3MyAzOC42NTY4QzI0Ny4zODIgNDUuMjIzIDI2MC4zMjQgNTEuNjA4IDI3Mi4wMjQgNTQuOTY2MkMyODUuODE5IDU4LjkyNTggMjk4LjQ5MyA1OC44NTAxIDMwOC4yMDIgNDkuMzc3NkMzMTQuNzY0IDQyLjk3NTkgMzE2Ljk3NCAzNS4xMjg4IDMxNS44MiAyNy41ODI2QzMxNC42NzUgMjAuMDg5MyAzMTAuMjM3IDEzLjAwMjkgMzAzLjcxIDcuOTAzNjNDMjkwLjU1NSAtMi4zNzM4MiAyNjguOTM4IC00LjYyMDM4IDI0Ny42NyAxMy4zNTM3TDI0OS45OSAxNi4wOTk0WlwiLFxuICAgICAgZmlsbDogXCJ1cmwoI3BhaW50MF9saW5lYXJfM182NzIpXCJcbiAgICB9KSwganN4KFwicGF0aFwiLCB7XG4gICAgICBkOiBcIk0yNjAuMjY0IDE3Ljg3NjdMMTc3LjYwNSA4OS40NjQ5TDE1Ny42NzkgNzMuOTY2NEwyMzkuMjMgMy44NTQyM0wyNjAuMjY0IDE3Ljg3NjdaXCIsXG4gICAgICBmaWxsOiBcIiM2QTcwNzVcIlxuICAgIH0pLCBqc3goXCJwYXRoXCIsIHtcbiAgICAgIGQ6IFwiTTIwNS45MzkgNTQuNDU3N0wxOTkuNzY0IDUwLjI2MzZMMjMzLjMxNiAyMC45MDUzTDIzOS45MDcgMjUuODM5NUwyMDUuOTM5IDU0LjQ1NzdaXCIsXG4gICAgICBmaWxsOiBcIiM0OTRFNTJcIlxuICAgIH0pLCBqc3goXCJwYXRoXCIsIHtcbiAgICAgIGQ6IFwiTTI2MC4yNjQgMTcuODc1N0wxNzcuNjA1IDg5LjQ2MzlMMTgyLjAzMyA5OC4zMjAyTDI2NC4zMjMgMjYuMzYzTDI2MC4yNjQgMTcuODc1N1pcIixcbiAgICAgIGZpbGw6IFwiIzQ5NEU1MlwiXG4gICAgfSksIGpzeChcInBhdGhcIiwge1xuICAgICAgZDogXCJNMTc3LjIzNiA4OS40NjQ2TDE4MS4yOTUgOTguMzIwOUwxNjUuMDU5IDg1Ljc3NDVMMTcwLjk2MyA4NS4wMzY1TDE3Ny4yMzYgODkuNDY0NlpcIixcbiAgICAgIGZpbGw6IFwiYmxhY2tcIlxuICAgIH0pLCBqc3goXCJwYXRoXCIsIHtcbiAgICAgIGQ6IFwiTTkzLjQ3MDggOTkuNjM4NEw5MS45OTQ4IDExMC4xM0wxNzQuNjUzIDkyLjg5NEwxNjQuNjkgODUuNzc0OUw5My40NzA4IDk5LjYzODRaXCIsXG4gICAgICBmaWxsOiBcIiNEQ0RBREFcIlxuICAgIH0pLCBqc3goXCJwYXRoXCIsIHtcbiAgICAgIGQ6IFwiTTkzLjExNTcgMTA0LjMyM0w5NC4zMTQgMTAwLjEyOUwxNjUuNjEzIDg2LjM0ODNMMTY5LjIwOCA4OS4zNDRMOTMuMTE1NyAxMDQuMzIzWlwiLFxuICAgICAgZmlsbDogXCIjQzFDMUMxXCJcbiAgICB9KSwganN4KFwicGF0aFwiLCB7XG4gICAgICBkOiBcIk05NC4yMDg2IDk5Ljc5NjNMODYuMDkwMyAxMDEuMjcyTDkyLjM2MzUgMTEwLjEyOUw5NC4yMDg2IDk5Ljc5NjNaXCIsXG4gICAgICBmaWxsOiBcIiNCM0FBQUFcIlxuICAgIH0pLCBqc3goXCJwYXRoXCIsIHtcbiAgICAgIGZpbGxSdWxlOiBcImV2ZW5vZGRcIixcbiAgICAgIGNsaXBSdWxlOiBcImV2ZW5vZGRcIixcbiAgICAgIGQ6IFwiTTg2LjA5MDMgMTAwLjkwN0w4OS4wMDI3IDc0LjEzMDRMMTc4LjQ1NSA1NS4yNDE2QzE4NC42OTUgNTMuOTk2MiAxOTUuNzY2IDU0Ljc2NzUgMTk3LjE3NyA2My43MDU4QzE5OC4yODQgNzAuNzE3IDE5NS41MDYgNzMuOTk0MyAxOTEuNjI4IDc3LjM1OTJDMTg4LjQ5NSA4MC4wNjcxIDE4MC4xNTIgODIuNDY0NiAxNzguMzQzIDgyLjg5NDRDMTc4LjI5MyA4Mi45MDY0IDE3OC4yNDEgODIuOTE4OCAxNzguMTg2IDgyLjkzMTlDMTc3LjM4IDgzLjEyNDUgMTc2LjAwNyA4My40NTI1IDE3MC42NDQgODQuNTA4OEMxNjkuMDg1IDg0LjgxNTggMTY3LjM4MiA4NS4xNTAxIDE2NS41NTcgODUuNTA3OEwxNjQuOTMzIDg1LjYzQzE0Ni4zMTIgODkuMjc2NCAxMTUuNTI4IDk1LjIyOTcgOTMuOTg0NCA5OS4zODQ5QzkxLjE4MDggOTkuOTI1NyA4OC41MzM3IDEwMC40MzYgODYuMDkwMyAxMDAuOTA3Wk0xODUuMDc2IDc1LjU1NEMxOTAuNzQ4IDczLjM1MzUgMTkzLjk5IDY4LjA3NDUgMTkyLjMxOCA2My43NjMxQzE5MC42NDUgNTkuNDUxNyAxODQuNjkxIDU3Ljc0MDUgMTc5LjAxOSA1OS45NDFDMTczLjM0NyA2Mi4xNDE2IDE3MC4xMDUgNjcuNDIwNiAxNzEuNzc4IDcxLjczMkMxNzMuNDUgNzYuMDQzNCAxNzkuNDA0IDc3Ljc1NDYgMTg1LjA3NiA3NS41NTRaXCIsXG4gICAgICBmaWxsOiBcIiNGNEYxRThcIlxuICAgIH0pLCBqc3goXCJwYXRoXCIsIHtcbiAgICAgIGQ6IFwiTTE5OS43NjQgNTAuMzk5NEwxOTYuNzY4IDQ4LjMwNDNMMjMyLjE5NCAxOC4wNDU0TDIzMy4zMTYgMjEuNjQwM0wxOTkuNzY0IDUwLjM5OTRaXCIsXG4gICAgICBmaWxsOiBcImJsYWNrXCJcbiAgICB9KSwganN4KFwicGF0aFwiLCB7XG4gICAgICBkOiBcIk0yMzkuOTY4IDI1Ljk5NDNMMjMyLjU4OCAyMC40NTkyVjE3LjUwNzFMMjQxLjgxMyAyNC41MTgzTDIzOS45NjggMjUuOTk0M1pcIixcbiAgICAgIGZpbGw6IFwiYmxhY2tcIlxuICAgIH0pLCBqc3goXCJlbGxpcHNlXCIsIHtcbiAgICAgIGN4OiBcIjE4Mi4wODRcIixcbiAgICAgIGN5OiBcIjY4LjA4MTFcIixcbiAgICAgIHJ4OiBcIjEwLjI0MlwiLFxuICAgICAgcnk6IFwiNy40Njc3MlwiLFxuICAgICAgdHJhbnNmb3JtOiBcInJvdGF0ZSgtMjMuNzk0OSAxODIuMDg0IDY4LjA4MTEpXCIsXG4gICAgICBmaWxsOiBcIiM0OTRFNTJcIlxuICAgIH0pLCBqc3goXCJlbGxpcHNlXCIsIHtcbiAgICAgIGN4OiBcIjE4Mi4wODRcIixcbiAgICAgIGN5OiBcIjY4LjA4MTZcIixcbiAgICAgIHJ4OiBcIjYuNjg0NjJcIixcbiAgICAgIHJ5OiBcIjQuODczOTRcIixcbiAgICAgIHRyYW5zZm9ybTogXCJyb3RhdGUoLTIzLjc5NDkgMTgyLjA4NCA2OC4wODE2KVwiLFxuICAgICAgZmlsbDogXCIjNDk0RTUyXCJcbiAgICB9KSwganN4KFwicGF0aFwiLCB7XG4gICAgICBmaWxsUnVsZTogXCJldmVub2RkXCIsXG4gICAgICBjbGlwUnVsZTogXCJldmVub2RkXCIsXG4gICAgICBkOiBcIk0yMzguNzI1IDIuOTMwOTRMMjYwLjM2OCAxNy4yNTY0TDI2NC44NjUgMjYuNDU1NkwxODEuNjE1IDk5LjAzNDFMMTc1LjE2IDk0LjMxMUw5Mi4wMDI4IDExMC45NDdMODUuMzI2NyAxMDEuMzk5TDg4LjMyNjkgNzMuODE1N0wxNzguMTE4IDU0Ljg1NTNMMjM4LjcyNSAyLjkzMDk0Wk0xNzguNTk5IDU2LjI2MjJMODkuNjc4NiA3NS4wMzg4TDg2LjkzMjEgMTAwLjI5Qzg5LjA5NzkgOTkuODcyNSA5MS40MTI0IDk5LjQyNjMgOTMuODQ0NiA5OC45NTcyQzExNS4zODggOTQuODAxOSAxNDYuMTcxIDg4Ljg0ODggMTY0Ljc5MSA4NS4yMDI2TDE2NS40MTUgODUuMDgwNEMxNjcuMjQgODQuNzIyOCAxNjguOTQzIDg0LjM4ODUgMTcwLjUwMSA4NC4wODE2QzE3NS44NTMgODMuMDI3NSAxNzcuMjE5IDgyLjcwMSAxNzguMDE1IDgyLjUxMDdDMTc4LjA3IDgyLjQ5NzYgMTc4LjEyMiA4Mi40ODUyIDE3OC4xNzMgODIuNDczMkMxNzkuMDQ4IDgyLjI2NTIgMTgxLjU1OCA4MS41NjY5IDE4NC4yMzUgODAuNTg1MUMxODYuNzQyIDc5LjY2NTUgMTg5LjI4NiA3OC41MzU0IDE5MC44MDIgNzcuMzc1OEwxOTEuMTUxIDc3LjA5MjJMMTkxLjY0NCA3Ni42NTk1QzE5My4zNDEgNzUuMTQ3IDE5NC43MjMgNzMuNjczOSAxOTUuNjEgNzEuODcxQzE5Ni41NzEgNjkuOTE2IDE5Ni45ODIgNjcuNTAyOSAxOTYuNDQ4IDY0LjExNzhDMTk1LjggNjAuMDEzMSAxOTIuOTU5IDU3Ljc1NzQgMTg5LjQwOCA1Ni42NTY2QzE4NS44MzMgNTUuNTQ4MyAxODEuNjM3IDU1LjY1NjYgMTc4LjYwMyA1Ni4yNjE1QzE3OC42MDEgNTYuMjYxNyAxNzguNiA1Ni4yNjIgMTc4LjU5OSA1Ni4yNjIyWk0xOTIuNjMxIDc3Ljc1NjVMMjU5LjU1NSAxOC45NTMxTDI2My4wNDIgMjYuMDg2OUwxODEuODA4IDk2LjkwNzhMMTc4LjEzMiA4OS41NzEzTDE5MS43MjQgNzguNTI5QzE5MS44NTkgNzguNDI0OSAxOTEuOTg4IDc4LjMyIDE5Mi4xMSA3OC4yMTQ0TDE5Mi4xMTEgNzguMjEzNkMxOTIuMjg2IDc4LjA2MTcgMTkyLjQ2IDc3LjkwOTQgMTkyLjYzMSA3Ny43NTY1Wk0xODUuNDkxIDgxLjY5MDhDMTg1LjI0IDgxLjc4NjggMTg0Ljk5IDgxLjg4MDIgMTg0Ljc0MyA4MS45NzA5QzE4Mi4wMTMgODIuOTcyMyAxNzkuNDQ3IDgzLjY4NzUgMTc4LjUxNCA4My45MDkzQzE3OC40NjMgODMuOTIxMyAxNzguNDExIDgzLjkzMzggMTc4LjM1NiA4My45NDY4QzE3Ny42MzUgODQuMTE5MiAxNzYuNDcyIDg0LjM5NzEgMTcyLjQ5MSA4NS4xOTE5TDE3Ny4xNzIgODguNDQ5MkwxODUuNDkxIDgxLjY5MDhaTTE3Ni42MzEgODkuODcwN0wxNzAuNDc5IDg1LjU5MDNDMTY5LjMwNiA4NS44MjEzIDE2OC4wNTQgODYuMDY3MyAxNjYuNzMxIDg2LjMyNjVMMTc1Ljc2OSA5Mi45Mjc2TDE3OS41NDggOTUuNjkyNEwxNzYuNjMxIDg5Ljg3MDdaTTE2NC43NTggODYuNzEzMkMxNDYuMjUyIDkwLjMzNjIgMTE2LjAyNyA5Ni4xODE3IDk0LjYzMjQgMTAwLjMwOEw5My4yMjU4IDEwOS4xOTdMMTczLjU0MyA5My4xMjkzTDE2NC43NTggODYuNzEzMlpNOTEuODg4IDEwOC4yMDdMOTMuMDkwOSAxMDAuNjA2QzkxLjA4NDggMTAwLjk5MyA4OS4xNjQyIDEwMS4zNjMgODcuMzQ3MSAxMDEuNzEzTDkxLjg4OCAxMDguMjA3Wk0yNTguNTgxIDE3Ljg0MzZMMTk3LjMwNiA3MS42ODQxQzE5OC4xNDIgNjkuNTc3OSAxOTguNDEgNjcuMDc5NSAxOTcuOTA2IDYzLjg4NzZDMTk3LjE0MyA1OS4wNTM5IDE5My43NDMgNTYuNDU0OSAxODkuODQ1IDU1LjI0NjdDMTg2LjkyMSA1NC4zNDAyIDE4My42NjIgNTQuMTkxNiAxODAuODYxIDU0LjQ0OUwyMzguODQgNC43NzY2OEwyNTguNTgxIDE3Ljg0MzZaTTIzMi41MDUgMTYuODJMMjQzLjA4OSAyNC41NjQzTDIwNS45MTUgNTYuNTEwNkwxOTYuMDQyIDQ4LjA2NjVMMjMyLjUwNSAxNi44MlpNMjMyLjExOCAxOS4wOTZMMTk4LjMxMiA0OC4wNjU0TDE5OS43NDQgNDkuMjlMMjMyLjU4NCAyMC45NDI0TDIzMi4xMTggMTkuMDk2Wk0yMzMuNDU2IDIyLjEzOTZMMjAwLjg3OCA1MC4yNjA0TDIwNS45MTMgNTQuNTY2NEwyMzkuMDQxIDI2LjA5NjlMMjMzLjQ1NiAyMi4xMzk2Wk0yNDAuMTk1IDI1LjEwNTRMMjQwLjcxNyAyNC42NTcxTDIzMy43NTkgMTkuNTY2M0wyMzQuMDYgMjAuNzU4NkwyNDAuMTk1IDI1LjEwNTRaXCIsXG4gICAgICBmaWxsOiBcImJsYWNrXCJcbiAgICB9KSwganN4KFwicGF0aFwiLCB7XG4gICAgICBmaWxsUnVsZTogXCJldmVub2RkXCIsXG4gICAgICBjbGlwUnVsZTogXCJldmVub2RkXCIsXG4gICAgICBkOiBcIk0xOTAuMTk0IDY5Ljk3NDRDMTkxLjMyIDY4LjE0MDkgMTkxLjU3NiA2Ni4yMjcxIDE5MC45NDIgNjQuNTkzN0MxOTAuMzA4IDYyLjk2MDMgMTg4LjgyOSA2MS43MTk4IDE4Ni43NjEgNjEuMTI1NEMxODQuNjkxIDYwLjUzMDcgMTgyLjExNiA2MC42MTk2IDE3OS41NTMgNjEuNjEzOUMxNzYuOTkxIDYyLjYwODEgMTc1LjAyOSA2NC4yNzk0IDE3My45MDIgNjYuMTE0MUMxNzIuNzc2IDY3Ljk0NzcgMTcyLjUyIDY5Ljg2MTQgMTczLjE1NCA3MS40OTQ4QzE3My43ODggNzMuMTI4MiAxNzUuMjY3IDc0LjM2ODcgMTc3LjMzNSA3NC45NjMxQzE3OS40MDUgNzUuNTU3OCAxODEuOTggNzUuNDY4OSAxODQuNTQzIDc0LjQ3NDZDMTg3LjEwNSA3My40ODA0IDE4OS4wNjcgNzEuODA5MSAxOTAuMTk0IDY5Ljk3NDRaTTE4NS4wNzcgNzUuODUwOEMxOTAuNzQ5IDczLjY1MDIgMTkzLjk5MSA2OC4zNzEyIDE5Mi4zMTggNjQuMDU5OEMxOTAuNjQ1IDU5Ljc0ODQgMTg0LjY5MSA1OC4wMzcyIDE3OS4wMTkgNjAuMjM3OEMxNzMuMzQ3IDYyLjQzODMgMTcwLjEwNSA2Ny43MTczIDE3MS43NzggNzIuMDI4N0MxNzMuNDUxIDc2LjM0MDEgMTc5LjQwNSA3OC4wNTEzIDE4NS4wNzcgNzUuODUwOFpcIixcbiAgICAgIGZpbGw6IFwiYmxhY2tcIlxuICAgIH0pLCBqc3goXCJwYXRoXCIsIHtcbiAgICAgIGZpbGxSdWxlOiBcImV2ZW5vZGRcIixcbiAgICAgIGNsaXBSdWxlOiBcImV2ZW5vZGRcIixcbiAgICAgIGQ6IFwiTTE4Ny4zOTEgNjkuMTY5QzE4OC4xMjcgNjcuOTcxMyAxODguMjY2IDY2Ljc3MjEgMTg3Ljg4MSA2NS43ODEyQzE4Ny40OTcgNjQuNzkwMyAxODYuNTg2IDYzLjk5ODQgMTg1LjIzNSA2My42MTAyQzE4My44ODMgNjMuMjIxNiAxODIuMTczIDYzLjI3NDEgMTgwLjQ1NiA2My45NDA0QzE3OC43MzggNjQuNjA2OCAxNzcuNDQxIDY1LjcyMDggMTc2LjcwNSA2Ni45MTk2QzE3NS45NjkgNjguMTE3MiAxNzUuODMgNjkuMzE2NSAxNzYuMjE1IDcwLjMwNzRDMTc2LjU5OSA3MS4yOTgzIDE3Ny41MTEgNzIuMDkwMSAxNzguODYxIDcyLjQ3ODNDMTgwLjIxNCA3Mi44NjY5IDE4MS45MjMgNzIuODE0NCAxODMuNjQgNzIuMTQ4MUMxODUuMzU4IDcxLjQ4MTggMTg2LjY1NSA3MC4zNjc4IDE4Ny4zOTEgNjkuMTY5Wk0xODQuMTc0IDczLjUyNDJDMTg4LjE1NiA3MS45Nzk1IDE5MC40MzIgNjguMjczOCAxODkuMjU3IDY1LjI0NzNDMTg4LjA4MyA2Mi4yMjA4IDE4My45MDQgNjEuMDE5NiAxNzkuOTIyIDYyLjU2NDNDMTc1Ljk0IDY0LjEwOTEgMTczLjY2NSA2Ny44MTQ4IDE3NC44MzkgNzAuODQxMkMxNzYuMDEzIDczLjg2NzcgMTgwLjE5MyA3NS4wNjg5IDE4NC4xNzQgNzMuNTI0MlpcIixcbiAgICAgIGZpbGw6IFwiYmxhY2tcIlxuICAgIH0pLCBqc3goXCJwYXRoXCIsIHtcbiAgICAgIGQ6IFwiTTI0MC40OTkgNDEuMjQ0MUMyMzkuNzQ0IDQwLjM2NDkgMjM5Ljg0NCAzOS4wNCAyNDAuNzI0IDM4LjI4NUwyNDkuNzgxIDMwLjUwNjdDMjUwLjY2IDI5Ljc1MTYgMjUxLjk4NSAyOS44NTIzIDI1Mi43NCAzMC43MzE1VjMwLjczMTVDMjUzLjQ5NSAzMS42MTA4IDI1My4zOTUgMzIuOTM1NiAyNTIuNTE2IDMzLjY5MDdMMjQzLjQ1OCA0MS40NjlDMjQyLjU3OSA0Mi4yMjQgMjQxLjI1NCA0Mi4xMjM0IDI0MC40OTkgNDEuMjQ0MVY0MS4yNDQxWlwiLFxuICAgICAgZmlsbDogXCJibGFja1wiXG4gICAgfSksIGpzeChcInBhdGhcIiwge1xuICAgICAgZmlsbFJ1bGU6IFwiZXZlbm9kZFwiLFxuICAgICAgY2xpcFJ1bGU6IFwiZXZlbm9kZFwiLFxuICAgICAgZDogXCJNMjUwLjc0MyAzMS42MjY1TDI0MS42ODUgMzkuNDA0OEMyNDEuNDI0IDM5LjYyODcgMjQxLjM5NSA0MC4wMjE3IDI0MS42MTkgNDAuMjgyNUMyNDEuODQyIDQwLjU0MzMgMjQyLjIzNSA0MC41NzMxIDI0Mi40OTYgNDAuMzQ5MkwyNTEuNTU0IDMyLjU3MDlDMjUxLjgxNSAzMi4zNDY5IDI1MS44NDUgMzEuOTU0IDI1MS42MjEgMzEuNjkzMkMyNTEuMzk3IDMxLjQzMjQgMjUxLjAwNCAzMS40MDI1IDI1MC43NDMgMzEuNjI2NVpNMjQwLjcyNCAzOC4yODVDMjM5Ljg0NCAzOS4wNCAyMzkuNzQ0IDQwLjM2NDkgMjQwLjQ5OSA0MS4yNDQxQzI0MS4yNTQgNDIuMTIzNCAyNDIuNTc5IDQyLjIyNCAyNDMuNDU4IDQxLjQ2OUwyNTIuNTE2IDMzLjY5MDdDMjUzLjM5NSAzMi45MzU2IDI1My40OTUgMzEuNjEwOCAyNTIuNzQgMzAuNzMxNUMyNTEuOTg1IDI5Ljg1MjMgMjUwLjY2IDI5Ljc1MTYgMjQ5Ljc4MSAzMC41MDY3TDI0MC43MjQgMzguMjg1WlwiLFxuICAgICAgZmlsbDogXCJibGFja1wiXG4gICAgfSksIGpzeChcInBhdGhcIiwge1xuICAgICAgZDogXCJNMjA1Ljc3OSA3MS40NjQ3QzIwNS4wMDUgNzAuNTY0MiAyMDUuMTA4IDY5LjIwNzMgMjA2LjAwOSA2OC40MzM5TDIxNC45ODkgNjAuNzIxOEMyMTUuODkgNTkuOTQ4NSAyMTcuMjQ3IDYwLjA1MTYgMjE4LjAyIDYwLjk1MjFWNjAuOTUyMUMyMTguNzkzIDYxLjg1MjYgMjE4LjY5IDYzLjIwOTUgMjE3Ljc5IDYzLjk4MjlMMjA4LjgwOSA3MS42OTVDMjA3LjkwOSA3Mi40NjgzIDIwNi41NTIgNzIuMzY1MiAyMDUuNzc5IDcxLjQ2NDdWNzEuNDY0N1pcIixcbiAgICAgIGZpbGw6IFwiYmxhY2tcIlxuICAgIH0pLCBqc3goXCJwYXRoXCIsIHtcbiAgICAgIGZpbGxSdWxlOiBcImV2ZW5vZGRcIixcbiAgICAgIGNsaXBSdWxlOiBcImV2ZW5vZGRcIixcbiAgICAgIGQ6IFwiTTIxNS45NTEgNjEuODQxNkwyMDYuOTcgNjkuNTUzN0MyMDYuNjg4IDY5Ljc5NiAyMDYuNjU2IDcwLjIyMSAyMDYuODk4IDcwLjUwMzFDMjA3LjE0MSA3MC43ODUxIDIwNy41NjYgNzAuODE3NCAyMDcuODQ4IDcwLjU3NTJMMjE2LjgyOCA2Mi44NjNDMjE3LjExIDYyLjYyMDggMjE3LjE0MyA2Mi4xOTU4IDIxNi45IDYxLjkxMzdDMjE2LjY1OCA2MS42MzE3IDIxNi4yMzMgNjEuNTk5NCAyMTUuOTUxIDYxLjg0MTZaTTIwNi4wMDkgNjguNDMzOUMyMDUuMTA4IDY5LjIwNzMgMjA1LjAwNSA3MC41NjQyIDIwNS43NzkgNzEuNDY0N0MyMDYuNTUyIDcyLjM2NTIgMjA3LjkwOSA3Mi40NjgzIDIwOC44MDkgNzEuNjk1TDIxNy43OSA2My45ODI5QzIxOC42OSA2My4yMDk1IDIxOC43OTMgNjEuODUyNiAyMTguMDIgNjAuOTUyMUMyMTcuMjQ3IDYwLjA1MTYgMjE1Ljg5IDU5Ljk0ODUgMjE0Ljk4OSA2MC43MjE4TDIwNi4wMDkgNjguNDMzOVpcIixcbiAgICAgIGZpbGw6IFwiYmxhY2tcIlxuICAgIH0pLCBqc3goXCJjaXJjbGVcIiwge1xuICAgICAgY3g6IFwiMTQxLjM1NlwiLFxuICAgICAgY3k6IFwiMTkuNTI1XCIsXG4gICAgICByOiBcIjEwLjE4NTVcIixcbiAgICAgIGZpbGw6IFwiI0ZFODlCNFwiXG4gICAgfSksIGpzeChcImVsbGlwc2VcIiwge1xuICAgICAgY3g6IFwiMTM5LjA2MlwiLFxuICAgICAgY3k6IFwiMTQuNzA5NFwiLFxuICAgICAgcng6IFwiMi40MjUxOVwiLFxuICAgICAgcnk6IFwiMS45NDAxNVwiLFxuICAgICAgdHJhbnNmb3JtOiBcInJvdGF0ZSgtMzQuNTQ0IDEzOS4wNjIgMTQuNzA5NClcIixcbiAgICAgIGZpbGw6IFwiI0ZERjdGRlwiXG4gICAgfSksIGpzeChcImNpcmNsZVwiLCB7XG4gICAgICBjeDogXCIyNTIuNDg5XCIsXG4gICAgICBjeTogXCI3OS43NTc3XCIsXG4gICAgICByOiBcIjcuNzg4OTNcIixcbiAgICAgIGZpbGw6IFwiI0VDNTIzNlwiXG4gICAgfSksIGpzeChcImVsbGlwc2VcIiwge1xuICAgICAgY3g6IFwiMjUwLjQzNFwiLFxuICAgICAgY3k6IFwiNzYuMzcwMVwiLFxuICAgICAgcng6IFwiMi42MTI3MlwiLFxuICAgICAgcnk6IFwiMi4wOTAxOFwiLFxuICAgICAgdHJhbnNmb3JtOiBcInJvdGF0ZSgtMzQuNTQ0IDI1MC40MzQgNzYuMzcwMSlcIixcbiAgICAgIGZpbGw6IFwiI0VEQjY5RFwiXG4gICAgfSksIGpzeChcInBhdGhcIiwge1xuICAgICAgZmlsbFJ1bGU6IFwiZXZlbm9kZFwiLFxuICAgICAgY2xpcFJ1bGU6IFwiZXZlbm9kZFwiLFxuICAgICAgZDogXCJNMTAwLjQzNiA3OS45MjU0QzEwMC40NjEgNzkuNjU2NyAxMDAuNzMyIDc5LjM4OTcgMTAxLjA0MiA3OS4zMjlMMTA2LjY1NyA3OC4yMjk5QzEwNy41ODcgNzguMDQ3OCAxMDguMjgxIDc4LjU1MzYgMTA4LjIwNyA3OS4zNTk2TDEwNy43NTkgODQuMjI0M0MxMDcuNzM0IDg0LjQ5MyAxMDcuNDYzIDg0Ljc2IDEwNy4xNTMgODQuODIwN0wxMDAuNDE2IDg2LjEzOTZDMTAwLjEwNiA4Ni4yMDAzIDk5Ljg3NDIgODYuMDMxNyA5OS44OTkgODUuNzYzMUwxMDAuNDM2IDc5LjkyNTRaXCIsXG4gICAgICBmaWxsOiBcIiNCM0FBQUFcIlxuICAgIH0pLCBqc3goXCJwYXRoXCIsIHtcbiAgICAgIGZpbGxSdWxlOiBcImV2ZW5vZGRcIixcbiAgICAgIGNsaXBSdWxlOiBcImV2ZW5vZGRcIixcbiAgICAgIGQ6IFwiTTk1Ljg1NTMgODEuNzc3NUM5NS45Mjk0IDgwLjk3MTUgOTYuNzQzNyA4MC4xNzA0IDk3LjY3MzkgNzkuOTg4M0w5OC43OTY4IDc5Ljc2ODVDOTkuMTA2OSA3OS43MDc4IDk5LjMzODIgNzkuODc2NCA5OS4zMTM1IDgwLjE0NTFMOTkuMTM0NCA4Mi4wOTFDOTkuMTA5NiA4Mi4zNTk3IDk4LjgzODIgODIuNjI2NyA5OC41MjgyIDgyLjY4NzRMOTYuMjgyNCA4My4xMjdDOTUuOTcyMyA4My4xODc3IDk1Ljc0MSA4My4wMTkxIDk1Ljc2NTcgODIuNzUwNUw5NS44NTUzIDgxLjc3NzVaXCIsXG4gICAgICBmaWxsOiBcIiNCM0FBQUFcIlxuICAgIH0pLCBqc3goXCJwYXRoXCIsIHtcbiAgICAgIGZpbGxSdWxlOiBcImV2ZW5vZGRcIixcbiAgICAgIGNsaXBSdWxlOiBcImV2ZW5vZGRcIixcbiAgICAgIGQ6IFwiTTk1LjU4NjUgODQuNjk2NUM5NS42MTEyIDg0LjQyNzggOTUuODgyNiA4NC4xNjA4IDk2LjE5MjcgODQuMTAwMUw5OC40Mzg1IDgzLjY2MDVDOTguNzQ4NiA4My41OTk4IDk4Ljk3OTkgODMuNzY4NCA5OC45NTUyIDg0LjAzN0w5OC43NzYxIDg1Ljk4MjlDOTguNzUxMyA4Ni4yNTE2IDk4LjQ3OTkgODYuNTE4NiA5OC4xNjk5IDg2LjU3OTNMOTUuOTI0MSA4Ny4wMTlDOTUuNjE0IDg3LjA3OTcgOTUuMzgyNyA4Ni45MTExIDk1LjQwNzQgODYuNjQyNEw5NS41ODY1IDg0LjY5NjVaXCIsXG4gICAgICBmaWxsOiBcIiNCM0FBQUFcIlxuICAgIH0pLCBqc3goXCJwYXRoXCIsIHtcbiAgICAgIGZpbGxSdWxlOiBcImV2ZW5vZGRcIixcbiAgICAgIGNsaXBSdWxlOiBcImV2ZW5vZGRcIixcbiAgICAgIGQ6IFwiTTk1LjIyODIgODguNTg4NEM5NS4yNTI5IDg4LjMxOTcgOTUuNTI0NCA4OC4wNTI3IDk1LjgzNDQgODcuOTkyTDk4LjA4MDIgODcuNTUyNEM5OC4zOTAzIDg3LjQ5MTcgOTguNjIxNiA4Ny42NjAzIDk4LjU5NjkgODcuOTI5TDk4LjQxNzggODkuODc0OUM5OC4zOTMxIDkwLjE0MzUgOTguMTIxNiA5MC40MTA1IDk3LjgxMTYgOTAuNDcxMkw5Ni42ODg3IDkwLjY5MTFDOTUuNzU4NCA5MC44NzMyIDk1LjA2NDUgOTAuMzY3NCA5NS4xMzg3IDg5LjU2MTRMOTUuMjI4MiA4OC41ODg0WlwiLFxuICAgICAgZmlsbDogXCIjQjNBQUFBXCJcbiAgICB9KSwganN4KFwicGF0aFwiLCB7XG4gICAgICBmaWxsUnVsZTogXCJldmVub2RkXCIsXG4gICAgICBjbGlwUnVsZTogXCJldmVub2RkXCIsXG4gICAgICBkOiBcIk05OS43MTk3IDg3LjcwOUM5OS43NDQ0IDg3LjQ0MDMgMTAwLjAxNiA4Ny4xNzMzIDEwMC4zMjYgODcuMTEyNkwxMDIuNTcyIDg2LjY3M0MxMDIuODgyIDg2LjYxMjMgMTAzLjExMyA4Ni43ODA5IDEwMy4wODggODcuMDQ5NkwxMDIuOTA5IDg4Ljk5NTVDMTAyLjg4NSA4OS4yNjQxIDEwMi42MTMgODkuNTMxMiAxMDIuMzAzIDg5LjU5MTlMMTAwLjA1NyA5MC4wMzE1Qzk5Ljc0NzIgOTAuMDkyMiA5OS41MTU5IDg5LjkyMzYgOTkuNTQwNiA4OS42NTQ5TDk5LjcxOTcgODcuNzA5WlwiLFxuICAgICAgZmlsbDogXCIjQjNBQUFBXCJcbiAgICB9KSwganN4KFwicGF0aFwiLCB7XG4gICAgICBmaWxsUnVsZTogXCJldmVub2RkXCIsXG4gICAgICBjbGlwUnVsZTogXCJldmVub2RkXCIsXG4gICAgICBkOiBcIk0xMDQuMjExIDg2LjgyOThDMTA0LjIzNiA4Ni41NjExIDEwNC41MDcgODYuMjk0MSAxMDQuODE3IDg2LjIzMzRMMTA3LjA2MyA4NS43OTM4QzEwNy4zNzMgODUuNzMzMSAxMDcuNjA1IDg1LjkwMTcgMTA3LjU4IDg2LjE3MDRMMTA3LjQ5IDg3LjE0MzNDMTA3LjQxNiA4Ny45NDkzIDEwNi42MDIgODguNzUwNCAxMDUuNjcyIDg4LjkzMjVMMTA0LjU0OSA4OS4xNTIzQzEwNC4yMzkgODkuMjEzIDEwNC4wMDcgODkuMDQ0NCAxMDQuMDMyIDg4Ljc3NTdMMTA0LjIxMSA4Ni44Mjk4WlwiLFxuICAgICAgZmlsbDogXCIjQjNBQUFBXCJcbiAgICB9KSwganN4KFwiZGVmc1wiLCB7XG4gICAgICBjaGlsZHJlbjoganN4cyhcImxpbmVhckdyYWRpZW50XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBpZDogXCJwYWludDBfbGluZWFyXzNfNjcyXCIsXG4gICAgICAgIHgxOiBcIi00NC41MTk1XCIsXG4gICAgICAgIHkxOiBcIjEyMi40MlwiLFxuICAgICAgICB4MjogXCIyNjMuMzU3XCIsXG4gICAgICAgIHkyOiBcIi04LjY1MDIzXCIsXG4gICAgICAgIGdyYWRpZW50VW5pdHM6IFwidXNlclNwYWNlT25Vc2VcIlxuICAgICAgfSwge1xuICAgICAgICBjaGlsZHJlbjogW2pzeChcInN0b3BcIiwge1xuICAgICAgICAgIG9mZnNldDogXCIwLjExMDY5N1wiLFxuICAgICAgICAgIHN0b3BDb2xvcjogXCIjMjMyMzIzXCJcbiAgICAgICAgfSksIGpzeChcInN0b3BcIiwge1xuICAgICAgICAgIG9mZnNldDogXCIxXCIsXG4gICAgICAgICAgc3RvcENvbG9yOiBcIiMzRDNEM0RcIlxuICAgICAgICB9KV1cbiAgICAgIH0pKVxuICAgIH0pXVxuICB9KSk7XG59O1xuXG5jb25zdCBVcEFycm93SWNvbiA9ICgpID0+IHtcbiAgcmV0dXJuIGpzeChcInN2Z1wiLCBPYmplY3QuYXNzaWduKHtcbiAgICB3aWR0aDogXCIxMFwiLFxuICAgIGhlaWdodDogXCI3XCIsXG4gICAgdmlld0JveDogXCIwIDAgMTAgN1wiLFxuICAgIGZpbGw6IFwibm9uZVwiLFxuICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbiAgfSwge1xuICAgIGNoaWxkcmVuOiBqc3goXCJwYXRoXCIsIHtcbiAgICAgIGQ6IFwiTTkgNS40NzYyTDUgMS40NzYyTDEgNS40NzYyXCIsXG4gICAgICBzdHJva2U6IFwiIzRGN0NEMVwiLFxuICAgICAgc3Ryb2tlV2lkdGg6IFwiMS41XCIsXG4gICAgICBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsXG4gICAgICBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiXG4gICAgfSlcbiAgfSkpO1xufTtcblxuY29uc3QgRG93bkFycm93SWNvbiA9ICgpID0+IHtcbiAgcmV0dXJuIGpzeChcInN2Z1wiLCBPYmplY3QuYXNzaWduKHtcbiAgICB3aWR0aDogXCIxMFwiLFxuICAgIGhlaWdodDogXCI3XCIsXG4gICAgdmlld0JveDogXCIwIDAgMTAgN1wiLFxuICAgIGZpbGw6IFwibm9uZVwiLFxuICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbiAgfSwge1xuICAgIGNoaWxkcmVuOiBqc3goXCJwYXRoXCIsIHtcbiAgICAgIGQ6IFwiTTEgMS41MjM4Mkw1IDUuNTIzODJMOSAxLjUyMzgyXCIsXG4gICAgICBzdHJva2U6IFwiIzRGN0NEMVwiLFxuICAgICAgc3Ryb2tlV2lkdGg6IFwiMS41XCIsXG4gICAgICBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsXG4gICAgICBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiXG4gICAgfSlcbiAgfSkpO1xufTtcblxuY29uc3QgREVGQVVMVF9ERVJJVkFUSU9OX1BBVEggPSBcIjQ0Jy8zOTcnLzAnLzAnLzEnXCI7XG5jb25zdCBEZXJpdmF0aW9uUGF0aCA9ICh7XG4gIHNlbGVjdG9yLFxuICBvcHRpb25zLFxuICBvbkJhY2ssXG4gIG9uQ29ubmVjdGVkLFxuICBwYXJhbXMsXG4gIG9uRXJyb3IsXG4gIG9uQ2xvc2VNb2RhbFxufSkgPT4ge1xuICBjb25zdCBbcm91dGUsIHNldFJvdXRlXSA9IHVzZVN0YXRlKFwiRW50ZXJEZXJpdmF0aW9uUGF0aFwiKTtcbiAgY29uc3QgW2Rlcml2YXRpb25QYXRoLCBzZXREZXJpdmF0aW9uUGF0aF0gPSB1c2VTdGF0ZShERUZBVUxUX0RFUklWQVRJT05fUEFUSCk7XG4gIGNvbnN0IFtjdXN0b21EZXJpdmF0aW9uUGF0aCwgc2V0Q3VzdG9tRGVyaXZhdGlvblBhdGhdID0gdXNlU3RhdGUoMSk7XG4gIGNvbnN0IFthY2NvdW50cywgc2V0QWNjb3VudHNdID0gdXNlU3RhdGUoW10pO1xuICBjb25zdCBbc2VsZWN0ZWRBY2NvdW50cywgc2V0U2VsZWN0ZWRBY2NvdW50c10gPSB1c2VTdGF0ZShbXSk7XG4gIGNvbnN0IFtoYXJkd2FyZVdhbGxldCwgc2V0SGFyZHdhcmVXYWxsZXRdID0gdXNlU3RhdGUoKTtcbiAgY29uc3QgW2N1c3RvbUFjY291bnRJZCwgc2V0Q3VzdG9tQWNjb3VudElkXSA9IHVzZVN0YXRlKFwiXCIpO1xuICBjb25zdCBbY29ubmVjdGluZywgc2V0Q29ubmVjdGluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IGluaXRhbEhlYWRlclRpdGxlID0gdHJhbnNsYXRlKFwibW9kYWwubGVkZ2VyLmNvbm5lY3RXaXRoTGVkZ2VyXCIpO1xuICBjb25zdCBbaGVhZGVyVGl0bGUsIHNldEhlYWRlclRpdGxlXSA9IHVzZVN0YXRlKGluaXRhbEhlYWRlclRpdGxlKTtcbiAgY29uc3QgZ2V0QWNjb3VudElkcyA9IHB1YmxpY0tleSA9PiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIGZldGNoKGAke3NlbGVjdG9yLm9wdGlvbnMubmV0d29yay5pbmRleGVyVXJsfS9wdWJsaWNLZXkvZWQyNTUxOToke3B1YmxpY0tleX0vYWNjb3VudHNgKTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZ2V0IGFjY291bnQgaWQgZnJvbSBwdWJsaWMga2V5XCIpO1xuICAgIH1cbiAgICBjb25zdCBhY2NvdW50SWRzID0geWllbGQgcmVzcG9uc2UuanNvbigpO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhY2NvdW50SWRzKSB8fCAhYWNjb3VudElkcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIGFjY291bnRJZHM7XG4gIH0pO1xuICBjb25zdCByZXNvbHZlQWNjb3VudHMgPSB3YWxsZXQgPT4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgY29uc3QgcHVibGljS2V5ID0geWllbGQgd2FsbGV0LmdldFB1YmxpY0tleShkZXJpdmF0aW9uUGF0aCk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGFjY291bnRJZHMgPSB5aWVsZCBnZXRBY2NvdW50SWRzKHB1YmxpY0tleSk7XG4gICAgICByZXR1cm4gYWNjb3VudElkcy5tYXAoKGFjY291bnRJZCwgaW5kZXgpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkZXJpdmF0aW9uUGF0aCxcbiAgICAgICAgICBwdWJsaWNLZXksXG4gICAgICAgICAgYWNjb3VudElkLFxuICAgICAgICAgIHNlbGVjdGVkOiBpbmRleCA9PT0gMFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgaGFuZGxlVmFsaWRhdGVBY2NvdW50ID0gKCkgPT4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgY29uc3Qgd2FsbGV0ID0geWllbGQgc2VsZWN0b3Iud2FsbGV0KHBhcmFtcy53YWxsZXRJZCk7XG4gICAgaWYgKHdhbGxldC50eXBlICE9PSBcImhhcmR3YXJlXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2V0Q29ubmVjdGluZyh0cnVlKTtcbiAgICBzZXRIYXJkd2FyZVdhbGxldCh3YWxsZXQpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNvbHZlZEFjY291bnRzID0geWllbGQgcmVzb2x2ZUFjY291bnRzKHdhbGxldCk7XG4gICAgICBpZiAoIXJlc29sdmVkQWNjb3VudHMpIHtcbiAgICAgICAgc2V0Um91dGUoXCJBZGRDdXN0b21BY2NvdW50SWRcIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5vQWNjb3VudHMgPSByZXNvbHZlZEFjY291bnRzLmxlbmd0aCA9PT0gMDtcbiAgICAgIGNvbnN0IG11bHRpcGxlQWNjb3VudHMgPSByZXNvbHZlZEFjY291bnRzLmxlbmd0aCA+IDE7XG4gICAgICBpZiAobm9BY2NvdW50cykge1xuICAgICAgICBzZXRIZWFkZXJUaXRsZSh0cmFuc2xhdGUoXCJtb2RhbC5sZWRnZXIubm9BY2NvdW50c0ZvdW5kXCIpKTtcbiAgICAgICAgc2V0Um91dGUoXCJOb0FjY291bnRzRm91bmRcIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNldEFjY291bnRzKHJlc29sdmVkQWNjb3VudHMpO1xuICAgICAgaWYgKCFtdWx0aXBsZUFjY291bnRzKSB7XG4gICAgICAgIHNldFNlbGVjdGVkQWNjb3VudHMocmVzb2x2ZWRBY2NvdW50cyk7XG4gICAgICAgIHNldFJvdXRlKFwiT3ZlcnZpZXdBY2NvdW50c1wiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldEhlYWRlclRpdGxlKHRyYW5zbGF0ZShcIm1vZGFsLmxlZGdlci5zZWxlY3RZb3VyQWNjb3VudHNcIikpO1xuICAgICAgICBzZXRSb3V0ZShcIkNob29zZUFjY291bnRcIik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBzZXRDb25uZWN0aW5nKGZhbHNlKTtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBlcnIgJiYgdHlwZW9mIGVyciA9PT0gXCJvYmplY3RcIiAmJiBcIm1lc3NhZ2VcIiBpbiBlcnIgPyBlcnIubWVzc2FnZSA6IFwiU29tZXRoaW5nIHdlbnQgd3JvbmdcIjtcbiAgICAgIG9uRXJyb3IobWVzc2FnZSwgd2FsbGV0KTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0Q29ubmVjdGluZyhmYWxzZSk7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgaGFuZGxlQWRkQ3VzdG9tQWNjb3VudElkID0gKCkgPT4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHNldENvbm5lY3RpbmcodHJ1ZSk7XG4gICAgICBjb25zdCBwdWJsaWNLZXkgPSB5aWVsZCBoYXJkd2FyZVdhbGxldC5nZXRQdWJsaWNLZXkoZGVyaXZhdGlvblBhdGgpO1xuICAgICAgY29uc3QgYWNjb3VudExpc3QgPSBbe1xuICAgICAgICBkZXJpdmF0aW9uUGF0aDogZGVyaXZhdGlvblBhdGgsXG4gICAgICAgIHB1YmxpY0tleSxcbiAgICAgICAgYWNjb3VudElkOiBjdXN0b21BY2NvdW50SWQsXG4gICAgICAgIHNlbGVjdGVkOiB0cnVlXG4gICAgICB9XTtcbiAgICAgIHNldEFjY291bnRzKGFjY291bnRMaXN0KTtcbiAgICAgIHNldFNlbGVjdGVkQWNjb3VudHMoYWNjb3VudExpc3QpO1xuICAgICAgc2V0SGVhZGVyVGl0bGUodHJhbnNsYXRlKFwibW9kYWwubGVkZ2VyLmNvbm5lY3RpbmcxQWNjb3VudFwiKSk7XG4gICAgICBzZXRSb3V0ZShcIk92ZXJ2aWV3QWNjb3VudHNcIik7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBzZXRDb25uZWN0aW5nKGZhbHNlKTtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBlcnIgJiYgdHlwZW9mIGVyciA9PT0gXCJvYmplY3RcIiAmJiBcIm1lc3NhZ2VcIiBpbiBlcnIgPyBlcnIubWVzc2FnZSA6IFwiU29tZXRoaW5nIHdlbnQgd3JvbmdcIjtcbiAgICAgIG9uRXJyb3IobWVzc2FnZSwgaGFyZHdhcmVXYWxsZXQpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRDb25uZWN0aW5nKGZhbHNlKTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBoYW5kbGVTaWduSW4gPSAoKSA9PiB7XG4gICAgY29uc3QgbWFwQWNjb3VudHMgPSBzZWxlY3RlZEFjY291bnRzLm1hcChhY2NvdW50ID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRlcml2YXRpb25QYXRoOiBhY2NvdW50LmRlcml2YXRpb25QYXRoLFxuICAgICAgICBwdWJsaWNLZXk6IGFjY291bnQucHVibGljS2V5LFxuICAgICAgICBhY2NvdW50SWQ6IGFjY291bnQuYWNjb3VudElkXG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBoYXJkd2FyZVdhbGxldC5zaWduSW4oe1xuICAgICAgY29udHJhY3RJZDogb3B0aW9ucy5jb250cmFjdElkLFxuICAgICAgbWV0aG9kTmFtZXM6IG9wdGlvbnMubWV0aG9kTmFtZXMsXG4gICAgICBhY2NvdW50czogbWFwQWNjb3VudHNcbiAgICB9KS50aGVuKCgpID0+IG9uQ29ubmVjdGVkKCkpLmNhdGNoKGVyciA9PiB7XG4gICAgICBvbkVycm9yKGBFcnJvcjogJHtlcnIubWVzc2FnZX1gLCBoYXJkd2FyZVdhbGxldCk7XG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IGhhbmRsZU9uQmFja0J1dHRvbkNsaWNrID0gKCkgPT4ge1xuICAgIGlmIChyb3V0ZSA9PT0gXCJTcGVjaWZ5SERQYXRoXCIgfHwgcm91dGUgPT09IFwiTm9BY2NvdW50c0ZvdW5kXCIgfHwgcm91dGUgPT09IFwiQ2hvb3NlQWNjb3VudFwiKSB7XG4gICAgICBzZXRIZWFkZXJUaXRsZSh0cmFuc2xhdGUoXCJtb2RhbC5sZWRnZXIuY29ubmVjdFdpdGhMZWRnZXJcIikpO1xuICAgICAgc2V0Um91dGUoXCJFbnRlckRlcml2YXRpb25QYXRoXCIpO1xuICAgIH1cbiAgICBpZiAocm91dGUgPT09IFwiT3ZlcnZpZXdBY2NvdW50c1wiKSB7XG4gICAgICBzZXRIZWFkZXJUaXRsZSh0cmFuc2xhdGUoXCJtb2RhbC5sZWRnZXIuc2VsZWN0WW91ckFjY291bnRzXCIpKTtcbiAgICAgIHNldFJvdXRlKFwiQ2hvb3NlQWNjb3VudFwiKTtcbiAgICB9XG4gIH07XG4gIGlmIChjb25uZWN0aW5nKSB7XG4gICAgcmV0dXJuIGpzeChcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgIGNsYXNzTmFtZTogXCJkZXJpdmF0aW9uLXBhdGgtd3JhcHBlclwiXG4gICAgfSwge1xuICAgICAgY2hpbGRyZW46IGpzeChXYWxsZXRDb25uZWN0aW5nLCB7XG4gICAgICAgIHdhbGxldDogaGFyZHdhcmVXYWxsZXQsXG4gICAgICAgIG9uQmFjazogKCkgPT4ge1xuICAgICAgICAgIHNldENvbm5lY3RpbmcoZmFsc2UpO1xuICAgICAgICB9LFxuICAgICAgICBvbkNsb3NlTW9kYWw6IG9uQ2xvc2VNb2RhbFxuICAgICAgfSlcbiAgICB9KSk7XG4gIH1cbiAgcmV0dXJuIGpzeHMoRnJhZ21lbnQsIHtcbiAgICBjaGlsZHJlbjogW2pzeHMoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICBjbGFzc05hbWU6IFwibndzLW1vZGFsLWhlYWRlci13cmFwcGVyXCJcbiAgICB9LCB7XG4gICAgICBjaGlsZHJlbjogWyhyb3V0ZSA9PT0gXCJTcGVjaWZ5SERQYXRoXCIgfHwgcm91dGUgPT09IFwiTm9BY2NvdW50c0ZvdW5kXCIgfHwgcm91dGUgPT09IFwiQ2hvb3NlQWNjb3VudFwiIHx8IHJvdXRlID09PSBcIk92ZXJ2aWV3QWNjb3VudHNcIikgJiYganN4KEJhY2tBcnJvdywge1xuICAgICAgICBvbkNsaWNrOiBoYW5kbGVPbkJhY2tCdXR0b25DbGlja1xuICAgICAgfSksIGpzeChNb2RhbEhlYWRlciwge1xuICAgICAgICB0aXRsZTogaGVhZGVyVGl0bGUsXG4gICAgICAgIG9uQ2xvc2VNb2RhbDogb25DbG9zZU1vZGFsXG4gICAgICB9KV1cbiAgICB9KSksIGpzeHMoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICBjbGFzc05hbWU6IFwiZGVyaXZhdGlvbi1wYXRoLXdyYXBwZXJcIlxuICAgIH0sIHtcbiAgICAgIGNoaWxkcmVuOiBbcm91dGUgPT09IFwiRW50ZXJEZXJpdmF0aW9uUGF0aFwiICYmIGpzeHMoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGNsYXNzTmFtZTogXCJlbnRlci1kZXJpdmF0aW9uLXBhdGhcIlxuICAgICAgfSwge1xuICAgICAgICBjaGlsZHJlbjogW2pzeChcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICBjbGFzc05hbWU6IFwibGVkZ2VyLWltYWdlXCJcbiAgICAgICAgfSwge1xuICAgICAgICAgIGNoaWxkcmVuOiBqc3goTGVkZ2VyRGV2aWNlSWNvbiwge30pXG4gICAgICAgIH0pKSwganN4cyhcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICBjbGFzc05hbWU6IFwibGVkZ2VyLWRlc2NyaXB0aW9uXCJcbiAgICAgICAgfSwge1xuICAgICAgICAgIGNoaWxkcmVuOiBbanN4KFwicFwiLCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogdHJhbnNsYXRlKFwibW9kYWwubGVkZ2VyLm1ha2VTdXJlWW91ckxlZGdlclwiKVxuICAgICAgICAgIH0pLCBqc3goXCJwXCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBcInNwZWNpZnktcGF0aFwiLFxuICAgICAgICAgICAgb25DbGljazogKCkgPT4ge1xuICAgICAgICAgICAgICBzZXRIZWFkZXJUaXRsZSh0cmFuc2xhdGUoXCJtb2RhbC5sZWRnZXIuc3BlY2lmeUhEUGF0aFwiKSk7XG4gICAgICAgICAgICAgIHNldFJvdXRlKFwiU3BlY2lmeUhEUGF0aFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogdHJhbnNsYXRlKFwibW9kYWwubGVkZ2VyLnNwZWNpZnlIRFBhdGhcIilcbiAgICAgICAgICB9KSldXG4gICAgICAgIH0pKSwganN4KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgIGNsYXNzTmFtZTogXCJhY3Rpb24tYnV0dG9uc1wiXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBjaGlsZHJlbjoganN4KFwiYnV0dG9uXCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBcIm1pZGRsZUJ1dHRvblwiLFxuICAgICAgICAgICAgb25DbGljazogaGFuZGxlVmFsaWRhdGVBY2NvdW50XG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgY2hpbGRyZW46IHRyYW5zbGF0ZShcIm1vZGFsLmxlZGdlci5jb250aW51ZVwiKVxuICAgICAgICAgIH0pKVxuICAgICAgICB9KSldXG4gICAgICB9KSksIHJvdXRlID09PSBcIlNwZWNpZnlIRFBhdGhcIiAmJiBqc3hzKFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBjbGFzc05hbWU6IFwic3BlY2lmeS1wYXRoLXdyYXBwZXJcIlxuICAgICAgfSwge1xuICAgICAgICBjaGlsZHJlbjogW2pzeHMoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcImNoYW5nZS1wYXRoLXdyYXBwZXJcIlxuICAgICAgICB9LCB7XG4gICAgICAgICAgY2hpbGRyZW46IFtqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwiZGlzcGxheS1wYXRoXCJcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBjaGlsZHJlbjoganN4KFwic3BhblwiLCB7XG4gICAgICAgICAgICAgIGNoaWxkcmVuOiBkZXJpdmF0aW9uUGF0aC5zbGljZSgwLCAtMilcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSkpLCBqc3hzKFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBcImNoYW5nZS1wYXRoXCJcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogW2pzeChcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcInBhdGgtdmFsdWVcIlxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBjaGlsZHJlbjoganN4KFwic3BhblwiLCB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IGN1c3RvbURlcml2YXRpb25QYXRoXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KSksIGpzeHMoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJidXR0b25zLXdyYXBwZXJcIlxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBjaGlsZHJlbjogW2pzeChcImJ1dHRvblwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgICAgICBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IGN1c3RvbURlcml2YXRpb25QYXRoICsgMTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHBhdGggPSBkZXJpdmF0aW9uUGF0aC5zbGljZSgwLCAtMik7XG4gICAgICAgICAgICAgICAgICBzZXREZXJpdmF0aW9uUGF0aChgJHtwYXRofSR7bmV3VmFsdWV9J2ApO1xuICAgICAgICAgICAgICAgICAgc2V0Q3VzdG9tRGVyaXZhdGlvblBhdGgobmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBqc3goVXBBcnJvd0ljb24sIHt9KVxuICAgICAgICAgICAgICB9KSksIGpzeChcImJ1dHRvblwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgICAgICBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IGN1c3RvbURlcml2YXRpb25QYXRoIC0gMTtcbiAgICAgICAgICAgICAgICAgIGlmIChuZXdWYWx1ZSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgY29uc3QgcGF0aCA9IGRlcml2YXRpb25QYXRoLnNsaWNlKDAsIC0yKTtcbiAgICAgICAgICAgICAgICAgIHNldERlcml2YXRpb25QYXRoKGAke3BhdGh9JHtuZXdWYWx1ZX0nYCk7XG4gICAgICAgICAgICAgICAgICBzZXRDdXN0b21EZXJpdmF0aW9uUGF0aChuZXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IGpzeChEb3duQXJyb3dJY29uLCB7fSlcbiAgICAgICAgICAgICAgfSkpXVxuICAgICAgICAgICAgfSkpXVxuICAgICAgICAgIH0pKV1cbiAgICAgICAgfSkpLCBqc3goXCJwXCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgIGNsYXNzTmFtZTogXCJwYXRoLWRlc2NyaXB0aW9uXCJcbiAgICAgICAgfSwge1xuICAgICAgICAgIGNoaWxkcmVuOiB0cmFuc2xhdGUoXCJtb2RhbC5sZWRnZXIuZW50ZXJZb3VyUHJlZmVycmVkSERQYXRoXCIpXG4gICAgICAgIH0pKSwganN4KFwicFwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICBjbGFzc05hbWU6IFwid2hhdC1saW5rXCJcbiAgICAgICAgfSwge1xuICAgICAgICAgIGNoaWxkcmVuOiBqc3goXCJhXCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgaHJlZjogXCJodHRwczovL3d3dy5sZWRnZXIuY29tL2FjYWRlbXkvY3J5cHRvL3doYXQtYXJlLWhpZXJhcmNoaWNhbC1kZXRlcm1pbmlzdGljLWhkLXdhbGxldHNcIixcbiAgICAgICAgICAgIHRhcmdldDogXCJfYmxhbmtcIlxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBcIldoYXQncyB0aGlzP1wiXG4gICAgICAgICAgfSkpXG4gICAgICAgIH0pKSwganN4KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgIGNsYXNzTmFtZTogXCJhY3Rpb24tYnV0dG9uc1wiXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBjaGlsZHJlbjoganN4KFwiYnV0dG9uXCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBcIm1pZGRsZUJ1dHRvblwiLFxuICAgICAgICAgICAgb25DbGljazogaGFuZGxlVmFsaWRhdGVBY2NvdW50XG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgY2hpbGRyZW46IHRyYW5zbGF0ZShcIm1vZGFsLmxlZGdlci5zY2FuXCIpXG4gICAgICAgICAgfSkpXG4gICAgICAgIH0pKV1cbiAgICAgIH0pKSwgcm91dGUgPT09IFwiTm9BY2NvdW50c0ZvdW5kXCIgJiYganN4KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBjbGFzc05hbWU6IFwibm8tYWNjb3VudHMtZm91bmQtd3JhcHBlclwiXG4gICAgICB9LCB7XG4gICAgICAgIGNoaWxkcmVuOiBqc3hzKFwicFwiLCB7XG4gICAgICAgICAgY2hpbGRyZW46IFt0cmFuc2xhdGUoXCJtb2RhbC5sZWRnZXIuY2FudEZpbmRBbnlBY2NvdW50XCIpLCBcIiBcIiwganN4KFwiYVwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGhyZWY6IGBodHRwczovLyR7c2VsZWN0b3Iub3B0aW9ucy5uZXR3b3JrLm5ldHdvcmtJZCA9PT0gXCJ0ZXN0bmV0XCIgPyBcInRlc3RuZXRcIiA6IFwiYXBwXCJ9Lm15bmVhcndhbGxldC5jb20vY3JlYXRlYCxcbiAgICAgICAgICAgIHRhcmdldDogXCJfYmxhbmtcIlxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBcIk15TmVhcldhbGxldFwiXG4gICAgICAgICAgfSkpLCBcIiBcIiwgdHJhbnNsYXRlKFwibW9kYWwubGVkZ2VyLm9yQ29ubmVjdEFuQW5vdGhlckxlZGdlclwiKV1cbiAgICAgICAgfSlcbiAgICAgIH0pKSwgcm91dGUgPT09IFwiQ2hvb3NlQWNjb3VudFwiICYmIGpzeChIYXJkd2FyZVdhbGxldEFjY291bnRzRm9ybSwge1xuICAgICAgICBhY2NvdW50czogYWNjb3VudHMsXG4gICAgICAgIG9uU2VsZWN0ZWRDaGFuZ2VkOiAoaW5kZXgsIHNlbGVjdGVkKSA9PiB7XG4gICAgICAgICAgc2V0QWNjb3VudHMocHJldkFjY291bnRzID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZUFjY291bnRzID0gcHJldkFjY291bnRzLm1hcCgoYWNjb3VudCwgaWR4KSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkVmFsdWUgPSBpbmRleCA9PT0gaWR4ID8gc2VsZWN0ZWQgOiBhY2NvdW50LnNlbGVjdGVkO1xuICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhY2NvdW50KSwge1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkOiBzZWxlY3RlZFZhbHVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gWy4uLnVwZGF0ZUFjY291bnRzXTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25TdWJtaXQ6IChhY2MsIGUpID0+IHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgY29uc3Qgc2VsZWN0ZWRBY2MgPSBhY2MuZmlsdGVyKGFjY291bnQgPT4gYWNjb3VudC5zZWxlY3RlZCk7XG4gICAgICAgICAgc2V0U2VsZWN0ZWRBY2NvdW50cyhzZWxlY3RlZEFjYyk7XG4gICAgICAgICAgY29uc3QgbnVtYmVyT2ZBY2NvdW50cyA9IHNlbGVjdGVkQWNjLmxlbmd0aDtcbiAgICAgICAgICBzZXRIZWFkZXJUaXRsZShgJHt0cmFuc2xhdGUoXCJtb2RhbC5sZWRnZXIuY29ubmVjdGluZ1wiKX0gJHtudW1iZXJPZkFjY291bnRzfSAke3RyYW5zbGF0ZShcIm1vZGFsLmxlZGdlci5vZkFjY291bnRzXCIpfWApO1xuICAgICAgICAgIHNldFJvdXRlKFwiT3ZlcnZpZXdBY2NvdW50c1wiKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25DaGFuZ2VSb3V0ZTogbmV3Um91dGUgPT4ge1xuICAgICAgICAgIGlmIChuZXdSb3V0ZSA9PT0gXCJTcGVjaWZ5SERQYXRoXCIpIHtcbiAgICAgICAgICAgIHNldEhlYWRlclRpdGxlKHRyYW5zbGF0ZShcIm1vZGFsLmxlZGdlci5zcGVjaWZ5SERQYXRoXCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2V0Um91dGUobmV3Um91dGUpO1xuICAgICAgICB9XG4gICAgICB9KSwgcm91dGUgPT09IFwiQWRkQ3VzdG9tQWNjb3VudElkXCIgJiYganN4cyhcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImVudGVyLWN1c3RvbS1hY2NvdW50XCJcbiAgICAgIH0sIHtcbiAgICAgICAgY2hpbGRyZW46IFtqc3goXCJwXCIsIHtcbiAgICAgICAgICBjaGlsZHJlbjogdHJhbnNsYXRlKFwibW9kYWwubGVkZ2VyLmZhaWxlZFRvQXV0b21hdGljYWxseVwiKVxuICAgICAgICB9KSwganN4KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgIGNsYXNzTmFtZTogXCJpbnB1dC13cmFwcGVyXCJcbiAgICAgICAgfSwge1xuICAgICAgICAgIGNoaWxkcmVuOiBqc3goXCJpbnB1dFwiLCB7XG4gICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBcIkFjY291bnQgSURcIixcbiAgICAgICAgICAgIHZhbHVlOiBjdXN0b21BY2NvdW50SWQsXG4gICAgICAgICAgICBvbkNoYW5nZTogZSA9PiB7XG4gICAgICAgICAgICAgIHNldEN1c3RvbUFjY291bnRJZChlLnRhcmdldC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfSkpLCBqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcImFjdGlvbi1idXR0b25zXCJcbiAgICAgICAgfSwge1xuICAgICAgICAgIGNoaWxkcmVuOiBqc3goXCJidXR0b25cIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwibWlkZGxlQnV0dG9uXCIsXG4gICAgICAgICAgICBvbkNsaWNrOiBoYW5kbGVBZGRDdXN0b21BY2NvdW50SWRcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogdHJhbnNsYXRlKFwibGVkZ2VyLkNvbnRpbnVlXCIpXG4gICAgICAgICAgfSkpXG4gICAgICAgIH0pKV1cbiAgICAgIH0pKSwgcm91dGUgPT09IFwiT3ZlcnZpZXdBY2NvdW50c1wiICYmIGpzeHMoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGNsYXNzTmFtZTogXCJvdmVydmlldy13cmFwcGVyXCJcbiAgICAgIH0sIHtcbiAgICAgICAgY2hpbGRyZW46IFtqc3goXCJwXCIsIHtcbiAgICAgICAgICBjaGlsZHJlbjogdHJhbnNsYXRlKFwibW9kYWwubGVkZ2VyLm92ZXJ2aWV3VGhlTGlzdE9mQXV0aG9yaXplZFwiKVxuICAgICAgICB9KSwganN4KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgIGNsYXNzTmFtZTogXCJhY2NvdW50c1wiXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBjaGlsZHJlbjogc2VsZWN0ZWRBY2NvdW50cy5tYXAoKGFjY291bnQsIGluZGV4KSA9PiBqc3goXCJkaXZcIiwge1xuICAgICAgICAgICAgY2hpbGRyZW46IGpzeChcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcImFjY291bnRcIlxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBjaGlsZHJlbjoganN4KFwic3BhblwiLCB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IGFjY291bnQuYWNjb3VudElkXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICB9LCBhY2NvdW50LmFjY291bnRJZCkpXG4gICAgICAgIH0pKSwganN4KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgIGNsYXNzTmFtZTogXCJhY3Rpb24tYnV0dG9uc1wiXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBjaGlsZHJlbjoganN4KFwiYnV0dG9uXCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBcIm1pZGRsZUJ1dHRvblwiLFxuICAgICAgICAgICAgb25DbGljazogaGFuZGxlU2lnbkluLFxuICAgICAgICAgICAgZGlzYWJsZWQ6IGFjY291bnRzLmxlbmd0aCA9PT0gMFxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiB0cmFuc2xhdGUoXCJtb2RhbC5sZWRnZXIuZmluaXNoXCIpXG4gICAgICAgICAgfSkpXG4gICAgICAgIH0pKV1cbiAgICAgIH0pKV1cbiAgICB9KSldXG4gIH0pO1xufTtcblxuY29uc3QgV2FsbGV0Tm90SW5zdGFsbGVkID0gKHtcbiAgbW9kdWxlLFxuICBvbkJhY2ssXG4gIG9uQ2xvc2VNb2RhbFxufSkgPT4ge1xuICByZXR1cm4ganN4cyhGcmFnbWVudCwge1xuICAgIGNoaWxkcmVuOiBbanN4cyhcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgIGNsYXNzTmFtZTogXCJud3MtbW9kYWwtaGVhZGVyLXdyYXBwZXJcIlxuICAgIH0sIHtcbiAgICAgIGNoaWxkcmVuOiBbanN4KEJhY2tBcnJvdywge1xuICAgICAgICBvbkNsaWNrOiBvbkJhY2tcbiAgICAgIH0pLCBqc3goTW9kYWxIZWFkZXIsIHtcbiAgICAgICAgdGl0bGU6IFwiXCIsXG4gICAgICAgIG9uQ2xvc2VNb2RhbDogb25DbG9zZU1vZGFsXG4gICAgICB9KV1cbiAgICB9KSksIGpzeHMoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICBjbGFzc05hbWU6IFwid2FsbGV0LW5vdC1pbnN0YWxsZWQtd3JhcHBlclwiXG4gICAgfSwge1xuICAgICAgY2hpbGRyZW46IFtqc3hzKFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBjbGFzc05hbWU6IFwid2FsbGV0LWRhdGFcIlxuICAgICAgfSwge1xuICAgICAgICBjaGlsZHJlbjogW2pzeChcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICBjbGFzc05hbWU6IGB3YWxsZXQtaWNvbi1ib3ggJHttb2R1bGUuaWR9YFxuICAgICAgICB9LCB7XG4gICAgICAgICAgY2hpbGRyZW46IGpzeChcImltZ1wiLCB7XG4gICAgICAgICAgICBzcmM6IG1vZHVsZS5tZXRhZGF0YS5pY29uVXJsLFxuICAgICAgICAgICAgYWx0OiBtb2R1bGUubWV0YWRhdGEubmFtZVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pKSwganN4KFwicFwiLCB7XG4gICAgICAgICAgY2hpbGRyZW46IG1vZHVsZS5tZXRhZGF0YS5uYW1lXG4gICAgICAgIH0pXVxuICAgICAgfSkpLCBqc3hzKFwicFwiLCB7XG4gICAgICAgIGNoaWxkcmVuOiBbdHJhbnNsYXRlKFwibW9kYWwuaW5zdGFsbC55b3VsbE5lZWRUb0luc3RhbGxcIiksIFwiIFwiLCBtb2R1bGUubWV0YWRhdGEubmFtZSwgXCIgXCIsIHRyYW5zbGF0ZShcIm1vZGFsLmluc3RhbGwudG9Db250aW51ZUFmdGVySW5zdGFsbGluZ1wiKSwganN4cyhcInNwYW5cIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcInJlZnJlc2gtbGlua1wiLFxuICAgICAgICAgIG9uQ2xpY2s6ICgpID0+IHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKVxuICAgICAgICB9LCB7XG4gICAgICAgICAgY2hpbGRyZW46IFtcIiBcIiwgdHJhbnNsYXRlKFwibW9kYWwuaW5zdGFsbC5yZWZyZXNoVGhlUGFnZVwiKV1cbiAgICAgICAgfSkpXVxuICAgICAgfSksIGpzeChcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImFjdGlvbi1idXR0b25zXCJcbiAgICAgIH0sIHtcbiAgICAgICAgY2hpbGRyZW46IGpzeHMoXCJidXR0b25cIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcIm1pZGRsZUJ1dHRvblwiLFxuICAgICAgICAgIG9uQ2xpY2s6ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChtb2R1bGUudHlwZSAhPT0gXCJpbmplY3RlZFwiKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdpbmRvdy5vcGVuKG1vZHVsZS5tZXRhZGF0YS5kb3dubG9hZFVybCwgXCJfYmxhbmtcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAgY2hpbGRyZW46IFt0cmFuc2xhdGUoXCJtb2RhbC5pbnN0YWxsLm9wZW5cIiksIFwiIFwiLCBtb2R1bGUubWV0YWRhdGEubmFtZV1cbiAgICAgICAgfSkpXG4gICAgICB9KSldXG4gICAgfSkpXVxuICB9KTtcbn07XG5cbmNvbnN0IFFSSWNvbiA9ICgpID0+IGpzeHMoXCJzdmdcIiwgT2JqZWN0LmFzc2lnbih7XG4gIHdpZHRoOiBcIjE4XCIsXG4gIGhlaWdodDogXCIxNlwiLFxuICB2aWV3Qm94OiBcIjAgMCAxOCAxNlwiLFxuICBmaWxsOiBcIm5vbmVcIixcbiAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxufSwge1xuICBjaGlsZHJlbjogW2pzeChcInBhdGhcIiwge1xuICAgIGQ6IFwiTTcuMjIyMjQgMS4zMzMzNEgxLjQ0NDQ2VjYuNjY2NjhINy4yMjIyNFYxLjMzMzM0WlwiLFxuICAgIHN0cm9rZTogXCJjdXJyZW50Q29sb3JcIixcbiAgICBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsXG4gICAgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIlxuICB9KSwganN4KFwicGF0aFwiLCB7XG4gICAgZDogXCJNMTUuODg4OSAxLjMzMzM0SDEwLjExMTFWNi42NjY2OEgxNS44ODg5VjEuMzMzMzRaXCIsXG4gICAgc3Ryb2tlOiBcImN1cnJlbnRDb2xvclwiLFxuICAgIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIixcbiAgICBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiXG4gIH0pLCBqc3goXCJwYXRoXCIsIHtcbiAgICBkOiBcIk03LjIyMjI0IDkuMzMzMzRIMS40NDQ0NlYxNC42NjY3SDcuMjIyMjRWOS4zMzMzNFpcIixcbiAgICBzdHJva2U6IFwiY3VycmVudENvbG9yXCIsXG4gICAgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLFxuICAgIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCJcbiAgfSksIGpzeChcInBhdGhcIiwge1xuICAgIGQ6IFwiTTEwLjExMTEgMTMuMTQyOVYxNC42NjY3SDE1Ljg4ODlNMTAuMTExMSA5LjMzMzM0VjEwLjg1NzJIMTIuNTg3M1Y5LjMzMzM0SDE1Ljg4ODlWMTIuMzgxXCIsXG4gICAgc3Ryb2tlOiBcIiM0QzUxNTVcIixcbiAgICBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsXG4gICAgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIlxuICB9KSwganN4KFwicmVjdFwiLCB7XG4gICAgeDogXCIzLjYxMTA4XCIsXG4gICAgeTogXCIzLjMzMzM0XCIsXG4gICAgd2lkdGg6IFwiMS40NDQ0NFwiLFxuICAgIGhlaWdodDogXCIxLjMzMzMzXCIsXG4gICAgZmlsbDogXCIjNEM1MTU1XCJcbiAgfSksIGpzeChcInJlY3RcIiwge1xuICAgIHg6IFwiMy42MTEwOFwiLFxuICAgIHk6IFwiMTEuMzMzM1wiLFxuICAgIHdpZHRoOiBcIjEuNDQ0NDRcIixcbiAgICBoZWlnaHQ6IFwiMS4zMzMzM1wiLFxuICAgIGZpbGw6IFwiIzRDNTE1NVwiXG4gIH0pLCBqc3goXCJyZWN0XCIsIHtcbiAgICB4OiBcIjEyLjI3NzhcIixcbiAgICB5OiBcIjMuMzMzMzRcIixcbiAgICB3aWR0aDogXCIxLjQ0NDQ1XCIsXG4gICAgaGVpZ2h0OiBcIjEuMzMzMzNcIixcbiAgICBmaWxsOiBcIiM0QzUxNTVcIlxuICB9KV1cbn0pKTtcblxuY29uc3QgTGlua0ljb24gPSAoKSA9PiBqc3hzKFwic3ZnXCIsIE9iamVjdC5hc3NpZ24oe1xuICB3aWR0aDogXCIxOFwiLFxuICBoZWlnaHQ6IFwiMTZcIixcbiAgdmlld0JveDogXCIwIDAgMTggMTZcIixcbiAgZmlsbDogXCJub25lXCIsXG4gIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbn0sIHtcbiAgY2hpbGRyZW46IFtqc3goXCJwYXRoXCIsIHtcbiAgICBkOiBcIk0xMyA4LjY2NjY3VjEyLjY2NjdDMTMgMTMuMDIwMyAxMi44NDc4IDEzLjM1OTQgMTIuNTc3IDEzLjYwOTVDMTIuMzA2MSAxMy44NTk1IDExLjkzODcgMTQgMTEuNTU1NiAxNEgzLjYxMTEzQzMuMjI4MDQgMTQgMi44NjA2NCAxMy44NTk1IDIuNTg5NzUgMTMuNjA5NUMyLjMxODg3IDEzLjM1OTQgMi4xNjY2OSAxMy4wMjAzIDIuMTY2NjkgMTIuNjY2N1Y1LjMzMzMzQzIuMTY2NjkgNC45Nzk3MSAyLjMxODg3IDQuNjQwNTcgMi41ODk3NSA0LjM5MDUyQzIuODYwNjQgNC4xNDA0OCAzLjIyODA0IDQgMy42MTExMyA0SDcuOTQ0NDdcIixcbiAgICBzdHJva2U6IFwiY3VycmVudENvbG9yXCIsXG4gICAgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLFxuICAgIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCJcbiAgfSksIGpzeChcInBhdGhcIiwge1xuICAgIGQ6IFwiTTEwLjgzMzMgMkgxNS4xNjY2VjZcIixcbiAgICBzdHJva2U6IFwiY3VycmVudENvbG9yXCIsXG4gICAgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLFxuICAgIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCJcbiAgfSksIGpzeChcInBhdGhcIiwge1xuICAgIGQ6IFwiTTcuMjIyMjMgOS4zMzMzM0wxNS4xNjY3IDJcIixcbiAgICBzdHJva2U6IFwiY3VycmVudENvbG9yXCIsXG4gICAgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLFxuICAgIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCJcbiAgfSldXG59KSk7XG5cbmNvbnN0IEtleUljb24gPSAoKSA9PiBqc3goXCJzdmdcIiwgT2JqZWN0LmFzc2lnbih7XG4gIHdpZHRoOiBcIjQwXCIsXG4gIGhlaWdodDogXCI0MFwiLFxuICB2aWV3Qm94OiBcIjAgMCA0MCA0MFwiLFxuICBmaWxsOiBcIm5vbmVcIixcbiAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxufSwge1xuICBjaGlsZHJlbjoganN4KFwicGF0aFwiLCB7XG4gICAgZDogXCJNMzMuNSAxLjgzMzI1TDMwLjE2NjYgNS4xNjY1OE0xNy40ODE4IDE3Ljg1MTRDMTkuMTQwNiAxOS41MTAzIDIwLjE2NjYgMjEuODAxOSAyMC4xNjY2IDI0LjMzMzNDMjAuMTY2NiAyOS4zOTU5IDE2LjA2MjYgMzMuNDk5OSAxMSAzMy40OTk5QzUuOTM3MzUgMzMuNDk5OSAxLjgzMzMgMjkuMzk1OSAxLjgzMzMgMjQuMzMzM0MxLjgzMzMgMTkuMjcwNiA1LjkzNzM1IDE1LjE2NjYgMTEgMTUuMTY2NkMxMy41MzEzIDE1LjE2NjYgMTUuODIyOSAxNi4xOTI2IDE3LjQ4MTggMTcuODUxNFpNMTcuNDgxOCAxNy44NTE0TDI0LjMzMzMgMTAuOTk5OU0yNC4zMzMzIDEwLjk5OTlMMjkuMzMzMyAxNS45OTk5TDM1LjE2NjYgMTAuMTY2NkwzMC4xNjY2IDUuMTY2NThNMjQuMzMzMyAxMC45OTk5TDMwLjE2NjYgNS4xNjY1OFwiLFxuICAgIHN0cm9rZTogXCJjdXJyZW50Q29sb3JcIixcbiAgICBzdHJva2VXaWR0aDogXCIzXCIsXG4gICAgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLFxuICAgIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCJcbiAgfSlcbn0pKTtcblxuY29uc3QgRm9sZGVySWNvbiA9ICgpID0+IGpzeHMoXCJzdmdcIiwgT2JqZWN0LmFzc2lnbih7XG4gIHdpZHRoOiBcIjQwXCIsXG4gIGhlaWdodDogXCI0MVwiLFxuICB2aWV3Qm94OiBcIjAgMCA0MCA0MVwiLFxuICBmaWxsOiBcIm5vbmVcIixcbiAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxufSwge1xuICBjaGlsZHJlbjogW2pzeChcImNpcmNsZVwiLCB7XG4gICAgY3g6IFwiMjguMzMzM1wiLFxuICAgIGN5OiBcIjIzLjgzMzNcIixcbiAgICByOiBcIjEuNjY2NjdcIixcbiAgICBmaWxsOiBcImN1cnJlbnRDb2xvclwiXG4gIH0pLCBqc3goXCJwYXRoXCIsIHtcbiAgICBkOiBcIk0zNSAxMi4xNjY3SDdDNS44OTU0MyAxMi4xNjY3IDUgMTEuMjcxMiA1IDEwLjE2NjdWNy41QzUgNi4zOTU0MyA1Ljg5NTQzIDUuNSA3IDUuNUgzMS42NjY3XCIsXG4gICAgc3Ryb2tlOiBcImN1cnJlbnRDb2xvclwiLFxuICAgIHN0cm9rZVdpZHRoOiBcIjNcIixcbiAgICBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsXG4gICAgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIlxuICB9KSwganN4KFwicGF0aFwiLCB7XG4gICAgZDogXCJNMzUgMTIuMTY2N1YzNS41SDdDNS44OTU0MyAzNS41IDUgMzQuNjA0NiA1IDMzLjVWOC44MzMzNFwiLFxuICAgIHN0cm9rZTogXCJjdXJyZW50Q29sb3JcIixcbiAgICBzdHJva2VXaWR0aDogXCIzXCIsXG4gICAgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLFxuICAgIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCJcbiAgfSldXG59KSk7XG5cbmNvbnN0IFdhbGxldEhvbWUgPSAoe1xuICBzZWxlY3RvcixcbiAgb25DbG9zZU1vZGFsXG59KSA9PiB7XG4gIGNvbnN0IFttb2R1bGVzLCBzZXRNb2R1bGVzXSA9IHVzZVN0YXRlKFtdKTtcbiAgY29uc3QgW3JvdXRlLCBzZXRSb3V0ZV0gPSB1c2VTdGF0ZShcIldhbGxldEluZm9cIik7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gc2VsZWN0b3Iuc3RvcmUub2JzZXJ2YWJsZS5zdWJzY3JpYmUoc3RhdGUgPT4ge1xuICAgICAgY29uc3QgZmlsdGVyQnlUeXBlID0gaXRlbSA9PiB7XG4gICAgICAgIHJldHVybiBpdGVtLnR5cGUgIT09IFwiYnJpZGdlXCIgJiYgaXRlbS50eXBlICE9PSBcImhhcmR3YXJlXCIgJiYgaXRlbS50eXBlICE9PSBcImluc3RhbnQtbGlua1wiO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGZpbHRlcmVkTW9kdWxlcyA9IHN0YXRlLm1vZHVsZXMuZmlsdGVyKGZpbHRlckJ5VHlwZSk7XG4gICAgICBzZXRNb2R1bGVzKGZpbHRlcmVkTW9kdWxlcyk7XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgW10pO1xuICBjb25zdCBnZXRXYWxsZXRVcmwgPSBtb2R1bGUgPT4ge1xuICAgIGxldCB1cmwgPSBcIlwiO1xuICAgIGlmIChtb2R1bGUudHlwZSA9PT0gXCJpbmplY3RlZFwiKSB7XG4gICAgICB1cmwgPSBtb2R1bGUubWV0YWRhdGEuZG93bmxvYWRVcmw7XG4gICAgfVxuICAgIGlmIChtb2R1bGUudHlwZSA9PT0gXCJicm93c2VyXCIpIHtcbiAgICAgIHVybCA9IG1vZHVsZS5tZXRhZGF0YS53YWxsZXRVcmw7XG4gICAgfVxuICAgIHJldHVybiB1cmw7XG4gIH07XG4gIHJldHVybiBqc3hzKFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgIGNsYXNzTmFtZTogXCJ3YWxsZXQtaG9tZS13cmFwcGVyXCJcbiAgfSwge1xuICAgIGNoaWxkcmVuOiBbanN4cyhcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgIGNsYXNzTmFtZTogXCJud3MtbW9kYWwtaGVhZGVyLXdyYXBwZXJcIlxuICAgIH0sIHtcbiAgICAgIGNoaWxkcmVuOiBbcm91dGUgPT09IFwiR2V0V2FsbGV0c1wiICYmIGpzeChCYWNrQXJyb3csIHtcbiAgICAgICAgb25DbGljazogKCkgPT4ge1xuICAgICAgICAgIHNldFJvdXRlKFwiV2FsbGV0SW5mb1wiKTtcbiAgICAgICAgfVxuICAgICAgfSksIGpzeChNb2RhbEhlYWRlciwge1xuICAgICAgICB0aXRsZTogcm91dGUgPT09IFwiR2V0V2FsbGV0c1wiID8gdHJhbnNsYXRlKFwibW9kYWwud2FsbGV0LmdldEFXYWxsZXRcIikgOiB0cmFuc2xhdGUoXCJtb2RhbC53YWxsZXQud2hhdElzQVdhbGxldFwiKSxcbiAgICAgICAgb25DbG9zZU1vZGFsOiBvbkNsb3NlTW9kYWxcbiAgICAgIH0pXVxuICAgIH0pKSwgcm91dGUgPT09IFwiR2V0V2FsbGV0c1wiICYmIGpzeChcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgIGNsYXNzTmFtZTogXCJnZXQtd2FsbGV0LXdyYXBwZXJcIlxuICAgIH0sIHtcbiAgICAgIGNoaWxkcmVuOiBtb2R1bGVzLm1hcChtb2R1bGUgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgaWNvblVybCxcbiAgICAgICAgICBuYW1lXG4gICAgICAgIH0gPSBtb2R1bGUubWV0YWRhdGE7XG4gICAgICAgIGNvbnN0IHFySWNvbiA9IFtcIm5lYXJmaVwiLCBcImhlcmUtd2FsbGV0XCJdLmluY2x1ZGVzKG1vZHVsZS5pZCk7XG4gICAgICAgIGNvbnN0IGhlcmVXYWxsZXRUeXBlID0gbW9kdWxlLmlkID09PSBcImhlcmUtd2FsbGV0XCIgPyBcIm1vYmlsZVwiIDogXCJcIjtcbiAgICAgICAgY29uc3Qgd2FsbGV0VXJsID0gZ2V0V2FsbGV0VXJsKG1vZHVsZSk7XG4gICAgICAgIHJldHVybiBqc3hzKFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgIHRhYkluZGV4OiAwLFxuICAgICAgICAgIGNsYXNzTmFtZTogYHNpbmdsZS13YWxsZXQtZ2V0ICR7bW9kdWxlLmlkfWAsXG4gICAgICAgICAgb25DbGljazogKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHdhbGxldFVybCkge1xuICAgICAgICAgICAgICB3aW5kb3cub3Blbih3YWxsZXRVcmwsIFwiX2JsYW5rXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGNoaWxkcmVuOiBbanN4cyhcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJzbWFsbC1pY29uXCJcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogW3FySWNvbiAmJiB3YWxsZXRVcmwgJiYganN4KFFSSWNvbiwge30pLCAhcXJJY29uICYmIHdhbGxldFVybCAmJiBqc3goTGlua0ljb24sIHt9KV1cbiAgICAgICAgICB9KSksIGpzeChcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJpY29uXCJcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBjaGlsZHJlbjoganN4KFwiaW1nXCIsIHtcbiAgICAgICAgICAgICAgc3JjOiBpY29uVXJsLFxuICAgICAgICAgICAgICBhbHQ6IG5hbWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSkpLCBqc3hzKFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBcImNvbnRlbnRcIlxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbanN4KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgICBjbGFzc05hbWU6IFwidGl0bGVcIlxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBjaGlsZHJlbjogbmFtZVxuICAgICAgICAgICAgfSkpLCBqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJ0eXBlXCJcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgY2hpbGRyZW46IHRyYW5zbGF0ZShgbW9kYWwud2FsbGV0VHlwZXMuJHtoZXJlV2FsbGV0VHlwZSB8fCBtb2R1bGUudHlwZX1gKVxuICAgICAgICAgICAgfSkpXVxuICAgICAgICAgIH0pKV1cbiAgICAgICAgfSksIG1vZHVsZS5pZCk7XG4gICAgICB9KVxuICAgIH0pKSwgcm91dGUgPT09IFwiV2FsbGV0SW5mb1wiICYmIGpzeHMoRnJhZ21lbnQkMSwge1xuICAgICAgY2hpbGRyZW46IFtqc3hzKFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBjbGFzc05hbWU6IFwid2FsbGV0LWluZm8td3JhcHBlciB3aGF0LXdhbGxldC1oaWRlXCJcbiAgICAgIH0sIHtcbiAgICAgICAgY2hpbGRyZW46IFtqc3hzKFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgIGNsYXNzTmFtZTogXCJ3YWxsZXQtd2hhdFwiXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBjaGlsZHJlbjogW2pzeChcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJpY29uLXNpZGVcIlxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBqc3goS2V5SWNvbiwge30pXG4gICAgICAgICAgfSkpLCBqc3hzKFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBcImNvbnRlbnQtc2lkZVwiXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgY2hpbGRyZW46IFtqc3goXCJoM1wiLCB7XG4gICAgICAgICAgICAgIGNoaWxkcmVuOiB0cmFuc2xhdGUoXCJtb2RhbC53YWxsZXQuc2VjdXJlQW5kTWFuYWdlXCIpXG4gICAgICAgICAgICB9KSwganN4KFwicFwiLCB7XG4gICAgICAgICAgICAgIGNoaWxkcmVuOiB0cmFuc2xhdGUoXCJtb2RhbC53YWxsZXQuc2FmZWx5U3RvcmVcIilcbiAgICAgICAgICAgIH0pXVxuICAgICAgICAgIH0pKV1cbiAgICAgICAgfSkpLCBqc3hzKFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgIGNsYXNzTmFtZTogXCJ3YWxsZXQtd2hhdFwiXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBjaGlsZHJlbjogW2pzeChcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJpY29uLXNpZGVcIlxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBqc3goRm9sZGVySWNvbiwge30pXG4gICAgICAgICAgfSkpLCBqc3hzKFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBcImNvbnRlbnQtc2lkZVwiXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgY2hpbGRyZW46IFtqc3goXCJoM1wiLCB7XG4gICAgICAgICAgICAgIGNoaWxkcmVuOiB0cmFuc2xhdGUoXCJtb2RhbC53YWxsZXQubG9nSW5Ub0FueVwiKVxuICAgICAgICAgICAgfSksIGpzeChcInBcIiwge1xuICAgICAgICAgICAgICBjaGlsZHJlbjogdHJhbnNsYXRlKFwibW9kYWwud2FsbGV0Lm5vTmVlZFRvQ3JlYXRlXCIpXG4gICAgICAgICAgICB9KV1cbiAgICAgICAgICB9KSldXG4gICAgICAgIH0pKSwganN4KFwiZGl2XCIsIHtcbiAgICAgICAgICBjbGFzc05hbWU6IFwiYnV0dG9uLXNwYWNpbmdcIlxuICAgICAgICB9KSwganN4KFwiYnV0dG9uXCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgIGNsYXNzTmFtZTogXCJtaWRkbGVCdXR0b25cIixcbiAgICAgICAgICBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICAgICAgICBzZXRSb3V0ZShcIkdldFdhbGxldHNcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAgY2hpbGRyZW46IHRyYW5zbGF0ZShcIm1vZGFsLndhbGxldC5nZXRBV2FsbGV0XCIpXG4gICAgICAgIH0pKV1cbiAgICAgIH0pKSwganN4cyhcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgY2xhc3NOYW1lOiBcIndoYXQtd2FsbGV0LW1vYmlsZVwiXG4gICAgICB9LCB7XG4gICAgICAgIGNoaWxkcmVuOiBbanN4KFwicFwiLCB7XG4gICAgICAgICAgY2hpbGRyZW46IHRyYW5zbGF0ZShcIm1vZGFsLndhbGxldC51c2VBV2FsbGV0XCIpXG4gICAgICAgIH0pLCBqc3goXCJidXR0b25cIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcIm1pZGRsZUJ1dHRvblwiLFxuICAgICAgICAgIG9uQ2xpY2s6ICgpID0+IHtcbiAgICAgICAgICAgIHNldFJvdXRlKFwiR2V0V2FsbGV0c1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBjaGlsZHJlbjogdHJhbnNsYXRlKFwibW9kYWwud2FsbGV0LmdldEFXYWxsZXRcIilcbiAgICAgICAgfSkpXVxuICAgICAgfSkpLCBqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGNsYXNzTmFtZTogXCJsYW5nLXNlbGVjdG9yLXdyYXBwZXJcIlxuICAgICAgfSwge1xuICAgICAgICBjaGlsZHJlbjoganN4cyhcInNlbGVjdFwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICBjbGFzc05hbWU6IFwibGFuZy1zZWxlY3RvclwiLFxuICAgICAgICAgIG5hbWU6IFwibGFuZ1wiXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBjaGlsZHJlbjogW2pzeChcIm9wdGlvblwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIHZhbHVlOiBcImVuXCJcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogXCJFbmdsaXNoXCJcbiAgICAgICAgICB9KSksIGpzeChcIm9wdGlvblwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIHZhbHVlOiBcImVzXCJcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogXCJTcGFuaXNoXCJcbiAgICAgICAgICB9KSldXG4gICAgICAgIH0pKVxuICAgICAgfSkpXVxuICAgIH0pXVxuICB9KSk7XG59O1xuXG5jb25zdCBXYWxsZXRDb25uZWN0ZWQgPSAoe1xuICBtb2R1bGUsXG4gIG9uQ2xvc2VNb2RhbFxufSkgPT4ge1xuICByZXR1cm4ganN4cyhGcmFnbWVudCwge1xuICAgIGNoaWxkcmVuOiBbanN4cyhcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgIGNsYXNzTmFtZTogXCJud3MtbW9kYWwtaGVhZGVyXCJcbiAgICB9LCB7XG4gICAgICBjaGlsZHJlbjogW2pzeChcImgzXCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBjbGFzc05hbWU6IFwibWlkZGxlVGl0bGVcIlxuICAgICAgfSwge1xuICAgICAgICBjaGlsZHJlbjogYGBcbiAgICAgIH0pKSwganN4KENsb3NlQnV0dG9uLCB7XG4gICAgICAgIG9uQ2xpY2s6IG9uQ2xvc2VNb2RhbFxuICAgICAgfSldXG4gICAgfSkpLCBqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICBjbGFzc05hbWU6IFwiY29ubmVjdGluZy13cmFwcGVyXCJcbiAgICB9LCB7XG4gICAgICBjaGlsZHJlbjoganN4cyhcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImNvbnRlbnRcIlxuICAgICAgfSwge1xuICAgICAgICBjaGlsZHJlbjogW2pzeHMoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcImljb25cIlxuICAgICAgICB9LCB7XG4gICAgICAgICAgY2hpbGRyZW46IFtqc3goXCJkaXZcIiwge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBcImdyZWVuLWRvdFwiXG4gICAgICAgICAgfSksIGpzeChcImltZ1wiLCB7XG4gICAgICAgICAgICBzcmM6IG1vZHVsZSA9PT0gbnVsbCB8fCBtb2R1bGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1vZHVsZS5tZXRhZGF0YS5pY29uVXJsLFxuICAgICAgICAgICAgYWx0OiBtb2R1bGUgPT09IG51bGwgfHwgbW9kdWxlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtb2R1bGUubWV0YWRhdGEubmFtZVxuICAgICAgICAgIH0pXVxuICAgICAgICB9KSksIGpzeChcImgzXCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgIGNsYXNzTmFtZTogXCJjb25uZWN0aW5nLW5hbWVcIlxuICAgICAgICB9LCB7XG4gICAgICAgICAgY2hpbGRyZW46IG1vZHVsZSA9PT0gbnVsbCB8fCBtb2R1bGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1vZHVsZS5tZXRhZGF0YS5uYW1lXG4gICAgICAgIH0pKSwganN4cyhcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICBjbGFzc05hbWU6IFwid2FsbGV0LWNvbm5lY3RlZC1zdWNjZXNzXCJcbiAgICAgICAgfSwge1xuICAgICAgICAgIGNoaWxkcmVuOiBbanN4KENvbm5lY3Rpb25TdWNjZXNzSWNvbiwge30pLCBqc3goXCJzcGFuXCIsIHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiB0cmFuc2xhdGUoXCJtb2RhbC53YWxsZXQuY29ubmVjdGlvblN1Y2Nlc3NmdWxcIilcbiAgICAgICAgICB9KV1cbiAgICAgICAgfSkpXVxuICAgICAgfSkpXG4gICAgfSkpXVxuICB9KTtcbn07XG5cbnZhciBhbk9iamVjdCQxID0gYW5PYmplY3QkYztcblxuLy8gYFJlZ0V4cC5wcm90b3R5cGUuZmxhZ3NgIGdldHRlciBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1nZXQtcmVnZXhwLnByb3RvdHlwZS5mbGFnc1xudmFyIHJlZ2V4cEZsYWdzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdGhhdCA9IGFuT2JqZWN0JDEodGhpcyk7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgaWYgKHRoYXQuaGFzSW5kaWNlcykgcmVzdWx0ICs9ICdkJztcbiAgaWYgKHRoYXQuZ2xvYmFsKSByZXN1bHQgKz0gJ2cnO1xuICBpZiAodGhhdC5pZ25vcmVDYXNlKSByZXN1bHQgKz0gJ2knO1xuICBpZiAodGhhdC5tdWx0aWxpbmUpIHJlc3VsdCArPSAnbSc7XG4gIGlmICh0aGF0LmRvdEFsbCkgcmVzdWx0ICs9ICdzJztcbiAgaWYgKHRoYXQudW5pY29kZSkgcmVzdWx0ICs9ICd1JztcbiAgaWYgKHRoYXQudW5pY29kZVNldHMpIHJlc3VsdCArPSAndic7XG4gIGlmICh0aGF0LnN0aWNreSkgcmVzdWx0ICs9ICd5JztcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciBjYWxsID0gZnVuY3Rpb25DYWxsO1xudmFyIGhhc093biA9IGhhc093blByb3BlcnR5XzE7XG52YXIgaXNQcm90b3R5cGVPZiA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG52YXIgcmVnRXhwRmxhZ3MgPSByZWdleHBGbGFncztcblxudmFyIFJlZ0V4cFByb3RvdHlwZSQxID0gUmVnRXhwLnByb3RvdHlwZTtcblxudmFyIHJlZ2V4cEdldEZsYWdzID0gZnVuY3Rpb24gKFIpIHtcbiAgdmFyIGZsYWdzID0gUi5mbGFncztcbiAgcmV0dXJuIGZsYWdzID09PSB1bmRlZmluZWQgJiYgISgnZmxhZ3MnIGluIFJlZ0V4cFByb3RvdHlwZSQxKSAmJiAhaGFzT3duKFIsICdmbGFncycpICYmIGlzUHJvdG90eXBlT2YoUmVnRXhwUHJvdG90eXBlJDEsIFIpXG4gICAgPyBjYWxsKHJlZ0V4cEZsYWdzLCBSKSA6IGZsYWdzO1xufTtcblxudmFyIFBST1BFUl9GVU5DVElPTl9OQU1FID0gZnVuY3Rpb25OYW1lLlBST1BFUjtcbnZhciBkZWZpbmVCdWlsdEluID0gZGVmaW5lQnVpbHRJbiQ2O1xudmFyIGFuT2JqZWN0ID0gYW5PYmplY3QkYztcbnZhciAkdG9TdHJpbmcgPSB0b1N0cmluZyQzO1xudmFyIGZhaWxzID0gZmFpbHMkaDtcbnZhciBnZXRSZWdFeHBGbGFncyA9IHJlZ2V4cEdldEZsYWdzO1xuXG52YXIgVE9fU1RSSU5HID0gJ3RvU3RyaW5nJztcbnZhciBSZWdFeHBQcm90b3R5cGUgPSBSZWdFeHAucHJvdG90eXBlO1xudmFyIG4kVG9TdHJpbmcgPSBSZWdFeHBQcm90b3R5cGVbVE9fU1RSSU5HXTtcblxudmFyIE5PVF9HRU5FUklDID0gZmFpbHMoZnVuY3Rpb24gKCkgeyByZXR1cm4gbiRUb1N0cmluZy5jYWxsKHsgc291cmNlOiAnYScsIGZsYWdzOiAnYicgfSkgIT0gJy9hL2InOyB9KTtcbi8vIEZGNDQtIFJlZ0V4cCN0b1N0cmluZyBoYXMgYSB3cm9uZyBuYW1lXG52YXIgSU5DT1JSRUNUX05BTUUgPSBQUk9QRVJfRlVOQ1RJT05fTkFNRSAmJiBuJFRvU3RyaW5nLm5hbWUgIT0gVE9fU1RSSU5HO1xuXG4vLyBgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZ2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXJlZ2V4cC5wcm90b3R5cGUudG9zdHJpbmdcbmlmIChOT1RfR0VORVJJQyB8fCBJTkNPUlJFQ1RfTkFNRSkge1xuICBkZWZpbmVCdWlsdEluKFJlZ0V4cC5wcm90b3R5cGUsIFRPX1NUUklORywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgdmFyIFIgPSBhbk9iamVjdCh0aGlzKTtcbiAgICB2YXIgcGF0dGVybiA9ICR0b1N0cmluZyhSLnNvdXJjZSk7XG4gICAgdmFyIGZsYWdzID0gJHRvU3RyaW5nKGdldFJlZ0V4cEZsYWdzKFIpKTtcbiAgICByZXR1cm4gJy8nICsgcGF0dGVybiArICcvJyArIGZsYWdzO1xuICB9LCB7IHVuc2FmZTogdHJ1ZSB9KTtcbn1cblxuY29uc3QgQ29weUljb24gPSAoKSA9PiBqc3hzKFwic3ZnXCIsIE9iamVjdC5hc3NpZ24oe1xuICB3aWR0aDogMjQsXG4gIGhlaWdodDogMjQsXG4gIHZpZXdCb3g6IFwiMCAwIDI0IDI0XCIsXG4gIGZpbGw6IFwibm9uZVwiLFxuICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG59LCB7XG4gIGNoaWxkcmVuOiBbanN4KFwicGF0aFwiLCB7XG4gICAgZDogXCJNNi41IDE1LjI1YTEuNzUgMS43NSAwIDAgMS0xLjc1LTEuNzVWNi43NWEyIDIgMCAwIDEgMi0yaDYuNzVjLjk2NiAwIDEuNzUuNzg0IDEuNzUgMS43NVwiLFxuICAgIHN0cm9rZTogXCIjNEY3Q0QxXCIsXG4gICAgc3Ryb2tlV2lkdGg6IDEuNSxcbiAgICBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsXG4gICAgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIlxuICB9KSwganN4KFwicGF0aFwiLCB7XG4gICAgZDogXCJNOC43NSAxMC43NWEyIDIgMCAwIDEgMi0yaDYuNWEyIDIgMCAwIDEgMiAydjYuNWEyIDIgMCAwIDEtMiAyaC02LjVhMiAyIDAgMCAxLTItMnYtNi41WlwiLFxuICAgIHN0cm9rZTogXCIjNEY3Q0QxXCIsXG4gICAgc3Ryb2tlV2lkdGg6IDEuNSxcbiAgICBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsXG4gICAgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIlxuICB9KV1cbn0pKTtcblxuZnVuY3Rpb24gZm9ybWF0UVJDb2RlSW1hZ2UoZGF0YSkge1xuICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgIHJldHVybiB5aWVsZCBRUkNvZGUudG9TdHJpbmcoZGF0YSwge1xuICAgICAgbWFyZ2luOiAwLFxuICAgICAgdHlwZTogXCJzdmdcIlxuICAgIH0pO1xuICB9KTtcbn1cbmNvbnN0IFNjYW5RUkNvZGUgPSAoe1xuICB3YWxsZXQsXG4gIHVyaSxcbiAgb25DbG9zZU1vZGFsLFxuICBoYW5kbGVPcGVuRGVmYXVsdE1vZGFsXG59KSA9PiB7XG4gIGNvbnN0IFtub3RpZmljYXRpb24sIHNldE5vdGlmaWNhdGlvbl0gPSBSZWFjdC51c2VTdGF0ZShcIlwiKTtcbiAgY29uc3QgW3N2Zywgc2V0U3ZnXSA9IFJlYWN0LnVzZVN0YXRlKFwiXCIpO1xuICBjb25zdCBjb3B5VG9DbGlwYm9hcmQgPSAoKSA9PiB7XG4gICAgaWYgKCF1cmkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3VjY2VzcyA9IGNvcHkodXJpKTtcbiAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgc2V0Tm90aWZpY2F0aW9uKHRyYW5zbGF0ZShcIm1vZGFsLnFyLmNvcGllZFRvQ2xpcGJvYXJkXCIpKTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gc2V0Tm90aWZpY2F0aW9uKFwiXCIpLCAxMjAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0Tm90aWZpY2F0aW9uKHRyYW5zbGF0ZShcIm1vZGFsLnFyLmZhaWxlZFRvQ29weVwiKSk7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHNldE5vdGlmaWNhdGlvbihcIlwiKSwgMTIwMCk7XG4gICAgfVxuICB9O1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICgoKSA9PiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICh1cmkpIHtcbiAgICAgICAgc2V0U3ZnKHlpZWxkIGZvcm1hdFFSQ29kZUltYWdlKHVyaSkpO1xuICAgICAgfVxuICAgIH0pKSgpO1xuICB9LCBbdXJpXSk7XG4gIHJldHVybiBqc3hzKFwic2VjdGlvblwiLCBPYmplY3QuYXNzaWduKHtcbiAgICBjbGFzc05hbWU6IFwic2Nhbi1xci1jb2RlXCJcbiAgfSwge1xuICAgIGNoaWxkcmVuOiBbanN4KE1vZGFsSGVhZGVyLCB7XG4gICAgICB0aXRsZTogdHJhbnNsYXRlKFwibW9kYWwucXIuc2NhbldpdGhZb3VyTW9iaWxlXCIpLFxuICAgICAgb25DbG9zZU1vZGFsOiBvbkNsb3NlTW9kYWxcbiAgICB9KSwganN4cyhcInNlY3Rpb25cIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICBjbGFzc05hbWU6IFwicXItY29kZVwiXG4gICAgfSwge1xuICAgICAgY2hpbGRyZW46IFtqc3goXCJkaXZcIiwge1xuICAgICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDoge1xuICAgICAgICAgIF9faHRtbDogc3ZnXG4gICAgICAgIH1cbiAgICAgIH0pLCBub3RpZmljYXRpb24gPyBqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGNsYXNzTmFtZTogXCJub3RpZmljYXRpb25cIlxuICAgICAgfSwge1xuICAgICAgICBjaGlsZHJlbjogbm90aWZpY2F0aW9uXG4gICAgICB9KSkgOiBqc3hzKFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBjbGFzc05hbWU6IFwiY29weS1idG5cIixcbiAgICAgICAgb25DbGljazogY29weVRvQ2xpcGJvYXJkXG4gICAgICB9LCB7XG4gICAgICAgIGNoaWxkcmVuOiBbanN4KENvcHlJY29uLCB7fSksIHRyYW5zbGF0ZShcIm1vZGFsLnFyLmNvcHlUb0NsaXBib2FyZFwiKV1cbiAgICAgIH0pKV1cbiAgICB9KSksIGpzeHMoXCJmb290ZXJcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICBjbGFzc05hbWU6IFwiZm9vdGVyXCJcbiAgICB9LCB7XG4gICAgICBjaGlsZHJlbjogW2pzeHMoXCJwXCIsIHtcbiAgICAgICAgY2hpbGRyZW46IFt0cmFuc2xhdGUoXCJtb2RhbC5xci5wcmVmZXJUaGVPZmZpY2lhbFwiKSwgXCIgXCIsIHdhbGxldC5tZXRhZGF0YS5uYW1lLCBcIj9cIl1cbiAgICAgIH0pLCBqc3goXCJidXR0b25cIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGNsYXNzTmFtZTogXCJidG5cIixcbiAgICAgICAgb25DbGljazogaGFuZGxlT3BlbkRlZmF1bHRNb2RhbFxuICAgICAgfSwge1xuICAgICAgICBjaGlsZHJlbjogdHJhbnNsYXRlKFwibW9kYWwucXIub3BlblwiKVxuICAgICAgfSkpXVxuICAgIH0pKV1cbiAgfSkpO1xufTtcblxuY29uc3QgZ2V0VGhlbWVDbGFzcyA9IHRoZW1lID0+IHtcbiAgc3dpdGNoICh0aGVtZSkge1xuICAgIGNhc2UgXCJkYXJrXCI6XG4gICAgICByZXR1cm4gXCJkYXJrLXRoZW1lXCI7XG4gICAgY2FzZSBcImxpZ2h0XCI6XG4gICAgICByZXR1cm4gXCJsaWdodC10aGVtZVwiO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gXCJcIjtcbiAgfVxufTtcbmNvbnN0IE1vZGFsID0gKHtcbiAgc2VsZWN0b3IsXG4gIG9wdGlvbnMsXG4gIHZpc2libGUsXG4gIGhpZGUsXG4gIGVtaXR0ZXJcbn0pID0+IHtcbiAgdmFyIF9hLCBfYiwgX2M7XG4gIGNvbnN0IFtyb3V0ZSwgc2V0Um91dGVdID0gdXNlU3RhdGUoe1xuICAgIG5hbWU6IFwiV2FsbGV0SG9tZVwiXG4gIH0pO1xuICBjb25zdCBbYWxlcnRNZXNzYWdlLCBzZXRBbGVydE1lc3NhZ2VdID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IFtzZWxlY3RlZFdhbGxldCwgc2V0U2VsZWN0ZWRXYWxsZXRdID0gdXNlU3RhdGUoKTtcbiAgY29uc3QgW2JyaWRnZVdhbGxldFVyaSwgc2V0QnJpZGdlV2FsbGV0VXJpXSA9IHVzZVN0YXRlKCk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgc2V0Um91dGUoe1xuICAgICAgbmFtZTogXCJXYWxsZXRIb21lXCJcbiAgICB9KTtcbiAgICBhbGxvd09ubHlMYW5ndWFnZShzZWxlY3Rvci5vcHRpb25zLmxhbmd1YWdlQ29kZSk7XG4gICAgY29uc3Qge1xuICAgICAgc2VsZWN0ZWRXYWxsZXRJZCxcbiAgICAgIG1vZHVsZXNcbiAgICB9ID0gc2VsZWN0b3Iuc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBpZiAoc2VsZWN0ZWRXYWxsZXRJZCkge1xuICAgICAgY29uc3QgbW9kdWxlID0gbW9kdWxlcy5maW5kKG0gPT4gbS5pZCA9PT0gc2VsZWN0ZWRXYWxsZXRJZCk7XG4gICAgICBzZXRTZWxlY3RlZFdhbGxldChtb2R1bGUpO1xuICAgICAgc2V0Um91dGUoe1xuICAgICAgICBuYW1lOiBcIldhbGxldENvbm5lY3RlZFwiLFxuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICBtb2R1bGVcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHNldEJyaWRnZVdhbGxldFVyaShcIlwiKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgfSwgW3Zpc2libGVdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBzZWxlY3Rvci5vbihcIm5ldHdvcmtDaGFuZ2VkXCIsICh7XG4gICAgICBuZXR3b3JrSWRcbiAgICB9KSA9PiB7XG4gICAgICAvLyBTd2l0Y2hlZCBiYWNrIHRvIHRoZSBjb3JyZWN0IG5ldHdvcmsuXG4gICAgICBpZiAobmV0d29ya0lkID09PSBzZWxlY3Rvci5vcHRpb25zLm5ldHdvcmsubmV0d29ya0lkKSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVEaXNtaXNzQ2xpY2soe30pO1xuICAgICAgfVxuICAgICAgc2V0Um91dGUoe1xuICAgICAgICBuYW1lOiBcIldhbGxldE5ldHdvcmtDaGFuZ2VkXCJcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiBzdWJzY3JpcHRpb24ucmVtb3ZlKCk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICB9LCBbXSk7XG4gIGNvbnN0IGhhbmRsZURpc21pc3NDbGljayA9IHVzZUNhbGxiYWNrKCh7XG4gICAgaGlkZVJlYXNvblxuICB9KSA9PiB7XG4gICAgc2V0QWxlcnRNZXNzYWdlKG51bGwpO1xuICAgIHNldFJvdXRlKHtcbiAgICAgIG5hbWU6IFwiV2FsbGV0SG9tZVwiXG4gICAgfSk7XG4gICAgaWYgKGhpZGVSZWFzb24gPT09IFwidXNlci10cmlnZ2VyZWRcIikge1xuICAgICAgZW1pdHRlci5lbWl0KFwib25IaWRlXCIsIHtcbiAgICAgICAgaGlkZVJlYXNvblxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChoaWRlUmVhc29uID09PSBcIndhbGxldC1uYXZpZ2F0aW9uXCIpIHtcbiAgICAgIGVtaXR0ZXIuZW1pdChcIm9uSGlkZVwiLCB7XG4gICAgICAgIGhpZGVSZWFzb25cbiAgICAgIH0pO1xuICAgIH1cbiAgICBoaWRlKCk7XG4gIH0sIFtoaWRlLCBlbWl0dGVyXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgY2xvc2UgPSBlID0+IHtcbiAgICAgIGlmIChlLmtleSA9PT0gXCJFc2NhcGVcIikge1xuICAgICAgICBoYW5kbGVEaXNtaXNzQ2xpY2soe1xuICAgICAgICAgIGhpZGVSZWFzb246IFwidXNlci10cmlnZ2VyZWRcIlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBjbG9zZSk7XG4gICAgcmV0dXJuICgpID0+IHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBjbG9zZSk7XG4gIH0sIFtoYW5kbGVEaXNtaXNzQ2xpY2tdKTtcbiAgY29uc3QgaGFuZGxlV2FsbGV0Q2xpY2sgPSAobW9kdWxlLCBxckNvZGVNb2RhbCkgPT4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgc2V0U2VsZWN0ZWRXYWxsZXQobW9kdWxlKTtcbiAgICBjb25zdCB7XG4gICAgICBzZWxlY3RlZFdhbGxldElkXG4gICAgfSA9IHNlbGVjdG9yLnN0b3JlLmdldFN0YXRlKCk7XG4gICAgaWYgKHNlbGVjdGVkV2FsbGV0SWQgPT09IG1vZHVsZS5pZCkge1xuICAgICAgc2V0Um91dGUoe1xuICAgICAgICBuYW1lOiBcIldhbGxldENvbm5lY3RlZFwiLFxuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICBtb2R1bGVcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRlcHJlY2F0ZWQsXG4gICAgICAgIGF2YWlsYWJsZVxuICAgICAgfSA9IG1vZHVsZS5tZXRhZGF0YTtcbiAgICAgIGlmIChtb2R1bGUudHlwZSA9PT0gXCJpbmplY3RlZFwiICYmICFhdmFpbGFibGUpIHtcbiAgICAgICAgc2V0Um91dGUoe1xuICAgICAgICAgIG5hbWU6IFwiV2FsbGV0Tm90SW5zdGFsbGVkXCIsXG4gICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICBtb2R1bGU6IG1vZHVsZVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHdhbGxldCA9IHlpZWxkIG1vZHVsZS53YWxsZXQoKTtcbiAgICAgIGlmIChkZXByZWNhdGVkKSB7XG4gICAgICAgIHNldEFsZXJ0TWVzc2FnZShgJHttb2R1bGUubWV0YWRhdGEubmFtZX0gaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHNlbGVjdCBhbm90aGVyIHdhbGxldC5gKTtcbiAgICAgICAgc2V0Um91dGUoe1xuICAgICAgICAgIG5hbWU6IFwiQWxlcnRNZXNzYWdlXCIsXG4gICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICBtb2R1bGU6IG1vZHVsZVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh3YWxsZXQudHlwZSA9PT0gXCJoYXJkd2FyZVwiKSB7XG4gICAgICAgIHNldFJvdXRlKHtcbiAgICAgICAgICBuYW1lOiBcIkRlcml2YXRpb25QYXRoXCIsXG4gICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICB3YWxsZXRJZDogd2FsbGV0LmlkIHx8IFwibGVkZ2VyXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZXRSb3V0ZSh7XG4gICAgICAgIG5hbWU6IFwiV2FsbGV0Q29ubmVjdGluZ1wiLFxuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICB3YWxsZXQ6IHdhbGxldFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmICh3YWxsZXQudHlwZSA9PT0gXCJicmlkZ2VcIikge1xuICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBzZWxlY3Rvci5vbihcInVyaUNoYW5nZWRcIiwgKHtcbiAgICAgICAgICB1cmlcbiAgICAgICAgfSkgPT4ge1xuICAgICAgICAgIHNldEJyaWRnZVdhbGxldFVyaSh1cmkpO1xuICAgICAgICAgIHNldFJvdXRlKHtcbiAgICAgICAgICAgIG5hbWU6IFwiU2NhblFSQ29kZVwiLFxuICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgIHVyaSxcbiAgICAgICAgICAgICAgd2FsbGV0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB5aWVsZCB3YWxsZXQuc2lnbkluKHtcbiAgICAgICAgICBjb250cmFjdElkOiBvcHRpb25zLmNvbnRyYWN0SWQsXG4gICAgICAgICAgbWV0aG9kTmFtZXM6IG9wdGlvbnMubWV0aG9kTmFtZXMsXG4gICAgICAgICAgcXJDb2RlTW9kYWxcbiAgICAgICAgfSk7XG4gICAgICAgIHN1YnNjcmlwdGlvbi5yZW1vdmUoKTtcbiAgICAgICAgaGFuZGxlRGlzbWlzc0NsaWNrKHtcbiAgICAgICAgICBoaWRlUmVhc29uOiBcIndhbGxldC1uYXZpZ2F0aW9uXCJcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh3YWxsZXQudHlwZSA9PT0gXCJicm93c2VyXCIpIHtcbiAgICAgICAgeWllbGQgd2FsbGV0LnNpZ25Jbih7XG4gICAgICAgICAgY29udHJhY3RJZDogb3B0aW9ucy5jb250cmFjdElkLFxuICAgICAgICAgIG1ldGhvZE5hbWVzOiBvcHRpb25zLm1ldGhvZE5hbWVzLFxuICAgICAgICAgIHN1Y2Nlc3NVcmw6IHdhbGxldC5tZXRhZGF0YS5zdWNjZXNzVXJsLFxuICAgICAgICAgIGZhaWx1cmVVcmw6IHdhbGxldC5tZXRhZGF0YS5mYWlsdXJlVXJsXG4gICAgICAgIH0pO1xuICAgICAgICBoYW5kbGVEaXNtaXNzQ2xpY2soe1xuICAgICAgICAgIGhpZGVSZWFzb246IFwid2FsbGV0LW5hdmlnYXRpb25cIlxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgeWllbGQgd2FsbGV0LnNpZ25Jbih7XG4gICAgICAgIGNvbnRyYWN0SWQ6IG9wdGlvbnMuY29udHJhY3RJZCxcbiAgICAgICAgbWV0aG9kTmFtZXM6IG9wdGlvbnMubWV0aG9kTmFtZXNcbiAgICAgIH0pO1xuICAgICAgaGFuZGxlRGlzbWlzc0NsaWNrKHtcbiAgICAgICAgaGlkZVJlYXNvbjogXCJ3YWxsZXQtbmF2aWdhdGlvblwiXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbmFtZVxuICAgICAgfSA9IG1vZHVsZS5tZXRhZGF0YTtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBlcnIgJiYgdHlwZW9mIGVyciA9PT0gXCJvYmplY3RcIiAmJiBcIm1lc3NhZ2VcIiBpbiBlcnIgPyBlcnIubWVzc2FnZSA6IFwiU29tZXRoaW5nIHdlbnQgd3JvbmdcIjtcbiAgICAgIHNldEFsZXJ0TWVzc2FnZShgRmFpbGVkIHRvIHNpZ24gaW4gd2l0aCAke25hbWV9OiAke21lc3NhZ2V9YCk7XG4gICAgICBzZXRSb3V0ZSh7XG4gICAgICAgIG5hbWU6IFwiQWxlcnRNZXNzYWdlXCIsXG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgIG1vZHVsZTogbW9kdWxlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIGlmICghdmlzaWJsZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBqc3hzKFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgIGNsYXNzTmFtZTogYG53cy1tb2RhbC13cmFwcGVyICR7Z2V0VGhlbWVDbGFzcyhvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudGhlbWUpfSAke3Zpc2libGUgPyBcIm9wZW5cIiA6IFwiXCJ9YFxuICB9LCB7XG4gICAgY2hpbGRyZW46IFtqc3goXCJkaXZcIiwge1xuICAgICAgY2xhc3NOYW1lOiBcIm53cy1tb2RhbC1vdmVybGF5XCIsXG4gICAgICBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICAgIGhhbmRsZURpc21pc3NDbGljayh7XG4gICAgICAgICAgaGlkZVJlYXNvbjogXCJ1c2VyLXRyaWdnZXJlZFwiXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pLCBqc3hzKFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgY2xhc3NOYW1lOiBcIm53cy1tb2RhbFwiXG4gICAgfSwge1xuICAgICAgY2hpbGRyZW46IFtqc3hzKFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBjbGFzc05hbWU6IFwibW9kYWwtbGVmdFwiXG4gICAgICB9LCB7XG4gICAgICAgIGNoaWxkcmVuOiBbanN4KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgIGNsYXNzTmFtZTogXCJtb2RhbC1sZWZ0LXRpdGxlXCJcbiAgICAgICAgfSwge1xuICAgICAgICAgIGNoaWxkcmVuOiBqc3goXCJoMlwiLCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogdHJhbnNsYXRlKFwibW9kYWwud2FsbGV0LmNvbm5lY3RZb3VyV2FsbGV0XCIpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSkpLCBqc3goV2FsbGV0T3B0aW9ucywge1xuICAgICAgICAgIGhhbmRsZVdhbGxldENsaWNrOiBtb2R1bGUgPT4ge1xuICAgICAgICAgICAgaGFuZGxlV2FsbGV0Q2xpY2sobW9kdWxlLCBmYWxzZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZWxlY3Rvcjogc2VsZWN0b3JcbiAgICAgICAgfSldXG4gICAgICB9KSksIGpzeChcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgY2xhc3NOYW1lOiBcIm1vZGFsLXJpZ2h0XCJcbiAgICAgIH0sIHtcbiAgICAgICAgY2hpbGRyZW46IGpzeHMoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcIm53cy1tb2RhbC1ib2R5XCJcbiAgICAgICAgfSwge1xuICAgICAgICAgIGNoaWxkcmVuOiBbcm91dGUubmFtZSA9PT0gXCJBbGVydE1lc3NhZ2VcIiAmJiBhbGVydE1lc3NhZ2UgJiYganN4KEFsZXJ0TWVzc2FnZSwge1xuICAgICAgICAgICAgbWVzc2FnZTogYWxlcnRNZXNzYWdlLFxuICAgICAgICAgICAgbW9kdWxlOiAoX2EgPSByb3V0ZS5wYXJhbXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tb2R1bGUsXG4gICAgICAgICAgICBvbkJhY2s6IHJldHJ5ID0+IHtcbiAgICAgICAgICAgICAgaWYgKHJldHJ5KSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlV2FsbGV0Q2xpY2soc2VsZWN0ZWRXYWxsZXQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzZXRBbGVydE1lc3NhZ2UobnVsbCk7XG4gICAgICAgICAgICAgIHNldFJvdXRlKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcIldhbGxldEhvbWVcIlxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkNsb3NlTW9kYWw6ICgpID0+IGhhbmRsZURpc21pc3NDbGljayh7XG4gICAgICAgICAgICAgIGhpZGVSZWFzb246IFwidXNlci10cmlnZ2VyZWRcIlxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KSwgcm91dGUubmFtZSA9PT0gXCJEZXJpdmF0aW9uUGF0aFwiICYmIGpzeChEZXJpdmF0aW9uUGF0aCwge1xuICAgICAgICAgICAgc2VsZWN0b3I6IHNlbGVjdG9yLFxuICAgICAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgICAgIG9uQ29ubmVjdGVkOiAoKSA9PiB7XG4gICAgICAgICAgICAgIGhhbmRsZURpc21pc3NDbGljayh7XG4gICAgICAgICAgICAgICAgaGlkZVJlYXNvbjogXCJ3YWxsZXQtbmF2aWdhdGlvblwiXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhcmFtczogcm91dGUucGFyYW1zLFxuICAgICAgICAgICAgb25CYWNrOiAoKSA9PiBzZXRSb3V0ZSh7XG4gICAgICAgICAgICAgIG5hbWU6IFwiV2FsbGV0SG9tZVwiXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIG9uRXJyb3I6IChtZXNzYWdlLCB3YWxsZXQpID0+IHtcbiAgICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIG1vZHVsZXNcbiAgICAgICAgICAgICAgfSA9IHNlbGVjdG9yLnN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgIGNvbnN0IGZpbmRNb2R1bGUgPSBtb2R1bGVzLmZpbmQobW9kdWxlID0+IG1vZHVsZS5pZCA9PT0gd2FsbGV0LmlkKTtcbiAgICAgICAgICAgICAgc2V0QWxlcnRNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICBzZXRSb3V0ZSh7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJBbGVydE1lc3NhZ2VcIixcbiAgICAgICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICAgIG1vZHVsZTogZmluZE1vZHVsZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25DbG9zZU1vZGFsOiAoKSA9PiBoYW5kbGVEaXNtaXNzQ2xpY2soe1xuICAgICAgICAgICAgICBoaWRlUmVhc29uOiBcInVzZXItdHJpZ2dlcmVkXCJcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSksIHJvdXRlLm5hbWUgPT09IFwiV2FsbGV0TmV0d29ya0NoYW5nZWRcIiAmJiBqc3goV2FsbGV0TmV0d29ya0NoYW5nZWQsIHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiBzZWxlY3RvcixcbiAgICAgICAgICAgIG9uQmFjazogKCkgPT4gc2V0Um91dGUoe1xuICAgICAgICAgICAgICBuYW1lOiBcIldhbGxldEhvbWVcIlxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBvbkNsb3NlTW9kYWw6ICgpID0+IGhhbmRsZURpc21pc3NDbGljayh7XG4gICAgICAgICAgICAgIGhpZGVSZWFzb246IFwidXNlci10cmlnZ2VyZWRcIlxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KSwgcm91dGUubmFtZSA9PT0gXCJXYWxsZXROb3RJbnN0YWxsZWRcIiAmJiBqc3goV2FsbGV0Tm90SW5zdGFsbGVkLCB7XG4gICAgICAgICAgICBtb2R1bGU6IChfYiA9IHJvdXRlLnBhcmFtcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm1vZHVsZSxcbiAgICAgICAgICAgIG9uQmFjazogKCkgPT4ge1xuICAgICAgICAgICAgICBzZXRSb3V0ZSh7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJXYWxsZXRIb21lXCJcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25DbG9zZU1vZGFsOiAoKSA9PiBoYW5kbGVEaXNtaXNzQ2xpY2soe1xuICAgICAgICAgICAgICBoaWRlUmVhc29uOiBcInVzZXItdHJpZ2dlcmVkXCJcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSksIHJvdXRlLm5hbWUgPT09IFwiV2FsbGV0Q29ubmVjdGluZ1wiICYmIGpzeChXYWxsZXRDb25uZWN0aW5nLCB7XG4gICAgICAgICAgICB3YWxsZXQ6IChfYyA9IHJvdXRlLnBhcmFtcykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLndhbGxldCxcbiAgICAgICAgICAgIG9uQmFjazogKCkgPT4ge1xuICAgICAgICAgICAgICBzZXRSb3V0ZSh7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJXYWxsZXRIb21lXCJcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25DbG9zZU1vZGFsOiAoKSA9PiBoYW5kbGVEaXNtaXNzQ2xpY2soe1xuICAgICAgICAgICAgICBoaWRlUmVhc29uOiBcInVzZXItdHJpZ2dlcmVkXCJcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSksIHJvdXRlLm5hbWUgPT09IFwiV2FsbGV0SG9tZVwiICYmIGpzeChXYWxsZXRIb21lLCB7XG4gICAgICAgICAgICBzZWxlY3Rvcjogc2VsZWN0b3IsXG4gICAgICAgICAgICBvbkNsb3NlTW9kYWw6ICgpID0+IGhhbmRsZURpc21pc3NDbGljayh7XG4gICAgICAgICAgICAgIGhpZGVSZWFzb246IFwidXNlci10cmlnZ2VyZWRcIlxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KSwgcm91dGUubmFtZSA9PT0gXCJXYWxsZXRDb25uZWN0ZWRcIiAmJiBqc3goV2FsbGV0Q29ubmVjdGVkLCB7XG4gICAgICAgICAgICBtb2R1bGU6IHNlbGVjdGVkV2FsbGV0LFxuICAgICAgICAgICAgb25DbG9zZU1vZGFsOiAoKSA9PiBoYW5kbGVEaXNtaXNzQ2xpY2soe1xuICAgICAgICAgICAgICBoaWRlUmVhc29uOiBcInVzZXItdHJpZ2dlcmVkXCJcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSksIHJvdXRlLm5hbWUgPT09IFwiU2NhblFSQ29kZVwiICYmIGpzeChTY2FuUVJDb2RlLCB7XG4gICAgICAgICAgICBoYW5kbGVPcGVuRGVmYXVsdE1vZGFsOiAoKSA9PiB7XG4gICAgICAgICAgICAgIGhhbmRsZVdhbGxldENsaWNrKHNlbGVjdGVkV2FsbGV0LCB0cnVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkNsb3NlTW9kYWw6ICgpID0+IGhhbmRsZURpc21pc3NDbGljayh7XG4gICAgICAgICAgICAgIGhpZGVSZWFzb246IFwidXNlci10cmlnZ2VyZWRcIlxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB1cmk6IGJyaWRnZVdhbGxldFVyaSxcbiAgICAgICAgICAgIHdhbGxldDogc2VsZWN0ZWRXYWxsZXRcbiAgICAgICAgICB9KV1cbiAgICAgICAgfSkpXG4gICAgICB9KSldXG4gICAgfSkpXVxuICB9KSk7XG59O1xuXG5jb25zdCBNT0RBTF9FTEVNRU5UX0lEID0gXCJuZWFyLXdhbGxldC1zZWxlY3Rvci1tb2RhbFwiO1xubGV0IG1vZGFsSW5zdGFuY2UgPSBudWxsO1xubGV0IHJvb3QgPSBudWxsO1xuLyoqXHJcbiAqIEluaXRpYXRlcyBhIG1vZGFsIGluc3RhbmNlXHJcbiAqIEBwYXJhbSB7V2FsbGV0U2VsZWN0b3J9IHNlbGVjdG9yIFNlbGVjdG9yXHJcbiAqIEBwYXJhbSB7TW9kYWxPcHRpb25zfSBvcHRpb25zIE1vZGFsIG9wdGlvbnNcclxuICogQHJldHVybnMge1dhbGxldFNlbGVjdG9yTW9kYWx9IFJldHVybnMgYSBXYWxsZXRTZWxlY3Rvck1vZGFsIG9iamVjdFxyXG4gKi9cbmNvbnN0IHNldHVwTW9kYWwgPSAoc2VsZWN0b3IsIG9wdGlvbnMpID0+IHtcbiAgaWYgKCFyb290KSB7XG4gICAgY29uc3QgYm9keSA9IGRvY3VtZW50LmJvZHk7XG4gICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBjb250YWluZXIuaWQgPSBNT0RBTF9FTEVNRU5UX0lEO1xuICAgIGJvZHkuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcbiAgICByb290ID0gY3JlYXRlUm9vdChjb250YWluZXIpO1xuICB9XG4gIGNvbnN0IGVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gIHNlbGVjdG9yLnN0b3JlLmdldFN0YXRlKCkubW9kdWxlcy5mb3JFYWNoKG1vZHVsZSA9PiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICBpZiAoXCJ0b3BMZXZlbEluamVjdGVkXCIgaW4gbW9kdWxlLm1ldGFkYXRhKSB7XG4gICAgICBpZiAoIW1vZHVsZS5tZXRhZGF0YS50b3BMZXZlbEluamVjdGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHdhbGxldCA9IHlpZWxkIG1vZHVsZS53YWxsZXQoKTtcbiAgICAgIGlmICh3YWxsZXQudHlwZSAhPT0gXCJpbmplY3RlZFwiKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHlpZWxkIHdhbGxldC5zaWduSW4oe1xuICAgICAgICBjb250cmFjdElkOiBvcHRpb25zLmNvbnRyYWN0SWQsXG4gICAgICAgIG1ldGhvZE5hbWVzOiBvcHRpb25zLm1ldGhvZE5hbWVzXG4gICAgICB9KTtcbiAgICB9XG4gIH0pKTtcbiAgY29uc3QgcmVuZGVyID0gKHZpc2libGUgPSBmYWxzZSkgPT4ge1xuICAgIHJvb3QucmVuZGVyKGpzeChNb2RhbCwge1xuICAgICAgc2VsZWN0b3I6IHNlbGVjdG9yLFxuICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgIHZpc2libGU6IHZpc2libGUsXG4gICAgICBoaWRlOiAoKSA9PiByZW5kZXIoZmFsc2UpLFxuICAgICAgZW1pdHRlcjogZW1pdHRlclxuICAgIH0pKTtcbiAgfTtcbiAgaWYgKCFtb2RhbEluc3RhbmNlKSB7XG4gICAgbW9kYWxJbnN0YW5jZSA9IHtcbiAgICAgIHNob3c6ICgpID0+IHtcbiAgICAgICAgcmVuZGVyKHRydWUpO1xuICAgICAgfSxcbiAgICAgIGhpZGU6ICgpID0+IHtcbiAgICAgICAgcmVuZGVyKGZhbHNlKTtcbiAgICAgIH0sXG4gICAgICBvbjogKGV2ZW50TmFtZSwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgcmV0dXJuIGVtaXR0ZXIub24oZXZlbnROYW1lLCBjYWxsYmFjayk7XG4gICAgICB9LFxuICAgICAgb2ZmOiAoZXZlbnROYW1lLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICBlbWl0dGVyLm9mZihldmVudE5hbWUsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHJldHVybiBtb2RhbEluc3RhbmNlO1xufTtcblxuZXhwb3J0IHsgc2V0dXBNb2RhbCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@near-wallet-selector/modal-ui/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@near-wallet-selector/my-near-wallet/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@near-wallet-selector/my-near-wallet/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   setupMyNearWallet: () => (/* binding */ setupMyNearWallet)\n/* harmony export */ });\n/* harmony import */ var near_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! near-api-js */ \"(ssr)/./node_modules/near-api-js/lib/index.js\");\n/* harmony import */ var _near_wallet_selector_wallet_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @near-wallet-selector/wallet-utils */ \"(ssr)/./node_modules/@near-wallet-selector/wallet-utils/index.cjs\");\n\n\n\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nvar check = function (it) {\n  return it && it.Math == Math && it;\n};\n\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global$o =\n  // eslint-disable-next-line es-x/no-global-this -- safe\n  check(typeof globalThis == 'object' && globalThis) ||\n  check(typeof window == 'object' && window) ||\n  // eslint-disable-next-line no-restricted-globals -- safe\n  check(typeof self == 'object' && self) ||\n  check(typeof commonjsGlobal == 'object' && commonjsGlobal) ||\n  // eslint-disable-next-line no-new-func -- fallback\n  (function () { return this; })() || Function('return this')();\n\nvar objectGetOwnPropertyDescriptor = {};\n\nvar fails$k = function (exec) {\n  try {\n    return !!exec();\n  } catch (error) {\n    return true;\n  }\n};\n\nvar fails$j = fails$k;\n\n// Detect IE8's incomplete defineProperty implementation\nvar descriptors = !fails$j(function () {\n  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;\n});\n\nvar fails$i = fails$k;\n\nvar functionBindNative = !fails$i(function () {\n  // eslint-disable-next-line es-x/no-function-prototype-bind -- safe\n  var test = (function () { /* empty */ }).bind();\n  // eslint-disable-next-line no-prototype-builtins -- safe\n  return typeof test != 'function' || test.hasOwnProperty('prototype');\n});\n\nvar NATIVE_BIND$3 = functionBindNative;\n\nvar call$k = Function.prototype.call;\n\nvar functionCall = NATIVE_BIND$3 ? call$k.bind(call$k) : function () {\n  return call$k.apply(call$k, arguments);\n};\n\nvar objectPropertyIsEnumerable = {};\n\nvar $propertyIsEnumerable = {}.propertyIsEnumerable;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar getOwnPropertyDescriptor$3 = Object.getOwnPropertyDescriptor;\n\n// Nashorn ~ JDK8 bug\nvar NASHORN_BUG = getOwnPropertyDescriptor$3 && !$propertyIsEnumerable.call({ 1: 2 }, 1);\n\n// `Object.prototype.propertyIsEnumerable` method implementation\n// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable\nobjectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n  var descriptor = getOwnPropertyDescriptor$3(this, V);\n  return !!descriptor && descriptor.enumerable;\n} : $propertyIsEnumerable;\n\nvar createPropertyDescriptor$5 = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n\nvar NATIVE_BIND$2 = functionBindNative;\n\nvar FunctionPrototype$2 = Function.prototype;\nvar bind$8 = FunctionPrototype$2.bind;\nvar call$j = FunctionPrototype$2.call;\nvar uncurryThis$m = NATIVE_BIND$2 && bind$8.bind(call$j, call$j);\n\nvar functionUncurryThis = NATIVE_BIND$2 ? function (fn) {\n  return fn && uncurryThis$m(fn);\n} : function (fn) {\n  return fn && function () {\n    return call$j.apply(fn, arguments);\n  };\n};\n\nvar uncurryThis$l = functionUncurryThis;\n\nvar toString$6 = uncurryThis$l({}.toString);\nvar stringSlice$6 = uncurryThis$l(''.slice);\n\nvar classofRaw$1 = function (it) {\n  return stringSlice$6(toString$6(it), 8, -1);\n};\n\nvar uncurryThis$k = functionUncurryThis;\nvar fails$h = fails$k;\nvar classof$7 = classofRaw$1;\n\nvar $Object$4 = Object;\nvar split$3 = uncurryThis$k(''.split);\n\n// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar indexedObject = fails$h(function () {\n  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n  // eslint-disable-next-line no-prototype-builtins -- safe\n  return !$Object$4('z').propertyIsEnumerable(0);\n}) ? function (it) {\n  return classof$7(it) == 'String' ? split$3(it, '') : $Object$4(it);\n} : $Object$4;\n\nvar $TypeError$c = TypeError;\n\n// `RequireObjectCoercible` abstract operation\n// https://tc39.es/ecma262/#sec-requireobjectcoercible\nvar requireObjectCoercible$4 = function (it) {\n  if (it == undefined) throw $TypeError$c(\"Can't call method on \" + it);\n  return it;\n};\n\n// toObject with fallback for non-array-like ES3 strings\nvar IndexedObject$1 = indexedObject;\nvar requireObjectCoercible$3 = requireObjectCoercible$4;\n\nvar toIndexedObject$5 = function (it) {\n  return IndexedObject$1(requireObjectCoercible$3(it));\n};\n\n// `IsCallable` abstract operation\n// https://tc39.es/ecma262/#sec-iscallable\nvar isCallable$n = function (argument) {\n  return typeof argument == 'function';\n};\n\nvar isCallable$m = isCallable$n;\n\nvar isObject$8 = function (it) {\n  return typeof it == 'object' ? it !== null : isCallable$m(it);\n};\n\nvar global$n = global$o;\nvar isCallable$l = isCallable$n;\n\nvar aFunction = function (argument) {\n  return isCallable$l(argument) ? argument : undefined;\n};\n\nvar getBuiltIn$8 = function (namespace, method) {\n  return arguments.length < 2 ? aFunction(global$n[namespace]) : global$n[namespace] && global$n[namespace][method];\n};\n\nvar uncurryThis$j = functionUncurryThis;\n\nvar objectIsPrototypeOf = uncurryThis$j({}.isPrototypeOf);\n\nvar getBuiltIn$7 = getBuiltIn$8;\n\nvar engineUserAgent = getBuiltIn$7('navigator', 'userAgent') || '';\n\nvar global$m = global$o;\nvar userAgent$3 = engineUserAgent;\n\nvar process$3 = global$m.process;\nvar Deno$1 = global$m.Deno;\nvar versions = process$3 && process$3.versions || Deno$1 && Deno$1.version;\nvar v8 = versions && versions.v8;\nvar match, version;\n\nif (v8) {\n  match = v8.split('.');\n  // in old Chrome, versions of V8 isn't V8 = Chrome / 10\n  // but their correct versions are not interesting for us\n  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);\n}\n\n// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`\n// so check `userAgent` even if `.v8` exists, but 0\nif (!version && userAgent$3) {\n  match = userAgent$3.match(/Edge\\/(\\d+)/);\n  if (!match || match[1] >= 74) {\n    match = userAgent$3.match(/Chrome\\/(\\d+)/);\n    if (match) version = +match[1];\n  }\n}\n\nvar engineV8Version = version;\n\n/* eslint-disable es-x/no-symbol -- required for testing */\n\nvar V8_VERSION$1 = engineV8Version;\nvar fails$g = fails$k;\n\n// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- required for testing\nvar nativeSymbol = !!Object.getOwnPropertySymbols && !fails$g(function () {\n  var symbol = Symbol();\n  // Chrome 38 Symbol has incorrect toString conversion\n  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances\n  return !String(symbol) || !(Object(symbol) instanceof Symbol) ||\n    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances\n    !Symbol.sham && V8_VERSION$1 && V8_VERSION$1 < 41;\n});\n\n/* eslint-disable es-x/no-symbol -- required for testing */\n\nvar NATIVE_SYMBOL$1 = nativeSymbol;\n\nvar useSymbolAsUid = NATIVE_SYMBOL$1\n  && !Symbol.sham\n  && typeof Symbol.iterator == 'symbol';\n\nvar getBuiltIn$6 = getBuiltIn$8;\nvar isCallable$k = isCallable$n;\nvar isPrototypeOf$3 = objectIsPrototypeOf;\nvar USE_SYMBOL_AS_UID$1 = useSymbolAsUid;\n\nvar $Object$3 = Object;\n\nvar isSymbol$2 = USE_SYMBOL_AS_UID$1 ? function (it) {\n  return typeof it == 'symbol';\n} : function (it) {\n  var $Symbol = getBuiltIn$6('Symbol');\n  return isCallable$k($Symbol) && isPrototypeOf$3($Symbol.prototype, $Object$3(it));\n};\n\nvar $String$3 = String;\n\nvar tryToString$4 = function (argument) {\n  try {\n    return $String$3(argument);\n  } catch (error) {\n    return 'Object';\n  }\n};\n\nvar isCallable$j = isCallable$n;\nvar tryToString$3 = tryToString$4;\n\nvar $TypeError$b = TypeError;\n\n// `Assert: IsCallable(argument) is true`\nvar aCallable$7 = function (argument) {\n  if (isCallable$j(argument)) return argument;\n  throw $TypeError$b(tryToString$3(argument) + ' is not a function');\n};\n\nvar aCallable$6 = aCallable$7;\n\n// `GetMethod` abstract operation\n// https://tc39.es/ecma262/#sec-getmethod\nvar getMethod$4 = function (V, P) {\n  var func = V[P];\n  return func == null ? undefined : aCallable$6(func);\n};\n\nvar call$i = functionCall;\nvar isCallable$i = isCallable$n;\nvar isObject$7 = isObject$8;\n\nvar $TypeError$a = TypeError;\n\n// `OrdinaryToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-ordinarytoprimitive\nvar ordinaryToPrimitive$1 = function (input, pref) {\n  var fn, val;\n  if (pref === 'string' && isCallable$i(fn = input.toString) && !isObject$7(val = call$i(fn, input))) return val;\n  if (isCallable$i(fn = input.valueOf) && !isObject$7(val = call$i(fn, input))) return val;\n  if (pref !== 'string' && isCallable$i(fn = input.toString) && !isObject$7(val = call$i(fn, input))) return val;\n  throw $TypeError$a(\"Can't convert object to primitive value\");\n};\n\nvar shared$4 = {exports: {}};\n\nvar isPure = false;\n\nvar global$l = global$o;\n\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar defineProperty$6 = Object.defineProperty;\n\nvar defineGlobalProperty$3 = function (key, value) {\n  try {\n    defineProperty$6(global$l, key, { value: value, configurable: true, writable: true });\n  } catch (error) {\n    global$l[key] = value;\n  } return value;\n};\n\nvar global$k = global$o;\nvar defineGlobalProperty$2 = defineGlobalProperty$3;\n\nvar SHARED = '__core-js_shared__';\nvar store$3 = global$k[SHARED] || defineGlobalProperty$2(SHARED, {});\n\nvar sharedStore = store$3;\n\nvar store$2 = sharedStore;\n\n(shared$4.exports = function (key, value) {\n  return store$2[key] || (store$2[key] = value !== undefined ? value : {});\n})('versions', []).push({\n  version: '3.23.3',\n  mode: 'global',\n  copyright: '© 2014-2022 Denis Pushkarev (zloirock.ru)',\n  license: 'https://github.com/zloirock/core-js/blob/v3.23.3/LICENSE',\n  source: 'https://github.com/zloirock/core-js'\n});\n\nvar requireObjectCoercible$2 = requireObjectCoercible$4;\n\nvar $Object$2 = Object;\n\n// `ToObject` abstract operation\n// https://tc39.es/ecma262/#sec-toobject\nvar toObject$5 = function (argument) {\n  return $Object$2(requireObjectCoercible$2(argument));\n};\n\nvar uncurryThis$i = functionUncurryThis;\nvar toObject$4 = toObject$5;\n\nvar hasOwnProperty = uncurryThis$i({}.hasOwnProperty);\n\n// `HasOwnProperty` abstract operation\n// https://tc39.es/ecma262/#sec-hasownproperty\n// eslint-disable-next-line es-x/no-object-hasown -- safe\nvar hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {\n  return hasOwnProperty(toObject$4(it), key);\n};\n\nvar uncurryThis$h = functionUncurryThis;\n\nvar id = 0;\nvar postfix = Math.random();\nvar toString$5 = uncurryThis$h(1.0.toString);\n\nvar uid$2 = function (key) {\n  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString$5(++id + postfix, 36);\n};\n\nvar global$j = global$o;\nvar shared$3 = shared$4.exports;\nvar hasOwn$c = hasOwnProperty_1;\nvar uid$1 = uid$2;\nvar NATIVE_SYMBOL = nativeSymbol;\nvar USE_SYMBOL_AS_UID = useSymbolAsUid;\n\nvar WellKnownSymbolsStore = shared$3('wks');\nvar Symbol$1 = global$j.Symbol;\nvar symbolFor = Symbol$1 && Symbol$1['for'];\nvar createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid$1;\n\nvar wellKnownSymbol$i = function (name) {\n  if (!hasOwn$c(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == 'string')) {\n    var description = 'Symbol.' + name;\n    if (NATIVE_SYMBOL && hasOwn$c(Symbol$1, name)) {\n      WellKnownSymbolsStore[name] = Symbol$1[name];\n    } else if (USE_SYMBOL_AS_UID && symbolFor) {\n      WellKnownSymbolsStore[name] = symbolFor(description);\n    } else {\n      WellKnownSymbolsStore[name] = createWellKnownSymbol(description);\n    }\n  } return WellKnownSymbolsStore[name];\n};\n\nvar call$h = functionCall;\nvar isObject$6 = isObject$8;\nvar isSymbol$1 = isSymbol$2;\nvar getMethod$3 = getMethod$4;\nvar ordinaryToPrimitive = ordinaryToPrimitive$1;\nvar wellKnownSymbol$h = wellKnownSymbol$i;\n\nvar $TypeError$9 = TypeError;\nvar TO_PRIMITIVE = wellKnownSymbol$h('toPrimitive');\n\n// `ToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-toprimitive\nvar toPrimitive$1 = function (input, pref) {\n  if (!isObject$6(input) || isSymbol$1(input)) return input;\n  var exoticToPrim = getMethod$3(input, TO_PRIMITIVE);\n  var result;\n  if (exoticToPrim) {\n    if (pref === undefined) pref = 'default';\n    result = call$h(exoticToPrim, input, pref);\n    if (!isObject$6(result) || isSymbol$1(result)) return result;\n    throw $TypeError$9(\"Can't convert object to primitive value\");\n  }\n  if (pref === undefined) pref = 'number';\n  return ordinaryToPrimitive(input, pref);\n};\n\nvar toPrimitive = toPrimitive$1;\nvar isSymbol = isSymbol$2;\n\n// `ToPropertyKey` abstract operation\n// https://tc39.es/ecma262/#sec-topropertykey\nvar toPropertyKey$3 = function (argument) {\n  var key = toPrimitive(argument, 'string');\n  return isSymbol(key) ? key : key + '';\n};\n\nvar global$i = global$o;\nvar isObject$5 = isObject$8;\n\nvar document$3 = global$i.document;\n// typeof document.createElement is 'object' in old IE\nvar EXISTS$1 = isObject$5(document$3) && isObject$5(document$3.createElement);\n\nvar documentCreateElement$2 = function (it) {\n  return EXISTS$1 ? document$3.createElement(it) : {};\n};\n\nvar DESCRIPTORS$c = descriptors;\nvar fails$f = fails$k;\nvar createElement$1 = documentCreateElement$2;\n\n// Thanks to IE8 for its funny defineProperty\nvar ie8DomDefine = !DESCRIPTORS$c && !fails$f(function () {\n  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n  return Object.defineProperty(createElement$1('div'), 'a', {\n    get: function () { return 7; }\n  }).a != 7;\n});\n\nvar DESCRIPTORS$b = descriptors;\nvar call$g = functionCall;\nvar propertyIsEnumerableModule$1 = objectPropertyIsEnumerable;\nvar createPropertyDescriptor$4 = createPropertyDescriptor$5;\nvar toIndexedObject$4 = toIndexedObject$5;\nvar toPropertyKey$2 = toPropertyKey$3;\nvar hasOwn$b = hasOwnProperty_1;\nvar IE8_DOM_DEFINE$1 = ie8DomDefine;\n\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;\n\n// `Object.getOwnPropertyDescriptor` method\n// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor\nobjectGetOwnPropertyDescriptor.f = DESCRIPTORS$b ? $getOwnPropertyDescriptor$1 : function getOwnPropertyDescriptor(O, P) {\n  O = toIndexedObject$4(O);\n  P = toPropertyKey$2(P);\n  if (IE8_DOM_DEFINE$1) try {\n    return $getOwnPropertyDescriptor$1(O, P);\n  } catch (error) { /* empty */ }\n  if (hasOwn$b(O, P)) return createPropertyDescriptor$4(!call$g(propertyIsEnumerableModule$1.f, O, P), O[P]);\n};\n\nvar objectDefineProperty = {};\n\nvar DESCRIPTORS$a = descriptors;\nvar fails$e = fails$k;\n\n// V8 ~ Chrome 36-\n// https://bugs.chromium.org/p/v8/issues/detail?id=3334\nvar v8PrototypeDefineBug = DESCRIPTORS$a && fails$e(function () {\n  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n  return Object.defineProperty(function () { /* empty */ }, 'prototype', {\n    value: 42,\n    writable: false\n  }).prototype != 42;\n});\n\nvar isObject$4 = isObject$8;\n\nvar $String$2 = String;\nvar $TypeError$8 = TypeError;\n\n// `Assert: Type(argument) is Object`\nvar anObject$g = function (argument) {\n  if (isObject$4(argument)) return argument;\n  throw $TypeError$8($String$2(argument) + ' is not an object');\n};\n\nvar DESCRIPTORS$9 = descriptors;\nvar IE8_DOM_DEFINE = ie8DomDefine;\nvar V8_PROTOTYPE_DEFINE_BUG$1 = v8PrototypeDefineBug;\nvar anObject$f = anObject$g;\nvar toPropertyKey$1 = toPropertyKey$3;\n\nvar $TypeError$7 = TypeError;\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar $defineProperty = Object.defineProperty;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar ENUMERABLE = 'enumerable';\nvar CONFIGURABLE$1 = 'configurable';\nvar WRITABLE = 'writable';\n\n// `Object.defineProperty` method\n// https://tc39.es/ecma262/#sec-object.defineproperty\nobjectDefineProperty.f = DESCRIPTORS$9 ? V8_PROTOTYPE_DEFINE_BUG$1 ? function defineProperty(O, P, Attributes) {\n  anObject$f(O);\n  P = toPropertyKey$1(P);\n  anObject$f(Attributes);\n  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {\n    var current = $getOwnPropertyDescriptor(O, P);\n    if (current && current[WRITABLE]) {\n      O[P] = Attributes.value;\n      Attributes = {\n        configurable: CONFIGURABLE$1 in Attributes ? Attributes[CONFIGURABLE$1] : current[CONFIGURABLE$1],\n        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],\n        writable: false\n      };\n    }\n  } return $defineProperty(O, P, Attributes);\n} : $defineProperty : function defineProperty(O, P, Attributes) {\n  anObject$f(O);\n  P = toPropertyKey$1(P);\n  anObject$f(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return $defineProperty(O, P, Attributes);\n  } catch (error) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw $TypeError$7('Accessors not supported');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n\nvar DESCRIPTORS$8 = descriptors;\nvar definePropertyModule$5 = objectDefineProperty;\nvar createPropertyDescriptor$3 = createPropertyDescriptor$5;\n\nvar createNonEnumerableProperty$5 = DESCRIPTORS$8 ? function (object, key, value) {\n  return definePropertyModule$5.f(object, key, createPropertyDescriptor$3(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n\nvar makeBuiltIn$3 = {exports: {}};\n\nvar DESCRIPTORS$7 = descriptors;\nvar hasOwn$a = hasOwnProperty_1;\n\nvar FunctionPrototype$1 = Function.prototype;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar getDescriptor = DESCRIPTORS$7 && Object.getOwnPropertyDescriptor;\n\nvar EXISTS = hasOwn$a(FunctionPrototype$1, 'name');\n// additional protection from minified / mangled / dropped function names\nvar PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';\nvar CONFIGURABLE = EXISTS && (!DESCRIPTORS$7 || (DESCRIPTORS$7 && getDescriptor(FunctionPrototype$1, 'name').configurable));\n\nvar functionName = {\n  EXISTS: EXISTS,\n  PROPER: PROPER,\n  CONFIGURABLE: CONFIGURABLE\n};\n\nvar uncurryThis$g = functionUncurryThis;\nvar isCallable$h = isCallable$n;\nvar store$1 = sharedStore;\n\nvar functionToString = uncurryThis$g(Function.toString);\n\n// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper\nif (!isCallable$h(store$1.inspectSource)) {\n  store$1.inspectSource = function (it) {\n    return functionToString(it);\n  };\n}\n\nvar inspectSource$4 = store$1.inspectSource;\n\nvar global$h = global$o;\nvar isCallable$g = isCallable$n;\nvar inspectSource$3 = inspectSource$4;\n\nvar WeakMap$1 = global$h.WeakMap;\n\nvar nativeWeakMap = isCallable$g(WeakMap$1) && /native code/.test(inspectSource$3(WeakMap$1));\n\nvar shared$2 = shared$4.exports;\nvar uid = uid$2;\n\nvar keys = shared$2('keys');\n\nvar sharedKey$3 = function (key) {\n  return keys[key] || (keys[key] = uid(key));\n};\n\nvar hiddenKeys$4 = {};\n\nvar NATIVE_WEAK_MAP = nativeWeakMap;\nvar global$g = global$o;\nvar uncurryThis$f = functionUncurryThis;\nvar isObject$3 = isObject$8;\nvar createNonEnumerableProperty$4 = createNonEnumerableProperty$5;\nvar hasOwn$9 = hasOwnProperty_1;\nvar shared$1 = sharedStore;\nvar sharedKey$2 = sharedKey$3;\nvar hiddenKeys$3 = hiddenKeys$4;\n\nvar OBJECT_ALREADY_INITIALIZED = 'Object already initialized';\nvar TypeError$4 = global$g.TypeError;\nvar WeakMap = global$g.WeakMap;\nvar set$1, get, has;\n\nvar enforce = function (it) {\n  return has(it) ? get(it) : set$1(it, {});\n};\n\nvar getterFor = function (TYPE) {\n  return function (it) {\n    var state;\n    if (!isObject$3(it) || (state = get(it)).type !== TYPE) {\n      throw TypeError$4('Incompatible receiver, ' + TYPE + ' required');\n    } return state;\n  };\n};\n\nif (NATIVE_WEAK_MAP || shared$1.state) {\n  var store = shared$1.state || (shared$1.state = new WeakMap());\n  var wmget = uncurryThis$f(store.get);\n  var wmhas = uncurryThis$f(store.has);\n  var wmset = uncurryThis$f(store.set);\n  set$1 = function (it, metadata) {\n    if (wmhas(store, it)) throw new TypeError$4(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    wmset(store, it, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return wmget(store, it) || {};\n  };\n  has = function (it) {\n    return wmhas(store, it);\n  };\n} else {\n  var STATE = sharedKey$2('state');\n  hiddenKeys$3[STATE] = true;\n  set$1 = function (it, metadata) {\n    if (hasOwn$9(it, STATE)) throw new TypeError$4(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    createNonEnumerableProperty$4(it, STATE, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return hasOwn$9(it, STATE) ? it[STATE] : {};\n  };\n  has = function (it) {\n    return hasOwn$9(it, STATE);\n  };\n}\n\nvar internalState = {\n  set: set$1,\n  get: get,\n  has: has,\n  enforce: enforce,\n  getterFor: getterFor\n};\n\nvar fails$d = fails$k;\nvar isCallable$f = isCallable$n;\nvar hasOwn$8 = hasOwnProperty_1;\nvar DESCRIPTORS$6 = descriptors;\nvar CONFIGURABLE_FUNCTION_NAME$1 = functionName.CONFIGURABLE;\nvar inspectSource$2 = inspectSource$4;\nvar InternalStateModule$5 = internalState;\n\nvar enforceInternalState = InternalStateModule$5.enforce;\nvar getInternalState$3 = InternalStateModule$5.get;\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar defineProperty$5 = Object.defineProperty;\n\nvar CONFIGURABLE_LENGTH = DESCRIPTORS$6 && !fails$d(function () {\n  return defineProperty$5(function () { /* empty */ }, 'length', { value: 8 }).length !== 8;\n});\n\nvar TEMPLATE = String(String).split('String');\n\nvar makeBuiltIn$2 = makeBuiltIn$3.exports = function (value, name, options) {\n  if (String(name).slice(0, 7) === 'Symbol(') {\n    name = '[' + String(name).replace(/^Symbol\\(([^)]*)\\)/, '$1') + ']';\n  }\n  if (options && options.getter) name = 'get ' + name;\n  if (options && options.setter) name = 'set ' + name;\n  if (!hasOwn$8(value, 'name') || (CONFIGURABLE_FUNCTION_NAME$1 && value.name !== name)) {\n    if (DESCRIPTORS$6) defineProperty$5(value, 'name', { value: name, configurable: true });\n    else value.name = name;\n  }\n  if (CONFIGURABLE_LENGTH && options && hasOwn$8(options, 'arity') && value.length !== options.arity) {\n    defineProperty$5(value, 'length', { value: options.arity });\n  }\n  try {\n    if (options && hasOwn$8(options, 'constructor') && options.constructor) {\n      if (DESCRIPTORS$6) defineProperty$5(value, 'prototype', { writable: false });\n    // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable\n    } else if (value.prototype) value.prototype = undefined;\n  } catch (error) { /* empty */ }\n  var state = enforceInternalState(value);\n  if (!hasOwn$8(state, 'source')) {\n    state.source = TEMPLATE.join(typeof name == 'string' ? name : '');\n  } return value;\n};\n\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n// eslint-disable-next-line no-extend-native -- required\nFunction.prototype.toString = makeBuiltIn$2(function toString() {\n  return isCallable$f(this) && getInternalState$3(this).source || inspectSource$2(this);\n}, 'toString');\n\nvar isCallable$e = isCallable$n;\nvar definePropertyModule$4 = objectDefineProperty;\nvar makeBuiltIn$1 = makeBuiltIn$3.exports;\nvar defineGlobalProperty$1 = defineGlobalProperty$3;\n\nvar defineBuiltIn$a = function (O, key, value, options) {\n  if (!options) options = {};\n  var simple = options.enumerable;\n  var name = options.name !== undefined ? options.name : key;\n  if (isCallable$e(value)) makeBuiltIn$1(value, name, options);\n  if (options.global) {\n    if (simple) O[key] = value;\n    else defineGlobalProperty$1(key, value);\n  } else {\n    try {\n      if (!options.unsafe) delete O[key];\n      else if (O[key]) simple = true;\n    } catch (error) { /* empty */ }\n    if (simple) O[key] = value;\n    else definePropertyModule$4.f(O, key, {\n      value: value,\n      enumerable: false,\n      configurable: !options.nonConfigurable,\n      writable: !options.nonWritable\n    });\n  } return O;\n};\n\nvar objectGetOwnPropertyNames = {};\n\nvar ceil = Math.ceil;\nvar floor$4 = Math.floor;\n\n// `Math.trunc` method\n// https://tc39.es/ecma262/#sec-math.trunc\n// eslint-disable-next-line es-x/no-math-trunc -- safe\nvar mathTrunc = Math.trunc || function trunc(x) {\n  var n = +x;\n  return (n > 0 ? floor$4 : ceil)(n);\n};\n\nvar trunc = mathTrunc;\n\n// `ToIntegerOrInfinity` abstract operation\n// https://tc39.es/ecma262/#sec-tointegerorinfinity\nvar toIntegerOrInfinity$4 = function (argument) {\n  var number = +argument;\n  // eslint-disable-next-line no-self-compare -- NaN check\n  return number !== number || number === 0 ? 0 : trunc(number);\n};\n\nvar toIntegerOrInfinity$3 = toIntegerOrInfinity$4;\n\nvar max$2 = Math.max;\nvar min$2 = Math.min;\n\n// Helper for a popular repeating case of the spec:\n// Let integer be ? ToInteger(index).\n// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).\nvar toAbsoluteIndex$2 = function (index, length) {\n  var integer = toIntegerOrInfinity$3(index);\n  return integer < 0 ? max$2(integer + length, 0) : min$2(integer, length);\n};\n\nvar toIntegerOrInfinity$2 = toIntegerOrInfinity$4;\n\nvar min$1 = Math.min;\n\n// `ToLength` abstract operation\n// https://tc39.es/ecma262/#sec-tolength\nvar toLength$2 = function (argument) {\n  return argument > 0 ? min$1(toIntegerOrInfinity$2(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n};\n\nvar toLength$1 = toLength$2;\n\n// `LengthOfArrayLike` abstract operation\n// https://tc39.es/ecma262/#sec-lengthofarraylike\nvar lengthOfArrayLike$4 = function (obj) {\n  return toLength$1(obj.length);\n};\n\nvar toIndexedObject$3 = toIndexedObject$5;\nvar toAbsoluteIndex$1 = toAbsoluteIndex$2;\nvar lengthOfArrayLike$3 = lengthOfArrayLike$4;\n\n// `Array.prototype.{ indexOf, includes }` methods implementation\nvar createMethod$1 = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIndexedObject$3($this);\n    var length = lengthOfArrayLike$3(O);\n    var index = toAbsoluteIndex$1(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare -- NaN check\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare -- NaN check\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) {\n      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\nvar arrayIncludes = {\n  // `Array.prototype.includes` method\n  // https://tc39.es/ecma262/#sec-array.prototype.includes\n  includes: createMethod$1(true),\n  // `Array.prototype.indexOf` method\n  // https://tc39.es/ecma262/#sec-array.prototype.indexof\n  indexOf: createMethod$1(false)\n};\n\nvar uncurryThis$e = functionUncurryThis;\nvar hasOwn$7 = hasOwnProperty_1;\nvar toIndexedObject$2 = toIndexedObject$5;\nvar indexOf$1 = arrayIncludes.indexOf;\nvar hiddenKeys$2 = hiddenKeys$4;\n\nvar push$4 = uncurryThis$e([].push);\n\nvar objectKeysInternal = function (object, names) {\n  var O = toIndexedObject$2(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) !hasOwn$7(hiddenKeys$2, key) && hasOwn$7(O, key) && push$4(result, key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (hasOwn$7(O, key = names[i++])) {\n    ~indexOf$1(result, key) || push$4(result, key);\n  }\n  return result;\n};\n\n// IE8- don't enum bug keys\nvar enumBugKeys$3 = [\n  'constructor',\n  'hasOwnProperty',\n  'isPrototypeOf',\n  'propertyIsEnumerable',\n  'toLocaleString',\n  'toString',\n  'valueOf'\n];\n\nvar internalObjectKeys$1 = objectKeysInternal;\nvar enumBugKeys$2 = enumBugKeys$3;\n\nvar hiddenKeys$1 = enumBugKeys$2.concat('length', 'prototype');\n\n// `Object.getOwnPropertyNames` method\n// https://tc39.es/ecma262/#sec-object.getownpropertynames\n// eslint-disable-next-line es-x/no-object-getownpropertynames -- safe\nobjectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return internalObjectKeys$1(O, hiddenKeys$1);\n};\n\nvar objectGetOwnPropertySymbols = {};\n\n// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- safe\nobjectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;\n\nvar getBuiltIn$5 = getBuiltIn$8;\nvar uncurryThis$d = functionUncurryThis;\nvar getOwnPropertyNamesModule = objectGetOwnPropertyNames;\nvar getOwnPropertySymbolsModule$1 = objectGetOwnPropertySymbols;\nvar anObject$e = anObject$g;\n\nvar concat$2 = uncurryThis$d([].concat);\n\n// all object keys, includes non-enumerable and symbols\nvar ownKeys$1 = getBuiltIn$5('Reflect', 'ownKeys') || function ownKeys(it) {\n  var keys = getOwnPropertyNamesModule.f(anObject$e(it));\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule$1.f;\n  return getOwnPropertySymbols ? concat$2(keys, getOwnPropertySymbols(it)) : keys;\n};\n\nvar hasOwn$6 = hasOwnProperty_1;\nvar ownKeys = ownKeys$1;\nvar getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;\nvar definePropertyModule$3 = objectDefineProperty;\n\nvar copyConstructorProperties$1 = function (target, source, exceptions) {\n  var keys = ownKeys(source);\n  var defineProperty = definePropertyModule$3.f;\n  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    if (!hasOwn$6(target, key) && !(exceptions && hasOwn$6(exceptions, key))) {\n      defineProperty(target, key, getOwnPropertyDescriptor(source, key));\n    }\n  }\n};\n\nvar fails$c = fails$k;\nvar isCallable$d = isCallable$n;\n\nvar replacement = /#|\\.prototype\\./;\n\nvar isForced$2 = function (feature, detection) {\n  var value = data[normalize(feature)];\n  return value == POLYFILL ? true\n    : value == NATIVE ? false\n    : isCallable$d(detection) ? fails$c(detection)\n    : !!detection;\n};\n\nvar normalize = isForced$2.normalize = function (string) {\n  return String(string).replace(replacement, '.').toLowerCase();\n};\n\nvar data = isForced$2.data = {};\nvar NATIVE = isForced$2.NATIVE = 'N';\nvar POLYFILL = isForced$2.POLYFILL = 'P';\n\nvar isForced_1 = isForced$2;\n\nvar global$f = global$o;\nvar getOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;\nvar createNonEnumerableProperty$3 = createNonEnumerableProperty$5;\nvar defineBuiltIn$9 = defineBuiltIn$a;\nvar defineGlobalProperty = defineGlobalProperty$3;\nvar copyConstructorProperties = copyConstructorProperties$1;\nvar isForced$1 = isForced_1;\n\n/*\n  options.target         - name of the target object\n  options.global         - target is the global object\n  options.stat           - export as static methods of target\n  options.proto          - export as prototype methods of target\n  options.real           - real prototype method for the `pure` version\n  options.forced         - export even if the native feature is available\n  options.bind           - bind methods to the target, required for the `pure` version\n  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version\n  options.unsafe         - use the simple assignment of property instead of delete + defineProperty\n  options.sham           - add a flag to not completely full polyfills\n  options.enumerable     - export as enumerable property\n  options.dontCallGetSet - prevent calling a getter on target\n  options.name           - the .name of the function if it does not match the key\n*/\nvar _export = function (options, source) {\n  var TARGET = options.target;\n  var GLOBAL = options.global;\n  var STATIC = options.stat;\n  var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n  if (GLOBAL) {\n    target = global$f;\n  } else if (STATIC) {\n    target = global$f[TARGET] || defineGlobalProperty(TARGET, {});\n  } else {\n    target = (global$f[TARGET] || {}).prototype;\n  }\n  if (target) for (key in source) {\n    sourceProperty = source[key];\n    if (options.dontCallGetSet) {\n      descriptor = getOwnPropertyDescriptor$2(target, key);\n      targetProperty = descriptor && descriptor.value;\n    } else targetProperty = target[key];\n    FORCED = isForced$1(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);\n    // contained in target\n    if (!FORCED && targetProperty !== undefined) {\n      if (typeof sourceProperty == typeof targetProperty) continue;\n      copyConstructorProperties(sourceProperty, targetProperty);\n    }\n    // add a flag to not completely full polyfills\n    if (options.sham || (targetProperty && targetProperty.sham)) {\n      createNonEnumerableProperty$3(sourceProperty, 'sham', true);\n    }\n    defineBuiltIn$9(target, key, sourceProperty, options);\n  }\n};\n\nvar internalObjectKeys = objectKeysInternal;\nvar enumBugKeys$1 = enumBugKeys$3;\n\n// `Object.keys` method\n// https://tc39.es/ecma262/#sec-object.keys\n// eslint-disable-next-line es-x/no-object-keys -- safe\nvar objectKeys$2 = Object.keys || function keys(O) {\n  return internalObjectKeys(O, enumBugKeys$1);\n};\n\nvar DESCRIPTORS$5 = descriptors;\nvar uncurryThis$c = functionUncurryThis;\nvar call$f = functionCall;\nvar fails$b = fails$k;\nvar objectKeys$1 = objectKeys$2;\nvar getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;\nvar propertyIsEnumerableModule = objectPropertyIsEnumerable;\nvar toObject$3 = toObject$5;\nvar IndexedObject = indexedObject;\n\n// eslint-disable-next-line es-x/no-object-assign -- safe\nvar $assign = Object.assign;\n// eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\nvar defineProperty$4 = Object.defineProperty;\nvar concat$1 = uncurryThis$c([].concat);\n\n// `Object.assign` method\n// https://tc39.es/ecma262/#sec-object.assign\nvar objectAssign = !$assign || fails$b(function () {\n  // should have correct order of operations (Edge bug)\n  if (DESCRIPTORS$5 && $assign({ b: 1 }, $assign(defineProperty$4({}, 'a', {\n    enumerable: true,\n    get: function () {\n      defineProperty$4(this, 'b', {\n        value: 3,\n        enumerable: false\n      });\n    }\n  }), { b: 2 })).b !== 1) return true;\n  // should work with symbols and should have deterministic property order (V8 bug)\n  var A = {};\n  var B = {};\n  // eslint-disable-next-line es-x/no-symbol -- safe\n  var symbol = Symbol();\n  var alphabet = 'abcdefghijklmnopqrst';\n  A[symbol] = 7;\n  alphabet.split('').forEach(function (chr) { B[chr] = chr; });\n  return $assign({}, A)[symbol] != 7 || objectKeys$1($assign({}, B)).join('') != alphabet;\n}) ? function assign(target, source) { // eslint-disable-line no-unused-vars -- required for `.length`\n  var T = toObject$3(target);\n  var argumentsLength = arguments.length;\n  var index = 1;\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n  var propertyIsEnumerable = propertyIsEnumerableModule.f;\n  while (argumentsLength > index) {\n    var S = IndexedObject(arguments[index++]);\n    var keys = getOwnPropertySymbols ? concat$1(objectKeys$1(S), getOwnPropertySymbols(S)) : objectKeys$1(S);\n    var length = keys.length;\n    var j = 0;\n    var key;\n    while (length > j) {\n      key = keys[j++];\n      if (!DESCRIPTORS$5 || call$f(propertyIsEnumerable, S, key)) T[key] = S[key];\n    }\n  } return T;\n} : $assign;\n\nvar $$a = _export;\nvar assign$1 = objectAssign;\n\n// `Object.assign` method\n// https://tc39.es/ecma262/#sec-object.assign\n// eslint-disable-next-line es-x/no-object-assign -- required for testing\n$$a({ target: 'Object', stat: true, arity: 2, forced: Object.assign !== assign$1 }, {\n  assign: assign$1\n});\n\nvar wellKnownSymbol$g = wellKnownSymbol$i;\n\nvar TO_STRING_TAG$3 = wellKnownSymbol$g('toStringTag');\nvar test = {};\n\ntest[TO_STRING_TAG$3] = 'z';\n\nvar toStringTagSupport = String(test) === '[object z]';\n\nvar TO_STRING_TAG_SUPPORT = toStringTagSupport;\nvar isCallable$c = isCallable$n;\nvar classofRaw = classofRaw$1;\nvar wellKnownSymbol$f = wellKnownSymbol$i;\n\nvar TO_STRING_TAG$2 = wellKnownSymbol$f('toStringTag');\nvar $Object$1 = Object;\n\n// ES3 wrong here\nvar CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function (it, key) {\n  try {\n    return it[key];\n  } catch (error) { /* empty */ }\n};\n\n// getting tag from ES6+ `Object.prototype.toString`\nvar classof$6 = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {\n  var O, tag, result;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (tag = tryGet(O = $Object$1(it), TO_STRING_TAG$2)) == 'string' ? tag\n    // builtinTag case\n    : CORRECT_ARGUMENTS ? classofRaw(O)\n    // ES3 arguments fallback\n    : (result = classofRaw(O)) == 'Object' && isCallable$c(O.callee) ? 'Arguments' : result;\n};\n\nvar classof$5 = classof$6;\n\nvar $String$1 = String;\n\nvar toString$4 = function (argument) {\n  if (classof$5(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');\n  return $String$1(argument);\n};\n\nvar anObject$d = anObject$g;\n\n// `RegExp.prototype.flags` getter implementation\n// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags\nvar regexpFlags$1 = function () {\n  var that = anObject$d(this);\n  var result = '';\n  if (that.hasIndices) result += 'd';\n  if (that.global) result += 'g';\n  if (that.ignoreCase) result += 'i';\n  if (that.multiline) result += 'm';\n  if (that.dotAll) result += 's';\n  if (that.unicode) result += 'u';\n  if (that.unicodeSets) result += 'v';\n  if (that.sticky) result += 'y';\n  return result;\n};\n\nvar call$e = functionCall;\nvar hasOwn$5 = hasOwnProperty_1;\nvar isPrototypeOf$2 = objectIsPrototypeOf;\nvar regExpFlags = regexpFlags$1;\n\nvar RegExpPrototype$2 = RegExp.prototype;\n\nvar regexpGetFlags = function (R) {\n  var flags = R.flags;\n  return flags === undefined && !('flags' in RegExpPrototype$2) && !hasOwn$5(R, 'flags') && isPrototypeOf$2(RegExpPrototype$2, R)\n    ? call$e(regExpFlags, R) : flags;\n};\n\nvar PROPER_FUNCTION_NAME$1 = functionName.PROPER;\nvar defineBuiltIn$8 = defineBuiltIn$a;\nvar anObject$c = anObject$g;\nvar $toString$2 = toString$4;\nvar fails$a = fails$k;\nvar getRegExpFlags = regexpGetFlags;\n\nvar TO_STRING = 'toString';\nvar RegExpPrototype$1 = RegExp.prototype;\nvar n$ToString = RegExpPrototype$1[TO_STRING];\n\nvar NOT_GENERIC = fails$a(function () { return n$ToString.call({ source: 'a', flags: 'b' }) != '/a/b'; });\n// FF44- RegExp#toString has a wrong name\nvar INCORRECT_NAME = PROPER_FUNCTION_NAME$1 && n$ToString.name != TO_STRING;\n\n// `RegExp.prototype.toString` method\n// https://tc39.es/ecma262/#sec-regexp.prototype.tostring\nif (NOT_GENERIC || INCORRECT_NAME) {\n  defineBuiltIn$8(RegExp.prototype, TO_STRING, function toString() {\n    var R = anObject$c(this);\n    var pattern = $toString$2(R.source);\n    var flags = $toString$2(getRegExpFlags(R));\n    return '/' + pattern + '/' + flags;\n  }, { unsafe: true });\n}\n\nvar objectDefineProperties = {};\n\nvar DESCRIPTORS$4 = descriptors;\nvar V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;\nvar definePropertyModule$2 = objectDefineProperty;\nvar anObject$b = anObject$g;\nvar toIndexedObject$1 = toIndexedObject$5;\nvar objectKeys = objectKeys$2;\n\n// `Object.defineProperties` method\n// https://tc39.es/ecma262/#sec-object.defineproperties\n// eslint-disable-next-line es-x/no-object-defineproperties -- safe\nobjectDefineProperties.f = DESCRIPTORS$4 && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {\n  anObject$b(O);\n  var props = toIndexedObject$1(Properties);\n  var keys = objectKeys(Properties);\n  var length = keys.length;\n  var index = 0;\n  var key;\n  while (length > index) definePropertyModule$2.f(O, key = keys[index++], props[key]);\n  return O;\n};\n\nvar getBuiltIn$4 = getBuiltIn$8;\n\nvar html$2 = getBuiltIn$4('document', 'documentElement');\n\n/* global ActiveXObject -- old IE, WSH */\n\nvar anObject$a = anObject$g;\nvar definePropertiesModule = objectDefineProperties;\nvar enumBugKeys = enumBugKeys$3;\nvar hiddenKeys = hiddenKeys$4;\nvar html$1 = html$2;\nvar documentCreateElement$1 = documentCreateElement$2;\nvar sharedKey$1 = sharedKey$3;\n\nvar GT = '>';\nvar LT = '<';\nvar PROTOTYPE = 'prototype';\nvar SCRIPT = 'script';\nvar IE_PROTO$1 = sharedKey$1('IE_PROTO');\n\nvar EmptyConstructor = function () { /* empty */ };\n\nvar scriptTag = function (content) {\n  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;\n};\n\n// Create object with fake `null` prototype: use ActiveX Object with cleared prototype\nvar NullProtoObjectViaActiveX = function (activeXDocument) {\n  activeXDocument.write(scriptTag(''));\n  activeXDocument.close();\n  var temp = activeXDocument.parentWindow.Object;\n  activeXDocument = null; // avoid memory leak\n  return temp;\n};\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar NullProtoObjectViaIFrame = function () {\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = documentCreateElement$1('iframe');\n  var JS = 'java' + SCRIPT + ':';\n  var iframeDocument;\n  iframe.style.display = 'none';\n  html$1.appendChild(iframe);\n  // https://github.com/zloirock/core-js/issues/475\n  iframe.src = String(JS);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(scriptTag('document.F=Object'));\n  iframeDocument.close();\n  return iframeDocument.F;\n};\n\n// Check for document.domain and active x support\n// No need to use active x approach when document.domain is not set\n// see https://github.com/es-shims/es5-shim/issues/150\n// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346\n// avoid IE GC bug\nvar activeXDocument;\nvar NullProtoObject = function () {\n  try {\n    activeXDocument = new ActiveXObject('htmlfile');\n  } catch (error) { /* ignore */ }\n  NullProtoObject = typeof document != 'undefined'\n    ? document.domain && activeXDocument\n      ? NullProtoObjectViaActiveX(activeXDocument) // old IE\n      : NullProtoObjectViaIFrame()\n    : NullProtoObjectViaActiveX(activeXDocument); // WSH\n  var length = enumBugKeys.length;\n  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];\n  return NullProtoObject();\n};\n\nhiddenKeys[IE_PROTO$1] = true;\n\n// `Object.create` method\n// https://tc39.es/ecma262/#sec-object.create\n// eslint-disable-next-line es-x/no-object-create -- safe\nvar objectCreate = Object.create || function create(O, Properties) {\n  var result;\n  if (O !== null) {\n    EmptyConstructor[PROTOTYPE] = anObject$a(O);\n    result = new EmptyConstructor();\n    EmptyConstructor[PROTOTYPE] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO$1] = O;\n  } else result = NullProtoObject();\n  return Properties === undefined ? result : definePropertiesModule.f(result, Properties);\n};\n\nvar wellKnownSymbol$e = wellKnownSymbol$i;\nvar create$3 = objectCreate;\nvar defineProperty$3 = objectDefineProperty.f;\n\nvar UNSCOPABLES = wellKnownSymbol$e('unscopables');\nvar ArrayPrototype$1 = Array.prototype;\n\n// Array.prototype[@@unscopables]\n// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\nif (ArrayPrototype$1[UNSCOPABLES] == undefined) {\n  defineProperty$3(ArrayPrototype$1, UNSCOPABLES, {\n    configurable: true,\n    value: create$3(null)\n  });\n}\n\n// add a key to Array.prototype[@@unscopables]\nvar addToUnscopables$1 = function (key) {\n  ArrayPrototype$1[UNSCOPABLES][key] = true;\n};\n\nvar iterators = {};\n\nvar fails$9 = fails$k;\n\nvar correctPrototypeGetter = !fails$9(function () {\n  function F() { /* empty */ }\n  F.prototype.constructor = null;\n  // eslint-disable-next-line es-x/no-object-getprototypeof -- required for testing\n  return Object.getPrototypeOf(new F()) !== F.prototype;\n});\n\nvar hasOwn$4 = hasOwnProperty_1;\nvar isCallable$b = isCallable$n;\nvar toObject$2 = toObject$5;\nvar sharedKey = sharedKey$3;\nvar CORRECT_PROTOTYPE_GETTER = correctPrototypeGetter;\n\nvar IE_PROTO = sharedKey('IE_PROTO');\nvar $Object = Object;\nvar ObjectPrototype = $Object.prototype;\n\n// `Object.getPrototypeOf` method\n// https://tc39.es/ecma262/#sec-object.getprototypeof\n// eslint-disable-next-line es-x/no-object-getprototypeof -- safe\nvar objectGetPrototypeOf = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function (O) {\n  var object = toObject$2(O);\n  if (hasOwn$4(object, IE_PROTO)) return object[IE_PROTO];\n  var constructor = object.constructor;\n  if (isCallable$b(constructor) && object instanceof constructor) {\n    return constructor.prototype;\n  } return object instanceof $Object ? ObjectPrototype : null;\n};\n\nvar fails$8 = fails$k;\nvar isCallable$a = isCallable$n;\nvar getPrototypeOf$1 = objectGetPrototypeOf;\nvar defineBuiltIn$7 = defineBuiltIn$a;\nvar wellKnownSymbol$d = wellKnownSymbol$i;\n\nvar ITERATOR$7 = wellKnownSymbol$d('iterator');\nvar BUGGY_SAFARI_ITERATORS$1 = false;\n\n// `%IteratorPrototype%` object\n// https://tc39.es/ecma262/#sec-%iteratorprototype%-object\nvar IteratorPrototype$2, PrototypeOfArrayIteratorPrototype, arrayIterator;\n\n/* eslint-disable es-x/no-array-prototype-keys -- safe */\nif ([].keys) {\n  arrayIterator = [].keys();\n  // Safari 8 has buggy iterators w/o `next`\n  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS$1 = true;\n  else {\n    PrototypeOfArrayIteratorPrototype = getPrototypeOf$1(getPrototypeOf$1(arrayIterator));\n    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype$2 = PrototypeOfArrayIteratorPrototype;\n  }\n}\n\nvar NEW_ITERATOR_PROTOTYPE = IteratorPrototype$2 == undefined || fails$8(function () {\n  var test = {};\n  // FF44- legacy iterators case\n  return IteratorPrototype$2[ITERATOR$7].call(test) !== test;\n});\n\nif (NEW_ITERATOR_PROTOTYPE) IteratorPrototype$2 = {};\n\n// `%IteratorPrototype%[@@iterator]()` method\n// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator\nif (!isCallable$a(IteratorPrototype$2[ITERATOR$7])) {\n  defineBuiltIn$7(IteratorPrototype$2, ITERATOR$7, function () {\n    return this;\n  });\n}\n\nvar iteratorsCore = {\n  IteratorPrototype: IteratorPrototype$2,\n  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1\n};\n\nvar defineProperty$2 = objectDefineProperty.f;\nvar hasOwn$3 = hasOwnProperty_1;\nvar wellKnownSymbol$c = wellKnownSymbol$i;\n\nvar TO_STRING_TAG$1 = wellKnownSymbol$c('toStringTag');\n\nvar setToStringTag$5 = function (target, TAG, STATIC) {\n  if (target && !STATIC) target = target.prototype;\n  if (target && !hasOwn$3(target, TO_STRING_TAG$1)) {\n    defineProperty$2(target, TO_STRING_TAG$1, { configurable: true, value: TAG });\n  }\n};\n\nvar IteratorPrototype$1 = iteratorsCore.IteratorPrototype;\nvar create$2 = objectCreate;\nvar createPropertyDescriptor$2 = createPropertyDescriptor$5;\nvar setToStringTag$4 = setToStringTag$5;\nvar Iterators$4 = iterators;\n\nvar returnThis$1 = function () { return this; };\n\nvar createIteratorConstructor$2 = function (IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {\n  var TO_STRING_TAG = NAME + ' Iterator';\n  IteratorConstructor.prototype = create$2(IteratorPrototype$1, { next: createPropertyDescriptor$2(+!ENUMERABLE_NEXT, next) });\n  setToStringTag$4(IteratorConstructor, TO_STRING_TAG, false);\n  Iterators$4[TO_STRING_TAG] = returnThis$1;\n  return IteratorConstructor;\n};\n\nvar isCallable$9 = isCallable$n;\n\nvar $String = String;\nvar $TypeError$6 = TypeError;\n\nvar aPossiblePrototype$1 = function (argument) {\n  if (typeof argument == 'object' || isCallable$9(argument)) return argument;\n  throw $TypeError$6(\"Can't set \" + $String(argument) + ' as a prototype');\n};\n\n/* eslint-disable no-proto -- safe */\n\nvar uncurryThis$b = functionUncurryThis;\nvar anObject$9 = anObject$g;\nvar aPossiblePrototype = aPossiblePrototype$1;\n\n// `Object.setPrototypeOf` method\n// https://tc39.es/ecma262/#sec-object.setprototypeof\n// Works with __proto__ only. Old v8 can't work with null proto objects.\n// eslint-disable-next-line es-x/no-object-setprototypeof -- safe\nvar objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {\n  var CORRECT_SETTER = false;\n  var test = {};\n  var setter;\n  try {\n    // eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\n    setter = uncurryThis$b(Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set);\n    setter(test, []);\n    CORRECT_SETTER = test instanceof Array;\n  } catch (error) { /* empty */ }\n  return function setPrototypeOf(O, proto) {\n    anObject$9(O);\n    aPossiblePrototype(proto);\n    if (CORRECT_SETTER) setter(O, proto);\n    else O.__proto__ = proto;\n    return O;\n  };\n}() : undefined);\n\nvar $$9 = _export;\nvar call$d = functionCall;\nvar FunctionName = functionName;\nvar isCallable$8 = isCallable$n;\nvar createIteratorConstructor$1 = createIteratorConstructor$2;\nvar getPrototypeOf = objectGetPrototypeOf;\nvar setPrototypeOf$1 = objectSetPrototypeOf;\nvar setToStringTag$3 = setToStringTag$5;\nvar createNonEnumerableProperty$2 = createNonEnumerableProperty$5;\nvar defineBuiltIn$6 = defineBuiltIn$a;\nvar wellKnownSymbol$b = wellKnownSymbol$i;\nvar Iterators$3 = iterators;\nvar IteratorsCore = iteratorsCore;\n\nvar PROPER_FUNCTION_NAME = FunctionName.PROPER;\nvar CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;\nvar IteratorPrototype = IteratorsCore.IteratorPrototype;\nvar BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;\nvar ITERATOR$6 = wellKnownSymbol$b('iterator');\nvar KEYS = 'keys';\nvar VALUES = 'values';\nvar ENTRIES = 'entries';\n\nvar returnThis = function () { return this; };\n\nvar defineIterator$2 = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {\n  createIteratorConstructor$1(IteratorConstructor, NAME, next);\n\n  var getIterationMethod = function (KIND) {\n    if (KIND === DEFAULT && defaultIterator) return defaultIterator;\n    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];\n    switch (KIND) {\n      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };\n      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };\n      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };\n    } return function () { return new IteratorConstructor(this); };\n  };\n\n  var TO_STRING_TAG = NAME + ' Iterator';\n  var INCORRECT_VALUES_NAME = false;\n  var IterablePrototype = Iterable.prototype;\n  var nativeIterator = IterablePrototype[ITERATOR$6]\n    || IterablePrototype['@@iterator']\n    || DEFAULT && IterablePrototype[DEFAULT];\n  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);\n  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;\n  var CurrentIteratorPrototype, methods, KEY;\n\n  // fix native\n  if (anyNativeIterator) {\n    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));\n    if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {\n      if (getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {\n        if (setPrototypeOf$1) {\n          setPrototypeOf$1(CurrentIteratorPrototype, IteratorPrototype);\n        } else if (!isCallable$8(CurrentIteratorPrototype[ITERATOR$6])) {\n          defineBuiltIn$6(CurrentIteratorPrototype, ITERATOR$6, returnThis);\n        }\n      }\n      // Set @@toStringTag to native iterators\n      setToStringTag$3(CurrentIteratorPrototype, TO_STRING_TAG, true);\n    }\n  }\n\n  // fix Array.prototype.{ values, @@iterator }.name in V8 / FF\n  if (PROPER_FUNCTION_NAME && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {\n    if (CONFIGURABLE_FUNCTION_NAME) {\n      createNonEnumerableProperty$2(IterablePrototype, 'name', VALUES);\n    } else {\n      INCORRECT_VALUES_NAME = true;\n      defaultIterator = function values() { return call$d(nativeIterator, this); };\n    }\n  }\n\n  // export additional methods\n  if (DEFAULT) {\n    methods = {\n      values: getIterationMethod(VALUES),\n      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),\n      entries: getIterationMethod(ENTRIES)\n    };\n    if (FORCED) for (KEY in methods) {\n      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {\n        defineBuiltIn$6(IterablePrototype, KEY, methods[KEY]);\n      }\n    } else $$9({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);\n  }\n\n  // define iterator\n  if (IterablePrototype[ITERATOR$6] !== defaultIterator) {\n    defineBuiltIn$6(IterablePrototype, ITERATOR$6, defaultIterator, { name: DEFAULT });\n  }\n  Iterators$3[NAME] = defaultIterator;\n\n  return methods;\n};\n\nvar toIndexedObject = toIndexedObject$5;\nvar addToUnscopables = addToUnscopables$1;\nvar Iterators$2 = iterators;\nvar InternalStateModule$4 = internalState;\nvar defineProperty$1 = objectDefineProperty.f;\nvar defineIterator$1 = defineIterator$2;\nvar DESCRIPTORS$3 = descriptors;\n\nvar ARRAY_ITERATOR = 'Array Iterator';\nvar setInternalState$4 = InternalStateModule$4.set;\nvar getInternalState$2 = InternalStateModule$4.getterFor(ARRAY_ITERATOR);\n\n// `Array.prototype.entries` method\n// https://tc39.es/ecma262/#sec-array.prototype.entries\n// `Array.prototype.keys` method\n// https://tc39.es/ecma262/#sec-array.prototype.keys\n// `Array.prototype.values` method\n// https://tc39.es/ecma262/#sec-array.prototype.values\n// `Array.prototype[@@iterator]` method\n// https://tc39.es/ecma262/#sec-array.prototype-@@iterator\n// `CreateArrayIterator` internal method\n// https://tc39.es/ecma262/#sec-createarrayiterator\nvar es_array_iterator = defineIterator$1(Array, 'Array', function (iterated, kind) {\n  setInternalState$4(this, {\n    type: ARRAY_ITERATOR,\n    target: toIndexedObject(iterated), // target\n    index: 0,                          // next index\n    kind: kind                         // kind\n  });\n// `%ArrayIteratorPrototype%.next` method\n// https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next\n}, function () {\n  var state = getInternalState$2(this);\n  var target = state.target;\n  var kind = state.kind;\n  var index = state.index++;\n  if (!target || index >= target.length) {\n    state.target = undefined;\n    return { value: undefined, done: true };\n  }\n  if (kind == 'keys') return { value: index, done: false };\n  if (kind == 'values') return { value: target[index], done: false };\n  return { value: [index, target[index]], done: false };\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values%\n// https://tc39.es/ecma262/#sec-createunmappedargumentsobject\n// https://tc39.es/ecma262/#sec-createmappedargumentsobject\nvar values = Iterators$2.Arguments = Iterators$2.Array;\n\n// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\naddToUnscopables('keys');\naddToUnscopables('values');\naddToUnscopables('entries');\n\n// V8 ~ Chrome 45- bug\nif (DESCRIPTORS$3 && values.name !== 'values') try {\n  defineProperty$1(values, 'name', { value: 'values' });\n} catch (error) { /* empty */ }\n\nvar classof$4 = classofRaw$1;\nvar global$e = global$o;\n\nvar engineIsNode = classof$4(global$e.process) == 'process';\n\nvar getBuiltIn$3 = getBuiltIn$8;\nvar definePropertyModule$1 = objectDefineProperty;\nvar wellKnownSymbol$a = wellKnownSymbol$i;\nvar DESCRIPTORS$2 = descriptors;\n\nvar SPECIES$3 = wellKnownSymbol$a('species');\n\nvar setSpecies$1 = function (CONSTRUCTOR_NAME) {\n  var Constructor = getBuiltIn$3(CONSTRUCTOR_NAME);\n  var defineProperty = definePropertyModule$1.f;\n\n  if (DESCRIPTORS$2 && Constructor && !Constructor[SPECIES$3]) {\n    defineProperty(Constructor, SPECIES$3, {\n      configurable: true,\n      get: function () { return this; }\n    });\n  }\n};\n\nvar isPrototypeOf$1 = objectIsPrototypeOf;\n\nvar $TypeError$5 = TypeError;\n\nvar anInstance$3 = function (it, Prototype) {\n  if (isPrototypeOf$1(Prototype, it)) return it;\n  throw $TypeError$5('Incorrect invocation');\n};\n\nvar uncurryThis$a = functionUncurryThis;\nvar fails$7 = fails$k;\nvar isCallable$7 = isCallable$n;\nvar classof$3 = classof$6;\nvar getBuiltIn$2 = getBuiltIn$8;\nvar inspectSource$1 = inspectSource$4;\n\nvar noop = function () { /* empty */ };\nvar empty = [];\nvar construct = getBuiltIn$2('Reflect', 'construct');\nvar constructorRegExp = /^\\s*(?:class|function)\\b/;\nvar exec$3 = uncurryThis$a(constructorRegExp.exec);\nvar INCORRECT_TO_STRING = !constructorRegExp.exec(noop);\n\nvar isConstructorModern = function isConstructor(argument) {\n  if (!isCallable$7(argument)) return false;\n  try {\n    construct(noop, empty, argument);\n    return true;\n  } catch (error) {\n    return false;\n  }\n};\n\nvar isConstructorLegacy = function isConstructor(argument) {\n  if (!isCallable$7(argument)) return false;\n  switch (classof$3(argument)) {\n    case 'AsyncFunction':\n    case 'GeneratorFunction':\n    case 'AsyncGeneratorFunction': return false;\n  }\n  try {\n    // we can't check .prototype since constructors produced by .bind haven't it\n    // `Function#toString` throws on some built-it function in some legacy engines\n    // (for example, `DOMQuad` and similar in FF41-)\n    return INCORRECT_TO_STRING || !!exec$3(constructorRegExp, inspectSource$1(argument));\n  } catch (error) {\n    return true;\n  }\n};\n\nisConstructorLegacy.sham = true;\n\n// `IsConstructor` abstract operation\n// https://tc39.es/ecma262/#sec-isconstructor\nvar isConstructor$2 = !construct || fails$7(function () {\n  var called;\n  return isConstructorModern(isConstructorModern.call)\n    || !isConstructorModern(Object)\n    || !isConstructorModern(function () { called = true; })\n    || called;\n}) ? isConstructorLegacy : isConstructorModern;\n\nvar isConstructor$1 = isConstructor$2;\nvar tryToString$2 = tryToString$4;\n\nvar $TypeError$4 = TypeError;\n\n// `Assert: IsConstructor(argument) is true`\nvar aConstructor$1 = function (argument) {\n  if (isConstructor$1(argument)) return argument;\n  throw $TypeError$4(tryToString$2(argument) + ' is not a constructor');\n};\n\nvar anObject$8 = anObject$g;\nvar aConstructor = aConstructor$1;\nvar wellKnownSymbol$9 = wellKnownSymbol$i;\n\nvar SPECIES$2 = wellKnownSymbol$9('species');\n\n// `SpeciesConstructor` abstract operation\n// https://tc39.es/ecma262/#sec-speciesconstructor\nvar speciesConstructor$1 = function (O, defaultConstructor) {\n  var C = anObject$8(O).constructor;\n  var S;\n  return C === undefined || (S = anObject$8(C)[SPECIES$2]) == undefined ? defaultConstructor : aConstructor(S);\n};\n\nvar NATIVE_BIND$1 = functionBindNative;\n\nvar FunctionPrototype = Function.prototype;\nvar apply$2 = FunctionPrototype.apply;\nvar call$c = FunctionPrototype.call;\n\n// eslint-disable-next-line es-x/no-reflect -- safe\nvar functionApply = typeof Reflect == 'object' && Reflect.apply || (NATIVE_BIND$1 ? call$c.bind(apply$2) : function () {\n  return call$c.apply(apply$2, arguments);\n});\n\nvar uncurryThis$9 = functionUncurryThis;\nvar aCallable$5 = aCallable$7;\nvar NATIVE_BIND = functionBindNative;\n\nvar bind$7 = uncurryThis$9(uncurryThis$9.bind);\n\n// optional / simple context binding\nvar functionBindContext = function (fn, that) {\n  aCallable$5(fn);\n  return that === undefined ? fn : NATIVE_BIND ? bind$7(fn, that) : function (/* ...args */) {\n    return fn.apply(that, arguments);\n  };\n};\n\nvar uncurryThis$8 = functionUncurryThis;\n\nvar arraySlice$3 = uncurryThis$8([].slice);\n\nvar $TypeError$3 = TypeError;\n\nvar validateArgumentsLength$3 = function (passed, required) {\n  if (passed < required) throw $TypeError$3('Not enough arguments');\n  return passed;\n};\n\nvar userAgent$2 = engineUserAgent;\n\nvar engineIsIos = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent$2);\n\nvar global$d = global$o;\nvar apply$1 = functionApply;\nvar bind$6 = functionBindContext;\nvar isCallable$6 = isCallable$n;\nvar hasOwn$2 = hasOwnProperty_1;\nvar fails$6 = fails$k;\nvar html = html$2;\nvar arraySlice$2 = arraySlice$3;\nvar createElement = documentCreateElement$2;\nvar validateArgumentsLength$2 = validateArgumentsLength$3;\nvar IS_IOS$1 = engineIsIos;\nvar IS_NODE$2 = engineIsNode;\n\nvar set = global$d.setImmediate;\nvar clear = global$d.clearImmediate;\nvar process$2 = global$d.process;\nvar Dispatch = global$d.Dispatch;\nvar Function$1 = global$d.Function;\nvar MessageChannel = global$d.MessageChannel;\nvar String$1 = global$d.String;\nvar counter = 0;\nvar queue$1 = {};\nvar ONREADYSTATECHANGE = 'onreadystatechange';\nvar location, defer, channel, port;\n\ntry {\n  // Deno throws a ReferenceError on `location` access without `--location` flag\n  location = global$d.location;\n} catch (error) { /* empty */ }\n\nvar run = function (id) {\n  if (hasOwn$2(queue$1, id)) {\n    var fn = queue$1[id];\n    delete queue$1[id];\n    fn();\n  }\n};\n\nvar runner = function (id) {\n  return function () {\n    run(id);\n  };\n};\n\nvar listener = function (event) {\n  run(event.data);\n};\n\nvar post = function (id) {\n  // old engines have not location.origin\n  global$d.postMessage(String$1(id), location.protocol + '//' + location.host);\n};\n\n// Node.js 0.9+ & IE10+ has setImmediate, otherwise:\nif (!set || !clear) {\n  set = function setImmediate(handler) {\n    validateArgumentsLength$2(arguments.length, 1);\n    var fn = isCallable$6(handler) ? handler : Function$1(handler);\n    var args = arraySlice$2(arguments, 1);\n    queue$1[++counter] = function () {\n      apply$1(fn, undefined, args);\n    };\n    defer(counter);\n    return counter;\n  };\n  clear = function clearImmediate(id) {\n    delete queue$1[id];\n  };\n  // Node.js 0.8-\n  if (IS_NODE$2) {\n    defer = function (id) {\n      process$2.nextTick(runner(id));\n    };\n  // Sphere (JS game engine) Dispatch API\n  } else if (Dispatch && Dispatch.now) {\n    defer = function (id) {\n      Dispatch.now(runner(id));\n    };\n  // Browsers with MessageChannel, includes WebWorkers\n  // except iOS - https://github.com/zloirock/core-js/issues/624\n  } else if (MessageChannel && !IS_IOS$1) {\n    channel = new MessageChannel();\n    port = channel.port2;\n    channel.port1.onmessage = listener;\n    defer = bind$6(port.postMessage, port);\n  // Browsers with postMessage, skip WebWorkers\n  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'\n  } else if (\n    global$d.addEventListener &&\n    isCallable$6(global$d.postMessage) &&\n    !global$d.importScripts &&\n    location && location.protocol !== 'file:' &&\n    !fails$6(post)\n  ) {\n    defer = post;\n    global$d.addEventListener('message', listener, false);\n  // IE8-\n  } else if (ONREADYSTATECHANGE in createElement('script')) {\n    defer = function (id) {\n      html.appendChild(createElement('script'))[ONREADYSTATECHANGE] = function () {\n        html.removeChild(this);\n        run(id);\n      };\n    };\n  // Rest old browsers\n  } else {\n    defer = function (id) {\n      setTimeout(runner(id), 0);\n    };\n  }\n}\n\nvar task$1 = {\n  set: set,\n  clear: clear\n};\n\nvar userAgent$1 = engineUserAgent;\nvar global$c = global$o;\n\nvar engineIsIosPebble = /ipad|iphone|ipod/i.test(userAgent$1) && global$c.Pebble !== undefined;\n\nvar userAgent = engineUserAgent;\n\nvar engineIsWebosWebkit = /web0s(?!.*chrome)/i.test(userAgent);\n\nvar global$b = global$o;\nvar bind$5 = functionBindContext;\nvar getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;\nvar macrotask = task$1.set;\nvar IS_IOS = engineIsIos;\nvar IS_IOS_PEBBLE = engineIsIosPebble;\nvar IS_WEBOS_WEBKIT = engineIsWebosWebkit;\nvar IS_NODE$1 = engineIsNode;\n\nvar MutationObserver = global$b.MutationObserver || global$b.WebKitMutationObserver;\nvar document$2 = global$b.document;\nvar process$1 = global$b.process;\nvar Promise$1 = global$b.Promise;\n// Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`\nvar queueMicrotaskDescriptor = getOwnPropertyDescriptor$1(global$b, 'queueMicrotask');\nvar queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;\n\nvar flush, head, last, notify$1, toggle, node, promise, then;\n\n// modern engines have queueMicrotask method\nif (!queueMicrotask) {\n  flush = function () {\n    var parent, fn;\n    if (IS_NODE$1 && (parent = process$1.domain)) parent.exit();\n    while (head) {\n      fn = head.fn;\n      head = head.next;\n      try {\n        fn();\n      } catch (error) {\n        if (head) notify$1();\n        else last = undefined;\n        throw error;\n      }\n    } last = undefined;\n    if (parent) parent.enter();\n  };\n\n  // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339\n  // also except WebOS Webkit https://github.com/zloirock/core-js/issues/898\n  if (!IS_IOS && !IS_NODE$1 && !IS_WEBOS_WEBKIT && MutationObserver && document$2) {\n    toggle = true;\n    node = document$2.createTextNode('');\n    new MutationObserver(flush).observe(node, { characterData: true });\n    notify$1 = function () {\n      node.data = toggle = !toggle;\n    };\n  // environments with maybe non-completely correct, but existent Promise\n  } else if (!IS_IOS_PEBBLE && Promise$1 && Promise$1.resolve) {\n    // Promise.resolve without an argument throws an error in LG WebOS 2\n    promise = Promise$1.resolve(undefined);\n    // workaround of WebKit ~ iOS Safari 10.1 bug\n    promise.constructor = Promise$1;\n    then = bind$5(promise.then, promise);\n    notify$1 = function () {\n      then(flush);\n    };\n  // Node.js without promises\n  } else if (IS_NODE$1) {\n    notify$1 = function () {\n      process$1.nextTick(flush);\n    };\n  // for other environments - macrotask based on:\n  // - setImmediate\n  // - MessageChannel\n  // - window.postMessage\n  // - onreadystatechange\n  // - setTimeout\n  } else {\n    // strange IE + webpack dev server bug - use .bind(global)\n    macrotask = bind$5(macrotask, global$b);\n    notify$1 = function () {\n      macrotask(flush);\n    };\n  }\n}\n\nvar microtask$1 = queueMicrotask || function (fn) {\n  var task = { fn: fn, next: undefined };\n  if (last) last.next = task;\n  if (!head) {\n    head = task;\n    notify$1();\n  } last = task;\n};\n\nvar global$a = global$o;\n\nvar hostReportErrors$1 = function (a, b) {\n  var console = global$a.console;\n  if (console && console.error) {\n    arguments.length == 1 ? console.error(a) : console.error(a, b);\n  }\n};\n\nvar perform$3 = function (exec) {\n  try {\n    return { error: false, value: exec() };\n  } catch (error) {\n    return { error: true, value: error };\n  }\n};\n\nvar Queue$1 = function () {\n  this.head = null;\n  this.tail = null;\n};\n\nQueue$1.prototype = {\n  add: function (item) {\n    var entry = { item: item, next: null };\n    if (this.head) this.tail.next = entry;\n    else this.head = entry;\n    this.tail = entry;\n  },\n  get: function () {\n    var entry = this.head;\n    if (entry) {\n      this.head = entry.next;\n      if (this.tail === entry) this.tail = null;\n      return entry.item;\n    }\n  }\n};\n\nvar queue = Queue$1;\n\nvar global$9 = global$o;\n\nvar promiseNativeConstructor = global$9.Promise;\n\nvar engineIsBrowser = typeof window == 'object' && typeof Deno != 'object';\n\nvar global$8 = global$o;\nvar NativePromiseConstructor$3 = promiseNativeConstructor;\nvar isCallable$5 = isCallable$n;\nvar isForced = isForced_1;\nvar inspectSource = inspectSource$4;\nvar wellKnownSymbol$8 = wellKnownSymbol$i;\nvar IS_BROWSER = engineIsBrowser;\nvar V8_VERSION = engineV8Version;\n\nNativePromiseConstructor$3 && NativePromiseConstructor$3.prototype;\nvar SPECIES$1 = wellKnownSymbol$8('species');\nvar SUBCLASSING = false;\nvar NATIVE_PROMISE_REJECTION_EVENT$1 = isCallable$5(global$8.PromiseRejectionEvent);\n\nvar FORCED_PROMISE_CONSTRUCTOR$5 = isForced('Promise', function () {\n  var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(NativePromiseConstructor$3);\n  var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(NativePromiseConstructor$3);\n  // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=830565\n  // We can't detect it synchronously, so just check versions\n  if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66) return true;\n  // We can't use @@species feature detection in V8 since it causes\n  // deoptimization and performance degradation\n  // https://github.com/zloirock/core-js/issues/679\n  if (V8_VERSION >= 51 && /native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) return false;\n  // Detect correctness of subclassing with @@species support\n  var promise = new NativePromiseConstructor$3(function (resolve) { resolve(1); });\n  var FakePromise = function (exec) {\n    exec(function () { /* empty */ }, function () { /* empty */ });\n  };\n  var constructor = promise.constructor = {};\n  constructor[SPECIES$1] = FakePromise;\n  SUBCLASSING = promise.then(function () { /* empty */ }) instanceof FakePromise;\n  if (!SUBCLASSING) return true;\n  // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test\n  return !GLOBAL_CORE_JS_PROMISE && IS_BROWSER && !NATIVE_PROMISE_REJECTION_EVENT$1;\n});\n\nvar promiseConstructorDetection = {\n  CONSTRUCTOR: FORCED_PROMISE_CONSTRUCTOR$5,\n  REJECTION_EVENT: NATIVE_PROMISE_REJECTION_EVENT$1,\n  SUBCLASSING: SUBCLASSING\n};\n\nvar newPromiseCapability$2 = {};\n\nvar aCallable$4 = aCallable$7;\n\nvar PromiseCapability = function (C) {\n  var resolve, reject;\n  this.promise = new C(function ($$resolve, $$reject) {\n    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');\n    resolve = $$resolve;\n    reject = $$reject;\n  });\n  this.resolve = aCallable$4(resolve);\n  this.reject = aCallable$4(reject);\n};\n\n// `NewPromiseCapability` abstract operation\n// https://tc39.es/ecma262/#sec-newpromisecapability\nnewPromiseCapability$2.f = function (C) {\n  return new PromiseCapability(C);\n};\n\nvar $$8 = _export;\nvar IS_NODE = engineIsNode;\nvar global$7 = global$o;\nvar call$b = functionCall;\nvar defineBuiltIn$5 = defineBuiltIn$a;\nvar setPrototypeOf = objectSetPrototypeOf;\nvar setToStringTag$2 = setToStringTag$5;\nvar setSpecies = setSpecies$1;\nvar aCallable$3 = aCallable$7;\nvar isCallable$4 = isCallable$n;\nvar isObject$2 = isObject$8;\nvar anInstance$2 = anInstance$3;\nvar speciesConstructor = speciesConstructor$1;\nvar task = task$1.set;\nvar microtask = microtask$1;\nvar hostReportErrors = hostReportErrors$1;\nvar perform$2 = perform$3;\nvar Queue = queue;\nvar InternalStateModule$3 = internalState;\nvar NativePromiseConstructor$2 = promiseNativeConstructor;\nvar PromiseConstructorDetection = promiseConstructorDetection;\nvar newPromiseCapabilityModule$3 = newPromiseCapability$2;\n\nvar PROMISE = 'Promise';\nvar FORCED_PROMISE_CONSTRUCTOR$4 = PromiseConstructorDetection.CONSTRUCTOR;\nvar NATIVE_PROMISE_REJECTION_EVENT = PromiseConstructorDetection.REJECTION_EVENT;\nvar NATIVE_PROMISE_SUBCLASSING = PromiseConstructorDetection.SUBCLASSING;\nvar getInternalPromiseState = InternalStateModule$3.getterFor(PROMISE);\nvar setInternalState$3 = InternalStateModule$3.set;\nvar NativePromisePrototype$1 = NativePromiseConstructor$2 && NativePromiseConstructor$2.prototype;\nvar PromiseConstructor = NativePromiseConstructor$2;\nvar PromisePrototype = NativePromisePrototype$1;\nvar TypeError$3 = global$7.TypeError;\nvar document$1 = global$7.document;\nvar process = global$7.process;\nvar newPromiseCapability$1 = newPromiseCapabilityModule$3.f;\nvar newGenericPromiseCapability = newPromiseCapability$1;\n\nvar DISPATCH_EVENT = !!(document$1 && document$1.createEvent && global$7.dispatchEvent);\nvar UNHANDLED_REJECTION = 'unhandledrejection';\nvar REJECTION_HANDLED = 'rejectionhandled';\nvar PENDING = 0;\nvar FULFILLED = 1;\nvar REJECTED = 2;\nvar HANDLED = 1;\nvar UNHANDLED = 2;\n\nvar Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;\n\n// helpers\nvar isThenable = function (it) {\n  var then;\n  return isObject$2(it) && isCallable$4(then = it.then) ? then : false;\n};\n\nvar callReaction = function (reaction, state) {\n  var value = state.value;\n  var ok = state.state == FULFILLED;\n  var handler = ok ? reaction.ok : reaction.fail;\n  var resolve = reaction.resolve;\n  var reject = reaction.reject;\n  var domain = reaction.domain;\n  var result, then, exited;\n  try {\n    if (handler) {\n      if (!ok) {\n        if (state.rejection === UNHANDLED) onHandleUnhandled(state);\n        state.rejection = HANDLED;\n      }\n      if (handler === true) result = value;\n      else {\n        if (domain) domain.enter();\n        result = handler(value); // can throw\n        if (domain) {\n          domain.exit();\n          exited = true;\n        }\n      }\n      if (result === reaction.promise) {\n        reject(TypeError$3('Promise-chain cycle'));\n      } else if (then = isThenable(result)) {\n        call$b(then, result, resolve, reject);\n      } else resolve(result);\n    } else reject(value);\n  } catch (error) {\n    if (domain && !exited) domain.exit();\n    reject(error);\n  }\n};\n\nvar notify = function (state, isReject) {\n  if (state.notified) return;\n  state.notified = true;\n  microtask(function () {\n    var reactions = state.reactions;\n    var reaction;\n    while (reaction = reactions.get()) {\n      callReaction(reaction, state);\n    }\n    state.notified = false;\n    if (isReject && !state.rejection) onUnhandled(state);\n  });\n};\n\nvar dispatchEvent = function (name, promise, reason) {\n  var event, handler;\n  if (DISPATCH_EVENT) {\n    event = document$1.createEvent('Event');\n    event.promise = promise;\n    event.reason = reason;\n    event.initEvent(name, false, true);\n    global$7.dispatchEvent(event);\n  } else event = { promise: promise, reason: reason };\n  if (!NATIVE_PROMISE_REJECTION_EVENT && (handler = global$7['on' + name])) handler(event);\n  else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);\n};\n\nvar onUnhandled = function (state) {\n  call$b(task, global$7, function () {\n    var promise = state.facade;\n    var value = state.value;\n    var IS_UNHANDLED = isUnhandled(state);\n    var result;\n    if (IS_UNHANDLED) {\n      result = perform$2(function () {\n        if (IS_NODE) {\n          process.emit('unhandledRejection', value, promise);\n        } else dispatchEvent(UNHANDLED_REJECTION, promise, value);\n      });\n      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should\n      state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;\n      if (result.error) throw result.value;\n    }\n  });\n};\n\nvar isUnhandled = function (state) {\n  return state.rejection !== HANDLED && !state.parent;\n};\n\nvar onHandleUnhandled = function (state) {\n  call$b(task, global$7, function () {\n    var promise = state.facade;\n    if (IS_NODE) {\n      process.emit('rejectionHandled', promise);\n    } else dispatchEvent(REJECTION_HANDLED, promise, state.value);\n  });\n};\n\nvar bind$4 = function (fn, state, unwrap) {\n  return function (value) {\n    fn(state, value, unwrap);\n  };\n};\n\nvar internalReject = function (state, value, unwrap) {\n  if (state.done) return;\n  state.done = true;\n  if (unwrap) state = unwrap;\n  state.value = value;\n  state.state = REJECTED;\n  notify(state, true);\n};\n\nvar internalResolve = function (state, value, unwrap) {\n  if (state.done) return;\n  state.done = true;\n  if (unwrap) state = unwrap;\n  try {\n    if (state.facade === value) throw TypeError$3(\"Promise can't be resolved itself\");\n    var then = isThenable(value);\n    if (then) {\n      microtask(function () {\n        var wrapper = { done: false };\n        try {\n          call$b(then, value,\n            bind$4(internalResolve, wrapper, state),\n            bind$4(internalReject, wrapper, state)\n          );\n        } catch (error) {\n          internalReject(wrapper, error, state);\n        }\n      });\n    } else {\n      state.value = value;\n      state.state = FULFILLED;\n      notify(state, false);\n    }\n  } catch (error) {\n    internalReject({ done: false }, error, state);\n  }\n};\n\n// constructor polyfill\nif (FORCED_PROMISE_CONSTRUCTOR$4) {\n  // 25.4.3.1 Promise(executor)\n  PromiseConstructor = function Promise(executor) {\n    anInstance$2(this, PromisePrototype);\n    aCallable$3(executor);\n    call$b(Internal, this);\n    var state = getInternalPromiseState(this);\n    try {\n      executor(bind$4(internalResolve, state), bind$4(internalReject, state));\n    } catch (error) {\n      internalReject(state, error);\n    }\n  };\n\n  PromisePrototype = PromiseConstructor.prototype;\n\n  // eslint-disable-next-line no-unused-vars -- required for `.length`\n  Internal = function Promise(executor) {\n    setInternalState$3(this, {\n      type: PROMISE,\n      done: false,\n      notified: false,\n      parent: false,\n      reactions: new Queue(),\n      rejection: false,\n      state: PENDING,\n      value: undefined\n    });\n  };\n\n  // `Promise.prototype.then` method\n  // https://tc39.es/ecma262/#sec-promise.prototype.then\n  Internal.prototype = defineBuiltIn$5(PromisePrototype, 'then', function then(onFulfilled, onRejected) {\n    var state = getInternalPromiseState(this);\n    var reaction = newPromiseCapability$1(speciesConstructor(this, PromiseConstructor));\n    state.parent = true;\n    reaction.ok = isCallable$4(onFulfilled) ? onFulfilled : true;\n    reaction.fail = isCallable$4(onRejected) && onRejected;\n    reaction.domain = IS_NODE ? process.domain : undefined;\n    if (state.state == PENDING) state.reactions.add(reaction);\n    else microtask(function () {\n      callReaction(reaction, state);\n    });\n    return reaction.promise;\n  });\n\n  OwnPromiseCapability = function () {\n    var promise = new Internal();\n    var state = getInternalPromiseState(promise);\n    this.promise = promise;\n    this.resolve = bind$4(internalResolve, state);\n    this.reject = bind$4(internalReject, state);\n  };\n\n  newPromiseCapabilityModule$3.f = newPromiseCapability$1 = function (C) {\n    return C === PromiseConstructor || C === PromiseWrapper\n      ? new OwnPromiseCapability(C)\n      : newGenericPromiseCapability(C);\n  };\n\n  if (isCallable$4(NativePromiseConstructor$2) && NativePromisePrototype$1 !== Object.prototype) {\n    nativeThen = NativePromisePrototype$1.then;\n\n    if (!NATIVE_PROMISE_SUBCLASSING) {\n      // make `Promise#then` return a polyfilled `Promise` for native promise-based APIs\n      defineBuiltIn$5(NativePromisePrototype$1, 'then', function then(onFulfilled, onRejected) {\n        var that = this;\n        return new PromiseConstructor(function (resolve, reject) {\n          call$b(nativeThen, that, resolve, reject);\n        }).then(onFulfilled, onRejected);\n      // https://github.com/zloirock/core-js/issues/640\n      }, { unsafe: true });\n    }\n\n    // make `.constructor === Promise` work for native promise-based APIs\n    try {\n      delete NativePromisePrototype$1.constructor;\n    } catch (error) { /* empty */ }\n\n    // make `instanceof Promise` work for native promise-based APIs\n    if (setPrototypeOf) {\n      setPrototypeOf(NativePromisePrototype$1, PromisePrototype);\n    }\n  }\n}\n\n$$8({ global: true, constructor: true, wrap: true, forced: FORCED_PROMISE_CONSTRUCTOR$4 }, {\n  Promise: PromiseConstructor\n});\n\nsetToStringTag$2(PromiseConstructor, PROMISE, false);\nsetSpecies(PROMISE);\n\nvar wellKnownSymbol$7 = wellKnownSymbol$i;\nvar Iterators$1 = iterators;\n\nvar ITERATOR$5 = wellKnownSymbol$7('iterator');\nvar ArrayPrototype = Array.prototype;\n\n// check on default Array iterator\nvar isArrayIteratorMethod$2 = function (it) {\n  return it !== undefined && (Iterators$1.Array === it || ArrayPrototype[ITERATOR$5] === it);\n};\n\nvar classof$2 = classof$6;\nvar getMethod$2 = getMethod$4;\nvar Iterators = iterators;\nvar wellKnownSymbol$6 = wellKnownSymbol$i;\n\nvar ITERATOR$4 = wellKnownSymbol$6('iterator');\n\nvar getIteratorMethod$4 = function (it) {\n  if (it != undefined) return getMethod$2(it, ITERATOR$4)\n    || getMethod$2(it, '@@iterator')\n    || Iterators[classof$2(it)];\n};\n\nvar call$a = functionCall;\nvar aCallable$2 = aCallable$7;\nvar anObject$7 = anObject$g;\nvar tryToString$1 = tryToString$4;\nvar getIteratorMethod$3 = getIteratorMethod$4;\n\nvar $TypeError$2 = TypeError;\n\nvar getIterator$3 = function (argument, usingIterator) {\n  var iteratorMethod = arguments.length < 2 ? getIteratorMethod$3(argument) : usingIterator;\n  if (aCallable$2(iteratorMethod)) return anObject$7(call$a(iteratorMethod, argument));\n  throw $TypeError$2(tryToString$1(argument) + ' is not iterable');\n};\n\nvar call$9 = functionCall;\nvar anObject$6 = anObject$g;\nvar getMethod$1 = getMethod$4;\n\nvar iteratorClose$2 = function (iterator, kind, value) {\n  var innerResult, innerError;\n  anObject$6(iterator);\n  try {\n    innerResult = getMethod$1(iterator, 'return');\n    if (!innerResult) {\n      if (kind === 'throw') throw value;\n      return value;\n    }\n    innerResult = call$9(innerResult, iterator);\n  } catch (error) {\n    innerError = true;\n    innerResult = error;\n  }\n  if (kind === 'throw') throw value;\n  if (innerError) throw innerResult;\n  anObject$6(innerResult);\n  return value;\n};\n\nvar bind$3 = functionBindContext;\nvar call$8 = functionCall;\nvar anObject$5 = anObject$g;\nvar tryToString = tryToString$4;\nvar isArrayIteratorMethod$1 = isArrayIteratorMethod$2;\nvar lengthOfArrayLike$2 = lengthOfArrayLike$4;\nvar isPrototypeOf = objectIsPrototypeOf;\nvar getIterator$2 = getIterator$3;\nvar getIteratorMethod$2 = getIteratorMethod$4;\nvar iteratorClose$1 = iteratorClose$2;\n\nvar $TypeError$1 = TypeError;\n\nvar Result = function (stopped, result) {\n  this.stopped = stopped;\n  this.result = result;\n};\n\nvar ResultPrototype = Result.prototype;\n\nvar iterate$2 = function (iterable, unboundFunction, options) {\n  var that = options && options.that;\n  var AS_ENTRIES = !!(options && options.AS_ENTRIES);\n  var IS_ITERATOR = !!(options && options.IS_ITERATOR);\n  var INTERRUPTED = !!(options && options.INTERRUPTED);\n  var fn = bind$3(unboundFunction, that);\n  var iterator, iterFn, index, length, result, next, step;\n\n  var stop = function (condition) {\n    if (iterator) iteratorClose$1(iterator, 'normal', condition);\n    return new Result(true, condition);\n  };\n\n  var callFn = function (value) {\n    if (AS_ENTRIES) {\n      anObject$5(value);\n      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);\n    } return INTERRUPTED ? fn(value, stop) : fn(value);\n  };\n\n  if (IS_ITERATOR) {\n    iterator = iterable;\n  } else {\n    iterFn = getIteratorMethod$2(iterable);\n    if (!iterFn) throw $TypeError$1(tryToString(iterable) + ' is not iterable');\n    // optimisation for array iterators\n    if (isArrayIteratorMethod$1(iterFn)) {\n      for (index = 0, length = lengthOfArrayLike$2(iterable); length > index; index++) {\n        result = callFn(iterable[index]);\n        if (result && isPrototypeOf(ResultPrototype, result)) return result;\n      } return new Result(false);\n    }\n    iterator = getIterator$2(iterable, iterFn);\n  }\n\n  next = iterator.next;\n  while (!(step = call$8(next, iterator)).done) {\n    try {\n      result = callFn(step.value);\n    } catch (error) {\n      iteratorClose$1(iterator, 'throw', error);\n    }\n    if (typeof result == 'object' && result && isPrototypeOf(ResultPrototype, result)) return result;\n  } return new Result(false);\n};\n\nvar wellKnownSymbol$5 = wellKnownSymbol$i;\n\nvar ITERATOR$3 = wellKnownSymbol$5('iterator');\nvar SAFE_CLOSING = false;\n\ntry {\n  var called = 0;\n  var iteratorWithReturn = {\n    next: function () {\n      return { done: !!called++ };\n    },\n    'return': function () {\n      SAFE_CLOSING = true;\n    }\n  };\n  iteratorWithReturn[ITERATOR$3] = function () {\n    return this;\n  };\n  // eslint-disable-next-line es-x/no-array-from, no-throw-literal -- required for testing\n  Array.from(iteratorWithReturn, function () { throw 2; });\n} catch (error) { /* empty */ }\n\nvar checkCorrectnessOfIteration$1 = function (exec, SKIP_CLOSING) {\n  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;\n  var ITERATION_SUPPORT = false;\n  try {\n    var object = {};\n    object[ITERATOR$3] = function () {\n      return {\n        next: function () {\n          return { done: ITERATION_SUPPORT = true };\n        }\n      };\n    };\n    exec(object);\n  } catch (error) { /* empty */ }\n  return ITERATION_SUPPORT;\n};\n\nvar NativePromiseConstructor$1 = promiseNativeConstructor;\nvar checkCorrectnessOfIteration = checkCorrectnessOfIteration$1;\nvar FORCED_PROMISE_CONSTRUCTOR$3 = promiseConstructorDetection.CONSTRUCTOR;\n\nvar promiseStaticsIncorrectIteration = FORCED_PROMISE_CONSTRUCTOR$3 || !checkCorrectnessOfIteration(function (iterable) {\n  NativePromiseConstructor$1.all(iterable).then(undefined, function () { /* empty */ });\n});\n\nvar $$7 = _export;\nvar call$7 = functionCall;\nvar aCallable$1 = aCallable$7;\nvar newPromiseCapabilityModule$2 = newPromiseCapability$2;\nvar perform$1 = perform$3;\nvar iterate$1 = iterate$2;\nvar PROMISE_STATICS_INCORRECT_ITERATION$1 = promiseStaticsIncorrectIteration;\n\n// `Promise.all` method\n// https://tc39.es/ecma262/#sec-promise.all\n$$7({ target: 'Promise', stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION$1 }, {\n  all: function all(iterable) {\n    var C = this;\n    var capability = newPromiseCapabilityModule$2.f(C);\n    var resolve = capability.resolve;\n    var reject = capability.reject;\n    var result = perform$1(function () {\n      var $promiseResolve = aCallable$1(C.resolve);\n      var values = [];\n      var counter = 0;\n      var remaining = 1;\n      iterate$1(iterable, function (promise) {\n        var index = counter++;\n        var alreadyCalled = false;\n        remaining++;\n        call$7($promiseResolve, C, promise).then(function (value) {\n          if (alreadyCalled) return;\n          alreadyCalled = true;\n          values[index] = value;\n          --remaining || resolve(values);\n        }, reject);\n      });\n      --remaining || resolve(values);\n    });\n    if (result.error) reject(result.value);\n    return capability.promise;\n  }\n});\n\nvar $$6 = _export;\nvar FORCED_PROMISE_CONSTRUCTOR$2 = promiseConstructorDetection.CONSTRUCTOR;\nvar NativePromiseConstructor = promiseNativeConstructor;\nvar getBuiltIn$1 = getBuiltIn$8;\nvar isCallable$3 = isCallable$n;\nvar defineBuiltIn$4 = defineBuiltIn$a;\n\nvar NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;\n\n// `Promise.prototype.catch` method\n// https://tc39.es/ecma262/#sec-promise.prototype.catch\n$$6({ target: 'Promise', proto: true, forced: FORCED_PROMISE_CONSTRUCTOR$2, real: true }, {\n  'catch': function (onRejected) {\n    return this.then(undefined, onRejected);\n  }\n});\n\n// makes sure that native promise-based APIs `Promise#catch` properly works with patched `Promise#then`\nif (isCallable$3(NativePromiseConstructor)) {\n  var method = getBuiltIn$1('Promise').prototype['catch'];\n  if (NativePromisePrototype['catch'] !== method) {\n    defineBuiltIn$4(NativePromisePrototype, 'catch', method, { unsafe: true });\n  }\n}\n\nvar $$5 = _export;\nvar call$6 = functionCall;\nvar aCallable = aCallable$7;\nvar newPromiseCapabilityModule$1 = newPromiseCapability$2;\nvar perform = perform$3;\nvar iterate = iterate$2;\nvar PROMISE_STATICS_INCORRECT_ITERATION = promiseStaticsIncorrectIteration;\n\n// `Promise.race` method\n// https://tc39.es/ecma262/#sec-promise.race\n$$5({ target: 'Promise', stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {\n  race: function race(iterable) {\n    var C = this;\n    var capability = newPromiseCapabilityModule$1.f(C);\n    var reject = capability.reject;\n    var result = perform(function () {\n      var $promiseResolve = aCallable(C.resolve);\n      iterate(iterable, function (promise) {\n        call$6($promiseResolve, C, promise).then(capability.resolve, reject);\n      });\n    });\n    if (result.error) reject(result.value);\n    return capability.promise;\n  }\n});\n\nvar $$4 = _export;\nvar call$5 = functionCall;\nvar newPromiseCapabilityModule = newPromiseCapability$2;\nvar FORCED_PROMISE_CONSTRUCTOR$1 = promiseConstructorDetection.CONSTRUCTOR;\n\n// `Promise.reject` method\n// https://tc39.es/ecma262/#sec-promise.reject\n$$4({ target: 'Promise', stat: true, forced: FORCED_PROMISE_CONSTRUCTOR$1 }, {\n  reject: function reject(r) {\n    var capability = newPromiseCapabilityModule.f(this);\n    call$5(capability.reject, undefined, r);\n    return capability.promise;\n  }\n});\n\nvar anObject$4 = anObject$g;\nvar isObject$1 = isObject$8;\nvar newPromiseCapability = newPromiseCapability$2;\n\nvar promiseResolve$1 = function (C, x) {\n  anObject$4(C);\n  if (isObject$1(x) && x.constructor === C) return x;\n  var promiseCapability = newPromiseCapability.f(C);\n  var resolve = promiseCapability.resolve;\n  resolve(x);\n  return promiseCapability.promise;\n};\n\nvar $$3 = _export;\nvar getBuiltIn = getBuiltIn$8;\nvar FORCED_PROMISE_CONSTRUCTOR = promiseConstructorDetection.CONSTRUCTOR;\nvar promiseResolve = promiseResolve$1;\n\ngetBuiltIn('Promise');\n\n// `Promise.resolve` method\n// https://tc39.es/ecma262/#sec-promise.resolve\n$$3({ target: 'Promise', stat: true, forced: FORCED_PROMISE_CONSTRUCTOR }, {\n  resolve: function resolve(x) {\n    return promiseResolve(this, x);\n  }\n});\n\n// iterable DOM collections\n// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods\nvar domIterables = {\n  CSSRuleList: 0,\n  CSSStyleDeclaration: 0,\n  CSSValueList: 0,\n  ClientRectList: 0,\n  DOMRectList: 0,\n  DOMStringList: 0,\n  DOMTokenList: 1,\n  DataTransferItemList: 0,\n  FileList: 0,\n  HTMLAllCollection: 0,\n  HTMLCollection: 0,\n  HTMLFormElement: 0,\n  HTMLSelectElement: 0,\n  MediaList: 0,\n  MimeTypeArray: 0,\n  NamedNodeMap: 0,\n  NodeList: 1,\n  PaintRequestList: 0,\n  Plugin: 0,\n  PluginArray: 0,\n  SVGLengthList: 0,\n  SVGNumberList: 0,\n  SVGPathSegList: 0,\n  SVGPointList: 0,\n  SVGStringList: 0,\n  SVGTransformList: 0,\n  SourceBufferList: 0,\n  StyleSheetList: 0,\n  TextTrackCueList: 0,\n  TextTrackList: 0,\n  TouchList: 0\n};\n\n// in old WebKit versions, `element.classList` is not an instance of global `DOMTokenList`\nvar documentCreateElement = documentCreateElement$2;\n\nvar classList = documentCreateElement('span').classList;\nvar DOMTokenListPrototype$1 = classList && classList.constructor && classList.constructor.prototype;\n\nvar domTokenListPrototype = DOMTokenListPrototype$1 === Object.prototype ? undefined : DOMTokenListPrototype$1;\n\nvar global$6 = global$o;\nvar DOMIterables = domIterables;\nvar DOMTokenListPrototype = domTokenListPrototype;\nvar ArrayIteratorMethods = es_array_iterator;\nvar createNonEnumerableProperty$1 = createNonEnumerableProperty$5;\nvar wellKnownSymbol$4 = wellKnownSymbol$i;\n\nvar ITERATOR$2 = wellKnownSymbol$4('iterator');\nvar TO_STRING_TAG = wellKnownSymbol$4('toStringTag');\nvar ArrayValues = ArrayIteratorMethods.values;\n\nvar handlePrototype = function (CollectionPrototype, COLLECTION_NAME) {\n  if (CollectionPrototype) {\n    // some Chrome versions have non-configurable methods on DOMTokenList\n    if (CollectionPrototype[ITERATOR$2] !== ArrayValues) try {\n      createNonEnumerableProperty$1(CollectionPrototype, ITERATOR$2, ArrayValues);\n    } catch (error) {\n      CollectionPrototype[ITERATOR$2] = ArrayValues;\n    }\n    if (!CollectionPrototype[TO_STRING_TAG]) {\n      createNonEnumerableProperty$1(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);\n    }\n    if (DOMIterables[COLLECTION_NAME]) for (var METHOD_NAME in ArrayIteratorMethods) {\n      // some Chrome versions have non-configurable methods on DOMTokenList\n      if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {\n        createNonEnumerableProperty$1(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);\n      } catch (error) {\n        CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];\n      }\n    }\n  }\n};\n\nfor (var COLLECTION_NAME in DOMIterables) {\n  handlePrototype(global$6[COLLECTION_NAME] && global$6[COLLECTION_NAME].prototype, COLLECTION_NAME);\n}\n\nhandlePrototype(DOMTokenListPrototype, 'DOMTokenList');\n\nvar uncurryThis$7 = functionUncurryThis;\nvar toIntegerOrInfinity$1 = toIntegerOrInfinity$4;\nvar toString$3 = toString$4;\nvar requireObjectCoercible$1 = requireObjectCoercible$4;\n\nvar charAt$6 = uncurryThis$7(''.charAt);\nvar charCodeAt$1 = uncurryThis$7(''.charCodeAt);\nvar stringSlice$5 = uncurryThis$7(''.slice);\n\nvar createMethod = function (CONVERT_TO_STRING) {\n  return function ($this, pos) {\n    var S = toString$3(requireObjectCoercible$1($this));\n    var position = toIntegerOrInfinity$1(pos);\n    var size = S.length;\n    var first, second;\n    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;\n    first = charCodeAt$1(S, position);\n    return first < 0xD800 || first > 0xDBFF || position + 1 === size\n      || (second = charCodeAt$1(S, position + 1)) < 0xDC00 || second > 0xDFFF\n        ? CONVERT_TO_STRING\n          ? charAt$6(S, position)\n          : first\n        : CONVERT_TO_STRING\n          ? stringSlice$5(S, position, position + 2)\n          : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;\n  };\n};\n\nvar stringMultibyte = {\n  // `String.prototype.codePointAt` method\n  // https://tc39.es/ecma262/#sec-string.prototype.codepointat\n  codeAt: createMethod(false),\n  // `String.prototype.at` method\n  // https://github.com/mathiasbynens/String.prototype.at\n  charAt: createMethod(true)\n};\n\nvar charAt$5 = stringMultibyte.charAt;\nvar toString$2 = toString$4;\nvar InternalStateModule$2 = internalState;\nvar defineIterator = defineIterator$2;\n\nvar STRING_ITERATOR = 'String Iterator';\nvar setInternalState$2 = InternalStateModule$2.set;\nvar getInternalState$1 = InternalStateModule$2.getterFor(STRING_ITERATOR);\n\n// `String.prototype[@@iterator]` method\n// https://tc39.es/ecma262/#sec-string.prototype-@@iterator\ndefineIterator(String, 'String', function (iterated) {\n  setInternalState$2(this, {\n    type: STRING_ITERATOR,\n    string: toString$2(iterated),\n    index: 0\n  });\n// `%StringIteratorPrototype%.next` method\n// https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next\n}, function next() {\n  var state = getInternalState$1(this);\n  var string = state.string;\n  var index = state.index;\n  var point;\n  if (index >= string.length) return { value: undefined, done: true };\n  point = charAt$5(string, index);\n  state.index += point.length;\n  return { value: point, done: false };\n});\n\nvar fails$5 = fails$k;\nvar wellKnownSymbol$3 = wellKnownSymbol$i;\nvar IS_PURE = isPure;\n\nvar ITERATOR$1 = wellKnownSymbol$3('iterator');\n\nvar nativeUrl = !fails$5(function () {\n  // eslint-disable-next-line unicorn/relative-url-style -- required for testing\n  var url = new URL('b?a=1&b=2&c=3', 'http://a');\n  var searchParams = url.searchParams;\n  var result = '';\n  url.pathname = 'c%20d';\n  searchParams.forEach(function (value, key) {\n    searchParams['delete']('b');\n    result += key + value;\n  });\n  return (IS_PURE && !url.toJSON)\n    || !searchParams.sort\n    || url.href !== 'http://a/c%20d?a=1&c=3'\n    || searchParams.get('c') !== '3'\n    || String(new URLSearchParams('?a=1')) !== 'a=1'\n    || !searchParams[ITERATOR$1]\n    // throws in Edge\n    || new URL('https://a@b').username !== 'a'\n    || new URLSearchParams(new URLSearchParams('a=b')).get('a') !== 'b'\n    // not punycoded in Edge\n    || new URL('http://тест').host !== 'xn--e1aybc'\n    // not escaped in Chrome 62-\n    || new URL('http://a#б').hash !== '#%D0%B1'\n    // fails in Chrome 66-\n    || result !== 'a1c3'\n    // throws in Safari\n    || new URL('http://x', undefined).host !== 'x';\n});\n\nvar makeBuiltIn = makeBuiltIn$3.exports;\nvar defineProperty = objectDefineProperty;\n\nvar defineBuiltInAccessor$1 = function (target, name, descriptor) {\n  if (descriptor.get) makeBuiltIn(descriptor.get, name, { getter: true });\n  if (descriptor.set) makeBuiltIn(descriptor.set, name, { setter: true });\n  return defineProperty.f(target, name, descriptor);\n};\n\nvar anObject$3 = anObject$g;\nvar iteratorClose = iteratorClose$2;\n\n// call something on iterator step with safe closing on error\nvar callWithSafeIterationClosing$1 = function (iterator, fn, value, ENTRIES) {\n  try {\n    return ENTRIES ? fn(anObject$3(value)[0], value[1]) : fn(value);\n  } catch (error) {\n    iteratorClose(iterator, 'throw', error);\n  }\n};\n\nvar toPropertyKey = toPropertyKey$3;\nvar definePropertyModule = objectDefineProperty;\nvar createPropertyDescriptor$1 = createPropertyDescriptor$5;\n\nvar createProperty$2 = function (object, key, value) {\n  var propertyKey = toPropertyKey(key);\n  if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor$1(0, value));\n  else object[propertyKey] = value;\n};\n\nvar bind$2 = functionBindContext;\nvar call$4 = functionCall;\nvar toObject$1 = toObject$5;\nvar callWithSafeIterationClosing = callWithSafeIterationClosing$1;\nvar isArrayIteratorMethod = isArrayIteratorMethod$2;\nvar isConstructor = isConstructor$2;\nvar lengthOfArrayLike$1 = lengthOfArrayLike$4;\nvar createProperty$1 = createProperty$2;\nvar getIterator$1 = getIterator$3;\nvar getIteratorMethod$1 = getIteratorMethod$4;\n\nvar $Array$1 = Array;\n\n// `Array.from` method implementation\n// https://tc39.es/ecma262/#sec-array.from\nvar arrayFrom$1 = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {\n  var O = toObject$1(arrayLike);\n  var IS_CONSTRUCTOR = isConstructor(this);\n  var argumentsLength = arguments.length;\n  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;\n  var mapping = mapfn !== undefined;\n  if (mapping) mapfn = bind$2(mapfn, argumentsLength > 2 ? arguments[2] : undefined);\n  var iteratorMethod = getIteratorMethod$1(O);\n  var index = 0;\n  var length, result, step, iterator, next, value;\n  // if the target is not iterable or it's an array with the default iterator - use a simple case\n  if (iteratorMethod && !(this === $Array$1 && isArrayIteratorMethod(iteratorMethod))) {\n    iterator = getIterator$1(O, iteratorMethod);\n    next = iterator.next;\n    result = IS_CONSTRUCTOR ? new this() : [];\n    for (;!(step = call$4(next, iterator)).done; index++) {\n      value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;\n      createProperty$1(result, index, value);\n    }\n  } else {\n    length = lengthOfArrayLike$1(O);\n    result = IS_CONSTRUCTOR ? new this(length) : $Array$1(length);\n    for (;length > index; index++) {\n      value = mapping ? mapfn(O[index], index) : O[index];\n      createProperty$1(result, index, value);\n    }\n  }\n  result.length = index;\n  return result;\n};\n\nvar toAbsoluteIndex = toAbsoluteIndex$2;\nvar lengthOfArrayLike = lengthOfArrayLike$4;\nvar createProperty = createProperty$2;\n\nvar $Array = Array;\nvar max$1 = Math.max;\n\nvar arraySliceSimple = function (O, start, end) {\n  var length = lengthOfArrayLike(O);\n  var k = toAbsoluteIndex(start, length);\n  var fin = toAbsoluteIndex(end === undefined ? length : end, length);\n  var result = $Array(max$1(fin - k, 0));\n  for (var n = 0; k < fin; k++, n++) createProperty(result, n, O[k]);\n  result.length = n;\n  return result;\n};\n\n// based on https://github.com/bestiejs/punycode.js/blob/master/punycode.js\nvar uncurryThis$6 = functionUncurryThis;\n\nvar maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\nvar base = 36;\nvar tMin = 1;\nvar tMax = 26;\nvar skew = 38;\nvar damp = 700;\nvar initialBias = 72;\nvar initialN = 128; // 0x80\nvar delimiter = '-'; // '\\x2D'\nvar regexNonASCII = /[^\\0-\\u007E]/; // non-ASCII chars\nvar regexSeparators = /[.\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators\nvar OVERFLOW_ERROR = 'Overflow: input needs wider integers to process';\nvar baseMinusTMin = base - tMin;\n\nvar $RangeError = RangeError;\nvar exec$2 = uncurryThis$6(regexSeparators.exec);\nvar floor$3 = Math.floor;\nvar fromCharCode = String.fromCharCode;\nvar charCodeAt = uncurryThis$6(''.charCodeAt);\nvar join$2 = uncurryThis$6([].join);\nvar push$3 = uncurryThis$6([].push);\nvar replace$4 = uncurryThis$6(''.replace);\nvar split$2 = uncurryThis$6(''.split);\nvar toLowerCase$1 = uncurryThis$6(''.toLowerCase);\n\n/**\n * Creates an array containing the numeric code points of each Unicode\n * character in the string. While JavaScript uses UCS-2 internally,\n * this function will convert a pair of surrogate halves (each of which\n * UCS-2 exposes as separate characters) into a single code point,\n * matching UTF-16.\n */\nvar ucs2decode = function (string) {\n  var output = [];\n  var counter = 0;\n  var length = string.length;\n  while (counter < length) {\n    var value = charCodeAt(string, counter++);\n    if (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n      // It's a high surrogate, and there is a next character.\n      var extra = charCodeAt(string, counter++);\n      if ((extra & 0xFC00) == 0xDC00) { // Low surrogate.\n        push$3(output, ((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n      } else {\n        // It's an unmatched surrogate; only append this code unit, in case the\n        // next code unit is the high surrogate of a surrogate pair.\n        push$3(output, value);\n        counter--;\n      }\n    } else {\n      push$3(output, value);\n    }\n  }\n  return output;\n};\n\n/**\n * Converts a digit/integer into a basic code point.\n */\nvar digitToBasic = function (digit) {\n  //  0..25 map to ASCII a..z or A..Z\n  // 26..35 map to ASCII 0..9\n  return digit + 22 + 75 * (digit < 26);\n};\n\n/**\n * Bias adaptation function as per section 3.4 of RFC 3492.\n * https://tools.ietf.org/html/rfc3492#section-3.4\n */\nvar adapt = function (delta, numPoints, firstTime) {\n  var k = 0;\n  delta = firstTime ? floor$3(delta / damp) : delta >> 1;\n  delta += floor$3(delta / numPoints);\n  while (delta > baseMinusTMin * tMax >> 1) {\n    delta = floor$3(delta / baseMinusTMin);\n    k += base;\n  }\n  return floor$3(k + (baseMinusTMin + 1) * delta / (delta + skew));\n};\n\n/**\n * Converts a string of Unicode symbols (e.g. a domain name label) to a\n * Punycode string of ASCII-only symbols.\n */\nvar encode = function (input) {\n  var output = [];\n\n  // Convert the input in UCS-2 to an array of Unicode code points.\n  input = ucs2decode(input);\n\n  // Cache the length.\n  var inputLength = input.length;\n\n  // Initialize the state.\n  var n = initialN;\n  var delta = 0;\n  var bias = initialBias;\n  var i, currentValue;\n\n  // Handle the basic code points.\n  for (i = 0; i < input.length; i++) {\n    currentValue = input[i];\n    if (currentValue < 0x80) {\n      push$3(output, fromCharCode(currentValue));\n    }\n  }\n\n  var basicLength = output.length; // number of basic code points.\n  var handledCPCount = basicLength; // number of code points that have been handled;\n\n  // Finish the basic string with a delimiter unless it's empty.\n  if (basicLength) {\n    push$3(output, delimiter);\n  }\n\n  // Main encoding loop:\n  while (handledCPCount < inputLength) {\n    // All non-basic code points < n have been handled already. Find the next larger one:\n    var m = maxInt;\n    for (i = 0; i < input.length; i++) {\n      currentValue = input[i];\n      if (currentValue >= n && currentValue < m) {\n        m = currentValue;\n      }\n    }\n\n    // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>, but guard against overflow.\n    var handledCPCountPlusOne = handledCPCount + 1;\n    if (m - n > floor$3((maxInt - delta) / handledCPCountPlusOne)) {\n      throw $RangeError(OVERFLOW_ERROR);\n    }\n\n    delta += (m - n) * handledCPCountPlusOne;\n    n = m;\n\n    for (i = 0; i < input.length; i++) {\n      currentValue = input[i];\n      if (currentValue < n && ++delta > maxInt) {\n        throw $RangeError(OVERFLOW_ERROR);\n      }\n      if (currentValue == n) {\n        // Represent delta as a generalized variable-length integer.\n        var q = delta;\n        var k = base;\n        while (true) {\n          var t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n          if (q < t) break;\n          var qMinusT = q - t;\n          var baseMinusT = base - t;\n          push$3(output, fromCharCode(digitToBasic(t + qMinusT % baseMinusT)));\n          q = floor$3(qMinusT / baseMinusT);\n          k += base;\n        }\n\n        push$3(output, fromCharCode(digitToBasic(q)));\n        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n        delta = 0;\n        handledCPCount++;\n      }\n    }\n\n    delta++;\n    n++;\n  }\n  return join$2(output, '');\n};\n\nvar stringPunycodeToAscii = function (input) {\n  var encoded = [];\n  var labels = split$2(replace$4(toLowerCase$1(input), regexSeparators, '\\u002E'), '.');\n  var i, label;\n  for (i = 0; i < labels.length; i++) {\n    label = labels[i];\n    push$3(encoded, exec$2(regexNonASCII, label) ? 'xn--' + encode(label) : label);\n  }\n  return join$2(encoded, '.');\n};\n\nvar defineBuiltIn$3 = defineBuiltIn$a;\n\nvar defineBuiltIns$1 = function (target, src, options) {\n  for (var key in src) defineBuiltIn$3(target, key, src[key], options);\n  return target;\n};\n\nvar arraySlice$1 = arraySliceSimple;\n\nvar floor$2 = Math.floor;\n\nvar mergeSort = function (array, comparefn) {\n  var length = array.length;\n  var middle = floor$2(length / 2);\n  return length < 8 ? insertionSort(array, comparefn) : merge(\n    array,\n    mergeSort(arraySlice$1(array, 0, middle), comparefn),\n    mergeSort(arraySlice$1(array, middle), comparefn),\n    comparefn\n  );\n};\n\nvar insertionSort = function (array, comparefn) {\n  var length = array.length;\n  var i = 1;\n  var element, j;\n\n  while (i < length) {\n    j = i;\n    element = array[i];\n    while (j && comparefn(array[j - 1], element) > 0) {\n      array[j] = array[--j];\n    }\n    if (j !== i++) array[j] = element;\n  } return array;\n};\n\nvar merge = function (array, left, right, comparefn) {\n  var llength = left.length;\n  var rlength = right.length;\n  var lindex = 0;\n  var rindex = 0;\n\n  while (lindex < llength || rindex < rlength) {\n    array[lindex + rindex] = (lindex < llength && rindex < rlength)\n      ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++]\n      : lindex < llength ? left[lindex++] : right[rindex++];\n  } return array;\n};\n\nvar arraySort$1 = mergeSort;\n\n// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`\n\nvar $$2 = _export;\nvar global$5 = global$o;\nvar call$3 = functionCall;\nvar uncurryThis$5 = functionUncurryThis;\nvar DESCRIPTORS$1 = descriptors;\nvar USE_NATIVE_URL$1 = nativeUrl;\nvar defineBuiltIn$2 = defineBuiltIn$a;\nvar defineBuiltIns = defineBuiltIns$1;\nvar setToStringTag$1 = setToStringTag$5;\nvar createIteratorConstructor = createIteratorConstructor$2;\nvar InternalStateModule$1 = internalState;\nvar anInstance$1 = anInstance$3;\nvar isCallable$2 = isCallable$n;\nvar hasOwn$1 = hasOwnProperty_1;\nvar bind$1 = functionBindContext;\nvar classof$1 = classof$6;\nvar anObject$2 = anObject$g;\nvar isObject = isObject$8;\nvar $toString$1 = toString$4;\nvar create$1 = objectCreate;\nvar createPropertyDescriptor = createPropertyDescriptor$5;\nvar getIterator = getIterator$3;\nvar getIteratorMethod = getIteratorMethod$4;\nvar validateArgumentsLength$1 = validateArgumentsLength$3;\nvar wellKnownSymbol$2 = wellKnownSymbol$i;\nvar arraySort = arraySort$1;\n\nvar ITERATOR = wellKnownSymbol$2('iterator');\nvar URL_SEARCH_PARAMS = 'URLSearchParams';\nvar URL_SEARCH_PARAMS_ITERATOR = URL_SEARCH_PARAMS + 'Iterator';\nvar setInternalState$1 = InternalStateModule$1.set;\nvar getInternalParamsState = InternalStateModule$1.getterFor(URL_SEARCH_PARAMS);\nvar getInternalIteratorState = InternalStateModule$1.getterFor(URL_SEARCH_PARAMS_ITERATOR);\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n// Avoid NodeJS experimental warning\nvar safeGetBuiltIn = function (name) {\n  if (!DESCRIPTORS$1) return global$5[name];\n  var descriptor = getOwnPropertyDescriptor(global$5, name);\n  return descriptor && descriptor.value;\n};\n\nvar nativeFetch = safeGetBuiltIn('fetch');\nvar NativeRequest = safeGetBuiltIn('Request');\nvar Headers = safeGetBuiltIn('Headers');\nvar RequestPrototype = NativeRequest && NativeRequest.prototype;\nvar HeadersPrototype = Headers && Headers.prototype;\nvar RegExp$1 = global$5.RegExp;\nvar TypeError$2 = global$5.TypeError;\nvar decodeURIComponent = global$5.decodeURIComponent;\nvar encodeURIComponent$1 = global$5.encodeURIComponent;\nvar charAt$4 = uncurryThis$5(''.charAt);\nvar join$1 = uncurryThis$5([].join);\nvar push$2 = uncurryThis$5([].push);\nvar replace$3 = uncurryThis$5(''.replace);\nvar shift$1 = uncurryThis$5([].shift);\nvar splice = uncurryThis$5([].splice);\nvar split$1 = uncurryThis$5(''.split);\nvar stringSlice$4 = uncurryThis$5(''.slice);\n\nvar plus = /\\+/g;\nvar sequences = Array(4);\n\nvar percentSequence = function (bytes) {\n  return sequences[bytes - 1] || (sequences[bytes - 1] = RegExp$1('((?:%[\\\\da-f]{2}){' + bytes + '})', 'gi'));\n};\n\nvar percentDecode = function (sequence) {\n  try {\n    return decodeURIComponent(sequence);\n  } catch (error) {\n    return sequence;\n  }\n};\n\nvar deserialize = function (it) {\n  var result = replace$3(it, plus, ' ');\n  var bytes = 4;\n  try {\n    return decodeURIComponent(result);\n  } catch (error) {\n    while (bytes) {\n      result = replace$3(result, percentSequence(bytes--), percentDecode);\n    }\n    return result;\n  }\n};\n\nvar find = /[!'()~]|%20/g;\n\nvar replacements = {\n  '!': '%21',\n  \"'\": '%27',\n  '(': '%28',\n  ')': '%29',\n  '~': '%7E',\n  '%20': '+'\n};\n\nvar replacer = function (match) {\n  return replacements[match];\n};\n\nvar serialize = function (it) {\n  return replace$3(encodeURIComponent$1(it), find, replacer);\n};\n\nvar URLSearchParamsIterator = createIteratorConstructor(function Iterator(params, kind) {\n  setInternalState$1(this, {\n    type: URL_SEARCH_PARAMS_ITERATOR,\n    iterator: getIterator(getInternalParamsState(params).entries),\n    kind: kind\n  });\n}, 'Iterator', function next() {\n  var state = getInternalIteratorState(this);\n  var kind = state.kind;\n  var step = state.iterator.next();\n  var entry = step.value;\n  if (!step.done) {\n    step.value = kind === 'keys' ? entry.key : kind === 'values' ? entry.value : [entry.key, entry.value];\n  } return step;\n}, true);\n\nvar URLSearchParamsState = function (init) {\n  this.entries = [];\n  this.url = null;\n\n  if (init !== undefined) {\n    if (isObject(init)) this.parseObject(init);\n    else this.parseQuery(typeof init == 'string' ? charAt$4(init, 0) === '?' ? stringSlice$4(init, 1) : init : $toString$1(init));\n  }\n};\n\nURLSearchParamsState.prototype = {\n  type: URL_SEARCH_PARAMS,\n  bindURL: function (url) {\n    this.url = url;\n    this.update();\n  },\n  parseObject: function (object) {\n    var iteratorMethod = getIteratorMethod(object);\n    var iterator, next, step, entryIterator, entryNext, first, second;\n\n    if (iteratorMethod) {\n      iterator = getIterator(object, iteratorMethod);\n      next = iterator.next;\n      while (!(step = call$3(next, iterator)).done) {\n        entryIterator = getIterator(anObject$2(step.value));\n        entryNext = entryIterator.next;\n        if (\n          (first = call$3(entryNext, entryIterator)).done ||\n          (second = call$3(entryNext, entryIterator)).done ||\n          !call$3(entryNext, entryIterator).done\n        ) throw TypeError$2('Expected sequence with length 2');\n        push$2(this.entries, { key: $toString$1(first.value), value: $toString$1(second.value) });\n      }\n    } else for (var key in object) if (hasOwn$1(object, key)) {\n      push$2(this.entries, { key: key, value: $toString$1(object[key]) });\n    }\n  },\n  parseQuery: function (query) {\n    if (query) {\n      var attributes = split$1(query, '&');\n      var index = 0;\n      var attribute, entry;\n      while (index < attributes.length) {\n        attribute = attributes[index++];\n        if (attribute.length) {\n          entry = split$1(attribute, '=');\n          push$2(this.entries, {\n            key: deserialize(shift$1(entry)),\n            value: deserialize(join$1(entry, '='))\n          });\n        }\n      }\n    }\n  },\n  serialize: function () {\n    var entries = this.entries;\n    var result = [];\n    var index = 0;\n    var entry;\n    while (index < entries.length) {\n      entry = entries[index++];\n      push$2(result, serialize(entry.key) + '=' + serialize(entry.value));\n    } return join$1(result, '&');\n  },\n  update: function () {\n    this.entries.length = 0;\n    this.parseQuery(this.url.query);\n  },\n  updateURL: function () {\n    if (this.url) this.url.update();\n  }\n};\n\n// `URLSearchParams` constructor\n// https://url.spec.whatwg.org/#interface-urlsearchparams\nvar URLSearchParamsConstructor = function URLSearchParams(/* init */) {\n  anInstance$1(this, URLSearchParamsPrototype);\n  var init = arguments.length > 0 ? arguments[0] : undefined;\n  setInternalState$1(this, new URLSearchParamsState(init));\n};\n\nvar URLSearchParamsPrototype = URLSearchParamsConstructor.prototype;\n\ndefineBuiltIns(URLSearchParamsPrototype, {\n  // `URLSearchParams.prototype.append` method\n  // https://url.spec.whatwg.org/#dom-urlsearchparams-append\n  append: function append(name, value) {\n    validateArgumentsLength$1(arguments.length, 2);\n    var state = getInternalParamsState(this);\n    push$2(state.entries, { key: $toString$1(name), value: $toString$1(value) });\n    state.updateURL();\n  },\n  // `URLSearchParams.prototype.delete` method\n  // https://url.spec.whatwg.org/#dom-urlsearchparams-delete\n  'delete': function (name) {\n    validateArgumentsLength$1(arguments.length, 1);\n    var state = getInternalParamsState(this);\n    var entries = state.entries;\n    var key = $toString$1(name);\n    var index = 0;\n    while (index < entries.length) {\n      if (entries[index].key === key) splice(entries, index, 1);\n      else index++;\n    }\n    state.updateURL();\n  },\n  // `URLSearchParams.prototype.get` method\n  // https://url.spec.whatwg.org/#dom-urlsearchparams-get\n  get: function get(name) {\n    validateArgumentsLength$1(arguments.length, 1);\n    var entries = getInternalParamsState(this).entries;\n    var key = $toString$1(name);\n    var index = 0;\n    for (; index < entries.length; index++) {\n      if (entries[index].key === key) return entries[index].value;\n    }\n    return null;\n  },\n  // `URLSearchParams.prototype.getAll` method\n  // https://url.spec.whatwg.org/#dom-urlsearchparams-getall\n  getAll: function getAll(name) {\n    validateArgumentsLength$1(arguments.length, 1);\n    var entries = getInternalParamsState(this).entries;\n    var key = $toString$1(name);\n    var result = [];\n    var index = 0;\n    for (; index < entries.length; index++) {\n      if (entries[index].key === key) push$2(result, entries[index].value);\n    }\n    return result;\n  },\n  // `URLSearchParams.prototype.has` method\n  // https://url.spec.whatwg.org/#dom-urlsearchparams-has\n  has: function has(name) {\n    validateArgumentsLength$1(arguments.length, 1);\n    var entries = getInternalParamsState(this).entries;\n    var key = $toString$1(name);\n    var index = 0;\n    while (index < entries.length) {\n      if (entries[index++].key === key) return true;\n    }\n    return false;\n  },\n  // `URLSearchParams.prototype.set` method\n  // https://url.spec.whatwg.org/#dom-urlsearchparams-set\n  set: function set(name, value) {\n    validateArgumentsLength$1(arguments.length, 1);\n    var state = getInternalParamsState(this);\n    var entries = state.entries;\n    var found = false;\n    var key = $toString$1(name);\n    var val = $toString$1(value);\n    var index = 0;\n    var entry;\n    for (; index < entries.length; index++) {\n      entry = entries[index];\n      if (entry.key === key) {\n        if (found) splice(entries, index--, 1);\n        else {\n          found = true;\n          entry.value = val;\n        }\n      }\n    }\n    if (!found) push$2(entries, { key: key, value: val });\n    state.updateURL();\n  },\n  // `URLSearchParams.prototype.sort` method\n  // https://url.spec.whatwg.org/#dom-urlsearchparams-sort\n  sort: function sort() {\n    var state = getInternalParamsState(this);\n    arraySort(state.entries, function (a, b) {\n      return a.key > b.key ? 1 : -1;\n    });\n    state.updateURL();\n  },\n  // `URLSearchParams.prototype.forEach` method\n  forEach: function forEach(callback /* , thisArg */) {\n    var entries = getInternalParamsState(this).entries;\n    var boundFunction = bind$1(callback, arguments.length > 1 ? arguments[1] : undefined);\n    var index = 0;\n    var entry;\n    while (index < entries.length) {\n      entry = entries[index++];\n      boundFunction(entry.value, entry.key, this);\n    }\n  },\n  // `URLSearchParams.prototype.keys` method\n  keys: function keys() {\n    return new URLSearchParamsIterator(this, 'keys');\n  },\n  // `URLSearchParams.prototype.values` method\n  values: function values() {\n    return new URLSearchParamsIterator(this, 'values');\n  },\n  // `URLSearchParams.prototype.entries` method\n  entries: function entries() {\n    return new URLSearchParamsIterator(this, 'entries');\n  }\n}, { enumerable: true });\n\n// `URLSearchParams.prototype[@@iterator]` method\ndefineBuiltIn$2(URLSearchParamsPrototype, ITERATOR, URLSearchParamsPrototype.entries, { name: 'entries' });\n\n// `URLSearchParams.prototype.toString` method\n// https://url.spec.whatwg.org/#urlsearchparams-stringification-behavior\ndefineBuiltIn$2(URLSearchParamsPrototype, 'toString', function toString() {\n  return getInternalParamsState(this).serialize();\n}, { enumerable: true });\n\nsetToStringTag$1(URLSearchParamsConstructor, URL_SEARCH_PARAMS);\n\n$$2({ global: true, constructor: true, forced: !USE_NATIVE_URL$1 }, {\n  URLSearchParams: URLSearchParamsConstructor\n});\n\n// Wrap `fetch` and `Request` for correct work with polyfilled `URLSearchParams`\nif (!USE_NATIVE_URL$1 && isCallable$2(Headers)) {\n  var headersHas = uncurryThis$5(HeadersPrototype.has);\n  var headersSet = uncurryThis$5(HeadersPrototype.set);\n\n  var wrapRequestOptions = function (init) {\n    if (isObject(init)) {\n      var body = init.body;\n      var headers;\n      if (classof$1(body) === URL_SEARCH_PARAMS) {\n        headers = init.headers ? new Headers(init.headers) : new Headers();\n        if (!headersHas(headers, 'content-type')) {\n          headersSet(headers, 'content-type', 'application/x-www-form-urlencoded;charset=UTF-8');\n        }\n        return create$1(init, {\n          body: createPropertyDescriptor(0, $toString$1(body)),\n          headers: createPropertyDescriptor(0, headers)\n        });\n      }\n    } return init;\n  };\n\n  if (isCallable$2(nativeFetch)) {\n    $$2({ global: true, enumerable: true, dontCallGetSet: true, forced: true }, {\n      fetch: function fetch(input /* , init */) {\n        return nativeFetch(input, arguments.length > 1 ? wrapRequestOptions(arguments[1]) : {});\n      }\n    });\n  }\n\n  if (isCallable$2(NativeRequest)) {\n    var RequestConstructor = function Request(input /* , init */) {\n      anInstance$1(this, RequestPrototype);\n      return new NativeRequest(input, arguments.length > 1 ? wrapRequestOptions(arguments[1]) : {});\n    };\n\n    RequestPrototype.constructor = RequestConstructor;\n    RequestConstructor.prototype = RequestPrototype;\n\n    $$2({ global: true, constructor: true, dontCallGetSet: true, forced: true }, {\n      Request: RequestConstructor\n    });\n  }\n}\n\nvar web_urlSearchParams_constructor = {\n  URLSearchParams: URLSearchParamsConstructor,\n  getState: getInternalParamsState\n};\n\n// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`\n\nvar $$1 = _export;\nvar DESCRIPTORS = descriptors;\nvar USE_NATIVE_URL = nativeUrl;\nvar global$4 = global$o;\nvar bind = functionBindContext;\nvar uncurryThis$4 = functionUncurryThis;\nvar defineBuiltIn$1 = defineBuiltIn$a;\nvar defineBuiltInAccessor = defineBuiltInAccessor$1;\nvar anInstance = anInstance$3;\nvar hasOwn = hasOwnProperty_1;\nvar assign = objectAssign;\nvar arrayFrom = arrayFrom$1;\nvar arraySlice = arraySliceSimple;\nvar codeAt = stringMultibyte.codeAt;\nvar toASCII = stringPunycodeToAscii;\nvar $toString = toString$4;\nvar setToStringTag = setToStringTag$5;\nvar validateArgumentsLength = validateArgumentsLength$3;\nvar URLSearchParamsModule = web_urlSearchParams_constructor;\nvar InternalStateModule = internalState;\n\nvar setInternalState = InternalStateModule.set;\nvar getInternalURLState = InternalStateModule.getterFor('URL');\nvar URLSearchParams$1 = URLSearchParamsModule.URLSearchParams;\nvar getInternalSearchParamsState = URLSearchParamsModule.getState;\n\nvar NativeURL = global$4.URL;\nvar TypeError$1 = global$4.TypeError;\nvar parseInt = global$4.parseInt;\nvar floor$1 = Math.floor;\nvar pow = Math.pow;\nvar charAt$3 = uncurryThis$4(''.charAt);\nvar exec$1 = uncurryThis$4(/./.exec);\nvar join = uncurryThis$4([].join);\nvar numberToString = uncurryThis$4(1.0.toString);\nvar pop = uncurryThis$4([].pop);\nvar push$1 = uncurryThis$4([].push);\nvar replace$2 = uncurryThis$4(''.replace);\nvar shift = uncurryThis$4([].shift);\nvar split = uncurryThis$4(''.split);\nvar stringSlice$3 = uncurryThis$4(''.slice);\nvar toLowerCase = uncurryThis$4(''.toLowerCase);\nvar unshift = uncurryThis$4([].unshift);\n\nvar INVALID_AUTHORITY = 'Invalid authority';\nvar INVALID_SCHEME = 'Invalid scheme';\nvar INVALID_HOST = 'Invalid host';\nvar INVALID_PORT = 'Invalid port';\n\nvar ALPHA = /[a-z]/i;\n// eslint-disable-next-line regexp/no-obscure-range -- safe\nvar ALPHANUMERIC = /[\\d+-.a-z]/i;\nvar DIGIT = /\\d/;\nvar HEX_START = /^0x/i;\nvar OCT = /^[0-7]+$/;\nvar DEC = /^\\d+$/;\nvar HEX = /^[\\da-f]+$/i;\n/* eslint-disable regexp/no-control-character -- safe */\nvar FORBIDDEN_HOST_CODE_POINT = /[\\0\\t\\n\\r #%/:<>?@[\\\\\\]^|]/;\nvar FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT = /[\\0\\t\\n\\r #/:<>?@[\\\\\\]^|]/;\nvar LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE = /^[\\u0000-\\u0020]+|[\\u0000-\\u0020]+$/g;\nvar TAB_AND_NEW_LINE = /[\\t\\n\\r]/g;\n/* eslint-enable regexp/no-control-character -- safe */\nvar EOF;\n\n// https://url.spec.whatwg.org/#ipv4-number-parser\nvar parseIPv4 = function (input) {\n  var parts = split(input, '.');\n  var partsLength, numbers, index, part, radix, number, ipv4;\n  if (parts.length && parts[parts.length - 1] == '') {\n    parts.length--;\n  }\n  partsLength = parts.length;\n  if (partsLength > 4) return input;\n  numbers = [];\n  for (index = 0; index < partsLength; index++) {\n    part = parts[index];\n    if (part == '') return input;\n    radix = 10;\n    if (part.length > 1 && charAt$3(part, 0) == '0') {\n      radix = exec$1(HEX_START, part) ? 16 : 8;\n      part = stringSlice$3(part, radix == 8 ? 1 : 2);\n    }\n    if (part === '') {\n      number = 0;\n    } else {\n      if (!exec$1(radix == 10 ? DEC : radix == 8 ? OCT : HEX, part)) return input;\n      number = parseInt(part, radix);\n    }\n    push$1(numbers, number);\n  }\n  for (index = 0; index < partsLength; index++) {\n    number = numbers[index];\n    if (index == partsLength - 1) {\n      if (number >= pow(256, 5 - partsLength)) return null;\n    } else if (number > 255) return null;\n  }\n  ipv4 = pop(numbers);\n  for (index = 0; index < numbers.length; index++) {\n    ipv4 += numbers[index] * pow(256, 3 - index);\n  }\n  return ipv4;\n};\n\n// https://url.spec.whatwg.org/#concept-ipv6-parser\n// eslint-disable-next-line max-statements -- TODO\nvar parseIPv6 = function (input) {\n  var address = [0, 0, 0, 0, 0, 0, 0, 0];\n  var pieceIndex = 0;\n  var compress = null;\n  var pointer = 0;\n  var value, length, numbersSeen, ipv4Piece, number, swaps, swap;\n\n  var chr = function () {\n    return charAt$3(input, pointer);\n  };\n\n  if (chr() == ':') {\n    if (charAt$3(input, 1) != ':') return;\n    pointer += 2;\n    pieceIndex++;\n    compress = pieceIndex;\n  }\n  while (chr()) {\n    if (pieceIndex == 8) return;\n    if (chr() == ':') {\n      if (compress !== null) return;\n      pointer++;\n      pieceIndex++;\n      compress = pieceIndex;\n      continue;\n    }\n    value = length = 0;\n    while (length < 4 && exec$1(HEX, chr())) {\n      value = value * 16 + parseInt(chr(), 16);\n      pointer++;\n      length++;\n    }\n    if (chr() == '.') {\n      if (length == 0) return;\n      pointer -= length;\n      if (pieceIndex > 6) return;\n      numbersSeen = 0;\n      while (chr()) {\n        ipv4Piece = null;\n        if (numbersSeen > 0) {\n          if (chr() == '.' && numbersSeen < 4) pointer++;\n          else return;\n        }\n        if (!exec$1(DIGIT, chr())) return;\n        while (exec$1(DIGIT, chr())) {\n          number = parseInt(chr(), 10);\n          if (ipv4Piece === null) ipv4Piece = number;\n          else if (ipv4Piece == 0) return;\n          else ipv4Piece = ipv4Piece * 10 + number;\n          if (ipv4Piece > 255) return;\n          pointer++;\n        }\n        address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;\n        numbersSeen++;\n        if (numbersSeen == 2 || numbersSeen == 4) pieceIndex++;\n      }\n      if (numbersSeen != 4) return;\n      break;\n    } else if (chr() == ':') {\n      pointer++;\n      if (!chr()) return;\n    } else if (chr()) return;\n    address[pieceIndex++] = value;\n  }\n  if (compress !== null) {\n    swaps = pieceIndex - compress;\n    pieceIndex = 7;\n    while (pieceIndex != 0 && swaps > 0) {\n      swap = address[pieceIndex];\n      address[pieceIndex--] = address[compress + swaps - 1];\n      address[compress + --swaps] = swap;\n    }\n  } else if (pieceIndex != 8) return;\n  return address;\n};\n\nvar findLongestZeroSequence = function (ipv6) {\n  var maxIndex = null;\n  var maxLength = 1;\n  var currStart = null;\n  var currLength = 0;\n  var index = 0;\n  for (; index < 8; index++) {\n    if (ipv6[index] !== 0) {\n      if (currLength > maxLength) {\n        maxIndex = currStart;\n        maxLength = currLength;\n      }\n      currStart = null;\n      currLength = 0;\n    } else {\n      if (currStart === null) currStart = index;\n      ++currLength;\n    }\n  }\n  if (currLength > maxLength) {\n    maxIndex = currStart;\n    maxLength = currLength;\n  }\n  return maxIndex;\n};\n\n// https://url.spec.whatwg.org/#host-serializing\nvar serializeHost = function (host) {\n  var result, index, compress, ignore0;\n  // ipv4\n  if (typeof host == 'number') {\n    result = [];\n    for (index = 0; index < 4; index++) {\n      unshift(result, host % 256);\n      host = floor$1(host / 256);\n    } return join(result, '.');\n  // ipv6\n  } else if (typeof host == 'object') {\n    result = '';\n    compress = findLongestZeroSequence(host);\n    for (index = 0; index < 8; index++) {\n      if (ignore0 && host[index] === 0) continue;\n      if (ignore0) ignore0 = false;\n      if (compress === index) {\n        result += index ? ':' : '::';\n        ignore0 = true;\n      } else {\n        result += numberToString(host[index], 16);\n        if (index < 7) result += ':';\n      }\n    }\n    return '[' + result + ']';\n  } return host;\n};\n\nvar C0ControlPercentEncodeSet = {};\nvar fragmentPercentEncodeSet = assign({}, C0ControlPercentEncodeSet, {\n  ' ': 1, '\"': 1, '<': 1, '>': 1, '`': 1\n});\nvar pathPercentEncodeSet = assign({}, fragmentPercentEncodeSet, {\n  '#': 1, '?': 1, '{': 1, '}': 1\n});\nvar userinfoPercentEncodeSet = assign({}, pathPercentEncodeSet, {\n  '/': 1, ':': 1, ';': 1, '=': 1, '@': 1, '[': 1, '\\\\': 1, ']': 1, '^': 1, '|': 1\n});\n\nvar percentEncode = function (chr, set) {\n  var code = codeAt(chr, 0);\n  return code > 0x20 && code < 0x7F && !hasOwn(set, chr) ? chr : encodeURIComponent(chr);\n};\n\n// https://url.spec.whatwg.org/#special-scheme\nvar specialSchemes = {\n  ftp: 21,\n  file: null,\n  http: 80,\n  https: 443,\n  ws: 80,\n  wss: 443\n};\n\n// https://url.spec.whatwg.org/#windows-drive-letter\nvar isWindowsDriveLetter = function (string, normalized) {\n  var second;\n  return string.length == 2 && exec$1(ALPHA, charAt$3(string, 0))\n    && ((second = charAt$3(string, 1)) == ':' || (!normalized && second == '|'));\n};\n\n// https://url.spec.whatwg.org/#start-with-a-windows-drive-letter\nvar startsWithWindowsDriveLetter = function (string) {\n  var third;\n  return string.length > 1 && isWindowsDriveLetter(stringSlice$3(string, 0, 2)) && (\n    string.length == 2 ||\n    ((third = charAt$3(string, 2)) === '/' || third === '\\\\' || third === '?' || third === '#')\n  );\n};\n\n// https://url.spec.whatwg.org/#single-dot-path-segment\nvar isSingleDot = function (segment) {\n  return segment === '.' || toLowerCase(segment) === '%2e';\n};\n\n// https://url.spec.whatwg.org/#double-dot-path-segment\nvar isDoubleDot = function (segment) {\n  segment = toLowerCase(segment);\n  return segment === '..' || segment === '%2e.' || segment === '.%2e' || segment === '%2e%2e';\n};\n\n// States:\nvar SCHEME_START = {};\nvar SCHEME = {};\nvar NO_SCHEME = {};\nvar SPECIAL_RELATIVE_OR_AUTHORITY = {};\nvar PATH_OR_AUTHORITY = {};\nvar RELATIVE = {};\nvar RELATIVE_SLASH = {};\nvar SPECIAL_AUTHORITY_SLASHES = {};\nvar SPECIAL_AUTHORITY_IGNORE_SLASHES = {};\nvar AUTHORITY = {};\nvar HOST = {};\nvar HOSTNAME = {};\nvar PORT = {};\nvar FILE = {};\nvar FILE_SLASH = {};\nvar FILE_HOST = {};\nvar PATH_START = {};\nvar PATH = {};\nvar CANNOT_BE_A_BASE_URL_PATH = {};\nvar QUERY = {};\nvar FRAGMENT = {};\n\nvar URLState = function (url, isBase, base) {\n  var urlString = $toString(url);\n  var baseState, failure, searchParams;\n  if (isBase) {\n    failure = this.parse(urlString);\n    if (failure) throw TypeError$1(failure);\n    this.searchParams = null;\n  } else {\n    if (base !== undefined) baseState = new URLState(base, true);\n    failure = this.parse(urlString, null, baseState);\n    if (failure) throw TypeError$1(failure);\n    searchParams = getInternalSearchParamsState(new URLSearchParams$1());\n    searchParams.bindURL(this);\n    this.searchParams = searchParams;\n  }\n};\n\nURLState.prototype = {\n  type: 'URL',\n  // https://url.spec.whatwg.org/#url-parsing\n  // eslint-disable-next-line max-statements -- TODO\n  parse: function (input, stateOverride, base) {\n    var url = this;\n    var state = stateOverride || SCHEME_START;\n    var pointer = 0;\n    var buffer = '';\n    var seenAt = false;\n    var seenBracket = false;\n    var seenPasswordToken = false;\n    var codePoints, chr, bufferCodePoints, failure;\n\n    input = $toString(input);\n\n    if (!stateOverride) {\n      url.scheme = '';\n      url.username = '';\n      url.password = '';\n      url.host = null;\n      url.port = null;\n      url.path = [];\n      url.query = null;\n      url.fragment = null;\n      url.cannotBeABaseURL = false;\n      input = replace$2(input, LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE, '');\n    }\n\n    input = replace$2(input, TAB_AND_NEW_LINE, '');\n\n    codePoints = arrayFrom(input);\n\n    while (pointer <= codePoints.length) {\n      chr = codePoints[pointer];\n      switch (state) {\n        case SCHEME_START:\n          if (chr && exec$1(ALPHA, chr)) {\n            buffer += toLowerCase(chr);\n            state = SCHEME;\n          } else if (!stateOverride) {\n            state = NO_SCHEME;\n            continue;\n          } else return INVALID_SCHEME;\n          break;\n\n        case SCHEME:\n          if (chr && (exec$1(ALPHANUMERIC, chr) || chr == '+' || chr == '-' || chr == '.')) {\n            buffer += toLowerCase(chr);\n          } else if (chr == ':') {\n            if (stateOverride && (\n              (url.isSpecial() != hasOwn(specialSchemes, buffer)) ||\n              (buffer == 'file' && (url.includesCredentials() || url.port !== null)) ||\n              (url.scheme == 'file' && !url.host)\n            )) return;\n            url.scheme = buffer;\n            if (stateOverride) {\n              if (url.isSpecial() && specialSchemes[url.scheme] == url.port) url.port = null;\n              return;\n            }\n            buffer = '';\n            if (url.scheme == 'file') {\n              state = FILE;\n            } else if (url.isSpecial() && base && base.scheme == url.scheme) {\n              state = SPECIAL_RELATIVE_OR_AUTHORITY;\n            } else if (url.isSpecial()) {\n              state = SPECIAL_AUTHORITY_SLASHES;\n            } else if (codePoints[pointer + 1] == '/') {\n              state = PATH_OR_AUTHORITY;\n              pointer++;\n            } else {\n              url.cannotBeABaseURL = true;\n              push$1(url.path, '');\n              state = CANNOT_BE_A_BASE_URL_PATH;\n            }\n          } else if (!stateOverride) {\n            buffer = '';\n            state = NO_SCHEME;\n            pointer = 0;\n            continue;\n          } else return INVALID_SCHEME;\n          break;\n\n        case NO_SCHEME:\n          if (!base || (base.cannotBeABaseURL && chr != '#')) return INVALID_SCHEME;\n          if (base.cannotBeABaseURL && chr == '#') {\n            url.scheme = base.scheme;\n            url.path = arraySlice(base.path);\n            url.query = base.query;\n            url.fragment = '';\n            url.cannotBeABaseURL = true;\n            state = FRAGMENT;\n            break;\n          }\n          state = base.scheme == 'file' ? FILE : RELATIVE;\n          continue;\n\n        case SPECIAL_RELATIVE_OR_AUTHORITY:\n          if (chr == '/' && codePoints[pointer + 1] == '/') {\n            state = SPECIAL_AUTHORITY_IGNORE_SLASHES;\n            pointer++;\n          } else {\n            state = RELATIVE;\n            continue;\n          } break;\n\n        case PATH_OR_AUTHORITY:\n          if (chr == '/') {\n            state = AUTHORITY;\n            break;\n          } else {\n            state = PATH;\n            continue;\n          }\n\n        case RELATIVE:\n          url.scheme = base.scheme;\n          if (chr == EOF) {\n            url.username = base.username;\n            url.password = base.password;\n            url.host = base.host;\n            url.port = base.port;\n            url.path = arraySlice(base.path);\n            url.query = base.query;\n          } else if (chr == '/' || (chr == '\\\\' && url.isSpecial())) {\n            state = RELATIVE_SLASH;\n          } else if (chr == '?') {\n            url.username = base.username;\n            url.password = base.password;\n            url.host = base.host;\n            url.port = base.port;\n            url.path = arraySlice(base.path);\n            url.query = '';\n            state = QUERY;\n          } else if (chr == '#') {\n            url.username = base.username;\n            url.password = base.password;\n            url.host = base.host;\n            url.port = base.port;\n            url.path = arraySlice(base.path);\n            url.query = base.query;\n            url.fragment = '';\n            state = FRAGMENT;\n          } else {\n            url.username = base.username;\n            url.password = base.password;\n            url.host = base.host;\n            url.port = base.port;\n            url.path = arraySlice(base.path);\n            url.path.length--;\n            state = PATH;\n            continue;\n          } break;\n\n        case RELATIVE_SLASH:\n          if (url.isSpecial() && (chr == '/' || chr == '\\\\')) {\n            state = SPECIAL_AUTHORITY_IGNORE_SLASHES;\n          } else if (chr == '/') {\n            state = AUTHORITY;\n          } else {\n            url.username = base.username;\n            url.password = base.password;\n            url.host = base.host;\n            url.port = base.port;\n            state = PATH;\n            continue;\n          } break;\n\n        case SPECIAL_AUTHORITY_SLASHES:\n          state = SPECIAL_AUTHORITY_IGNORE_SLASHES;\n          if (chr != '/' || charAt$3(buffer, pointer + 1) != '/') continue;\n          pointer++;\n          break;\n\n        case SPECIAL_AUTHORITY_IGNORE_SLASHES:\n          if (chr != '/' && chr != '\\\\') {\n            state = AUTHORITY;\n            continue;\n          } break;\n\n        case AUTHORITY:\n          if (chr == '@') {\n            if (seenAt) buffer = '%40' + buffer;\n            seenAt = true;\n            bufferCodePoints = arrayFrom(buffer);\n            for (var i = 0; i < bufferCodePoints.length; i++) {\n              var codePoint = bufferCodePoints[i];\n              if (codePoint == ':' && !seenPasswordToken) {\n                seenPasswordToken = true;\n                continue;\n              }\n              var encodedCodePoints = percentEncode(codePoint, userinfoPercentEncodeSet);\n              if (seenPasswordToken) url.password += encodedCodePoints;\n              else url.username += encodedCodePoints;\n            }\n            buffer = '';\n          } else if (\n            chr == EOF || chr == '/' || chr == '?' || chr == '#' ||\n            (chr == '\\\\' && url.isSpecial())\n          ) {\n            if (seenAt && buffer == '') return INVALID_AUTHORITY;\n            pointer -= arrayFrom(buffer).length + 1;\n            buffer = '';\n            state = HOST;\n          } else buffer += chr;\n          break;\n\n        case HOST:\n        case HOSTNAME:\n          if (stateOverride && url.scheme == 'file') {\n            state = FILE_HOST;\n            continue;\n          } else if (chr == ':' && !seenBracket) {\n            if (buffer == '') return INVALID_HOST;\n            failure = url.parseHost(buffer);\n            if (failure) return failure;\n            buffer = '';\n            state = PORT;\n            if (stateOverride == HOSTNAME) return;\n          } else if (\n            chr == EOF || chr == '/' || chr == '?' || chr == '#' ||\n            (chr == '\\\\' && url.isSpecial())\n          ) {\n            if (url.isSpecial() && buffer == '') return INVALID_HOST;\n            if (stateOverride && buffer == '' && (url.includesCredentials() || url.port !== null)) return;\n            failure = url.parseHost(buffer);\n            if (failure) return failure;\n            buffer = '';\n            state = PATH_START;\n            if (stateOverride) return;\n            continue;\n          } else {\n            if (chr == '[') seenBracket = true;\n            else if (chr == ']') seenBracket = false;\n            buffer += chr;\n          } break;\n\n        case PORT:\n          if (exec$1(DIGIT, chr)) {\n            buffer += chr;\n          } else if (\n            chr == EOF || chr == '/' || chr == '?' || chr == '#' ||\n            (chr == '\\\\' && url.isSpecial()) ||\n            stateOverride\n          ) {\n            if (buffer != '') {\n              var port = parseInt(buffer, 10);\n              if (port > 0xFFFF) return INVALID_PORT;\n              url.port = (url.isSpecial() && port === specialSchemes[url.scheme]) ? null : port;\n              buffer = '';\n            }\n            if (stateOverride) return;\n            state = PATH_START;\n            continue;\n          } else return INVALID_PORT;\n          break;\n\n        case FILE:\n          url.scheme = 'file';\n          if (chr == '/' || chr == '\\\\') state = FILE_SLASH;\n          else if (base && base.scheme == 'file') {\n            if (chr == EOF) {\n              url.host = base.host;\n              url.path = arraySlice(base.path);\n              url.query = base.query;\n            } else if (chr == '?') {\n              url.host = base.host;\n              url.path = arraySlice(base.path);\n              url.query = '';\n              state = QUERY;\n            } else if (chr == '#') {\n              url.host = base.host;\n              url.path = arraySlice(base.path);\n              url.query = base.query;\n              url.fragment = '';\n              state = FRAGMENT;\n            } else {\n              if (!startsWithWindowsDriveLetter(join(arraySlice(codePoints, pointer), ''))) {\n                url.host = base.host;\n                url.path = arraySlice(base.path);\n                url.shortenPath();\n              }\n              state = PATH;\n              continue;\n            }\n          } else {\n            state = PATH;\n            continue;\n          } break;\n\n        case FILE_SLASH:\n          if (chr == '/' || chr == '\\\\') {\n            state = FILE_HOST;\n            break;\n          }\n          if (base && base.scheme == 'file' && !startsWithWindowsDriveLetter(join(arraySlice(codePoints, pointer), ''))) {\n            if (isWindowsDriveLetter(base.path[0], true)) push$1(url.path, base.path[0]);\n            else url.host = base.host;\n          }\n          state = PATH;\n          continue;\n\n        case FILE_HOST:\n          if (chr == EOF || chr == '/' || chr == '\\\\' || chr == '?' || chr == '#') {\n            if (!stateOverride && isWindowsDriveLetter(buffer)) {\n              state = PATH;\n            } else if (buffer == '') {\n              url.host = '';\n              if (stateOverride) return;\n              state = PATH_START;\n            } else {\n              failure = url.parseHost(buffer);\n              if (failure) return failure;\n              if (url.host == 'localhost') url.host = '';\n              if (stateOverride) return;\n              buffer = '';\n              state = PATH_START;\n            } continue;\n          } else buffer += chr;\n          break;\n\n        case PATH_START:\n          if (url.isSpecial()) {\n            state = PATH;\n            if (chr != '/' && chr != '\\\\') continue;\n          } else if (!stateOverride && chr == '?') {\n            url.query = '';\n            state = QUERY;\n          } else if (!stateOverride && chr == '#') {\n            url.fragment = '';\n            state = FRAGMENT;\n          } else if (chr != EOF) {\n            state = PATH;\n            if (chr != '/') continue;\n          } break;\n\n        case PATH:\n          if (\n            chr == EOF || chr == '/' ||\n            (chr == '\\\\' && url.isSpecial()) ||\n            (!stateOverride && (chr == '?' || chr == '#'))\n          ) {\n            if (isDoubleDot(buffer)) {\n              url.shortenPath();\n              if (chr != '/' && !(chr == '\\\\' && url.isSpecial())) {\n                push$1(url.path, '');\n              }\n            } else if (isSingleDot(buffer)) {\n              if (chr != '/' && !(chr == '\\\\' && url.isSpecial())) {\n                push$1(url.path, '');\n              }\n            } else {\n              if (url.scheme == 'file' && !url.path.length && isWindowsDriveLetter(buffer)) {\n                if (url.host) url.host = '';\n                buffer = charAt$3(buffer, 0) + ':'; // normalize windows drive letter\n              }\n              push$1(url.path, buffer);\n            }\n            buffer = '';\n            if (url.scheme == 'file' && (chr == EOF || chr == '?' || chr == '#')) {\n              while (url.path.length > 1 && url.path[0] === '') {\n                shift(url.path);\n              }\n            }\n            if (chr == '?') {\n              url.query = '';\n              state = QUERY;\n            } else if (chr == '#') {\n              url.fragment = '';\n              state = FRAGMENT;\n            }\n          } else {\n            buffer += percentEncode(chr, pathPercentEncodeSet);\n          } break;\n\n        case CANNOT_BE_A_BASE_URL_PATH:\n          if (chr == '?') {\n            url.query = '';\n            state = QUERY;\n          } else if (chr == '#') {\n            url.fragment = '';\n            state = FRAGMENT;\n          } else if (chr != EOF) {\n            url.path[0] += percentEncode(chr, C0ControlPercentEncodeSet);\n          } break;\n\n        case QUERY:\n          if (!stateOverride && chr == '#') {\n            url.fragment = '';\n            state = FRAGMENT;\n          } else if (chr != EOF) {\n            if (chr == \"'\" && url.isSpecial()) url.query += '%27';\n            else if (chr == '#') url.query += '%23';\n            else url.query += percentEncode(chr, C0ControlPercentEncodeSet);\n          } break;\n\n        case FRAGMENT:\n          if (chr != EOF) url.fragment += percentEncode(chr, fragmentPercentEncodeSet);\n          break;\n      }\n\n      pointer++;\n    }\n  },\n  // https://url.spec.whatwg.org/#host-parsing\n  parseHost: function (input) {\n    var result, codePoints, index;\n    if (charAt$3(input, 0) == '[') {\n      if (charAt$3(input, input.length - 1) != ']') return INVALID_HOST;\n      result = parseIPv6(stringSlice$3(input, 1, -1));\n      if (!result) return INVALID_HOST;\n      this.host = result;\n    // opaque host\n    } else if (!this.isSpecial()) {\n      if (exec$1(FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT, input)) return INVALID_HOST;\n      result = '';\n      codePoints = arrayFrom(input);\n      for (index = 0; index < codePoints.length; index++) {\n        result += percentEncode(codePoints[index], C0ControlPercentEncodeSet);\n      }\n      this.host = result;\n    } else {\n      input = toASCII(input);\n      if (exec$1(FORBIDDEN_HOST_CODE_POINT, input)) return INVALID_HOST;\n      result = parseIPv4(input);\n      if (result === null) return INVALID_HOST;\n      this.host = result;\n    }\n  },\n  // https://url.spec.whatwg.org/#cannot-have-a-username-password-port\n  cannotHaveUsernamePasswordPort: function () {\n    return !this.host || this.cannotBeABaseURL || this.scheme == 'file';\n  },\n  // https://url.spec.whatwg.org/#include-credentials\n  includesCredentials: function () {\n    return this.username != '' || this.password != '';\n  },\n  // https://url.spec.whatwg.org/#is-special\n  isSpecial: function () {\n    return hasOwn(specialSchemes, this.scheme);\n  },\n  // https://url.spec.whatwg.org/#shorten-a-urls-path\n  shortenPath: function () {\n    var path = this.path;\n    var pathSize = path.length;\n    if (pathSize && (this.scheme != 'file' || pathSize != 1 || !isWindowsDriveLetter(path[0], true))) {\n      path.length--;\n    }\n  },\n  // https://url.spec.whatwg.org/#concept-url-serializer\n  serialize: function () {\n    var url = this;\n    var scheme = url.scheme;\n    var username = url.username;\n    var password = url.password;\n    var host = url.host;\n    var port = url.port;\n    var path = url.path;\n    var query = url.query;\n    var fragment = url.fragment;\n    var output = scheme + ':';\n    if (host !== null) {\n      output += '//';\n      if (url.includesCredentials()) {\n        output += username + (password ? ':' + password : '') + '@';\n      }\n      output += serializeHost(host);\n      if (port !== null) output += ':' + port;\n    } else if (scheme == 'file') output += '//';\n    output += url.cannotBeABaseURL ? path[0] : path.length ? '/' + join(path, '/') : '';\n    if (query !== null) output += '?' + query;\n    if (fragment !== null) output += '#' + fragment;\n    return output;\n  },\n  // https://url.spec.whatwg.org/#dom-url-href\n  setHref: function (href) {\n    var failure = this.parse(href);\n    if (failure) throw TypeError$1(failure);\n    this.searchParams.update();\n  },\n  // https://url.spec.whatwg.org/#dom-url-origin\n  getOrigin: function () {\n    var scheme = this.scheme;\n    var port = this.port;\n    if (scheme == 'blob') try {\n      return new URLConstructor(scheme.path[0]).origin;\n    } catch (error) {\n      return 'null';\n    }\n    if (scheme == 'file' || !this.isSpecial()) return 'null';\n    return scheme + '://' + serializeHost(this.host) + (port !== null ? ':' + port : '');\n  },\n  // https://url.spec.whatwg.org/#dom-url-protocol\n  getProtocol: function () {\n    return this.scheme + ':';\n  },\n  setProtocol: function (protocol) {\n    this.parse($toString(protocol) + ':', SCHEME_START);\n  },\n  // https://url.spec.whatwg.org/#dom-url-username\n  getUsername: function () {\n    return this.username;\n  },\n  setUsername: function (username) {\n    var codePoints = arrayFrom($toString(username));\n    if (this.cannotHaveUsernamePasswordPort()) return;\n    this.username = '';\n    for (var i = 0; i < codePoints.length; i++) {\n      this.username += percentEncode(codePoints[i], userinfoPercentEncodeSet);\n    }\n  },\n  // https://url.spec.whatwg.org/#dom-url-password\n  getPassword: function () {\n    return this.password;\n  },\n  setPassword: function (password) {\n    var codePoints = arrayFrom($toString(password));\n    if (this.cannotHaveUsernamePasswordPort()) return;\n    this.password = '';\n    for (var i = 0; i < codePoints.length; i++) {\n      this.password += percentEncode(codePoints[i], userinfoPercentEncodeSet);\n    }\n  },\n  // https://url.spec.whatwg.org/#dom-url-host\n  getHost: function () {\n    var host = this.host;\n    var port = this.port;\n    return host === null ? ''\n      : port === null ? serializeHost(host)\n      : serializeHost(host) + ':' + port;\n  },\n  setHost: function (host) {\n    if (this.cannotBeABaseURL) return;\n    this.parse(host, HOST);\n  },\n  // https://url.spec.whatwg.org/#dom-url-hostname\n  getHostname: function () {\n    var host = this.host;\n    return host === null ? '' : serializeHost(host);\n  },\n  setHostname: function (hostname) {\n    if (this.cannotBeABaseURL) return;\n    this.parse(hostname, HOSTNAME);\n  },\n  // https://url.spec.whatwg.org/#dom-url-port\n  getPort: function () {\n    var port = this.port;\n    return port === null ? '' : $toString(port);\n  },\n  setPort: function (port) {\n    if (this.cannotHaveUsernamePasswordPort()) return;\n    port = $toString(port);\n    if (port == '') this.port = null;\n    else this.parse(port, PORT);\n  },\n  // https://url.spec.whatwg.org/#dom-url-pathname\n  getPathname: function () {\n    var path = this.path;\n    return this.cannotBeABaseURL ? path[0] : path.length ? '/' + join(path, '/') : '';\n  },\n  setPathname: function (pathname) {\n    if (this.cannotBeABaseURL) return;\n    this.path = [];\n    this.parse(pathname, PATH_START);\n  },\n  // https://url.spec.whatwg.org/#dom-url-search\n  getSearch: function () {\n    var query = this.query;\n    return query ? '?' + query : '';\n  },\n  setSearch: function (search) {\n    search = $toString(search);\n    if (search == '') {\n      this.query = null;\n    } else {\n      if ('?' == charAt$3(search, 0)) search = stringSlice$3(search, 1);\n      this.query = '';\n      this.parse(search, QUERY);\n    }\n    this.searchParams.update();\n  },\n  // https://url.spec.whatwg.org/#dom-url-searchparams\n  getSearchParams: function () {\n    return this.searchParams.facade;\n  },\n  // https://url.spec.whatwg.org/#dom-url-hash\n  getHash: function () {\n    var fragment = this.fragment;\n    return fragment ? '#' + fragment : '';\n  },\n  setHash: function (hash) {\n    hash = $toString(hash);\n    if (hash == '') {\n      this.fragment = null;\n      return;\n    }\n    if ('#' == charAt$3(hash, 0)) hash = stringSlice$3(hash, 1);\n    this.fragment = '';\n    this.parse(hash, FRAGMENT);\n  },\n  update: function () {\n    this.query = this.searchParams.serialize() || null;\n  }\n};\n\n// `URL` constructor\n// https://url.spec.whatwg.org/#url-class\nvar URLConstructor = function URL(url /* , base */) {\n  var that = anInstance(this, URLPrototype);\n  var base = validateArgumentsLength(arguments.length, 1) > 1 ? arguments[1] : undefined;\n  var state = setInternalState(that, new URLState(url, false, base));\n  if (!DESCRIPTORS) {\n    that.href = state.serialize();\n    that.origin = state.getOrigin();\n    that.protocol = state.getProtocol();\n    that.username = state.getUsername();\n    that.password = state.getPassword();\n    that.host = state.getHost();\n    that.hostname = state.getHostname();\n    that.port = state.getPort();\n    that.pathname = state.getPathname();\n    that.search = state.getSearch();\n    that.searchParams = state.getSearchParams();\n    that.hash = state.getHash();\n  }\n};\n\nvar URLPrototype = URLConstructor.prototype;\n\nvar accessorDescriptor = function (getter, setter) {\n  return {\n    get: function () {\n      return getInternalURLState(this)[getter]();\n    },\n    set: setter && function (value) {\n      return getInternalURLState(this)[setter](value);\n    },\n    configurable: true,\n    enumerable: true\n  };\n};\n\nif (DESCRIPTORS) {\n  // `URL.prototype.href` accessors pair\n  // https://url.spec.whatwg.org/#dom-url-href\n  defineBuiltInAccessor(URLPrototype, 'href', accessorDescriptor('serialize', 'setHref'));\n  // `URL.prototype.origin` getter\n  // https://url.spec.whatwg.org/#dom-url-origin\n  defineBuiltInAccessor(URLPrototype, 'origin', accessorDescriptor('getOrigin'));\n  // `URL.prototype.protocol` accessors pair\n  // https://url.spec.whatwg.org/#dom-url-protocol\n  defineBuiltInAccessor(URLPrototype, 'protocol', accessorDescriptor('getProtocol', 'setProtocol'));\n  // `URL.prototype.username` accessors pair\n  // https://url.spec.whatwg.org/#dom-url-username\n  defineBuiltInAccessor(URLPrototype, 'username', accessorDescriptor('getUsername', 'setUsername'));\n  // `URL.prototype.password` accessors pair\n  // https://url.spec.whatwg.org/#dom-url-password\n  defineBuiltInAccessor(URLPrototype, 'password', accessorDescriptor('getPassword', 'setPassword'));\n  // `URL.prototype.host` accessors pair\n  // https://url.spec.whatwg.org/#dom-url-host\n  defineBuiltInAccessor(URLPrototype, 'host', accessorDescriptor('getHost', 'setHost'));\n  // `URL.prototype.hostname` accessors pair\n  // https://url.spec.whatwg.org/#dom-url-hostname\n  defineBuiltInAccessor(URLPrototype, 'hostname', accessorDescriptor('getHostname', 'setHostname'));\n  // `URL.prototype.port` accessors pair\n  // https://url.spec.whatwg.org/#dom-url-port\n  defineBuiltInAccessor(URLPrototype, 'port', accessorDescriptor('getPort', 'setPort'));\n  // `URL.prototype.pathname` accessors pair\n  // https://url.spec.whatwg.org/#dom-url-pathname\n  defineBuiltInAccessor(URLPrototype, 'pathname', accessorDescriptor('getPathname', 'setPathname'));\n  // `URL.prototype.search` accessors pair\n  // https://url.spec.whatwg.org/#dom-url-search\n  defineBuiltInAccessor(URLPrototype, 'search', accessorDescriptor('getSearch', 'setSearch'));\n  // `URL.prototype.searchParams` getter\n  // https://url.spec.whatwg.org/#dom-url-searchparams\n  defineBuiltInAccessor(URLPrototype, 'searchParams', accessorDescriptor('getSearchParams'));\n  // `URL.prototype.hash` accessors pair\n  // https://url.spec.whatwg.org/#dom-url-hash\n  defineBuiltInAccessor(URLPrototype, 'hash', accessorDescriptor('getHash', 'setHash'));\n}\n\n// `URL.prototype.toJSON` method\n// https://url.spec.whatwg.org/#dom-url-tojson\ndefineBuiltIn$1(URLPrototype, 'toJSON', function toJSON() {\n  return getInternalURLState(this).serialize();\n}, { enumerable: true });\n\n// `URL.prototype.toString` method\n// https://url.spec.whatwg.org/#URL-stringification-behavior\ndefineBuiltIn$1(URLPrototype, 'toString', function toString() {\n  return getInternalURLState(this).serialize();\n}, { enumerable: true });\n\nif (NativeURL) {\n  var nativeCreateObjectURL = NativeURL.createObjectURL;\n  var nativeRevokeObjectURL = NativeURL.revokeObjectURL;\n  // `URL.createObjectURL` method\n  // https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL\n  if (nativeCreateObjectURL) defineBuiltIn$1(URLConstructor, 'createObjectURL', bind(nativeCreateObjectURL, NativeURL));\n  // `URL.revokeObjectURL` method\n  // https://developer.mozilla.org/en-US/docs/Web/API/URL/revokeObjectURL\n  if (nativeRevokeObjectURL) defineBuiltIn$1(URLConstructor, 'revokeObjectURL', bind(nativeRevokeObjectURL, NativeURL));\n}\n\nsetToStringTag(URLConstructor, 'URL');\n\n$$1({ global: true, constructor: true, forced: !USE_NATIVE_URL, sham: !DESCRIPTORS }, {\n  URL: URLConstructor\n});\n\nvar fails$4 = fails$k;\nvar global$3 = global$o;\n\n// babel-minify and Closure Compiler transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError\nvar $RegExp$2 = global$3.RegExp;\n\nvar UNSUPPORTED_Y$1 = fails$4(function () {\n  var re = $RegExp$2('a', 'y');\n  re.lastIndex = 2;\n  return re.exec('abcd') != null;\n});\n\n// UC Browser bug\n// https://github.com/zloirock/core-js/issues/1008\nvar MISSED_STICKY = UNSUPPORTED_Y$1 || fails$4(function () {\n  return !$RegExp$2('a', 'y').sticky;\n});\n\nvar BROKEN_CARET = UNSUPPORTED_Y$1 || fails$4(function () {\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=773687\n  var re = $RegExp$2('^r', 'gy');\n  re.lastIndex = 2;\n  return re.exec('str') != null;\n});\n\nvar regexpStickyHelpers = {\n  BROKEN_CARET: BROKEN_CARET,\n  MISSED_STICKY: MISSED_STICKY,\n  UNSUPPORTED_Y: UNSUPPORTED_Y$1\n};\n\nvar fails$3 = fails$k;\nvar global$2 = global$o;\n\n// babel-minify and Closure Compiler transpiles RegExp('.', 's') -> /./s and it causes SyntaxError\nvar $RegExp$1 = global$2.RegExp;\n\nvar regexpUnsupportedDotAll = fails$3(function () {\n  var re = $RegExp$1('.', 's');\n  return !(re.dotAll && re.exec('\\n') && re.flags === 's');\n});\n\nvar fails$2 = fails$k;\nvar global$1 = global$o;\n\n// babel-minify and Closure Compiler transpiles RegExp('(?<a>b)', 'g') -> /(?<a>b)/g and it causes SyntaxError\nvar $RegExp = global$1.RegExp;\n\nvar regexpUnsupportedNcg = fails$2(function () {\n  var re = $RegExp('(?<a>b)', 'g');\n  return re.exec('b').groups.a !== 'b' ||\n    'b'.replace(re, '$<a>c') !== 'bc';\n});\n\n/* eslint-disable regexp/no-empty-capturing-group, regexp/no-empty-group, regexp/no-lazy-ends -- testing */\n/* eslint-disable regexp/no-useless-quantifier -- testing */\nvar call$2 = functionCall;\nvar uncurryThis$3 = functionUncurryThis;\nvar toString$1 = toString$4;\nvar regexpFlags = regexpFlags$1;\nvar stickyHelpers = regexpStickyHelpers;\nvar shared = shared$4.exports;\nvar create = objectCreate;\nvar getInternalState = internalState.get;\nvar UNSUPPORTED_DOT_ALL = regexpUnsupportedDotAll;\nvar UNSUPPORTED_NCG = regexpUnsupportedNcg;\n\nvar nativeReplace = shared('native-string-replace', String.prototype.replace);\nvar nativeExec = RegExp.prototype.exec;\nvar patchedExec = nativeExec;\nvar charAt$2 = uncurryThis$3(''.charAt);\nvar indexOf = uncurryThis$3(''.indexOf);\nvar replace$1 = uncurryThis$3(''.replace);\nvar stringSlice$2 = uncurryThis$3(''.slice);\n\nvar UPDATES_LAST_INDEX_WRONG = (function () {\n  var re1 = /a/;\n  var re2 = /b*/g;\n  call$2(nativeExec, re1, 'a');\n  call$2(nativeExec, re2, 'a');\n  return re1.lastIndex !== 0 || re2.lastIndex !== 0;\n})();\n\nvar UNSUPPORTED_Y = stickyHelpers.BROKEN_CARET;\n\n// nonparticipating capturing group, copied from es5-shim's String#split patch.\nvar NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;\n\nvar PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG;\n\nif (PATCH) {\n  patchedExec = function exec(string) {\n    var re = this;\n    var state = getInternalState(re);\n    var str = toString$1(string);\n    var raw = state.raw;\n    var result, reCopy, lastIndex, match, i, object, group;\n\n    if (raw) {\n      raw.lastIndex = re.lastIndex;\n      result = call$2(patchedExec, raw, str);\n      re.lastIndex = raw.lastIndex;\n      return result;\n    }\n\n    var groups = state.groups;\n    var sticky = UNSUPPORTED_Y && re.sticky;\n    var flags = call$2(regexpFlags, re);\n    var source = re.source;\n    var charsAdded = 0;\n    var strCopy = str;\n\n    if (sticky) {\n      flags = replace$1(flags, 'y', '');\n      if (indexOf(flags, 'g') === -1) {\n        flags += 'g';\n      }\n\n      strCopy = stringSlice$2(str, re.lastIndex);\n      // Support anchored sticky behavior.\n      if (re.lastIndex > 0 && (!re.multiline || re.multiline && charAt$2(str, re.lastIndex - 1) !== '\\n')) {\n        source = '(?: ' + source + ')';\n        strCopy = ' ' + strCopy;\n        charsAdded++;\n      }\n      // ^(? + rx + ) is needed, in combination with some str slicing, to\n      // simulate the 'y' flag.\n      reCopy = new RegExp('^(?:' + source + ')', flags);\n    }\n\n    if (NPCG_INCLUDED) {\n      reCopy = new RegExp('^' + source + '$(?!\\\\s)', flags);\n    }\n    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;\n\n    match = call$2(nativeExec, sticky ? reCopy : re, strCopy);\n\n    if (sticky) {\n      if (match) {\n        match.input = stringSlice$2(match.input, charsAdded);\n        match[0] = stringSlice$2(match[0], charsAdded);\n        match.index = re.lastIndex;\n        re.lastIndex += match[0].length;\n      } else re.lastIndex = 0;\n    } else if (UPDATES_LAST_INDEX_WRONG && match) {\n      re.lastIndex = re.global ? match.index + match[0].length : lastIndex;\n    }\n    if (NPCG_INCLUDED && match && match.length > 1) {\n      // Fix browsers whose `exec` methods don't consistently return `undefined`\n      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/\n      call$2(nativeReplace, match[0], reCopy, function () {\n        for (i = 1; i < arguments.length - 2; i++) {\n          if (arguments[i] === undefined) match[i] = undefined;\n        }\n      });\n    }\n\n    if (match && groups) {\n      match.groups = object = create(null);\n      for (i = 0; i < groups.length; i++) {\n        group = groups[i];\n        object[group[0]] = match[group[1]];\n      }\n    }\n\n    return match;\n  };\n}\n\nvar regexpExec$2 = patchedExec;\n\nvar $ = _export;\nvar exec = regexpExec$2;\n\n// `RegExp.prototype.exec` method\n// https://tc39.es/ecma262/#sec-regexp.prototype.exec\n$({ target: 'RegExp', proto: true, forced: /./.exec !== exec }, {\n  exec: exec\n});\n\n// TODO: Remove from `core-js@4` since it's moved to entry points\n\nvar uncurryThis$2 = functionUncurryThis;\nvar defineBuiltIn = defineBuiltIn$a;\nvar regexpExec$1 = regexpExec$2;\nvar fails$1 = fails$k;\nvar wellKnownSymbol$1 = wellKnownSymbol$i;\nvar createNonEnumerableProperty = createNonEnumerableProperty$5;\n\nvar SPECIES = wellKnownSymbol$1('species');\nvar RegExpPrototype = RegExp.prototype;\n\nvar fixRegexpWellKnownSymbolLogic = function (KEY, exec, FORCED, SHAM) {\n  var SYMBOL = wellKnownSymbol$1(KEY);\n\n  var DELEGATES_TO_SYMBOL = !fails$1(function () {\n    // String methods call symbol-named RegEp methods\n    var O = {};\n    O[SYMBOL] = function () { return 7; };\n    return ''[KEY](O) != 7;\n  });\n\n  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails$1(function () {\n    // Symbol-named RegExp methods call .exec\n    var execCalled = false;\n    var re = /a/;\n\n    if (KEY === 'split') {\n      // We can't use real regex here since it causes deoptimization\n      // and serious performance degradation in V8\n      // https://github.com/zloirock/core-js/issues/306\n      re = {};\n      // RegExp[@@split] doesn't call the regex's exec method, but first creates\n      // a new one. We need to return the patched regex when creating the new one.\n      re.constructor = {};\n      re.constructor[SPECIES] = function () { return re; };\n      re.flags = '';\n      re[SYMBOL] = /./[SYMBOL];\n    }\n\n    re.exec = function () { execCalled = true; return null; };\n\n    re[SYMBOL]('');\n    return !execCalled;\n  });\n\n  if (\n    !DELEGATES_TO_SYMBOL ||\n    !DELEGATES_TO_EXEC ||\n    FORCED\n  ) {\n    var uncurriedNativeRegExpMethod = uncurryThis$2(/./[SYMBOL]);\n    var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {\n      var uncurriedNativeMethod = uncurryThis$2(nativeMethod);\n      var $exec = regexp.exec;\n      if ($exec === regexpExec$1 || $exec === RegExpPrototype.exec) {\n        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {\n          // The native String method already delegates to @@method (this\n          // polyfilled function), leasing to infinite recursion.\n          // We avoid it by directly calling the native @@method method.\n          return { done: true, value: uncurriedNativeRegExpMethod(regexp, str, arg2) };\n        }\n        return { done: true, value: uncurriedNativeMethod(str, regexp, arg2) };\n      }\n      return { done: false };\n    });\n\n    defineBuiltIn(String.prototype, KEY, methods[0]);\n    defineBuiltIn(RegExpPrototype, SYMBOL, methods[1]);\n  }\n\n  if (SHAM) createNonEnumerableProperty(RegExpPrototype[SYMBOL], 'sham', true);\n};\n\nvar charAt$1 = stringMultibyte.charAt;\n\n// `AdvanceStringIndex` abstract operation\n// https://tc39.es/ecma262/#sec-advancestringindex\nvar advanceStringIndex$1 = function (S, index, unicode) {\n  return index + (unicode ? charAt$1(S, index).length : 1);\n};\n\nvar uncurryThis$1 = functionUncurryThis;\nvar toObject = toObject$5;\n\nvar floor = Math.floor;\nvar charAt = uncurryThis$1(''.charAt);\nvar replace = uncurryThis$1(''.replace);\nvar stringSlice$1 = uncurryThis$1(''.slice);\nvar SUBSTITUTION_SYMBOLS = /\\$([$&'`]|\\d{1,2}|<[^>]*>)/g;\nvar SUBSTITUTION_SYMBOLS_NO_NAMED = /\\$([$&'`]|\\d{1,2})/g;\n\n// `GetSubstitution` abstract operation\n// https://tc39.es/ecma262/#sec-getsubstitution\nvar getSubstitution$1 = function (matched, str, position, captures, namedCaptures, replacement) {\n  var tailPos = position + matched.length;\n  var m = captures.length;\n  var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;\n  if (namedCaptures !== undefined) {\n    namedCaptures = toObject(namedCaptures);\n    symbols = SUBSTITUTION_SYMBOLS;\n  }\n  return replace(replacement, symbols, function (match, ch) {\n    var capture;\n    switch (charAt(ch, 0)) {\n      case '$': return '$';\n      case '&': return matched;\n      case '`': return stringSlice$1(str, 0, position);\n      case \"'\": return stringSlice$1(str, tailPos);\n      case '<':\n        capture = namedCaptures[stringSlice$1(ch, 1, -1)];\n        break;\n      default: // \\d\\d?\n        var n = +ch;\n        if (n === 0) return match;\n        if (n > m) {\n          var f = floor(n / 10);\n          if (f === 0) return match;\n          if (f <= m) return captures[f - 1] === undefined ? charAt(ch, 1) : captures[f - 1] + charAt(ch, 1);\n          return match;\n        }\n        capture = captures[n - 1];\n    }\n    return capture === undefined ? '' : capture;\n  });\n};\n\nvar call$1 = functionCall;\nvar anObject$1 = anObject$g;\nvar isCallable$1 = isCallable$n;\nvar classof = classofRaw$1;\nvar regexpExec = regexpExec$2;\n\nvar $TypeError = TypeError;\n\n// `RegExpExec` abstract operation\n// https://tc39.es/ecma262/#sec-regexpexec\nvar regexpExecAbstract = function (R, S) {\n  var exec = R.exec;\n  if (isCallable$1(exec)) {\n    var result = call$1(exec, R, S);\n    if (result !== null) anObject$1(result);\n    return result;\n  }\n  if (classof(R) === 'RegExp') return call$1(regexpExec, R, S);\n  throw $TypeError('RegExp#exec called on incompatible receiver');\n};\n\nvar apply = functionApply;\nvar call = functionCall;\nvar uncurryThis = functionUncurryThis;\nvar fixRegExpWellKnownSymbolLogic = fixRegexpWellKnownSymbolLogic;\nvar fails = fails$k;\nvar anObject = anObject$g;\nvar isCallable = isCallable$n;\nvar toIntegerOrInfinity = toIntegerOrInfinity$4;\nvar toLength = toLength$2;\nvar toString = toString$4;\nvar requireObjectCoercible = requireObjectCoercible$4;\nvar advanceStringIndex = advanceStringIndex$1;\nvar getMethod = getMethod$4;\nvar getSubstitution = getSubstitution$1;\nvar regExpExec = regexpExecAbstract;\nvar wellKnownSymbol = wellKnownSymbol$i;\n\nvar REPLACE = wellKnownSymbol('replace');\nvar max = Math.max;\nvar min = Math.min;\nvar concat = uncurryThis([].concat);\nvar push = uncurryThis([].push);\nvar stringIndexOf = uncurryThis(''.indexOf);\nvar stringSlice = uncurryThis(''.slice);\n\nvar maybeToString = function (it) {\n  return it === undefined ? it : String(it);\n};\n\n// IE <= 11 replaces $0 with the whole match, as if it was $&\n// https://stackoverflow.com/questions/6024666/getting-ie-to-replace-a-regex-with-the-literal-string-0\nvar REPLACE_KEEPS_$0 = (function () {\n  // eslint-disable-next-line regexp/prefer-escape-replacement-dollar-char -- required for testing\n  return 'a'.replace(/./, '$0') === '$0';\n})();\n\n// Safari <= 13.0.3(?) substitutes nth capture where n>m with an empty string\nvar REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = (function () {\n  if (/./[REPLACE]) {\n    return /./[REPLACE]('a', '$0') === '';\n  }\n  return false;\n})();\n\nvar REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {\n  var re = /./;\n  re.exec = function () {\n    var result = [];\n    result.groups = { a: '7' };\n    return result;\n  };\n  // eslint-disable-next-line regexp/no-useless-dollar-replacements -- false positive\n  return ''.replace(re, '$<a>') !== '7';\n});\n\n// @@replace logic\nfixRegExpWellKnownSymbolLogic('replace', function (_, nativeReplace, maybeCallNative) {\n  var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? '$' : '$0';\n\n  return [\n    // `String.prototype.replace` method\n    // https://tc39.es/ecma262/#sec-string.prototype.replace\n    function replace(searchValue, replaceValue) {\n      var O = requireObjectCoercible(this);\n      var replacer = searchValue == undefined ? undefined : getMethod(searchValue, REPLACE);\n      return replacer\n        ? call(replacer, searchValue, O, replaceValue)\n        : call(nativeReplace, toString(O), searchValue, replaceValue);\n    },\n    // `RegExp.prototype[@@replace]` method\n    // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace\n    function (string, replaceValue) {\n      var rx = anObject(this);\n      var S = toString(string);\n\n      if (\n        typeof replaceValue == 'string' &&\n        stringIndexOf(replaceValue, UNSAFE_SUBSTITUTE) === -1 &&\n        stringIndexOf(replaceValue, '$<') === -1\n      ) {\n        var res = maybeCallNative(nativeReplace, rx, S, replaceValue);\n        if (res.done) return res.value;\n      }\n\n      var functionalReplace = isCallable(replaceValue);\n      if (!functionalReplace) replaceValue = toString(replaceValue);\n\n      var global = rx.global;\n      if (global) {\n        var fullUnicode = rx.unicode;\n        rx.lastIndex = 0;\n      }\n      var results = [];\n      while (true) {\n        var result = regExpExec(rx, S);\n        if (result === null) break;\n\n        push(results, result);\n        if (!global) break;\n\n        var matchStr = toString(result[0]);\n        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);\n      }\n\n      var accumulatedResult = '';\n      var nextSourcePosition = 0;\n      for (var i = 0; i < results.length; i++) {\n        result = results[i];\n\n        var matched = toString(result[0]);\n        var position = max(min(toIntegerOrInfinity(result.index), S.length), 0);\n        var captures = [];\n        // NOTE: This is equivalent to\n        //   captures = result.slice(1).map(maybeToString)\n        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in\n        // the slice polyfill when slicing native arrays) \"doesn't work\" in safari 9 and\n        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.\n        for (var j = 1; j < result.length; j++) push(captures, maybeToString(result[j]));\n        var namedCaptures = result.groups;\n        if (functionalReplace) {\n          var replacerArgs = concat([matched], captures, position, S);\n          if (namedCaptures !== undefined) push(replacerArgs, namedCaptures);\n          var replacement = toString(apply(replaceValue, undefined, replacerArgs));\n        } else {\n          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);\n        }\n        if (position >= nextSourcePosition) {\n          accumulatedResult += stringSlice(S, nextSourcePosition, position) + replacement;\n          nextSourcePosition = position + matched.length;\n        }\n      }\n      return accumulatedResult + stringSlice(S, nextSourcePosition);\n    }\n  ];\n}, !REPLACE_SUPPORTS_NAMED_GROUPS || !REPLACE_KEEPS_$0 || REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE);\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\n\nvar icon = `data:image/png;base64,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`;\n\nconst resolveWalletUrl = (network, walletUrl) => {\n  if (walletUrl) {\n    return walletUrl;\n  }\n  switch (network.networkId) {\n    case \"mainnet\":\n      return \"https://app.mynearwallet.com\";\n    case \"testnet\":\n      return \"https://testnet.mynearwallet.com\";\n    default:\n      throw new Error(\"Invalid wallet url\");\n  }\n};\nconst setupWalletState = (params, network) => __awaiter(void 0, void 0, void 0, function* () {\n  const keyStore = new near_api_js__WEBPACK_IMPORTED_MODULE_0__.keyStores.BrowserLocalStorageKeyStore();\n  const near = yield near_api_js__WEBPACK_IMPORTED_MODULE_0__.connect(Object.assign(Object.assign({\n    keyStore,\n    walletUrl: params.walletUrl\n  }, network), {\n    headers: {}\n  }));\n  const wallet = new near_api_js__WEBPACK_IMPORTED_MODULE_0__.WalletConnection(near, \"near_app\");\n  return {\n    wallet,\n    keyStore\n  };\n});\nconst MyNearWallet = ({\n  metadata,\n  options,\n  store,\n  params,\n  logger,\n  id\n}) => __awaiter(void 0, void 0, void 0, function* () {\n  const _state = yield setupWalletState(params, options.network);\n  const getAccounts = () => __awaiter(void 0, void 0, void 0, function* () {\n    const accountId = _state.wallet.getAccountId();\n    const account = _state.wallet.account();\n    if (!accountId || !account) {\n      return [];\n    }\n    const publicKey = yield account.connection.signer.getPublicKey(account.accountId, options.network.networkId);\n    return [{\n      accountId,\n      publicKey: publicKey ? publicKey.toString() : \"\"\n    }];\n  });\n  const transformTransactions = transactions => __awaiter(void 0, void 0, void 0, function* () {\n    const account = _state.wallet.account();\n    const {\n      networkId,\n      signer,\n      provider\n    } = account.connection;\n    const localKey = yield signer.getPublicKey(account.accountId, networkId);\n    return Promise.all(transactions.map((transaction, index) => __awaiter(void 0, void 0, void 0, function* () {\n      const actions = transaction.actions.map(action => (0,_near_wallet_selector_wallet_utils__WEBPACK_IMPORTED_MODULE_1__.createAction)(action));\n      const accessKey = yield account.accessKeyForTransaction(transaction.receiverId, actions, localKey);\n      if (!accessKey) {\n        throw new Error(`Failed to find matching key for transaction sent to ${transaction.receiverId}`);\n      }\n      const block = yield provider.block({\n        finality: \"final\"\n      });\n      return near_api_js__WEBPACK_IMPORTED_MODULE_0__.transactions.createTransaction(account.accountId, near_api_js__WEBPACK_IMPORTED_MODULE_0__.utils.PublicKey.from(accessKey.public_key), transaction.receiverId, accessKey.access_key.nonce + index + 1, actions, near_api_js__WEBPACK_IMPORTED_MODULE_0__.utils.serialize.base_decode(block.header.hash));\n    })));\n  });\n  return {\n    signIn({\n      contractId,\n      methodNames,\n      successUrl,\n      failureUrl\n    }) {\n      return __awaiter(this, void 0, void 0, function* () {\n        const existingAccounts = yield getAccounts();\n        if (existingAccounts.length) {\n          return existingAccounts;\n        }\n        yield _state.wallet.requestSignIn({\n          contractId,\n          methodNames,\n          successUrl,\n          failureUrl\n        });\n        return getAccounts();\n      });\n    },\n    signOut() {\n      return __awaiter(this, void 0, void 0, function* () {\n        if (_state.wallet.isSignedIn()) {\n          _state.wallet.signOut();\n        }\n      });\n    },\n    getAccounts() {\n      return __awaiter(this, void 0, void 0, function* () {\n        return getAccounts();\n      });\n    },\n    verifyOwner() {\n      return __awaiter(this, void 0, void 0, function* () {\n        throw new Error(`Method not supported by ${metadata.name}`);\n      });\n    },\n    signMessage({\n      message,\n      nonce,\n      recipient,\n      callbackUrl,\n      state\n    }) {\n      return __awaiter(this, void 0, void 0, function* () {\n        logger.log(\"sign message\", {\n          message\n        });\n        if (id !== \"my-near-wallet\") {\n          throw Error(`The signMessage method is not supported by ${metadata.name}`);\n        }\n        const locationUrl = typeof window !== \"undefined\" ? window.location.href : \"\";\n        const url = callbackUrl || locationUrl;\n        if (!url) {\n          throw new Error(`The callbackUrl is missing for ${metadata.name}`);\n        }\n        const href = new URL(params.walletUrl);\n        href.pathname = \"sign-message\";\n        href.searchParams.append(\"message\", message);\n        href.searchParams.append(\"nonce\", nonce.toString(\"base64\"));\n        href.searchParams.append(\"recipient\", recipient);\n        href.searchParams.append(\"callbackUrl\", url);\n        if (state) {\n          href.searchParams.append(\"state\", state);\n        }\n        window.location.replace(href.toString());\n        return;\n      });\n    },\n    signAndSendTransaction({\n      signerId,\n      receiverId,\n      actions,\n      callbackUrl\n    }) {\n      return __awaiter(this, void 0, void 0, function* () {\n        logger.log(\"signAndSendTransaction\", {\n          signerId,\n          receiverId,\n          actions,\n          callbackUrl\n        });\n        const {\n          contract\n        } = store.getState();\n        if (!_state.wallet.isSignedIn() || !contract) {\n          throw new Error(\"Wallet not signed in\");\n        }\n        const account = _state.wallet.account();\n        return account[\"signAndSendTransaction\"]({\n          receiverId: receiverId || contract.contractId,\n          actions: actions.map(action => (0,_near_wallet_selector_wallet_utils__WEBPACK_IMPORTED_MODULE_1__.createAction)(action)),\n          walletCallbackUrl: callbackUrl\n        });\n      });\n    },\n    signAndSendTransactions({\n      transactions,\n      callbackUrl\n    }) {\n      return __awaiter(this, void 0, void 0, function* () {\n        logger.log(\"signAndSendTransactions\", {\n          transactions,\n          callbackUrl\n        });\n        if (!_state.wallet.isSignedIn()) {\n          throw new Error(\"Wallet not signed in\");\n        }\n        return _state.wallet.requestSignTransactions({\n          transactions: yield transformTransactions(transactions),\n          callbackUrl\n        });\n      });\n    },\n    buildImportAccountsUrl() {\n      return `${params.walletUrl}/batch-import`;\n    }\n  };\n});\nfunction setupMyNearWallet({\n  walletUrl,\n  iconUrl = icon,\n  deprecated = false,\n  successUrl = \"\",\n  failureUrl = \"\"\n} = {}) {\n  return moduleOptions => __awaiter(this, void 0, void 0, function* () {\n    return {\n      id: \"my-near-wallet\",\n      type: \"browser\",\n      metadata: {\n        name: \"MyNearWallet\",\n        description: \"NEAR wallet to store, buy, send and stake assets for DeFi.\",\n        iconUrl,\n        deprecated,\n        available: true,\n        successUrl,\n        failureUrl,\n        walletUrl: resolveWalletUrl(moduleOptions.options.network, walletUrl)\n      },\n      init: options => {\n        return MyNearWallet(Object.assign(Object.assign({}, options), {\n          params: {\n            walletUrl: resolveWalletUrl(options.options.network, walletUrl)\n          }\n        }));\n      }\n    };\n  });\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5lYXItd2FsbGV0LXNlbGVjdG9yL215LW5lYXItd2FsbGV0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF1QztBQUMyQjs7QUFFbEU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixjQUFjOztBQUUvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxPQUFPLG1CQUFtQixhQUFhO0FBQ3hFLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixhQUFhO0FBQ3pDO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBLDhFQUE4RSxNQUFNOztBQUVwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsaUNBQWlDO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMENBQTBDOztBQUUx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QTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QscUJBQXFCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsSUFBSTtBQUNKLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxhQUFhO0FBQ2pGO0FBQ0EsdUJBQXVCLGFBQWEsZ0JBQWdCLGFBQWE7QUFDakU7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGFBQWE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSLE1BQU07QUFDTixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxlQUFlO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixxQkFBcUIsYUFBYTtBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU8sSUFBSSxjQUFjO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sZ0JBQWdCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTSxtRkFBbUY7QUFDekY7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsZ0JBQWdCO0FBQzlFO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFVBQVU7QUFDekQsRUFBRSxnQkFBZ0I7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdCQUFnQjtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlFQUF5RSxhQUFhO0FBQ3RGLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sOEVBQThFO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxrRkFBa0Y7QUFDeEY7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxjQUFjO0FBQzdFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sNEVBQTRFO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0scUVBQXFFO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLG1FQUFtRTtBQUN6RTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNkJBQTZCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwyQkFBMkI7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsSUFBSSxrQkFBa0I7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxJQUFJLGtCQUFrQjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsTUFBTSw4RUFBOEU7QUFDcEY7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJLDBEQUEwRDtBQUM5RDtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBOztBQUVBLDRCQUE0QixtQkFBbUI7O0FBRS9DO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxlQUFlO0FBQ2YsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsSUFBSTtBQUM3QyxrREFBa0QsSUFBSTs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFD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QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRTZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbnVyc2VibG9jLy4vbm9kZV9tb2R1bGVzL0BuZWFyLXdhbGxldC1zZWxlY3Rvci9teS1uZWFyLXdhbGxldC9pbmRleC5qcz9mZDYzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIG5lYXJBUEkgZnJvbSAnbmVhci1hcGktanMnO1xuaW1wb3J0IHsgY3JlYXRlQWN0aW9uIH0gZnJvbSAnQG5lYXItd2FsbGV0LXNlbGVjdG9yL3dhbGxldC11dGlscyc7XG5cbnZhciBjb21tb25qc0dsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9O1xuXG52YXIgY2hlY2sgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ICYmIGl0Lk1hdGggPT0gTWF0aCAmJiBpdDtcbn07XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG52YXIgZ2xvYmFsJG8gPVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1nbG9iYWwtdGhpcyAtLSBzYWZlXG4gIGNoZWNrKHR5cGVvZiBnbG9iYWxUaGlzID09ICdvYmplY3QnICYmIGdsb2JhbFRoaXMpIHx8XG4gIGNoZWNrKHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93KSB8fFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzIC0tIHNhZmVcbiAgY2hlY2sodHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZikgfHxcbiAgY2hlY2sodHlwZW9mIGNvbW1vbmpzR2xvYmFsID09ICdvYmplY3QnICYmIGNvbW1vbmpzR2xvYmFsKSB8fFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmMgLS0gZmFsbGJhY2tcbiAgKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pKCkgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxudmFyIG9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHt9O1xuXG52YXIgZmFpbHMkayA9IGZ1bmN0aW9uIChleGVjKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhZXhlYygpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG52YXIgZmFpbHMkaiA9IGZhaWxzJGs7XG5cbi8vIERldGVjdCBJRTgncyBpbmNvbXBsZXRlIGRlZmluZVByb3BlcnR5IGltcGxlbWVudGF0aW9uXG52YXIgZGVzY3JpcHRvcnMgPSAhZmFpbHMkaihmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAxLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KVsxXSAhPSA3O1xufSk7XG5cbnZhciBmYWlscyRpID0gZmFpbHMkaztcblxudmFyIGZ1bmN0aW9uQmluZE5hdGl2ZSA9ICFmYWlscyRpKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tZnVuY3Rpb24tcHJvdG90eXBlLWJpbmQgLS0gc2FmZVxuICB2YXIgdGVzdCA9IChmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0pLmJpbmQoKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGlucyAtLSBzYWZlXG4gIHJldHVybiB0eXBlb2YgdGVzdCAhPSAnZnVuY3Rpb24nIHx8IHRlc3QuaGFzT3duUHJvcGVydHkoJ3Byb3RvdHlwZScpO1xufSk7XG5cbnZhciBOQVRJVkVfQklORCQzID0gZnVuY3Rpb25CaW5kTmF0aXZlO1xuXG52YXIgY2FsbCRrID0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGw7XG5cbnZhciBmdW5jdGlvbkNhbGwgPSBOQVRJVkVfQklORCQzID8gY2FsbCRrLmJpbmQoY2FsbCRrKSA6IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGNhbGwkay5hcHBseShjYWxsJGssIGFyZ3VtZW50cyk7XG59O1xuXG52YXIgb2JqZWN0UHJvcGVydHlJc0VudW1lcmFibGUgPSB7fTtcblxudmFyICRwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG4vLyBOYXNob3JuIH4gSkRLOCBidWdcbnZhciBOQVNIT1JOX0JVRyA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvciQzICYmICEkcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh7IDE6IDIgfSwgMSk7XG5cbi8vIGBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlYCBtZXRob2QgaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eWlzZW51bWVyYWJsZVxub2JqZWN0UHJvcGVydHlJc0VudW1lcmFibGUuZiA9IE5BU0hPUk5fQlVHID8gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoVikge1xuICB2YXIgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvciQzKHRoaXMsIFYpO1xuICByZXR1cm4gISFkZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IuZW51bWVyYWJsZTtcbn0gOiAkcHJvcGVydHlJc0VudW1lcmFibGU7XG5cbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkNSA9IGZ1bmN0aW9uIChiaXRtYXAsIHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZTogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGU6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWU6IHZhbHVlXG4gIH07XG59O1xuXG52YXIgTkFUSVZFX0JJTkQkMiA9IGZ1bmN0aW9uQmluZE5hdGl2ZTtcblxudmFyIEZ1bmN0aW9uUHJvdG90eXBlJDIgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG52YXIgYmluZCQ4ID0gRnVuY3Rpb25Qcm90b3R5cGUkMi5iaW5kO1xudmFyIGNhbGwkaiA9IEZ1bmN0aW9uUHJvdG90eXBlJDIuY2FsbDtcbnZhciB1bmN1cnJ5VGhpcyRtID0gTkFUSVZFX0JJTkQkMiAmJiBiaW5kJDguYmluZChjYWxsJGosIGNhbGwkaik7XG5cbnZhciBmdW5jdGlvblVuY3VycnlUaGlzID0gTkFUSVZFX0JJTkQkMiA/IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gZm4gJiYgdW5jdXJyeVRoaXMkbShmbik7XG59IDogZnVuY3Rpb24gKGZuKSB7XG4gIHJldHVybiBmbiAmJiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNhbGwkai5hcHBseShmbiwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG5cbnZhciB1bmN1cnJ5VGhpcyRsID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcblxudmFyIHRvU3RyaW5nJDYgPSB1bmN1cnJ5VGhpcyRsKHt9LnRvU3RyaW5nKTtcbnZhciBzdHJpbmdTbGljZSQ2ID0gdW5jdXJyeVRoaXMkbCgnJy5zbGljZSk7XG5cbnZhciBjbGFzc29mUmF3JDEgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHN0cmluZ1NsaWNlJDYodG9TdHJpbmckNihpdCksIDgsIC0xKTtcbn07XG5cbnZhciB1bmN1cnJ5VGhpcyRrID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBmYWlscyRoID0gZmFpbHMkaztcbnZhciBjbGFzc29mJDcgPSBjbGFzc29mUmF3JDE7XG5cbnZhciAkT2JqZWN0JDQgPSBPYmplY3Q7XG52YXIgc3BsaXQkMyA9IHVuY3VycnlUaGlzJGsoJycuc3BsaXQpO1xuXG4vLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xudmFyIGluZGV4ZWRPYmplY3QgPSBmYWlscyRoKGZ1bmN0aW9uICgpIHtcbiAgLy8gdGhyb3dzIGFuIGVycm9yIGluIHJoaW5vLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvcmhpbm8vaXNzdWVzLzM0NlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zIC0tIHNhZmVcbiAgcmV0dXJuICEkT2JqZWN0JDQoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKTtcbn0pID8gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBjbGFzc29mJDcoaXQpID09ICdTdHJpbmcnID8gc3BsaXQkMyhpdCwgJycpIDogJE9iamVjdCQ0KGl0KTtcbn0gOiAkT2JqZWN0JDQ7XG5cbnZhciAkVHlwZUVycm9yJGMgPSBUeXBlRXJyb3I7XG5cbi8vIGBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcmVxdWlyZW9iamVjdGNvZXJjaWJsZVxudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUkNCA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgPT0gdW5kZWZpbmVkKSB0aHJvdyAkVHlwZUVycm9yJGMoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcblxuLy8gdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcbnZhciBJbmRleGVkT2JqZWN0JDEgPSBpbmRleGVkT2JqZWN0O1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUkMyA9IHJlcXVpcmVPYmplY3RDb2VyY2libGUkNDtcblxudmFyIHRvSW5kZXhlZE9iamVjdCQ1ID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBJbmRleGVkT2JqZWN0JDEocmVxdWlyZU9iamVjdENvZXJjaWJsZSQzKGl0KSk7XG59O1xuXG4vLyBgSXNDYWxsYWJsZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWlzY2FsbGFibGVcbnZhciBpc0NhbGxhYmxlJG4gPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmd1bWVudCA9PSAnZnVuY3Rpb24nO1xufTtcblxudmFyIGlzQ2FsbGFibGUkbSA9IGlzQ2FsbGFibGUkbjtcblxudmFyIGlzT2JqZWN0JDggPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogaXNDYWxsYWJsZSRtKGl0KTtcbn07XG5cbnZhciBnbG9iYWwkbiA9IGdsb2JhbCRvO1xudmFyIGlzQ2FsbGFibGUkbCA9IGlzQ2FsbGFibGUkbjtcblxudmFyIGFGdW5jdGlvbiA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gaXNDYWxsYWJsZSRsKGFyZ3VtZW50KSA/IGFyZ3VtZW50IDogdW5kZWZpbmVkO1xufTtcblxudmFyIGdldEJ1aWx0SW4kOCA9IGZ1bmN0aW9uIChuYW1lc3BhY2UsIG1ldGhvZCkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBhRnVuY3Rpb24oZ2xvYmFsJG5bbmFtZXNwYWNlXSkgOiBnbG9iYWwkbltuYW1lc3BhY2VdICYmIGdsb2JhbCRuW25hbWVzcGFjZV1bbWV0aG9kXTtcbn07XG5cbnZhciB1bmN1cnJ5VGhpcyRqID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcblxudmFyIG9iamVjdElzUHJvdG90eXBlT2YgPSB1bmN1cnJ5VGhpcyRqKHt9LmlzUHJvdG90eXBlT2YpO1xuXG52YXIgZ2V0QnVpbHRJbiQ3ID0gZ2V0QnVpbHRJbiQ4O1xuXG52YXIgZW5naW5lVXNlckFnZW50ID0gZ2V0QnVpbHRJbiQ3KCduYXZpZ2F0b3InLCAndXNlckFnZW50JykgfHwgJyc7XG5cbnZhciBnbG9iYWwkbSA9IGdsb2JhbCRvO1xudmFyIHVzZXJBZ2VudCQzID0gZW5naW5lVXNlckFnZW50O1xuXG52YXIgcHJvY2VzcyQzID0gZ2xvYmFsJG0ucHJvY2VzcztcbnZhciBEZW5vJDEgPSBnbG9iYWwkbS5EZW5vO1xudmFyIHZlcnNpb25zID0gcHJvY2VzcyQzICYmIHByb2Nlc3MkMy52ZXJzaW9ucyB8fCBEZW5vJDEgJiYgRGVubyQxLnZlcnNpb247XG52YXIgdjggPSB2ZXJzaW9ucyAmJiB2ZXJzaW9ucy52ODtcbnZhciBtYXRjaCwgdmVyc2lvbjtcblxuaWYgKHY4KSB7XG4gIG1hdGNoID0gdjguc3BsaXQoJy4nKTtcbiAgLy8gaW4gb2xkIENocm9tZSwgdmVyc2lvbnMgb2YgVjggaXNuJ3QgVjggPSBDaHJvbWUgLyAxMFxuICAvLyBidXQgdGhlaXIgY29ycmVjdCB2ZXJzaW9ucyBhcmUgbm90IGludGVyZXN0aW5nIGZvciB1c1xuICB2ZXJzaW9uID0gbWF0Y2hbMF0gPiAwICYmIG1hdGNoWzBdIDwgNCA/IDEgOiArKG1hdGNoWzBdICsgbWF0Y2hbMV0pO1xufVxuXG4vLyBCcm93c2VyRlMgTm9kZUpTIGBwcm9jZXNzYCBwb2x5ZmlsbCBpbmNvcnJlY3RseSBzZXQgYC52OGAgdG8gYDAuMGBcbi8vIHNvIGNoZWNrIGB1c2VyQWdlbnRgIGV2ZW4gaWYgYC52OGAgZXhpc3RzLCBidXQgMFxuaWYgKCF2ZXJzaW9uICYmIHVzZXJBZ2VudCQzKSB7XG4gIG1hdGNoID0gdXNlckFnZW50JDMubWF0Y2goL0VkZ2VcXC8oXFxkKykvKTtcbiAgaWYgKCFtYXRjaCB8fCBtYXRjaFsxXSA+PSA3NCkge1xuICAgIG1hdGNoID0gdXNlckFnZW50JDMubWF0Y2goL0Nocm9tZVxcLyhcXGQrKS8pO1xuICAgIGlmIChtYXRjaCkgdmVyc2lvbiA9ICttYXRjaFsxXTtcbiAgfVxufVxuXG52YXIgZW5naW5lVjhWZXJzaW9uID0gdmVyc2lvbjtcblxuLyogZXNsaW50LWRpc2FibGUgZXMteC9uby1zeW1ib2wgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmcgKi9cblxudmFyIFY4X1ZFUlNJT04kMSA9IGVuZ2luZVY4VmVyc2lvbjtcbnZhciBmYWlscyRnID0gZmFpbHMkaztcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5c3ltYm9scyAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xudmFyIG5hdGl2ZVN5bWJvbCA9ICEhT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyAmJiAhZmFpbHMkZyhmdW5jdGlvbiAoKSB7XG4gIHZhciBzeW1ib2wgPSBTeW1ib2woKTtcbiAgLy8gQ2hyb21lIDM4IFN5bWJvbCBoYXMgaW5jb3JyZWN0IHRvU3RyaW5nIGNvbnZlcnNpb25cbiAgLy8gYGdldC1vd24tcHJvcGVydHktc3ltYm9sc2AgcG9seWZpbGwgc3ltYm9scyBjb252ZXJ0ZWQgdG8gb2JqZWN0IGFyZSBub3QgU3ltYm9sIGluc3RhbmNlc1xuICByZXR1cm4gIVN0cmluZyhzeW1ib2wpIHx8ICEoT2JqZWN0KHN5bWJvbCkgaW5zdGFuY2VvZiBTeW1ib2wpIHx8XG4gICAgLy8gQ2hyb21lIDM4LTQwIHN5bWJvbHMgYXJlIG5vdCBpbmhlcml0ZWQgZnJvbSBET00gY29sbGVjdGlvbnMgcHJvdG90eXBlcyB0byBpbnN0YW5jZXNcbiAgICAhU3ltYm9sLnNoYW0gJiYgVjhfVkVSU0lPTiQxICYmIFY4X1ZFUlNJT04kMSA8IDQxO1xufSk7XG5cbi8qIGVzbGludC1kaXNhYmxlIGVzLXgvbm8tc3ltYm9sIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nICovXG5cbnZhciBOQVRJVkVfU1lNQk9MJDEgPSBuYXRpdmVTeW1ib2w7XG5cbnZhciB1c2VTeW1ib2xBc1VpZCA9IE5BVElWRV9TWU1CT0wkMVxuICAmJiAhU3ltYm9sLnNoYW1cbiAgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSAnc3ltYm9sJztcblxudmFyIGdldEJ1aWx0SW4kNiA9IGdldEJ1aWx0SW4kODtcbnZhciBpc0NhbGxhYmxlJGsgPSBpc0NhbGxhYmxlJG47XG52YXIgaXNQcm90b3R5cGVPZiQzID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbnZhciBVU0VfU1lNQk9MX0FTX1VJRCQxID0gdXNlU3ltYm9sQXNVaWQ7XG5cbnZhciAkT2JqZWN0JDMgPSBPYmplY3Q7XG5cbnZhciBpc1N5bWJvbCQyID0gVVNFX1NZTUJPTF9BU19VSUQkMSA/IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnO1xufSA6IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgJFN5bWJvbCA9IGdldEJ1aWx0SW4kNignU3ltYm9sJyk7XG4gIHJldHVybiBpc0NhbGxhYmxlJGsoJFN5bWJvbCkgJiYgaXNQcm90b3R5cGVPZiQzKCRTeW1ib2wucHJvdG90eXBlLCAkT2JqZWN0JDMoaXQpKTtcbn07XG5cbnZhciAkU3RyaW5nJDMgPSBTdHJpbmc7XG5cbnZhciB0cnlUb1N0cmluZyQ0ID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICRTdHJpbmckMyhhcmd1bWVudCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuICdPYmplY3QnO1xuICB9XG59O1xuXG52YXIgaXNDYWxsYWJsZSRqID0gaXNDYWxsYWJsZSRuO1xudmFyIHRyeVRvU3RyaW5nJDMgPSB0cnlUb1N0cmluZyQ0O1xuXG52YXIgJFR5cGVFcnJvciRiID0gVHlwZUVycm9yO1xuXG4vLyBgQXNzZXJ0OiBJc0NhbGxhYmxlKGFyZ3VtZW50KSBpcyB0cnVlYFxudmFyIGFDYWxsYWJsZSQ3ID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmIChpc0NhbGxhYmxlJGooYXJndW1lbnQpKSByZXR1cm4gYXJndW1lbnQ7XG4gIHRocm93ICRUeXBlRXJyb3IkYih0cnlUb1N0cmluZyQzKGFyZ3VtZW50KSArICcgaXMgbm90IGEgZnVuY3Rpb24nKTtcbn07XG5cbnZhciBhQ2FsbGFibGUkNiA9IGFDYWxsYWJsZSQ3O1xuXG4vLyBgR2V0TWV0aG9kYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtZ2V0bWV0aG9kXG52YXIgZ2V0TWV0aG9kJDQgPSBmdW5jdGlvbiAoViwgUCkge1xuICB2YXIgZnVuYyA9IFZbUF07XG4gIHJldHVybiBmdW5jID09IG51bGwgPyB1bmRlZmluZWQgOiBhQ2FsbGFibGUkNihmdW5jKTtcbn07XG5cbnZhciBjYWxsJGkgPSBmdW5jdGlvbkNhbGw7XG52YXIgaXNDYWxsYWJsZSRpID0gaXNDYWxsYWJsZSRuO1xudmFyIGlzT2JqZWN0JDcgPSBpc09iamVjdCQ4O1xuXG52YXIgJFR5cGVFcnJvciRhID0gVHlwZUVycm9yO1xuXG4vLyBgT3JkaW5hcnlUb1ByaW1pdGl2ZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9yZGluYXJ5dG9wcmltaXRpdmVcbnZhciBvcmRpbmFyeVRvUHJpbWl0aXZlJDEgPSBmdW5jdGlvbiAoaW5wdXQsIHByZWYpIHtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmIChwcmVmID09PSAnc3RyaW5nJyAmJiBpc0NhbGxhYmxlJGkoZm4gPSBpbnB1dC50b1N0cmluZykgJiYgIWlzT2JqZWN0JDcodmFsID0gY2FsbCRpKGZuLCBpbnB1dCkpKSByZXR1cm4gdmFsO1xuICBpZiAoaXNDYWxsYWJsZSRpKGZuID0gaW5wdXQudmFsdWVPZikgJiYgIWlzT2JqZWN0JDcodmFsID0gY2FsbCRpKGZuLCBpbnB1dCkpKSByZXR1cm4gdmFsO1xuICBpZiAocHJlZiAhPT0gJ3N0cmluZycgJiYgaXNDYWxsYWJsZSRpKGZuID0gaW5wdXQudG9TdHJpbmcpICYmICFpc09iamVjdCQ3KHZhbCA9IGNhbGwkaShmbiwgaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgdGhyb3cgJFR5cGVFcnJvciRhKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTtcblxudmFyIHNoYXJlZCQ0ID0ge2V4cG9ydHM6IHt9fTtcblxudmFyIGlzUHVyZSA9IGZhbHNlO1xuXG52YXIgZ2xvYmFsJGwgPSBnbG9iYWwkbztcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcbnZhciBkZWZpbmVQcm9wZXJ0eSQ2ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG52YXIgZGVmaW5lR2xvYmFsUHJvcGVydHkkMyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgZGVmaW5lUHJvcGVydHkkNihnbG9iYWwkbCwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBnbG9iYWwkbFtrZXldID0gdmFsdWU7XG4gIH0gcmV0dXJuIHZhbHVlO1xufTtcblxudmFyIGdsb2JhbCRrID0gZ2xvYmFsJG87XG52YXIgZGVmaW5lR2xvYmFsUHJvcGVydHkkMiA9IGRlZmluZUdsb2JhbFByb3BlcnR5JDM7XG5cbnZhciBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJztcbnZhciBzdG9yZSQzID0gZ2xvYmFsJGtbU0hBUkVEXSB8fCBkZWZpbmVHbG9iYWxQcm9wZXJ0eSQyKFNIQVJFRCwge30pO1xuXG52YXIgc2hhcmVkU3RvcmUgPSBzdG9yZSQzO1xuXG52YXIgc3RvcmUkMiA9IHNoYXJlZFN0b3JlO1xuXG4oc2hhcmVkJDQuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHJldHVybiBzdG9yZSQyW2tleV0gfHwgKHN0b3JlJDJba2V5XSA9IHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IHt9KTtcbn0pKCd2ZXJzaW9ucycsIFtdKS5wdXNoKHtcbiAgdmVyc2lvbjogJzMuMjMuMycsXG4gIG1vZGU6ICdnbG9iYWwnLFxuICBjb3B5cmlnaHQ6ICfCqSAyMDE0LTIwMjIgRGVuaXMgUHVzaGthcmV2ICh6bG9pcm9jay5ydSknLFxuICBsaWNlbnNlOiAnaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvYmxvYi92My4yMy4zL0xJQ0VOU0UnLFxuICBzb3VyY2U6ICdodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcydcbn0pO1xuXG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSQyID0gcmVxdWlyZU9iamVjdENvZXJjaWJsZSQ0O1xuXG52YXIgJE9iamVjdCQyID0gT2JqZWN0O1xuXG4vLyBgVG9PYmplY3RgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b29iamVjdFxudmFyIHRvT2JqZWN0JDUgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuICRPYmplY3QkMihyZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDIoYXJndW1lbnQpKTtcbn07XG5cbnZhciB1bmN1cnJ5VGhpcyRpID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciB0b09iamVjdCQ0ID0gdG9PYmplY3QkNTtcblxudmFyIGhhc093blByb3BlcnR5ID0gdW5jdXJyeVRoaXMkaSh7fS5oYXNPd25Qcm9wZXJ0eSk7XG5cbi8vIGBIYXNPd25Qcm9wZXJ0eWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWhhc293bnByb3BlcnR5XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtaGFzb3duIC0tIHNhZmVcbnZhciBoYXNPd25Qcm9wZXJ0eV8xID0gT2JqZWN0Lmhhc093biB8fCBmdW5jdGlvbiBoYXNPd24oaXQsIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkodG9PYmplY3QkNChpdCksIGtleSk7XG59O1xuXG52YXIgdW5jdXJyeVRoaXMkaCA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG5cbnZhciBpZCA9IDA7XG52YXIgcG9zdGZpeCA9IE1hdGgucmFuZG9tKCk7XG52YXIgdG9TdHJpbmckNSA9IHVuY3VycnlUaGlzJGgoMS4wLnRvU3RyaW5nKTtcblxudmFyIHVpZCQyID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gJ1N5bWJvbCgnICsgKGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXkpICsgJylfJyArIHRvU3RyaW5nJDUoKytpZCArIHBvc3RmaXgsIDM2KTtcbn07XG5cbnZhciBnbG9iYWwkaiA9IGdsb2JhbCRvO1xudmFyIHNoYXJlZCQzID0gc2hhcmVkJDQuZXhwb3J0cztcbnZhciBoYXNPd24kYyA9IGhhc093blByb3BlcnR5XzE7XG52YXIgdWlkJDEgPSB1aWQkMjtcbnZhciBOQVRJVkVfU1lNQk9MID0gbmF0aXZlU3ltYm9sO1xudmFyIFVTRV9TWU1CT0xfQVNfVUlEID0gdXNlU3ltYm9sQXNVaWQ7XG5cbnZhciBXZWxsS25vd25TeW1ib2xzU3RvcmUgPSBzaGFyZWQkMygnd2tzJyk7XG52YXIgU3ltYm9sJDEgPSBnbG9iYWwkai5TeW1ib2w7XG52YXIgc3ltYm9sRm9yID0gU3ltYm9sJDEgJiYgU3ltYm9sJDFbJ2ZvciddO1xudmFyIGNyZWF0ZVdlbGxLbm93blN5bWJvbCA9IFVTRV9TWU1CT0xfQVNfVUlEID8gU3ltYm9sJDEgOiBTeW1ib2wkMSAmJiBTeW1ib2wkMS53aXRob3V0U2V0dGVyIHx8IHVpZCQxO1xuXG52YXIgd2VsbEtub3duU3ltYm9sJGkgPSBmdW5jdGlvbiAobmFtZSkge1xuICBpZiAoIWhhc093biRjKFdlbGxLbm93blN5bWJvbHNTdG9yZSwgbmFtZSkgfHwgIShOQVRJVkVfU1lNQk9MIHx8IHR5cGVvZiBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV0gPT0gJ3N0cmluZycpKSB7XG4gICAgdmFyIGRlc2NyaXB0aW9uID0gJ1N5bWJvbC4nICsgbmFtZTtcbiAgICBpZiAoTkFUSVZFX1NZTUJPTCAmJiBoYXNPd24kYyhTeW1ib2wkMSwgbmFtZSkpIHtcbiAgICAgIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9IFN5bWJvbCQxW25hbWVdO1xuICAgIH0gZWxzZSBpZiAoVVNFX1NZTUJPTF9BU19VSUQgJiYgc3ltYm9sRm9yKSB7XG4gICAgICBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV0gPSBzeW1ib2xGb3IoZGVzY3JpcHRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV0gPSBjcmVhdGVXZWxsS25vd25TeW1ib2woZGVzY3JpcHRpb24pO1xuICAgIH1cbiAgfSByZXR1cm4gV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdO1xufTtcblxudmFyIGNhbGwkaCA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBpc09iamVjdCQ2ID0gaXNPYmplY3QkODtcbnZhciBpc1N5bWJvbCQxID0gaXNTeW1ib2wkMjtcbnZhciBnZXRNZXRob2QkMyA9IGdldE1ldGhvZCQ0O1xudmFyIG9yZGluYXJ5VG9QcmltaXRpdmUgPSBvcmRpbmFyeVRvUHJpbWl0aXZlJDE7XG52YXIgd2VsbEtub3duU3ltYm9sJGggPSB3ZWxsS25vd25TeW1ib2wkaTtcblxudmFyICRUeXBlRXJyb3IkOSA9IFR5cGVFcnJvcjtcbnZhciBUT19QUklNSVRJVkUgPSB3ZWxsS25vd25TeW1ib2wkaCgndG9QcmltaXRpdmUnKTtcblxuLy8gYFRvUHJpbWl0aXZlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9wcmltaXRpdmVcbnZhciB0b1ByaW1pdGl2ZSQxID0gZnVuY3Rpb24gKGlucHV0LCBwcmVmKSB7XG4gIGlmICghaXNPYmplY3QkNihpbnB1dCkgfHwgaXNTeW1ib2wkMShpbnB1dCkpIHJldHVybiBpbnB1dDtcbiAgdmFyIGV4b3RpY1RvUHJpbSA9IGdldE1ldGhvZCQzKGlucHV0LCBUT19QUklNSVRJVkUpO1xuICB2YXIgcmVzdWx0O1xuICBpZiAoZXhvdGljVG9QcmltKSB7XG4gICAgaWYgKHByZWYgPT09IHVuZGVmaW5lZCkgcHJlZiA9ICdkZWZhdWx0JztcbiAgICByZXN1bHQgPSBjYWxsJGgoZXhvdGljVG9QcmltLCBpbnB1dCwgcHJlZik7XG4gICAgaWYgKCFpc09iamVjdCQ2KHJlc3VsdCkgfHwgaXNTeW1ib2wkMShyZXN1bHQpKSByZXR1cm4gcmVzdWx0O1xuICAgIHRocm93ICRUeXBlRXJyb3IkOShcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbiAgfVxuICBpZiAocHJlZiA9PT0gdW5kZWZpbmVkKSBwcmVmID0gJ251bWJlcic7XG4gIHJldHVybiBvcmRpbmFyeVRvUHJpbWl0aXZlKGlucHV0LCBwcmVmKTtcbn07XG5cbnZhciB0b1ByaW1pdGl2ZSA9IHRvUHJpbWl0aXZlJDE7XG52YXIgaXNTeW1ib2wgPSBpc1N5bWJvbCQyO1xuXG4vLyBgVG9Qcm9wZXJ0eUtleWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvcHJvcGVydHlrZXlcbnZhciB0b1Byb3BlcnR5S2V5JDMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgdmFyIGtleSA9IHRvUHJpbWl0aXZlKGFyZ3VtZW50LCAnc3RyaW5nJyk7XG4gIHJldHVybiBpc1N5bWJvbChrZXkpID8ga2V5IDoga2V5ICsgJyc7XG59O1xuXG52YXIgZ2xvYmFsJGkgPSBnbG9iYWwkbztcbnZhciBpc09iamVjdCQ1ID0gaXNPYmplY3QkODtcblxudmFyIGRvY3VtZW50JDMgPSBnbG9iYWwkaS5kb2N1bWVudDtcbi8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxudmFyIEVYSVNUUyQxID0gaXNPYmplY3QkNShkb2N1bWVudCQzKSAmJiBpc09iamVjdCQ1KGRvY3VtZW50JDMuY3JlYXRlRWxlbWVudCk7XG5cbnZhciBkb2N1bWVudENyZWF0ZUVsZW1lbnQkMiA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gRVhJU1RTJDEgPyBkb2N1bWVudCQzLmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59O1xuXG52YXIgREVTQ1JJUFRPUlMkYyA9IGRlc2NyaXB0b3JzO1xudmFyIGZhaWxzJGYgPSBmYWlscyRrO1xudmFyIGNyZWF0ZUVsZW1lbnQkMSA9IGRvY3VtZW50Q3JlYXRlRWxlbWVudCQyO1xuXG4vLyBUaGFua3MgdG8gSUU4IGZvciBpdHMgZnVubnkgZGVmaW5lUHJvcGVydHlcbnZhciBpZThEb21EZWZpbmUgPSAhREVTQ1JJUFRPUlMkYyAmJiAhZmFpbHMkZihmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGNyZWF0ZUVsZW1lbnQkMSgnZGl2JyksICdhJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfVxuICB9KS5hICE9IDc7XG59KTtcblxudmFyIERFU0NSSVBUT1JTJGIgPSBkZXNjcmlwdG9ycztcbnZhciBjYWxsJGcgPSBmdW5jdGlvbkNhbGw7XG52YXIgcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUkMSA9IG9iamVjdFByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQ0ID0gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDU7XG52YXIgdG9JbmRleGVkT2JqZWN0JDQgPSB0b0luZGV4ZWRPYmplY3QkNTtcbnZhciB0b1Byb3BlcnR5S2V5JDIgPSB0b1Byb3BlcnR5S2V5JDM7XG52YXIgaGFzT3duJGIgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIElFOF9ET01fREVGSU5FJDEgPSBpZThEb21EZWZpbmU7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbi8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5ZGVzY3JpcHRvclxub2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLmYgPSBERVNDUklQVE9SUyRiID8gJGdldE93blByb3BlcnR5RGVzY3JpcHRvciQxIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApIHtcbiAgTyA9IHRvSW5kZXhlZE9iamVjdCQ0KE8pO1xuICBQID0gdG9Qcm9wZXJ0eUtleSQyKFApO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUkMSkgdHJ5IHtcbiAgICByZXR1cm4gJGdldE93blByb3BlcnR5RGVzY3JpcHRvciQxKE8sIFApO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIGlmIChoYXNPd24kYihPLCBQKSkgcmV0dXJuIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQ0KCFjYWxsJGcocHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUkMS5mLCBPLCBQKSwgT1tQXSk7XG59O1xuXG52YXIgb2JqZWN0RGVmaW5lUHJvcGVydHkgPSB7fTtcblxudmFyIERFU0NSSVBUT1JTJGEgPSBkZXNjcmlwdG9ycztcbnZhciBmYWlscyRlID0gZmFpbHMkaztcblxuLy8gVjggfiBDaHJvbWUgMzYtXG4vLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMzM0XG52YXIgdjhQcm90b3R5cGVEZWZpbmVCdWcgPSBERVNDUklQVE9SUyRhICYmIGZhaWxzJGUoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0sICdwcm90b3R5cGUnLCB7XG4gICAgdmFsdWU6IDQyLFxuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KS5wcm90b3R5cGUgIT0gNDI7XG59KTtcblxudmFyIGlzT2JqZWN0JDQgPSBpc09iamVjdCQ4O1xuXG52YXIgJFN0cmluZyQyID0gU3RyaW5nO1xudmFyICRUeXBlRXJyb3IkOCA9IFR5cGVFcnJvcjtcblxuLy8gYEFzc2VydDogVHlwZShhcmd1bWVudCkgaXMgT2JqZWN0YFxudmFyIGFuT2JqZWN0JGcgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgaWYgKGlzT2JqZWN0JDQoYXJndW1lbnQpKSByZXR1cm4gYXJndW1lbnQ7XG4gIHRocm93ICRUeXBlRXJyb3IkOCgkU3RyaW5nJDIoYXJndW1lbnQpICsgJyBpcyBub3QgYW4gb2JqZWN0Jyk7XG59O1xuXG52YXIgREVTQ1JJUFRPUlMkOSA9IGRlc2NyaXB0b3JzO1xudmFyIElFOF9ET01fREVGSU5FID0gaWU4RG9tRGVmaW5lO1xudmFyIFY4X1BST1RPVFlQRV9ERUZJTkVfQlVHJDEgPSB2OFByb3RvdHlwZURlZmluZUJ1ZztcbnZhciBhbk9iamVjdCRmID0gYW5PYmplY3QkZztcbnZhciB0b1Byb3BlcnR5S2V5JDEgPSB0b1Byb3BlcnR5S2V5JDM7XG5cbnZhciAkVHlwZUVycm9yJDcgPSBUeXBlRXJyb3I7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gc2FmZVxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIEVOVU1FUkFCTEUgPSAnZW51bWVyYWJsZSc7XG52YXIgQ09ORklHVVJBQkxFJDEgPSAnY29uZmlndXJhYmxlJztcbnZhciBXUklUQUJMRSA9ICd3cml0YWJsZSc7XG5cbi8vIGBPYmplY3QuZGVmaW5lUHJvcGVydHlgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydHlcbm9iamVjdERlZmluZVByb3BlcnR5LmYgPSBERVNDUklQVE9SUyQ5ID8gVjhfUFJPVE9UWVBFX0RFRklORV9CVUckMSA/IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgYW5PYmplY3QkZihPKTtcbiAgUCA9IHRvUHJvcGVydHlLZXkkMShQKTtcbiAgYW5PYmplY3QkZihBdHRyaWJ1dGVzKTtcbiAgaWYgKHR5cGVvZiBPID09PSAnZnVuY3Rpb24nICYmIFAgPT09ICdwcm90b3R5cGUnICYmICd2YWx1ZScgaW4gQXR0cmlidXRlcyAmJiBXUklUQUJMRSBpbiBBdHRyaWJ1dGVzICYmICFBdHRyaWJ1dGVzW1dSSVRBQkxFXSkge1xuICAgIHZhciBjdXJyZW50ID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKTtcbiAgICBpZiAoY3VycmVudCAmJiBjdXJyZW50W1dSSVRBQkxFXSkge1xuICAgICAgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gICAgICBBdHRyaWJ1dGVzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IENPTkZJR1VSQUJMRSQxIGluIEF0dHJpYnV0ZXMgPyBBdHRyaWJ1dGVzW0NPTkZJR1VSQUJMRSQxXSA6IGN1cnJlbnRbQ09ORklHVVJBQkxFJDFdLFxuICAgICAgICBlbnVtZXJhYmxlOiBFTlVNRVJBQkxFIGluIEF0dHJpYnV0ZXMgPyBBdHRyaWJ1dGVzW0VOVU1FUkFCTEVdIDogY3VycmVudFtFTlVNRVJBQkxFXSxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgfSByZXR1cm4gJGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpO1xufSA6ICRkZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgYW5PYmplY3QkZihPKTtcbiAgUCA9IHRvUHJvcGVydHlLZXkkMShQKTtcbiAgYW5PYmplY3QkZihBdHRyaWJ1dGVzKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiAkZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcykgdGhyb3cgJFR5cGVFcnJvciQ3KCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCcpO1xuICBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKSBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuXG52YXIgREVTQ1JJUFRPUlMkOCA9IGRlc2NyaXB0b3JzO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlJDUgPSBvYmplY3REZWZpbmVQcm9wZXJ0eTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkMyA9IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQ1O1xuXG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDUgPSBERVNDUklQVE9SUyQ4ID8gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICByZXR1cm4gZGVmaW5lUHJvcGVydHlNb2R1bGUkNS5mKG9iamVjdCwga2V5LCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkMygxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG5cbnZhciBtYWtlQnVpbHRJbiQzID0ge2V4cG9ydHM6IHt9fTtcblxudmFyIERFU0NSSVBUT1JTJDcgPSBkZXNjcmlwdG9ycztcbnZhciBoYXNPd24kYSA9IGhhc093blByb3BlcnR5XzE7XG5cbnZhciBGdW5jdGlvblByb3RvdHlwZSQxID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG52YXIgZ2V0RGVzY3JpcHRvciA9IERFU0NSSVBUT1JTJDcgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxudmFyIEVYSVNUUyA9IGhhc093biRhKEZ1bmN0aW9uUHJvdG90eXBlJDEsICduYW1lJyk7XG4vLyBhZGRpdGlvbmFsIHByb3RlY3Rpb24gZnJvbSBtaW5pZmllZCAvIG1hbmdsZWQgLyBkcm9wcGVkIGZ1bmN0aW9uIG5hbWVzXG52YXIgUFJPUEVSID0gRVhJU1RTICYmIChmdW5jdGlvbiBzb21ldGhpbmcoKSB7IC8qIGVtcHR5ICovIH0pLm5hbWUgPT09ICdzb21ldGhpbmcnO1xudmFyIENPTkZJR1VSQUJMRSA9IEVYSVNUUyAmJiAoIURFU0NSSVBUT1JTJDcgfHwgKERFU0NSSVBUT1JTJDcgJiYgZ2V0RGVzY3JpcHRvcihGdW5jdGlvblByb3RvdHlwZSQxLCAnbmFtZScpLmNvbmZpZ3VyYWJsZSkpO1xuXG52YXIgZnVuY3Rpb25OYW1lID0ge1xuICBFWElTVFM6IEVYSVNUUyxcbiAgUFJPUEVSOiBQUk9QRVIsXG4gIENPTkZJR1VSQUJMRTogQ09ORklHVVJBQkxFXG59O1xuXG52YXIgdW5jdXJyeVRoaXMkZyA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgaXNDYWxsYWJsZSRoID0gaXNDYWxsYWJsZSRuO1xudmFyIHN0b3JlJDEgPSBzaGFyZWRTdG9yZTtcblxudmFyIGZ1bmN0aW9uVG9TdHJpbmcgPSB1bmN1cnJ5VGhpcyRnKEZ1bmN0aW9uLnRvU3RyaW5nKTtcblxuLy8gdGhpcyBoZWxwZXIgYnJva2VuIGluIGBjb3JlLWpzQDMuNC4xLTMuNC40YCwgc28gd2UgY2FuJ3QgdXNlIGBzaGFyZWRgIGhlbHBlclxuaWYgKCFpc0NhbGxhYmxlJGgoc3RvcmUkMS5pbnNwZWN0U291cmNlKSkge1xuICBzdG9yZSQxLmluc3BlY3RTb3VyY2UgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb25Ub1N0cmluZyhpdCk7XG4gIH07XG59XG5cbnZhciBpbnNwZWN0U291cmNlJDQgPSBzdG9yZSQxLmluc3BlY3RTb3VyY2U7XG5cbnZhciBnbG9iYWwkaCA9IGdsb2JhbCRvO1xudmFyIGlzQ2FsbGFibGUkZyA9IGlzQ2FsbGFibGUkbjtcbnZhciBpbnNwZWN0U291cmNlJDMgPSBpbnNwZWN0U291cmNlJDQ7XG5cbnZhciBXZWFrTWFwJDEgPSBnbG9iYWwkaC5XZWFrTWFwO1xuXG52YXIgbmF0aXZlV2Vha01hcCA9IGlzQ2FsbGFibGUkZyhXZWFrTWFwJDEpICYmIC9uYXRpdmUgY29kZS8udGVzdChpbnNwZWN0U291cmNlJDMoV2Vha01hcCQxKSk7XG5cbnZhciBzaGFyZWQkMiA9IHNoYXJlZCQ0LmV4cG9ydHM7XG52YXIgdWlkID0gdWlkJDI7XG5cbnZhciBrZXlzID0gc2hhcmVkJDIoJ2tleXMnKTtcblxudmFyIHNoYXJlZEtleSQzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4ga2V5c1trZXldIHx8IChrZXlzW2tleV0gPSB1aWQoa2V5KSk7XG59O1xuXG52YXIgaGlkZGVuS2V5cyQ0ID0ge307XG5cbnZhciBOQVRJVkVfV0VBS19NQVAgPSBuYXRpdmVXZWFrTWFwO1xudmFyIGdsb2JhbCRnID0gZ2xvYmFsJG87XG52YXIgdW5jdXJyeVRoaXMkZiA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgaXNPYmplY3QkMyA9IGlzT2JqZWN0JDg7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDQgPSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNTtcbnZhciBoYXNPd24kOSA9IGhhc093blByb3BlcnR5XzE7XG52YXIgc2hhcmVkJDEgPSBzaGFyZWRTdG9yZTtcbnZhciBzaGFyZWRLZXkkMiA9IHNoYXJlZEtleSQzO1xudmFyIGhpZGRlbktleXMkMyA9IGhpZGRlbktleXMkNDtcblxudmFyIE9CSkVDVF9BTFJFQURZX0lOSVRJQUxJWkVEID0gJ09iamVjdCBhbHJlYWR5IGluaXRpYWxpemVkJztcbnZhciBUeXBlRXJyb3IkNCA9IGdsb2JhbCRnLlR5cGVFcnJvcjtcbnZhciBXZWFrTWFwID0gZ2xvYmFsJGcuV2Vha01hcDtcbnZhciBzZXQkMSwgZ2V0LCBoYXM7XG5cbnZhciBlbmZvcmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBoYXMoaXQpID8gZ2V0KGl0KSA6IHNldCQxKGl0LCB7fSk7XG59O1xuXG52YXIgZ2V0dGVyRm9yID0gZnVuY3Rpb24gKFRZUEUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpdCkge1xuICAgIHZhciBzdGF0ZTtcbiAgICBpZiAoIWlzT2JqZWN0JDMoaXQpIHx8IChzdGF0ZSA9IGdldChpdCkpLnR5cGUgIT09IFRZUEUpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvciQ0KCdJbmNvbXBhdGlibGUgcmVjZWl2ZXIsICcgKyBUWVBFICsgJyByZXF1aXJlZCcpO1xuICAgIH0gcmV0dXJuIHN0YXRlO1xuICB9O1xufTtcblxuaWYgKE5BVElWRV9XRUFLX01BUCB8fCBzaGFyZWQkMS5zdGF0ZSkge1xuICB2YXIgc3RvcmUgPSBzaGFyZWQkMS5zdGF0ZSB8fCAoc2hhcmVkJDEuc3RhdGUgPSBuZXcgV2Vha01hcCgpKTtcbiAgdmFyIHdtZ2V0ID0gdW5jdXJyeVRoaXMkZihzdG9yZS5nZXQpO1xuICB2YXIgd21oYXMgPSB1bmN1cnJ5VGhpcyRmKHN0b3JlLmhhcyk7XG4gIHZhciB3bXNldCA9IHVuY3VycnlUaGlzJGYoc3RvcmUuc2V0KTtcbiAgc2V0JDEgPSBmdW5jdGlvbiAoaXQsIG1ldGFkYXRhKSB7XG4gICAgaWYgKHdtaGFzKHN0b3JlLCBpdCkpIHRocm93IG5ldyBUeXBlRXJyb3IkNChPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCk7XG4gICAgbWV0YWRhdGEuZmFjYWRlID0gaXQ7XG4gICAgd21zZXQoc3RvcmUsIGl0LCBtZXRhZGF0YSk7XG4gICAgcmV0dXJuIG1ldGFkYXRhO1xuICB9O1xuICBnZXQgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gd21nZXQoc3RvcmUsIGl0KSB8fCB7fTtcbiAgfTtcbiAgaGFzID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIHdtaGFzKHN0b3JlLCBpdCk7XG4gIH07XG59IGVsc2Uge1xuICB2YXIgU1RBVEUgPSBzaGFyZWRLZXkkMignc3RhdGUnKTtcbiAgaGlkZGVuS2V5cyQzW1NUQVRFXSA9IHRydWU7XG4gIHNldCQxID0gZnVuY3Rpb24gKGl0LCBtZXRhZGF0YSkge1xuICAgIGlmIChoYXNPd24kOShpdCwgU1RBVEUpKSB0aHJvdyBuZXcgVHlwZUVycm9yJDQoT0JKRUNUX0FMUkVBRFlfSU5JVElBTElaRUQpO1xuICAgIG1ldGFkYXRhLmZhY2FkZSA9IGl0O1xuICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ0KGl0LCBTVEFURSwgbWV0YWRhdGEpO1xuICAgIHJldHVybiBtZXRhZGF0YTtcbiAgfTtcbiAgZ2V0ID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGhhc093biQ5KGl0LCBTVEFURSkgPyBpdFtTVEFURV0gOiB7fTtcbiAgfTtcbiAgaGFzID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGhhc093biQ5KGl0LCBTVEFURSk7XG4gIH07XG59XG5cbnZhciBpbnRlcm5hbFN0YXRlID0ge1xuICBzZXQ6IHNldCQxLFxuICBnZXQ6IGdldCxcbiAgaGFzOiBoYXMsXG4gIGVuZm9yY2U6IGVuZm9yY2UsXG4gIGdldHRlckZvcjogZ2V0dGVyRm9yXG59O1xuXG52YXIgZmFpbHMkZCA9IGZhaWxzJGs7XG52YXIgaXNDYWxsYWJsZSRmID0gaXNDYWxsYWJsZSRuO1xudmFyIGhhc093biQ4ID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBERVNDUklQVE9SUyQ2ID0gZGVzY3JpcHRvcnM7XG52YXIgQ09ORklHVVJBQkxFX0ZVTkNUSU9OX05BTUUkMSA9IGZ1bmN0aW9uTmFtZS5DT05GSUdVUkFCTEU7XG52YXIgaW5zcGVjdFNvdXJjZSQyID0gaW5zcGVjdFNvdXJjZSQ0O1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUkNSA9IGludGVybmFsU3RhdGU7XG5cbnZhciBlbmZvcmNlSW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUkNS5lbmZvcmNlO1xudmFyIGdldEludGVybmFsU3RhdGUkMyA9IEludGVybmFsU3RhdGVNb2R1bGUkNS5nZXQ7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gc2FmZVxudmFyIGRlZmluZVByb3BlcnR5JDUgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbnZhciBDT05GSUdVUkFCTEVfTEVOR1RIID0gREVTQ1JJUFRPUlMkNiAmJiAhZmFpbHMkZChmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eSQ1KGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSwgJ2xlbmd0aCcsIHsgdmFsdWU6IDggfSkubGVuZ3RoICE9PSA4O1xufSk7XG5cbnZhciBURU1QTEFURSA9IFN0cmluZyhTdHJpbmcpLnNwbGl0KCdTdHJpbmcnKTtcblxudmFyIG1ha2VCdWlsdEluJDIgPSBtYWtlQnVpbHRJbiQzLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUsIG5hbWUsIG9wdGlvbnMpIHtcbiAgaWYgKFN0cmluZyhuYW1lKS5zbGljZSgwLCA3KSA9PT0gJ1N5bWJvbCgnKSB7XG4gICAgbmFtZSA9ICdbJyArIFN0cmluZyhuYW1lKS5yZXBsYWNlKC9eU3ltYm9sXFwoKFteKV0qKVxcKS8sICckMScpICsgJ10nO1xuICB9XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZ2V0dGVyKSBuYW1lID0gJ2dldCAnICsgbmFtZTtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5zZXR0ZXIpIG5hbWUgPSAnc2V0ICcgKyBuYW1lO1xuICBpZiAoIWhhc093biQ4KHZhbHVlLCAnbmFtZScpIHx8IChDT05GSUdVUkFCTEVfRlVOQ1RJT05fTkFNRSQxICYmIHZhbHVlLm5hbWUgIT09IG5hbWUpKSB7XG4gICAgaWYgKERFU0NSSVBUT1JTJDYpIGRlZmluZVByb3BlcnR5JDUodmFsdWUsICduYW1lJywgeyB2YWx1ZTogbmFtZSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xuICAgIGVsc2UgdmFsdWUubmFtZSA9IG5hbWU7XG4gIH1cbiAgaWYgKENPTkZJR1VSQUJMRV9MRU5HVEggJiYgb3B0aW9ucyAmJiBoYXNPd24kOChvcHRpb25zLCAnYXJpdHknKSAmJiB2YWx1ZS5sZW5ndGggIT09IG9wdGlvbnMuYXJpdHkpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eSQ1KHZhbHVlLCAnbGVuZ3RoJywgeyB2YWx1ZTogb3B0aW9ucy5hcml0eSB9KTtcbiAgfVxuICB0cnkge1xuICAgIGlmIChvcHRpb25zICYmIGhhc093biQ4KG9wdGlvbnMsICdjb25zdHJ1Y3RvcicpICYmIG9wdGlvbnMuY29uc3RydWN0b3IpIHtcbiAgICAgIGlmIChERVNDUklQVE9SUyQ2KSBkZWZpbmVQcm9wZXJ0eSQ1KHZhbHVlLCAncHJvdG90eXBlJywgeyB3cml0YWJsZTogZmFsc2UgfSk7XG4gICAgLy8gaW4gVjggfiBDaHJvbWUgNTMsIHByb3RvdHlwZXMgb2Ygc29tZSBtZXRob2RzLCBsaWtlIGBBcnJheS5wcm90b3R5cGUudmFsdWVzYCwgYXJlIG5vbi13cml0YWJsZVxuICAgIH0gZWxzZSBpZiAodmFsdWUucHJvdG90eXBlKSB2YWx1ZS5wcm90b3R5cGUgPSB1bmRlZmluZWQ7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgdmFyIHN0YXRlID0gZW5mb3JjZUludGVybmFsU3RhdGUodmFsdWUpO1xuICBpZiAoIWhhc093biQ4KHN0YXRlLCAnc291cmNlJykpIHtcbiAgICBzdGF0ZS5zb3VyY2UgPSBURU1QTEFURS5qb2luKHR5cGVvZiBuYW1lID09ICdzdHJpbmcnID8gbmFtZSA6ICcnKTtcbiAgfSByZXR1cm4gdmFsdWU7XG59O1xuXG4vLyBhZGQgZmFrZSBGdW5jdGlvbiN0b1N0cmluZyBmb3IgY29ycmVjdCB3b3JrIHdyYXBwZWQgbWV0aG9kcyAvIGNvbnN0cnVjdG9ycyB3aXRoIG1ldGhvZHMgbGlrZSBMb0Rhc2ggaXNOYXRpdmVcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1leHRlbmQtbmF0aXZlIC0tIHJlcXVpcmVkXG5GdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBtYWtlQnVpbHRJbiQyKGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gaXNDYWxsYWJsZSRmKHRoaXMpICYmIGdldEludGVybmFsU3RhdGUkMyh0aGlzKS5zb3VyY2UgfHwgaW5zcGVjdFNvdXJjZSQyKHRoaXMpO1xufSwgJ3RvU3RyaW5nJyk7XG5cbnZhciBpc0NhbGxhYmxlJGUgPSBpc0NhbGxhYmxlJG47XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUkNCA9IG9iamVjdERlZmluZVByb3BlcnR5O1xudmFyIG1ha2VCdWlsdEluJDEgPSBtYWtlQnVpbHRJbiQzLmV4cG9ydHM7XG52YXIgZGVmaW5lR2xvYmFsUHJvcGVydHkkMSA9IGRlZmluZUdsb2JhbFByb3BlcnR5JDM7XG5cbnZhciBkZWZpbmVCdWlsdEluJGEgPSBmdW5jdGlvbiAoTywga2V5LCB2YWx1ZSwgb3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcbiAgdmFyIHNpbXBsZSA9IG9wdGlvbnMuZW51bWVyYWJsZTtcbiAgdmFyIG5hbWUgPSBvcHRpb25zLm5hbWUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubmFtZSA6IGtleTtcbiAgaWYgKGlzQ2FsbGFibGUkZSh2YWx1ZSkpIG1ha2VCdWlsdEluJDEodmFsdWUsIG5hbWUsIG9wdGlvbnMpO1xuICBpZiAob3B0aW9ucy5nbG9iYWwpIHtcbiAgICBpZiAoc2ltcGxlKSBPW2tleV0gPSB2YWx1ZTtcbiAgICBlbHNlIGRlZmluZUdsb2JhbFByb3BlcnR5JDEoa2V5LCB2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghb3B0aW9ucy51bnNhZmUpIGRlbGV0ZSBPW2tleV07XG4gICAgICBlbHNlIGlmIChPW2tleV0pIHNpbXBsZSA9IHRydWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICAgIGlmIChzaW1wbGUpIE9ba2V5XSA9IHZhbHVlO1xuICAgIGVsc2UgZGVmaW5lUHJvcGVydHlNb2R1bGUkNC5mKE8sIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6ICFvcHRpb25zLm5vbkNvbmZpZ3VyYWJsZSxcbiAgICAgIHdyaXRhYmxlOiAhb3B0aW9ucy5ub25Xcml0YWJsZVxuICAgIH0pO1xuICB9IHJldHVybiBPO1xufTtcblxudmFyIG9iamVjdEdldE93blByb3BlcnR5TmFtZXMgPSB7fTtcblxudmFyIGNlaWwgPSBNYXRoLmNlaWw7XG52YXIgZmxvb3IkNCA9IE1hdGguZmxvb3I7XG5cbi8vIGBNYXRoLnRydW5jYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbWF0aC50cnVuY1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tbWF0aC10cnVuYyAtLSBzYWZlXG52YXIgbWF0aFRydW5jID0gTWF0aC50cnVuYyB8fCBmdW5jdGlvbiB0cnVuYyh4KSB7XG4gIHZhciBuID0gK3g7XG4gIHJldHVybiAobiA+IDAgPyBmbG9vciQ0IDogY2VpbCkobik7XG59O1xuXG52YXIgdHJ1bmMgPSBtYXRoVHJ1bmM7XG5cbi8vIGBUb0ludGVnZXJPckluZmluaXR5YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9pbnRlZ2Vyb3JpbmZpbml0eVxudmFyIHRvSW50ZWdlck9ySW5maW5pdHkkNCA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICB2YXIgbnVtYmVyID0gK2FyZ3VtZW50O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xuICByZXR1cm4gbnVtYmVyICE9PSBudW1iZXIgfHwgbnVtYmVyID09PSAwID8gMCA6IHRydW5jKG51bWJlcik7XG59O1xuXG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSQzID0gdG9JbnRlZ2VyT3JJbmZpbml0eSQ0O1xuXG52YXIgbWF4JDIgPSBNYXRoLm1heDtcbnZhciBtaW4kMiA9IE1hdGgubWluO1xuXG4vLyBIZWxwZXIgZm9yIGEgcG9wdWxhciByZXBlYXRpbmcgY2FzZSBvZiB0aGUgc3BlYzpcbi8vIExldCBpbnRlZ2VyIGJlID8gVG9JbnRlZ2VyKGluZGV4KS5cbi8vIElmIGludGVnZXIgPCAwLCBsZXQgcmVzdWx0IGJlIG1heCgobGVuZ3RoICsgaW50ZWdlciksIDApOyBlbHNlIGxldCByZXN1bHQgYmUgbWluKGludGVnZXIsIGxlbmd0aCkuXG52YXIgdG9BYnNvbHV0ZUluZGV4JDIgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICB2YXIgaW50ZWdlciA9IHRvSW50ZWdlck9ySW5maW5pdHkkMyhpbmRleCk7XG4gIHJldHVybiBpbnRlZ2VyIDwgMCA/IG1heCQyKGludGVnZXIgKyBsZW5ndGgsIDApIDogbWluJDIoaW50ZWdlciwgbGVuZ3RoKTtcbn07XG5cbnZhciB0b0ludGVnZXJPckluZmluaXR5JDIgPSB0b0ludGVnZXJPckluZmluaXR5JDQ7XG5cbnZhciBtaW4kMSA9IE1hdGgubWluO1xuXG4vLyBgVG9MZW5ndGhgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b2xlbmd0aFxudmFyIHRvTGVuZ3RoJDIgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIGFyZ3VtZW50ID4gMCA/IG1pbiQxKHRvSW50ZWdlck9ySW5maW5pdHkkMihhcmd1bWVudCksIDB4MUZGRkZGRkZGRkZGRkYpIDogMDsgLy8gMiAqKiA1MyAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTtcblxudmFyIHRvTGVuZ3RoJDEgPSB0b0xlbmd0aCQyO1xuXG4vLyBgTGVuZ3RoT2ZBcnJheUxpa2VgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1sZW5ndGhvZmFycmF5bGlrZVxudmFyIGxlbmd0aE9mQXJyYXlMaWtlJDQgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0b0xlbmd0aCQxKG9iai5sZW5ndGgpO1xufTtcblxudmFyIHRvSW5kZXhlZE9iamVjdCQzID0gdG9JbmRleGVkT2JqZWN0JDU7XG52YXIgdG9BYnNvbHV0ZUluZGV4JDEgPSB0b0Fic29sdXRlSW5kZXgkMjtcbnZhciBsZW5ndGhPZkFycmF5TGlrZSQzID0gbGVuZ3RoT2ZBcnJheUxpa2UkNDtcblxuLy8gYEFycmF5LnByb3RvdHlwZS57IGluZGV4T2YsIGluY2x1ZGVzIH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cbnZhciBjcmVhdGVNZXRob2QkMSA9IGZ1bmN0aW9uIChJU19JTkNMVURFUykge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBlbCwgZnJvbUluZGV4KSB7XG4gICAgdmFyIE8gPSB0b0luZGV4ZWRPYmplY3QkMygkdGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlJDMoTyk7XG4gICAgdmFyIGluZGV4ID0gdG9BYnNvbHV0ZUluZGV4JDEoZnJvbUluZGV4LCBsZW5ndGgpO1xuICAgIHZhciB2YWx1ZTtcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcbiAgICBpZiAoSVNfSU5DTFVERVMgJiYgZWwgIT0gZWwpIHdoaWxlIChsZW5ndGggPiBpbmRleCkge1xuICAgICAgdmFsdWUgPSBPW2luZGV4KytdO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcbiAgICAgIGlmICh2YWx1ZSAhPSB2YWx1ZSkgcmV0dXJuIHRydWU7XG4gICAgLy8gQXJyYXkjaW5kZXhPZiBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgIH0gZWxzZSBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgaWYgKChJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKSAmJiBPW2luZGV4XSA9PT0gZWwpIHJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgIH0gcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgfTtcbn07XG5cbnZhciBhcnJheUluY2x1ZGVzID0ge1xuICAvLyBgQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuaW5jbHVkZXNcbiAgaW5jbHVkZXM6IGNyZWF0ZU1ldGhvZCQxKHRydWUpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmluZGV4T2ZgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmRleG9mXG4gIGluZGV4T2Y6IGNyZWF0ZU1ldGhvZCQxKGZhbHNlKVxufTtcblxudmFyIHVuY3VycnlUaGlzJGUgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGhhc093biQ3ID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciB0b0luZGV4ZWRPYmplY3QkMiA9IHRvSW5kZXhlZE9iamVjdCQ1O1xudmFyIGluZGV4T2YkMSA9IGFycmF5SW5jbHVkZXMuaW5kZXhPZjtcbnZhciBoaWRkZW5LZXlzJDIgPSBoaWRkZW5LZXlzJDQ7XG5cbnZhciBwdXNoJDQgPSB1bmN1cnJ5VGhpcyRlKFtdLnB1c2gpO1xuXG52YXIgb2JqZWN0S2V5c0ludGVybmFsID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZXMpIHtcbiAgdmFyIE8gPSB0b0luZGV4ZWRPYmplY3QkMihvYmplY3QpO1xuICB2YXIgaSA9IDA7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gTykgIWhhc093biQ3KGhpZGRlbktleXMkMiwga2V5KSAmJiBoYXNPd24kNyhPLCBrZXkpICYmIHB1c2gkNChyZXN1bHQsIGtleSk7XG4gIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIGlmIChoYXNPd24kNyhPLCBrZXkgPSBuYW1lc1tpKytdKSkge1xuICAgIH5pbmRleE9mJDEocmVzdWx0LCBrZXkpIHx8IHB1c2gkNChyZXN1bHQsIGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIElFOC0gZG9uJ3QgZW51bSBidWcga2V5c1xudmFyIGVudW1CdWdLZXlzJDMgPSBbXG4gICdjb25zdHJ1Y3RvcicsXG4gICdoYXNPd25Qcm9wZXJ0eScsXG4gICdpc1Byb3RvdHlwZU9mJyxcbiAgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJyxcbiAgJ3RvTG9jYWxlU3RyaW5nJyxcbiAgJ3RvU3RyaW5nJyxcbiAgJ3ZhbHVlT2YnXG5dO1xuXG52YXIgaW50ZXJuYWxPYmplY3RLZXlzJDEgPSBvYmplY3RLZXlzSW50ZXJuYWw7XG52YXIgZW51bUJ1Z0tleXMkMiA9IGVudW1CdWdLZXlzJDM7XG5cbnZhciBoaWRkZW5LZXlzJDEgPSBlbnVtQnVnS2V5cyQyLmNvbmNhdCgnbGVuZ3RoJywgJ3Byb3RvdHlwZScpO1xuXG4vLyBgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHluYW1lc1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5bmFtZXMgLS0gc2FmZVxub2JqZWN0R2V0T3duUHJvcGVydHlOYW1lcy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKSB7XG4gIHJldHVybiBpbnRlcm5hbE9iamVjdEtleXMkMShPLCBoaWRkZW5LZXlzJDEpO1xufTtcblxudmFyIG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyA9IHt9O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlzeW1ib2xzIC0tIHNhZmVcbm9iamVjdEdldE93blByb3BlcnR5U3ltYm9scy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxudmFyIGdldEJ1aWx0SW4kNSA9IGdldEJ1aWx0SW4kODtcbnZhciB1bmN1cnJ5VGhpcyRkID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlID0gb2JqZWN0R2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUkMSA9IG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBhbk9iamVjdCRlID0gYW5PYmplY3QkZztcblxudmFyIGNvbmNhdCQyID0gdW5jdXJyeVRoaXMkZChbXS5jb25jYXQpO1xuXG4vLyBhbGwgb2JqZWN0IGtleXMsIGluY2x1ZGVzIG5vbi1lbnVtZXJhYmxlIGFuZCBzeW1ib2xzXG52YXIgb3duS2V5cyQxID0gZ2V0QnVpbHRJbiQ1KCdSZWZsZWN0JywgJ293bktleXMnKSB8fCBmdW5jdGlvbiBvd25LZXlzKGl0KSB7XG4gIHZhciBrZXlzID0gZ2V0T3duUHJvcGVydHlOYW1lc01vZHVsZS5mKGFuT2JqZWN0JGUoaXQpKTtcbiAgdmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSQxLmY7XG4gIHJldHVybiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBjb25jYXQkMihrZXlzLCBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpKSA6IGtleXM7XG59O1xuXG52YXIgaGFzT3duJDYgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIG93bktleXMgPSBvd25LZXlzJDE7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlID0gb2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlJDMgPSBvYmplY3REZWZpbmVQcm9wZXJ0eTtcblxudmFyIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMkMSA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSwgZXhjZXB0aW9ucykge1xuICB2YXIga2V5cyA9IG93bktleXMoc291cmNlKTtcbiAgdmFyIGRlZmluZVByb3BlcnR5ID0gZGVmaW5lUHJvcGVydHlNb2R1bGUkMy5mO1xuICB2YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlLmY7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIGlmICghaGFzT3duJDYodGFyZ2V0LCBrZXkpICYmICEoZXhjZXB0aW9ucyAmJiBoYXNPd24kNihleGNlcHRpb25zLCBrZXkpKSkge1xuICAgICAgZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIGZhaWxzJGMgPSBmYWlscyRrO1xudmFyIGlzQ2FsbGFibGUkZCA9IGlzQ2FsbGFibGUkbjtcblxudmFyIHJlcGxhY2VtZW50ID0gLyN8XFwucHJvdG90eXBlXFwuLztcblxudmFyIGlzRm9yY2VkJDIgPSBmdW5jdGlvbiAoZmVhdHVyZSwgZGV0ZWN0aW9uKSB7XG4gIHZhciB2YWx1ZSA9IGRhdGFbbm9ybWFsaXplKGZlYXR1cmUpXTtcbiAgcmV0dXJuIHZhbHVlID09IFBPTFlGSUxMID8gdHJ1ZVxuICAgIDogdmFsdWUgPT0gTkFUSVZFID8gZmFsc2VcbiAgICA6IGlzQ2FsbGFibGUkZChkZXRlY3Rpb24pID8gZmFpbHMkYyhkZXRlY3Rpb24pXG4gICAgOiAhIWRldGVjdGlvbjtcbn07XG5cbnZhciBub3JtYWxpemUgPSBpc0ZvcmNlZCQyLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgcmV0dXJuIFN0cmluZyhzdHJpbmcpLnJlcGxhY2UocmVwbGFjZW1lbnQsICcuJykudG9Mb3dlckNhc2UoKTtcbn07XG5cbnZhciBkYXRhID0gaXNGb3JjZWQkMi5kYXRhID0ge307XG52YXIgTkFUSVZFID0gaXNGb3JjZWQkMi5OQVRJVkUgPSAnTic7XG52YXIgUE9MWUZJTEwgPSBpc0ZvcmNlZCQyLlBPTFlGSUxMID0gJ1AnO1xuXG52YXIgaXNGb3JjZWRfMSA9IGlzRm9yY2VkJDI7XG5cbnZhciBnbG9iYWwkZiA9IGdsb2JhbCRvO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciQyID0gb2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLmY7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDMgPSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNTtcbnZhciBkZWZpbmVCdWlsdEluJDkgPSBkZWZpbmVCdWlsdEluJGE7XG52YXIgZGVmaW5lR2xvYmFsUHJvcGVydHkgPSBkZWZpbmVHbG9iYWxQcm9wZXJ0eSQzO1xudmFyIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMgPSBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzJDE7XG52YXIgaXNGb3JjZWQkMSA9IGlzRm9yY2VkXzE7XG5cbi8qXG4gIG9wdGlvbnMudGFyZ2V0ICAgICAgICAgLSBuYW1lIG9mIHRoZSB0YXJnZXQgb2JqZWN0XG4gIG9wdGlvbnMuZ2xvYmFsICAgICAgICAgLSB0YXJnZXQgaXMgdGhlIGdsb2JhbCBvYmplY3RcbiAgb3B0aW9ucy5zdGF0ICAgICAgICAgICAtIGV4cG9ydCBhcyBzdGF0aWMgbWV0aG9kcyBvZiB0YXJnZXRcbiAgb3B0aW9ucy5wcm90byAgICAgICAgICAtIGV4cG9ydCBhcyBwcm90b3R5cGUgbWV0aG9kcyBvZiB0YXJnZXRcbiAgb3B0aW9ucy5yZWFsICAgICAgICAgICAtIHJlYWwgcHJvdG90eXBlIG1ldGhvZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMuZm9yY2VkICAgICAgICAgLSBleHBvcnQgZXZlbiBpZiB0aGUgbmF0aXZlIGZlYXR1cmUgaXMgYXZhaWxhYmxlXG4gIG9wdGlvbnMuYmluZCAgICAgICAgICAgLSBiaW5kIG1ldGhvZHMgdG8gdGhlIHRhcmdldCwgcmVxdWlyZWQgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuICBvcHRpb25zLndyYXAgICAgICAgICAgIC0gd3JhcCBjb25zdHJ1Y3RvcnMgdG8gcHJldmVudGluZyBnbG9iYWwgcG9sbHV0aW9uLCByZXF1aXJlZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMudW5zYWZlICAgICAgICAgLSB1c2UgdGhlIHNpbXBsZSBhc3NpZ25tZW50IG9mIHByb3BlcnR5IGluc3RlYWQgb2YgZGVsZXRlICsgZGVmaW5lUHJvcGVydHlcbiAgb3B0aW9ucy5zaGFtICAgICAgICAgICAtIGFkZCBhIGZsYWcgdG8gbm90IGNvbXBsZXRlbHkgZnVsbCBwb2x5ZmlsbHNcbiAgb3B0aW9ucy5lbnVtZXJhYmxlICAgICAtIGV4cG9ydCBhcyBlbnVtZXJhYmxlIHByb3BlcnR5XG4gIG9wdGlvbnMuZG9udENhbGxHZXRTZXQgLSBwcmV2ZW50IGNhbGxpbmcgYSBnZXR0ZXIgb24gdGFyZ2V0XG4gIG9wdGlvbnMubmFtZSAgICAgICAgICAgLSB0aGUgLm5hbWUgb2YgdGhlIGZ1bmN0aW9uIGlmIGl0IGRvZXMgbm90IG1hdGNoIHRoZSBrZXlcbiovXG52YXIgX2V4cG9ydCA9IGZ1bmN0aW9uIChvcHRpb25zLCBzb3VyY2UpIHtcbiAgdmFyIFRBUkdFVCA9IG9wdGlvbnMudGFyZ2V0O1xuICB2YXIgR0xPQkFMID0gb3B0aW9ucy5nbG9iYWw7XG4gIHZhciBTVEFUSUMgPSBvcHRpb25zLnN0YXQ7XG4gIHZhciBGT1JDRUQsIHRhcmdldCwga2V5LCB0YXJnZXRQcm9wZXJ0eSwgc291cmNlUHJvcGVydHksIGRlc2NyaXB0b3I7XG4gIGlmIChHTE9CQUwpIHtcbiAgICB0YXJnZXQgPSBnbG9iYWwkZjtcbiAgfSBlbHNlIGlmIChTVEFUSUMpIHtcbiAgICB0YXJnZXQgPSBnbG9iYWwkZltUQVJHRVRdIHx8IGRlZmluZUdsb2JhbFByb3BlcnR5KFRBUkdFVCwge30pO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldCA9IChnbG9iYWwkZltUQVJHRVRdIHx8IHt9KS5wcm90b3R5cGU7XG4gIH1cbiAgaWYgKHRhcmdldCkgZm9yIChrZXkgaW4gc291cmNlKSB7XG4gICAgc291cmNlUHJvcGVydHkgPSBzb3VyY2Vba2V5XTtcbiAgICBpZiAob3B0aW9ucy5kb250Q2FsbEdldFNldCkge1xuICAgICAgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvciQyKHRhcmdldCwga2V5KTtcbiAgICAgIHRhcmdldFByb3BlcnR5ID0gZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLnZhbHVlO1xuICAgIH0gZWxzZSB0YXJnZXRQcm9wZXJ0eSA9IHRhcmdldFtrZXldO1xuICAgIEZPUkNFRCA9IGlzRm9yY2VkJDEoR0xPQkFMID8ga2V5IDogVEFSR0VUICsgKFNUQVRJQyA/ICcuJyA6ICcjJykgKyBrZXksIG9wdGlvbnMuZm9yY2VkKTtcbiAgICAvLyBjb250YWluZWQgaW4gdGFyZ2V0XG4gICAgaWYgKCFGT1JDRUQgJiYgdGFyZ2V0UHJvcGVydHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHR5cGVvZiBzb3VyY2VQcm9wZXJ0eSA9PSB0eXBlb2YgdGFyZ2V0UHJvcGVydHkpIGNvbnRpbnVlO1xuICAgICAgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyhzb3VyY2VQcm9wZXJ0eSwgdGFyZ2V0UHJvcGVydHkpO1xuICAgIH1cbiAgICAvLyBhZGQgYSBmbGFnIHRvIG5vdCBjb21wbGV0ZWx5IGZ1bGwgcG9seWZpbGxzXG4gICAgaWYgKG9wdGlvbnMuc2hhbSB8fCAodGFyZ2V0UHJvcGVydHkgJiYgdGFyZ2V0UHJvcGVydHkuc2hhbSkpIHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQzKHNvdXJjZVByb3BlcnR5LCAnc2hhbScsIHRydWUpO1xuICAgIH1cbiAgICBkZWZpbmVCdWlsdEluJDkodGFyZ2V0LCBrZXksIHNvdXJjZVByb3BlcnR5LCBvcHRpb25zKTtcbiAgfVxufTtcblxudmFyIGludGVybmFsT2JqZWN0S2V5cyA9IG9iamVjdEtleXNJbnRlcm5hbDtcbnZhciBlbnVtQnVnS2V5cyQxID0gZW51bUJ1Z0tleXMkMztcblxuLy8gYE9iamVjdC5rZXlzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmtleXNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1rZXlzIC0tIHNhZmVcbnZhciBvYmplY3RLZXlzJDIgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pIHtcbiAgcmV0dXJuIGludGVybmFsT2JqZWN0S2V5cyhPLCBlbnVtQnVnS2V5cyQxKTtcbn07XG5cbnZhciBERVNDUklQVE9SUyQ1ID0gZGVzY3JpcHRvcnM7XG52YXIgdW5jdXJyeVRoaXMkYyA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgY2FsbCRmID0gZnVuY3Rpb25DYWxsO1xudmFyIGZhaWxzJGIgPSBmYWlscyRrO1xudmFyIG9iamVjdEtleXMkMSA9IG9iamVjdEtleXMkMjtcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUgPSBvYmplY3RQcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciB0b09iamVjdCQzID0gdG9PYmplY3QkNTtcbnZhciBJbmRleGVkT2JqZWN0ID0gaW5kZXhlZE9iamVjdDtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWFzc2lnbiAtLSBzYWZlXG52YXIgJGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbnZhciBkZWZpbmVQcm9wZXJ0eSQ0ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIGNvbmNhdCQxID0gdW5jdXJyeVRoaXMkYyhbXS5jb25jYXQpO1xuXG4vLyBgT2JqZWN0LmFzc2lnbmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5hc3NpZ25cbnZhciBvYmplY3RBc3NpZ24gPSAhJGFzc2lnbiB8fCBmYWlscyRiKGZ1bmN0aW9uICgpIHtcbiAgLy8gc2hvdWxkIGhhdmUgY29ycmVjdCBvcmRlciBvZiBvcGVyYXRpb25zIChFZGdlIGJ1ZylcbiAgaWYgKERFU0NSSVBUT1JTJDUgJiYgJGFzc2lnbih7IGI6IDEgfSwgJGFzc2lnbihkZWZpbmVQcm9wZXJ0eSQ0KHt9LCAnYScsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgZGVmaW5lUHJvcGVydHkkNCh0aGlzLCAnYicsIHtcbiAgICAgICAgdmFsdWU6IDMsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gIH0pLCB7IGI6IDIgfSkpLmIgIT09IDEpIHJldHVybiB0cnVlO1xuICAvLyBzaG91bGQgd29yayB3aXRoIHN5bWJvbHMgYW5kIHNob3VsZCBoYXZlIGRldGVybWluaXN0aWMgcHJvcGVydHkgb3JkZXIgKFY4IGJ1ZylcbiAgdmFyIEEgPSB7fTtcbiAgdmFyIEIgPSB7fTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tc3ltYm9sIC0tIHNhZmVcbiAgdmFyIHN5bWJvbCA9IFN5bWJvbCgpO1xuICB2YXIgYWxwaGFiZXQgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3QnO1xuICBBW3N5bWJvbF0gPSA3O1xuICBhbHBoYWJldC5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAoY2hyKSB7IEJbY2hyXSA9IGNocjsgfSk7XG4gIHJldHVybiAkYXNzaWduKHt9LCBBKVtzeW1ib2xdICE9IDcgfHwgb2JqZWN0S2V5cyQxKCRhc3NpZ24oe30sIEIpKS5qb2luKCcnKSAhPSBhbHBoYWJldDtcbn0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnMgLS0gcmVxdWlyZWQgZm9yIGAubGVuZ3RoYFxuICB2YXIgVCA9IHRvT2JqZWN0JDModGFyZ2V0KTtcbiAgdmFyIGFyZ3VtZW50c0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBpbmRleCA9IDE7XG4gIHZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUuZjtcbiAgdmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUuZjtcbiAgd2hpbGUgKGFyZ3VtZW50c0xlbmd0aCA+IGluZGV4KSB7XG4gICAgdmFyIFMgPSBJbmRleGVkT2JqZWN0KGFyZ3VtZW50c1tpbmRleCsrXSk7XG4gICAgdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBjb25jYXQkMShvYmplY3RLZXlzJDEoUyksIGdldE93blByb3BlcnR5U3ltYm9scyhTKSkgOiBvYmplY3RLZXlzJDEoUyk7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBqID0gMDtcbiAgICB2YXIga2V5O1xuICAgIHdoaWxlIChsZW5ndGggPiBqKSB7XG4gICAgICBrZXkgPSBrZXlzW2orK107XG4gICAgICBpZiAoIURFU0NSSVBUT1JTJDUgfHwgY2FsbCRmKHByb3BlcnR5SXNFbnVtZXJhYmxlLCBTLCBrZXkpKSBUW2tleV0gPSBTW2tleV07XG4gICAgfVxuICB9IHJldHVybiBUO1xufSA6ICRhc3NpZ247XG5cbnZhciAkJGEgPSBfZXhwb3J0O1xudmFyIGFzc2lnbiQxID0gb2JqZWN0QXNzaWduO1xuXG4vLyBgT2JqZWN0LmFzc2lnbmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5hc3NpZ25cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1hc3NpZ24gLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiQkYSh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIGFyaXR5OiAyLCBmb3JjZWQ6IE9iamVjdC5hc3NpZ24gIT09IGFzc2lnbiQxIH0sIHtcbiAgYXNzaWduOiBhc3NpZ24kMVxufSk7XG5cbnZhciB3ZWxsS25vd25TeW1ib2wkZyA9IHdlbGxLbm93blN5bWJvbCRpO1xuXG52YXIgVE9fU1RSSU5HX1RBRyQzID0gd2VsbEtub3duU3ltYm9sJGcoJ3RvU3RyaW5nVGFnJyk7XG52YXIgdGVzdCA9IHt9O1xuXG50ZXN0W1RPX1NUUklOR19UQUckM10gPSAneic7XG5cbnZhciB0b1N0cmluZ1RhZ1N1cHBvcnQgPSBTdHJpbmcodGVzdCkgPT09ICdbb2JqZWN0IHpdJztcblxudmFyIFRPX1NUUklOR19UQUdfU1VQUE9SVCA9IHRvU3RyaW5nVGFnU3VwcG9ydDtcbnZhciBpc0NhbGxhYmxlJGMgPSBpc0NhbGxhYmxlJG47XG52YXIgY2xhc3NvZlJhdyA9IGNsYXNzb2ZSYXckMTtcbnZhciB3ZWxsS25vd25TeW1ib2wkZiA9IHdlbGxLbm93blN5bWJvbCRpO1xuXG52YXIgVE9fU1RSSU5HX1RBRyQyID0gd2VsbEtub3duU3ltYm9sJGYoJ3RvU3RyaW5nVGFnJyk7XG52YXIgJE9iamVjdCQxID0gT2JqZWN0O1xuXG4vLyBFUzMgd3JvbmcgaGVyZVxudmFyIENPUlJFQ1RfQVJHVU1FTlRTID0gY2xhc3NvZlJhdyhmdW5jdGlvbiAoKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPT0gJ0FyZ3VtZW50cyc7XG5cbi8vIGZhbGxiYWNrIGZvciBJRTExIFNjcmlwdCBBY2Nlc3MgRGVuaWVkIGVycm9yXG52YXIgdHJ5R2V0ID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaXRba2V5XTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxufTtcblxuLy8gZ2V0dGluZyB0YWcgZnJvbSBFUzYrIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYFxudmFyIGNsYXNzb2YkNiA9IFRPX1NUUklOR19UQUdfU1VQUE9SVCA/IGNsYXNzb2ZSYXcgOiBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIE8sIHRhZywgcmVzdWx0O1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCdcbiAgICAvLyBAQHRvU3RyaW5nVGFnIGNhc2VcbiAgICA6IHR5cGVvZiAodGFnID0gdHJ5R2V0KE8gPSAkT2JqZWN0JDEoaXQpLCBUT19TVFJJTkdfVEFHJDIpKSA9PSAnc3RyaW5nJyA/IHRhZ1xuICAgIC8vIGJ1aWx0aW5UYWcgY2FzZVxuICAgIDogQ09SUkVDVF9BUkdVTUVOVFMgPyBjbGFzc29mUmF3KE8pXG4gICAgLy8gRVMzIGFyZ3VtZW50cyBmYWxsYmFja1xuICAgIDogKHJlc3VsdCA9IGNsYXNzb2ZSYXcoTykpID09ICdPYmplY3QnICYmIGlzQ2FsbGFibGUkYyhPLmNhbGxlZSkgPyAnQXJndW1lbnRzJyA6IHJlc3VsdDtcbn07XG5cbnZhciBjbGFzc29mJDUgPSBjbGFzc29mJDY7XG5cbnZhciAkU3RyaW5nJDEgPSBTdHJpbmc7XG5cbnZhciB0b1N0cmluZyQ0ID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmIChjbGFzc29mJDUoYXJndW1lbnQpID09PSAnU3ltYm9sJykgdGhyb3cgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCBhIFN5bWJvbCB2YWx1ZSB0byBhIHN0cmluZycpO1xuICByZXR1cm4gJFN0cmluZyQxKGFyZ3VtZW50KTtcbn07XG5cbnZhciBhbk9iamVjdCRkID0gYW5PYmplY3QkZztcblxuLy8gYFJlZ0V4cC5wcm90b3R5cGUuZmxhZ3NgIGdldHRlciBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1nZXQtcmVnZXhwLnByb3RvdHlwZS5mbGFnc1xudmFyIHJlZ2V4cEZsYWdzJDEgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0aGF0ID0gYW5PYmplY3QkZCh0aGlzKTtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuICBpZiAodGhhdC5oYXNJbmRpY2VzKSByZXN1bHQgKz0gJ2QnO1xuICBpZiAodGhhdC5nbG9iYWwpIHJlc3VsdCArPSAnZyc7XG4gIGlmICh0aGF0Lmlnbm9yZUNhc2UpIHJlc3VsdCArPSAnaSc7XG4gIGlmICh0aGF0Lm11bHRpbGluZSkgcmVzdWx0ICs9ICdtJztcbiAgaWYgKHRoYXQuZG90QWxsKSByZXN1bHQgKz0gJ3MnO1xuICBpZiAodGhhdC51bmljb2RlKSByZXN1bHQgKz0gJ3UnO1xuICBpZiAodGhhdC51bmljb2RlU2V0cykgcmVzdWx0ICs9ICd2JztcbiAgaWYgKHRoYXQuc3RpY2t5KSByZXN1bHQgKz0gJ3knO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxudmFyIGNhbGwkZSA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBoYXNPd24kNSA9IGhhc093blByb3BlcnR5XzE7XG52YXIgaXNQcm90b3R5cGVPZiQyID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbnZhciByZWdFeHBGbGFncyA9IHJlZ2V4cEZsYWdzJDE7XG5cbnZhciBSZWdFeHBQcm90b3R5cGUkMiA9IFJlZ0V4cC5wcm90b3R5cGU7XG5cbnZhciByZWdleHBHZXRGbGFncyA9IGZ1bmN0aW9uIChSKSB7XG4gIHZhciBmbGFncyA9IFIuZmxhZ3M7XG4gIHJldHVybiBmbGFncyA9PT0gdW5kZWZpbmVkICYmICEoJ2ZsYWdzJyBpbiBSZWdFeHBQcm90b3R5cGUkMikgJiYgIWhhc093biQ1KFIsICdmbGFncycpICYmIGlzUHJvdG90eXBlT2YkMihSZWdFeHBQcm90b3R5cGUkMiwgUilcbiAgICA/IGNhbGwkZShyZWdFeHBGbGFncywgUikgOiBmbGFncztcbn07XG5cbnZhciBQUk9QRVJfRlVOQ1RJT05fTkFNRSQxID0gZnVuY3Rpb25OYW1lLlBST1BFUjtcbnZhciBkZWZpbmVCdWlsdEluJDggPSBkZWZpbmVCdWlsdEluJGE7XG52YXIgYW5PYmplY3QkYyA9IGFuT2JqZWN0JGc7XG52YXIgJHRvU3RyaW5nJDIgPSB0b1N0cmluZyQ0O1xudmFyIGZhaWxzJGEgPSBmYWlscyRrO1xudmFyIGdldFJlZ0V4cEZsYWdzID0gcmVnZXhwR2V0RmxhZ3M7XG5cbnZhciBUT19TVFJJTkcgPSAndG9TdHJpbmcnO1xudmFyIFJlZ0V4cFByb3RvdHlwZSQxID0gUmVnRXhwLnByb3RvdHlwZTtcbnZhciBuJFRvU3RyaW5nID0gUmVnRXhwUHJvdG90eXBlJDFbVE9fU1RSSU5HXTtcblxudmFyIE5PVF9HRU5FUklDID0gZmFpbHMkYShmdW5jdGlvbiAoKSB7IHJldHVybiBuJFRvU3RyaW5nLmNhbGwoeyBzb3VyY2U6ICdhJywgZmxhZ3M6ICdiJyB9KSAhPSAnL2EvYic7IH0pO1xuLy8gRkY0NC0gUmVnRXhwI3RvU3RyaW5nIGhhcyBhIHdyb25nIG5hbWVcbnZhciBJTkNPUlJFQ1RfTkFNRSA9IFBST1BFUl9GVU5DVElPTl9OQU1FJDEgJiYgbiRUb1N0cmluZy5uYW1lICE9IFRPX1NUUklORztcblxuLy8gYFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmdgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1yZWdleHAucHJvdG90eXBlLnRvc3RyaW5nXG5pZiAoTk9UX0dFTkVSSUMgfHwgSU5DT1JSRUNUX05BTUUpIHtcbiAgZGVmaW5lQnVpbHRJbiQ4KFJlZ0V4cC5wcm90b3R5cGUsIFRPX1NUUklORywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgdmFyIFIgPSBhbk9iamVjdCRjKHRoaXMpO1xuICAgIHZhciBwYXR0ZXJuID0gJHRvU3RyaW5nJDIoUi5zb3VyY2UpO1xuICAgIHZhciBmbGFncyA9ICR0b1N0cmluZyQyKGdldFJlZ0V4cEZsYWdzKFIpKTtcbiAgICByZXR1cm4gJy8nICsgcGF0dGVybiArICcvJyArIGZsYWdzO1xuICB9LCB7IHVuc2FmZTogdHJ1ZSB9KTtcbn1cblxudmFyIG9iamVjdERlZmluZVByb3BlcnRpZXMgPSB7fTtcblxudmFyIERFU0NSSVBUT1JTJDQgPSBkZXNjcmlwdG9ycztcbnZhciBWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyA9IHY4UHJvdG90eXBlRGVmaW5lQnVnO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlJDIgPSBvYmplY3REZWZpbmVQcm9wZXJ0eTtcbnZhciBhbk9iamVjdCRiID0gYW5PYmplY3QkZztcbnZhciB0b0luZGV4ZWRPYmplY3QkMSA9IHRvSW5kZXhlZE9iamVjdCQ1O1xudmFyIG9iamVjdEtleXMgPSBvYmplY3RLZXlzJDI7XG5cbi8vIGBPYmplY3QuZGVmaW5lUHJvcGVydGllc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0aWVzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZGVmaW5lcHJvcGVydGllcyAtLSBzYWZlXG5vYmplY3REZWZpbmVQcm9wZXJ0aWVzLmYgPSBERVNDUklQVE9SUyQ0ICYmICFWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XG4gIGFuT2JqZWN0JGIoTyk7XG4gIHZhciBwcm9wcyA9IHRvSW5kZXhlZE9iamVjdCQxKFByb3BlcnRpZXMpO1xuICB2YXIga2V5cyA9IG9iamVjdEtleXMoUHJvcGVydGllcyk7XG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQyLmYoTywga2V5ID0ga2V5c1tpbmRleCsrXSwgcHJvcHNba2V5XSk7XG4gIHJldHVybiBPO1xufTtcblxudmFyIGdldEJ1aWx0SW4kNCA9IGdldEJ1aWx0SW4kODtcblxudmFyIGh0bWwkMiA9IGdldEJ1aWx0SW4kNCgnZG9jdW1lbnQnLCAnZG9jdW1lbnRFbGVtZW50Jyk7XG5cbi8qIGdsb2JhbCBBY3RpdmVYT2JqZWN0IC0tIG9sZCBJRSwgV1NIICovXG5cbnZhciBhbk9iamVjdCRhID0gYW5PYmplY3QkZztcbnZhciBkZWZpbmVQcm9wZXJ0aWVzTW9kdWxlID0gb2JqZWN0RGVmaW5lUHJvcGVydGllcztcbnZhciBlbnVtQnVnS2V5cyA9IGVudW1CdWdLZXlzJDM7XG52YXIgaGlkZGVuS2V5cyA9IGhpZGRlbktleXMkNDtcbnZhciBodG1sJDEgPSBodG1sJDI7XG52YXIgZG9jdW1lbnRDcmVhdGVFbGVtZW50JDEgPSBkb2N1bWVudENyZWF0ZUVsZW1lbnQkMjtcbnZhciBzaGFyZWRLZXkkMSA9IHNoYXJlZEtleSQzO1xuXG52YXIgR1QgPSAnPic7XG52YXIgTFQgPSAnPCc7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG52YXIgU0NSSVBUID0gJ3NjcmlwdCc7XG52YXIgSUVfUFJPVE8kMSA9IHNoYXJlZEtleSQxKCdJRV9QUk9UTycpO1xuXG52YXIgRW1wdHlDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcblxudmFyIHNjcmlwdFRhZyA9IGZ1bmN0aW9uIChjb250ZW50KSB7XG4gIHJldHVybiBMVCArIFNDUklQVCArIEdUICsgY29udGVudCArIExUICsgJy8nICsgU0NSSVBUICsgR1Q7XG59O1xuXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgQWN0aXZlWCBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxudmFyIE51bGxQcm90b09iamVjdFZpYUFjdGl2ZVggPSBmdW5jdGlvbiAoYWN0aXZlWERvY3VtZW50KSB7XG4gIGFjdGl2ZVhEb2N1bWVudC53cml0ZShzY3JpcHRUYWcoJycpKTtcbiAgYWN0aXZlWERvY3VtZW50LmNsb3NlKCk7XG4gIHZhciB0ZW1wID0gYWN0aXZlWERvY3VtZW50LnBhcmVudFdpbmRvdy5PYmplY3Q7XG4gIGFjdGl2ZVhEb2N1bWVudCA9IG51bGw7IC8vIGF2b2lkIG1lbW9yeSBsZWFrXG4gIHJldHVybiB0ZW1wO1xufTtcblxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIGlmcmFtZSBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxudmFyIE51bGxQcm90b09iamVjdFZpYUlGcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gVGhyYXNoLCB3YXN0ZSBhbmQgc29kb215OiBJRSBHQyBidWdcbiAgdmFyIGlmcmFtZSA9IGRvY3VtZW50Q3JlYXRlRWxlbWVudCQxKCdpZnJhbWUnKTtcbiAgdmFyIEpTID0gJ2phdmEnICsgU0NSSVBUICsgJzonO1xuICB2YXIgaWZyYW1lRG9jdW1lbnQ7XG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICBodG1sJDEuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzQ3NVxuICBpZnJhbWUuc3JjID0gU3RyaW5nKEpTKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShzY3JpcHRUYWcoJ2RvY3VtZW50LkY9T2JqZWN0JykpO1xuICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xuICByZXR1cm4gaWZyYW1lRG9jdW1lbnQuRjtcbn07XG5cbi8vIENoZWNrIGZvciBkb2N1bWVudC5kb21haW4gYW5kIGFjdGl2ZSB4IHN1cHBvcnRcbi8vIE5vIG5lZWQgdG8gdXNlIGFjdGl2ZSB4IGFwcHJvYWNoIHdoZW4gZG9jdW1lbnQuZG9tYWluIGlzIG5vdCBzZXRcbi8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0vaXNzdWVzLzE1MFxuLy8gdmFyaWF0aW9uIG9mIGh0dHBzOi8vZ2l0aHViLmNvbS9raXRjYW1icmlkZ2UvZXM1LXNoaW0vY29tbWl0LzRmNzM4YWMwNjYzNDZcbi8vIGF2b2lkIElFIEdDIGJ1Z1xudmFyIGFjdGl2ZVhEb2N1bWVudDtcbnZhciBOdWxsUHJvdG9PYmplY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgYWN0aXZlWERvY3VtZW50ID0gbmV3IEFjdGl2ZVhPYmplY3QoJ2h0bWxmaWxlJyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGlnbm9yZSAqLyB9XG4gIE51bGxQcm90b09iamVjdCA9IHR5cGVvZiBkb2N1bWVudCAhPSAndW5kZWZpbmVkJ1xuICAgID8gZG9jdW1lbnQuZG9tYWluICYmIGFjdGl2ZVhEb2N1bWVudFxuICAgICAgPyBOdWxsUHJvdG9PYmplY3RWaWFBY3RpdmVYKGFjdGl2ZVhEb2N1bWVudCkgLy8gb2xkIElFXG4gICAgICA6IE51bGxQcm90b09iamVjdFZpYUlGcmFtZSgpXG4gICAgOiBOdWxsUHJvdG9PYmplY3RWaWFBY3RpdmVYKGFjdGl2ZVhEb2N1bWVudCk7IC8vIFdTSFxuICB2YXIgbGVuZ3RoID0gZW51bUJ1Z0tleXMubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIGRlbGV0ZSBOdWxsUHJvdG9PYmplY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tsZW5ndGhdXTtcbiAgcmV0dXJuIE51bGxQcm90b09iamVjdCgpO1xufTtcblxuaGlkZGVuS2V5c1tJRV9QUk9UTyQxXSA9IHRydWU7XG5cbi8vIGBPYmplY3QuY3JlYXRlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmNyZWF0ZVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWNyZWF0ZSAtLSBzYWZlXG52YXIgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoTyAhPT0gbnVsbCkge1xuICAgIEVtcHR5Q29uc3RydWN0b3JbUFJPVE9UWVBFXSA9IGFuT2JqZWN0JGEoTyk7XG4gICAgcmVzdWx0ID0gbmV3IEVtcHR5Q29uc3RydWN0b3IoKTtcbiAgICBFbXB0eUNvbnN0cnVjdG9yW1BST1RPVFlQRV0gPSBudWxsO1xuICAgIC8vIGFkZCBcIl9fcHJvdG9fX1wiIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YgcG9seWZpbGxcbiAgICByZXN1bHRbSUVfUFJPVE8kMV0gPSBPO1xuICB9IGVsc2UgcmVzdWx0ID0gTnVsbFByb3RvT2JqZWN0KCk7XG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkZWZpbmVQcm9wZXJ0aWVzTW9kdWxlLmYocmVzdWx0LCBQcm9wZXJ0aWVzKTtcbn07XG5cbnZhciB3ZWxsS25vd25TeW1ib2wkZSA9IHdlbGxLbm93blN5bWJvbCRpO1xudmFyIGNyZWF0ZSQzID0gb2JqZWN0Q3JlYXRlO1xudmFyIGRlZmluZVByb3BlcnR5JDMgPSBvYmplY3REZWZpbmVQcm9wZXJ0eS5mO1xuXG52YXIgVU5TQ09QQUJMRVMgPSB3ZWxsS25vd25TeW1ib2wkZSgndW5zY29wYWJsZXMnKTtcbnZhciBBcnJheVByb3RvdHlwZSQxID0gQXJyYXkucHJvdG90eXBlO1xuXG4vLyBBcnJheS5wcm90b3R5cGVbQEB1bnNjb3BhYmxlc11cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAdW5zY29wYWJsZXNcbmlmIChBcnJheVByb3RvdHlwZSQxW1VOU0NPUEFCTEVTXSA9PSB1bmRlZmluZWQpIHtcbiAgZGVmaW5lUHJvcGVydHkkMyhBcnJheVByb3RvdHlwZSQxLCBVTlNDT1BBQkxFUywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogY3JlYXRlJDMobnVsbClcbiAgfSk7XG59XG5cbi8vIGFkZCBhIGtleSB0byBBcnJheS5wcm90b3R5cGVbQEB1bnNjb3BhYmxlc11cbnZhciBhZGRUb1Vuc2NvcGFibGVzJDEgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIEFycmF5UHJvdG90eXBlJDFbVU5TQ09QQUJMRVNdW2tleV0gPSB0cnVlO1xufTtcblxudmFyIGl0ZXJhdG9ycyA9IHt9O1xuXG52YXIgZmFpbHMkOSA9IGZhaWxzJGs7XG5cbnZhciBjb3JyZWN0UHJvdG90eXBlR2V0dGVyID0gIWZhaWxzJDkoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGKCkgeyAvKiBlbXB0eSAqLyB9XG4gIEYucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbnVsbDtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldHByb3RvdHlwZW9mIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YobmV3IEYoKSkgIT09IEYucHJvdG90eXBlO1xufSk7XG5cbnZhciBoYXNPd24kNCA9IGhhc093blByb3BlcnR5XzE7XG52YXIgaXNDYWxsYWJsZSRiID0gaXNDYWxsYWJsZSRuO1xudmFyIHRvT2JqZWN0JDIgPSB0b09iamVjdCQ1O1xudmFyIHNoYXJlZEtleSA9IHNoYXJlZEtleSQzO1xudmFyIENPUlJFQ1RfUFJPVE9UWVBFX0dFVFRFUiA9IGNvcnJlY3RQcm90b3R5cGVHZXR0ZXI7XG5cbnZhciBJRV9QUk9UTyA9IHNoYXJlZEtleSgnSUVfUFJPVE8nKTtcbnZhciAkT2JqZWN0ID0gT2JqZWN0O1xudmFyIE9iamVjdFByb3RvdHlwZSA9ICRPYmplY3QucHJvdG90eXBlO1xuXG4vLyBgT2JqZWN0LmdldFByb3RvdHlwZU9mYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldHByb3RvdHlwZW9mXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0cHJvdG90eXBlb2YgLS0gc2FmZVxudmFyIG9iamVjdEdldFByb3RvdHlwZU9mID0gQ09SUkVDVF9QUk9UT1RZUEVfR0VUVEVSID8gJE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIChPKSB7XG4gIHZhciBvYmplY3QgPSB0b09iamVjdCQyKE8pO1xuICBpZiAoaGFzT3duJDQob2JqZWN0LCBJRV9QUk9UTykpIHJldHVybiBvYmplY3RbSUVfUFJPVE9dO1xuICB2YXIgY29uc3RydWN0b3IgPSBvYmplY3QuY29uc3RydWN0b3I7XG4gIGlmIChpc0NhbGxhYmxlJGIoY29uc3RydWN0b3IpICYmIG9iamVjdCBpbnN0YW5jZW9mIGNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIGNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgfSByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgJE9iamVjdCA/IE9iamVjdFByb3RvdHlwZSA6IG51bGw7XG59O1xuXG52YXIgZmFpbHMkOCA9IGZhaWxzJGs7XG52YXIgaXNDYWxsYWJsZSRhID0gaXNDYWxsYWJsZSRuO1xudmFyIGdldFByb3RvdHlwZU9mJDEgPSBvYmplY3RHZXRQcm90b3R5cGVPZjtcbnZhciBkZWZpbmVCdWlsdEluJDcgPSBkZWZpbmVCdWlsdEluJGE7XG52YXIgd2VsbEtub3duU3ltYm9sJGQgPSB3ZWxsS25vd25TeW1ib2wkaTtcblxudmFyIElURVJBVE9SJDcgPSB3ZWxsS25vd25TeW1ib2wkZCgnaXRlcmF0b3InKTtcbnZhciBCVUdHWV9TQUZBUklfSVRFUkFUT1JTJDEgPSBmYWxzZTtcblxuLy8gYCVJdGVyYXRvclByb3RvdHlwZSVgIG9iamVjdFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0laXRlcmF0b3Jwcm90b3R5cGUlLW9iamVjdFxudmFyIEl0ZXJhdG9yUHJvdG90eXBlJDIsIFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZSwgYXJyYXlJdGVyYXRvcjtcblxuLyogZXNsaW50LWRpc2FibGUgZXMteC9uby1hcnJheS1wcm90b3R5cGUta2V5cyAtLSBzYWZlICovXG5pZiAoW10ua2V5cykge1xuICBhcnJheUl0ZXJhdG9yID0gW10ua2V5cygpO1xuICAvLyBTYWZhcmkgOCBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbiAgaWYgKCEoJ25leHQnIGluIGFycmF5SXRlcmF0b3IpKSBCVUdHWV9TQUZBUklfSVRFUkFUT1JTJDEgPSB0cnVlO1xuICBlbHNlIHtcbiAgICBQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZiQxKGdldFByb3RvdHlwZU9mJDEoYXJyYXlJdGVyYXRvcikpO1xuICAgIGlmIChQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUpIEl0ZXJhdG9yUHJvdG90eXBlJDIgPSBQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cbn1cblxudmFyIE5FV19JVEVSQVRPUl9QUk9UT1RZUEUgPSBJdGVyYXRvclByb3RvdHlwZSQyID09IHVuZGVmaW5lZCB8fCBmYWlscyQ4KGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRlc3QgPSB7fTtcbiAgLy8gRkY0NC0gbGVnYWN5IGl0ZXJhdG9ycyBjYXNlXG4gIHJldHVybiBJdGVyYXRvclByb3RvdHlwZSQyW0lURVJBVE9SJDddLmNhbGwodGVzdCkgIT09IHRlc3Q7XG59KTtcblxuaWYgKE5FV19JVEVSQVRPUl9QUk9UT1RZUEUpIEl0ZXJhdG9yUHJvdG90eXBlJDIgPSB7fTtcblxuLy8gYCVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSVpdGVyYXRvcnByb3RvdHlwZSUtQEBpdGVyYXRvclxuaWYgKCFpc0NhbGxhYmxlJGEoSXRlcmF0b3JQcm90b3R5cGUkMltJVEVSQVRPUiQ3XSkpIHtcbiAgZGVmaW5lQnVpbHRJbiQ3KEl0ZXJhdG9yUHJvdG90eXBlJDIsIElURVJBVE9SJDcsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG59XG5cbnZhciBpdGVyYXRvcnNDb3JlID0ge1xuICBJdGVyYXRvclByb3RvdHlwZTogSXRlcmF0b3JQcm90b3R5cGUkMixcbiAgQlVHR1lfU0FGQVJJX0lURVJBVE9SUzogQlVHR1lfU0FGQVJJX0lURVJBVE9SUyQxXG59O1xuXG52YXIgZGVmaW5lUHJvcGVydHkkMiA9IG9iamVjdERlZmluZVByb3BlcnR5LmY7XG52YXIgaGFzT3duJDMgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIHdlbGxLbm93blN5bWJvbCRjID0gd2VsbEtub3duU3ltYm9sJGk7XG5cbnZhciBUT19TVFJJTkdfVEFHJDEgPSB3ZWxsS25vd25TeW1ib2wkYygndG9TdHJpbmdUYWcnKTtcblxudmFyIHNldFRvU3RyaW5nVGFnJDUgPSBmdW5jdGlvbiAodGFyZ2V0LCBUQUcsIFNUQVRJQykge1xuICBpZiAodGFyZ2V0ICYmICFTVEFUSUMpIHRhcmdldCA9IHRhcmdldC5wcm90b3R5cGU7XG4gIGlmICh0YXJnZXQgJiYgIWhhc093biQzKHRhcmdldCwgVE9fU1RSSU5HX1RBRyQxKSkge1xuICAgIGRlZmluZVByb3BlcnR5JDIodGFyZ2V0LCBUT19TVFJJTkdfVEFHJDEsIHsgY29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogVEFHIH0pO1xuICB9XG59O1xuXG52YXIgSXRlcmF0b3JQcm90b3R5cGUkMSA9IGl0ZXJhdG9yc0NvcmUuSXRlcmF0b3JQcm90b3R5cGU7XG52YXIgY3JlYXRlJDIgPSBvYmplY3RDcmVhdGU7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDIgPSBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkNTtcbnZhciBzZXRUb1N0cmluZ1RhZyQ0ID0gc2V0VG9TdHJpbmdUYWckNTtcbnZhciBJdGVyYXRvcnMkNCA9IGl0ZXJhdG9ycztcblxudmFyIHJldHVyblRoaXMkMSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cbnZhciBjcmVhdGVJdGVyYXRvckNvbnN0cnVjdG9yJDIgPSBmdW5jdGlvbiAoSXRlcmF0b3JDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCwgRU5VTUVSQUJMRV9ORVhUKSB7XG4gIHZhciBUT19TVFJJTkdfVEFHID0gTkFNRSArICcgSXRlcmF0b3InO1xuICBJdGVyYXRvckNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGNyZWF0ZSQyKEl0ZXJhdG9yUHJvdG90eXBlJDEsIHsgbmV4dDogY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDIoKyFFTlVNRVJBQkxFX05FWFQsIG5leHQpIH0pO1xuICBzZXRUb1N0cmluZ1RhZyQ0KEl0ZXJhdG9yQ29uc3RydWN0b3IsIFRPX1NUUklOR19UQUcsIGZhbHNlKTtcbiAgSXRlcmF0b3JzJDRbVE9fU1RSSU5HX1RBR10gPSByZXR1cm5UaGlzJDE7XG4gIHJldHVybiBJdGVyYXRvckNvbnN0cnVjdG9yO1xufTtcblxudmFyIGlzQ2FsbGFibGUkOSA9IGlzQ2FsbGFibGUkbjtcblxudmFyICRTdHJpbmcgPSBTdHJpbmc7XG52YXIgJFR5cGVFcnJvciQ2ID0gVHlwZUVycm9yO1xuXG52YXIgYVBvc3NpYmxlUHJvdG90eXBlJDEgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgaWYgKHR5cGVvZiBhcmd1bWVudCA9PSAnb2JqZWN0JyB8fCBpc0NhbGxhYmxlJDkoYXJndW1lbnQpKSByZXR1cm4gYXJndW1lbnQ7XG4gIHRocm93ICRUeXBlRXJyb3IkNihcIkNhbid0IHNldCBcIiArICRTdHJpbmcoYXJndW1lbnQpICsgJyBhcyBhIHByb3RvdHlwZScpO1xufTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gLS0gc2FmZSAqL1xuXG52YXIgdW5jdXJyeVRoaXMkYiA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgYW5PYmplY3QkOSA9IGFuT2JqZWN0JGc7XG52YXIgYVBvc3NpYmxlUHJvdG90eXBlID0gYVBvc3NpYmxlUHJvdG90eXBlJDE7XG5cbi8vIGBPYmplY3Quc2V0UHJvdG90eXBlT2ZgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3Quc2V0cHJvdG90eXBlb2Zcbi8vIFdvcmtzIHdpdGggX19wcm90b19fIG9ubHkuIE9sZCB2OCBjYW4ndCB3b3JrIHdpdGggbnVsbCBwcm90byBvYmplY3RzLlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LXNldHByb3RvdHlwZW9mIC0tIHNhZmVcbnZhciBvYmplY3RTZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCAoJ19fcHJvdG9fXycgaW4ge30gPyBmdW5jdGlvbiAoKSB7XG4gIHZhciBDT1JSRUNUX1NFVFRFUiA9IGZhbHNlO1xuICB2YXIgdGVzdCA9IHt9O1xuICB2YXIgc2V0dGVyO1xuICB0cnkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxuICAgIHNldHRlciA9IHVuY3VycnlUaGlzJGIoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPYmplY3QucHJvdG90eXBlLCAnX19wcm90b19fJykuc2V0KTtcbiAgICBzZXR0ZXIodGVzdCwgW10pO1xuICAgIENPUlJFQ1RfU0VUVEVSID0gdGVzdCBpbnN0YW5jZW9mIEFycmF5O1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihPLCBwcm90bykge1xuICAgIGFuT2JqZWN0JDkoTyk7XG4gICAgYVBvc3NpYmxlUHJvdG90eXBlKHByb3RvKTtcbiAgICBpZiAoQ09SUkVDVF9TRVRURVIpIHNldHRlcihPLCBwcm90byk7XG4gICAgZWxzZSBPLl9fcHJvdG9fXyA9IHByb3RvO1xuICAgIHJldHVybiBPO1xuICB9O1xufSgpIDogdW5kZWZpbmVkKTtcblxudmFyICQkOSA9IF9leHBvcnQ7XG52YXIgY2FsbCRkID0gZnVuY3Rpb25DYWxsO1xudmFyIEZ1bmN0aW9uTmFtZSA9IGZ1bmN0aW9uTmFtZTtcbnZhciBpc0NhbGxhYmxlJDggPSBpc0NhbGxhYmxlJG47XG52YXIgY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvciQxID0gY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvciQyO1xudmFyIGdldFByb3RvdHlwZU9mID0gb2JqZWN0R2V0UHJvdG90eXBlT2Y7XG52YXIgc2V0UHJvdG90eXBlT2YkMSA9IG9iamVjdFNldFByb3RvdHlwZU9mO1xudmFyIHNldFRvU3RyaW5nVGFnJDMgPSBzZXRUb1N0cmluZ1RhZyQ1O1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQyID0gY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDU7XG52YXIgZGVmaW5lQnVpbHRJbiQ2ID0gZGVmaW5lQnVpbHRJbiRhO1xudmFyIHdlbGxLbm93blN5bWJvbCRiID0gd2VsbEtub3duU3ltYm9sJGk7XG52YXIgSXRlcmF0b3JzJDMgPSBpdGVyYXRvcnM7XG52YXIgSXRlcmF0b3JzQ29yZSA9IGl0ZXJhdG9yc0NvcmU7XG5cbnZhciBQUk9QRVJfRlVOQ1RJT05fTkFNRSA9IEZ1bmN0aW9uTmFtZS5QUk9QRVI7XG52YXIgQ09ORklHVVJBQkxFX0ZVTkNUSU9OX05BTUUgPSBGdW5jdGlvbk5hbWUuQ09ORklHVVJBQkxFO1xudmFyIEl0ZXJhdG9yUHJvdG90eXBlID0gSXRlcmF0b3JzQ29yZS5JdGVyYXRvclByb3RvdHlwZTtcbnZhciBCVUdHWV9TQUZBUklfSVRFUkFUT1JTID0gSXRlcmF0b3JzQ29yZS5CVUdHWV9TQUZBUklfSVRFUkFUT1JTO1xudmFyIElURVJBVE9SJDYgPSB3ZWxsS25vd25TeW1ib2wkYignaXRlcmF0b3InKTtcbnZhciBLRVlTID0gJ2tleXMnO1xudmFyIFZBTFVFUyA9ICd2YWx1ZXMnO1xudmFyIEVOVFJJRVMgPSAnZW50cmllcyc7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxudmFyIGRlZmluZUl0ZXJhdG9yJDIgPSBmdW5jdGlvbiAoSXRlcmFibGUsIE5BTUUsIEl0ZXJhdG9yQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKSB7XG4gIGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IkMShJdGVyYXRvckNvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KTtcblxuICB2YXIgZ2V0SXRlcmF0aW9uTWV0aG9kID0gZnVuY3Rpb24gKEtJTkQpIHtcbiAgICBpZiAoS0lORCA9PT0gREVGQVVMVCAmJiBkZWZhdWx0SXRlcmF0b3IpIHJldHVybiBkZWZhdWx0SXRlcmF0b3I7XG4gICAgaWYgKCFCVUdHWV9TQUZBUklfSVRFUkFUT1JTICYmIEtJTkQgaW4gSXRlcmFibGVQcm90b3R5cGUpIHJldHVybiBJdGVyYWJsZVByb3RvdHlwZVtLSU5EXTtcbiAgICBzd2l0Y2ggKEtJTkQpIHtcbiAgICAgIGNhc2UgS0VZUzogcmV0dXJuIGZ1bmN0aW9uIGtleXMoKSB7IHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzLCBLSU5EKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcywgS0lORCk7IH07XG4gICAgICBjYXNlIEVOVFJJRVM6IHJldHVybiBmdW5jdGlvbiBlbnRyaWVzKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcywgS0lORCk7IH07XG4gICAgfSByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcyk7IH07XG4gIH07XG5cbiAgdmFyIFRPX1NUUklOR19UQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIHZhciBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgPSBmYWxzZTtcbiAgdmFyIEl0ZXJhYmxlUHJvdG90eXBlID0gSXRlcmFibGUucHJvdG90eXBlO1xuICB2YXIgbmF0aXZlSXRlcmF0b3IgPSBJdGVyYWJsZVByb3RvdHlwZVtJVEVSQVRPUiQ2XVxuICAgIHx8IEl0ZXJhYmxlUHJvdG90eXBlWydAQGl0ZXJhdG9yJ11cbiAgICB8fCBERUZBVUxUICYmIEl0ZXJhYmxlUHJvdG90eXBlW0RFRkFVTFRdO1xuICB2YXIgZGVmYXVsdEl0ZXJhdG9yID0gIUJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgJiYgbmF0aXZlSXRlcmF0b3IgfHwgZ2V0SXRlcmF0aW9uTWV0aG9kKERFRkFVTFQpO1xuICB2YXIgYW55TmF0aXZlSXRlcmF0b3IgPSBOQU1FID09ICdBcnJheScgPyBJdGVyYWJsZVByb3RvdHlwZS5lbnRyaWVzIHx8IG5hdGl2ZUl0ZXJhdG9yIDogbmF0aXZlSXRlcmF0b3I7XG4gIHZhciBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUsIG1ldGhvZHMsIEtFWTtcblxuICAvLyBmaXggbmF0aXZlXG4gIGlmIChhbnlOYXRpdmVJdGVyYXRvcikge1xuICAgIEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKGFueU5hdGl2ZUl0ZXJhdG9yLmNhbGwobmV3IEl0ZXJhYmxlKCkpKTtcbiAgICBpZiAoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlICYmIEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZS5uZXh0KSB7XG4gICAgICBpZiAoZ2V0UHJvdG90eXBlT2YoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlKSAhPT0gSXRlcmF0b3JQcm90b3R5cGUpIHtcbiAgICAgICAgaWYgKHNldFByb3RvdHlwZU9mJDEpIHtcbiAgICAgICAgICBzZXRQcm90b3R5cGVPZiQxKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgSXRlcmF0b3JQcm90b3R5cGUpO1xuICAgICAgICB9IGVsc2UgaWYgKCFpc0NhbGxhYmxlJDgoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlW0lURVJBVE9SJDZdKSkge1xuICAgICAgICAgIGRlZmluZUJ1aWx0SW4kNihDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SJDYsIHJldHVyblRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBTZXQgQEB0b1N0cmluZ1RhZyB0byBuYXRpdmUgaXRlcmF0b3JzXG4gICAgICBzZXRUb1N0cmluZ1RhZyQzKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgVE9fU1RSSU5HX1RBRywgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gZml4IEFycmF5LnByb3RvdHlwZS57IHZhbHVlcywgQEBpdGVyYXRvciB9Lm5hbWUgaW4gVjggLyBGRlxuICBpZiAoUFJPUEVSX0ZVTkNUSU9OX05BTUUgJiYgREVGQVVMVCA9PSBWQUxVRVMgJiYgbmF0aXZlSXRlcmF0b3IgJiYgbmF0aXZlSXRlcmF0b3IubmFtZSAhPT0gVkFMVUVTKSB7XG4gICAgaWYgKENPTkZJR1VSQUJMRV9GVU5DVElPTl9OQU1FKSB7XG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMihJdGVyYWJsZVByb3RvdHlwZSwgJ25hbWUnLCBWQUxVRVMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgPSB0cnVlO1xuICAgICAgZGVmYXVsdEl0ZXJhdG9yID0gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gY2FsbCRkKG5hdGl2ZUl0ZXJhdG9yLCB0aGlzKTsgfTtcbiAgICB9XG4gIH1cblxuICAvLyBleHBvcnQgYWRkaXRpb25hbCBtZXRob2RzXG4gIGlmIChERUZBVUxUKSB7XG4gICAgbWV0aG9kcyA9IHtcbiAgICAgIHZhbHVlczogZ2V0SXRlcmF0aW9uTWV0aG9kKFZBTFVFUyksXG4gICAgICBrZXlzOiBJU19TRVQgPyBkZWZhdWx0SXRlcmF0b3IgOiBnZXRJdGVyYXRpb25NZXRob2QoS0VZUyksXG4gICAgICBlbnRyaWVzOiBnZXRJdGVyYXRpb25NZXRob2QoRU5UUklFUylcbiAgICB9O1xuICAgIGlmIChGT1JDRUQpIGZvciAoS0VZIGluIG1ldGhvZHMpIHtcbiAgICAgIGlmIChCVUdHWV9TQUZBUklfSVRFUkFUT1JTIHx8IElOQ09SUkVDVF9WQUxVRVNfTkFNRSB8fCAhKEtFWSBpbiBJdGVyYWJsZVByb3RvdHlwZSkpIHtcbiAgICAgICAgZGVmaW5lQnVpbHRJbiQ2KEl0ZXJhYmxlUHJvdG90eXBlLCBLRVksIG1ldGhvZHNbS0VZXSk7XG4gICAgICB9XG4gICAgfSBlbHNlICQkOSh7IHRhcmdldDogTkFNRSwgcHJvdG86IHRydWUsIGZvcmNlZDogQlVHR1lfU0FGQVJJX0lURVJBVE9SUyB8fCBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgfSwgbWV0aG9kcyk7XG4gIH1cblxuICAvLyBkZWZpbmUgaXRlcmF0b3JcbiAgaWYgKEl0ZXJhYmxlUHJvdG90eXBlW0lURVJBVE9SJDZdICE9PSBkZWZhdWx0SXRlcmF0b3IpIHtcbiAgICBkZWZpbmVCdWlsdEluJDYoSXRlcmFibGVQcm90b3R5cGUsIElURVJBVE9SJDYsIGRlZmF1bHRJdGVyYXRvciwgeyBuYW1lOiBERUZBVUxUIH0pO1xuICB9XG4gIEl0ZXJhdG9ycyQzW05BTUVdID0gZGVmYXVsdEl0ZXJhdG9yO1xuXG4gIHJldHVybiBtZXRob2RzO1xufTtcblxudmFyIHRvSW5kZXhlZE9iamVjdCA9IHRvSW5kZXhlZE9iamVjdCQ1O1xudmFyIGFkZFRvVW5zY29wYWJsZXMgPSBhZGRUb1Vuc2NvcGFibGVzJDE7XG52YXIgSXRlcmF0b3JzJDIgPSBpdGVyYXRvcnM7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSQ0ID0gaW50ZXJuYWxTdGF0ZTtcbnZhciBkZWZpbmVQcm9wZXJ0eSQxID0gb2JqZWN0RGVmaW5lUHJvcGVydHkuZjtcbnZhciBkZWZpbmVJdGVyYXRvciQxID0gZGVmaW5lSXRlcmF0b3IkMjtcbnZhciBERVNDUklQVE9SUyQzID0gZGVzY3JpcHRvcnM7XG5cbnZhciBBUlJBWV9JVEVSQVRPUiA9ICdBcnJheSBJdGVyYXRvcic7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSQ0ID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQ0LnNldDtcbnZhciBnZXRJbnRlcm5hbFN0YXRlJDIgPSBJbnRlcm5hbFN0YXRlTW9kdWxlJDQuZ2V0dGVyRm9yKEFSUkFZX0lURVJBVE9SKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5lbnRyaWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmVudHJpZXNcbi8vIGBBcnJheS5wcm90b3R5cGUua2V5c2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5rZXlzXG4vLyBgQXJyYXkucHJvdG90eXBlLnZhbHVlc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS52YWx1ZXNcbi8vIGBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl1gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUtQEBpdGVyYXRvclxuLy8gYENyZWF0ZUFycmF5SXRlcmF0b3JgIGludGVybmFsIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1jcmVhdGVhcnJheWl0ZXJhdG9yXG52YXIgZXNfYXJyYXlfaXRlcmF0b3IgPSBkZWZpbmVJdGVyYXRvciQxKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbiAoaXRlcmF0ZWQsIGtpbmQpIHtcbiAgc2V0SW50ZXJuYWxTdGF0ZSQ0KHRoaXMsIHtcbiAgICB0eXBlOiBBUlJBWV9JVEVSQVRPUixcbiAgICB0YXJnZXQ6IHRvSW5kZXhlZE9iamVjdChpdGVyYXRlZCksIC8vIHRhcmdldFxuICAgIGluZGV4OiAwLCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICAgIGtpbmQ6IGtpbmQgICAgICAgICAgICAgICAgICAgICAgICAgLy8ga2luZFxuICB9KTtcbi8vIGAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSVhcnJheWl0ZXJhdG9ycHJvdG90eXBlJS5uZXh0XG59LCBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUkMih0aGlzKTtcbiAgdmFyIHRhcmdldCA9IHN0YXRlLnRhcmdldDtcbiAgdmFyIGtpbmQgPSBzdGF0ZS5raW5kO1xuICB2YXIgaW5kZXggPSBzdGF0ZS5pbmRleCsrO1xuICBpZiAoIXRhcmdldCB8fCBpbmRleCA+PSB0YXJnZXQubGVuZ3RoKSB7XG4gICAgc3RhdGUudGFyZ2V0ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuICBpZiAoa2luZCA9PSAna2V5cycpIHJldHVybiB7IHZhbHVlOiBpbmRleCwgZG9uZTogZmFsc2UgfTtcbiAgaWYgKGtpbmQgPT0gJ3ZhbHVlcycpIHJldHVybiB7IHZhbHVlOiB0YXJnZXRbaW5kZXhdLCBkb25lOiBmYWxzZSB9O1xuICByZXR1cm4geyB2YWx1ZTogW2luZGV4LCB0YXJnZXRbaW5kZXhdXSwgZG9uZTogZmFsc2UgfTtcbn0sICd2YWx1ZXMnKTtcblxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWNyZWF0ZXVubWFwcGVkYXJndW1lbnRzb2JqZWN0XG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWNyZWF0ZW1hcHBlZGFyZ3VtZW50c29iamVjdFxudmFyIHZhbHVlcyA9IEl0ZXJhdG9ycyQyLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycyQyLkFycmF5O1xuXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQHVuc2NvcGFibGVzXG5hZGRUb1Vuc2NvcGFibGVzKCdrZXlzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCd2YWx1ZXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ2VudHJpZXMnKTtcblxuLy8gVjggfiBDaHJvbWUgNDUtIGJ1Z1xuaWYgKERFU0NSSVBUT1JTJDMgJiYgdmFsdWVzLm5hbWUgIT09ICd2YWx1ZXMnKSB0cnkge1xuICBkZWZpbmVQcm9wZXJ0eSQxKHZhbHVlcywgJ25hbWUnLCB7IHZhbHVlOiAndmFsdWVzJyB9KTtcbn0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cblxudmFyIGNsYXNzb2YkNCA9IGNsYXNzb2ZSYXckMTtcbnZhciBnbG9iYWwkZSA9IGdsb2JhbCRvO1xuXG52YXIgZW5naW5lSXNOb2RlID0gY2xhc3NvZiQ0KGdsb2JhbCRlLnByb2Nlc3MpID09ICdwcm9jZXNzJztcblxudmFyIGdldEJ1aWx0SW4kMyA9IGdldEJ1aWx0SW4kODtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQxID0gb2JqZWN0RGVmaW5lUHJvcGVydHk7XG52YXIgd2VsbEtub3duU3ltYm9sJGEgPSB3ZWxsS25vd25TeW1ib2wkaTtcbnZhciBERVNDUklQVE9SUyQyID0gZGVzY3JpcHRvcnM7XG5cbnZhciBTUEVDSUVTJDMgPSB3ZWxsS25vd25TeW1ib2wkYSgnc3BlY2llcycpO1xuXG52YXIgc2V0U3BlY2llcyQxID0gZnVuY3Rpb24gKENPTlNUUlVDVE9SX05BTUUpIHtcbiAgdmFyIENvbnN0cnVjdG9yID0gZ2V0QnVpbHRJbiQzKENPTlNUUlVDVE9SX05BTUUpO1xuICB2YXIgZGVmaW5lUHJvcGVydHkgPSBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQxLmY7XG5cbiAgaWYgKERFU0NSSVBUT1JTJDIgJiYgQ29uc3RydWN0b3IgJiYgIUNvbnN0cnVjdG9yW1NQRUNJRVMkM10pIHtcbiAgICBkZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgU1BFQ0lFUyQzLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH1cbiAgICB9KTtcbiAgfVxufTtcblxudmFyIGlzUHJvdG90eXBlT2YkMSA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG5cbnZhciAkVHlwZUVycm9yJDUgPSBUeXBlRXJyb3I7XG5cbnZhciBhbkluc3RhbmNlJDMgPSBmdW5jdGlvbiAoaXQsIFByb3RvdHlwZSkge1xuICBpZiAoaXNQcm90b3R5cGVPZiQxKFByb3RvdHlwZSwgaXQpKSByZXR1cm4gaXQ7XG4gIHRocm93ICRUeXBlRXJyb3IkNSgnSW5jb3JyZWN0IGludm9jYXRpb24nKTtcbn07XG5cbnZhciB1bmN1cnJ5VGhpcyRhID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBmYWlscyQ3ID0gZmFpbHMkaztcbnZhciBpc0NhbGxhYmxlJDcgPSBpc0NhbGxhYmxlJG47XG52YXIgY2xhc3NvZiQzID0gY2xhc3NvZiQ2O1xudmFyIGdldEJ1aWx0SW4kMiA9IGdldEJ1aWx0SW4kODtcbnZhciBpbnNwZWN0U291cmNlJDEgPSBpbnNwZWN0U291cmNlJDQ7XG5cbnZhciBub29wID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xudmFyIGVtcHR5ID0gW107XG52YXIgY29uc3RydWN0ID0gZ2V0QnVpbHRJbiQyKCdSZWZsZWN0JywgJ2NvbnN0cnVjdCcpO1xudmFyIGNvbnN0cnVjdG9yUmVnRXhwID0gL15cXHMqKD86Y2xhc3N8ZnVuY3Rpb24pXFxiLztcbnZhciBleGVjJDMgPSB1bmN1cnJ5VGhpcyRhKGNvbnN0cnVjdG9yUmVnRXhwLmV4ZWMpO1xudmFyIElOQ09SUkVDVF9UT19TVFJJTkcgPSAhY29uc3RydWN0b3JSZWdFeHAuZXhlYyhub29wKTtcblxudmFyIGlzQ29uc3RydWN0b3JNb2Rlcm4gPSBmdW5jdGlvbiBpc0NvbnN0cnVjdG9yKGFyZ3VtZW50KSB7XG4gIGlmICghaXNDYWxsYWJsZSQ3KGFyZ3VtZW50KSkgcmV0dXJuIGZhbHNlO1xuICB0cnkge1xuICAgIGNvbnN0cnVjdChub29wLCBlbXB0eSwgYXJndW1lbnQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxudmFyIGlzQ29uc3RydWN0b3JMZWdhY3kgPSBmdW5jdGlvbiBpc0NvbnN0cnVjdG9yKGFyZ3VtZW50KSB7XG4gIGlmICghaXNDYWxsYWJsZSQ3KGFyZ3VtZW50KSkgcmV0dXJuIGZhbHNlO1xuICBzd2l0Y2ggKGNsYXNzb2YkMyhhcmd1bWVudCkpIHtcbiAgICBjYXNlICdBc3luY0Z1bmN0aW9uJzpcbiAgICBjYXNlICdHZW5lcmF0b3JGdW5jdGlvbic6XG4gICAgY2FzZSAnQXN5bmNHZW5lcmF0b3JGdW5jdGlvbic6IHJldHVybiBmYWxzZTtcbiAgfVxuICB0cnkge1xuICAgIC8vIHdlIGNhbid0IGNoZWNrIC5wcm90b3R5cGUgc2luY2UgY29uc3RydWN0b3JzIHByb2R1Y2VkIGJ5IC5iaW5kIGhhdmVuJ3QgaXRcbiAgICAvLyBgRnVuY3Rpb24jdG9TdHJpbmdgIHRocm93cyBvbiBzb21lIGJ1aWx0LWl0IGZ1bmN0aW9uIGluIHNvbWUgbGVnYWN5IGVuZ2luZXNcbiAgICAvLyAoZm9yIGV4YW1wbGUsIGBET01RdWFkYCBhbmQgc2ltaWxhciBpbiBGRjQxLSlcbiAgICByZXR1cm4gSU5DT1JSRUNUX1RPX1NUUklORyB8fCAhIWV4ZWMkMyhjb25zdHJ1Y3RvclJlZ0V4cCwgaW5zcGVjdFNvdXJjZSQxKGFyZ3VtZW50KSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cbmlzQ29uc3RydWN0b3JMZWdhY3kuc2hhbSA9IHRydWU7XG5cbi8vIGBJc0NvbnN0cnVjdG9yYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaXNjb25zdHJ1Y3RvclxudmFyIGlzQ29uc3RydWN0b3IkMiA9ICFjb25zdHJ1Y3QgfHwgZmFpbHMkNyhmdW5jdGlvbiAoKSB7XG4gIHZhciBjYWxsZWQ7XG4gIHJldHVybiBpc0NvbnN0cnVjdG9yTW9kZXJuKGlzQ29uc3RydWN0b3JNb2Rlcm4uY2FsbClcbiAgICB8fCAhaXNDb25zdHJ1Y3Rvck1vZGVybihPYmplY3QpXG4gICAgfHwgIWlzQ29uc3RydWN0b3JNb2Rlcm4oZnVuY3Rpb24gKCkgeyBjYWxsZWQgPSB0cnVlOyB9KVxuICAgIHx8IGNhbGxlZDtcbn0pID8gaXNDb25zdHJ1Y3RvckxlZ2FjeSA6IGlzQ29uc3RydWN0b3JNb2Rlcm47XG5cbnZhciBpc0NvbnN0cnVjdG9yJDEgPSBpc0NvbnN0cnVjdG9yJDI7XG52YXIgdHJ5VG9TdHJpbmckMiA9IHRyeVRvU3RyaW5nJDQ7XG5cbnZhciAkVHlwZUVycm9yJDQgPSBUeXBlRXJyb3I7XG5cbi8vIGBBc3NlcnQ6IElzQ29uc3RydWN0b3IoYXJndW1lbnQpIGlzIHRydWVgXG52YXIgYUNvbnN0cnVjdG9yJDEgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgaWYgKGlzQ29uc3RydWN0b3IkMShhcmd1bWVudCkpIHJldHVybiBhcmd1bWVudDtcbiAgdGhyb3cgJFR5cGVFcnJvciQ0KHRyeVRvU3RyaW5nJDIoYXJndW1lbnQpICsgJyBpcyBub3QgYSBjb25zdHJ1Y3RvcicpO1xufTtcblxudmFyIGFuT2JqZWN0JDggPSBhbk9iamVjdCRnO1xudmFyIGFDb25zdHJ1Y3RvciA9IGFDb25zdHJ1Y3RvciQxO1xudmFyIHdlbGxLbm93blN5bWJvbCQ5ID0gd2VsbEtub3duU3ltYm9sJGk7XG5cbnZhciBTUEVDSUVTJDIgPSB3ZWxsS25vd25TeW1ib2wkOSgnc3BlY2llcycpO1xuXG4vLyBgU3BlY2llc0NvbnN0cnVjdG9yYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3BlY2llc2NvbnN0cnVjdG9yXG52YXIgc3BlY2llc0NvbnN0cnVjdG9yJDEgPSBmdW5jdGlvbiAoTywgZGVmYXVsdENvbnN0cnVjdG9yKSB7XG4gIHZhciBDID0gYW5PYmplY3QkOChPKS5jb25zdHJ1Y3RvcjtcbiAgdmFyIFM7XG4gIHJldHVybiBDID09PSB1bmRlZmluZWQgfHwgKFMgPSBhbk9iamVjdCQ4KEMpW1NQRUNJRVMkMl0pID09IHVuZGVmaW5lZCA/IGRlZmF1bHRDb25zdHJ1Y3RvciA6IGFDb25zdHJ1Y3RvcihTKTtcbn07XG5cbnZhciBOQVRJVkVfQklORCQxID0gZnVuY3Rpb25CaW5kTmF0aXZlO1xuXG52YXIgRnVuY3Rpb25Qcm90b3R5cGUgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG52YXIgYXBwbHkkMiA9IEZ1bmN0aW9uUHJvdG90eXBlLmFwcGx5O1xudmFyIGNhbGwkYyA9IEZ1bmN0aW9uUHJvdG90eXBlLmNhbGw7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLXJlZmxlY3QgLS0gc2FmZVxudmFyIGZ1bmN0aW9uQXBwbHkgPSB0eXBlb2YgUmVmbGVjdCA9PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmFwcGx5IHx8IChOQVRJVkVfQklORCQxID8gY2FsbCRjLmJpbmQoYXBwbHkkMikgOiBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBjYWxsJGMuYXBwbHkoYXBwbHkkMiwgYXJndW1lbnRzKTtcbn0pO1xuXG52YXIgdW5jdXJyeVRoaXMkOSA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgYUNhbGxhYmxlJDUgPSBhQ2FsbGFibGUkNztcbnZhciBOQVRJVkVfQklORCA9IGZ1bmN0aW9uQmluZE5hdGl2ZTtcblxudmFyIGJpbmQkNyA9IHVuY3VycnlUaGlzJDkodW5jdXJyeVRoaXMkOS5iaW5kKTtcblxuLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG52YXIgZnVuY3Rpb25CaW5kQ29udGV4dCA9IGZ1bmN0aW9uIChmbiwgdGhhdCkge1xuICBhQ2FsbGFibGUkNShmbik7XG4gIHJldHVybiB0aGF0ID09PSB1bmRlZmluZWQgPyBmbiA6IE5BVElWRV9CSU5EID8gYmluZCQ3KGZuLCB0aGF0KSA6IGZ1bmN0aW9uICgvKiAuLi5hcmdzICovKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuXG52YXIgdW5jdXJyeVRoaXMkOCA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG5cbnZhciBhcnJheVNsaWNlJDMgPSB1bmN1cnJ5VGhpcyQ4KFtdLnNsaWNlKTtcblxudmFyICRUeXBlRXJyb3IkMyA9IFR5cGVFcnJvcjtcblxudmFyIHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoJDMgPSBmdW5jdGlvbiAocGFzc2VkLCByZXF1aXJlZCkge1xuICBpZiAocGFzc2VkIDwgcmVxdWlyZWQpIHRocm93ICRUeXBlRXJyb3IkMygnTm90IGVub3VnaCBhcmd1bWVudHMnKTtcbiAgcmV0dXJuIHBhc3NlZDtcbn07XG5cbnZhciB1c2VyQWdlbnQkMiA9IGVuZ2luZVVzZXJBZ2VudDtcblxudmFyIGVuZ2luZUlzSW9zID0gLyg/OmlwYWR8aXBob25lfGlwb2QpLiphcHBsZXdlYmtpdC9pLnRlc3QodXNlckFnZW50JDIpO1xuXG52YXIgZ2xvYmFsJGQgPSBnbG9iYWwkbztcbnZhciBhcHBseSQxID0gZnVuY3Rpb25BcHBseTtcbnZhciBiaW5kJDYgPSBmdW5jdGlvbkJpbmRDb250ZXh0O1xudmFyIGlzQ2FsbGFibGUkNiA9IGlzQ2FsbGFibGUkbjtcbnZhciBoYXNPd24kMiA9IGhhc093blByb3BlcnR5XzE7XG52YXIgZmFpbHMkNiA9IGZhaWxzJGs7XG52YXIgaHRtbCA9IGh0bWwkMjtcbnZhciBhcnJheVNsaWNlJDIgPSBhcnJheVNsaWNlJDM7XG52YXIgY3JlYXRlRWxlbWVudCA9IGRvY3VtZW50Q3JlYXRlRWxlbWVudCQyO1xudmFyIHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoJDIgPSB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aCQzO1xudmFyIElTX0lPUyQxID0gZW5naW5lSXNJb3M7XG52YXIgSVNfTk9ERSQyID0gZW5naW5lSXNOb2RlO1xuXG52YXIgc2V0ID0gZ2xvYmFsJGQuc2V0SW1tZWRpYXRlO1xudmFyIGNsZWFyID0gZ2xvYmFsJGQuY2xlYXJJbW1lZGlhdGU7XG52YXIgcHJvY2VzcyQyID0gZ2xvYmFsJGQucHJvY2VzcztcbnZhciBEaXNwYXRjaCA9IGdsb2JhbCRkLkRpc3BhdGNoO1xudmFyIEZ1bmN0aW9uJDEgPSBnbG9iYWwkZC5GdW5jdGlvbjtcbnZhciBNZXNzYWdlQ2hhbm5lbCA9IGdsb2JhbCRkLk1lc3NhZ2VDaGFubmVsO1xudmFyIFN0cmluZyQxID0gZ2xvYmFsJGQuU3RyaW5nO1xudmFyIGNvdW50ZXIgPSAwO1xudmFyIHF1ZXVlJDEgPSB7fTtcbnZhciBPTlJFQURZU1RBVEVDSEFOR0UgPSAnb25yZWFkeXN0YXRlY2hhbmdlJztcbnZhciBsb2NhdGlvbiwgZGVmZXIsIGNoYW5uZWwsIHBvcnQ7XG5cbnRyeSB7XG4gIC8vIERlbm8gdGhyb3dzIGEgUmVmZXJlbmNlRXJyb3Igb24gYGxvY2F0aW9uYCBhY2Nlc3Mgd2l0aG91dCBgLS1sb2NhdGlvbmAgZmxhZ1xuICBsb2NhdGlvbiA9IGdsb2JhbCRkLmxvY2F0aW9uO1xufSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuXG52YXIgcnVuID0gZnVuY3Rpb24gKGlkKSB7XG4gIGlmIChoYXNPd24kMihxdWV1ZSQxLCBpZCkpIHtcbiAgICB2YXIgZm4gPSBxdWV1ZSQxW2lkXTtcbiAgICBkZWxldGUgcXVldWUkMVtpZF07XG4gICAgZm4oKTtcbiAgfVxufTtcblxudmFyIHJ1bm5lciA9IGZ1bmN0aW9uIChpZCkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJ1bihpZCk7XG4gIH07XG59O1xuXG52YXIgbGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgcnVuKGV2ZW50LmRhdGEpO1xufTtcblxudmFyIHBvc3QgPSBmdW5jdGlvbiAoaWQpIHtcbiAgLy8gb2xkIGVuZ2luZXMgaGF2ZSBub3QgbG9jYXRpb24ub3JpZ2luXG4gIGdsb2JhbCRkLnBvc3RNZXNzYWdlKFN0cmluZyQxKGlkKSwgbG9jYXRpb24ucHJvdG9jb2wgKyAnLy8nICsgbG9jYXRpb24uaG9zdCk7XG59O1xuXG4vLyBOb2RlLmpzIDAuOSsgJiBJRTEwKyBoYXMgc2V0SW1tZWRpYXRlLCBvdGhlcndpc2U6XG5pZiAoIXNldCB8fCAhY2xlYXIpIHtcbiAgc2V0ID0gZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGhhbmRsZXIpIHtcbiAgICB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aCQyKGFyZ3VtZW50cy5sZW5ndGgsIDEpO1xuICAgIHZhciBmbiA9IGlzQ2FsbGFibGUkNihoYW5kbGVyKSA/IGhhbmRsZXIgOiBGdW5jdGlvbiQxKGhhbmRsZXIpO1xuICAgIHZhciBhcmdzID0gYXJyYXlTbGljZSQyKGFyZ3VtZW50cywgMSk7XG4gICAgcXVldWUkMVsrK2NvdW50ZXJdID0gZnVuY3Rpb24gKCkge1xuICAgICAgYXBwbHkkMShmbiwgdW5kZWZpbmVkLCBhcmdzKTtcbiAgICB9O1xuICAgIGRlZmVyKGNvdW50ZXIpO1xuICAgIHJldHVybiBjb3VudGVyO1xuICB9O1xuICBjbGVhciA9IGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGlkKSB7XG4gICAgZGVsZXRlIHF1ZXVlJDFbaWRdO1xuICB9O1xuICAvLyBOb2RlLmpzIDAuOC1cbiAgaWYgKElTX05PREUkMikge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBwcm9jZXNzJDIubmV4dFRpY2socnVubmVyKGlkKSk7XG4gICAgfTtcbiAgLy8gU3BoZXJlIChKUyBnYW1lIGVuZ2luZSkgRGlzcGF0Y2ggQVBJXG4gIH0gZWxzZSBpZiAoRGlzcGF0Y2ggJiYgRGlzcGF0Y2gubm93KSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIERpc3BhdGNoLm5vdyhydW5uZXIoaWQpKTtcbiAgICB9O1xuICAvLyBCcm93c2VycyB3aXRoIE1lc3NhZ2VDaGFubmVsLCBpbmNsdWRlcyBXZWJXb3JrZXJzXG4gIC8vIGV4Y2VwdCBpT1MgLSBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNjI0XG4gIH0gZWxzZSBpZiAoTWVzc2FnZUNoYW5uZWwgJiYgIUlTX0lPUyQxKSB7XG4gICAgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgIHBvcnQgPSBjaGFubmVsLnBvcnQyO1xuICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gbGlzdGVuZXI7XG4gICAgZGVmZXIgPSBiaW5kJDYocG9ydC5wb3N0TWVzc2FnZSwgcG9ydCk7XG4gIC8vIEJyb3dzZXJzIHdpdGggcG9zdE1lc3NhZ2UsIHNraXAgV2ViV29ya2Vyc1xuICAvLyBJRTggaGFzIHBvc3RNZXNzYWdlLCBidXQgaXQncyBzeW5jICYgdHlwZW9mIGl0cyBwb3N0TWVzc2FnZSBpcyAnb2JqZWN0J1xuICB9IGVsc2UgaWYgKFxuICAgIGdsb2JhbCRkLmFkZEV2ZW50TGlzdGVuZXIgJiZcbiAgICBpc0NhbGxhYmxlJDYoZ2xvYmFsJGQucG9zdE1lc3NhZ2UpICYmXG4gICAgIWdsb2JhbCRkLmltcG9ydFNjcmlwdHMgJiZcbiAgICBsb2NhdGlvbiAmJiBsb2NhdGlvbi5wcm90b2NvbCAhPT0gJ2ZpbGU6JyAmJlxuICAgICFmYWlscyQ2KHBvc3QpXG4gICkge1xuICAgIGRlZmVyID0gcG9zdDtcbiAgICBnbG9iYWwkZC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuZXIsIGZhbHNlKTtcbiAgLy8gSUU4LVxuICB9IGVsc2UgaWYgKE9OUkVBRFlTVEFURUNIQU5HRSBpbiBjcmVhdGVFbGVtZW50KCdzY3JpcHQnKSkge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBodG1sLmFwcGVuZENoaWxkKGNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpKVtPTlJFQURZU1RBVEVDSEFOR0VdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgICAgICBydW4oaWQpO1xuICAgICAgfTtcbiAgICB9O1xuICAvLyBSZXN0IG9sZCBicm93c2Vyc1xuICB9IGVsc2Uge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBzZXRUaW1lb3V0KHJ1bm5lcihpZCksIDApO1xuICAgIH07XG4gIH1cbn1cblxudmFyIHRhc2skMSA9IHtcbiAgc2V0OiBzZXQsXG4gIGNsZWFyOiBjbGVhclxufTtcblxudmFyIHVzZXJBZ2VudCQxID0gZW5naW5lVXNlckFnZW50O1xudmFyIGdsb2JhbCRjID0gZ2xvYmFsJG87XG5cbnZhciBlbmdpbmVJc0lvc1BlYmJsZSA9IC9pcGFkfGlwaG9uZXxpcG9kL2kudGVzdCh1c2VyQWdlbnQkMSkgJiYgZ2xvYmFsJGMuUGViYmxlICE9PSB1bmRlZmluZWQ7XG5cbnZhciB1c2VyQWdlbnQgPSBlbmdpbmVVc2VyQWdlbnQ7XG5cbnZhciBlbmdpbmVJc1dlYm9zV2Via2l0ID0gL3dlYjBzKD8hLipjaHJvbWUpL2kudGVzdCh1c2VyQWdlbnQpO1xuXG52YXIgZ2xvYmFsJGIgPSBnbG9iYWwkbztcbnZhciBiaW5kJDUgPSBmdW5jdGlvbkJpbmRDb250ZXh0O1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciQxID0gb2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLmY7XG52YXIgbWFjcm90YXNrID0gdGFzayQxLnNldDtcbnZhciBJU19JT1MgPSBlbmdpbmVJc0lvcztcbnZhciBJU19JT1NfUEVCQkxFID0gZW5naW5lSXNJb3NQZWJibGU7XG52YXIgSVNfV0VCT1NfV0VCS0lUID0gZW5naW5lSXNXZWJvc1dlYmtpdDtcbnZhciBJU19OT0RFJDEgPSBlbmdpbmVJc05vZGU7XG5cbnZhciBNdXRhdGlvbk9ic2VydmVyID0gZ2xvYmFsJGIuTXV0YXRpb25PYnNlcnZlciB8fCBnbG9iYWwkYi5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xudmFyIGRvY3VtZW50JDIgPSBnbG9iYWwkYi5kb2N1bWVudDtcbnZhciBwcm9jZXNzJDEgPSBnbG9iYWwkYi5wcm9jZXNzO1xudmFyIFByb21pc2UkMSA9IGdsb2JhbCRiLlByb21pc2U7XG4vLyBOb2RlLmpzIDExIHNob3dzIEV4cGVyaW1lbnRhbFdhcm5pbmcgb24gZ2V0dGluZyBgcXVldWVNaWNyb3Rhc2tgXG52YXIgcXVldWVNaWNyb3Rhc2tEZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEoZ2xvYmFsJGIsICdxdWV1ZU1pY3JvdGFzaycpO1xudmFyIHF1ZXVlTWljcm90YXNrID0gcXVldWVNaWNyb3Rhc2tEZXNjcmlwdG9yICYmIHF1ZXVlTWljcm90YXNrRGVzY3JpcHRvci52YWx1ZTtcblxudmFyIGZsdXNoLCBoZWFkLCBsYXN0LCBub3RpZnkkMSwgdG9nZ2xlLCBub2RlLCBwcm9taXNlLCB0aGVuO1xuXG4vLyBtb2Rlcm4gZW5naW5lcyBoYXZlIHF1ZXVlTWljcm90YXNrIG1ldGhvZFxuaWYgKCFxdWV1ZU1pY3JvdGFzaykge1xuICBmbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGFyZW50LCBmbjtcbiAgICBpZiAoSVNfTk9ERSQxICYmIChwYXJlbnQgPSBwcm9jZXNzJDEuZG9tYWluKSkgcGFyZW50LmV4aXQoKTtcbiAgICB3aGlsZSAoaGVhZCkge1xuICAgICAgZm4gPSBoZWFkLmZuO1xuICAgICAgaGVhZCA9IGhlYWQubmV4dDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZuKCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoaGVhZCkgbm90aWZ5JDEoKTtcbiAgICAgICAgZWxzZSBsYXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9IGxhc3QgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHBhcmVudCkgcGFyZW50LmVudGVyKCk7XG4gIH07XG5cbiAgLy8gYnJvd3NlcnMgd2l0aCBNdXRhdGlvbk9ic2VydmVyLCBleGNlcHQgaU9TIC0gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzMzOVxuICAvLyBhbHNvIGV4Y2VwdCBXZWJPUyBXZWJraXQgaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg5OFxuICBpZiAoIUlTX0lPUyAmJiAhSVNfTk9ERSQxICYmICFJU19XRUJPU19XRUJLSVQgJiYgTXV0YXRpb25PYnNlcnZlciAmJiBkb2N1bWVudCQyKSB7XG4gICAgdG9nZ2xlID0gdHJ1ZTtcbiAgICBub2RlID0gZG9jdW1lbnQkMi5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZmx1c2gpLm9ic2VydmUobm9kZSwgeyBjaGFyYWN0ZXJEYXRhOiB0cnVlIH0pO1xuICAgIG5vdGlmeSQxID0gZnVuY3Rpb24gKCkge1xuICAgICAgbm9kZS5kYXRhID0gdG9nZ2xlID0gIXRvZ2dsZTtcbiAgICB9O1xuICAvLyBlbnZpcm9ubWVudHMgd2l0aCBtYXliZSBub24tY29tcGxldGVseSBjb3JyZWN0LCBidXQgZXhpc3RlbnQgUHJvbWlzZVxuICB9IGVsc2UgaWYgKCFJU19JT1NfUEVCQkxFICYmIFByb21pc2UkMSAmJiBQcm9taXNlJDEucmVzb2x2ZSkge1xuICAgIC8vIFByb21pc2UucmVzb2x2ZSB3aXRob3V0IGFuIGFyZ3VtZW50IHRocm93cyBhbiBlcnJvciBpbiBMRyBXZWJPUyAyXG4gICAgcHJvbWlzZSA9IFByb21pc2UkMS5yZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgLy8gd29ya2Fyb3VuZCBvZiBXZWJLaXQgfiBpT1MgU2FmYXJpIDEwLjEgYnVnXG4gICAgcHJvbWlzZS5jb25zdHJ1Y3RvciA9IFByb21pc2UkMTtcbiAgICB0aGVuID0gYmluZCQ1KHByb21pc2UudGhlbiwgcHJvbWlzZSk7XG4gICAgbm90aWZ5JDEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGVuKGZsdXNoKTtcbiAgICB9O1xuICAvLyBOb2RlLmpzIHdpdGhvdXQgcHJvbWlzZXNcbiAgfSBlbHNlIGlmIChJU19OT0RFJDEpIHtcbiAgICBub3RpZnkkMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHByb2Nlc3MkMS5uZXh0VGljayhmbHVzaCk7XG4gICAgfTtcbiAgLy8gZm9yIG90aGVyIGVudmlyb25tZW50cyAtIG1hY3JvdGFzayBiYXNlZCBvbjpcbiAgLy8gLSBzZXRJbW1lZGlhdGVcbiAgLy8gLSBNZXNzYWdlQ2hhbm5lbFxuICAvLyAtIHdpbmRvdy5wb3N0TWVzc2FnZVxuICAvLyAtIG9ucmVhZHlzdGF0ZWNoYW5nZVxuICAvLyAtIHNldFRpbWVvdXRcbiAgfSBlbHNlIHtcbiAgICAvLyBzdHJhbmdlIElFICsgd2VicGFjayBkZXYgc2VydmVyIGJ1ZyAtIHVzZSAuYmluZChnbG9iYWwpXG4gICAgbWFjcm90YXNrID0gYmluZCQ1KG1hY3JvdGFzaywgZ2xvYmFsJGIpO1xuICAgIG5vdGlmeSQxID0gZnVuY3Rpb24gKCkge1xuICAgICAgbWFjcm90YXNrKGZsdXNoKTtcbiAgICB9O1xuICB9XG59XG5cbnZhciBtaWNyb3Rhc2skMSA9IHF1ZXVlTWljcm90YXNrIHx8IGZ1bmN0aW9uIChmbikge1xuICB2YXIgdGFzayA9IHsgZm46IGZuLCBuZXh0OiB1bmRlZmluZWQgfTtcbiAgaWYgKGxhc3QpIGxhc3QubmV4dCA9IHRhc2s7XG4gIGlmICghaGVhZCkge1xuICAgIGhlYWQgPSB0YXNrO1xuICAgIG5vdGlmeSQxKCk7XG4gIH0gbGFzdCA9IHRhc2s7XG59O1xuXG52YXIgZ2xvYmFsJGEgPSBnbG9iYWwkbztcblxudmFyIGhvc3RSZXBvcnRFcnJvcnMkMSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gIHZhciBjb25zb2xlID0gZ2xvYmFsJGEuY29uc29sZTtcbiAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS5lcnJvcikge1xuICAgIGFyZ3VtZW50cy5sZW5ndGggPT0gMSA/IGNvbnNvbGUuZXJyb3IoYSkgOiBjb25zb2xlLmVycm9yKGEsIGIpO1xuICB9XG59O1xuXG52YXIgcGVyZm9ybSQzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4geyBlcnJvcjogZmFsc2UsIHZhbHVlOiBleGVjKCkgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4geyBlcnJvcjogdHJ1ZSwgdmFsdWU6IGVycm9yIH07XG4gIH1cbn07XG5cbnZhciBRdWV1ZSQxID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmhlYWQgPSBudWxsO1xuICB0aGlzLnRhaWwgPSBudWxsO1xufTtcblxuUXVldWUkMS5wcm90b3R5cGUgPSB7XG4gIGFkZDogZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICB2YXIgZW50cnkgPSB7IGl0ZW06IGl0ZW0sIG5leHQ6IG51bGwgfTtcbiAgICBpZiAodGhpcy5oZWFkKSB0aGlzLnRhaWwubmV4dCA9IGVudHJ5O1xuICAgIGVsc2UgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgdGhpcy50YWlsID0gZW50cnk7XG4gIH0sXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbnRyeSA9IHRoaXMuaGVhZDtcbiAgICBpZiAoZW50cnkpIHtcbiAgICAgIHRoaXMuaGVhZCA9IGVudHJ5Lm5leHQ7XG4gICAgICBpZiAodGhpcy50YWlsID09PSBlbnRyeSkgdGhpcy50YWlsID0gbnVsbDtcbiAgICAgIHJldHVybiBlbnRyeS5pdGVtO1xuICAgIH1cbiAgfVxufTtcblxudmFyIHF1ZXVlID0gUXVldWUkMTtcblxudmFyIGdsb2JhbCQ5ID0gZ2xvYmFsJG87XG5cbnZhciBwcm9taXNlTmF0aXZlQ29uc3RydWN0b3IgPSBnbG9iYWwkOS5Qcm9taXNlO1xuXG52YXIgZW5naW5lSXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgRGVubyAhPSAnb2JqZWN0JztcblxudmFyIGdsb2JhbCQ4ID0gZ2xvYmFsJG87XG52YXIgTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yJDMgPSBwcm9taXNlTmF0aXZlQ29uc3RydWN0b3I7XG52YXIgaXNDYWxsYWJsZSQ1ID0gaXNDYWxsYWJsZSRuO1xudmFyIGlzRm9yY2VkID0gaXNGb3JjZWRfMTtcbnZhciBpbnNwZWN0U291cmNlID0gaW5zcGVjdFNvdXJjZSQ0O1xudmFyIHdlbGxLbm93blN5bWJvbCQ4ID0gd2VsbEtub3duU3ltYm9sJGk7XG52YXIgSVNfQlJPV1NFUiA9IGVuZ2luZUlzQnJvd3NlcjtcbnZhciBWOF9WRVJTSU9OID0gZW5naW5lVjhWZXJzaW9uO1xuXG5OYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMyAmJiBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMy5wcm90b3R5cGU7XG52YXIgU1BFQ0lFUyQxID0gd2VsbEtub3duU3ltYm9sJDgoJ3NwZWNpZXMnKTtcbnZhciBTVUJDTEFTU0lORyA9IGZhbHNlO1xudmFyIE5BVElWRV9QUk9NSVNFX1JFSkVDVElPTl9FVkVOVCQxID0gaXNDYWxsYWJsZSQ1KGdsb2JhbCQ4LlByb21pc2VSZWplY3Rpb25FdmVudCk7XG5cbnZhciBGT1JDRURfUFJPTUlTRV9DT05TVFJVQ1RPUiQ1ID0gaXNGb3JjZWQoJ1Byb21pc2UnLCBmdW5jdGlvbiAoKSB7XG4gIHZhciBQUk9NSVNFX0NPTlNUUlVDVE9SX1NPVVJDRSA9IGluc3BlY3RTb3VyY2UoTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yJDMpO1xuICB2YXIgR0xPQkFMX0NPUkVfSlNfUFJPTUlTRSA9IFBST01JU0VfQ09OU1RSVUNUT1JfU09VUkNFICE9PSBTdHJpbmcoTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yJDMpO1xuICAvLyBWOCA2LjYgKE5vZGUgMTAgYW5kIENocm9tZSA2NikgaGF2ZSBhIGJ1ZyB3aXRoIHJlc29sdmluZyBjdXN0b20gdGhlbmFibGVzXG4gIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTgzMDU2NVxuICAvLyBXZSBjYW4ndCBkZXRlY3QgaXQgc3luY2hyb25vdXNseSwgc28ganVzdCBjaGVjayB2ZXJzaW9uc1xuICBpZiAoIUdMT0JBTF9DT1JFX0pTX1BST01JU0UgJiYgVjhfVkVSU0lPTiA9PT0gNjYpIHJldHVybiB0cnVlO1xuICAvLyBXZSBjYW4ndCB1c2UgQEBzcGVjaWVzIGZlYXR1cmUgZGV0ZWN0aW9uIGluIFY4IHNpbmNlIGl0IGNhdXNlc1xuICAvLyBkZW9wdGltaXphdGlvbiBhbmQgcGVyZm9ybWFuY2UgZGVncmFkYXRpb25cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzY3OVxuICBpZiAoVjhfVkVSU0lPTiA+PSA1MSAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoUFJPTUlTRV9DT05TVFJVQ1RPUl9TT1VSQ0UpKSByZXR1cm4gZmFsc2U7XG4gIC8vIERldGVjdCBjb3JyZWN0bmVzcyBvZiBzdWJjbGFzc2luZyB3aXRoIEBAc3BlY2llcyBzdXBwb3J0XG4gIHZhciBwcm9taXNlID0gbmV3IE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQzKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUoMSk7IH0pO1xuICB2YXIgRmFrZVByb21pc2UgPSBmdW5jdGlvbiAoZXhlYykge1xuICAgIGV4ZWMoZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9LCBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0pO1xuICB9O1xuICB2YXIgY29uc3RydWN0b3IgPSBwcm9taXNlLmNvbnN0cnVjdG9yID0ge307XG4gIGNvbnN0cnVjdG9yW1NQRUNJRVMkMV0gPSBGYWtlUHJvbWlzZTtcbiAgU1VCQ0xBU1NJTkcgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9KSBpbnN0YW5jZW9mIEZha2VQcm9taXNlO1xuICBpZiAoIVNVQkNMQVNTSU5HKSByZXR1cm4gdHJ1ZTtcbiAgLy8gVW5oYW5kbGVkIHJlamVjdGlvbnMgdHJhY2tpbmcgc3VwcG9ydCwgTm9kZUpTIFByb21pc2Ugd2l0aG91dCBpdCBmYWlscyBAQHNwZWNpZXMgdGVzdFxuICByZXR1cm4gIUdMT0JBTF9DT1JFX0pTX1BST01JU0UgJiYgSVNfQlJPV1NFUiAmJiAhTkFUSVZFX1BST01JU0VfUkVKRUNUSU9OX0VWRU5UJDE7XG59KTtcblxudmFyIHByb21pc2VDb25zdHJ1Y3RvckRldGVjdGlvbiA9IHtcbiAgQ09OU1RSVUNUT1I6IEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SJDUsXG4gIFJFSkVDVElPTl9FVkVOVDogTkFUSVZFX1BST01JU0VfUkVKRUNUSU9OX0VWRU5UJDEsXG4gIFNVQkNMQVNTSU5HOiBTVUJDTEFTU0lOR1xufTtcblxudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5JDIgPSB7fTtcblxudmFyIGFDYWxsYWJsZSQ0ID0gYUNhbGxhYmxlJDc7XG5cbnZhciBQcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uIChDKSB7XG4gIHZhciByZXNvbHZlLCByZWplY3Q7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBDKGZ1bmN0aW9uICgkJHJlc29sdmUsICQkcmVqZWN0KSB7XG4gICAgaWYgKHJlc29sdmUgIT09IHVuZGVmaW5lZCB8fCByZWplY3QgIT09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKCdCYWQgUHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xuICAgIHJlc29sdmUgPSAkJHJlc29sdmU7XG4gICAgcmVqZWN0ID0gJCRyZWplY3Q7XG4gIH0pO1xuICB0aGlzLnJlc29sdmUgPSBhQ2FsbGFibGUkNChyZXNvbHZlKTtcbiAgdGhpcy5yZWplY3QgPSBhQ2FsbGFibGUkNChyZWplY3QpO1xufTtcblxuLy8gYE5ld1Byb21pc2VDYXBhYmlsaXR5YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbmV3cHJvbWlzZWNhcGFiaWxpdHlcbm5ld1Byb21pc2VDYXBhYmlsaXR5JDIuZiA9IGZ1bmN0aW9uIChDKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG59O1xuXG52YXIgJCQ4ID0gX2V4cG9ydDtcbnZhciBJU19OT0RFID0gZW5naW5lSXNOb2RlO1xudmFyIGdsb2JhbCQ3ID0gZ2xvYmFsJG87XG52YXIgY2FsbCRiID0gZnVuY3Rpb25DYWxsO1xudmFyIGRlZmluZUJ1aWx0SW4kNSA9IGRlZmluZUJ1aWx0SW4kYTtcbnZhciBzZXRQcm90b3R5cGVPZiA9IG9iamVjdFNldFByb3RvdHlwZU9mO1xudmFyIHNldFRvU3RyaW5nVGFnJDIgPSBzZXRUb1N0cmluZ1RhZyQ1O1xudmFyIHNldFNwZWNpZXMgPSBzZXRTcGVjaWVzJDE7XG52YXIgYUNhbGxhYmxlJDMgPSBhQ2FsbGFibGUkNztcbnZhciBpc0NhbGxhYmxlJDQgPSBpc0NhbGxhYmxlJG47XG52YXIgaXNPYmplY3QkMiA9IGlzT2JqZWN0JDg7XG52YXIgYW5JbnN0YW5jZSQyID0gYW5JbnN0YW5jZSQzO1xudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHNwZWNpZXNDb25zdHJ1Y3RvciQxO1xudmFyIHRhc2sgPSB0YXNrJDEuc2V0O1xudmFyIG1pY3JvdGFzayA9IG1pY3JvdGFzayQxO1xudmFyIGhvc3RSZXBvcnRFcnJvcnMgPSBob3N0UmVwb3J0RXJyb3JzJDE7XG52YXIgcGVyZm9ybSQyID0gcGVyZm9ybSQzO1xudmFyIFF1ZXVlID0gcXVldWU7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSQzID0gaW50ZXJuYWxTdGF0ZTtcbnZhciBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMiA9IHByb21pc2VOYXRpdmVDb25zdHJ1Y3RvcjtcbnZhciBQcm9taXNlQ29uc3RydWN0b3JEZXRlY3Rpb24gPSBwcm9taXNlQ29uc3RydWN0b3JEZXRlY3Rpb247XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUkMyA9IG5ld1Byb21pc2VDYXBhYmlsaXR5JDI7XG5cbnZhciBQUk9NSVNFID0gJ1Byb21pc2UnO1xudmFyIEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SJDQgPSBQcm9taXNlQ29uc3RydWN0b3JEZXRlY3Rpb24uQ09OU1RSVUNUT1I7XG52YXIgTkFUSVZFX1BST01JU0VfUkVKRUNUSU9OX0VWRU5UID0gUHJvbWlzZUNvbnN0cnVjdG9yRGV0ZWN0aW9uLlJFSkVDVElPTl9FVkVOVDtcbnZhciBOQVRJVkVfUFJPTUlTRV9TVUJDTEFTU0lORyA9IFByb21pc2VDb25zdHJ1Y3RvckRldGVjdGlvbi5TVUJDTEFTU0lORztcbnZhciBnZXRJbnRlcm5hbFByb21pc2VTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUkMy5nZXR0ZXJGb3IoUFJPTUlTRSk7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSQzID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQzLnNldDtcbnZhciBOYXRpdmVQcm9taXNlUHJvdG90eXBlJDEgPSBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMiAmJiBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMi5wcm90b3R5cGU7XG52YXIgUHJvbWlzZUNvbnN0cnVjdG9yID0gTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yJDI7XG52YXIgUHJvbWlzZVByb3RvdHlwZSA9IE5hdGl2ZVByb21pc2VQcm90b3R5cGUkMTtcbnZhciBUeXBlRXJyb3IkMyA9IGdsb2JhbCQ3LlR5cGVFcnJvcjtcbnZhciBkb2N1bWVudCQxID0gZ2xvYmFsJDcuZG9jdW1lbnQ7XG52YXIgcHJvY2VzcyA9IGdsb2JhbCQ3LnByb2Nlc3M7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkkMSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlJDMuZjtcbnZhciBuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSQxO1xuXG52YXIgRElTUEFUQ0hfRVZFTlQgPSAhIShkb2N1bWVudCQxICYmIGRvY3VtZW50JDEuY3JlYXRlRXZlbnQgJiYgZ2xvYmFsJDcuZGlzcGF0Y2hFdmVudCk7XG52YXIgVU5IQU5ETEVEX1JFSkVDVElPTiA9ICd1bmhhbmRsZWRyZWplY3Rpb24nO1xudmFyIFJFSkVDVElPTl9IQU5ETEVEID0gJ3JlamVjdGlvbmhhbmRsZWQnO1xudmFyIFBFTkRJTkcgPSAwO1xudmFyIEZVTEZJTExFRCA9IDE7XG52YXIgUkVKRUNURUQgPSAyO1xudmFyIEhBTkRMRUQgPSAxO1xudmFyIFVOSEFORExFRCA9IDI7XG5cbnZhciBJbnRlcm5hbCwgT3duUHJvbWlzZUNhcGFiaWxpdHksIFByb21pc2VXcmFwcGVyLCBuYXRpdmVUaGVuO1xuXG4vLyBoZWxwZXJzXG52YXIgaXNUaGVuYWJsZSA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgdGhlbjtcbiAgcmV0dXJuIGlzT2JqZWN0JDIoaXQpICYmIGlzQ2FsbGFibGUkNCh0aGVuID0gaXQudGhlbikgPyB0aGVuIDogZmFsc2U7XG59O1xuXG52YXIgY2FsbFJlYWN0aW9uID0gZnVuY3Rpb24gKHJlYWN0aW9uLCBzdGF0ZSkge1xuICB2YXIgdmFsdWUgPSBzdGF0ZS52YWx1ZTtcbiAgdmFyIG9rID0gc3RhdGUuc3RhdGUgPT0gRlVMRklMTEVEO1xuICB2YXIgaGFuZGxlciA9IG9rID8gcmVhY3Rpb24ub2sgOiByZWFjdGlvbi5mYWlsO1xuICB2YXIgcmVzb2x2ZSA9IHJlYWN0aW9uLnJlc29sdmU7XG4gIHZhciByZWplY3QgPSByZWFjdGlvbi5yZWplY3Q7XG4gIHZhciBkb21haW4gPSByZWFjdGlvbi5kb21haW47XG4gIHZhciByZXN1bHQsIHRoZW4sIGV4aXRlZDtcbiAgdHJ5IHtcbiAgICBpZiAoaGFuZGxlcikge1xuICAgICAgaWYgKCFvaykge1xuICAgICAgICBpZiAoc3RhdGUucmVqZWN0aW9uID09PSBVTkhBTkRMRUQpIG9uSGFuZGxlVW5oYW5kbGVkKHN0YXRlKTtcbiAgICAgICAgc3RhdGUucmVqZWN0aW9uID0gSEFORExFRDtcbiAgICAgIH1cbiAgICAgIGlmIChoYW5kbGVyID09PSB0cnVlKSByZXN1bHQgPSB2YWx1ZTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoZG9tYWluKSBkb21haW4uZW50ZXIoKTtcbiAgICAgICAgcmVzdWx0ID0gaGFuZGxlcih2YWx1ZSk7IC8vIGNhbiB0aHJvd1xuICAgICAgICBpZiAoZG9tYWluKSB7XG4gICAgICAgICAgZG9tYWluLmV4aXQoKTtcbiAgICAgICAgICBleGl0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0ID09PSByZWFjdGlvbi5wcm9taXNlKSB7XG4gICAgICAgIHJlamVjdChUeXBlRXJyb3IkMygnUHJvbWlzZS1jaGFpbiBjeWNsZScpKTtcbiAgICAgIH0gZWxzZSBpZiAodGhlbiA9IGlzVGhlbmFibGUocmVzdWx0KSkge1xuICAgICAgICBjYWxsJGIodGhlbiwgcmVzdWx0LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgfSBlbHNlIHJlc29sdmUocmVzdWx0KTtcbiAgICB9IGVsc2UgcmVqZWN0KHZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoZG9tYWluICYmICFleGl0ZWQpIGRvbWFpbi5leGl0KCk7XG4gICAgcmVqZWN0KGVycm9yKTtcbiAgfVxufTtcblxudmFyIG5vdGlmeSA9IGZ1bmN0aW9uIChzdGF0ZSwgaXNSZWplY3QpIHtcbiAgaWYgKHN0YXRlLm5vdGlmaWVkKSByZXR1cm47XG4gIHN0YXRlLm5vdGlmaWVkID0gdHJ1ZTtcbiAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVhY3Rpb25zID0gc3RhdGUucmVhY3Rpb25zO1xuICAgIHZhciByZWFjdGlvbjtcbiAgICB3aGlsZSAocmVhY3Rpb24gPSByZWFjdGlvbnMuZ2V0KCkpIHtcbiAgICAgIGNhbGxSZWFjdGlvbihyZWFjdGlvbiwgc3RhdGUpO1xuICAgIH1cbiAgICBzdGF0ZS5ub3RpZmllZCA9IGZhbHNlO1xuICAgIGlmIChpc1JlamVjdCAmJiAhc3RhdGUucmVqZWN0aW9uKSBvblVuaGFuZGxlZChzdGF0ZSk7XG4gIH0pO1xufTtcblxudmFyIGRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbiAobmFtZSwgcHJvbWlzZSwgcmVhc29uKSB7XG4gIHZhciBldmVudCwgaGFuZGxlcjtcbiAgaWYgKERJU1BBVENIX0VWRU5UKSB7XG4gICAgZXZlbnQgPSBkb2N1bWVudCQxLmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgIGV2ZW50LnByb21pc2UgPSBwcm9taXNlO1xuICAgIGV2ZW50LnJlYXNvbiA9IHJlYXNvbjtcbiAgICBldmVudC5pbml0RXZlbnQobmFtZSwgZmFsc2UsIHRydWUpO1xuICAgIGdsb2JhbCQ3LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICB9IGVsc2UgZXZlbnQgPSB7IHByb21pc2U6IHByb21pc2UsIHJlYXNvbjogcmVhc29uIH07XG4gIGlmICghTkFUSVZFX1BST01JU0VfUkVKRUNUSU9OX0VWRU5UICYmIChoYW5kbGVyID0gZ2xvYmFsJDdbJ29uJyArIG5hbWVdKSkgaGFuZGxlcihldmVudCk7XG4gIGVsc2UgaWYgKG5hbWUgPT09IFVOSEFORExFRF9SRUpFQ1RJT04pIGhvc3RSZXBvcnRFcnJvcnMoJ1VuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbicsIHJlYXNvbik7XG59O1xuXG52YXIgb25VbmhhbmRsZWQgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgY2FsbCRiKHRhc2ssIGdsb2JhbCQ3LCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByb21pc2UgPSBzdGF0ZS5mYWNhZGU7XG4gICAgdmFyIHZhbHVlID0gc3RhdGUudmFsdWU7XG4gICAgdmFyIElTX1VOSEFORExFRCA9IGlzVW5oYW5kbGVkKHN0YXRlKTtcbiAgICB2YXIgcmVzdWx0O1xuICAgIGlmIChJU19VTkhBTkRMRUQpIHtcbiAgICAgIHJlc3VsdCA9IHBlcmZvcm0kMihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChJU19OT0RFKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbWl0KCd1bmhhbmRsZWRSZWplY3Rpb24nLCB2YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgIH0gZWxzZSBkaXNwYXRjaEV2ZW50KFVOSEFORExFRF9SRUpFQ1RJT04sIHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgICAgLy8gQnJvd3NlcnMgc2hvdWxkIG5vdCB0cmlnZ2VyIGByZWplY3Rpb25IYW5kbGVkYCBldmVudCBpZiBpdCB3YXMgaGFuZGxlZCBoZXJlLCBOb2RlSlMgLSBzaG91bGRcbiAgICAgIHN0YXRlLnJlamVjdGlvbiA9IElTX05PREUgfHwgaXNVbmhhbmRsZWQoc3RhdGUpID8gVU5IQU5ETEVEIDogSEFORExFRDtcbiAgICAgIGlmIChyZXN1bHQuZXJyb3IpIHRocm93IHJlc3VsdC52YWx1ZTtcbiAgICB9XG4gIH0pO1xufTtcblxudmFyIGlzVW5oYW5kbGVkID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5yZWplY3Rpb24gIT09IEhBTkRMRUQgJiYgIXN0YXRlLnBhcmVudDtcbn07XG5cbnZhciBvbkhhbmRsZVVuaGFuZGxlZCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICBjYWxsJGIodGFzaywgZ2xvYmFsJDcsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvbWlzZSA9IHN0YXRlLmZhY2FkZTtcbiAgICBpZiAoSVNfTk9ERSkge1xuICAgICAgcHJvY2Vzcy5lbWl0KCdyZWplY3Rpb25IYW5kbGVkJywgcHJvbWlzZSk7XG4gICAgfSBlbHNlIGRpc3BhdGNoRXZlbnQoUkVKRUNUSU9OX0hBTkRMRUQsIHByb21pc2UsIHN0YXRlLnZhbHVlKTtcbiAgfSk7XG59O1xuXG52YXIgYmluZCQ0ID0gZnVuY3Rpb24gKGZuLCBzdGF0ZSwgdW53cmFwKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBmbihzdGF0ZSwgdmFsdWUsIHVud3JhcCk7XG4gIH07XG59O1xuXG52YXIgaW50ZXJuYWxSZWplY3QgPSBmdW5jdGlvbiAoc3RhdGUsIHZhbHVlLCB1bndyYXApIHtcbiAgaWYgKHN0YXRlLmRvbmUpIHJldHVybjtcbiAgc3RhdGUuZG9uZSA9IHRydWU7XG4gIGlmICh1bndyYXApIHN0YXRlID0gdW53cmFwO1xuICBzdGF0ZS52YWx1ZSA9IHZhbHVlO1xuICBzdGF0ZS5zdGF0ZSA9IFJFSkVDVEVEO1xuICBub3RpZnkoc3RhdGUsIHRydWUpO1xufTtcblxudmFyIGludGVybmFsUmVzb2x2ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgdmFsdWUsIHVud3JhcCkge1xuICBpZiAoc3RhdGUuZG9uZSkgcmV0dXJuO1xuICBzdGF0ZS5kb25lID0gdHJ1ZTtcbiAgaWYgKHVud3JhcCkgc3RhdGUgPSB1bndyYXA7XG4gIHRyeSB7XG4gICAgaWYgKHN0YXRlLmZhY2FkZSA9PT0gdmFsdWUpIHRocm93IFR5cGVFcnJvciQzKFwiUHJvbWlzZSBjYW4ndCBiZSByZXNvbHZlZCBpdHNlbGZcIik7XG4gICAgdmFyIHRoZW4gPSBpc1RoZW5hYmxlKHZhbHVlKTtcbiAgICBpZiAodGhlbikge1xuICAgICAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHdyYXBwZXIgPSB7IGRvbmU6IGZhbHNlIH07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2FsbCRiKHRoZW4sIHZhbHVlLFxuICAgICAgICAgICAgYmluZCQ0KGludGVybmFsUmVzb2x2ZSwgd3JhcHBlciwgc3RhdGUpLFxuICAgICAgICAgICAgYmluZCQ0KGludGVybmFsUmVqZWN0LCB3cmFwcGVyLCBzdGF0ZSlcbiAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGludGVybmFsUmVqZWN0KHdyYXBwZXIsIGVycm9yLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS52YWx1ZSA9IHZhbHVlO1xuICAgICAgc3RhdGUuc3RhdGUgPSBGVUxGSUxMRUQ7XG4gICAgICBub3RpZnkoc3RhdGUsIGZhbHNlKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaW50ZXJuYWxSZWplY3QoeyBkb25lOiBmYWxzZSB9LCBlcnJvciwgc3RhdGUpO1xuICB9XG59O1xuXG4vLyBjb25zdHJ1Y3RvciBwb2x5ZmlsbFxuaWYgKEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SJDQpIHtcbiAgLy8gMjUuNC4zLjEgUHJvbWlzZShleGVjdXRvcilcbiAgUHJvbWlzZUNvbnN0cnVjdG9yID0gZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcikge1xuICAgIGFuSW5zdGFuY2UkMih0aGlzLCBQcm9taXNlUHJvdG90eXBlKTtcbiAgICBhQ2FsbGFibGUkMyhleGVjdXRvcik7XG4gICAgY2FsbCRiKEludGVybmFsLCB0aGlzKTtcbiAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFByb21pc2VTdGF0ZSh0aGlzKTtcbiAgICB0cnkge1xuICAgICAgZXhlY3V0b3IoYmluZCQ0KGludGVybmFsUmVzb2x2ZSwgc3RhdGUpLCBiaW5kJDQoaW50ZXJuYWxSZWplY3QsIHN0YXRlKSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGludGVybmFsUmVqZWN0KHN0YXRlLCBlcnJvcik7XG4gICAgfVxuICB9O1xuXG4gIFByb21pc2VQcm90b3R5cGUgPSBQcm9taXNlQ29uc3RydWN0b3IucHJvdG90eXBlO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFycyAtLSByZXF1aXJlZCBmb3IgYC5sZW5ndGhgXG4gIEludGVybmFsID0gZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcikge1xuICAgIHNldEludGVybmFsU3RhdGUkMyh0aGlzLCB7XG4gICAgICB0eXBlOiBQUk9NSVNFLFxuICAgICAgZG9uZTogZmFsc2UsXG4gICAgICBub3RpZmllZDogZmFsc2UsXG4gICAgICBwYXJlbnQ6IGZhbHNlLFxuICAgICAgcmVhY3Rpb25zOiBuZXcgUXVldWUoKSxcbiAgICAgIHJlamVjdGlvbjogZmFsc2UsXG4gICAgICBzdGF0ZTogUEVORElORyxcbiAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICB9KTtcbiAgfTtcblxuICAvLyBgUHJvbWlzZS5wcm90b3R5cGUudGhlbmAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcHJvbWlzZS5wcm90b3R5cGUudGhlblxuICBJbnRlcm5hbC5wcm90b3R5cGUgPSBkZWZpbmVCdWlsdEluJDUoUHJvbWlzZVByb3RvdHlwZSwgJ3RoZW4nLCBmdW5jdGlvbiB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxQcm9taXNlU3RhdGUodGhpcyk7XG4gICAgdmFyIHJlYWN0aW9uID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkkMShzcGVjaWVzQ29uc3RydWN0b3IodGhpcywgUHJvbWlzZUNvbnN0cnVjdG9yKSk7XG4gICAgc3RhdGUucGFyZW50ID0gdHJ1ZTtcbiAgICByZWFjdGlvbi5vayA9IGlzQ2FsbGFibGUkNChvbkZ1bGZpbGxlZCkgPyBvbkZ1bGZpbGxlZCA6IHRydWU7XG4gICAgcmVhY3Rpb24uZmFpbCA9IGlzQ2FsbGFibGUkNChvblJlamVjdGVkKSAmJiBvblJlamVjdGVkO1xuICAgIHJlYWN0aW9uLmRvbWFpbiA9IElTX05PREUgPyBwcm9jZXNzLmRvbWFpbiA6IHVuZGVmaW5lZDtcbiAgICBpZiAoc3RhdGUuc3RhdGUgPT0gUEVORElORykgc3RhdGUucmVhY3Rpb25zLmFkZChyZWFjdGlvbik7XG4gICAgZWxzZSBtaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgICAgY2FsbFJlYWN0aW9uKHJlYWN0aW9uLCBzdGF0ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlYWN0aW9uLnByb21pc2U7XG4gIH0pO1xuXG4gIE93blByb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9taXNlID0gbmV3IEludGVybmFsKCk7XG4gICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxQcm9taXNlU3RhdGUocHJvbWlzZSk7XG4gICAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgICB0aGlzLnJlc29sdmUgPSBiaW5kJDQoaW50ZXJuYWxSZXNvbHZlLCBzdGF0ZSk7XG4gICAgdGhpcy5yZWplY3QgPSBiaW5kJDQoaW50ZXJuYWxSZWplY3QsIHN0YXRlKTtcbiAgfTtcblxuICBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSQzLmYgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSQxID0gZnVuY3Rpb24gKEMpIHtcbiAgICByZXR1cm4gQyA9PT0gUHJvbWlzZUNvbnN0cnVjdG9yIHx8IEMgPT09IFByb21pc2VXcmFwcGVyXG4gICAgICA/IG5ldyBPd25Qcm9taXNlQ2FwYWJpbGl0eShDKVxuICAgICAgOiBuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG4gIH07XG5cbiAgaWYgKGlzQ2FsbGFibGUkNChOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMikgJiYgTmF0aXZlUHJvbWlzZVByb3RvdHlwZSQxICE9PSBPYmplY3QucHJvdG90eXBlKSB7XG4gICAgbmF0aXZlVGhlbiA9IE5hdGl2ZVByb21pc2VQcm90b3R5cGUkMS50aGVuO1xuXG4gICAgaWYgKCFOQVRJVkVfUFJPTUlTRV9TVUJDTEFTU0lORykge1xuICAgICAgLy8gbWFrZSBgUHJvbWlzZSN0aGVuYCByZXR1cm4gYSBwb2x5ZmlsbGVkIGBQcm9taXNlYCBmb3IgbmF0aXZlIHByb21pc2UtYmFzZWQgQVBJc1xuICAgICAgZGVmaW5lQnVpbHRJbiQ1KE5hdGl2ZVByb21pc2VQcm90b3R5cGUkMSwgJ3RoZW4nLCBmdW5jdGlvbiB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlQ29uc3RydWN0b3IoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGNhbGwkYihuYXRpdmVUaGVuLCB0aGF0LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKTtcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy82NDBcbiAgICAgIH0sIHsgdW5zYWZlOiB0cnVlIH0pO1xuICAgIH1cblxuICAgIC8vIG1ha2UgYC5jb25zdHJ1Y3RvciA9PT0gUHJvbWlzZWAgd29yayBmb3IgbmF0aXZlIHByb21pc2UtYmFzZWQgQVBJc1xuICAgIHRyeSB7XG4gICAgICBkZWxldGUgTmF0aXZlUHJvbWlzZVByb3RvdHlwZSQxLmNvbnN0cnVjdG9yO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cblxuICAgIC8vIG1ha2UgYGluc3RhbmNlb2YgUHJvbWlzZWAgd29yayBmb3IgbmF0aXZlIHByb21pc2UtYmFzZWQgQVBJc1xuICAgIGlmIChzZXRQcm90b3R5cGVPZikge1xuICAgICAgc2V0UHJvdG90eXBlT2YoTmF0aXZlUHJvbWlzZVByb3RvdHlwZSQxLCBQcm9taXNlUHJvdG90eXBlKTtcbiAgICB9XG4gIH1cbn1cblxuJCQ4KHsgZ2xvYmFsOiB0cnVlLCBjb25zdHJ1Y3RvcjogdHJ1ZSwgd3JhcDogdHJ1ZSwgZm9yY2VkOiBGT1JDRURfUFJPTUlTRV9DT05TVFJVQ1RPUiQ0IH0sIHtcbiAgUHJvbWlzZTogUHJvbWlzZUNvbnN0cnVjdG9yXG59KTtcblxuc2V0VG9TdHJpbmdUYWckMihQcm9taXNlQ29uc3RydWN0b3IsIFBST01JU0UsIGZhbHNlKTtcbnNldFNwZWNpZXMoUFJPTUlTRSk7XG5cbnZhciB3ZWxsS25vd25TeW1ib2wkNyA9IHdlbGxLbm93blN5bWJvbCRpO1xudmFyIEl0ZXJhdG9ycyQxID0gaXRlcmF0b3JzO1xuXG52YXIgSVRFUkFUT1IkNSA9IHdlbGxLbm93blN5bWJvbCQ3KCdpdGVyYXRvcicpO1xudmFyIEFycmF5UHJvdG90eXBlID0gQXJyYXkucHJvdG90eXBlO1xuXG4vLyBjaGVjayBvbiBkZWZhdWx0IEFycmF5IGl0ZXJhdG9yXG52YXIgaXNBcnJheUl0ZXJhdG9yTWV0aG9kJDIgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ICE9PSB1bmRlZmluZWQgJiYgKEl0ZXJhdG9ycyQxLkFycmF5ID09PSBpdCB8fCBBcnJheVByb3RvdHlwZVtJVEVSQVRPUiQ1XSA9PT0gaXQpO1xufTtcblxudmFyIGNsYXNzb2YkMiA9IGNsYXNzb2YkNjtcbnZhciBnZXRNZXRob2QkMiA9IGdldE1ldGhvZCQ0O1xudmFyIEl0ZXJhdG9ycyA9IGl0ZXJhdG9ycztcbnZhciB3ZWxsS25vd25TeW1ib2wkNiA9IHdlbGxLbm93blN5bWJvbCRpO1xuXG52YXIgSVRFUkFUT1IkNCA9IHdlbGxLbm93blN5bWJvbCQ2KCdpdGVyYXRvcicpO1xuXG52YXIgZ2V0SXRlcmF0b3JNZXRob2QkNCA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgIT0gdW5kZWZpbmVkKSByZXR1cm4gZ2V0TWV0aG9kJDIoaXQsIElURVJBVE9SJDQpXG4gICAgfHwgZ2V0TWV0aG9kJDIoaXQsICdAQGl0ZXJhdG9yJylcbiAgICB8fCBJdGVyYXRvcnNbY2xhc3NvZiQyKGl0KV07XG59O1xuXG52YXIgY2FsbCRhID0gZnVuY3Rpb25DYWxsO1xudmFyIGFDYWxsYWJsZSQyID0gYUNhbGxhYmxlJDc7XG52YXIgYW5PYmplY3QkNyA9IGFuT2JqZWN0JGc7XG52YXIgdHJ5VG9TdHJpbmckMSA9IHRyeVRvU3RyaW5nJDQ7XG52YXIgZ2V0SXRlcmF0b3JNZXRob2QkMyA9IGdldEl0ZXJhdG9yTWV0aG9kJDQ7XG5cbnZhciAkVHlwZUVycm9yJDIgPSBUeXBlRXJyb3I7XG5cbnZhciBnZXRJdGVyYXRvciQzID0gZnVuY3Rpb24gKGFyZ3VtZW50LCB1c2luZ0l0ZXJhdG9yKSB7XG4gIHZhciBpdGVyYXRvck1ldGhvZCA9IGFyZ3VtZW50cy5sZW5ndGggPCAyID8gZ2V0SXRlcmF0b3JNZXRob2QkMyhhcmd1bWVudCkgOiB1c2luZ0l0ZXJhdG9yO1xuICBpZiAoYUNhbGxhYmxlJDIoaXRlcmF0b3JNZXRob2QpKSByZXR1cm4gYW5PYmplY3QkNyhjYWxsJGEoaXRlcmF0b3JNZXRob2QsIGFyZ3VtZW50KSk7XG4gIHRocm93ICRUeXBlRXJyb3IkMih0cnlUb1N0cmluZyQxKGFyZ3VtZW50KSArICcgaXMgbm90IGl0ZXJhYmxlJyk7XG59O1xuXG52YXIgY2FsbCQ5ID0gZnVuY3Rpb25DYWxsO1xudmFyIGFuT2JqZWN0JDYgPSBhbk9iamVjdCRnO1xudmFyIGdldE1ldGhvZCQxID0gZ2V0TWV0aG9kJDQ7XG5cbnZhciBpdGVyYXRvckNsb3NlJDIgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIGtpbmQsIHZhbHVlKSB7XG4gIHZhciBpbm5lclJlc3VsdCwgaW5uZXJFcnJvcjtcbiAgYW5PYmplY3QkNihpdGVyYXRvcik7XG4gIHRyeSB7XG4gICAgaW5uZXJSZXN1bHQgPSBnZXRNZXRob2QkMShpdGVyYXRvciwgJ3JldHVybicpO1xuICAgIGlmICghaW5uZXJSZXN1bHQpIHtcbiAgICAgIGlmIChraW5kID09PSAndGhyb3cnKSB0aHJvdyB2YWx1ZTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaW5uZXJSZXN1bHQgPSBjYWxsJDkoaW5uZXJSZXN1bHQsIGl0ZXJhdG9yKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpbm5lckVycm9yID0gdHJ1ZTtcbiAgICBpbm5lclJlc3VsdCA9IGVycm9yO1xuICB9XG4gIGlmIChraW5kID09PSAndGhyb3cnKSB0aHJvdyB2YWx1ZTtcbiAgaWYgKGlubmVyRXJyb3IpIHRocm93IGlubmVyUmVzdWx0O1xuICBhbk9iamVjdCQ2KGlubmVyUmVzdWx0KTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcblxudmFyIGJpbmQkMyA9IGZ1bmN0aW9uQmluZENvbnRleHQ7XG52YXIgY2FsbCQ4ID0gZnVuY3Rpb25DYWxsO1xudmFyIGFuT2JqZWN0JDUgPSBhbk9iamVjdCRnO1xudmFyIHRyeVRvU3RyaW5nID0gdHJ5VG9TdHJpbmckNDtcbnZhciBpc0FycmF5SXRlcmF0b3JNZXRob2QkMSA9IGlzQXJyYXlJdGVyYXRvck1ldGhvZCQyO1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlJDIgPSBsZW5ndGhPZkFycmF5TGlrZSQ0O1xudmFyIGlzUHJvdG90eXBlT2YgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xudmFyIGdldEl0ZXJhdG9yJDIgPSBnZXRJdGVyYXRvciQzO1xudmFyIGdldEl0ZXJhdG9yTWV0aG9kJDIgPSBnZXRJdGVyYXRvck1ldGhvZCQ0O1xudmFyIGl0ZXJhdG9yQ2xvc2UkMSA9IGl0ZXJhdG9yQ2xvc2UkMjtcblxudmFyICRUeXBlRXJyb3IkMSA9IFR5cGVFcnJvcjtcblxudmFyIFJlc3VsdCA9IGZ1bmN0aW9uIChzdG9wcGVkLCByZXN1bHQpIHtcbiAgdGhpcy5zdG9wcGVkID0gc3RvcHBlZDtcbiAgdGhpcy5yZXN1bHQgPSByZXN1bHQ7XG59O1xuXG52YXIgUmVzdWx0UHJvdG90eXBlID0gUmVzdWx0LnByb3RvdHlwZTtcblxudmFyIGl0ZXJhdGUkMiA9IGZ1bmN0aW9uIChpdGVyYWJsZSwgdW5ib3VuZEZ1bmN0aW9uLCBvcHRpb25zKSB7XG4gIHZhciB0aGF0ID0gb3B0aW9ucyAmJiBvcHRpb25zLnRoYXQ7XG4gIHZhciBBU19FTlRSSUVTID0gISEob3B0aW9ucyAmJiBvcHRpb25zLkFTX0VOVFJJRVMpO1xuICB2YXIgSVNfSVRFUkFUT1IgPSAhIShvcHRpb25zICYmIG9wdGlvbnMuSVNfSVRFUkFUT1IpO1xuICB2YXIgSU5URVJSVVBURUQgPSAhIShvcHRpb25zICYmIG9wdGlvbnMuSU5URVJSVVBURUQpO1xuICB2YXIgZm4gPSBiaW5kJDModW5ib3VuZEZ1bmN0aW9uLCB0aGF0KTtcbiAgdmFyIGl0ZXJhdG9yLCBpdGVyRm4sIGluZGV4LCBsZW5ndGgsIHJlc3VsdCwgbmV4dCwgc3RlcDtcblxuICB2YXIgc3RvcCA9IGZ1bmN0aW9uIChjb25kaXRpb24pIHtcbiAgICBpZiAoaXRlcmF0b3IpIGl0ZXJhdG9yQ2xvc2UkMShpdGVyYXRvciwgJ25vcm1hbCcsIGNvbmRpdGlvbik7XG4gICAgcmV0dXJuIG5ldyBSZXN1bHQodHJ1ZSwgY29uZGl0aW9uKTtcbiAgfTtcblxuICB2YXIgY2FsbEZuID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKEFTX0VOVFJJRVMpIHtcbiAgICAgIGFuT2JqZWN0JDUodmFsdWUpO1xuICAgICAgcmV0dXJuIElOVEVSUlVQVEVEID8gZm4odmFsdWVbMF0sIHZhbHVlWzFdLCBzdG9wKSA6IGZuKHZhbHVlWzBdLCB2YWx1ZVsxXSk7XG4gICAgfSByZXR1cm4gSU5URVJSVVBURUQgPyBmbih2YWx1ZSwgc3RvcCkgOiBmbih2YWx1ZSk7XG4gIH07XG5cbiAgaWYgKElTX0lURVJBVE9SKSB7XG4gICAgaXRlcmF0b3IgPSBpdGVyYWJsZTtcbiAgfSBlbHNlIHtcbiAgICBpdGVyRm4gPSBnZXRJdGVyYXRvck1ldGhvZCQyKGl0ZXJhYmxlKTtcbiAgICBpZiAoIWl0ZXJGbikgdGhyb3cgJFR5cGVFcnJvciQxKHRyeVRvU3RyaW5nKGl0ZXJhYmxlKSArICcgaXMgbm90IGl0ZXJhYmxlJyk7XG4gICAgLy8gb3B0aW1pc2F0aW9uIGZvciBhcnJheSBpdGVyYXRvcnNcbiAgICBpZiAoaXNBcnJheUl0ZXJhdG9yTWV0aG9kJDEoaXRlckZuKSkge1xuICAgICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlJDIoaXRlcmFibGUpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgICByZXN1bHQgPSBjYWxsRm4oaXRlcmFibGVbaW5kZXhdKTtcbiAgICAgICAgaWYgKHJlc3VsdCAmJiBpc1Byb3RvdHlwZU9mKFJlc3VsdFByb3RvdHlwZSwgcmVzdWx0KSkgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0gcmV0dXJuIG5ldyBSZXN1bHQoZmFsc2UpO1xuICAgIH1cbiAgICBpdGVyYXRvciA9IGdldEl0ZXJhdG9yJDIoaXRlcmFibGUsIGl0ZXJGbik7XG4gIH1cblxuICBuZXh0ID0gaXRlcmF0b3IubmV4dDtcbiAgd2hpbGUgKCEoc3RlcCA9IGNhbGwkOChuZXh0LCBpdGVyYXRvcikpLmRvbmUpIHtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gY2FsbEZuKHN0ZXAudmFsdWUpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpdGVyYXRvckNsb3NlJDEoaXRlcmF0b3IsICd0aHJvdycsIGVycm9yKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiByZXN1bHQgPT0gJ29iamVjdCcgJiYgcmVzdWx0ICYmIGlzUHJvdG90eXBlT2YoUmVzdWx0UHJvdG90eXBlLCByZXN1bHQpKSByZXR1cm4gcmVzdWx0O1xuICB9IHJldHVybiBuZXcgUmVzdWx0KGZhbHNlKTtcbn07XG5cbnZhciB3ZWxsS25vd25TeW1ib2wkNSA9IHdlbGxLbm93blN5bWJvbCRpO1xuXG52YXIgSVRFUkFUT1IkMyA9IHdlbGxLbm93blN5bWJvbCQ1KCdpdGVyYXRvcicpO1xudmFyIFNBRkVfQ0xPU0lORyA9IGZhbHNlO1xuXG50cnkge1xuICB2YXIgY2FsbGVkID0gMDtcbiAgdmFyIGl0ZXJhdG9yV2l0aFJldHVybiA9IHtcbiAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4geyBkb25lOiAhIWNhbGxlZCsrIH07XG4gICAgfSxcbiAgICAncmV0dXJuJzogZnVuY3Rpb24gKCkge1xuICAgICAgU0FGRV9DTE9TSU5HID0gdHJ1ZTtcbiAgICB9XG4gIH07XG4gIGl0ZXJhdG9yV2l0aFJldHVybltJVEVSQVRPUiQzXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tYXJyYXktZnJvbSwgbm8tdGhyb3ctbGl0ZXJhbCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICBBcnJheS5mcm9tKGl0ZXJhdG9yV2l0aFJldHVybiwgZnVuY3Rpb24gKCkgeyB0aHJvdyAyOyB9KTtcbn0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cblxudmFyIGNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbiQxID0gZnVuY3Rpb24gKGV4ZWMsIFNLSVBfQ0xPU0lORykge1xuICBpZiAoIVNLSVBfQ0xPU0lORyAmJiAhU0FGRV9DTE9TSU5HKSByZXR1cm4gZmFsc2U7XG4gIHZhciBJVEVSQVRJT05fU1VQUE9SVCA9IGZhbHNlO1xuICB0cnkge1xuICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICBvYmplY3RbSVRFUkFUT1IkM10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHsgZG9uZTogSVRFUkFUSU9OX1NVUFBPUlQgPSB0cnVlIH07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcbiAgICBleGVjKG9iamVjdCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIElURVJBVElPTl9TVVBQT1JUO1xufTtcblxudmFyIE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQxID0gcHJvbWlzZU5hdGl2ZUNvbnN0cnVjdG9yO1xudmFyIGNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbiA9IGNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbiQxO1xudmFyIEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SJDMgPSBwcm9taXNlQ29uc3RydWN0b3JEZXRlY3Rpb24uQ09OU1RSVUNUT1I7XG5cbnZhciBwcm9taXNlU3RhdGljc0luY29ycmVjdEl0ZXJhdGlvbiA9IEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SJDMgfHwgIWNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbihmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiAgTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yJDEuYWxsKGl0ZXJhYmxlKS50aGVuKHVuZGVmaW5lZCwgZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9KTtcbn0pO1xuXG52YXIgJCQ3ID0gX2V4cG9ydDtcbnZhciBjYWxsJDcgPSBmdW5jdGlvbkNhbGw7XG52YXIgYUNhbGxhYmxlJDEgPSBhQ2FsbGFibGUkNztcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSQyID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkkMjtcbnZhciBwZXJmb3JtJDEgPSBwZXJmb3JtJDM7XG52YXIgaXRlcmF0ZSQxID0gaXRlcmF0ZSQyO1xudmFyIFBST01JU0VfU1RBVElDU19JTkNPUlJFQ1RfSVRFUkFUSU9OJDEgPSBwcm9taXNlU3RhdGljc0luY29ycmVjdEl0ZXJhdGlvbjtcblxuLy8gYFByb21pc2UuYWxsYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcHJvbWlzZS5hbGxcbiQkNyh7IHRhcmdldDogJ1Byb21pc2UnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IFBST01JU0VfU1RBVElDU19JTkNPUlJFQ1RfSVRFUkFUSU9OJDEgfSwge1xuICBhbGw6IGZ1bmN0aW9uIGFsbChpdGVyYWJsZSkge1xuICAgIHZhciBDID0gdGhpcztcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlJDIuZihDKTtcbiAgICB2YXIgcmVzb2x2ZSA9IGNhcGFiaWxpdHkucmVzb2x2ZTtcbiAgICB2YXIgcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgdmFyIHJlc3VsdCA9IHBlcmZvcm0kMShmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHByb21pc2VSZXNvbHZlID0gYUNhbGxhYmxlJDEoQy5yZXNvbHZlKTtcbiAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgIHZhciBjb3VudGVyID0gMDtcbiAgICAgIHZhciByZW1haW5pbmcgPSAxO1xuICAgICAgaXRlcmF0ZSQxKGl0ZXJhYmxlLCBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICB2YXIgaW5kZXggPSBjb3VudGVyKys7XG4gICAgICAgIHZhciBhbHJlYWR5Q2FsbGVkID0gZmFsc2U7XG4gICAgICAgIHJlbWFpbmluZysrO1xuICAgICAgICBjYWxsJDcoJHByb21pc2VSZXNvbHZlLCBDLCBwcm9taXNlKS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIGlmIChhbHJlYWR5Q2FsbGVkKSByZXR1cm47XG4gICAgICAgICAgYWxyZWFkeUNhbGxlZCA9IHRydWU7XG4gICAgICAgICAgdmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgIH0pO1xuICAgIGlmIChyZXN1bHQuZXJyb3IpIHJlamVjdChyZXN1bHQudmFsdWUpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuXG52YXIgJCQ2ID0gX2V4cG9ydDtcbnZhciBGT1JDRURfUFJPTUlTRV9DT05TVFJVQ1RPUiQyID0gcHJvbWlzZUNvbnN0cnVjdG9yRGV0ZWN0aW9uLkNPTlNUUlVDVE9SO1xudmFyIE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciA9IHByb21pc2VOYXRpdmVDb25zdHJ1Y3RvcjtcbnZhciBnZXRCdWlsdEluJDEgPSBnZXRCdWlsdEluJDg7XG52YXIgaXNDYWxsYWJsZSQzID0gaXNDYWxsYWJsZSRuO1xudmFyIGRlZmluZUJ1aWx0SW4kNCA9IGRlZmluZUJ1aWx0SW4kYTtcblxudmFyIE5hdGl2ZVByb21pc2VQcm90b3R5cGUgPSBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IgJiYgTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yLnByb3RvdHlwZTtcblxuLy8gYFByb21pc2UucHJvdG90eXBlLmNhdGNoYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcHJvbWlzZS5wcm90b3R5cGUuY2F0Y2hcbiQkNih7IHRhcmdldDogJ1Byb21pc2UnLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBGT1JDRURfUFJPTUlTRV9DT05TVFJVQ1RPUiQyLCByZWFsOiB0cnVlIH0sIHtcbiAgJ2NhdGNoJzogZnVuY3Rpb24gKG9uUmVqZWN0ZWQpIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgb25SZWplY3RlZCk7XG4gIH1cbn0pO1xuXG4vLyBtYWtlcyBzdXJlIHRoYXQgbmF0aXZlIHByb21pc2UtYmFzZWQgQVBJcyBgUHJvbWlzZSNjYXRjaGAgcHJvcGVybHkgd29ya3Mgd2l0aCBwYXRjaGVkIGBQcm9taXNlI3RoZW5gXG5pZiAoaXNDYWxsYWJsZSQzKE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvcikpIHtcbiAgdmFyIG1ldGhvZCA9IGdldEJ1aWx0SW4kMSgnUHJvbWlzZScpLnByb3RvdHlwZVsnY2F0Y2gnXTtcbiAgaWYgKE5hdGl2ZVByb21pc2VQcm90b3R5cGVbJ2NhdGNoJ10gIT09IG1ldGhvZCkge1xuICAgIGRlZmluZUJ1aWx0SW4kNChOYXRpdmVQcm9taXNlUHJvdG90eXBlLCAnY2F0Y2gnLCBtZXRob2QsIHsgdW5zYWZlOiB0cnVlIH0pO1xuICB9XG59XG5cbnZhciAkJDUgPSBfZXhwb3J0O1xudmFyIGNhbGwkNiA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBhQ2FsbGFibGUgPSBhQ2FsbGFibGUkNztcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSQxID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkkMjtcbnZhciBwZXJmb3JtID0gcGVyZm9ybSQzO1xudmFyIGl0ZXJhdGUgPSBpdGVyYXRlJDI7XG52YXIgUFJPTUlTRV9TVEFUSUNTX0lOQ09SUkVDVF9JVEVSQVRJT04gPSBwcm9taXNlU3RhdGljc0luY29ycmVjdEl0ZXJhdGlvbjtcblxuLy8gYFByb21pc2UucmFjZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXByb21pc2UucmFjZVxuJCQ1KHsgdGFyZ2V0OiAnUHJvbWlzZScsIHN0YXQ6IHRydWUsIGZvcmNlZDogUFJPTUlTRV9TVEFUSUNTX0lOQ09SUkVDVF9JVEVSQVRJT04gfSwge1xuICByYWNlOiBmdW5jdGlvbiByYWNlKGl0ZXJhYmxlKSB7XG4gICAgdmFyIEMgPSB0aGlzO1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUkMS5mKEMpO1xuICAgIHZhciByZWplY3QgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICB2YXIgcmVzdWx0ID0gcGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHByb21pc2VSZXNvbHZlID0gYUNhbGxhYmxlKEMucmVzb2x2ZSk7XG4gICAgICBpdGVyYXRlKGl0ZXJhYmxlLCBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICBjYWxsJDYoJHByb21pc2VSZXNvbHZlLCBDLCBwcm9taXNlKS50aGVuKGNhcGFiaWxpdHkucmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmIChyZXN1bHQuZXJyb3IpIHJlamVjdChyZXN1bHQudmFsdWUpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuXG52YXIgJCQ0ID0gX2V4cG9ydDtcbnZhciBjYWxsJDUgPSBmdW5jdGlvbkNhbGw7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSQyO1xudmFyIEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SJDEgPSBwcm9taXNlQ29uc3RydWN0b3JEZXRlY3Rpb24uQ09OU1RSVUNUT1I7XG5cbi8vIGBQcm9taXNlLnJlamVjdGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXByb21pc2UucmVqZWN0XG4kJDQoeyB0YXJnZXQ6ICdQcm9taXNlJywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBGT1JDRURfUFJPTUlTRV9DT05TVFJVQ1RPUiQxIH0sIHtcbiAgcmVqZWN0OiBmdW5jdGlvbiByZWplY3Qocikge1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUuZih0aGlzKTtcbiAgICBjYWxsJDUoY2FwYWJpbGl0eS5yZWplY3QsIHVuZGVmaW5lZCwgcik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG5cbnZhciBhbk9iamVjdCQ0ID0gYW5PYmplY3QkZztcbnZhciBpc09iamVjdCQxID0gaXNPYmplY3QkODtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5JDI7XG5cbnZhciBwcm9taXNlUmVzb2x2ZSQxID0gZnVuY3Rpb24gKEMsIHgpIHtcbiAgYW5PYmplY3QkNChDKTtcbiAgaWYgKGlzT2JqZWN0JDEoeCkgJiYgeC5jb25zdHJ1Y3RvciA9PT0gQykgcmV0dXJuIHg7XG4gIHZhciBwcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5LmYoQyk7XG4gIHZhciByZXNvbHZlID0gcHJvbWlzZUNhcGFiaWxpdHkucmVzb2x2ZTtcbiAgcmVzb2x2ZSh4KTtcbiAgcmV0dXJuIHByb21pc2VDYXBhYmlsaXR5LnByb21pc2U7XG59O1xuXG52YXIgJCQzID0gX2V4cG9ydDtcbnZhciBnZXRCdWlsdEluID0gZ2V0QnVpbHRJbiQ4O1xudmFyIEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SID0gcHJvbWlzZUNvbnN0cnVjdG9yRGV0ZWN0aW9uLkNPTlNUUlVDVE9SO1xudmFyIHByb21pc2VSZXNvbHZlID0gcHJvbWlzZVJlc29sdmUkMTtcblxuZ2V0QnVpbHRJbignUHJvbWlzZScpO1xuXG4vLyBgUHJvbWlzZS5yZXNvbHZlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcHJvbWlzZS5yZXNvbHZlXG4kJDMoeyB0YXJnZXQ6ICdQcm9taXNlJywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBGT1JDRURfUFJPTUlTRV9DT05TVFJVQ1RPUiB9LCB7XG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoeCkge1xuICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZSh0aGlzLCB4KTtcbiAgfVxufSk7XG5cbi8vIGl0ZXJhYmxlIERPTSBjb2xsZWN0aW9uc1xuLy8gZmxhZyAtIGBpdGVyYWJsZWAgaW50ZXJmYWNlIC0gJ2VudHJpZXMnLCAna2V5cycsICd2YWx1ZXMnLCAnZm9yRWFjaCcgbWV0aG9kc1xudmFyIGRvbUl0ZXJhYmxlcyA9IHtcbiAgQ1NTUnVsZUxpc3Q6IDAsXG4gIENTU1N0eWxlRGVjbGFyYXRpb246IDAsXG4gIENTU1ZhbHVlTGlzdDogMCxcbiAgQ2xpZW50UmVjdExpc3Q6IDAsXG4gIERPTVJlY3RMaXN0OiAwLFxuICBET01TdHJpbmdMaXN0OiAwLFxuICBET01Ub2tlbkxpc3Q6IDEsXG4gIERhdGFUcmFuc2Zlckl0ZW1MaXN0OiAwLFxuICBGaWxlTGlzdDogMCxcbiAgSFRNTEFsbENvbGxlY3Rpb246IDAsXG4gIEhUTUxDb2xsZWN0aW9uOiAwLFxuICBIVE1MRm9ybUVsZW1lbnQ6IDAsXG4gIEhUTUxTZWxlY3RFbGVtZW50OiAwLFxuICBNZWRpYUxpc3Q6IDAsXG4gIE1pbWVUeXBlQXJyYXk6IDAsXG4gIE5hbWVkTm9kZU1hcDogMCxcbiAgTm9kZUxpc3Q6IDEsXG4gIFBhaW50UmVxdWVzdExpc3Q6IDAsXG4gIFBsdWdpbjogMCxcbiAgUGx1Z2luQXJyYXk6IDAsXG4gIFNWR0xlbmd0aExpc3Q6IDAsXG4gIFNWR051bWJlckxpc3Q6IDAsXG4gIFNWR1BhdGhTZWdMaXN0OiAwLFxuICBTVkdQb2ludExpc3Q6IDAsXG4gIFNWR1N0cmluZ0xpc3Q6IDAsXG4gIFNWR1RyYW5zZm9ybUxpc3Q6IDAsXG4gIFNvdXJjZUJ1ZmZlckxpc3Q6IDAsXG4gIFN0eWxlU2hlZXRMaXN0OiAwLFxuICBUZXh0VHJhY2tDdWVMaXN0OiAwLFxuICBUZXh0VHJhY2tMaXN0OiAwLFxuICBUb3VjaExpc3Q6IDBcbn07XG5cbi8vIGluIG9sZCBXZWJLaXQgdmVyc2lvbnMsIGBlbGVtZW50LmNsYXNzTGlzdGAgaXMgbm90IGFuIGluc3RhbmNlIG9mIGdsb2JhbCBgRE9NVG9rZW5MaXN0YFxudmFyIGRvY3VtZW50Q3JlYXRlRWxlbWVudCA9IGRvY3VtZW50Q3JlYXRlRWxlbWVudCQyO1xuXG52YXIgY2xhc3NMaXN0ID0gZG9jdW1lbnRDcmVhdGVFbGVtZW50KCdzcGFuJykuY2xhc3NMaXN0O1xudmFyIERPTVRva2VuTGlzdFByb3RvdHlwZSQxID0gY2xhc3NMaXN0ICYmIGNsYXNzTGlzdC5jb25zdHJ1Y3RvciAmJiBjbGFzc0xpc3QuY29uc3RydWN0b3IucHJvdG90eXBlO1xuXG52YXIgZG9tVG9rZW5MaXN0UHJvdG90eXBlID0gRE9NVG9rZW5MaXN0UHJvdG90eXBlJDEgPT09IE9iamVjdC5wcm90b3R5cGUgPyB1bmRlZmluZWQgOiBET01Ub2tlbkxpc3RQcm90b3R5cGUkMTtcblxudmFyIGdsb2JhbCQ2ID0gZ2xvYmFsJG87XG52YXIgRE9NSXRlcmFibGVzID0gZG9tSXRlcmFibGVzO1xudmFyIERPTVRva2VuTGlzdFByb3RvdHlwZSA9IGRvbVRva2VuTGlzdFByb3RvdHlwZTtcbnZhciBBcnJheUl0ZXJhdG9yTWV0aG9kcyA9IGVzX2FycmF5X2l0ZXJhdG9yO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQxID0gY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDU7XG52YXIgd2VsbEtub3duU3ltYm9sJDQgPSB3ZWxsS25vd25TeW1ib2wkaTtcblxudmFyIElURVJBVE9SJDIgPSB3ZWxsS25vd25TeW1ib2wkNCgnaXRlcmF0b3InKTtcbnZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sJDQoJ3RvU3RyaW5nVGFnJyk7XG52YXIgQXJyYXlWYWx1ZXMgPSBBcnJheUl0ZXJhdG9yTWV0aG9kcy52YWx1ZXM7XG5cbnZhciBoYW5kbGVQcm90b3R5cGUgPSBmdW5jdGlvbiAoQ29sbGVjdGlvblByb3RvdHlwZSwgQ09MTEVDVElPTl9OQU1FKSB7XG4gIGlmIChDb2xsZWN0aW9uUHJvdG90eXBlKSB7XG4gICAgLy8gc29tZSBDaHJvbWUgdmVyc2lvbnMgaGF2ZSBub24tY29uZmlndXJhYmxlIG1ldGhvZHMgb24gRE9NVG9rZW5MaXN0XG4gICAgaWYgKENvbGxlY3Rpb25Qcm90b3R5cGVbSVRFUkFUT1IkMl0gIT09IEFycmF5VmFsdWVzKSB0cnkge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDEoQ29sbGVjdGlvblByb3RvdHlwZSwgSVRFUkFUT1IkMiwgQXJyYXlWYWx1ZXMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBDb2xsZWN0aW9uUHJvdG90eXBlW0lURVJBVE9SJDJdID0gQXJyYXlWYWx1ZXM7XG4gICAgfVxuICAgIGlmICghQ29sbGVjdGlvblByb3RvdHlwZVtUT19TVFJJTkdfVEFHXSkge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDEoQ29sbGVjdGlvblByb3RvdHlwZSwgVE9fU1RSSU5HX1RBRywgQ09MTEVDVElPTl9OQU1FKTtcbiAgICB9XG4gICAgaWYgKERPTUl0ZXJhYmxlc1tDT0xMRUNUSU9OX05BTUVdKSBmb3IgKHZhciBNRVRIT0RfTkFNRSBpbiBBcnJheUl0ZXJhdG9yTWV0aG9kcykge1xuICAgICAgLy8gc29tZSBDaHJvbWUgdmVyc2lvbnMgaGF2ZSBub24tY29uZmlndXJhYmxlIG1ldGhvZHMgb24gRE9NVG9rZW5MaXN0XG4gICAgICBpZiAoQ29sbGVjdGlvblByb3RvdHlwZVtNRVRIT0RfTkFNRV0gIT09IEFycmF5SXRlcmF0b3JNZXRob2RzW01FVEhPRF9OQU1FXSkgdHJ5IHtcbiAgICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDEoQ29sbGVjdGlvblByb3RvdHlwZSwgTUVUSE9EX05BTUUsIEFycmF5SXRlcmF0b3JNZXRob2RzW01FVEhPRF9OQU1FXSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBDb2xsZWN0aW9uUHJvdG90eXBlW01FVEhPRF9OQU1FXSA9IEFycmF5SXRlcmF0b3JNZXRob2RzW01FVEhPRF9OQU1FXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmZvciAodmFyIENPTExFQ1RJT05fTkFNRSBpbiBET01JdGVyYWJsZXMpIHtcbiAgaGFuZGxlUHJvdG90eXBlKGdsb2JhbCQ2W0NPTExFQ1RJT05fTkFNRV0gJiYgZ2xvYmFsJDZbQ09MTEVDVElPTl9OQU1FXS5wcm90b3R5cGUsIENPTExFQ1RJT05fTkFNRSk7XG59XG5cbmhhbmRsZVByb3RvdHlwZShET01Ub2tlbkxpc3RQcm90b3R5cGUsICdET01Ub2tlbkxpc3QnKTtcblxudmFyIHVuY3VycnlUaGlzJDcgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIHRvSW50ZWdlck9ySW5maW5pdHkkMSA9IHRvSW50ZWdlck9ySW5maW5pdHkkNDtcbnZhciB0b1N0cmluZyQzID0gdG9TdHJpbmckNDtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDEgPSByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDQ7XG5cbnZhciBjaGFyQXQkNiA9IHVuY3VycnlUaGlzJDcoJycuY2hhckF0KTtcbnZhciBjaGFyQ29kZUF0JDEgPSB1bmN1cnJ5VGhpcyQ3KCcnLmNoYXJDb2RlQXQpO1xudmFyIHN0cmluZ1NsaWNlJDUgPSB1bmN1cnJ5VGhpcyQ3KCcnLnNsaWNlKTtcblxudmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uIChDT05WRVJUX1RPX1NUUklORykge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBwb3MpIHtcbiAgICB2YXIgUyA9IHRvU3RyaW5nJDMocmVxdWlyZU9iamVjdENvZXJjaWJsZSQxKCR0aGlzKSk7XG4gICAgdmFyIHBvc2l0aW9uID0gdG9JbnRlZ2VyT3JJbmZpbml0eSQxKHBvcyk7XG4gICAgdmFyIHNpemUgPSBTLmxlbmd0aDtcbiAgICB2YXIgZmlyc3QsIHNlY29uZDtcbiAgICBpZiAocG9zaXRpb24gPCAwIHx8IHBvc2l0aW9uID49IHNpemUpIHJldHVybiBDT05WRVJUX1RPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkO1xuICAgIGZpcnN0ID0gY2hhckNvZGVBdCQxKFMsIHBvc2l0aW9uKTtcbiAgICByZXR1cm4gZmlyc3QgPCAweEQ4MDAgfHwgZmlyc3QgPiAweERCRkYgfHwgcG9zaXRpb24gKyAxID09PSBzaXplXG4gICAgICB8fCAoc2Vjb25kID0gY2hhckNvZGVBdCQxKFMsIHBvc2l0aW9uICsgMSkpIDwgMHhEQzAwIHx8IHNlY29uZCA+IDB4REZGRlxuICAgICAgICA/IENPTlZFUlRfVE9fU1RSSU5HXG4gICAgICAgICAgPyBjaGFyQXQkNihTLCBwb3NpdGlvbilcbiAgICAgICAgICA6IGZpcnN0XG4gICAgICAgIDogQ09OVkVSVF9UT19TVFJJTkdcbiAgICAgICAgICA/IHN0cmluZ1NsaWNlJDUoUywgcG9zaXRpb24sIHBvc2l0aW9uICsgMilcbiAgICAgICAgICA6IChmaXJzdCAtIDB4RDgwMCA8PCAxMCkgKyAoc2Vjb25kIC0gMHhEQzAwKSArIDB4MTAwMDA7XG4gIH07XG59O1xuXG52YXIgc3RyaW5nTXVsdGlieXRlID0ge1xuICAvLyBgU3RyaW5nLnByb3RvdHlwZS5jb2RlUG9pbnRBdGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5jb2RlcG9pbnRhdFxuICBjb2RlQXQ6IGNyZWF0ZU1ldGhvZChmYWxzZSksXG4gIC8vIGBTdHJpbmcucHJvdG90eXBlLmF0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21hdGhpYXNieW5lbnMvU3RyaW5nLnByb3RvdHlwZS5hdFxuICBjaGFyQXQ6IGNyZWF0ZU1ldGhvZCh0cnVlKVxufTtcblxudmFyIGNoYXJBdCQ1ID0gc3RyaW5nTXVsdGlieXRlLmNoYXJBdDtcbnZhciB0b1N0cmluZyQyID0gdG9TdHJpbmckNDtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlJDIgPSBpbnRlcm5hbFN0YXRlO1xudmFyIGRlZmluZUl0ZXJhdG9yID0gZGVmaW5lSXRlcmF0b3IkMjtcblxudmFyIFNUUklOR19JVEVSQVRPUiA9ICdTdHJpbmcgSXRlcmF0b3InO1xudmFyIHNldEludGVybmFsU3RhdGUkMiA9IEludGVybmFsU3RhdGVNb2R1bGUkMi5zZXQ7XG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSQxID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQyLmdldHRlckZvcihTVFJJTkdfSVRFUkFUT1IpO1xuXG4vLyBgU3RyaW5nLnByb3RvdHlwZVtAQGl0ZXJhdG9yXWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUtQEBpdGVyYXRvclxuZGVmaW5lSXRlcmF0b3IoU3RyaW5nLCAnU3RyaW5nJywgZnVuY3Rpb24gKGl0ZXJhdGVkKSB7XG4gIHNldEludGVybmFsU3RhdGUkMih0aGlzLCB7XG4gICAgdHlwZTogU1RSSU5HX0lURVJBVE9SLFxuICAgIHN0cmluZzogdG9TdHJpbmckMihpdGVyYXRlZCksXG4gICAgaW5kZXg6IDBcbiAgfSk7XG4vLyBgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJXN0cmluZ2l0ZXJhdG9ycHJvdG90eXBlJS5uZXh0XG59LCBmdW5jdGlvbiBuZXh0KCkge1xuICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlJDEodGhpcyk7XG4gIHZhciBzdHJpbmcgPSBzdGF0ZS5zdHJpbmc7XG4gIHZhciBpbmRleCA9IHN0YXRlLmluZGV4O1xuICB2YXIgcG9pbnQ7XG4gIGlmIChpbmRleCA+PSBzdHJpbmcubGVuZ3RoKSByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIHBvaW50ID0gY2hhckF0JDUoc3RyaW5nLCBpbmRleCk7XG4gIHN0YXRlLmluZGV4ICs9IHBvaW50Lmxlbmd0aDtcbiAgcmV0dXJuIHsgdmFsdWU6IHBvaW50LCBkb25lOiBmYWxzZSB9O1xufSk7XG5cbnZhciBmYWlscyQ1ID0gZmFpbHMkaztcbnZhciB3ZWxsS25vd25TeW1ib2wkMyA9IHdlbGxLbm93blN5bWJvbCRpO1xudmFyIElTX1BVUkUgPSBpc1B1cmU7XG5cbnZhciBJVEVSQVRPUiQxID0gd2VsbEtub3duU3ltYm9sJDMoJ2l0ZXJhdG9yJyk7XG5cbnZhciBuYXRpdmVVcmwgPSAhZmFpbHMkNShmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL3JlbGF0aXZlLXVybC1zdHlsZSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICB2YXIgdXJsID0gbmV3IFVSTCgnYj9hPTEmYj0yJmM9MycsICdodHRwOi8vYScpO1xuICB2YXIgc2VhcmNoUGFyYW1zID0gdXJsLnNlYXJjaFBhcmFtcztcbiAgdmFyIHJlc3VsdCA9ICcnO1xuICB1cmwucGF0aG5hbWUgPSAnYyUyMGQnO1xuICBzZWFyY2hQYXJhbXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgIHNlYXJjaFBhcmFtc1snZGVsZXRlJ10oJ2InKTtcbiAgICByZXN1bHQgKz0ga2V5ICsgdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gKElTX1BVUkUgJiYgIXVybC50b0pTT04pXG4gICAgfHwgIXNlYXJjaFBhcmFtcy5zb3J0XG4gICAgfHwgdXJsLmhyZWYgIT09ICdodHRwOi8vYS9jJTIwZD9hPTEmYz0zJ1xuICAgIHx8IHNlYXJjaFBhcmFtcy5nZXQoJ2MnKSAhPT0gJzMnXG4gICAgfHwgU3RyaW5nKG5ldyBVUkxTZWFyY2hQYXJhbXMoJz9hPTEnKSkgIT09ICdhPTEnXG4gICAgfHwgIXNlYXJjaFBhcmFtc1tJVEVSQVRPUiQxXVxuICAgIC8vIHRocm93cyBpbiBFZGdlXG4gICAgfHwgbmV3IFVSTCgnaHR0cHM6Ly9hQGInKS51c2VybmFtZSAhPT0gJ2EnXG4gICAgfHwgbmV3IFVSTFNlYXJjaFBhcmFtcyhuZXcgVVJMU2VhcmNoUGFyYW1zKCdhPWInKSkuZ2V0KCdhJykgIT09ICdiJ1xuICAgIC8vIG5vdCBwdW55Y29kZWQgaW4gRWRnZVxuICAgIHx8IG5ldyBVUkwoJ2h0dHA6Ly/RgtC10YHRgicpLmhvc3QgIT09ICd4bi0tZTFheWJjJ1xuICAgIC8vIG5vdCBlc2NhcGVkIGluIENocm9tZSA2Mi1cbiAgICB8fCBuZXcgVVJMKCdodHRwOi8vYSPQsScpLmhhc2ggIT09ICcjJUQwJUIxJ1xuICAgIC8vIGZhaWxzIGluIENocm9tZSA2Ni1cbiAgICB8fCByZXN1bHQgIT09ICdhMWMzJ1xuICAgIC8vIHRocm93cyBpbiBTYWZhcmlcbiAgICB8fCBuZXcgVVJMKCdodHRwOi8veCcsIHVuZGVmaW5lZCkuaG9zdCAhPT0gJ3gnO1xufSk7XG5cbnZhciBtYWtlQnVpbHRJbiA9IG1ha2VCdWlsdEluJDMuZXhwb3J0cztcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IG9iamVjdERlZmluZVByb3BlcnR5O1xuXG52YXIgZGVmaW5lQnVpbHRJbkFjY2Vzc29yJDEgPSBmdW5jdGlvbiAodGFyZ2V0LCBuYW1lLCBkZXNjcmlwdG9yKSB7XG4gIGlmIChkZXNjcmlwdG9yLmdldCkgbWFrZUJ1aWx0SW4oZGVzY3JpcHRvci5nZXQsIG5hbWUsIHsgZ2V0dGVyOiB0cnVlIH0pO1xuICBpZiAoZGVzY3JpcHRvci5zZXQpIG1ha2VCdWlsdEluKGRlc2NyaXB0b3Iuc2V0LCBuYW1lLCB7IHNldHRlcjogdHJ1ZSB9KTtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5LmYodGFyZ2V0LCBuYW1lLCBkZXNjcmlwdG9yKTtcbn07XG5cbnZhciBhbk9iamVjdCQzID0gYW5PYmplY3QkZztcbnZhciBpdGVyYXRvckNsb3NlID0gaXRlcmF0b3JDbG9zZSQyO1xuXG4vLyBjYWxsIHNvbWV0aGluZyBvbiBpdGVyYXRvciBzdGVwIHdpdGggc2FmZSBjbG9zaW5nIG9uIGVycm9yXG52YXIgY2FsbFdpdGhTYWZlSXRlcmF0aW9uQ2xvc2luZyQxID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCBmbiwgdmFsdWUsIEVOVFJJRVMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gRU5UUklFUyA/IGZuKGFuT2JqZWN0JDModmFsdWUpWzBdLCB2YWx1ZVsxXSkgOiBmbih2YWx1ZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaXRlcmF0b3JDbG9zZShpdGVyYXRvciwgJ3Rocm93JywgZXJyb3IpO1xuICB9XG59O1xuXG52YXIgdG9Qcm9wZXJ0eUtleSA9IHRvUHJvcGVydHlLZXkkMztcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IG9iamVjdERlZmluZVByb3BlcnR5O1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQxID0gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDU7XG5cbnZhciBjcmVhdGVQcm9wZXJ0eSQyID0gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICB2YXIgcHJvcGVydHlLZXkgPSB0b1Byb3BlcnR5S2V5KGtleSk7XG4gIGlmIChwcm9wZXJ0eUtleSBpbiBvYmplY3QpIGRlZmluZVByb3BlcnR5TW9kdWxlLmYob2JqZWN0LCBwcm9wZXJ0eUtleSwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDEoMCwgdmFsdWUpKTtcbiAgZWxzZSBvYmplY3RbcHJvcGVydHlLZXldID0gdmFsdWU7XG59O1xuXG52YXIgYmluZCQyID0gZnVuY3Rpb25CaW5kQ29udGV4dDtcbnZhciBjYWxsJDQgPSBmdW5jdGlvbkNhbGw7XG52YXIgdG9PYmplY3QkMSA9IHRvT2JqZWN0JDU7XG52YXIgY2FsbFdpdGhTYWZlSXRlcmF0aW9uQ2xvc2luZyA9IGNhbGxXaXRoU2FmZUl0ZXJhdGlvbkNsb3NpbmckMTtcbnZhciBpc0FycmF5SXRlcmF0b3JNZXRob2QgPSBpc0FycmF5SXRlcmF0b3JNZXRob2QkMjtcbnZhciBpc0NvbnN0cnVjdG9yID0gaXNDb25zdHJ1Y3RvciQyO1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlJDEgPSBsZW5ndGhPZkFycmF5TGlrZSQ0O1xudmFyIGNyZWF0ZVByb3BlcnR5JDEgPSBjcmVhdGVQcm9wZXJ0eSQyO1xudmFyIGdldEl0ZXJhdG9yJDEgPSBnZXRJdGVyYXRvciQzO1xudmFyIGdldEl0ZXJhdG9yTWV0aG9kJDEgPSBnZXRJdGVyYXRvck1ldGhvZCQ0O1xuXG52YXIgJEFycmF5JDEgPSBBcnJheTtcblxuLy8gYEFycmF5LmZyb21gIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5mcm9tXG52YXIgYXJyYXlGcm9tJDEgPSBmdW5jdGlvbiBmcm9tKGFycmF5TGlrZSAvKiAsIG1hcGZuID0gdW5kZWZpbmVkLCB0aGlzQXJnID0gdW5kZWZpbmVkICovKSB7XG4gIHZhciBPID0gdG9PYmplY3QkMShhcnJheUxpa2UpO1xuICB2YXIgSVNfQ09OU1RSVUNUT1IgPSBpc0NvbnN0cnVjdG9yKHRoaXMpO1xuICB2YXIgYXJndW1lbnRzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIG1hcGZuID0gYXJndW1lbnRzTGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgdmFyIG1hcHBpbmcgPSBtYXBmbiAhPT0gdW5kZWZpbmVkO1xuICBpZiAobWFwcGluZykgbWFwZm4gPSBiaW5kJDIobWFwZm4sIGFyZ3VtZW50c0xlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQpO1xuICB2YXIgaXRlcmF0b3JNZXRob2QgPSBnZXRJdGVyYXRvck1ldGhvZCQxKE8pO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGVuZ3RoLCByZXN1bHQsIHN0ZXAsIGl0ZXJhdG9yLCBuZXh0LCB2YWx1ZTtcbiAgLy8gaWYgdGhlIHRhcmdldCBpcyBub3QgaXRlcmFibGUgb3IgaXQncyBhbiBhcnJheSB3aXRoIHRoZSBkZWZhdWx0IGl0ZXJhdG9yIC0gdXNlIGEgc2ltcGxlIGNhc2VcbiAgaWYgKGl0ZXJhdG9yTWV0aG9kICYmICEodGhpcyA9PT0gJEFycmF5JDEgJiYgaXNBcnJheUl0ZXJhdG9yTWV0aG9kKGl0ZXJhdG9yTWV0aG9kKSkpIHtcbiAgICBpdGVyYXRvciA9IGdldEl0ZXJhdG9yJDEoTywgaXRlcmF0b3JNZXRob2QpO1xuICAgIG5leHQgPSBpdGVyYXRvci5uZXh0O1xuICAgIHJlc3VsdCA9IElTX0NPTlNUUlVDVE9SID8gbmV3IHRoaXMoKSA6IFtdO1xuICAgIGZvciAoOyEoc3RlcCA9IGNhbGwkNChuZXh0LCBpdGVyYXRvcikpLmRvbmU7IGluZGV4KyspIHtcbiAgICAgIHZhbHVlID0gbWFwcGluZyA/IGNhbGxXaXRoU2FmZUl0ZXJhdGlvbkNsb3NpbmcoaXRlcmF0b3IsIG1hcGZuLCBbc3RlcC52YWx1ZSwgaW5kZXhdLCB0cnVlKSA6IHN0ZXAudmFsdWU7XG4gICAgICBjcmVhdGVQcm9wZXJ0eSQxKHJlc3VsdCwgaW5kZXgsIHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UkMShPKTtcbiAgICByZXN1bHQgPSBJU19DT05TVFJVQ1RPUiA/IG5ldyB0aGlzKGxlbmd0aCkgOiAkQXJyYXkkMShsZW5ndGgpO1xuICAgIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgICB2YWx1ZSA9IG1hcHBpbmcgPyBtYXBmbihPW2luZGV4XSwgaW5kZXgpIDogT1tpbmRleF07XG4gICAgICBjcmVhdGVQcm9wZXJ0eSQxKHJlc3VsdCwgaW5kZXgsIHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmVzdWx0Lmxlbmd0aCA9IGluZGV4O1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxudmFyIHRvQWJzb2x1dGVJbmRleCA9IHRvQWJzb2x1dGVJbmRleCQyO1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlID0gbGVuZ3RoT2ZBcnJheUxpa2UkNDtcbnZhciBjcmVhdGVQcm9wZXJ0eSA9IGNyZWF0ZVByb3BlcnR5JDI7XG5cbnZhciAkQXJyYXkgPSBBcnJheTtcbnZhciBtYXgkMSA9IE1hdGgubWF4O1xuXG52YXIgYXJyYXlTbGljZVNpbXBsZSA9IGZ1bmN0aW9uIChPLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW5ndGggPSBsZW5ndGhPZkFycmF5TGlrZShPKTtcbiAgdmFyIGsgPSB0b0Fic29sdXRlSW5kZXgoc3RhcnQsIGxlbmd0aCk7XG4gIHZhciBmaW4gPSB0b0Fic29sdXRlSW5kZXgoZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiBlbmQsIGxlbmd0aCk7XG4gIHZhciByZXN1bHQgPSAkQXJyYXkobWF4JDEoZmluIC0gaywgMCkpO1xuICBmb3IgKHZhciBuID0gMDsgayA8IGZpbjsgaysrLCBuKyspIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgbiwgT1trXSk7XG4gIHJlc3VsdC5sZW5ndGggPSBuO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2Jlc3RpZWpzL3B1bnljb2RlLmpzL2Jsb2IvbWFzdGVyL3B1bnljb2RlLmpzXG52YXIgdW5jdXJyeVRoaXMkNiA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG5cbnZhciBtYXhJbnQgPSAyMTQ3NDgzNjQ3OyAvLyBha2EuIDB4N0ZGRkZGRkYgb3IgMl4zMS0xXG52YXIgYmFzZSA9IDM2O1xudmFyIHRNaW4gPSAxO1xudmFyIHRNYXggPSAyNjtcbnZhciBza2V3ID0gMzg7XG52YXIgZGFtcCA9IDcwMDtcbnZhciBpbml0aWFsQmlhcyA9IDcyO1xudmFyIGluaXRpYWxOID0gMTI4OyAvLyAweDgwXG52YXIgZGVsaW1pdGVyID0gJy0nOyAvLyAnXFx4MkQnXG52YXIgcmVnZXhOb25BU0NJSSA9IC9bXlxcMC1cXHUwMDdFXS87IC8vIG5vbi1BU0NJSSBjaGFyc1xudmFyIHJlZ2V4U2VwYXJhdG9ycyA9IC9bLlxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZzsgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xudmFyIE9WRVJGTE9XX0VSUk9SID0gJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJztcbnZhciBiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW47XG5cbnZhciAkUmFuZ2VFcnJvciA9IFJhbmdlRXJyb3I7XG52YXIgZXhlYyQyID0gdW5jdXJyeVRoaXMkNihyZWdleFNlcGFyYXRvcnMuZXhlYyk7XG52YXIgZmxvb3IkMyA9IE1hdGguZmxvb3I7XG52YXIgZnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcbnZhciBjaGFyQ29kZUF0ID0gdW5jdXJyeVRoaXMkNignJy5jaGFyQ29kZUF0KTtcbnZhciBqb2luJDIgPSB1bmN1cnJ5VGhpcyQ2KFtdLmpvaW4pO1xudmFyIHB1c2gkMyA9IHVuY3VycnlUaGlzJDYoW10ucHVzaCk7XG52YXIgcmVwbGFjZSQ0ID0gdW5jdXJyeVRoaXMkNignJy5yZXBsYWNlKTtcbnZhciBzcGxpdCQyID0gdW5jdXJyeVRoaXMkNignJy5zcGxpdCk7XG52YXIgdG9Mb3dlckNhc2UkMSA9IHVuY3VycnlUaGlzJDYoJycudG9Mb3dlckNhc2UpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcbiAqIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLiBXaGlsZSBKYXZhU2NyaXB0IHVzZXMgVUNTLTIgaW50ZXJuYWxseSxcbiAqIHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGEgcGFpciBvZiBzdXJyb2dhdGUgaGFsdmVzIChlYWNoIG9mIHdoaWNoXG4gKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcbiAqIG1hdGNoaW5nIFVURi0xNi5cbiAqL1xudmFyIHVjczJkZWNvZGUgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgdmFyIGNvdW50ZXIgPSAwO1xuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgd2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBjaGFyQ29kZUF0KHN0cmluZywgY291bnRlcisrKTtcbiAgICBpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG4gICAgICAvLyBJdCdzIGEgaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyLlxuICAgICAgdmFyIGV4dHJhID0gY2hhckNvZGVBdChzdHJpbmcsIGNvdW50ZXIrKyk7XG4gICAgICBpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gTG93IHN1cnJvZ2F0ZS5cbiAgICAgICAgcHVzaCQzKG91dHB1dCwgKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEl0J3MgYW4gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlXG4gICAgICAgIC8vIG5leHQgY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyLlxuICAgICAgICBwdXNoJDMob3V0cHV0LCB2YWx1ZSk7XG4gICAgICAgIGNvdW50ZXItLTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcHVzaCQzKG91dHB1dCwgdmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuXG4gKi9cbnZhciBkaWdpdFRvQmFzaWMgPSBmdW5jdGlvbiAoZGlnaXQpIHtcbiAgLy8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcbiAgLy8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG4gIHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNik7XG59O1xuXG4vKipcbiAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxuICovXG52YXIgYWRhcHQgPSBmdW5jdGlvbiAoZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XG4gIHZhciBrID0gMDtcbiAgZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vciQzKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xuICBkZWx0YSArPSBmbG9vciQzKGRlbHRhIC8gbnVtUG9pbnRzKTtcbiAgd2hpbGUgKGRlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMSkge1xuICAgIGRlbHRhID0gZmxvb3IkMyhkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuICAgIGsgKz0gYmFzZTtcbiAgfVxuICByZXR1cm4gZmxvb3IkMyhrICsgKGJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhIC8gKGRlbHRhICsgc2tldykpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMgKGUuZy4gYSBkb21haW4gbmFtZSBsYWJlbCkgdG8gYVxuICogUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cbiAqL1xudmFyIGVuY29kZSA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICB2YXIgb3V0cHV0ID0gW107XG5cbiAgLy8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gYW4gYXJyYXkgb2YgVW5pY29kZSBjb2RlIHBvaW50cy5cbiAgaW5wdXQgPSB1Y3MyZGVjb2RlKGlucHV0KTtcblxuICAvLyBDYWNoZSB0aGUgbGVuZ3RoLlxuICB2YXIgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cbiAgLy8gSW5pdGlhbGl6ZSB0aGUgc3RhdGUuXG4gIHZhciBuID0gaW5pdGlhbE47XG4gIHZhciBkZWx0YSA9IDA7XG4gIHZhciBiaWFzID0gaW5pdGlhbEJpYXM7XG4gIHZhciBpLCBjdXJyZW50VmFsdWU7XG5cbiAgLy8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50cy5cbiAgZm9yIChpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgY3VycmVudFZhbHVlID0gaW5wdXRbaV07XG4gICAgaWYgKGN1cnJlbnRWYWx1ZSA8IDB4ODApIHtcbiAgICAgIHB1c2gkMyhvdXRwdXQsIGZyb21DaGFyQ29kZShjdXJyZW50VmFsdWUpKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzaWNMZW5ndGggPSBvdXRwdXQubGVuZ3RoOyAvLyBudW1iZXIgb2YgYmFzaWMgY29kZSBwb2ludHMuXG4gIHZhciBoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoOyAvLyBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcblxuICAvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyB3aXRoIGEgZGVsaW1pdGVyIHVubGVzcyBpdCdzIGVtcHR5LlxuICBpZiAoYmFzaWNMZW5ndGgpIHtcbiAgICBwdXNoJDMob3V0cHV0LCBkZWxpbWl0ZXIpO1xuICB9XG5cbiAgLy8gTWFpbiBlbmNvZGluZyBsb29wOlxuICB3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuICAgIC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHQgbGFyZ2VyIG9uZTpcbiAgICB2YXIgbSA9IG1heEludDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGN1cnJlbnRWYWx1ZSA9IGlucHV0W2ldO1xuICAgICAgaWYgKGN1cnJlbnRWYWx1ZSA+PSBuICYmIGN1cnJlbnRWYWx1ZSA8IG0pIHtcbiAgICAgICAgbSA9IGN1cnJlbnRWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93LlxuICAgIHZhciBoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XG4gICAgaWYgKG0gLSBuID4gZmxvb3IkMygobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuICAgICAgdGhyb3cgJFJhbmdlRXJyb3IoT1ZFUkZMT1dfRVJST1IpO1xuICAgIH1cblxuICAgIGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7XG4gICAgbiA9IG07XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGN1cnJlbnRWYWx1ZSA9IGlucHV0W2ldO1xuICAgICAgaWYgKGN1cnJlbnRWYWx1ZSA8IG4gJiYgKytkZWx0YSA+IG1heEludCkge1xuICAgICAgICB0aHJvdyAkUmFuZ2VFcnJvcihPVkVSRkxPV19FUlJPUik7XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudFZhbHVlID09IG4pIHtcbiAgICAgICAgLy8gUmVwcmVzZW50IGRlbHRhIGFzIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIuXG4gICAgICAgIHZhciBxID0gZGVsdGE7XG4gICAgICAgIHZhciBrID0gYmFzZTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICB2YXIgdCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG4gICAgICAgICAgaWYgKHEgPCB0KSBicmVhaztcbiAgICAgICAgICB2YXIgcU1pbnVzVCA9IHEgLSB0O1xuICAgICAgICAgIHZhciBiYXNlTWludXNUID0gYmFzZSAtIHQ7XG4gICAgICAgICAgcHVzaCQzKG91dHB1dCwgZnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QpKSk7XG4gICAgICAgICAgcSA9IGZsb29yJDMocU1pbnVzVCAvIGJhc2VNaW51c1QpO1xuICAgICAgICAgIGsgKz0gYmFzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHB1c2gkMyhvdXRwdXQsIGZyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSkpKTtcbiAgICAgICAgYmlhcyA9IGFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09IGJhc2ljTGVuZ3RoKTtcbiAgICAgICAgZGVsdGEgPSAwO1xuICAgICAgICBoYW5kbGVkQ1BDb3VudCsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGRlbHRhKys7XG4gICAgbisrO1xuICB9XG4gIHJldHVybiBqb2luJDIob3V0cHV0LCAnJyk7XG59O1xuXG52YXIgc3RyaW5nUHVueWNvZGVUb0FzY2lpID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gIHZhciBlbmNvZGVkID0gW107XG4gIHZhciBsYWJlbHMgPSBzcGxpdCQyKHJlcGxhY2UkNCh0b0xvd2VyQ2FzZSQxKGlucHV0KSwgcmVnZXhTZXBhcmF0b3JzLCAnXFx1MDAyRScpLCAnLicpO1xuICB2YXIgaSwgbGFiZWw7XG4gIGZvciAoaSA9IDA7IGkgPCBsYWJlbHMubGVuZ3RoOyBpKyspIHtcbiAgICBsYWJlbCA9IGxhYmVsc1tpXTtcbiAgICBwdXNoJDMoZW5jb2RlZCwgZXhlYyQyKHJlZ2V4Tm9uQVNDSUksIGxhYmVsKSA/ICd4bi0tJyArIGVuY29kZShsYWJlbCkgOiBsYWJlbCk7XG4gIH1cbiAgcmV0dXJuIGpvaW4kMihlbmNvZGVkLCAnLicpO1xufTtcblxudmFyIGRlZmluZUJ1aWx0SW4kMyA9IGRlZmluZUJ1aWx0SW4kYTtcblxudmFyIGRlZmluZUJ1aWx0SW5zJDEgPSBmdW5jdGlvbiAodGFyZ2V0LCBzcmMsIG9wdGlvbnMpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykgZGVmaW5lQnVpbHRJbiQzKHRhcmdldCwga2V5LCBzcmNba2V5XSwgb3B0aW9ucyk7XG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG52YXIgYXJyYXlTbGljZSQxID0gYXJyYXlTbGljZVNpbXBsZTtcblxudmFyIGZsb29yJDIgPSBNYXRoLmZsb29yO1xuXG52YXIgbWVyZ2VTb3J0ID0gZnVuY3Rpb24gKGFycmF5LCBjb21wYXJlZm4pIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgdmFyIG1pZGRsZSA9IGZsb29yJDIobGVuZ3RoIC8gMik7XG4gIHJldHVybiBsZW5ndGggPCA4ID8gaW5zZXJ0aW9uU29ydChhcnJheSwgY29tcGFyZWZuKSA6IG1lcmdlKFxuICAgIGFycmF5LFxuICAgIG1lcmdlU29ydChhcnJheVNsaWNlJDEoYXJyYXksIDAsIG1pZGRsZSksIGNvbXBhcmVmbiksXG4gICAgbWVyZ2VTb3J0KGFycmF5U2xpY2UkMShhcnJheSwgbWlkZGxlKSwgY29tcGFyZWZuKSxcbiAgICBjb21wYXJlZm5cbiAgKTtcbn07XG5cbnZhciBpbnNlcnRpb25Tb3J0ID0gZnVuY3Rpb24gKGFycmF5LCBjb21wYXJlZm4pIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgdmFyIGkgPSAxO1xuICB2YXIgZWxlbWVudCwgajtcblxuICB3aGlsZSAoaSA8IGxlbmd0aCkge1xuICAgIGogPSBpO1xuICAgIGVsZW1lbnQgPSBhcnJheVtpXTtcbiAgICB3aGlsZSAoaiAmJiBjb21wYXJlZm4oYXJyYXlbaiAtIDFdLCBlbGVtZW50KSA+IDApIHtcbiAgICAgIGFycmF5W2pdID0gYXJyYXlbLS1qXTtcbiAgICB9XG4gICAgaWYgKGogIT09IGkrKykgYXJyYXlbal0gPSBlbGVtZW50O1xuICB9IHJldHVybiBhcnJheTtcbn07XG5cbnZhciBtZXJnZSA9IGZ1bmN0aW9uIChhcnJheSwgbGVmdCwgcmlnaHQsIGNvbXBhcmVmbikge1xuICB2YXIgbGxlbmd0aCA9IGxlZnQubGVuZ3RoO1xuICB2YXIgcmxlbmd0aCA9IHJpZ2h0Lmxlbmd0aDtcbiAgdmFyIGxpbmRleCA9IDA7XG4gIHZhciByaW5kZXggPSAwO1xuXG4gIHdoaWxlIChsaW5kZXggPCBsbGVuZ3RoIHx8IHJpbmRleCA8IHJsZW5ndGgpIHtcbiAgICBhcnJheVtsaW5kZXggKyByaW5kZXhdID0gKGxpbmRleCA8IGxsZW5ndGggJiYgcmluZGV4IDwgcmxlbmd0aClcbiAgICAgID8gY29tcGFyZWZuKGxlZnRbbGluZGV4XSwgcmlnaHRbcmluZGV4XSkgPD0gMCA/IGxlZnRbbGluZGV4KytdIDogcmlnaHRbcmluZGV4KytdXG4gICAgICA6IGxpbmRleCA8IGxsZW5ndGggPyBsZWZ0W2xpbmRleCsrXSA6IHJpZ2h0W3JpbmRleCsrXTtcbiAgfSByZXR1cm4gYXJyYXk7XG59O1xuXG52YXIgYXJyYXlTb3J0JDEgPSBtZXJnZVNvcnQ7XG5cbi8vIFRPRE86IGluIGNvcmUtanNANCwgbW92ZSAvbW9kdWxlcy8gZGVwZW5kZW5jaWVzIHRvIHB1YmxpYyBlbnRyaWVzIGZvciBiZXR0ZXIgb3B0aW1pemF0aW9uIGJ5IHRvb2xzIGxpa2UgYHByZXNldC1lbnZgXG5cbnZhciAkJDIgPSBfZXhwb3J0O1xudmFyIGdsb2JhbCQ1ID0gZ2xvYmFsJG87XG52YXIgY2FsbCQzID0gZnVuY3Rpb25DYWxsO1xudmFyIHVuY3VycnlUaGlzJDUgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIERFU0NSSVBUT1JTJDEgPSBkZXNjcmlwdG9ycztcbnZhciBVU0VfTkFUSVZFX1VSTCQxID0gbmF0aXZlVXJsO1xudmFyIGRlZmluZUJ1aWx0SW4kMiA9IGRlZmluZUJ1aWx0SW4kYTtcbnZhciBkZWZpbmVCdWlsdElucyA9IGRlZmluZUJ1aWx0SW5zJDE7XG52YXIgc2V0VG9TdHJpbmdUYWckMSA9IHNldFRvU3RyaW5nVGFnJDU7XG52YXIgY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvciA9IGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IkMjtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlJDEgPSBpbnRlcm5hbFN0YXRlO1xudmFyIGFuSW5zdGFuY2UkMSA9IGFuSW5zdGFuY2UkMztcbnZhciBpc0NhbGxhYmxlJDIgPSBpc0NhbGxhYmxlJG47XG52YXIgaGFzT3duJDEgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIGJpbmQkMSA9IGZ1bmN0aW9uQmluZENvbnRleHQ7XG52YXIgY2xhc3NvZiQxID0gY2xhc3NvZiQ2O1xudmFyIGFuT2JqZWN0JDIgPSBhbk9iamVjdCRnO1xudmFyIGlzT2JqZWN0ID0gaXNPYmplY3QkODtcbnZhciAkdG9TdHJpbmckMSA9IHRvU3RyaW5nJDQ7XG52YXIgY3JlYXRlJDEgPSBvYmplY3RDcmVhdGU7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDU7XG52YXIgZ2V0SXRlcmF0b3IgPSBnZXRJdGVyYXRvciQzO1xudmFyIGdldEl0ZXJhdG9yTWV0aG9kID0gZ2V0SXRlcmF0b3JNZXRob2QkNDtcbnZhciB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aCQxID0gdmFsaWRhdGVBcmd1bWVudHNMZW5ndGgkMztcbnZhciB3ZWxsS25vd25TeW1ib2wkMiA9IHdlbGxLbm93blN5bWJvbCRpO1xudmFyIGFycmF5U29ydCA9IGFycmF5U29ydCQxO1xuXG52YXIgSVRFUkFUT1IgPSB3ZWxsS25vd25TeW1ib2wkMignaXRlcmF0b3InKTtcbnZhciBVUkxfU0VBUkNIX1BBUkFNUyA9ICdVUkxTZWFyY2hQYXJhbXMnO1xudmFyIFVSTF9TRUFSQ0hfUEFSQU1TX0lURVJBVE9SID0gVVJMX1NFQVJDSF9QQVJBTVMgKyAnSXRlcmF0b3InO1xudmFyIHNldEludGVybmFsU3RhdGUkMSA9IEludGVybmFsU3RhdGVNb2R1bGUkMS5zZXQ7XG52YXIgZ2V0SW50ZXJuYWxQYXJhbXNTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUkMS5nZXR0ZXJGb3IoVVJMX1NFQVJDSF9QQVJBTVMpO1xudmFyIGdldEludGVybmFsSXRlcmF0b3JTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUkMS5nZXR0ZXJGb3IoVVJMX1NFQVJDSF9QQVJBTVNfSVRFUkFUT1IpO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuLy8gQXZvaWQgTm9kZUpTIGV4cGVyaW1lbnRhbCB3YXJuaW5nXG52YXIgc2FmZUdldEJ1aWx0SW4gPSBmdW5jdGlvbiAobmFtZSkge1xuICBpZiAoIURFU0NSSVBUT1JTJDEpIHJldHVybiBnbG9iYWwkNVtuYW1lXTtcbiAgdmFyIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZ2xvYmFsJDUsIG5hbWUpO1xuICByZXR1cm4gZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLnZhbHVlO1xufTtcblxudmFyIG5hdGl2ZUZldGNoID0gc2FmZUdldEJ1aWx0SW4oJ2ZldGNoJyk7XG52YXIgTmF0aXZlUmVxdWVzdCA9IHNhZmVHZXRCdWlsdEluKCdSZXF1ZXN0Jyk7XG52YXIgSGVhZGVycyA9IHNhZmVHZXRCdWlsdEluKCdIZWFkZXJzJyk7XG52YXIgUmVxdWVzdFByb3RvdHlwZSA9IE5hdGl2ZVJlcXVlc3QgJiYgTmF0aXZlUmVxdWVzdC5wcm90b3R5cGU7XG52YXIgSGVhZGVyc1Byb3RvdHlwZSA9IEhlYWRlcnMgJiYgSGVhZGVycy5wcm90b3R5cGU7XG52YXIgUmVnRXhwJDEgPSBnbG9iYWwkNS5SZWdFeHA7XG52YXIgVHlwZUVycm9yJDIgPSBnbG9iYWwkNS5UeXBlRXJyb3I7XG52YXIgZGVjb2RlVVJJQ29tcG9uZW50ID0gZ2xvYmFsJDUuZGVjb2RlVVJJQ29tcG9uZW50O1xudmFyIGVuY29kZVVSSUNvbXBvbmVudCQxID0gZ2xvYmFsJDUuZW5jb2RlVVJJQ29tcG9uZW50O1xudmFyIGNoYXJBdCQ0ID0gdW5jdXJyeVRoaXMkNSgnJy5jaGFyQXQpO1xudmFyIGpvaW4kMSA9IHVuY3VycnlUaGlzJDUoW10uam9pbik7XG52YXIgcHVzaCQyID0gdW5jdXJyeVRoaXMkNShbXS5wdXNoKTtcbnZhciByZXBsYWNlJDMgPSB1bmN1cnJ5VGhpcyQ1KCcnLnJlcGxhY2UpO1xudmFyIHNoaWZ0JDEgPSB1bmN1cnJ5VGhpcyQ1KFtdLnNoaWZ0KTtcbnZhciBzcGxpY2UgPSB1bmN1cnJ5VGhpcyQ1KFtdLnNwbGljZSk7XG52YXIgc3BsaXQkMSA9IHVuY3VycnlUaGlzJDUoJycuc3BsaXQpO1xudmFyIHN0cmluZ1NsaWNlJDQgPSB1bmN1cnJ5VGhpcyQ1KCcnLnNsaWNlKTtcblxudmFyIHBsdXMgPSAvXFwrL2c7XG52YXIgc2VxdWVuY2VzID0gQXJyYXkoNCk7XG5cbnZhciBwZXJjZW50U2VxdWVuY2UgPSBmdW5jdGlvbiAoYnl0ZXMpIHtcbiAgcmV0dXJuIHNlcXVlbmNlc1tieXRlcyAtIDFdIHx8IChzZXF1ZW5jZXNbYnl0ZXMgLSAxXSA9IFJlZ0V4cCQxKCcoKD86JVtcXFxcZGEtZl17Mn0peycgKyBieXRlcyArICd9KScsICdnaScpKTtcbn07XG5cbnZhciBwZXJjZW50RGVjb2RlID0gZnVuY3Rpb24gKHNlcXVlbmNlKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzZXF1ZW5jZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHNlcXVlbmNlO1xuICB9XG59O1xuXG52YXIgZGVzZXJpYWxpemUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIHJlc3VsdCA9IHJlcGxhY2UkMyhpdCwgcGx1cywgJyAnKTtcbiAgdmFyIGJ5dGVzID0gNDtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHJlc3VsdCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgd2hpbGUgKGJ5dGVzKSB7XG4gICAgICByZXN1bHQgPSByZXBsYWNlJDMocmVzdWx0LCBwZXJjZW50U2VxdWVuY2UoYnl0ZXMtLSksIHBlcmNlbnREZWNvZGUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuXG52YXIgZmluZCA9IC9bIScoKX5dfCUyMC9nO1xuXG52YXIgcmVwbGFjZW1lbnRzID0ge1xuICAnISc6ICclMjEnLFxuICBcIidcIjogJyUyNycsXG4gICcoJzogJyUyOCcsXG4gICcpJzogJyUyOScsXG4gICd+JzogJyU3RScsXG4gICclMjAnOiAnKydcbn07XG5cbnZhciByZXBsYWNlciA9IGZ1bmN0aW9uIChtYXRjaCkge1xuICByZXR1cm4gcmVwbGFjZW1lbnRzW21hdGNoXTtcbn07XG5cbnZhciBzZXJpYWxpemUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHJlcGxhY2UkMyhlbmNvZGVVUklDb21wb25lbnQkMShpdCksIGZpbmQsIHJlcGxhY2VyKTtcbn07XG5cbnZhciBVUkxTZWFyY2hQYXJhbXNJdGVyYXRvciA9IGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IoZnVuY3Rpb24gSXRlcmF0b3IocGFyYW1zLCBraW5kKSB7XG4gIHNldEludGVybmFsU3RhdGUkMSh0aGlzLCB7XG4gICAgdHlwZTogVVJMX1NFQVJDSF9QQVJBTVNfSVRFUkFUT1IsXG4gICAgaXRlcmF0b3I6IGdldEl0ZXJhdG9yKGdldEludGVybmFsUGFyYW1zU3RhdGUocGFyYW1zKS5lbnRyaWVzKSxcbiAgICBraW5kOiBraW5kXG4gIH0pO1xufSwgJ0l0ZXJhdG9yJywgZnVuY3Rpb24gbmV4dCgpIHtcbiAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxJdGVyYXRvclN0YXRlKHRoaXMpO1xuICB2YXIga2luZCA9IHN0YXRlLmtpbmQ7XG4gIHZhciBzdGVwID0gc3RhdGUuaXRlcmF0b3IubmV4dCgpO1xuICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICBpZiAoIXN0ZXAuZG9uZSkge1xuICAgIHN0ZXAudmFsdWUgPSBraW5kID09PSAna2V5cycgPyBlbnRyeS5rZXkgOiBraW5kID09PSAndmFsdWVzJyA/IGVudHJ5LnZhbHVlIDogW2VudHJ5LmtleSwgZW50cnkudmFsdWVdO1xuICB9IHJldHVybiBzdGVwO1xufSwgdHJ1ZSk7XG5cbnZhciBVUkxTZWFyY2hQYXJhbXNTdGF0ZSA9IGZ1bmN0aW9uIChpbml0KSB7XG4gIHRoaXMuZW50cmllcyA9IFtdO1xuICB0aGlzLnVybCA9IG51bGw7XG5cbiAgaWYgKGluaXQgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChpc09iamVjdChpbml0KSkgdGhpcy5wYXJzZU9iamVjdChpbml0KTtcbiAgICBlbHNlIHRoaXMucGFyc2VRdWVyeSh0eXBlb2YgaW5pdCA9PSAnc3RyaW5nJyA/IGNoYXJBdCQ0KGluaXQsIDApID09PSAnPycgPyBzdHJpbmdTbGljZSQ0KGluaXQsIDEpIDogaW5pdCA6ICR0b1N0cmluZyQxKGluaXQpKTtcbiAgfVxufTtcblxuVVJMU2VhcmNoUGFyYW1zU3RhdGUucHJvdG90eXBlID0ge1xuICB0eXBlOiBVUkxfU0VBUkNIX1BBUkFNUyxcbiAgYmluZFVSTDogZnVuY3Rpb24gKHVybCkge1xuICAgIHRoaXMudXJsID0gdXJsO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH0sXG4gIHBhcnNlT2JqZWN0OiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gZ2V0SXRlcmF0b3JNZXRob2Qob2JqZWN0KTtcbiAgICB2YXIgaXRlcmF0b3IsIG5leHQsIHN0ZXAsIGVudHJ5SXRlcmF0b3IsIGVudHJ5TmV4dCwgZmlyc3QsIHNlY29uZDtcblxuICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgaXRlcmF0b3IgPSBnZXRJdGVyYXRvcihvYmplY3QsIGl0ZXJhdG9yTWV0aG9kKTtcbiAgICAgIG5leHQgPSBpdGVyYXRvci5uZXh0O1xuICAgICAgd2hpbGUgKCEoc3RlcCA9IGNhbGwkMyhuZXh0LCBpdGVyYXRvcikpLmRvbmUpIHtcbiAgICAgICAgZW50cnlJdGVyYXRvciA9IGdldEl0ZXJhdG9yKGFuT2JqZWN0JDIoc3RlcC52YWx1ZSkpO1xuICAgICAgICBlbnRyeU5leHQgPSBlbnRyeUl0ZXJhdG9yLm5leHQ7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAoZmlyc3QgPSBjYWxsJDMoZW50cnlOZXh0LCBlbnRyeUl0ZXJhdG9yKSkuZG9uZSB8fFxuICAgICAgICAgIChzZWNvbmQgPSBjYWxsJDMoZW50cnlOZXh0LCBlbnRyeUl0ZXJhdG9yKSkuZG9uZSB8fFxuICAgICAgICAgICFjYWxsJDMoZW50cnlOZXh0LCBlbnRyeUl0ZXJhdG9yKS5kb25lXG4gICAgICAgICkgdGhyb3cgVHlwZUVycm9yJDIoJ0V4cGVjdGVkIHNlcXVlbmNlIHdpdGggbGVuZ3RoIDInKTtcbiAgICAgICAgcHVzaCQyKHRoaXMuZW50cmllcywgeyBrZXk6ICR0b1N0cmluZyQxKGZpcnN0LnZhbHVlKSwgdmFsdWU6ICR0b1N0cmluZyQxKHNlY29uZC52YWx1ZSkgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGZvciAodmFyIGtleSBpbiBvYmplY3QpIGlmIChoYXNPd24kMShvYmplY3QsIGtleSkpIHtcbiAgICAgIHB1c2gkMih0aGlzLmVudHJpZXMsIHsga2V5OiBrZXksIHZhbHVlOiAkdG9TdHJpbmckMShvYmplY3Rba2V5XSkgfSk7XG4gICAgfVxuICB9LFxuICBwYXJzZVF1ZXJ5OiBmdW5jdGlvbiAocXVlcnkpIHtcbiAgICBpZiAocXVlcnkpIHtcbiAgICAgIHZhciBhdHRyaWJ1dGVzID0gc3BsaXQkMShxdWVyeSwgJyYnKTtcbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICB2YXIgYXR0cmlidXRlLCBlbnRyeTtcbiAgICAgIHdoaWxlIChpbmRleCA8IGF0dHJpYnV0ZXMubGVuZ3RoKSB7XG4gICAgICAgIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbaW5kZXgrK107XG4gICAgICAgIGlmIChhdHRyaWJ1dGUubGVuZ3RoKSB7XG4gICAgICAgICAgZW50cnkgPSBzcGxpdCQxKGF0dHJpYnV0ZSwgJz0nKTtcbiAgICAgICAgICBwdXNoJDIodGhpcy5lbnRyaWVzLCB7XG4gICAgICAgICAgICBrZXk6IGRlc2VyaWFsaXplKHNoaWZ0JDEoZW50cnkpKSxcbiAgICAgICAgICAgIHZhbHVlOiBkZXNlcmlhbGl6ZShqb2luJDEoZW50cnksICc9JykpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHNlcmlhbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbnRyaWVzID0gdGhpcy5lbnRyaWVzO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBlbnRyeTtcbiAgICB3aGlsZSAoaW5kZXggPCBlbnRyaWVzLmxlbmd0aCkge1xuICAgICAgZW50cnkgPSBlbnRyaWVzW2luZGV4KytdO1xuICAgICAgcHVzaCQyKHJlc3VsdCwgc2VyaWFsaXplKGVudHJ5LmtleSkgKyAnPScgKyBzZXJpYWxpemUoZW50cnkudmFsdWUpKTtcbiAgICB9IHJldHVybiBqb2luJDEocmVzdWx0LCAnJicpO1xuICB9LFxuICB1cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmVudHJpZXMubGVuZ3RoID0gMDtcbiAgICB0aGlzLnBhcnNlUXVlcnkodGhpcy51cmwucXVlcnkpO1xuICB9LFxuICB1cGRhdGVVUkw6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy51cmwpIHRoaXMudXJsLnVwZGF0ZSgpO1xuICB9XG59O1xuXG4vLyBgVVJMU2VhcmNoUGFyYW1zYCBjb25zdHJ1Y3RvclxuLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNpbnRlcmZhY2UtdXJsc2VhcmNocGFyYW1zXG52YXIgVVJMU2VhcmNoUGFyYW1zQ29uc3RydWN0b3IgPSBmdW5jdGlvbiBVUkxTZWFyY2hQYXJhbXMoLyogaW5pdCAqLykge1xuICBhbkluc3RhbmNlJDEodGhpcywgVVJMU2VhcmNoUGFyYW1zUHJvdG90eXBlKTtcbiAgdmFyIGluaXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZDtcbiAgc2V0SW50ZXJuYWxTdGF0ZSQxKHRoaXMsIG5ldyBVUkxTZWFyY2hQYXJhbXNTdGF0ZShpbml0KSk7XG59O1xuXG52YXIgVVJMU2VhcmNoUGFyYW1zUHJvdG90eXBlID0gVVJMU2VhcmNoUGFyYW1zQ29uc3RydWN0b3IucHJvdG90eXBlO1xuXG5kZWZpbmVCdWlsdElucyhVUkxTZWFyY2hQYXJhbXNQcm90b3R5cGUsIHtcbiAgLy8gYFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuYXBwZW5kYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsc2VhcmNocGFyYW1zLWFwcGVuZFxuICBhcHBlbmQ6IGZ1bmN0aW9uIGFwcGVuZChuYW1lLCB2YWx1ZSkge1xuICAgIHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoJDEoYXJndW1lbnRzLmxlbmd0aCwgMik7XG4gICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxQYXJhbXNTdGF0ZSh0aGlzKTtcbiAgICBwdXNoJDIoc3RhdGUuZW50cmllcywgeyBrZXk6ICR0b1N0cmluZyQxKG5hbWUpLCB2YWx1ZTogJHRvU3RyaW5nJDEodmFsdWUpIH0pO1xuICAgIHN0YXRlLnVwZGF0ZVVSTCgpO1xuICB9LFxuICAvLyBgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5kZWxldGVgIG1ldGhvZFxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmxzZWFyY2hwYXJhbXMtZGVsZXRlXG4gICdkZWxldGUnOiBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoJDEoYXJndW1lbnRzLmxlbmd0aCwgMSk7XG4gICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxQYXJhbXNTdGF0ZSh0aGlzKTtcbiAgICB2YXIgZW50cmllcyA9IHN0YXRlLmVudHJpZXM7XG4gICAgdmFyIGtleSA9ICR0b1N0cmluZyQxKG5hbWUpO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgd2hpbGUgKGluZGV4IDwgZW50cmllcy5sZW5ndGgpIHtcbiAgICAgIGlmIChlbnRyaWVzW2luZGV4XS5rZXkgPT09IGtleSkgc3BsaWNlKGVudHJpZXMsIGluZGV4LCAxKTtcbiAgICAgIGVsc2UgaW5kZXgrKztcbiAgICB9XG4gICAgc3RhdGUudXBkYXRlVVJMKCk7XG4gIH0sXG4gIC8vIGBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmdldGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybHNlYXJjaHBhcmFtcy1nZXRcbiAgZ2V0OiBmdW5jdGlvbiBnZXQobmFtZSkge1xuICAgIHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoJDEoYXJndW1lbnRzLmxlbmd0aCwgMSk7XG4gICAgdmFyIGVudHJpZXMgPSBnZXRJbnRlcm5hbFBhcmFtc1N0YXRlKHRoaXMpLmVudHJpZXM7XG4gICAgdmFyIGtleSA9ICR0b1N0cmluZyQxKG5hbWUpO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgZm9yICg7IGluZGV4IDwgZW50cmllcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGlmIChlbnRyaWVzW2luZGV4XS5rZXkgPT09IGtleSkgcmV0dXJuIGVudHJpZXNbaW5kZXhdLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcbiAgLy8gYFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuZ2V0QWxsYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsc2VhcmNocGFyYW1zLWdldGFsbFxuICBnZXRBbGw6IGZ1bmN0aW9uIGdldEFsbChuYW1lKSB7XG4gICAgdmFsaWRhdGVBcmd1bWVudHNMZW5ndGgkMShhcmd1bWVudHMubGVuZ3RoLCAxKTtcbiAgICB2YXIgZW50cmllcyA9IGdldEludGVybmFsUGFyYW1zU3RhdGUodGhpcykuZW50cmllcztcbiAgICB2YXIga2V5ID0gJHRvU3RyaW5nJDEobmFtZSk7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgZm9yICg7IGluZGV4IDwgZW50cmllcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGlmIChlbnRyaWVzW2luZGV4XS5rZXkgPT09IGtleSkgcHVzaCQyKHJlc3VsdCwgZW50cmllc1tpbmRleF0udmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuICAvLyBgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5oYXNgIG1ldGhvZFxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmxzZWFyY2hwYXJhbXMtaGFzXG4gIGhhczogZnVuY3Rpb24gaGFzKG5hbWUpIHtcbiAgICB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aCQxKGFyZ3VtZW50cy5sZW5ndGgsIDEpO1xuICAgIHZhciBlbnRyaWVzID0gZ2V0SW50ZXJuYWxQYXJhbXNTdGF0ZSh0aGlzKS5lbnRyaWVzO1xuICAgIHZhciBrZXkgPSAkdG9TdHJpbmckMShuYW1lKTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHdoaWxlIChpbmRleCA8IGVudHJpZXMubGVuZ3RoKSB7XG4gICAgICBpZiAoZW50cmllc1tpbmRleCsrXS5rZXkgPT09IGtleSkgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcbiAgLy8gYFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuc2V0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsc2VhcmNocGFyYW1zLXNldFxuICBzZXQ6IGZ1bmN0aW9uIHNldChuYW1lLCB2YWx1ZSkge1xuICAgIHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoJDEoYXJndW1lbnRzLmxlbmd0aCwgMSk7XG4gICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxQYXJhbXNTdGF0ZSh0aGlzKTtcbiAgICB2YXIgZW50cmllcyA9IHN0YXRlLmVudHJpZXM7XG4gICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgdmFyIGtleSA9ICR0b1N0cmluZyQxKG5hbWUpO1xuICAgIHZhciB2YWwgPSAkdG9TdHJpbmckMSh2YWx1ZSk7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgZW50cnk7XG4gICAgZm9yICg7IGluZGV4IDwgZW50cmllcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgICBpZiAoZW50cnkua2V5ID09PSBrZXkpIHtcbiAgICAgICAgaWYgKGZvdW5kKSBzcGxpY2UoZW50cmllcywgaW5kZXgtLSwgMSk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICBlbnRyeS52YWx1ZSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWZvdW5kKSBwdXNoJDIoZW50cmllcywgeyBrZXk6IGtleSwgdmFsdWU6IHZhbCB9KTtcbiAgICBzdGF0ZS51cGRhdGVVUkwoKTtcbiAgfSxcbiAgLy8gYFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuc29ydGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybHNlYXJjaHBhcmFtcy1zb3J0XG4gIHNvcnQ6IGZ1bmN0aW9uIHNvcnQoKSB7XG4gICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxQYXJhbXNTdGF0ZSh0aGlzKTtcbiAgICBhcnJheVNvcnQoc3RhdGUuZW50cmllcywgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhLmtleSA+IGIua2V5ID8gMSA6IC0xO1xuICAgIH0pO1xuICAgIHN0YXRlLnVwZGF0ZVVSTCgpO1xuICB9LFxuICAvLyBgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5mb3JFYWNoYCBtZXRob2RcbiAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFjayAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICB2YXIgZW50cmllcyA9IGdldEludGVybmFsUGFyYW1zU3RhdGUodGhpcykuZW50cmllcztcbiAgICB2YXIgYm91bmRGdW5jdGlvbiA9IGJpbmQkMShjYWxsYmFjaywgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGVudHJ5O1xuICAgIHdoaWxlIChpbmRleCA8IGVudHJpZXMubGVuZ3RoKSB7XG4gICAgICBlbnRyeSA9IGVudHJpZXNbaW5kZXgrK107XG4gICAgICBib3VuZEZ1bmN0aW9uKGVudHJ5LnZhbHVlLCBlbnRyeS5rZXksIHRoaXMpO1xuICAgIH1cbiAgfSxcbiAgLy8gYFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUua2V5c2AgbWV0aG9kXG4gIGtleXM6IGZ1bmN0aW9uIGtleXMoKSB7XG4gICAgcmV0dXJuIG5ldyBVUkxTZWFyY2hQYXJhbXNJdGVyYXRvcih0aGlzLCAna2V5cycpO1xuICB9LFxuICAvLyBgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS52YWx1ZXNgIG1ldGhvZFxuICB2YWx1ZXM6IGZ1bmN0aW9uIHZhbHVlcygpIHtcbiAgICByZXR1cm4gbmV3IFVSTFNlYXJjaFBhcmFtc0l0ZXJhdG9yKHRoaXMsICd2YWx1ZXMnKTtcbiAgfSxcbiAgLy8gYFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuZW50cmllc2AgbWV0aG9kXG4gIGVudHJpZXM6IGZ1bmN0aW9uIGVudHJpZXMoKSB7XG4gICAgcmV0dXJuIG5ldyBVUkxTZWFyY2hQYXJhbXNJdGVyYXRvcih0aGlzLCAnZW50cmllcycpO1xuICB9XG59LCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5cbi8vIGBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlW0BAaXRlcmF0b3JdYCBtZXRob2RcbmRlZmluZUJ1aWx0SW4kMihVUkxTZWFyY2hQYXJhbXNQcm90b3R5cGUsIElURVJBVE9SLCBVUkxTZWFyY2hQYXJhbXNQcm90b3R5cGUuZW50cmllcywgeyBuYW1lOiAnZW50cmllcycgfSk7XG5cbi8vIGBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLnRvU3RyaW5nYCBtZXRob2Rcbi8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jdXJsc2VhcmNocGFyYW1zLXN0cmluZ2lmaWNhdGlvbi1iZWhhdmlvclxuZGVmaW5lQnVpbHRJbiQyKFVSTFNlYXJjaFBhcmFtc1Byb3RvdHlwZSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiBnZXRJbnRlcm5hbFBhcmFtc1N0YXRlKHRoaXMpLnNlcmlhbGl6ZSgpO1xufSwgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuXG5zZXRUb1N0cmluZ1RhZyQxKFVSTFNlYXJjaFBhcmFtc0NvbnN0cnVjdG9yLCBVUkxfU0VBUkNIX1BBUkFNUyk7XG5cbiQkMih7IGdsb2JhbDogdHJ1ZSwgY29uc3RydWN0b3I6IHRydWUsIGZvcmNlZDogIVVTRV9OQVRJVkVfVVJMJDEgfSwge1xuICBVUkxTZWFyY2hQYXJhbXM6IFVSTFNlYXJjaFBhcmFtc0NvbnN0cnVjdG9yXG59KTtcblxuLy8gV3JhcCBgZmV0Y2hgIGFuZCBgUmVxdWVzdGAgZm9yIGNvcnJlY3Qgd29yayB3aXRoIHBvbHlmaWxsZWQgYFVSTFNlYXJjaFBhcmFtc2BcbmlmICghVVNFX05BVElWRV9VUkwkMSAmJiBpc0NhbGxhYmxlJDIoSGVhZGVycykpIHtcbiAgdmFyIGhlYWRlcnNIYXMgPSB1bmN1cnJ5VGhpcyQ1KEhlYWRlcnNQcm90b3R5cGUuaGFzKTtcbiAgdmFyIGhlYWRlcnNTZXQgPSB1bmN1cnJ5VGhpcyQ1KEhlYWRlcnNQcm90b3R5cGUuc2V0KTtcblxuICB2YXIgd3JhcFJlcXVlc3RPcHRpb25zID0gZnVuY3Rpb24gKGluaXQpIHtcbiAgICBpZiAoaXNPYmplY3QoaW5pdCkpIHtcbiAgICAgIHZhciBib2R5ID0gaW5pdC5ib2R5O1xuICAgICAgdmFyIGhlYWRlcnM7XG4gICAgICBpZiAoY2xhc3NvZiQxKGJvZHkpID09PSBVUkxfU0VBUkNIX1BBUkFNUykge1xuICAgICAgICBoZWFkZXJzID0gaW5pdC5oZWFkZXJzID8gbmV3IEhlYWRlcnMoaW5pdC5oZWFkZXJzKSA6IG5ldyBIZWFkZXJzKCk7XG4gICAgICAgIGlmICghaGVhZGVyc0hhcyhoZWFkZXJzLCAnY29udGVudC10eXBlJykpIHtcbiAgICAgICAgICBoZWFkZXJzU2V0KGhlYWRlcnMsICdjb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9VVRGLTgnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlJDEoaW5pdCwge1xuICAgICAgICAgIGJvZHk6IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigwLCAkdG9TdHJpbmckMShib2R5KSksXG4gICAgICAgICAgaGVhZGVyczogY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDAsIGhlYWRlcnMpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gcmV0dXJuIGluaXQ7XG4gIH07XG5cbiAgaWYgKGlzQ2FsbGFibGUkMihuYXRpdmVGZXRjaCkpIHtcbiAgICAkJDIoeyBnbG9iYWw6IHRydWUsIGVudW1lcmFibGU6IHRydWUsIGRvbnRDYWxsR2V0U2V0OiB0cnVlLCBmb3JjZWQ6IHRydWUgfSwge1xuICAgICAgZmV0Y2g6IGZ1bmN0aW9uIGZldGNoKGlucHV0IC8qICwgaW5pdCAqLykge1xuICAgICAgICByZXR1cm4gbmF0aXZlRmV0Y2goaW5wdXQsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gd3JhcFJlcXVlc3RPcHRpb25zKGFyZ3VtZW50c1sxXSkgOiB7fSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAoaXNDYWxsYWJsZSQyKE5hdGl2ZVJlcXVlc3QpKSB7XG4gICAgdmFyIFJlcXVlc3RDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIFJlcXVlc3QoaW5wdXQgLyogLCBpbml0ICovKSB7XG4gICAgICBhbkluc3RhbmNlJDEodGhpcywgUmVxdWVzdFByb3RvdHlwZSk7XG4gICAgICByZXR1cm4gbmV3IE5hdGl2ZVJlcXVlc3QoaW5wdXQsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gd3JhcFJlcXVlc3RPcHRpb25zKGFyZ3VtZW50c1sxXSkgOiB7fSk7XG4gICAgfTtcblxuICAgIFJlcXVlc3RQcm90b3R5cGUuY29uc3RydWN0b3IgPSBSZXF1ZXN0Q29uc3RydWN0b3I7XG4gICAgUmVxdWVzdENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IFJlcXVlc3RQcm90b3R5cGU7XG5cbiAgICAkJDIoeyBnbG9iYWw6IHRydWUsIGNvbnN0cnVjdG9yOiB0cnVlLCBkb250Q2FsbEdldFNldDogdHJ1ZSwgZm9yY2VkOiB0cnVlIH0sIHtcbiAgICAgIFJlcXVlc3Q6IFJlcXVlc3RDb25zdHJ1Y3RvclxuICAgIH0pO1xuICB9XG59XG5cbnZhciB3ZWJfdXJsU2VhcmNoUGFyYW1zX2NvbnN0cnVjdG9yID0ge1xuICBVUkxTZWFyY2hQYXJhbXM6IFVSTFNlYXJjaFBhcmFtc0NvbnN0cnVjdG9yLFxuICBnZXRTdGF0ZTogZ2V0SW50ZXJuYWxQYXJhbXNTdGF0ZVxufTtcblxuLy8gVE9ETzogaW4gY29yZS1qc0A0LCBtb3ZlIC9tb2R1bGVzLyBkZXBlbmRlbmNpZXMgdG8gcHVibGljIGVudHJpZXMgZm9yIGJldHRlciBvcHRpbWl6YXRpb24gYnkgdG9vbHMgbGlrZSBgcHJlc2V0LWVudmBcblxudmFyICQkMSA9IF9leHBvcnQ7XG52YXIgREVTQ1JJUFRPUlMgPSBkZXNjcmlwdG9ycztcbnZhciBVU0VfTkFUSVZFX1VSTCA9IG5hdGl2ZVVybDtcbnZhciBnbG9iYWwkNCA9IGdsb2JhbCRvO1xudmFyIGJpbmQgPSBmdW5jdGlvbkJpbmRDb250ZXh0O1xudmFyIHVuY3VycnlUaGlzJDQgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGRlZmluZUJ1aWx0SW4kMSA9IGRlZmluZUJ1aWx0SW4kYTtcbnZhciBkZWZpbmVCdWlsdEluQWNjZXNzb3IgPSBkZWZpbmVCdWlsdEluQWNjZXNzb3IkMTtcbnZhciBhbkluc3RhbmNlID0gYW5JbnN0YW5jZSQzO1xudmFyIGhhc093biA9IGhhc093blByb3BlcnR5XzE7XG52YXIgYXNzaWduID0gb2JqZWN0QXNzaWduO1xudmFyIGFycmF5RnJvbSA9IGFycmF5RnJvbSQxO1xudmFyIGFycmF5U2xpY2UgPSBhcnJheVNsaWNlU2ltcGxlO1xudmFyIGNvZGVBdCA9IHN0cmluZ011bHRpYnl0ZS5jb2RlQXQ7XG52YXIgdG9BU0NJSSA9IHN0cmluZ1B1bnljb2RlVG9Bc2NpaTtcbnZhciAkdG9TdHJpbmcgPSB0b1N0cmluZyQ0O1xudmFyIHNldFRvU3RyaW5nVGFnID0gc2V0VG9TdHJpbmdUYWckNTtcbnZhciB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aCA9IHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoJDM7XG52YXIgVVJMU2VhcmNoUGFyYW1zTW9kdWxlID0gd2ViX3VybFNlYXJjaFBhcmFtc19jb25zdHJ1Y3RvcjtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gaW50ZXJuYWxTdGF0ZTtcblxudmFyIHNldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLnNldDtcbnZhciBnZXRJbnRlcm5hbFVSTFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXR0ZXJGb3IoJ1VSTCcpO1xudmFyIFVSTFNlYXJjaFBhcmFtcyQxID0gVVJMU2VhcmNoUGFyYW1zTW9kdWxlLlVSTFNlYXJjaFBhcmFtcztcbnZhciBnZXRJbnRlcm5hbFNlYXJjaFBhcmFtc1N0YXRlID0gVVJMU2VhcmNoUGFyYW1zTW9kdWxlLmdldFN0YXRlO1xuXG52YXIgTmF0aXZlVVJMID0gZ2xvYmFsJDQuVVJMO1xudmFyIFR5cGVFcnJvciQxID0gZ2xvYmFsJDQuVHlwZUVycm9yO1xudmFyIHBhcnNlSW50ID0gZ2xvYmFsJDQucGFyc2VJbnQ7XG52YXIgZmxvb3IkMSA9IE1hdGguZmxvb3I7XG52YXIgcG93ID0gTWF0aC5wb3c7XG52YXIgY2hhckF0JDMgPSB1bmN1cnJ5VGhpcyQ0KCcnLmNoYXJBdCk7XG52YXIgZXhlYyQxID0gdW5jdXJyeVRoaXMkNCgvLi8uZXhlYyk7XG52YXIgam9pbiA9IHVuY3VycnlUaGlzJDQoW10uam9pbik7XG52YXIgbnVtYmVyVG9TdHJpbmcgPSB1bmN1cnJ5VGhpcyQ0KDEuMC50b1N0cmluZyk7XG52YXIgcG9wID0gdW5jdXJyeVRoaXMkNChbXS5wb3ApO1xudmFyIHB1c2gkMSA9IHVuY3VycnlUaGlzJDQoW10ucHVzaCk7XG52YXIgcmVwbGFjZSQyID0gdW5jdXJyeVRoaXMkNCgnJy5yZXBsYWNlKTtcbnZhciBzaGlmdCA9IHVuY3VycnlUaGlzJDQoW10uc2hpZnQpO1xudmFyIHNwbGl0ID0gdW5jdXJyeVRoaXMkNCgnJy5zcGxpdCk7XG52YXIgc3RyaW5nU2xpY2UkMyA9IHVuY3VycnlUaGlzJDQoJycuc2xpY2UpO1xudmFyIHRvTG93ZXJDYXNlID0gdW5jdXJyeVRoaXMkNCgnJy50b0xvd2VyQ2FzZSk7XG52YXIgdW5zaGlmdCA9IHVuY3VycnlUaGlzJDQoW10udW5zaGlmdCk7XG5cbnZhciBJTlZBTElEX0FVVEhPUklUWSA9ICdJbnZhbGlkIGF1dGhvcml0eSc7XG52YXIgSU5WQUxJRF9TQ0hFTUUgPSAnSW52YWxpZCBzY2hlbWUnO1xudmFyIElOVkFMSURfSE9TVCA9ICdJbnZhbGlkIGhvc3QnO1xudmFyIElOVkFMSURfUE9SVCA9ICdJbnZhbGlkIHBvcnQnO1xuXG52YXIgQUxQSEEgPSAvW2Etel0vaTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWdleHAvbm8tb2JzY3VyZS1yYW5nZSAtLSBzYWZlXG52YXIgQUxQSEFOVU1FUklDID0gL1tcXGQrLS5hLXpdL2k7XG52YXIgRElHSVQgPSAvXFxkLztcbnZhciBIRVhfU1RBUlQgPSAvXjB4L2k7XG52YXIgT0NUID0gL15bMC03XSskLztcbnZhciBERUMgPSAvXlxcZCskLztcbnZhciBIRVggPSAvXltcXGRhLWZdKyQvaTtcbi8qIGVzbGludC1kaXNhYmxlIHJlZ2V4cC9uby1jb250cm9sLWNoYXJhY3RlciAtLSBzYWZlICovXG52YXIgRk9SQklEREVOX0hPU1RfQ09ERV9QT0lOVCA9IC9bXFwwXFx0XFxuXFxyICMlLzo8Pj9AW1xcXFxcXF1efF0vO1xudmFyIEZPUkJJRERFTl9IT1NUX0NPREVfUE9JTlRfRVhDTFVESU5HX1BFUkNFTlQgPSAvW1xcMFxcdFxcblxcciAjLzo8Pj9AW1xcXFxcXF1efF0vO1xudmFyIExFQURJTkdfQU5EX1RSQUlMSU5HX0MwX0NPTlRST0xfT1JfU1BBQ0UgPSAvXltcXHUwMDAwLVxcdTAwMjBdK3xbXFx1MDAwMC1cXHUwMDIwXSskL2c7XG52YXIgVEFCX0FORF9ORVdfTElORSA9IC9bXFx0XFxuXFxyXS9nO1xuLyogZXNsaW50LWVuYWJsZSByZWdleHAvbm8tY29udHJvbC1jaGFyYWN0ZXIgLS0gc2FmZSAqL1xudmFyIEVPRjtcblxuLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNpcHY0LW51bWJlci1wYXJzZXJcbnZhciBwYXJzZUlQdjQgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgdmFyIHBhcnRzID0gc3BsaXQoaW5wdXQsICcuJyk7XG4gIHZhciBwYXJ0c0xlbmd0aCwgbnVtYmVycywgaW5kZXgsIHBhcnQsIHJhZGl4LCBudW1iZXIsIGlwdjQ7XG4gIGlmIChwYXJ0cy5sZW5ndGggJiYgcGFydHNbcGFydHMubGVuZ3RoIC0gMV0gPT0gJycpIHtcbiAgICBwYXJ0cy5sZW5ndGgtLTtcbiAgfVxuICBwYXJ0c0xlbmd0aCA9IHBhcnRzLmxlbmd0aDtcbiAgaWYgKHBhcnRzTGVuZ3RoID4gNCkgcmV0dXJuIGlucHV0O1xuICBudW1iZXJzID0gW107XG4gIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHBhcnRzTGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgcGFydCA9IHBhcnRzW2luZGV4XTtcbiAgICBpZiAocGFydCA9PSAnJykgcmV0dXJuIGlucHV0O1xuICAgIHJhZGl4ID0gMTA7XG4gICAgaWYgKHBhcnQubGVuZ3RoID4gMSAmJiBjaGFyQXQkMyhwYXJ0LCAwKSA9PSAnMCcpIHtcbiAgICAgIHJhZGl4ID0gZXhlYyQxKEhFWF9TVEFSVCwgcGFydCkgPyAxNiA6IDg7XG4gICAgICBwYXJ0ID0gc3RyaW5nU2xpY2UkMyhwYXJ0LCByYWRpeCA9PSA4ID8gMSA6IDIpO1xuICAgIH1cbiAgICBpZiAocGFydCA9PT0gJycpIHtcbiAgICAgIG51bWJlciA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghZXhlYyQxKHJhZGl4ID09IDEwID8gREVDIDogcmFkaXggPT0gOCA/IE9DVCA6IEhFWCwgcGFydCkpIHJldHVybiBpbnB1dDtcbiAgICAgIG51bWJlciA9IHBhcnNlSW50KHBhcnQsIHJhZGl4KTtcbiAgICB9XG4gICAgcHVzaCQxKG51bWJlcnMsIG51bWJlcik7XG4gIH1cbiAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgcGFydHNMZW5ndGg7IGluZGV4KyspIHtcbiAgICBudW1iZXIgPSBudW1iZXJzW2luZGV4XTtcbiAgICBpZiAoaW5kZXggPT0gcGFydHNMZW5ndGggLSAxKSB7XG4gICAgICBpZiAobnVtYmVyID49IHBvdygyNTYsIDUgLSBwYXJ0c0xlbmd0aCkpIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSBpZiAobnVtYmVyID4gMjU1KSByZXR1cm4gbnVsbDtcbiAgfVxuICBpcHY0ID0gcG9wKG51bWJlcnMpO1xuICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBudW1iZXJzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIGlwdjQgKz0gbnVtYmVyc1tpbmRleF0gKiBwb3coMjU2LCAzIC0gaW5kZXgpO1xuICB9XG4gIHJldHVybiBpcHY0O1xufTtcblxuLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWlwdjYtcGFyc2VyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXN0YXRlbWVudHMgLS0gVE9ET1xudmFyIHBhcnNlSVB2NiA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICB2YXIgYWRkcmVzcyA9IFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwXTtcbiAgdmFyIHBpZWNlSW5kZXggPSAwO1xuICB2YXIgY29tcHJlc3MgPSBudWxsO1xuICB2YXIgcG9pbnRlciA9IDA7XG4gIHZhciB2YWx1ZSwgbGVuZ3RoLCBudW1iZXJzU2VlbiwgaXB2NFBpZWNlLCBudW1iZXIsIHN3YXBzLCBzd2FwO1xuXG4gIHZhciBjaHIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNoYXJBdCQzKGlucHV0LCBwb2ludGVyKTtcbiAgfTtcblxuICBpZiAoY2hyKCkgPT0gJzonKSB7XG4gICAgaWYgKGNoYXJBdCQzKGlucHV0LCAxKSAhPSAnOicpIHJldHVybjtcbiAgICBwb2ludGVyICs9IDI7XG4gICAgcGllY2VJbmRleCsrO1xuICAgIGNvbXByZXNzID0gcGllY2VJbmRleDtcbiAgfVxuICB3aGlsZSAoY2hyKCkpIHtcbiAgICBpZiAocGllY2VJbmRleCA9PSA4KSByZXR1cm47XG4gICAgaWYgKGNocigpID09ICc6Jykge1xuICAgICAgaWYgKGNvbXByZXNzICE9PSBudWxsKSByZXR1cm47XG4gICAgICBwb2ludGVyKys7XG4gICAgICBwaWVjZUluZGV4Kys7XG4gICAgICBjb21wcmVzcyA9IHBpZWNlSW5kZXg7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFsdWUgPSBsZW5ndGggPSAwO1xuICAgIHdoaWxlIChsZW5ndGggPCA0ICYmIGV4ZWMkMShIRVgsIGNocigpKSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZSAqIDE2ICsgcGFyc2VJbnQoY2hyKCksIDE2KTtcbiAgICAgIHBvaW50ZXIrKztcbiAgICAgIGxlbmd0aCsrO1xuICAgIH1cbiAgICBpZiAoY2hyKCkgPT0gJy4nKSB7XG4gICAgICBpZiAobGVuZ3RoID09IDApIHJldHVybjtcbiAgICAgIHBvaW50ZXIgLT0gbGVuZ3RoO1xuICAgICAgaWYgKHBpZWNlSW5kZXggPiA2KSByZXR1cm47XG4gICAgICBudW1iZXJzU2VlbiA9IDA7XG4gICAgICB3aGlsZSAoY2hyKCkpIHtcbiAgICAgICAgaXB2NFBpZWNlID0gbnVsbDtcbiAgICAgICAgaWYgKG51bWJlcnNTZWVuID4gMCkge1xuICAgICAgICAgIGlmIChjaHIoKSA9PSAnLicgJiYgbnVtYmVyc1NlZW4gPCA0KSBwb2ludGVyKys7XG4gICAgICAgICAgZWxzZSByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFleGVjJDEoRElHSVQsIGNocigpKSkgcmV0dXJuO1xuICAgICAgICB3aGlsZSAoZXhlYyQxKERJR0lULCBjaHIoKSkpIHtcbiAgICAgICAgICBudW1iZXIgPSBwYXJzZUludChjaHIoKSwgMTApO1xuICAgICAgICAgIGlmIChpcHY0UGllY2UgPT09IG51bGwpIGlwdjRQaWVjZSA9IG51bWJlcjtcbiAgICAgICAgICBlbHNlIGlmIChpcHY0UGllY2UgPT0gMCkgcmV0dXJuO1xuICAgICAgICAgIGVsc2UgaXB2NFBpZWNlID0gaXB2NFBpZWNlICogMTAgKyBudW1iZXI7XG4gICAgICAgICAgaWYgKGlwdjRQaWVjZSA+IDI1NSkgcmV0dXJuO1xuICAgICAgICAgIHBvaW50ZXIrKztcbiAgICAgICAgfVxuICAgICAgICBhZGRyZXNzW3BpZWNlSW5kZXhdID0gYWRkcmVzc1twaWVjZUluZGV4XSAqIDI1NiArIGlwdjRQaWVjZTtcbiAgICAgICAgbnVtYmVyc1NlZW4rKztcbiAgICAgICAgaWYgKG51bWJlcnNTZWVuID09IDIgfHwgbnVtYmVyc1NlZW4gPT0gNCkgcGllY2VJbmRleCsrO1xuICAgICAgfVxuICAgICAgaWYgKG51bWJlcnNTZWVuICE9IDQpIHJldHVybjtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSBpZiAoY2hyKCkgPT0gJzonKSB7XG4gICAgICBwb2ludGVyKys7XG4gICAgICBpZiAoIWNocigpKSByZXR1cm47XG4gICAgfSBlbHNlIGlmIChjaHIoKSkgcmV0dXJuO1xuICAgIGFkZHJlc3NbcGllY2VJbmRleCsrXSA9IHZhbHVlO1xuICB9XG4gIGlmIChjb21wcmVzcyAhPT0gbnVsbCkge1xuICAgIHN3YXBzID0gcGllY2VJbmRleCAtIGNvbXByZXNzO1xuICAgIHBpZWNlSW5kZXggPSA3O1xuICAgIHdoaWxlIChwaWVjZUluZGV4ICE9IDAgJiYgc3dhcHMgPiAwKSB7XG4gICAgICBzd2FwID0gYWRkcmVzc1twaWVjZUluZGV4XTtcbiAgICAgIGFkZHJlc3NbcGllY2VJbmRleC0tXSA9IGFkZHJlc3NbY29tcHJlc3MgKyBzd2FwcyAtIDFdO1xuICAgICAgYWRkcmVzc1tjb21wcmVzcyArIC0tc3dhcHNdID0gc3dhcDtcbiAgICB9XG4gIH0gZWxzZSBpZiAocGllY2VJbmRleCAhPSA4KSByZXR1cm47XG4gIHJldHVybiBhZGRyZXNzO1xufTtcblxudmFyIGZpbmRMb25nZXN0WmVyb1NlcXVlbmNlID0gZnVuY3Rpb24gKGlwdjYpIHtcbiAgdmFyIG1heEluZGV4ID0gbnVsbDtcbiAgdmFyIG1heExlbmd0aCA9IDE7XG4gIHZhciBjdXJyU3RhcnQgPSBudWxsO1xuICB2YXIgY3Vyckxlbmd0aCA9IDA7XG4gIHZhciBpbmRleCA9IDA7XG4gIGZvciAoOyBpbmRleCA8IDg7IGluZGV4KyspIHtcbiAgICBpZiAoaXB2NltpbmRleF0gIT09IDApIHtcbiAgICAgIGlmIChjdXJyTGVuZ3RoID4gbWF4TGVuZ3RoKSB7XG4gICAgICAgIG1heEluZGV4ID0gY3VyclN0YXJ0O1xuICAgICAgICBtYXhMZW5ndGggPSBjdXJyTGVuZ3RoO1xuICAgICAgfVxuICAgICAgY3VyclN0YXJ0ID0gbnVsbDtcbiAgICAgIGN1cnJMZW5ndGggPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY3VyclN0YXJ0ID09PSBudWxsKSBjdXJyU3RhcnQgPSBpbmRleDtcbiAgICAgICsrY3Vyckxlbmd0aDtcbiAgICB9XG4gIH1cbiAgaWYgKGN1cnJMZW5ndGggPiBtYXhMZW5ndGgpIHtcbiAgICBtYXhJbmRleCA9IGN1cnJTdGFydDtcbiAgICBtYXhMZW5ndGggPSBjdXJyTGVuZ3RoO1xuICB9XG4gIHJldHVybiBtYXhJbmRleDtcbn07XG5cbi8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jaG9zdC1zZXJpYWxpemluZ1xudmFyIHNlcmlhbGl6ZUhvc3QgPSBmdW5jdGlvbiAoaG9zdCkge1xuICB2YXIgcmVzdWx0LCBpbmRleCwgY29tcHJlc3MsIGlnbm9yZTA7XG4gIC8vIGlwdjRcbiAgaWYgKHR5cGVvZiBob3N0ID09ICdudW1iZXInKSB7XG4gICAgcmVzdWx0ID0gW107XG4gICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgNDsgaW5kZXgrKykge1xuICAgICAgdW5zaGlmdChyZXN1bHQsIGhvc3QgJSAyNTYpO1xuICAgICAgaG9zdCA9IGZsb29yJDEoaG9zdCAvIDI1Nik7XG4gICAgfSByZXR1cm4gam9pbihyZXN1bHQsICcuJyk7XG4gIC8vIGlwdjZcbiAgfSBlbHNlIGlmICh0eXBlb2YgaG9zdCA9PSAnb2JqZWN0Jykge1xuICAgIHJlc3VsdCA9ICcnO1xuICAgIGNvbXByZXNzID0gZmluZExvbmdlc3RaZXJvU2VxdWVuY2UoaG9zdCk7XG4gICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgODsgaW5kZXgrKykge1xuICAgICAgaWYgKGlnbm9yZTAgJiYgaG9zdFtpbmRleF0gPT09IDApIGNvbnRpbnVlO1xuICAgICAgaWYgKGlnbm9yZTApIGlnbm9yZTAgPSBmYWxzZTtcbiAgICAgIGlmIChjb21wcmVzcyA9PT0gaW5kZXgpIHtcbiAgICAgICAgcmVzdWx0ICs9IGluZGV4ID8gJzonIDogJzo6JztcbiAgICAgICAgaWdub3JlMCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgKz0gbnVtYmVyVG9TdHJpbmcoaG9zdFtpbmRleF0sIDE2KTtcbiAgICAgICAgaWYgKGluZGV4IDwgNykgcmVzdWx0ICs9ICc6JztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICdbJyArIHJlc3VsdCArICddJztcbiAgfSByZXR1cm4gaG9zdDtcbn07XG5cbnZhciBDMENvbnRyb2xQZXJjZW50RW5jb2RlU2V0ID0ge307XG52YXIgZnJhZ21lbnRQZXJjZW50RW5jb2RlU2V0ID0gYXNzaWduKHt9LCBDMENvbnRyb2xQZXJjZW50RW5jb2RlU2V0LCB7XG4gICcgJzogMSwgJ1wiJzogMSwgJzwnOiAxLCAnPic6IDEsICdgJzogMVxufSk7XG52YXIgcGF0aFBlcmNlbnRFbmNvZGVTZXQgPSBhc3NpZ24oe30sIGZyYWdtZW50UGVyY2VudEVuY29kZVNldCwge1xuICAnIyc6IDEsICc/JzogMSwgJ3snOiAxLCAnfSc6IDFcbn0pO1xudmFyIHVzZXJpbmZvUGVyY2VudEVuY29kZVNldCA9IGFzc2lnbih7fSwgcGF0aFBlcmNlbnRFbmNvZGVTZXQsIHtcbiAgJy8nOiAxLCAnOic6IDEsICc7JzogMSwgJz0nOiAxLCAnQCc6IDEsICdbJzogMSwgJ1xcXFwnOiAxLCAnXSc6IDEsICdeJzogMSwgJ3wnOiAxXG59KTtcblxudmFyIHBlcmNlbnRFbmNvZGUgPSBmdW5jdGlvbiAoY2hyLCBzZXQpIHtcbiAgdmFyIGNvZGUgPSBjb2RlQXQoY2hyLCAwKTtcbiAgcmV0dXJuIGNvZGUgPiAweDIwICYmIGNvZGUgPCAweDdGICYmICFoYXNPd24oc2V0LCBjaHIpID8gY2hyIDogZW5jb2RlVVJJQ29tcG9uZW50KGNocik7XG59O1xuXG4vLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3NwZWNpYWwtc2NoZW1lXG52YXIgc3BlY2lhbFNjaGVtZXMgPSB7XG4gIGZ0cDogMjEsXG4gIGZpbGU6IG51bGwsXG4gIGh0dHA6IDgwLFxuICBodHRwczogNDQzLFxuICB3czogODAsXG4gIHdzczogNDQzXG59O1xuXG4vLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3dpbmRvd3MtZHJpdmUtbGV0dGVyXG52YXIgaXNXaW5kb3dzRHJpdmVMZXR0ZXIgPSBmdW5jdGlvbiAoc3RyaW5nLCBub3JtYWxpemVkKSB7XG4gIHZhciBzZWNvbmQ7XG4gIHJldHVybiBzdHJpbmcubGVuZ3RoID09IDIgJiYgZXhlYyQxKEFMUEhBLCBjaGFyQXQkMyhzdHJpbmcsIDApKVxuICAgICYmICgoc2Vjb25kID0gY2hhckF0JDMoc3RyaW5nLCAxKSkgPT0gJzonIHx8ICghbm9ybWFsaXplZCAmJiBzZWNvbmQgPT0gJ3wnKSk7XG59O1xuXG4vLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3N0YXJ0LXdpdGgtYS13aW5kb3dzLWRyaXZlLWxldHRlclxudmFyIHN0YXJ0c1dpdGhXaW5kb3dzRHJpdmVMZXR0ZXIgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gIHZhciB0aGlyZDtcbiAgcmV0dXJuIHN0cmluZy5sZW5ndGggPiAxICYmIGlzV2luZG93c0RyaXZlTGV0dGVyKHN0cmluZ1NsaWNlJDMoc3RyaW5nLCAwLCAyKSkgJiYgKFxuICAgIHN0cmluZy5sZW5ndGggPT0gMiB8fFxuICAgICgodGhpcmQgPSBjaGFyQXQkMyhzdHJpbmcsIDIpKSA9PT0gJy8nIHx8IHRoaXJkID09PSAnXFxcXCcgfHwgdGhpcmQgPT09ICc/JyB8fCB0aGlyZCA9PT0gJyMnKVxuICApO1xufTtcblxuLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNzaW5nbGUtZG90LXBhdGgtc2VnbWVudFxudmFyIGlzU2luZ2xlRG90ID0gZnVuY3Rpb24gKHNlZ21lbnQpIHtcbiAgcmV0dXJuIHNlZ21lbnQgPT09ICcuJyB8fCB0b0xvd2VyQ2FzZShzZWdtZW50KSA9PT0gJyUyZSc7XG59O1xuXG4vLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvdWJsZS1kb3QtcGF0aC1zZWdtZW50XG52YXIgaXNEb3VibGVEb3QgPSBmdW5jdGlvbiAoc2VnbWVudCkge1xuICBzZWdtZW50ID0gdG9Mb3dlckNhc2Uoc2VnbWVudCk7XG4gIHJldHVybiBzZWdtZW50ID09PSAnLi4nIHx8IHNlZ21lbnQgPT09ICclMmUuJyB8fCBzZWdtZW50ID09PSAnLiUyZScgfHwgc2VnbWVudCA9PT0gJyUyZSUyZSc7XG59O1xuXG4vLyBTdGF0ZXM6XG52YXIgU0NIRU1FX1NUQVJUID0ge307XG52YXIgU0NIRU1FID0ge307XG52YXIgTk9fU0NIRU1FID0ge307XG52YXIgU1BFQ0lBTF9SRUxBVElWRV9PUl9BVVRIT1JJVFkgPSB7fTtcbnZhciBQQVRIX09SX0FVVEhPUklUWSA9IHt9O1xudmFyIFJFTEFUSVZFID0ge307XG52YXIgUkVMQVRJVkVfU0xBU0ggPSB7fTtcbnZhciBTUEVDSUFMX0FVVEhPUklUWV9TTEFTSEVTID0ge307XG52YXIgU1BFQ0lBTF9BVVRIT1JJVFlfSUdOT1JFX1NMQVNIRVMgPSB7fTtcbnZhciBBVVRIT1JJVFkgPSB7fTtcbnZhciBIT1NUID0ge307XG52YXIgSE9TVE5BTUUgPSB7fTtcbnZhciBQT1JUID0ge307XG52YXIgRklMRSA9IHt9O1xudmFyIEZJTEVfU0xBU0ggPSB7fTtcbnZhciBGSUxFX0hPU1QgPSB7fTtcbnZhciBQQVRIX1NUQVJUID0ge307XG52YXIgUEFUSCA9IHt9O1xudmFyIENBTk5PVF9CRV9BX0JBU0VfVVJMX1BBVEggPSB7fTtcbnZhciBRVUVSWSA9IHt9O1xudmFyIEZSQUdNRU5UID0ge307XG5cbnZhciBVUkxTdGF0ZSA9IGZ1bmN0aW9uICh1cmwsIGlzQmFzZSwgYmFzZSkge1xuICB2YXIgdXJsU3RyaW5nID0gJHRvU3RyaW5nKHVybCk7XG4gIHZhciBiYXNlU3RhdGUsIGZhaWx1cmUsIHNlYXJjaFBhcmFtcztcbiAgaWYgKGlzQmFzZSkge1xuICAgIGZhaWx1cmUgPSB0aGlzLnBhcnNlKHVybFN0cmluZyk7XG4gICAgaWYgKGZhaWx1cmUpIHRocm93IFR5cGVFcnJvciQxKGZhaWx1cmUpO1xuICAgIHRoaXMuc2VhcmNoUGFyYW1zID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICBpZiAoYmFzZSAhPT0gdW5kZWZpbmVkKSBiYXNlU3RhdGUgPSBuZXcgVVJMU3RhdGUoYmFzZSwgdHJ1ZSk7XG4gICAgZmFpbHVyZSA9IHRoaXMucGFyc2UodXJsU3RyaW5nLCBudWxsLCBiYXNlU3RhdGUpO1xuICAgIGlmIChmYWlsdXJlKSB0aHJvdyBUeXBlRXJyb3IkMShmYWlsdXJlKTtcbiAgICBzZWFyY2hQYXJhbXMgPSBnZXRJbnRlcm5hbFNlYXJjaFBhcmFtc1N0YXRlKG5ldyBVUkxTZWFyY2hQYXJhbXMkMSgpKTtcbiAgICBzZWFyY2hQYXJhbXMuYmluZFVSTCh0aGlzKTtcbiAgICB0aGlzLnNlYXJjaFBhcmFtcyA9IHNlYXJjaFBhcmFtcztcbiAgfVxufTtcblxuVVJMU3RhdGUucHJvdG90eXBlID0ge1xuICB0eXBlOiAnVVJMJyxcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN1cmwtcGFyc2luZ1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXN0YXRlbWVudHMgLS0gVE9ET1xuICBwYXJzZTogZnVuY3Rpb24gKGlucHV0LCBzdGF0ZU92ZXJyaWRlLCBiYXNlKSB7XG4gICAgdmFyIHVybCA9IHRoaXM7XG4gICAgdmFyIHN0YXRlID0gc3RhdGVPdmVycmlkZSB8fCBTQ0hFTUVfU1RBUlQ7XG4gICAgdmFyIHBvaW50ZXIgPSAwO1xuICAgIHZhciBidWZmZXIgPSAnJztcbiAgICB2YXIgc2VlbkF0ID0gZmFsc2U7XG4gICAgdmFyIHNlZW5CcmFja2V0ID0gZmFsc2U7XG4gICAgdmFyIHNlZW5QYXNzd29yZFRva2VuID0gZmFsc2U7XG4gICAgdmFyIGNvZGVQb2ludHMsIGNociwgYnVmZmVyQ29kZVBvaW50cywgZmFpbHVyZTtcblxuICAgIGlucHV0ID0gJHRvU3RyaW5nKGlucHV0KTtcblxuICAgIGlmICghc3RhdGVPdmVycmlkZSkge1xuICAgICAgdXJsLnNjaGVtZSA9ICcnO1xuICAgICAgdXJsLnVzZXJuYW1lID0gJyc7XG4gICAgICB1cmwucGFzc3dvcmQgPSAnJztcbiAgICAgIHVybC5ob3N0ID0gbnVsbDtcbiAgICAgIHVybC5wb3J0ID0gbnVsbDtcbiAgICAgIHVybC5wYXRoID0gW107XG4gICAgICB1cmwucXVlcnkgPSBudWxsO1xuICAgICAgdXJsLmZyYWdtZW50ID0gbnVsbDtcbiAgICAgIHVybC5jYW5ub3RCZUFCYXNlVVJMID0gZmFsc2U7XG4gICAgICBpbnB1dCA9IHJlcGxhY2UkMihpbnB1dCwgTEVBRElOR19BTkRfVFJBSUxJTkdfQzBfQ09OVFJPTF9PUl9TUEFDRSwgJycpO1xuICAgIH1cblxuICAgIGlucHV0ID0gcmVwbGFjZSQyKGlucHV0LCBUQUJfQU5EX05FV19MSU5FLCAnJyk7XG5cbiAgICBjb2RlUG9pbnRzID0gYXJyYXlGcm9tKGlucHV0KTtcblxuICAgIHdoaWxlIChwb2ludGVyIDw9IGNvZGVQb2ludHMubGVuZ3RoKSB7XG4gICAgICBjaHIgPSBjb2RlUG9pbnRzW3BvaW50ZXJdO1xuICAgICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgICBjYXNlIFNDSEVNRV9TVEFSVDpcbiAgICAgICAgICBpZiAoY2hyICYmIGV4ZWMkMShBTFBIQSwgY2hyKSkge1xuICAgICAgICAgICAgYnVmZmVyICs9IHRvTG93ZXJDYXNlKGNocik7XG4gICAgICAgICAgICBzdGF0ZSA9IFNDSEVNRTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFzdGF0ZU92ZXJyaWRlKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IE5PX1NDSEVNRTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSByZXR1cm4gSU5WQUxJRF9TQ0hFTUU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBTQ0hFTUU6XG4gICAgICAgICAgaWYgKGNociAmJiAoZXhlYyQxKEFMUEhBTlVNRVJJQywgY2hyKSB8fCBjaHIgPT0gJysnIHx8IGNociA9PSAnLScgfHwgY2hyID09ICcuJykpIHtcbiAgICAgICAgICAgIGJ1ZmZlciArPSB0b0xvd2VyQ2FzZShjaHIpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2hyID09ICc6Jykge1xuICAgICAgICAgICAgaWYgKHN0YXRlT3ZlcnJpZGUgJiYgKFxuICAgICAgICAgICAgICAodXJsLmlzU3BlY2lhbCgpICE9IGhhc093bihzcGVjaWFsU2NoZW1lcywgYnVmZmVyKSkgfHxcbiAgICAgICAgICAgICAgKGJ1ZmZlciA9PSAnZmlsZScgJiYgKHVybC5pbmNsdWRlc0NyZWRlbnRpYWxzKCkgfHwgdXJsLnBvcnQgIT09IG51bGwpKSB8fFxuICAgICAgICAgICAgICAodXJsLnNjaGVtZSA9PSAnZmlsZScgJiYgIXVybC5ob3N0KVxuICAgICAgICAgICAgKSkgcmV0dXJuO1xuICAgICAgICAgICAgdXJsLnNjaGVtZSA9IGJ1ZmZlcjtcbiAgICAgICAgICAgIGlmIChzdGF0ZU92ZXJyaWRlKSB7XG4gICAgICAgICAgICAgIGlmICh1cmwuaXNTcGVjaWFsKCkgJiYgc3BlY2lhbFNjaGVtZXNbdXJsLnNjaGVtZV0gPT0gdXJsLnBvcnQpIHVybC5wb3J0ID0gbnVsbDtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmZmVyID0gJyc7XG4gICAgICAgICAgICBpZiAodXJsLnNjaGVtZSA9PSAnZmlsZScpIHtcbiAgICAgICAgICAgICAgc3RhdGUgPSBGSUxFO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh1cmwuaXNTcGVjaWFsKCkgJiYgYmFzZSAmJiBiYXNlLnNjaGVtZSA9PSB1cmwuc2NoZW1lKSB7XG4gICAgICAgICAgICAgIHN0YXRlID0gU1BFQ0lBTF9SRUxBVElWRV9PUl9BVVRIT1JJVFk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHVybC5pc1NwZWNpYWwoKSkge1xuICAgICAgICAgICAgICBzdGF0ZSA9IFNQRUNJQUxfQVVUSE9SSVRZX1NMQVNIRVM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvZGVQb2ludHNbcG9pbnRlciArIDFdID09ICcvJykge1xuICAgICAgICAgICAgICBzdGF0ZSA9IFBBVEhfT1JfQVVUSE9SSVRZO1xuICAgICAgICAgICAgICBwb2ludGVyKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB1cmwuY2Fubm90QmVBQmFzZVVSTCA9IHRydWU7XG4gICAgICAgICAgICAgIHB1c2gkMSh1cmwucGF0aCwgJycpO1xuICAgICAgICAgICAgICBzdGF0ZSA9IENBTk5PVF9CRV9BX0JBU0VfVVJMX1BBVEg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICghc3RhdGVPdmVycmlkZSkge1xuICAgICAgICAgICAgYnVmZmVyID0gJyc7XG4gICAgICAgICAgICBzdGF0ZSA9IE5PX1NDSEVNRTtcbiAgICAgICAgICAgIHBvaW50ZXIgPSAwO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBlbHNlIHJldHVybiBJTlZBTElEX1NDSEVNRTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIE5PX1NDSEVNRTpcbiAgICAgICAgICBpZiAoIWJhc2UgfHwgKGJhc2UuY2Fubm90QmVBQmFzZVVSTCAmJiBjaHIgIT0gJyMnKSkgcmV0dXJuIElOVkFMSURfU0NIRU1FO1xuICAgICAgICAgIGlmIChiYXNlLmNhbm5vdEJlQUJhc2VVUkwgJiYgY2hyID09ICcjJykge1xuICAgICAgICAgICAgdXJsLnNjaGVtZSA9IGJhc2Uuc2NoZW1lO1xuICAgICAgICAgICAgdXJsLnBhdGggPSBhcnJheVNsaWNlKGJhc2UucGF0aCk7XG4gICAgICAgICAgICB1cmwucXVlcnkgPSBiYXNlLnF1ZXJ5O1xuICAgICAgICAgICAgdXJsLmZyYWdtZW50ID0gJyc7XG4gICAgICAgICAgICB1cmwuY2Fubm90QmVBQmFzZVVSTCA9IHRydWU7XG4gICAgICAgICAgICBzdGF0ZSA9IEZSQUdNRU5UO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YXRlID0gYmFzZS5zY2hlbWUgPT0gJ2ZpbGUnID8gRklMRSA6IFJFTEFUSVZFO1xuICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgIGNhc2UgU1BFQ0lBTF9SRUxBVElWRV9PUl9BVVRIT1JJVFk6XG4gICAgICAgICAgaWYgKGNociA9PSAnLycgJiYgY29kZVBvaW50c1twb2ludGVyICsgMV0gPT0gJy8nKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IFNQRUNJQUxfQVVUSE9SSVRZX0lHTk9SRV9TTEFTSEVTO1xuICAgICAgICAgICAgcG9pbnRlcisrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZSA9IFJFTEFUSVZFO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBicmVhaztcblxuICAgICAgICBjYXNlIFBBVEhfT1JfQVVUSE9SSVRZOlxuICAgICAgICAgIGlmIChjaHIgPT0gJy8nKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEFVVEhPUklUWTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZSA9IFBBVEg7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUxBVElWRTpcbiAgICAgICAgICB1cmwuc2NoZW1lID0gYmFzZS5zY2hlbWU7XG4gICAgICAgICAgaWYgKGNociA9PSBFT0YpIHtcbiAgICAgICAgICAgIHVybC51c2VybmFtZSA9IGJhc2UudXNlcm5hbWU7XG4gICAgICAgICAgICB1cmwucGFzc3dvcmQgPSBiYXNlLnBhc3N3b3JkO1xuICAgICAgICAgICAgdXJsLmhvc3QgPSBiYXNlLmhvc3Q7XG4gICAgICAgICAgICB1cmwucG9ydCA9IGJhc2UucG9ydDtcbiAgICAgICAgICAgIHVybC5wYXRoID0gYXJyYXlTbGljZShiYXNlLnBhdGgpO1xuICAgICAgICAgICAgdXJsLnF1ZXJ5ID0gYmFzZS5xdWVyeTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNociA9PSAnLycgfHwgKGNociA9PSAnXFxcXCcgJiYgdXJsLmlzU3BlY2lhbCgpKSkge1xuICAgICAgICAgICAgc3RhdGUgPSBSRUxBVElWRV9TTEFTSDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNociA9PSAnPycpIHtcbiAgICAgICAgICAgIHVybC51c2VybmFtZSA9IGJhc2UudXNlcm5hbWU7XG4gICAgICAgICAgICB1cmwucGFzc3dvcmQgPSBiYXNlLnBhc3N3b3JkO1xuICAgICAgICAgICAgdXJsLmhvc3QgPSBiYXNlLmhvc3Q7XG4gICAgICAgICAgICB1cmwucG9ydCA9IGJhc2UucG9ydDtcbiAgICAgICAgICAgIHVybC5wYXRoID0gYXJyYXlTbGljZShiYXNlLnBhdGgpO1xuICAgICAgICAgICAgdXJsLnF1ZXJ5ID0gJyc7XG4gICAgICAgICAgICBzdGF0ZSA9IFFVRVJZO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2hyID09ICcjJykge1xuICAgICAgICAgICAgdXJsLnVzZXJuYW1lID0gYmFzZS51c2VybmFtZTtcbiAgICAgICAgICAgIHVybC5wYXNzd29yZCA9IGJhc2UucGFzc3dvcmQ7XG4gICAgICAgICAgICB1cmwuaG9zdCA9IGJhc2UuaG9zdDtcbiAgICAgICAgICAgIHVybC5wb3J0ID0gYmFzZS5wb3J0O1xuICAgICAgICAgICAgdXJsLnBhdGggPSBhcnJheVNsaWNlKGJhc2UucGF0aCk7XG4gICAgICAgICAgICB1cmwucXVlcnkgPSBiYXNlLnF1ZXJ5O1xuICAgICAgICAgICAgdXJsLmZyYWdtZW50ID0gJyc7XG4gICAgICAgICAgICBzdGF0ZSA9IEZSQUdNRU5UO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1cmwudXNlcm5hbWUgPSBiYXNlLnVzZXJuYW1lO1xuICAgICAgICAgICAgdXJsLnBhc3N3b3JkID0gYmFzZS5wYXNzd29yZDtcbiAgICAgICAgICAgIHVybC5ob3N0ID0gYmFzZS5ob3N0O1xuICAgICAgICAgICAgdXJsLnBvcnQgPSBiYXNlLnBvcnQ7XG4gICAgICAgICAgICB1cmwucGF0aCA9IGFycmF5U2xpY2UoYmFzZS5wYXRoKTtcbiAgICAgICAgICAgIHVybC5wYXRoLmxlbmd0aC0tO1xuICAgICAgICAgICAgc3RhdGUgPSBQQVRIO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBicmVhaztcblxuICAgICAgICBjYXNlIFJFTEFUSVZFX1NMQVNIOlxuICAgICAgICAgIGlmICh1cmwuaXNTcGVjaWFsKCkgJiYgKGNociA9PSAnLycgfHwgY2hyID09ICdcXFxcJykpIHtcbiAgICAgICAgICAgIHN0YXRlID0gU1BFQ0lBTF9BVVRIT1JJVFlfSUdOT1JFX1NMQVNIRVM7XG4gICAgICAgICAgfSBlbHNlIGlmIChjaHIgPT0gJy8nKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEFVVEhPUklUWTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXJsLnVzZXJuYW1lID0gYmFzZS51c2VybmFtZTtcbiAgICAgICAgICAgIHVybC5wYXNzd29yZCA9IGJhc2UucGFzc3dvcmQ7XG4gICAgICAgICAgICB1cmwuaG9zdCA9IGJhc2UuaG9zdDtcbiAgICAgICAgICAgIHVybC5wb3J0ID0gYmFzZS5wb3J0O1xuICAgICAgICAgICAgc3RhdGUgPSBQQVRIO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBicmVhaztcblxuICAgICAgICBjYXNlIFNQRUNJQUxfQVVUSE9SSVRZX1NMQVNIRVM6XG4gICAgICAgICAgc3RhdGUgPSBTUEVDSUFMX0FVVEhPUklUWV9JR05PUkVfU0xBU0hFUztcbiAgICAgICAgICBpZiAoY2hyICE9ICcvJyB8fCBjaGFyQXQkMyhidWZmZXIsIHBvaW50ZXIgKyAxKSAhPSAnLycpIGNvbnRpbnVlO1xuICAgICAgICAgIHBvaW50ZXIrKztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFNQRUNJQUxfQVVUSE9SSVRZX0lHTk9SRV9TTEFTSEVTOlxuICAgICAgICAgIGlmIChjaHIgIT0gJy8nICYmIGNociAhPSAnXFxcXCcpIHtcbiAgICAgICAgICAgIHN0YXRlID0gQVVUSE9SSVRZO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBicmVhaztcblxuICAgICAgICBjYXNlIEFVVEhPUklUWTpcbiAgICAgICAgICBpZiAoY2hyID09ICdAJykge1xuICAgICAgICAgICAgaWYgKHNlZW5BdCkgYnVmZmVyID0gJyU0MCcgKyBidWZmZXI7XG4gICAgICAgICAgICBzZWVuQXQgPSB0cnVlO1xuICAgICAgICAgICAgYnVmZmVyQ29kZVBvaW50cyA9IGFycmF5RnJvbShidWZmZXIpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXJDb2RlUG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBjb2RlUG9pbnQgPSBidWZmZXJDb2RlUG9pbnRzW2ldO1xuICAgICAgICAgICAgICBpZiAoY29kZVBvaW50ID09ICc6JyAmJiAhc2VlblBhc3N3b3JkVG9rZW4pIHtcbiAgICAgICAgICAgICAgICBzZWVuUGFzc3dvcmRUb2tlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIGVuY29kZWRDb2RlUG9pbnRzID0gcGVyY2VudEVuY29kZShjb2RlUG9pbnQsIHVzZXJpbmZvUGVyY2VudEVuY29kZVNldCk7XG4gICAgICAgICAgICAgIGlmIChzZWVuUGFzc3dvcmRUb2tlbikgdXJsLnBhc3N3b3JkICs9IGVuY29kZWRDb2RlUG9pbnRzO1xuICAgICAgICAgICAgICBlbHNlIHVybC51c2VybmFtZSArPSBlbmNvZGVkQ29kZVBvaW50cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlciA9ICcnO1xuICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICBjaHIgPT0gRU9GIHx8IGNociA9PSAnLycgfHwgY2hyID09ICc/JyB8fCBjaHIgPT0gJyMnIHx8XG4gICAgICAgICAgICAoY2hyID09ICdcXFxcJyAmJiB1cmwuaXNTcGVjaWFsKCkpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAoc2VlbkF0ICYmIGJ1ZmZlciA9PSAnJykgcmV0dXJuIElOVkFMSURfQVVUSE9SSVRZO1xuICAgICAgICAgICAgcG9pbnRlciAtPSBhcnJheUZyb20oYnVmZmVyKS5sZW5ndGggKyAxO1xuICAgICAgICAgICAgYnVmZmVyID0gJyc7XG4gICAgICAgICAgICBzdGF0ZSA9IEhPU1Q7XG4gICAgICAgICAgfSBlbHNlIGJ1ZmZlciArPSBjaHI7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBIT1NUOlxuICAgICAgICBjYXNlIEhPU1ROQU1FOlxuICAgICAgICAgIGlmIChzdGF0ZU92ZXJyaWRlICYmIHVybC5zY2hlbWUgPT0gJ2ZpbGUnKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEZJTEVfSE9TVDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2hyID09ICc6JyAmJiAhc2VlbkJyYWNrZXQpIHtcbiAgICAgICAgICAgIGlmIChidWZmZXIgPT0gJycpIHJldHVybiBJTlZBTElEX0hPU1Q7XG4gICAgICAgICAgICBmYWlsdXJlID0gdXJsLnBhcnNlSG9zdChidWZmZXIpO1xuICAgICAgICAgICAgaWYgKGZhaWx1cmUpIHJldHVybiBmYWlsdXJlO1xuICAgICAgICAgICAgYnVmZmVyID0gJyc7XG4gICAgICAgICAgICBzdGF0ZSA9IFBPUlQ7XG4gICAgICAgICAgICBpZiAoc3RhdGVPdmVycmlkZSA9PSBIT1NUTkFNRSkgcmV0dXJuO1xuICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICBjaHIgPT0gRU9GIHx8IGNociA9PSAnLycgfHwgY2hyID09ICc/JyB8fCBjaHIgPT0gJyMnIHx8XG4gICAgICAgICAgICAoY2hyID09ICdcXFxcJyAmJiB1cmwuaXNTcGVjaWFsKCkpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAodXJsLmlzU3BlY2lhbCgpICYmIGJ1ZmZlciA9PSAnJykgcmV0dXJuIElOVkFMSURfSE9TVDtcbiAgICAgICAgICAgIGlmIChzdGF0ZU92ZXJyaWRlICYmIGJ1ZmZlciA9PSAnJyAmJiAodXJsLmluY2x1ZGVzQ3JlZGVudGlhbHMoKSB8fCB1cmwucG9ydCAhPT0gbnVsbCkpIHJldHVybjtcbiAgICAgICAgICAgIGZhaWx1cmUgPSB1cmwucGFyc2VIb3N0KGJ1ZmZlcik7XG4gICAgICAgICAgICBpZiAoZmFpbHVyZSkgcmV0dXJuIGZhaWx1cmU7XG4gICAgICAgICAgICBidWZmZXIgPSAnJztcbiAgICAgICAgICAgIHN0YXRlID0gUEFUSF9TVEFSVDtcbiAgICAgICAgICAgIGlmIChzdGF0ZU92ZXJyaWRlKSByZXR1cm47XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNociA9PSAnWycpIHNlZW5CcmFja2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGNociA9PSAnXScpIHNlZW5CcmFja2V0ID0gZmFsc2U7XG4gICAgICAgICAgICBidWZmZXIgKz0gY2hyO1xuICAgICAgICAgIH0gYnJlYWs7XG5cbiAgICAgICAgY2FzZSBQT1JUOlxuICAgICAgICAgIGlmIChleGVjJDEoRElHSVQsIGNocikpIHtcbiAgICAgICAgICAgIGJ1ZmZlciArPSBjaHI7XG4gICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgIGNociA9PSBFT0YgfHwgY2hyID09ICcvJyB8fCBjaHIgPT0gJz8nIHx8IGNociA9PSAnIycgfHxcbiAgICAgICAgICAgIChjaHIgPT0gJ1xcXFwnICYmIHVybC5pc1NwZWNpYWwoKSkgfHxcbiAgICAgICAgICAgIHN0YXRlT3ZlcnJpZGVcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGlmIChidWZmZXIgIT0gJycpIHtcbiAgICAgICAgICAgICAgdmFyIHBvcnQgPSBwYXJzZUludChidWZmZXIsIDEwKTtcbiAgICAgICAgICAgICAgaWYgKHBvcnQgPiAweEZGRkYpIHJldHVybiBJTlZBTElEX1BPUlQ7XG4gICAgICAgICAgICAgIHVybC5wb3J0ID0gKHVybC5pc1NwZWNpYWwoKSAmJiBwb3J0ID09PSBzcGVjaWFsU2NoZW1lc1t1cmwuc2NoZW1lXSkgPyBudWxsIDogcG9ydDtcbiAgICAgICAgICAgICAgYnVmZmVyID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGVPdmVycmlkZSkgcmV0dXJuO1xuICAgICAgICAgICAgc3RhdGUgPSBQQVRIX1NUQVJUO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBlbHNlIHJldHVybiBJTlZBTElEX1BPUlQ7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBGSUxFOlxuICAgICAgICAgIHVybC5zY2hlbWUgPSAnZmlsZSc7XG4gICAgICAgICAgaWYgKGNociA9PSAnLycgfHwgY2hyID09ICdcXFxcJykgc3RhdGUgPSBGSUxFX1NMQVNIO1xuICAgICAgICAgIGVsc2UgaWYgKGJhc2UgJiYgYmFzZS5zY2hlbWUgPT0gJ2ZpbGUnKSB7XG4gICAgICAgICAgICBpZiAoY2hyID09IEVPRikge1xuICAgICAgICAgICAgICB1cmwuaG9zdCA9IGJhc2UuaG9zdDtcbiAgICAgICAgICAgICAgdXJsLnBhdGggPSBhcnJheVNsaWNlKGJhc2UucGF0aCk7XG4gICAgICAgICAgICAgIHVybC5xdWVyeSA9IGJhc2UucXVlcnk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNociA9PSAnPycpIHtcbiAgICAgICAgICAgICAgdXJsLmhvc3QgPSBiYXNlLmhvc3Q7XG4gICAgICAgICAgICAgIHVybC5wYXRoID0gYXJyYXlTbGljZShiYXNlLnBhdGgpO1xuICAgICAgICAgICAgICB1cmwucXVlcnkgPSAnJztcbiAgICAgICAgICAgICAgc3RhdGUgPSBRVUVSWTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hyID09ICcjJykge1xuICAgICAgICAgICAgICB1cmwuaG9zdCA9IGJhc2UuaG9zdDtcbiAgICAgICAgICAgICAgdXJsLnBhdGggPSBhcnJheVNsaWNlKGJhc2UucGF0aCk7XG4gICAgICAgICAgICAgIHVybC5xdWVyeSA9IGJhc2UucXVlcnk7XG4gICAgICAgICAgICAgIHVybC5mcmFnbWVudCA9ICcnO1xuICAgICAgICAgICAgICBzdGF0ZSA9IEZSQUdNRU5UO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKCFzdGFydHNXaXRoV2luZG93c0RyaXZlTGV0dGVyKGpvaW4oYXJyYXlTbGljZShjb2RlUG9pbnRzLCBwb2ludGVyKSwgJycpKSkge1xuICAgICAgICAgICAgICAgIHVybC5ob3N0ID0gYmFzZS5ob3N0O1xuICAgICAgICAgICAgICAgIHVybC5wYXRoID0gYXJyYXlTbGljZShiYXNlLnBhdGgpO1xuICAgICAgICAgICAgICAgIHVybC5zaG9ydGVuUGF0aCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN0YXRlID0gUEFUSDtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlID0gUEFUSDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gYnJlYWs7XG5cbiAgICAgICAgY2FzZSBGSUxFX1NMQVNIOlxuICAgICAgICAgIGlmIChjaHIgPT0gJy8nIHx8IGNociA9PSAnXFxcXCcpIHtcbiAgICAgICAgICAgIHN0YXRlID0gRklMRV9IT1NUO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChiYXNlICYmIGJhc2Uuc2NoZW1lID09ICdmaWxlJyAmJiAhc3RhcnRzV2l0aFdpbmRvd3NEcml2ZUxldHRlcihqb2luKGFycmF5U2xpY2UoY29kZVBvaW50cywgcG9pbnRlciksICcnKSkpIHtcbiAgICAgICAgICAgIGlmIChpc1dpbmRvd3NEcml2ZUxldHRlcihiYXNlLnBhdGhbMF0sIHRydWUpKSBwdXNoJDEodXJsLnBhdGgsIGJhc2UucGF0aFswXSk7XG4gICAgICAgICAgICBlbHNlIHVybC5ob3N0ID0gYmFzZS5ob3N0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdGF0ZSA9IFBBVEg7XG4gICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgY2FzZSBGSUxFX0hPU1Q6XG4gICAgICAgICAgaWYgKGNociA9PSBFT0YgfHwgY2hyID09ICcvJyB8fCBjaHIgPT0gJ1xcXFwnIHx8IGNociA9PSAnPycgfHwgY2hyID09ICcjJykge1xuICAgICAgICAgICAgaWYgKCFzdGF0ZU92ZXJyaWRlICYmIGlzV2luZG93c0RyaXZlTGV0dGVyKGJ1ZmZlcikpIHtcbiAgICAgICAgICAgICAgc3RhdGUgPSBQQVRIO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChidWZmZXIgPT0gJycpIHtcbiAgICAgICAgICAgICAgdXJsLmhvc3QgPSAnJztcbiAgICAgICAgICAgICAgaWYgKHN0YXRlT3ZlcnJpZGUpIHJldHVybjtcbiAgICAgICAgICAgICAgc3RhdGUgPSBQQVRIX1NUQVJUO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZmFpbHVyZSA9IHVybC5wYXJzZUhvc3QoYnVmZmVyKTtcbiAgICAgICAgICAgICAgaWYgKGZhaWx1cmUpIHJldHVybiBmYWlsdXJlO1xuICAgICAgICAgICAgICBpZiAodXJsLmhvc3QgPT0gJ2xvY2FsaG9zdCcpIHVybC5ob3N0ID0gJyc7XG4gICAgICAgICAgICAgIGlmIChzdGF0ZU92ZXJyaWRlKSByZXR1cm47XG4gICAgICAgICAgICAgIGJ1ZmZlciA9ICcnO1xuICAgICAgICAgICAgICBzdGF0ZSA9IFBBVEhfU1RBUlQ7XG4gICAgICAgICAgICB9IGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSBidWZmZXIgKz0gY2hyO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUEFUSF9TVEFSVDpcbiAgICAgICAgICBpZiAodXJsLmlzU3BlY2lhbCgpKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IFBBVEg7XG4gICAgICAgICAgICBpZiAoY2hyICE9ICcvJyAmJiBjaHIgIT0gJ1xcXFwnKSBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFzdGF0ZU92ZXJyaWRlICYmIGNociA9PSAnPycpIHtcbiAgICAgICAgICAgIHVybC5xdWVyeSA9ICcnO1xuICAgICAgICAgICAgc3RhdGUgPSBRVUVSWTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFzdGF0ZU92ZXJyaWRlICYmIGNociA9PSAnIycpIHtcbiAgICAgICAgICAgIHVybC5mcmFnbWVudCA9ICcnO1xuICAgICAgICAgICAgc3RhdGUgPSBGUkFHTUVOVDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNociAhPSBFT0YpIHtcbiAgICAgICAgICAgIHN0YXRlID0gUEFUSDtcbiAgICAgICAgICAgIGlmIChjaHIgIT0gJy8nKSBjb250aW51ZTtcbiAgICAgICAgICB9IGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUEFUSDpcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBjaHIgPT0gRU9GIHx8IGNociA9PSAnLycgfHxcbiAgICAgICAgICAgIChjaHIgPT0gJ1xcXFwnICYmIHVybC5pc1NwZWNpYWwoKSkgfHxcbiAgICAgICAgICAgICghc3RhdGVPdmVycmlkZSAmJiAoY2hyID09ICc/JyB8fCBjaHIgPT0gJyMnKSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGlmIChpc0RvdWJsZURvdChidWZmZXIpKSB7XG4gICAgICAgICAgICAgIHVybC5zaG9ydGVuUGF0aCgpO1xuICAgICAgICAgICAgICBpZiAoY2hyICE9ICcvJyAmJiAhKGNociA9PSAnXFxcXCcgJiYgdXJsLmlzU3BlY2lhbCgpKSkge1xuICAgICAgICAgICAgICAgIHB1c2gkMSh1cmwucGF0aCwgJycpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzU2luZ2xlRG90KGJ1ZmZlcikpIHtcbiAgICAgICAgICAgICAgaWYgKGNociAhPSAnLycgJiYgIShjaHIgPT0gJ1xcXFwnICYmIHVybC5pc1NwZWNpYWwoKSkpIHtcbiAgICAgICAgICAgICAgICBwdXNoJDEodXJsLnBhdGgsICcnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHVybC5zY2hlbWUgPT0gJ2ZpbGUnICYmICF1cmwucGF0aC5sZW5ndGggJiYgaXNXaW5kb3dzRHJpdmVMZXR0ZXIoYnVmZmVyKSkge1xuICAgICAgICAgICAgICAgIGlmICh1cmwuaG9zdCkgdXJsLmhvc3QgPSAnJztcbiAgICAgICAgICAgICAgICBidWZmZXIgPSBjaGFyQXQkMyhidWZmZXIsIDApICsgJzonOyAvLyBub3JtYWxpemUgd2luZG93cyBkcml2ZSBsZXR0ZXJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwdXNoJDEodXJsLnBhdGgsIGJ1ZmZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXIgPSAnJztcbiAgICAgICAgICAgIGlmICh1cmwuc2NoZW1lID09ICdmaWxlJyAmJiAoY2hyID09IEVPRiB8fCBjaHIgPT0gJz8nIHx8IGNociA9PSAnIycpKSB7XG4gICAgICAgICAgICAgIHdoaWxlICh1cmwucGF0aC5sZW5ndGggPiAxICYmIHVybC5wYXRoWzBdID09PSAnJykge1xuICAgICAgICAgICAgICAgIHNoaWZ0KHVybC5wYXRoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNociA9PSAnPycpIHtcbiAgICAgICAgICAgICAgdXJsLnF1ZXJ5ID0gJyc7XG4gICAgICAgICAgICAgIHN0YXRlID0gUVVFUlk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNociA9PSAnIycpIHtcbiAgICAgICAgICAgICAgdXJsLmZyYWdtZW50ID0gJyc7XG4gICAgICAgICAgICAgIHN0YXRlID0gRlJBR01FTlQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ1ZmZlciArPSBwZXJjZW50RW5jb2RlKGNociwgcGF0aFBlcmNlbnRFbmNvZGVTZXQpO1xuICAgICAgICAgIH0gYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDQU5OT1RfQkVfQV9CQVNFX1VSTF9QQVRIOlxuICAgICAgICAgIGlmIChjaHIgPT0gJz8nKSB7XG4gICAgICAgICAgICB1cmwucXVlcnkgPSAnJztcbiAgICAgICAgICAgIHN0YXRlID0gUVVFUlk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjaHIgPT0gJyMnKSB7XG4gICAgICAgICAgICB1cmwuZnJhZ21lbnQgPSAnJztcbiAgICAgICAgICAgIHN0YXRlID0gRlJBR01FTlQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChjaHIgIT0gRU9GKSB7XG4gICAgICAgICAgICB1cmwucGF0aFswXSArPSBwZXJjZW50RW5jb2RlKGNociwgQzBDb250cm9sUGVyY2VudEVuY29kZVNldCk7XG4gICAgICAgICAgfSBicmVhaztcblxuICAgICAgICBjYXNlIFFVRVJZOlxuICAgICAgICAgIGlmICghc3RhdGVPdmVycmlkZSAmJiBjaHIgPT0gJyMnKSB7XG4gICAgICAgICAgICB1cmwuZnJhZ21lbnQgPSAnJztcbiAgICAgICAgICAgIHN0YXRlID0gRlJBR01FTlQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChjaHIgIT0gRU9GKSB7XG4gICAgICAgICAgICBpZiAoY2hyID09IFwiJ1wiICYmIHVybC5pc1NwZWNpYWwoKSkgdXJsLnF1ZXJ5ICs9ICclMjcnO1xuICAgICAgICAgICAgZWxzZSBpZiAoY2hyID09ICcjJykgdXJsLnF1ZXJ5ICs9ICclMjMnO1xuICAgICAgICAgICAgZWxzZSB1cmwucXVlcnkgKz0gcGVyY2VudEVuY29kZShjaHIsIEMwQ29udHJvbFBlcmNlbnRFbmNvZGVTZXQpO1xuICAgICAgICAgIH0gYnJlYWs7XG5cbiAgICAgICAgY2FzZSBGUkFHTUVOVDpcbiAgICAgICAgICBpZiAoY2hyICE9IEVPRikgdXJsLmZyYWdtZW50ICs9IHBlcmNlbnRFbmNvZGUoY2hyLCBmcmFnbWVudFBlcmNlbnRFbmNvZGVTZXQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBwb2ludGVyKys7XG4gICAgfVxuICB9LFxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2hvc3QtcGFyc2luZ1xuICBwYXJzZUhvc3Q6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIHZhciByZXN1bHQsIGNvZGVQb2ludHMsIGluZGV4O1xuICAgIGlmIChjaGFyQXQkMyhpbnB1dCwgMCkgPT0gJ1snKSB7XG4gICAgICBpZiAoY2hhckF0JDMoaW5wdXQsIGlucHV0Lmxlbmd0aCAtIDEpICE9ICddJykgcmV0dXJuIElOVkFMSURfSE9TVDtcbiAgICAgIHJlc3VsdCA9IHBhcnNlSVB2NihzdHJpbmdTbGljZSQzKGlucHV0LCAxLCAtMSkpO1xuICAgICAgaWYgKCFyZXN1bHQpIHJldHVybiBJTlZBTElEX0hPU1Q7XG4gICAgICB0aGlzLmhvc3QgPSByZXN1bHQ7XG4gICAgLy8gb3BhcXVlIGhvc3RcbiAgICB9IGVsc2UgaWYgKCF0aGlzLmlzU3BlY2lhbCgpKSB7XG4gICAgICBpZiAoZXhlYyQxKEZPUkJJRERFTl9IT1NUX0NPREVfUE9JTlRfRVhDTFVESU5HX1BFUkNFTlQsIGlucHV0KSkgcmV0dXJuIElOVkFMSURfSE9TVDtcbiAgICAgIHJlc3VsdCA9ICcnO1xuICAgICAgY29kZVBvaW50cyA9IGFycmF5RnJvbShpbnB1dCk7XG4gICAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBjb2RlUG9pbnRzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICByZXN1bHQgKz0gcGVyY2VudEVuY29kZShjb2RlUG9pbnRzW2luZGV4XSwgQzBDb250cm9sUGVyY2VudEVuY29kZVNldCk7XG4gICAgICB9XG4gICAgICB0aGlzLmhvc3QgPSByZXN1bHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlucHV0ID0gdG9BU0NJSShpbnB1dCk7XG4gICAgICBpZiAoZXhlYyQxKEZPUkJJRERFTl9IT1NUX0NPREVfUE9JTlQsIGlucHV0KSkgcmV0dXJuIElOVkFMSURfSE9TVDtcbiAgICAgIHJlc3VsdCA9IHBhcnNlSVB2NChpbnB1dCk7XG4gICAgICBpZiAocmVzdWx0ID09PSBudWxsKSByZXR1cm4gSU5WQUxJRF9IT1NUO1xuICAgICAgdGhpcy5ob3N0ID0gcmVzdWx0O1xuICAgIH1cbiAgfSxcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNjYW5ub3QtaGF2ZS1hLXVzZXJuYW1lLXBhc3N3b3JkLXBvcnRcbiAgY2Fubm90SGF2ZVVzZXJuYW1lUGFzc3dvcmRQb3J0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICF0aGlzLmhvc3QgfHwgdGhpcy5jYW5ub3RCZUFCYXNlVVJMIHx8IHRoaXMuc2NoZW1lID09ICdmaWxlJztcbiAgfSxcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNpbmNsdWRlLWNyZWRlbnRpYWxzXG4gIGluY2x1ZGVzQ3JlZGVudGlhbHM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy51c2VybmFtZSAhPSAnJyB8fCB0aGlzLnBhc3N3b3JkICE9ICcnO1xuICB9LFxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2lzLXNwZWNpYWxcbiAgaXNTcGVjaWFsOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGhhc093bihzcGVjaWFsU2NoZW1lcywgdGhpcy5zY2hlbWUpO1xuICB9LFxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3Nob3J0ZW4tYS11cmxzLXBhdGhcbiAgc2hvcnRlblBhdGg6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGF0aCA9IHRoaXMucGF0aDtcbiAgICB2YXIgcGF0aFNpemUgPSBwYXRoLmxlbmd0aDtcbiAgICBpZiAocGF0aFNpemUgJiYgKHRoaXMuc2NoZW1lICE9ICdmaWxlJyB8fCBwYXRoU2l6ZSAhPSAxIHx8ICFpc1dpbmRvd3NEcml2ZUxldHRlcihwYXRoWzBdLCB0cnVlKSkpIHtcbiAgICAgIHBhdGgubGVuZ3RoLS07XG4gICAgfVxuICB9LFxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtdXJsLXNlcmlhbGl6ZXJcbiAgc2VyaWFsaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHVybCA9IHRoaXM7XG4gICAgdmFyIHNjaGVtZSA9IHVybC5zY2hlbWU7XG4gICAgdmFyIHVzZXJuYW1lID0gdXJsLnVzZXJuYW1lO1xuICAgIHZhciBwYXNzd29yZCA9IHVybC5wYXNzd29yZDtcbiAgICB2YXIgaG9zdCA9IHVybC5ob3N0O1xuICAgIHZhciBwb3J0ID0gdXJsLnBvcnQ7XG4gICAgdmFyIHBhdGggPSB1cmwucGF0aDtcbiAgICB2YXIgcXVlcnkgPSB1cmwucXVlcnk7XG4gICAgdmFyIGZyYWdtZW50ID0gdXJsLmZyYWdtZW50O1xuICAgIHZhciBvdXRwdXQgPSBzY2hlbWUgKyAnOic7XG4gICAgaWYgKGhvc3QgIT09IG51bGwpIHtcbiAgICAgIG91dHB1dCArPSAnLy8nO1xuICAgICAgaWYgKHVybC5pbmNsdWRlc0NyZWRlbnRpYWxzKCkpIHtcbiAgICAgICAgb3V0cHV0ICs9IHVzZXJuYW1lICsgKHBhc3N3b3JkID8gJzonICsgcGFzc3dvcmQgOiAnJykgKyAnQCc7XG4gICAgICB9XG4gICAgICBvdXRwdXQgKz0gc2VyaWFsaXplSG9zdChob3N0KTtcbiAgICAgIGlmIChwb3J0ICE9PSBudWxsKSBvdXRwdXQgKz0gJzonICsgcG9ydDtcbiAgICB9IGVsc2UgaWYgKHNjaGVtZSA9PSAnZmlsZScpIG91dHB1dCArPSAnLy8nO1xuICAgIG91dHB1dCArPSB1cmwuY2Fubm90QmVBQmFzZVVSTCA/IHBhdGhbMF0gOiBwYXRoLmxlbmd0aCA/ICcvJyArIGpvaW4ocGF0aCwgJy8nKSA6ICcnO1xuICAgIGlmIChxdWVyeSAhPT0gbnVsbCkgb3V0cHV0ICs9ICc/JyArIHF1ZXJ5O1xuICAgIGlmIChmcmFnbWVudCAhPT0gbnVsbCkgb3V0cHV0ICs9ICcjJyArIGZyYWdtZW50O1xuICAgIHJldHVybiBvdXRwdXQ7XG4gIH0sXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC1ocmVmXG4gIHNldEhyZWY6IGZ1bmN0aW9uIChocmVmKSB7XG4gICAgdmFyIGZhaWx1cmUgPSB0aGlzLnBhcnNlKGhyZWYpO1xuICAgIGlmIChmYWlsdXJlKSB0aHJvdyBUeXBlRXJyb3IkMShmYWlsdXJlKTtcbiAgICB0aGlzLnNlYXJjaFBhcmFtcy51cGRhdGUoKTtcbiAgfSxcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsLW9yaWdpblxuICBnZXRPcmlnaW46IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2NoZW1lID0gdGhpcy5zY2hlbWU7XG4gICAgdmFyIHBvcnQgPSB0aGlzLnBvcnQ7XG4gICAgaWYgKHNjaGVtZSA9PSAnYmxvYicpIHRyeSB7XG4gICAgICByZXR1cm4gbmV3IFVSTENvbnN0cnVjdG9yKHNjaGVtZS5wYXRoWzBdKS5vcmlnaW47XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgfVxuICAgIGlmIChzY2hlbWUgPT0gJ2ZpbGUnIHx8ICF0aGlzLmlzU3BlY2lhbCgpKSByZXR1cm4gJ251bGwnO1xuICAgIHJldHVybiBzY2hlbWUgKyAnOi8vJyArIHNlcmlhbGl6ZUhvc3QodGhpcy5ob3N0KSArIChwb3J0ICE9PSBudWxsID8gJzonICsgcG9ydCA6ICcnKTtcbiAgfSxcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsLXByb3RvY29sXG4gIGdldFByb3RvY29sOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NoZW1lICsgJzonO1xuICB9LFxuICBzZXRQcm90b2NvbDogZnVuY3Rpb24gKHByb3RvY29sKSB7XG4gICAgdGhpcy5wYXJzZSgkdG9TdHJpbmcocHJvdG9jb2wpICsgJzonLCBTQ0hFTUVfU1RBUlQpO1xuICB9LFxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmwtdXNlcm5hbWVcbiAgZ2V0VXNlcm5hbWU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy51c2VybmFtZTtcbiAgfSxcbiAgc2V0VXNlcm5hbWU6IGZ1bmN0aW9uICh1c2VybmFtZSkge1xuICAgIHZhciBjb2RlUG9pbnRzID0gYXJyYXlGcm9tKCR0b1N0cmluZyh1c2VybmFtZSkpO1xuICAgIGlmICh0aGlzLmNhbm5vdEhhdmVVc2VybmFtZVBhc3N3b3JkUG9ydCgpKSByZXR1cm47XG4gICAgdGhpcy51c2VybmFtZSA9ICcnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29kZVBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy51c2VybmFtZSArPSBwZXJjZW50RW5jb2RlKGNvZGVQb2ludHNbaV0sIHVzZXJpbmZvUGVyY2VudEVuY29kZVNldCk7XG4gICAgfVxuICB9LFxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmwtcGFzc3dvcmRcbiAgZ2V0UGFzc3dvcmQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXNzd29yZDtcbiAgfSxcbiAgc2V0UGFzc3dvcmQ6IGZ1bmN0aW9uIChwYXNzd29yZCkge1xuICAgIHZhciBjb2RlUG9pbnRzID0gYXJyYXlGcm9tKCR0b1N0cmluZyhwYXNzd29yZCkpO1xuICAgIGlmICh0aGlzLmNhbm5vdEhhdmVVc2VybmFtZVBhc3N3b3JkUG9ydCgpKSByZXR1cm47XG4gICAgdGhpcy5wYXNzd29yZCA9ICcnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29kZVBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5wYXNzd29yZCArPSBwZXJjZW50RW5jb2RlKGNvZGVQb2ludHNbaV0sIHVzZXJpbmZvUGVyY2VudEVuY29kZVNldCk7XG4gICAgfVxuICB9LFxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmwtaG9zdFxuICBnZXRIb3N0OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhvc3QgPSB0aGlzLmhvc3Q7XG4gICAgdmFyIHBvcnQgPSB0aGlzLnBvcnQ7XG4gICAgcmV0dXJuIGhvc3QgPT09IG51bGwgPyAnJ1xuICAgICAgOiBwb3J0ID09PSBudWxsID8gc2VyaWFsaXplSG9zdChob3N0KVxuICAgICAgOiBzZXJpYWxpemVIb3N0KGhvc3QpICsgJzonICsgcG9ydDtcbiAgfSxcbiAgc2V0SG9zdDogZnVuY3Rpb24gKGhvc3QpIHtcbiAgICBpZiAodGhpcy5jYW5ub3RCZUFCYXNlVVJMKSByZXR1cm47XG4gICAgdGhpcy5wYXJzZShob3N0LCBIT1NUKTtcbiAgfSxcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsLWhvc3RuYW1lXG4gIGdldEhvc3RuYW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhvc3QgPSB0aGlzLmhvc3Q7XG4gICAgcmV0dXJuIGhvc3QgPT09IG51bGwgPyAnJyA6IHNlcmlhbGl6ZUhvc3QoaG9zdCk7XG4gIH0sXG4gIHNldEhvc3RuYW1lOiBmdW5jdGlvbiAoaG9zdG5hbWUpIHtcbiAgICBpZiAodGhpcy5jYW5ub3RCZUFCYXNlVVJMKSByZXR1cm47XG4gICAgdGhpcy5wYXJzZShob3N0bmFtZSwgSE9TVE5BTUUpO1xuICB9LFxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmwtcG9ydFxuICBnZXRQb3J0OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBvcnQgPSB0aGlzLnBvcnQ7XG4gICAgcmV0dXJuIHBvcnQgPT09IG51bGwgPyAnJyA6ICR0b1N0cmluZyhwb3J0KTtcbiAgfSxcbiAgc2V0UG9ydDogZnVuY3Rpb24gKHBvcnQpIHtcbiAgICBpZiAodGhpcy5jYW5ub3RIYXZlVXNlcm5hbWVQYXNzd29yZFBvcnQoKSkgcmV0dXJuO1xuICAgIHBvcnQgPSAkdG9TdHJpbmcocG9ydCk7XG4gICAgaWYgKHBvcnQgPT0gJycpIHRoaXMucG9ydCA9IG51bGw7XG4gICAgZWxzZSB0aGlzLnBhcnNlKHBvcnQsIFBPUlQpO1xuICB9LFxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmwtcGF0aG5hbWVcbiAgZ2V0UGF0aG5hbWU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGF0aCA9IHRoaXMucGF0aDtcbiAgICByZXR1cm4gdGhpcy5jYW5ub3RCZUFCYXNlVVJMID8gcGF0aFswXSA6IHBhdGgubGVuZ3RoID8gJy8nICsgam9pbihwYXRoLCAnLycpIDogJyc7XG4gIH0sXG4gIHNldFBhdGhuYW1lOiBmdW5jdGlvbiAocGF0aG5hbWUpIHtcbiAgICBpZiAodGhpcy5jYW5ub3RCZUFCYXNlVVJMKSByZXR1cm47XG4gICAgdGhpcy5wYXRoID0gW107XG4gICAgdGhpcy5wYXJzZShwYXRobmFtZSwgUEFUSF9TVEFSVCk7XG4gIH0sXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC1zZWFyY2hcbiAgZ2V0U2VhcmNoOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHF1ZXJ5ID0gdGhpcy5xdWVyeTtcbiAgICByZXR1cm4gcXVlcnkgPyAnPycgKyBxdWVyeSA6ICcnO1xuICB9LFxuICBzZXRTZWFyY2g6IGZ1bmN0aW9uIChzZWFyY2gpIHtcbiAgICBzZWFyY2ggPSAkdG9TdHJpbmcoc2VhcmNoKTtcbiAgICBpZiAoc2VhcmNoID09ICcnKSB7XG4gICAgICB0aGlzLnF1ZXJ5ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCc/JyA9PSBjaGFyQXQkMyhzZWFyY2gsIDApKSBzZWFyY2ggPSBzdHJpbmdTbGljZSQzKHNlYXJjaCwgMSk7XG4gICAgICB0aGlzLnF1ZXJ5ID0gJyc7XG4gICAgICB0aGlzLnBhcnNlKHNlYXJjaCwgUVVFUlkpO1xuICAgIH1cbiAgICB0aGlzLnNlYXJjaFBhcmFtcy51cGRhdGUoKTtcbiAgfSxcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsLXNlYXJjaHBhcmFtc1xuICBnZXRTZWFyY2hQYXJhbXM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5zZWFyY2hQYXJhbXMuZmFjYWRlO1xuICB9LFxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmwtaGFzaFxuICBnZXRIYXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZyYWdtZW50ID0gdGhpcy5mcmFnbWVudDtcbiAgICByZXR1cm4gZnJhZ21lbnQgPyAnIycgKyBmcmFnbWVudCA6ICcnO1xuICB9LFxuICBzZXRIYXNoOiBmdW5jdGlvbiAoaGFzaCkge1xuICAgIGhhc2ggPSAkdG9TdHJpbmcoaGFzaCk7XG4gICAgaWYgKGhhc2ggPT0gJycpIHtcbiAgICAgIHRoaXMuZnJhZ21lbnQgPSBudWxsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoJyMnID09IGNoYXJBdCQzKGhhc2gsIDApKSBoYXNoID0gc3RyaW5nU2xpY2UkMyhoYXNoLCAxKTtcbiAgICB0aGlzLmZyYWdtZW50ID0gJyc7XG4gICAgdGhpcy5wYXJzZShoYXNoLCBGUkFHTUVOVCk7XG4gIH0sXG4gIHVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucXVlcnkgPSB0aGlzLnNlYXJjaFBhcmFtcy5zZXJpYWxpemUoKSB8fCBudWxsO1xuICB9XG59O1xuXG4vLyBgVVJMYCBjb25zdHJ1Y3RvclxuLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN1cmwtY2xhc3NcbnZhciBVUkxDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIFVSTCh1cmwgLyogLCBiYXNlICovKSB7XG4gIHZhciB0aGF0ID0gYW5JbnN0YW5jZSh0aGlzLCBVUkxQcm90b3R5cGUpO1xuICB2YXIgYmFzZSA9IHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoKGFyZ3VtZW50cy5sZW5ndGgsIDEpID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgdmFyIHN0YXRlID0gc2V0SW50ZXJuYWxTdGF0ZSh0aGF0LCBuZXcgVVJMU3RhdGUodXJsLCBmYWxzZSwgYmFzZSkpO1xuICBpZiAoIURFU0NSSVBUT1JTKSB7XG4gICAgdGhhdC5ocmVmID0gc3RhdGUuc2VyaWFsaXplKCk7XG4gICAgdGhhdC5vcmlnaW4gPSBzdGF0ZS5nZXRPcmlnaW4oKTtcbiAgICB0aGF0LnByb3RvY29sID0gc3RhdGUuZ2V0UHJvdG9jb2woKTtcbiAgICB0aGF0LnVzZXJuYW1lID0gc3RhdGUuZ2V0VXNlcm5hbWUoKTtcbiAgICB0aGF0LnBhc3N3b3JkID0gc3RhdGUuZ2V0UGFzc3dvcmQoKTtcbiAgICB0aGF0Lmhvc3QgPSBzdGF0ZS5nZXRIb3N0KCk7XG4gICAgdGhhdC5ob3N0bmFtZSA9IHN0YXRlLmdldEhvc3RuYW1lKCk7XG4gICAgdGhhdC5wb3J0ID0gc3RhdGUuZ2V0UG9ydCgpO1xuICAgIHRoYXQucGF0aG5hbWUgPSBzdGF0ZS5nZXRQYXRobmFtZSgpO1xuICAgIHRoYXQuc2VhcmNoID0gc3RhdGUuZ2V0U2VhcmNoKCk7XG4gICAgdGhhdC5zZWFyY2hQYXJhbXMgPSBzdGF0ZS5nZXRTZWFyY2hQYXJhbXMoKTtcbiAgICB0aGF0Lmhhc2ggPSBzdGF0ZS5nZXRIYXNoKCk7XG4gIH1cbn07XG5cbnZhciBVUkxQcm90b3R5cGUgPSBVUkxDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG5cbnZhciBhY2Nlc3NvckRlc2NyaXB0b3IgPSBmdW5jdGlvbiAoZ2V0dGVyLCBzZXR0ZXIpIHtcbiAgcmV0dXJuIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBnZXRJbnRlcm5hbFVSTFN0YXRlKHRoaXMpW2dldHRlcl0oKTtcbiAgICB9LFxuICAgIHNldDogc2V0dGVyICYmIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGdldEludGVybmFsVVJMU3RhdGUodGhpcylbc2V0dGVyXSh2YWx1ZSk7XG4gICAgfSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogdHJ1ZVxuICB9O1xufTtcblxuaWYgKERFU0NSSVBUT1JTKSB7XG4gIC8vIGBVUkwucHJvdG90eXBlLmhyZWZgIGFjY2Vzc29ycyBwYWlyXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC1ocmVmXG4gIGRlZmluZUJ1aWx0SW5BY2Nlc3NvcihVUkxQcm90b3R5cGUsICdocmVmJywgYWNjZXNzb3JEZXNjcmlwdG9yKCdzZXJpYWxpemUnLCAnc2V0SHJlZicpKTtcbiAgLy8gYFVSTC5wcm90b3R5cGUub3JpZ2luYCBnZXR0ZXJcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsLW9yaWdpblxuICBkZWZpbmVCdWlsdEluQWNjZXNzb3IoVVJMUHJvdG90eXBlLCAnb3JpZ2luJywgYWNjZXNzb3JEZXNjcmlwdG9yKCdnZXRPcmlnaW4nKSk7XG4gIC8vIGBVUkwucHJvdG90eXBlLnByb3RvY29sYCBhY2Nlc3NvcnMgcGFpclxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmwtcHJvdG9jb2xcbiAgZGVmaW5lQnVpbHRJbkFjY2Vzc29yKFVSTFByb3RvdHlwZSwgJ3Byb3RvY29sJywgYWNjZXNzb3JEZXNjcmlwdG9yKCdnZXRQcm90b2NvbCcsICdzZXRQcm90b2NvbCcpKTtcbiAgLy8gYFVSTC5wcm90b3R5cGUudXNlcm5hbWVgIGFjY2Vzc29ycyBwYWlyXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC11c2VybmFtZVxuICBkZWZpbmVCdWlsdEluQWNjZXNzb3IoVVJMUHJvdG90eXBlLCAndXNlcm5hbWUnLCBhY2Nlc3NvckRlc2NyaXB0b3IoJ2dldFVzZXJuYW1lJywgJ3NldFVzZXJuYW1lJykpO1xuICAvLyBgVVJMLnByb3RvdHlwZS5wYXNzd29yZGAgYWNjZXNzb3JzIHBhaXJcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsLXBhc3N3b3JkXG4gIGRlZmluZUJ1aWx0SW5BY2Nlc3NvcihVUkxQcm90b3R5cGUsICdwYXNzd29yZCcsIGFjY2Vzc29yRGVzY3JpcHRvcignZ2V0UGFzc3dvcmQnLCAnc2V0UGFzc3dvcmQnKSk7XG4gIC8vIGBVUkwucHJvdG90eXBlLmhvc3RgIGFjY2Vzc29ycyBwYWlyXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC1ob3N0XG4gIGRlZmluZUJ1aWx0SW5BY2Nlc3NvcihVUkxQcm90b3R5cGUsICdob3N0JywgYWNjZXNzb3JEZXNjcmlwdG9yKCdnZXRIb3N0JywgJ3NldEhvc3QnKSk7XG4gIC8vIGBVUkwucHJvdG90eXBlLmhvc3RuYW1lYCBhY2Nlc3NvcnMgcGFpclxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmwtaG9zdG5hbWVcbiAgZGVmaW5lQnVpbHRJbkFjY2Vzc29yKFVSTFByb3RvdHlwZSwgJ2hvc3RuYW1lJywgYWNjZXNzb3JEZXNjcmlwdG9yKCdnZXRIb3N0bmFtZScsICdzZXRIb3N0bmFtZScpKTtcbiAgLy8gYFVSTC5wcm90b3R5cGUucG9ydGAgYWNjZXNzb3JzIHBhaXJcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsLXBvcnRcbiAgZGVmaW5lQnVpbHRJbkFjY2Vzc29yKFVSTFByb3RvdHlwZSwgJ3BvcnQnLCBhY2Nlc3NvckRlc2NyaXB0b3IoJ2dldFBvcnQnLCAnc2V0UG9ydCcpKTtcbiAgLy8gYFVSTC5wcm90b3R5cGUucGF0aG5hbWVgIGFjY2Vzc29ycyBwYWlyXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC1wYXRobmFtZVxuICBkZWZpbmVCdWlsdEluQWNjZXNzb3IoVVJMUHJvdG90eXBlLCAncGF0aG5hbWUnLCBhY2Nlc3NvckRlc2NyaXB0b3IoJ2dldFBhdGhuYW1lJywgJ3NldFBhdGhuYW1lJykpO1xuICAvLyBgVVJMLnByb3RvdHlwZS5zZWFyY2hgIGFjY2Vzc29ycyBwYWlyXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC1zZWFyY2hcbiAgZGVmaW5lQnVpbHRJbkFjY2Vzc29yKFVSTFByb3RvdHlwZSwgJ3NlYXJjaCcsIGFjY2Vzc29yRGVzY3JpcHRvcignZ2V0U2VhcmNoJywgJ3NldFNlYXJjaCcpKTtcbiAgLy8gYFVSTC5wcm90b3R5cGUuc2VhcmNoUGFyYW1zYCBnZXR0ZXJcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsLXNlYXJjaHBhcmFtc1xuICBkZWZpbmVCdWlsdEluQWNjZXNzb3IoVVJMUHJvdG90eXBlLCAnc2VhcmNoUGFyYW1zJywgYWNjZXNzb3JEZXNjcmlwdG9yKCdnZXRTZWFyY2hQYXJhbXMnKSk7XG4gIC8vIGBVUkwucHJvdG90eXBlLmhhc2hgIGFjY2Vzc29ycyBwYWlyXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC1oYXNoXG4gIGRlZmluZUJ1aWx0SW5BY2Nlc3NvcihVUkxQcm90b3R5cGUsICdoYXNoJywgYWNjZXNzb3JEZXNjcmlwdG9yKCdnZXRIYXNoJywgJ3NldEhhc2gnKSk7XG59XG5cbi8vIGBVUkwucHJvdG90eXBlLnRvSlNPTmAgbWV0aG9kXG4vLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmwtdG9qc29uXG5kZWZpbmVCdWlsdEluJDEoVVJMUHJvdG90eXBlLCAndG9KU09OJywgZnVuY3Rpb24gdG9KU09OKCkge1xuICByZXR1cm4gZ2V0SW50ZXJuYWxVUkxTdGF0ZSh0aGlzKS5zZXJpYWxpemUoKTtcbn0sIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcblxuLy8gYFVSTC5wcm90b3R5cGUudG9TdHJpbmdgIG1ldGhvZFxuLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNVUkwtc3RyaW5naWZpY2F0aW9uLWJlaGF2aW9yXG5kZWZpbmVCdWlsdEluJDEoVVJMUHJvdG90eXBlLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuIGdldEludGVybmFsVVJMU3RhdGUodGhpcykuc2VyaWFsaXplKCk7XG59LCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5cbmlmIChOYXRpdmVVUkwpIHtcbiAgdmFyIG5hdGl2ZUNyZWF0ZU9iamVjdFVSTCA9IE5hdGl2ZVVSTC5jcmVhdGVPYmplY3RVUkw7XG4gIHZhciBuYXRpdmVSZXZva2VPYmplY3RVUkwgPSBOYXRpdmVVUkwucmV2b2tlT2JqZWN0VVJMO1xuICAvLyBgVVJMLmNyZWF0ZU9iamVjdFVSTGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9VUkwvY3JlYXRlT2JqZWN0VVJMXG4gIGlmIChuYXRpdmVDcmVhdGVPYmplY3RVUkwpIGRlZmluZUJ1aWx0SW4kMShVUkxDb25zdHJ1Y3RvciwgJ2NyZWF0ZU9iamVjdFVSTCcsIGJpbmQobmF0aXZlQ3JlYXRlT2JqZWN0VVJMLCBOYXRpdmVVUkwpKTtcbiAgLy8gYFVSTC5yZXZva2VPYmplY3RVUkxgIG1ldGhvZFxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVVJML3Jldm9rZU9iamVjdFVSTFxuICBpZiAobmF0aXZlUmV2b2tlT2JqZWN0VVJMKSBkZWZpbmVCdWlsdEluJDEoVVJMQ29uc3RydWN0b3IsICdyZXZva2VPYmplY3RVUkwnLCBiaW5kKG5hdGl2ZVJldm9rZU9iamVjdFVSTCwgTmF0aXZlVVJMKSk7XG59XG5cbnNldFRvU3RyaW5nVGFnKFVSTENvbnN0cnVjdG9yLCAnVVJMJyk7XG5cbiQkMSh7IGdsb2JhbDogdHJ1ZSwgY29uc3RydWN0b3I6IHRydWUsIGZvcmNlZDogIVVTRV9OQVRJVkVfVVJMLCBzaGFtOiAhREVTQ1JJUFRPUlMgfSwge1xuICBVUkw6IFVSTENvbnN0cnVjdG9yXG59KTtcblxudmFyIGZhaWxzJDQgPSBmYWlscyRrO1xudmFyIGdsb2JhbCQzID0gZ2xvYmFsJG87XG5cbi8vIGJhYmVsLW1pbmlmeSBhbmQgQ2xvc3VyZSBDb21waWxlciB0cmFuc3BpbGVzIFJlZ0V4cCgnYScsICd5JykgLT4gL2EveSBhbmQgaXQgY2F1c2VzIFN5bnRheEVycm9yXG52YXIgJFJlZ0V4cCQyID0gZ2xvYmFsJDMuUmVnRXhwO1xuXG52YXIgVU5TVVBQT1JURURfWSQxID0gZmFpbHMkNChmdW5jdGlvbiAoKSB7XG4gIHZhciByZSA9ICRSZWdFeHAkMignYScsICd5Jyk7XG4gIHJlLmxhc3RJbmRleCA9IDI7XG4gIHJldHVybiByZS5leGVjKCdhYmNkJykgIT0gbnVsbDtcbn0pO1xuXG4vLyBVQyBCcm93c2VyIGJ1Z1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzEwMDhcbnZhciBNSVNTRURfU1RJQ0tZID0gVU5TVVBQT1JURURfWSQxIHx8IGZhaWxzJDQoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gISRSZWdFeHAkMignYScsICd5Jykuc3RpY2t5O1xufSk7XG5cbnZhciBCUk9LRU5fQ0FSRVQgPSBVTlNVUFBPUlRFRF9ZJDEgfHwgZmFpbHMkNChmdW5jdGlvbiAoKSB7XG4gIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTc3MzY4N1xuICB2YXIgcmUgPSAkUmVnRXhwJDIoJ15yJywgJ2d5Jyk7XG4gIHJlLmxhc3RJbmRleCA9IDI7XG4gIHJldHVybiByZS5leGVjKCdzdHInKSAhPSBudWxsO1xufSk7XG5cbnZhciByZWdleHBTdGlja3lIZWxwZXJzID0ge1xuICBCUk9LRU5fQ0FSRVQ6IEJST0tFTl9DQVJFVCxcbiAgTUlTU0VEX1NUSUNLWTogTUlTU0VEX1NUSUNLWSxcbiAgVU5TVVBQT1JURURfWTogVU5TVVBQT1JURURfWSQxXG59O1xuXG52YXIgZmFpbHMkMyA9IGZhaWxzJGs7XG52YXIgZ2xvYmFsJDIgPSBnbG9iYWwkbztcblxuLy8gYmFiZWwtbWluaWZ5IGFuZCBDbG9zdXJlIENvbXBpbGVyIHRyYW5zcGlsZXMgUmVnRXhwKCcuJywgJ3MnKSAtPiAvLi9zIGFuZCBpdCBjYXVzZXMgU3ludGF4RXJyb3JcbnZhciAkUmVnRXhwJDEgPSBnbG9iYWwkMi5SZWdFeHA7XG5cbnZhciByZWdleHBVbnN1cHBvcnRlZERvdEFsbCA9IGZhaWxzJDMoZnVuY3Rpb24gKCkge1xuICB2YXIgcmUgPSAkUmVnRXhwJDEoJy4nLCAncycpO1xuICByZXR1cm4gIShyZS5kb3RBbGwgJiYgcmUuZXhlYygnXFxuJykgJiYgcmUuZmxhZ3MgPT09ICdzJyk7XG59KTtcblxudmFyIGZhaWxzJDIgPSBmYWlscyRrO1xudmFyIGdsb2JhbCQxID0gZ2xvYmFsJG87XG5cbi8vIGJhYmVsLW1pbmlmeSBhbmQgQ2xvc3VyZSBDb21waWxlciB0cmFuc3BpbGVzIFJlZ0V4cCgnKD88YT5iKScsICdnJykgLT4gLyg/PGE+YikvZyBhbmQgaXQgY2F1c2VzIFN5bnRheEVycm9yXG52YXIgJFJlZ0V4cCA9IGdsb2JhbCQxLlJlZ0V4cDtcblxudmFyIHJlZ2V4cFVuc3VwcG9ydGVkTmNnID0gZmFpbHMkMihmdW5jdGlvbiAoKSB7XG4gIHZhciByZSA9ICRSZWdFeHAoJyg/PGE+YiknLCAnZycpO1xuICByZXR1cm4gcmUuZXhlYygnYicpLmdyb3Vwcy5hICE9PSAnYicgfHxcbiAgICAnYicucmVwbGFjZShyZSwgJyQ8YT5jJykgIT09ICdiYyc7XG59KTtcblxuLyogZXNsaW50LWRpc2FibGUgcmVnZXhwL25vLWVtcHR5LWNhcHR1cmluZy1ncm91cCwgcmVnZXhwL25vLWVtcHR5LWdyb3VwLCByZWdleHAvbm8tbGF6eS1lbmRzIC0tIHRlc3RpbmcgKi9cbi8qIGVzbGludC1kaXNhYmxlIHJlZ2V4cC9uby11c2VsZXNzLXF1YW50aWZpZXIgLS0gdGVzdGluZyAqL1xudmFyIGNhbGwkMiA9IGZ1bmN0aW9uQ2FsbDtcbnZhciB1bmN1cnJ5VGhpcyQzID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciB0b1N0cmluZyQxID0gdG9TdHJpbmckNDtcbnZhciByZWdleHBGbGFncyA9IHJlZ2V4cEZsYWdzJDE7XG52YXIgc3RpY2t5SGVscGVycyA9IHJlZ2V4cFN0aWNreUhlbHBlcnM7XG52YXIgc2hhcmVkID0gc2hhcmVkJDQuZXhwb3J0cztcbnZhciBjcmVhdGUgPSBvYmplY3RDcmVhdGU7XG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IGludGVybmFsU3RhdGUuZ2V0O1xudmFyIFVOU1VQUE9SVEVEX0RPVF9BTEwgPSByZWdleHBVbnN1cHBvcnRlZERvdEFsbDtcbnZhciBVTlNVUFBPUlRFRF9OQ0cgPSByZWdleHBVbnN1cHBvcnRlZE5jZztcblxudmFyIG5hdGl2ZVJlcGxhY2UgPSBzaGFyZWQoJ25hdGl2ZS1zdHJpbmctcmVwbGFjZScsIFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSk7XG52YXIgbmF0aXZlRXhlYyA9IFJlZ0V4cC5wcm90b3R5cGUuZXhlYztcbnZhciBwYXRjaGVkRXhlYyA9IG5hdGl2ZUV4ZWM7XG52YXIgY2hhckF0JDIgPSB1bmN1cnJ5VGhpcyQzKCcnLmNoYXJBdCk7XG52YXIgaW5kZXhPZiA9IHVuY3VycnlUaGlzJDMoJycuaW5kZXhPZik7XG52YXIgcmVwbGFjZSQxID0gdW5jdXJyeVRoaXMkMygnJy5yZXBsYWNlKTtcbnZhciBzdHJpbmdTbGljZSQyID0gdW5jdXJyeVRoaXMkMygnJy5zbGljZSk7XG5cbnZhciBVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgcmUxID0gL2EvO1xuICB2YXIgcmUyID0gL2IqL2c7XG4gIGNhbGwkMihuYXRpdmVFeGVjLCByZTEsICdhJyk7XG4gIGNhbGwkMihuYXRpdmVFeGVjLCByZTIsICdhJyk7XG4gIHJldHVybiByZTEubGFzdEluZGV4ICE9PSAwIHx8IHJlMi5sYXN0SW5kZXggIT09IDA7XG59KSgpO1xuXG52YXIgVU5TVVBQT1JURURfWSA9IHN0aWNreUhlbHBlcnMuQlJPS0VOX0NBUkVUO1xuXG4vLyBub25wYXJ0aWNpcGF0aW5nIGNhcHR1cmluZyBncm91cCwgY29waWVkIGZyb20gZXM1LXNoaW0ncyBTdHJpbmcjc3BsaXQgcGF0Y2guXG52YXIgTlBDR19JTkNMVURFRCA9IC8oKT8/Ly5leGVjKCcnKVsxXSAhPT0gdW5kZWZpbmVkO1xuXG52YXIgUEFUQ0ggPSBVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcgfHwgTlBDR19JTkNMVURFRCB8fCBVTlNVUFBPUlRFRF9ZIHx8IFVOU1VQUE9SVEVEX0RPVF9BTEwgfHwgVU5TVVBQT1JURURfTkNHO1xuXG5pZiAoUEFUQ0gpIHtcbiAgcGF0Y2hlZEV4ZWMgPSBmdW5jdGlvbiBleGVjKHN0cmluZykge1xuICAgIHZhciByZSA9IHRoaXM7XG4gICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZShyZSk7XG4gICAgdmFyIHN0ciA9IHRvU3RyaW5nJDEoc3RyaW5nKTtcbiAgICB2YXIgcmF3ID0gc3RhdGUucmF3O1xuICAgIHZhciByZXN1bHQsIHJlQ29weSwgbGFzdEluZGV4LCBtYXRjaCwgaSwgb2JqZWN0LCBncm91cDtcblxuICAgIGlmIChyYXcpIHtcbiAgICAgIHJhdy5sYXN0SW5kZXggPSByZS5sYXN0SW5kZXg7XG4gICAgICByZXN1bHQgPSBjYWxsJDIocGF0Y2hlZEV4ZWMsIHJhdywgc3RyKTtcbiAgICAgIHJlLmxhc3RJbmRleCA9IHJhdy5sYXN0SW5kZXg7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHZhciBncm91cHMgPSBzdGF0ZS5ncm91cHM7XG4gICAgdmFyIHN0aWNreSA9IFVOU1VQUE9SVEVEX1kgJiYgcmUuc3RpY2t5O1xuICAgIHZhciBmbGFncyA9IGNhbGwkMihyZWdleHBGbGFncywgcmUpO1xuICAgIHZhciBzb3VyY2UgPSByZS5zb3VyY2U7XG4gICAgdmFyIGNoYXJzQWRkZWQgPSAwO1xuICAgIHZhciBzdHJDb3B5ID0gc3RyO1xuXG4gICAgaWYgKHN0aWNreSkge1xuICAgICAgZmxhZ3MgPSByZXBsYWNlJDEoZmxhZ3MsICd5JywgJycpO1xuICAgICAgaWYgKGluZGV4T2YoZmxhZ3MsICdnJykgPT09IC0xKSB7XG4gICAgICAgIGZsYWdzICs9ICdnJztcbiAgICAgIH1cblxuICAgICAgc3RyQ29weSA9IHN0cmluZ1NsaWNlJDIoc3RyLCByZS5sYXN0SW5kZXgpO1xuICAgICAgLy8gU3VwcG9ydCBhbmNob3JlZCBzdGlja3kgYmVoYXZpb3IuXG4gICAgICBpZiAocmUubGFzdEluZGV4ID4gMCAmJiAoIXJlLm11bHRpbGluZSB8fCByZS5tdWx0aWxpbmUgJiYgY2hhckF0JDIoc3RyLCByZS5sYXN0SW5kZXggLSAxKSAhPT0gJ1xcbicpKSB7XG4gICAgICAgIHNvdXJjZSA9ICcoPzogJyArIHNvdXJjZSArICcpJztcbiAgICAgICAgc3RyQ29weSA9ICcgJyArIHN0ckNvcHk7XG4gICAgICAgIGNoYXJzQWRkZWQrKztcbiAgICAgIH1cbiAgICAgIC8vIF4oPyArIHJ4ICsgKSBpcyBuZWVkZWQsIGluIGNvbWJpbmF0aW9uIHdpdGggc29tZSBzdHIgc2xpY2luZywgdG9cbiAgICAgIC8vIHNpbXVsYXRlIHRoZSAneScgZmxhZy5cbiAgICAgIHJlQ29weSA9IG5ldyBSZWdFeHAoJ14oPzonICsgc291cmNlICsgJyknLCBmbGFncyk7XG4gICAgfVxuXG4gICAgaWYgKE5QQ0dfSU5DTFVERUQpIHtcbiAgICAgIHJlQ29weSA9IG5ldyBSZWdFeHAoJ14nICsgc291cmNlICsgJyQoPyFcXFxccyknLCBmbGFncyk7XG4gICAgfVxuICAgIGlmIChVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcpIGxhc3RJbmRleCA9IHJlLmxhc3RJbmRleDtcblxuICAgIG1hdGNoID0gY2FsbCQyKG5hdGl2ZUV4ZWMsIHN0aWNreSA/IHJlQ29weSA6IHJlLCBzdHJDb3B5KTtcblxuICAgIGlmIChzdGlja3kpIHtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBtYXRjaC5pbnB1dCA9IHN0cmluZ1NsaWNlJDIobWF0Y2guaW5wdXQsIGNoYXJzQWRkZWQpO1xuICAgICAgICBtYXRjaFswXSA9IHN0cmluZ1NsaWNlJDIobWF0Y2hbMF0sIGNoYXJzQWRkZWQpO1xuICAgICAgICBtYXRjaC5pbmRleCA9IHJlLmxhc3RJbmRleDtcbiAgICAgICAgcmUubGFzdEluZGV4ICs9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgIH0gZWxzZSByZS5sYXN0SW5kZXggPSAwO1xuICAgIH0gZWxzZSBpZiAoVVBEQVRFU19MQVNUX0lOREVYX1dST05HICYmIG1hdGNoKSB7XG4gICAgICByZS5sYXN0SW5kZXggPSByZS5nbG9iYWwgPyBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCA6IGxhc3RJbmRleDtcbiAgICB9XG4gICAgaWYgKE5QQ0dfSU5DTFVERUQgJiYgbWF0Y2ggJiYgbWF0Y2gubGVuZ3RoID4gMSkge1xuICAgICAgLy8gRml4IGJyb3dzZXJzIHdob3NlIGBleGVjYCBtZXRob2RzIGRvbid0IGNvbnNpc3RlbnRseSByZXR1cm4gYHVuZGVmaW5lZGBcbiAgICAgIC8vIGZvciBOUENHLCBsaWtlIElFOC4gTk9URTogVGhpcyBkb2Vzbicgd29yayBmb3IgLyguPyk/L1xuICAgICAgY2FsbCQyKG5hdGl2ZVJlcGxhY2UsIG1hdGNoWzBdLCByZUNvcHksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGggLSAyOyBpKyspIHtcbiAgICAgICAgICBpZiAoYXJndW1lbnRzW2ldID09PSB1bmRlZmluZWQpIG1hdGNoW2ldID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAobWF0Y2ggJiYgZ3JvdXBzKSB7XG4gICAgICBtYXRjaC5ncm91cHMgPSBvYmplY3QgPSBjcmVhdGUobnVsbCk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGdyb3VwID0gZ3JvdXBzW2ldO1xuICAgICAgICBvYmplY3RbZ3JvdXBbMF1dID0gbWF0Y2hbZ3JvdXBbMV1dO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYXRjaDtcbiAgfTtcbn1cblxudmFyIHJlZ2V4cEV4ZWMkMiA9IHBhdGNoZWRFeGVjO1xuXG52YXIgJCA9IF9leHBvcnQ7XG52YXIgZXhlYyA9IHJlZ2V4cEV4ZWMkMjtcblxuLy8gYFJlZ0V4cC5wcm90b3R5cGUuZXhlY2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXJlZ2V4cC5wcm90b3R5cGUuZXhlY1xuJCh7IHRhcmdldDogJ1JlZ0V4cCcsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IC8uLy5leGVjICE9PSBleGVjIH0sIHtcbiAgZXhlYzogZXhlY1xufSk7XG5cbi8vIFRPRE86IFJlbW92ZSBmcm9tIGBjb3JlLWpzQDRgIHNpbmNlIGl0J3MgbW92ZWQgdG8gZW50cnkgcG9pbnRzXG5cbnZhciB1bmN1cnJ5VGhpcyQyID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBkZWZpbmVCdWlsdEluID0gZGVmaW5lQnVpbHRJbiRhO1xudmFyIHJlZ2V4cEV4ZWMkMSA9IHJlZ2V4cEV4ZWMkMjtcbnZhciBmYWlscyQxID0gZmFpbHMkaztcbnZhciB3ZWxsS25vd25TeW1ib2wkMSA9IHdlbGxLbm93blN5bWJvbCRpO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ1O1xuXG52YXIgU1BFQ0lFUyA9IHdlbGxLbm93blN5bWJvbCQxKCdzcGVjaWVzJyk7XG52YXIgUmVnRXhwUHJvdG90eXBlID0gUmVnRXhwLnByb3RvdHlwZTtcblxudmFyIGZpeFJlZ2V4cFdlbGxLbm93blN5bWJvbExvZ2ljID0gZnVuY3Rpb24gKEtFWSwgZXhlYywgRk9SQ0VELCBTSEFNKSB7XG4gIHZhciBTWU1CT0wgPSB3ZWxsS25vd25TeW1ib2wkMShLRVkpO1xuXG4gIHZhciBERUxFR0FURVNfVE9fU1lNQk9MID0gIWZhaWxzJDEoZnVuY3Rpb24gKCkge1xuICAgIC8vIFN0cmluZyBtZXRob2RzIGNhbGwgc3ltYm9sLW5hbWVkIFJlZ0VwIG1ldGhvZHNcbiAgICB2YXIgTyA9IHt9O1xuICAgIE9bU1lNQk9MXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH07XG4gICAgcmV0dXJuICcnW0tFWV0oTykgIT0gNztcbiAgfSk7XG5cbiAgdmFyIERFTEVHQVRFU19UT19FWEVDID0gREVMRUdBVEVTX1RPX1NZTUJPTCAmJiAhZmFpbHMkMShmdW5jdGlvbiAoKSB7XG4gICAgLy8gU3ltYm9sLW5hbWVkIFJlZ0V4cCBtZXRob2RzIGNhbGwgLmV4ZWNcbiAgICB2YXIgZXhlY0NhbGxlZCA9IGZhbHNlO1xuICAgIHZhciByZSA9IC9hLztcblxuICAgIGlmIChLRVkgPT09ICdzcGxpdCcpIHtcbiAgICAgIC8vIFdlIGNhbid0IHVzZSByZWFsIHJlZ2V4IGhlcmUgc2luY2UgaXQgY2F1c2VzIGRlb3B0aW1pemF0aW9uXG4gICAgICAvLyBhbmQgc2VyaW91cyBwZXJmb3JtYW5jZSBkZWdyYWRhdGlvbiBpbiBWOFxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzMwNlxuICAgICAgcmUgPSB7fTtcbiAgICAgIC8vIFJlZ0V4cFtAQHNwbGl0XSBkb2Vzbid0IGNhbGwgdGhlIHJlZ2V4J3MgZXhlYyBtZXRob2QsIGJ1dCBmaXJzdCBjcmVhdGVzXG4gICAgICAvLyBhIG5ldyBvbmUuIFdlIG5lZWQgdG8gcmV0dXJuIHRoZSBwYXRjaGVkIHJlZ2V4IHdoZW4gY3JlYXRpbmcgdGhlIG5ldyBvbmUuXG4gICAgICByZS5jb25zdHJ1Y3RvciA9IHt9O1xuICAgICAgcmUuY29uc3RydWN0b3JbU1BFQ0lFU10gPSBmdW5jdGlvbiAoKSB7IHJldHVybiByZTsgfTtcbiAgICAgIHJlLmZsYWdzID0gJyc7XG4gICAgICByZVtTWU1CT0xdID0gLy4vW1NZTUJPTF07XG4gICAgfVxuXG4gICAgcmUuZXhlYyA9IGZ1bmN0aW9uICgpIHsgZXhlY0NhbGxlZCA9IHRydWU7IHJldHVybiBudWxsOyB9O1xuXG4gICAgcmVbU1lNQk9MXSgnJyk7XG4gICAgcmV0dXJuICFleGVjQ2FsbGVkO1xuICB9KTtcblxuICBpZiAoXG4gICAgIURFTEVHQVRFU19UT19TWU1CT0wgfHxcbiAgICAhREVMRUdBVEVTX1RPX0VYRUMgfHxcbiAgICBGT1JDRURcbiAgKSB7XG4gICAgdmFyIHVuY3VycmllZE5hdGl2ZVJlZ0V4cE1ldGhvZCA9IHVuY3VycnlUaGlzJDIoLy4vW1NZTUJPTF0pO1xuICAgIHZhciBtZXRob2RzID0gZXhlYyhTWU1CT0wsICcnW0tFWV0sIGZ1bmN0aW9uIChuYXRpdmVNZXRob2QsIHJlZ2V4cCwgc3RyLCBhcmcyLCBmb3JjZVN0cmluZ01ldGhvZCkge1xuICAgICAgdmFyIHVuY3VycmllZE5hdGl2ZU1ldGhvZCA9IHVuY3VycnlUaGlzJDIobmF0aXZlTWV0aG9kKTtcbiAgICAgIHZhciAkZXhlYyA9IHJlZ2V4cC5leGVjO1xuICAgICAgaWYgKCRleGVjID09PSByZWdleHBFeGVjJDEgfHwgJGV4ZWMgPT09IFJlZ0V4cFByb3RvdHlwZS5leGVjKSB7XG4gICAgICAgIGlmIChERUxFR0FURVNfVE9fU1lNQk9MICYmICFmb3JjZVN0cmluZ01ldGhvZCkge1xuICAgICAgICAgIC8vIFRoZSBuYXRpdmUgU3RyaW5nIG1ldGhvZCBhbHJlYWR5IGRlbGVnYXRlcyB0byBAQG1ldGhvZCAodGhpc1xuICAgICAgICAgIC8vIHBvbHlmaWxsZWQgZnVuY3Rpb24pLCBsZWFzaW5nIHRvIGluZmluaXRlIHJlY3Vyc2lvbi5cbiAgICAgICAgICAvLyBXZSBhdm9pZCBpdCBieSBkaXJlY3RseSBjYWxsaW5nIHRoZSBuYXRpdmUgQEBtZXRob2QgbWV0aG9kLlxuICAgICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUsIHZhbHVlOiB1bmN1cnJpZWROYXRpdmVSZWdFeHBNZXRob2QocmVnZXhwLCBzdHIsIGFyZzIpIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IHVuY3VycmllZE5hdGl2ZU1ldGhvZChzdHIsIHJlZ2V4cCwgYXJnMikgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IGRvbmU6IGZhbHNlIH07XG4gICAgfSk7XG5cbiAgICBkZWZpbmVCdWlsdEluKFN0cmluZy5wcm90b3R5cGUsIEtFWSwgbWV0aG9kc1swXSk7XG4gICAgZGVmaW5lQnVpbHRJbihSZWdFeHBQcm90b3R5cGUsIFNZTUJPTCwgbWV0aG9kc1sxXSk7XG4gIH1cblxuICBpZiAoU0hBTSkgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KFJlZ0V4cFByb3RvdHlwZVtTWU1CT0xdLCAnc2hhbScsIHRydWUpO1xufTtcblxudmFyIGNoYXJBdCQxID0gc3RyaW5nTXVsdGlieXRlLmNoYXJBdDtcblxuLy8gYEFkdmFuY2VTdHJpbmdJbmRleGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFkdmFuY2VzdHJpbmdpbmRleFxudmFyIGFkdmFuY2VTdHJpbmdJbmRleCQxID0gZnVuY3Rpb24gKFMsIGluZGV4LCB1bmljb2RlKSB7XG4gIHJldHVybiBpbmRleCArICh1bmljb2RlID8gY2hhckF0JDEoUywgaW5kZXgpLmxlbmd0aCA6IDEpO1xufTtcblxudmFyIHVuY3VycnlUaGlzJDEgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIHRvT2JqZWN0ID0gdG9PYmplY3QkNTtcblxudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbnZhciBjaGFyQXQgPSB1bmN1cnJ5VGhpcyQxKCcnLmNoYXJBdCk7XG52YXIgcmVwbGFjZSA9IHVuY3VycnlUaGlzJDEoJycucmVwbGFjZSk7XG52YXIgc3RyaW5nU2xpY2UkMSA9IHVuY3VycnlUaGlzJDEoJycuc2xpY2UpO1xudmFyIFNVQlNUSVRVVElPTl9TWU1CT0xTID0gL1xcJChbJCYnYF18XFxkezEsMn18PFtePl0qPikvZztcbnZhciBTVUJTVElUVVRJT05fU1lNQk9MU19OT19OQU1FRCA9IC9cXCQoWyQmJ2BdfFxcZHsxLDJ9KS9nO1xuXG4vLyBgR2V0U3Vic3RpdHV0aW9uYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtZ2V0c3Vic3RpdHV0aW9uXG52YXIgZ2V0U3Vic3RpdHV0aW9uJDEgPSBmdW5jdGlvbiAobWF0Y2hlZCwgc3RyLCBwb3NpdGlvbiwgY2FwdHVyZXMsIG5hbWVkQ2FwdHVyZXMsIHJlcGxhY2VtZW50KSB7XG4gIHZhciB0YWlsUG9zID0gcG9zaXRpb24gKyBtYXRjaGVkLmxlbmd0aDtcbiAgdmFyIG0gPSBjYXB0dXJlcy5sZW5ndGg7XG4gIHZhciBzeW1ib2xzID0gU1VCU1RJVFVUSU9OX1NZTUJPTFNfTk9fTkFNRUQ7XG4gIGlmIChuYW1lZENhcHR1cmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICBuYW1lZENhcHR1cmVzID0gdG9PYmplY3QobmFtZWRDYXB0dXJlcyk7XG4gICAgc3ltYm9scyA9IFNVQlNUSVRVVElPTl9TWU1CT0xTO1xuICB9XG4gIHJldHVybiByZXBsYWNlKHJlcGxhY2VtZW50LCBzeW1ib2xzLCBmdW5jdGlvbiAobWF0Y2gsIGNoKSB7XG4gICAgdmFyIGNhcHR1cmU7XG4gICAgc3dpdGNoIChjaGFyQXQoY2gsIDApKSB7XG4gICAgICBjYXNlICckJzogcmV0dXJuICckJztcbiAgICAgIGNhc2UgJyYnOiByZXR1cm4gbWF0Y2hlZDtcbiAgICAgIGNhc2UgJ2AnOiByZXR1cm4gc3RyaW5nU2xpY2UkMShzdHIsIDAsIHBvc2l0aW9uKTtcbiAgICAgIGNhc2UgXCInXCI6IHJldHVybiBzdHJpbmdTbGljZSQxKHN0ciwgdGFpbFBvcyk7XG4gICAgICBjYXNlICc8JzpcbiAgICAgICAgY2FwdHVyZSA9IG5hbWVkQ2FwdHVyZXNbc3RyaW5nU2xpY2UkMShjaCwgMSwgLTEpXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OiAvLyBcXGRcXGQ/XG4gICAgICAgIHZhciBuID0gK2NoO1xuICAgICAgICBpZiAobiA9PT0gMCkgcmV0dXJuIG1hdGNoO1xuICAgICAgICBpZiAobiA+IG0pIHtcbiAgICAgICAgICB2YXIgZiA9IGZsb29yKG4gLyAxMCk7XG4gICAgICAgICAgaWYgKGYgPT09IDApIHJldHVybiBtYXRjaDtcbiAgICAgICAgICBpZiAoZiA8PSBtKSByZXR1cm4gY2FwdHVyZXNbZiAtIDFdID09PSB1bmRlZmluZWQgPyBjaGFyQXQoY2gsIDEpIDogY2FwdHVyZXNbZiAtIDFdICsgY2hhckF0KGNoLCAxKTtcbiAgICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICAgIH1cbiAgICAgICAgY2FwdHVyZSA9IGNhcHR1cmVzW24gLSAxXTtcbiAgICB9XG4gICAgcmV0dXJuIGNhcHR1cmUgPT09IHVuZGVmaW5lZCA/ICcnIDogY2FwdHVyZTtcbiAgfSk7XG59O1xuXG52YXIgY2FsbCQxID0gZnVuY3Rpb25DYWxsO1xudmFyIGFuT2JqZWN0JDEgPSBhbk9iamVjdCRnO1xudmFyIGlzQ2FsbGFibGUkMSA9IGlzQ2FsbGFibGUkbjtcbnZhciBjbGFzc29mID0gY2xhc3NvZlJhdyQxO1xudmFyIHJlZ2V4cEV4ZWMgPSByZWdleHBFeGVjJDI7XG5cbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuXG4vLyBgUmVnRXhwRXhlY2AgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXJlZ2V4cGV4ZWNcbnZhciByZWdleHBFeGVjQWJzdHJhY3QgPSBmdW5jdGlvbiAoUiwgUykge1xuICB2YXIgZXhlYyA9IFIuZXhlYztcbiAgaWYgKGlzQ2FsbGFibGUkMShleGVjKSkge1xuICAgIHZhciByZXN1bHQgPSBjYWxsJDEoZXhlYywgUiwgUyk7XG4gICAgaWYgKHJlc3VsdCAhPT0gbnVsbCkgYW5PYmplY3QkMShyZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaWYgKGNsYXNzb2YoUikgPT09ICdSZWdFeHAnKSByZXR1cm4gY2FsbCQxKHJlZ2V4cEV4ZWMsIFIsIFMpO1xuICB0aHJvdyAkVHlwZUVycm9yKCdSZWdFeHAjZXhlYyBjYWxsZWQgb24gaW5jb21wYXRpYmxlIHJlY2VpdmVyJyk7XG59O1xuXG52YXIgYXBwbHkgPSBmdW5jdGlvbkFwcGx5O1xudmFyIGNhbGwgPSBmdW5jdGlvbkNhbGw7XG52YXIgdW5jdXJyeVRoaXMgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGZpeFJlZ0V4cFdlbGxLbm93blN5bWJvbExvZ2ljID0gZml4UmVnZXhwV2VsbEtub3duU3ltYm9sTG9naWM7XG52YXIgZmFpbHMgPSBmYWlscyRrO1xudmFyIGFuT2JqZWN0ID0gYW5PYmplY3QkZztcbnZhciBpc0NhbGxhYmxlID0gaXNDYWxsYWJsZSRuO1xudmFyIHRvSW50ZWdlck9ySW5maW5pdHkgPSB0b0ludGVnZXJPckluZmluaXR5JDQ7XG52YXIgdG9MZW5ndGggPSB0b0xlbmd0aCQyO1xudmFyIHRvU3RyaW5nID0gdG9TdHJpbmckNDtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZU9iamVjdENvZXJjaWJsZSQ0O1xudmFyIGFkdmFuY2VTdHJpbmdJbmRleCA9IGFkdmFuY2VTdHJpbmdJbmRleCQxO1xudmFyIGdldE1ldGhvZCA9IGdldE1ldGhvZCQ0O1xudmFyIGdldFN1YnN0aXR1dGlvbiA9IGdldFN1YnN0aXR1dGlvbiQxO1xudmFyIHJlZ0V4cEV4ZWMgPSByZWdleHBFeGVjQWJzdHJhY3Q7XG52YXIgd2VsbEtub3duU3ltYm9sID0gd2VsbEtub3duU3ltYm9sJGk7XG5cbnZhciBSRVBMQUNFID0gd2VsbEtub3duU3ltYm9sKCdyZXBsYWNlJyk7XG52YXIgbWF4ID0gTWF0aC5tYXg7XG52YXIgbWluID0gTWF0aC5taW47XG52YXIgY29uY2F0ID0gdW5jdXJyeVRoaXMoW10uY29uY2F0KTtcbnZhciBwdXNoID0gdW5jdXJyeVRoaXMoW10ucHVzaCk7XG52YXIgc3RyaW5nSW5kZXhPZiA9IHVuY3VycnlUaGlzKCcnLmluZGV4T2YpO1xudmFyIHN0cmluZ1NsaWNlID0gdW5jdXJyeVRoaXMoJycuc2xpY2UpO1xuXG52YXIgbWF5YmVUb1N0cmluZyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/IGl0IDogU3RyaW5nKGl0KTtcbn07XG5cbi8vIElFIDw9IDExIHJlcGxhY2VzICQwIHdpdGggdGhlIHdob2xlIG1hdGNoLCBhcyBpZiBpdCB3YXMgJCZcbi8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzYwMjQ2NjYvZ2V0dGluZy1pZS10by1yZXBsYWNlLWEtcmVnZXgtd2l0aC10aGUtbGl0ZXJhbC1zdHJpbmctMFxudmFyIFJFUExBQ0VfS0VFUFNfJDAgPSAoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVnZXhwL3ByZWZlci1lc2NhcGUtcmVwbGFjZW1lbnQtZG9sbGFyLWNoYXIgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgcmV0dXJuICdhJy5yZXBsYWNlKC8uLywgJyQwJykgPT09ICckMCc7XG59KSgpO1xuXG4vLyBTYWZhcmkgPD0gMTMuMC4zKD8pIHN1YnN0aXR1dGVzIG50aCBjYXB0dXJlIHdoZXJlIG4+bSB3aXRoIGFuIGVtcHR5IHN0cmluZ1xudmFyIFJFR0VYUF9SRVBMQUNFX1NVQlNUSVRVVEVTX1VOREVGSU5FRF9DQVBUVVJFID0gKGZ1bmN0aW9uICgpIHtcbiAgaWYgKC8uL1tSRVBMQUNFXSkge1xuICAgIHJldHVybiAvLi9bUkVQTEFDRV0oJ2EnLCAnJDAnKSA9PT0gJyc7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufSkoKTtcblxudmFyIFJFUExBQ0VfU1VQUE9SVFNfTkFNRURfR1JPVVBTID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJlID0gLy4vO1xuICByZS5leGVjID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICByZXN1bHQuZ3JvdXBzID0geyBhOiAnNycgfTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVnZXhwL25vLXVzZWxlc3MtZG9sbGFyLXJlcGxhY2VtZW50cyAtLSBmYWxzZSBwb3NpdGl2ZVxuICByZXR1cm4gJycucmVwbGFjZShyZSwgJyQ8YT4nKSAhPT0gJzcnO1xufSk7XG5cbi8vIEBAcmVwbGFjZSBsb2dpY1xuZml4UmVnRXhwV2VsbEtub3duU3ltYm9sTG9naWMoJ3JlcGxhY2UnLCBmdW5jdGlvbiAoXywgbmF0aXZlUmVwbGFjZSwgbWF5YmVDYWxsTmF0aXZlKSB7XG4gIHZhciBVTlNBRkVfU1VCU1RJVFVURSA9IFJFR0VYUF9SRVBMQUNFX1NVQlNUSVRVVEVTX1VOREVGSU5FRF9DQVBUVVJFID8gJyQnIDogJyQwJztcblxuICByZXR1cm4gW1xuICAgIC8vIGBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2VgIG1ldGhvZFxuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlXG4gICAgZnVuY3Rpb24gcmVwbGFjZShzZWFyY2hWYWx1ZSwgcmVwbGFjZVZhbHVlKSB7XG4gICAgICB2YXIgTyA9IHJlcXVpcmVPYmplY3RDb2VyY2libGUodGhpcyk7XG4gICAgICB2YXIgcmVwbGFjZXIgPSBzZWFyY2hWYWx1ZSA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBnZXRNZXRob2Qoc2VhcmNoVmFsdWUsIFJFUExBQ0UpO1xuICAgICAgcmV0dXJuIHJlcGxhY2VyXG4gICAgICAgID8gY2FsbChyZXBsYWNlciwgc2VhcmNoVmFsdWUsIE8sIHJlcGxhY2VWYWx1ZSlcbiAgICAgICAgOiBjYWxsKG5hdGl2ZVJlcGxhY2UsIHRvU3RyaW5nKE8pLCBzZWFyY2hWYWx1ZSwgcmVwbGFjZVZhbHVlKTtcbiAgICB9LFxuICAgIC8vIGBSZWdFeHAucHJvdG90eXBlW0BAcmVwbGFjZV1gIG1ldGhvZFxuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcmVnZXhwLnByb3RvdHlwZS1AQHJlcGxhY2VcbiAgICBmdW5jdGlvbiAoc3RyaW5nLCByZXBsYWNlVmFsdWUpIHtcbiAgICAgIHZhciByeCA9IGFuT2JqZWN0KHRoaXMpO1xuICAgICAgdmFyIFMgPSB0b1N0cmluZyhzdHJpbmcpO1xuXG4gICAgICBpZiAoXG4gICAgICAgIHR5cGVvZiByZXBsYWNlVmFsdWUgPT0gJ3N0cmluZycgJiZcbiAgICAgICAgc3RyaW5nSW5kZXhPZihyZXBsYWNlVmFsdWUsIFVOU0FGRV9TVUJTVElUVVRFKSA9PT0gLTEgJiZcbiAgICAgICAgc3RyaW5nSW5kZXhPZihyZXBsYWNlVmFsdWUsICckPCcpID09PSAtMVxuICAgICAgKSB7XG4gICAgICAgIHZhciByZXMgPSBtYXliZUNhbGxOYXRpdmUobmF0aXZlUmVwbGFjZSwgcngsIFMsIHJlcGxhY2VWYWx1ZSk7XG4gICAgICAgIGlmIChyZXMuZG9uZSkgcmV0dXJuIHJlcy52YWx1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGZ1bmN0aW9uYWxSZXBsYWNlID0gaXNDYWxsYWJsZShyZXBsYWNlVmFsdWUpO1xuICAgICAgaWYgKCFmdW5jdGlvbmFsUmVwbGFjZSkgcmVwbGFjZVZhbHVlID0gdG9TdHJpbmcocmVwbGFjZVZhbHVlKTtcblxuICAgICAgdmFyIGdsb2JhbCA9IHJ4Lmdsb2JhbDtcbiAgICAgIGlmIChnbG9iYWwpIHtcbiAgICAgICAgdmFyIGZ1bGxVbmljb2RlID0gcngudW5pY29kZTtcbiAgICAgICAgcngubGFzdEluZGV4ID0gMDtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVnRXhwRXhlYyhyeCwgUyk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIGJyZWFrO1xuXG4gICAgICAgIHB1c2gocmVzdWx0cywgcmVzdWx0KTtcbiAgICAgICAgaWYgKCFnbG9iYWwpIGJyZWFrO1xuXG4gICAgICAgIHZhciBtYXRjaFN0ciA9IHRvU3RyaW5nKHJlc3VsdFswXSk7XG4gICAgICAgIGlmIChtYXRjaFN0ciA9PT0gJycpIHJ4Lmxhc3RJbmRleCA9IGFkdmFuY2VTdHJpbmdJbmRleChTLCB0b0xlbmd0aChyeC5sYXN0SW5kZXgpLCBmdWxsVW5pY29kZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBhY2N1bXVsYXRlZFJlc3VsdCA9ICcnO1xuICAgICAgdmFyIG5leHRTb3VyY2VQb3NpdGlvbiA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0c1tpXTtcblxuICAgICAgICB2YXIgbWF0Y2hlZCA9IHRvU3RyaW5nKHJlc3VsdFswXSk7XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IG1heChtaW4odG9JbnRlZ2VyT3JJbmZpbml0eShyZXN1bHQuaW5kZXgpLCBTLmxlbmd0aCksIDApO1xuICAgICAgICB2YXIgY2FwdHVyZXMgPSBbXTtcbiAgICAgICAgLy8gTk9URTogVGhpcyBpcyBlcXVpdmFsZW50IHRvXG4gICAgICAgIC8vICAgY2FwdHVyZXMgPSByZXN1bHQuc2xpY2UoMSkubWFwKG1heWJlVG9TdHJpbmcpXG4gICAgICAgIC8vIGJ1dCBmb3Igc29tZSByZWFzb24gYG5hdGl2ZVNsaWNlLmNhbGwocmVzdWx0LCAxLCByZXN1bHQubGVuZ3RoKWAgKGNhbGxlZCBpblxuICAgICAgICAvLyB0aGUgc2xpY2UgcG9seWZpbGwgd2hlbiBzbGljaW5nIG5hdGl2ZSBhcnJheXMpIFwiZG9lc24ndCB3b3JrXCIgaW4gc2FmYXJpIDkgYW5kXG4gICAgICAgIC8vIGNhdXNlcyBhIGNyYXNoIChodHRwczovL3Bhc3RlYmluLmNvbS9OMjFRemVRQSkgd2hlbiB0cnlpbmcgdG8gZGVidWcgaXQuXG4gICAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgcmVzdWx0Lmxlbmd0aDsgaisrKSBwdXNoKGNhcHR1cmVzLCBtYXliZVRvU3RyaW5nKHJlc3VsdFtqXSkpO1xuICAgICAgICB2YXIgbmFtZWRDYXB0dXJlcyA9IHJlc3VsdC5ncm91cHM7XG4gICAgICAgIGlmIChmdW5jdGlvbmFsUmVwbGFjZSkge1xuICAgICAgICAgIHZhciByZXBsYWNlckFyZ3MgPSBjb25jYXQoW21hdGNoZWRdLCBjYXB0dXJlcywgcG9zaXRpb24sIFMpO1xuICAgICAgICAgIGlmIChuYW1lZENhcHR1cmVzICE9PSB1bmRlZmluZWQpIHB1c2gocmVwbGFjZXJBcmdzLCBuYW1lZENhcHR1cmVzKTtcbiAgICAgICAgICB2YXIgcmVwbGFjZW1lbnQgPSB0b1N0cmluZyhhcHBseShyZXBsYWNlVmFsdWUsIHVuZGVmaW5lZCwgcmVwbGFjZXJBcmdzKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVwbGFjZW1lbnQgPSBnZXRTdWJzdGl0dXRpb24obWF0Y2hlZCwgUywgcG9zaXRpb24sIGNhcHR1cmVzLCBuYW1lZENhcHR1cmVzLCByZXBsYWNlVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3NpdGlvbiA+PSBuZXh0U291cmNlUG9zaXRpb24pIHtcbiAgICAgICAgICBhY2N1bXVsYXRlZFJlc3VsdCArPSBzdHJpbmdTbGljZShTLCBuZXh0U291cmNlUG9zaXRpb24sIHBvc2l0aW9uKSArIHJlcGxhY2VtZW50O1xuICAgICAgICAgIG5leHRTb3VyY2VQb3NpdGlvbiA9IHBvc2l0aW9uICsgbWF0Y2hlZC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2N1bXVsYXRlZFJlc3VsdCArIHN0cmluZ1NsaWNlKFMsIG5leHRTb3VyY2VQb3NpdGlvbik7XG4gICAgfVxuICBdO1xufSwgIVJFUExBQ0VfU1VQUE9SVFNfTkFNRURfR1JPVVBTIHx8ICFSRVBMQUNFX0tFRVBTXyQwIHx8IFJFR0VYUF9SRVBMQUNFX1NVQlNUSVRVVEVTX1VOREVGSU5FRF9DQVBUVVJFKTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblxyXG5mdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG50eXBlb2YgU3VwcHJlc3NlZEVycm9yID09PSBcImZ1bmN0aW9uXCIgPyBTdXBwcmVzc2VkRXJyb3IgOiBmdW5jdGlvbiAoZXJyb3IsIHN1cHByZXNzZWQsIG1lc3NhZ2UpIHtcclxuICAgIHZhciBlID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG4gICAgcmV0dXJuIGUubmFtZSA9IFwiU3VwcHJlc3NlZEVycm9yXCIsIGUuZXJyb3IgPSBlcnJvciwgZS5zdXBwcmVzc2VkID0gc3VwcHJlc3NlZCwgZTtcclxufTtcblxudmFyIGljb24gPSBgZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFTd0FBQUVzQ0FNQUFBQk9vMzVIQUFBQUJHZEJUVUVBQUxHUEMveGhCUUFBQUFGelVrZENBSzdPSE9rQUFBRDhVRXhVUlVkd1RHeDVycExPOFlPWXgxT2cwbHkyOVg1ZXpSNG1UMHRpamk0ZVdKOTUzS0duMUp4czdxQjl4dmZEL1VzMGdkdXU4eWVoNEhPcTc0ZEQ2NDdSOTEyNTZlU3orajgyY2J2Zy9kU2ovTHVMNzlXcDZ6Q2YyNEtOOXhBTkdSQU5GNTlkLzBXKy90YWEvOGlOLzNITDl1T24vejYzOEJpbDdsM0c4NFRQK0ZIQjhvNUEvMGk5L1pqVSs0N1MrdnE4LzRReS9TNnc4Tyt4LzVScC93eWc3RzJUL3MrVC92TzIvK3F0LzFxcC9xRFYvSHlEL2tpNCs0UjcvcW5ZL3R5aC8xR3gvcHRVLzc2RS8yYko5TGQ4LzR0MC9weGUrWHZOOWlPcTdyQjAvMGk4OGFSay82cHMveisrL25hTC9tYWIvbUdoL3BWTS93dWI1bUdkK2ZBRU9oRUFBQUFnZEZKT1V3QkV5V0tBNDdFS0pobkZsdUdBNmwzSDY3RHU2Y3JkTk9YczVxL0k2NXJjUWJmQjlBQUFJQUJKUkVGVWVOcnNuRTlyNHpvWHhpZE9HOXROUXFCdlNyTEtlS0dGN1dJejRKMFdnU0N1RGMxczd2Zi9NcS8rUzBkMnA3WmtkN2kwU3NaSmgzdGgrUEdjUjQrT3BQNzQ4VDMrNHlOT0RvZkRLWTIvU1l4Z2RiaGNmbDR1bDlNM3JZOVpwWmVmYkZ3dTZUZU1EOGRKd1BwNVNiNmw5ZUZJTDV6VzVURG9XckVjMzV3RWp0T0ZEV1B4akUyYUpNa3FXYTNXNi9XZXZ1aWdQeVZKK3RXbmdUZytIUTU4UG1TRFFscXZ0NUVheCtqSUJ2MlVZN3VteUw2dTBKaU1CSzZEcEVUcDRLcW1ML25nWDlobndjRUpZbDhUR0lWMUVwek9FYU5VQ1VCcUZQd1BmUlgwVzhHZkZTUEdnWDI1NUpDY1Rwd1VCeVZZMVdBVS9GSHdMeFJXVjNSZElZR3R2aEl2S3FvVkkwV3Jpd29HSzFDRHZMaThKRG91c2U1TDhZcVQwOE0yT3ArdlZGT1lsNTR3Sis1UGtwcGtKVWtKWllsaXBOOVJWMU5lNjlVWG1DT1Qwelk2WHErNEtpcDdHRVlHbUtaVnlORjFnaGo5d2h4Ly9aZmx0WFFZVEUvYjh4blRVZUZyMVI4MkxtN3Z3dVBoNkNnejlqcitUVng4TXQremNUZ3QwdzZJazMxMHhJSlZKWHhkVWFxZ3NJekgxdzZ0amxla3hyVmRwWC9GU2xiN3pXNjNhK2xydDN2YXpHOEpGaXFIVmEyZXdPUUxsUjcwVzFvWDU4WGxoU2l2N2Flckt6NHhVdmQ3UnNlOXBXTzMyeHhtL1ZmRTZUbzY0eXQxS3lFc2dVdDhja1Q5OUdEc0hVcEw2b3E5RWFLVDQrY1dZNXdlTnJ2ZmJadGxOd3FMZmtwY00wbzhYdEZNaFpsUlVUN1lZRExLRXRtaHN1clFKTk82UjBzRUwwYnJrM0ZSV2UzK3lkcE1EdmJsenBEdG52WXovU1BpaElZRnpIUkZZWUU2eE1hekJuSldZVHlyaHNyaTR1cUVmU0VTUFgrV2RjV256YTdOYmplbUt5WXBWb2IvTWw1WnU5dlAwY21NRTFhQnhaWER1U3BkS1dTR2xLMHF4VXF0ZVN4VXBoQTdoTG9Pc2VkbldWZThZaVY0eTM0elRZa1g5YTRiaFhlanRiZ0pwOFZRY1ZtSnVEQTRHeXA3ZDJLOFRGbjFvR25KV2JFanFPNXl3bkxFNStpSzhtR3lFbmJGbE1WMGRXTzFHRXlMbWhXZEExa0tyZGlURzd5MmR1UHZzczNRV3gxcVZMVkxTeFppSndSV2RPUVR4SlhzZDlxckdLdk1Ic3pubjRKb2NiTmljNkI1S1dXNXdsTE1CbWJEZXNqY096TjRLWkxqMHVLS0Q3dFdjc2xjVklKZ2lMYmkxZmFzU1lrM3AyV1VKVHNPZHNxcUhHVkJ3OUk1cTdCUWNWcDBYbHhZWEtkTmE0VGxxa3A4L3VOTmkwVXJ6dXBxYXdzTGQ4Y1lxcW9YU2tIT3F1MEVENVNGMUFzaFFvMSt0Unl0ZU0rRjFSaEdqWHkwb2l3WkxVOXR4V3dkS0VocFRLSUlqV3YxcERVUUhHcFhXNjZ1VUdmVFdpOFdJazVQZDZBbzVWcU5ORENHcTcxNzBXSXg5SXFGcXE0aXVYTlVWeVdyOTVSVkRlWXNTS3F3UEV2U2tyZ1FMY1hGaEhXL1NUejhUMnVxejlES2ZId3JQVmlzTVAvR1NWMHRaZGt4dnE2cWdmNmZ6dSsxaFFzb0MrbXdSUWQvUGk1a1hPbm10K0poNTNmSDRta0cyMjBtL2dPU2gwZ3B5dUJTVlZoaHVOeFJzYlJmaCs1c0NIMUxDcXBqdk5nMzlrSFlyTGlJY2ZFcVpId2FoNUR6TTh0YmsyZ2xiQmJFVmdIS3FWQU5NeFZpSnp2QXBXRmQ5d09XY25nOUZTckhRdExwYVVKZGdGYThldXFIaGVFeHplV3B0UnV6TWdxemdwYU84YkNsVlZYdWhvWFNWVDBrTENFdHdVbyttRzJoeHdWb3hldGROaFlXMDlZa1hVRlEzTElNSjFPSkdQSnlGb2lxVlZyRDZLNlZwU2RDcFMweGxxakVkRDhhMWhSYThmWXM4RGl1QlVyUnBTV0YxZS8rRGJTenJDcTBZcGFhRGp2Mm1KOVd1dGxsOXc4eE5XS0dwTFQyNDJnbDBmbkRFc1JEeWxLa3FvRjJWdTI0Rm94WWNzR2p5cERRRWEzbnBSVnZSbGxXdzhNWFhXR1BwSlZFMGJYdldDYWQyc0xDZmM5eVprU29xa0kzc3V5bGpuUXJyaW1PaStRNW1wbFd1aG5wN3pLcVVtMmxvNndRbHFHcVF5Z3N0ZURCb0FGZnVXc2RwMU9xdXUrODJkQlp5b0t1UmRocjNrcWtzTWJTb3Y4ZGphOGp0WlZzb3lGbHllNkRyU3d0TFZ4YnlkUUEwNWhxVzFxT1oxbXJRMUdFTkd5eHg3eTBLS3piT0ZnTno2YWpYVDV4b2dPKzJqMEg0Rm0ydE54ZXFaWGdCNVNGM0pRRkJuV3RlZlBXMkRKc1ZMUnZSOUtLazRHZ3BWMUxTUXYwSGpEY3doOENwVGZDUUhQR1dKYW1wRjErenJ3MTJyUEVsRGdoUVhCYTJQVjNMRmM5bHJJd2JDdGJzMkV4Qk16T285WkVxQ3RRVXBMRm1PZkg1OWxXMWVtWUFOKzJyYjFzbkVEckhXbTU2UUU3dUFabVExaUluYjNRa2FURWd3aGdpSWdQTkNldGROeHFwelVtbjRrZXhGaGF1T2RiWURWdGR3QXI5enpiOEphaHlxU3dDanRrUzR2d3dYL0s4Mmc3VDM4cm5xZ3M5UmYzMFM1L3hYOVFsaE8xYXZOeWxkVnplS2VqYktwUVNvc0k0NkpoaStSenhhMTA5RG9hakZzMm50WWZwTldiRUhzdG1yb2ZzbVFaRnJENURrMkxDSk5ucGtXQm9YbE1QaDRKcTRFTkc1NjN2TFRWQzFxZ0R1dCtGNzUvNUFpVUlmUjM2ZXI2V3k0VVJycDViQ3NaQmF2cGIyZmNSdmEzK3RxQ01iN0NUZyt3NnA4cWZiOE1rZWJsbXBhd2VPWmJsRmw1bktQUkhIdVc0ZmorRnNoYmVJZ1hQUEJRZ1NOYThpd3BuQWp0SWpUdVRvQnB5YVcwR3ZQWUZsWFdQWVRXaERuUk5KY3gxcnM4eXJDMFpmV09PNENHQTVnTGtXMVpySjJza0FsQldRUGw1Q1hjdHBpeWZHRzEyY2lWejBsV0lqWkxhNk9zeWozWFZ0ZnZHNVltVlZpR1phMTFwR1VSRVVwRmVwRFNJalBZbHFleUd0WGZtcEszc05VQXRHajFUbW5CM3ArN2FXaU9OMWpXM2tsSjZUb0V3cUtvYU5wNmlQOEtyRWE1L2RpOGRiTG5STnhybDFaMjFKTExSSmdkM01NenJydXI3RTZRZVFCWXBDUlJNa1BPOGl0RHRiYzR0bU56QmdadnczS2I4QU03UEVKYm1oWFlNRVNnajBWMHlESTFtSE5wbGNkZ2Fma2JQS2ZGOWhQSG5BMGNXUG1BckdWMWFjQ0p0dDUrWVFIOXluWXNndlM2RURsbFNHblJLQi9zOFFFR2IzWXh4czZKZzVZRnR5eUFyQXBuYlNqUGRQY1NLUUxLVWdidmVGWWU3dkZCMFdGS2Y2dTNrWWhCOXdIMmxqVXJGVXJyb2UxQ0k2cU9HR0VSaEZDZkUvOElsVmFZc3FaMGJOVEtCMk9WSXJCVGlmSnk0Y0FSM0hjV09oS1lHMGQ3TStGYzB2SlRsbGQvQzg2SklHcnBKUS9vbGFxTFRYVnRvU3FzUkdwV09UQzVtM0RGS1RGUTNMVkNjN3lYc3RwK2YydlVuby9KVzA0M1hzYlN1aHE0a0RKMDdoWnVyTUpBT21CWGlsb1pKaTNmQk4vQ295TnNQekdkc1BLeFlabXp5OEt2c0s1RjlXVW9rMExYSXFDZmJDSkRybGpsWXBSaDBrckR5dEJhSjA3Umx1TmE4SmozVVYwaWY1YjNwdTJEcEk2eVlNQXlqUVlyTWhEOUNwVldIQndkVkgvcjl4UmFJTVRiVFJvQmFyOWFKV0tzK0gxWFNxeG44SnBWSjJkRGlRckJLRXFBc2dLbEZiYVFobmxyZENWZXdUYStWaGEvWDg5K2lVTU0vNDlFQUNzS2MvSWR3Zk1OQkxSSWtXdFl1ZmI1SUdreFpiRTdBdE1YaDluQWVmbnQ2UDFFck5mVjhpWVB4bWQyUWVLZFMzdHhzbHBUWFBKZVUxY2c1UFJuVUsvK0JCOUxWRE5JaSswYnR1MmYzR2cwdlpGbmJIUVBvbUszVTBRZ3JhN25qMjZJczlzL3h5T2xVeFJEWjlkMEtMWGpsZWFsUENzblFkSksrQ1pybTgwdzJpbVZLTHFCL0hvS1Y5Vzdvb0s0b2tKMXN4Q01XVVFsZDJRYkZ2QXJ1cGJtclpwVmdMTCt4eTZEWmZkd1VxekxOUzF2aVdYTzlScHRrMUU3ZTF4ZHRBYVZiU0hVMjZvQXdUMDNaaVdabGJRTy9ac1BGTmJyTGJzTkg3cWQwZ3pVNTdmUzhWbWVYOVNrRlRqK2tIK1NiS05hbkdDVEo3RTYzdmdqQ0VZc291WkJSWW03T3pQNGtMNFdoZlhyOVhZYjNIK2VQamZlc21ZQ0xkNkp2MDY4Yk1QRXBZL08yQ2RtMUU0MHNxclFyVVRPeTkvaUdTeEZxd2xncGM5dk5VOWpLNUhkQUo0a0szVysrdmtJdCt3N3F6bUsrdjBHQzFRZWxoNDRyRi8vM3VUTjZDYk11VzZqODlhUGxIZHN6dEgweTdyc0FyR3F4TTVxK0JGM0JXM2xLMFdMTFJEOUxWN0FvdHE2WnpKdk5iN1J3ZlMzUnMySmxCYU5tbDdYUnBMdDhVaW9yQXB3eWtqSGh0d09DNFpVS1QvS1I5ODZsTEFvcllFcmRGN3I2M2EwdHRiZWR3T3BjUkhTZFhDWEFzWUcxZklqRGkvMjhLMURCWXZUYWx2djRPRDB0MFpwSy9iL0pSdU1sck1KVGR3OENyTzdwYXo4SlJTVzBGWkl4OVRhOGhtcHJaQnVDYVdWeS8xQ0dMR3N1SzU0bGNMZHBiSnk3em8wc0xodlpkNzdZZzA0TkhKZm50WTJNZzFsZ25ydFB1RHJTbG9TMStOekdncExKb2g3Z0xJbTk3ZENHdUxiSTRFNzlvNi9XN2hJcVZtVnRBeDk2OUNHMVUrblBuT2l6QkMvRjZlMWl0UjJEaGxZNXBqdXFPMVpVbG92cTNCWWdsYnI1Zk9OWDM4cnBDVytqdXo5SE9UMHNHekxLcVZ4bGVMdGExb1FGdmV0VzNadjUrbEJiQmYrSFF2VXR1U0Jvai9Wb1BINFVxQXFjK0puV2c0c09TZTJRY3RFZmRCbXd2MUVQOXVLT25VZUMyZ3FIL1lyU1lvOS9KS1dDNHZUdXMwZ3JBbnBOTEFRWWNKeWxzOWxibUpES1EyZVBsN21nUldVdDV5WTJpeE5LM2srOGdQSlRzQ3lkU1ZRS1V4U1dXK1BYaHY1ZlZnaWI0VjJBNmYxdC95bGRSd01EVTVUUnZBeTBhRXMwY05Nc0dicGI4bGZudEUweTlKS29pTTc2TzRJSzdlRE96QXNodXFOS2VzaG5RbVdTNnYxdHEzeDl4UDlYWXZZc0t5T2U4bmVtcFlzUUVYTXorRkY4MitZVnR1RzJ0WnRjZCtpeVpSWVc2bnZLY3RRa3VNbG1VdFpwci9WaHZzV3BiVmRqbGE2UFpaY1dRNHFLQ3Jic2RoNEs3MHl2RmJXNjhDYzZOK3lVYm0wYlRpdDViUVZyNko4dU4wT0RNdFcxaHVmRG4weVBOdmQrVFdzTGY5RXFoWSs3TE5aMk9XVGwzNy8yTzdKNkxoZ0FYc0xnY1Z4dmM2WXQ4enZTV0tMeG1aSld1bnpzWFJ4bGR6YVM5dXRjaHNWZXo5NEsrdjExK3V3YndWS3Eya0ZySFk1V2pScWxXWWpoNmpGb0Z3OEExQnZGcXZINXlCbERXbkx0MlVqOXFjYlJxdmh5bXIrVDl2WnRUYU9aR0c0bTUxTzNNM0FzRE9FZ2FFRFhoanN4cjZKY1h4aDNBS0xIUW5GRGs2OC92Ly9aYXZPVjUxVFZmS0hwSlJreFVsNkx1YmhPVytkS3RsTzlWRzBmR2hGcmFqc3hpaWhmcWk4Z3JQTFVwcGh0YmhWOWxoSDR3ZE40ZmpBM1ByODhQY1B2Y2FoWFFaZGdSb1ZzZXJVYUhFWmlsdUdHZDVQN0JEMFRxZXlGcTE4eG44WXJkSHZmNGZtWFdKZDFvTlJnN1dqOHo4UDNXQTl6Y21zbHR3cU85SnliUU1kT0Q2b0V1Ly9sWFJZMFg2TVRJRUVDaTRkWWMwRjFEemZRZHk4ditVSjRiblU0L0ZEYUVHbmxaZ2xwSDdzb2c2TGFIV0dSYmptdVppSC9hMzZKcWZHSmJHS1lEbTNQdUpETVNIaENkUi9iUmY2UTlYZXp1VDdycGRaOC9aSzdIREhndXRQVG9MMTdRTm91ZVVodnhnNXRBMnpkRG00STJhN2ZtWElhdVY1M1hZL3NRNTFhTVdxM09IZHV2OFFXRE9KTElYcWg0NzAzVXlmdXk2TFF6SUxlYzNUK1RCN1A3RStxeGFRcW1PcmlOY0gwQm85eUV2VmVCNmNtYlRheGNCMkhWZlNiQllBdzJKTTdicHlmd3VMY0ltSnRSd25pUVdYNnR2UXRENC9TTmRPRzZONmNhUDdkam5jK1BKNWdNeHE3MDZ2dVorNFpMZVlWU1NXZ3pXNFc4NnN6SzZNWFRkcldqdDRkSGs3blpnMW44L1Z0QmhYSSt4dmpjL3VieTNKcW1XbWFTQ3hNTGFHZG90Z2hiVWczNVVJTXMwdzF5bmVkMmpXZmVmTTBwM3B2R1VQNHFKWndvdWNHdXNDSkZwK2ZCdjBrL2hHRHovMFl0RHM4ZG5lS3FDYURHS1daTmRUNHRibGpyVFdkYmhNcGtKbVZUMytPaVF0QjJ1bTdqbmJ4WTBxUUoxWVBjeWFpMXk2aThqMlcvdDJxWllScVhFb3Z6cFlWUTN1RnBvMWk3WVpRdjM1ODZjcFFXOVdsOTIvWEdhWjZESzVkYjQvTFRteUlyR3FjSHdFTGM0c20rbmNKRVNVaG9MMUZCcXVyRnBQNnQwRjdRdkNqRmR3Rmxxc1FXbjVNa3hXenJ0TXR5Q2dKdTR5aEZtbTQ1b25icFhuYjFFc1d4b3NhMVdCdElhYUV3Rld2QlpVQzV1SUZkTHFEdXNZVmFFcVF1c1h2VjcrVE9mT2srQllOZTIrWFlpODhtT29sSWVBVDIvZ2hFbHdOck9vZXBubFdSM244NHhobVE2aTlmVmIzRjJOMDY0ZGtTbXpDajhlQjNKcjlDRE5sZTdXZDdzd0QwNTJQOUduY0Jtb0RNUE0rRFRQMy9OSnRtdzhvbktabXdpNUZ3Mmtpb3FPb2hpR2xvY0ZidTFVdHhEU1BWU2VPWHFVNFRGSExKdjE0RllON3hWZTJpMHN0Y2l4YWJYVU5WaXdXSlYzYTRoS0ZMTm1paGRUd2lmQ0tEenBVWVpIQzB6YWh5d3RpSzE5VklEcFJNaU51ODBySlphajlmc0F0QmpXVGpVTU85MnVhN1h3N0Jud1NPcVltcFZ1MitBNk1iemJseHYzZklkbHk3Q0FNZ3hqaUE0Q1lhbUpiNVpNZmdHVlhMLzgwc01zVnF0bFptenRJSlp4Z3hVQ3E5THJRYzBLY0czOHVSbWdFbzFaeXFiSjJhTTdMTWFWWnBmczNjeXp0UEN0RlJtdkt1NUliYnFIQ2dSYWcxUWl3RkpUbjJHbG1hbkk2bStXK0hXTWFDVnVIWmxXM2RhNWkxVFdyRkNESHRWbXN4bUFsb01sUVRXVFhRV0twMGtVVlNIZ2Yra2Q4TWZzbkpqMlhFZmNDb1R3Mmt0b1JmdnRVZU1lRXFzaXExd1pBcTErZjZ1S3pPSmRQVjJDa3hTUzU5Y1BWbm9rWFZmY2NkV3YrSG1TL2lWWSsyWFl3NHEyUlRXcVFvZTd3N1FaaGhhWXRUUHJaUTNKY3VKSEgxaEgvN0RoZGN4Rmw0dzcvNWRKYTlwcDJPZFdnOHM0Mnl1TmlzWHlveWN0YjFheVV0WkpCWEFtaEl0cGRZU0ZsRUl0SmxIL3hJdnJvTmNmZDMvK2RrZXZ2dkt2V0V2M1JkTWFORDBEbU1XME5yMW9lYk55TGRYRXJuQ2kwUmtXRDdhTFdKMXg2NC9mdm43OWZJZC83SFpaaTFlMXdoUnQ5MUZZVlJtemVycEZaWGkyWDVqSVY4YldEVlo5TEFXVWtNbzFFdEoxQWF6N1QvZk9yVmV2VlQzV1ZzVWI3ckp5amtpeFdRZDM5SElMelRKTmVrQmpyaE9GcXhlc1NLNDR1cDRVTG9MMTZldHZkL3RYdlBkczA3MnFraW9zS3FhMWtjWkJ4UEs0dXROQ1dKTnMvY2sxSG92ZXNDRG9iWFRsTm0zbUhoYjh4ODZ0MnQ3SUNiY21vc0N5NmI3aEE4MDY5S0ZGWnNWYTdWU3E2eWVUdm1WWUdydEVNTnVpNm0xbk1NdjkxNS92S0tkcXVsVFN0NXR0R2RscFVHRmx4RG9jRG85MzNXaU5IdEtFdWpBV1BjMHFMYXU1anE5b3dSaGdlYmQwdUh1cGluUWJXYThIcVhVblhBY2dCYXhXaDQ1dXhiQW1xbGRRZU9pRVI2OHlMTXNTY1Nsazh6cGRXd3N5aGdXVmlGcFZ5elRaay9XZ2xLQVNDNnJ3NEhGMW94Vmd0WFFKQTV0VmxvS3ExRG12cDhmalhHMXlDU3hQcXdwdUtiVlVNeG9sMW1hejRYVEhxUkJqeXoyK2RLRTFlamdQQ1l5eWh6czd3Z0pTWlVsZmt1eWlzclNHQlZpK2c2amlGV0dWcUVXMGdsZ3FzQ0N5d0sxT0tlOWdSWTFDV254Y2Z3dUIxeGtXYzRJbmNUV2EzWWdqTlJBS0Z0R3Fscmw5MGNpcVdDek1kdUFFbzFOdWVWaVpPbU9GQkp2RjFRWFdDTTJDekVKbXgxU3hPT2FmREN4UEN6alYwR0FwWG9YWmRHZXBDaDFYOUdCWXF3NjVoV1lsckd3Sm1rdHZzeEFYU0VXdFJHbm5SdE42R1ZqZ1ZwWFprcEVWWWRVYTdvZU45c3JCV3QyY1d6bXpKdHFzdUJpN1o5WTNnQ1UxU0pYSWxxWHRSQTRXcDN5eUhveFE4UlpXQ0NzSzlrRExmWGNyTFE5cmtZWjVrQ2dOK0s1bU1TeEdGcXFSN0txaitJSkxCQXR6cTFxbVBZUGR3cks5YUpnSG9RTEpyTU90dVFWbUpZamdYT2dpTk45TUJvQ2xISE9VeXJpejUrZzZ4ckRBcmFnT3czS3drUFdORkNFdGNnUVZrc0xyNlRaYVpGYjdLWlI2WjVhRE5mYnYvaXI1VXFvcWxHcXNmWXVxNmpHQmhiUnlOMVBOUEZnWXM2UUFWK0h3eEc3TExRZXJuVS80YnJIQWk3OU8rcGhWKzNPczFRcFZpZGtQdktpdmQ1Y1VWa1JMYm5wVklsWmg1OEdEcWtHc1FqcFhiN2YxOGxTR2h0V0NTakJBbXFqcm9ydFpZNCtwUnJFU3dVcUZTNm1WZ1dWcEZZbGFHN1Y4UHRpOElrajBaWFhqbkFobUxmUTVZVkRxcVlEcWwxa2UxampRTXJ5NEVvL1k1M1BZNTh5aURzSnNNNWdHeS9idUI5MWZIWWhWR0Rlay9PaTdBV04xa2hxa242RllQYzFDWWd4cHJIRFJVc2kycVZsWXdhMUNaOWFHT3l5bjFTRmFPNGNHUytONlc1MXVjR3YwZlRHeFhsbkJGZ3R0RnovdkNzdmZMR1ZhNE5oWWNDR3lZNjJ2M3JBOHJPQlc2TEEyMGpVVWVpM0ltMWhoS2d5azRQcDI5YXJhd2JKam9wNDNPdDBuOHJORkQxajBNVkJBeXJIU3VQeDNab0tFYW15QnhiUUtmVGRIbGpnRnB4VXZuaTBxS2NNM2g4cU4xWlgzcWhXc2lTcS9Kc0ttWVBwZi9ic3JySkkrNmhmdEdrdGRjb0pGUlhsc05ZdHBGWGFKWXpaR0QzYnh2REppblVnc3I5YnB5a3FNekdxVVBuU05xUGtmVGpyQzJxY2ZrRnlPcFN4cm5maXlPZkZyR3l5a3BlZkJUYUVYejlFOHVKSitWSW5sSTR2ZHVvSldCR3ZTTEs0WkE4RVNaUGkxREdWWmNwTlJ0cG9GdEV6UFlCcFJuQUx0cm93cFFjNHN4SFg2Y2tVbE9sZ04rblFCazlhcmgxbDdPckxBYWxXVFhKWHRacUZiVVM5cWJrNGMxRVl5TFFrRjF4dFZJTVhXKyttS1NpU3pDRmREbHd5NVpqQ3o4TlBZV3FqcHlNY2U5Z3dzY012Y2RpNE1xRGl3YklQbGlnOUpyUURXNlhMS3MxbEdML3UwU2RCMU4ydnZ4aGdlbHRXZVFPRm5PMkYvQVc3VjU4ekNmcXN3OTd6MGdyQXQzRkVzWlBVT1JYZzZnVnNYYU9uTWFvU09NbzEvMWFoLzFuU0h4UWN6NHhQSjdlVXpuc1N6czJaUkpSWkYxTGRUOVczT291TEd3VTJHRHRhN3czYUpGcG5WaFBKckRKN0cvZ3dmL2N4aXUxZ3hPZUdvNGFBUGZQZWZuSHdlbG5lTDJsSGRpbTdPc3BJcXBISHk0LzM5SWkwZDhFMnNVZmhCTkF2MGdJVkE5cUtYeU1XbzhNOFF3TWNlK3VNU0xNb3R1eHEwMnd3WnJ6d3FZWVcwUEt3THREd3NCNktoU3hOVUVvS05xVlA0VFZkWTJSRnd1VkhUUThaRldPQldZZTdRbTNWemJwSERuVHRPaEcvdlBOYnZwM08wUnQrYmhsR0ZjbXpFcHNZODRjZWdzT3p3UllpVkNJOHJZSG0zSGpuaUR4dTdNYXJNc21xRnhEb0pxYlc3bm5PTFlaRllHbGxqWnNmbXc4dzZQNjZBQmJTQ1ZYYi9LckNLcHNGUWdHVFd5YkZhcjgvUkVsZ3Rna1hORjN6cERPdlYvYysvd3RrMmtsKzkxbGZBOHEreGVUUU5WblRYSytNVjhqb1JyVGNReTd0MVdyZlQ4ckNtN3JERXdoRkNLeVJaRDFpdlJPc1ZUejdDVTQ4SGpqMzk0MnZNZ3R4NkRIdFl1Um9NK3d6Z0ZkZWdFd3JhQmpEcnRQWm5lMjQ1V0ZPRGE1RXlXMWhpbmMxNkpScEJMNFdJa2ZrVEJuN3pjaDJzVC9kLzNsVktMTE16R3RMOXplek1ZTHhMdUs5SnJuV3JXNlB2MHltZ212cXZMUU9Mazg5RkgxaXZUSVVoQVJPdEdQOFMvK1hybGJBKzNWTWw0dmJWSm9jcTZxNXdJblMwM2tMQ3I1bFc5cDFjRGhaeWltdXhhVExKejVyMU1VdFhuc1lrSE1VdFAxNnVob1cwSEtlVmVRVkkzR0N0UXNDLzI2NUJ4UElwbi8za0NqWnJpbktkSTdZSTBIcVpKVndVTUV0SWYzY3RMS2pFeDQxZTU2UjNjbENzbFhnbFdnR2tkenJXYlpVSXNJRFY5S0piSWZTN3dvcE51anhlcm9mMTZTdlFTdGJQcWgxOVcwV3N0RmxyTVd2cmpod3RoQldBWVg0MVRXdCtOVTAvV0ZjUmVuMmg4K1VXV09pV2JiSFMyeE9yUkt0M1VZcFRmdXR3WldnRldPUVd4RHhOa1Bra1cweTd3bnJabnlVRXB4OU15ei81NXdaWVFDdThTa1plMGhERk8rejV1YTdoelhnbGdZVmprcUhsWVQxUFkyRHlwU1gzaHpicmhWR0ZnOFM2eVN5aXRVbjdkdFc0VXpOS3ZaVW1wVms1dVZKYUR0WXpZOUswenJMcUN1c2w4UWlCdklUbjhpTWVmOTBFaTkzS1JMdFo1bVNMa09OcTYxdlRISzNSOTJlajF0UlkxVWlHNlRIdEFZdk5vWk10d3JyaklsVGpuOXZNSWxxNWxiUGFrMUc1cmtnSkxqZG1wKzAycGVWaEFhN25Ka242V0xKZXNPNEJGdklKR1c0aktnTDE4bzg3YmpUTERhQVZyUWREV3RFc3FIQ1p1TnFpWE9zdER0dHZFYXlwOGF0NWJrSTNrYXZISG1hOWhIS1RRRThvTVNsMzNBNHJkU3ZwR1VKZ1NYdmx6aTJIMVJhS01YV0x5akN1eFFTVVVxeXpXVkpzSnBoU1RNeXBvMW1mN2tkSUs0RFNlYVhicXpXdENZMVpBc3FQbjVxV2cvWDhqTFFJMnJUNW55UitubGRYczE1VVFPa3lOSmcwS1Q4NndMSzAxQjd5NmkxZTVkaTJmY3NadnlXOXR0di84M1orUFkza1dCU0hwZGtrWkJ0bEhqWXRRcjlVbGFDa2xpWFVLR3VJWkNsUktROFFiUWxVK2Y3ZlplMTcvZWRlbDlNVFhNbFdNbW1HSHFUaDErY2VIeDlYQjBGcEFTeG5XN1hWMTl1eWIxNjFUeFRaQnY5T0VrSHEydkxIRnY3SmVqc25RNHQyb2s1WmU4ZktWRE9mZXRFempkK0tpOHJMNnBjUjF1cnhNZENhL0RTb0dDK3RyQzZvNjQxUnNtSWJBb3ZPM244UGlNcWowc3JLZWk4R1Q0dFc3dnVlcnZZcmxrWUJsTWUxMnVFZ0JtMTVaY0ZMWjRCMWI1eVR3MVVQOGl5QWxSQld3Qk5lNkxYSWZPTUtvUFh4WVc5WTIvL25ZNytQaHREUG45OFBraEZVOWxYcHk3djg1Q2ZvYXJuVWNxcUp2S3pmTDk4SXQ4QnNBS3dlS2Z2cVRDcG9hdHVZUjQ1bk1XM3Q5ZE9kT24rUUxKcks3WnZWaHJxN3NheU5NTnJDQkRINTJTRXFhL1BFNk9sKzBVc01YMDhFYSt1bDVmaHdWVFg2dWNoK1M1VHhQNi9oRmhtOEZRc3NhMCtuY1BVWnp5Q2JRNjB0WVhCcFlLcTQvb2Y1M3hnakxGUldSNVRGb2tTY1UvTmdiV09Ic29NWEpwQ0Jnc2NBV0NOREM2S296ZTU3WDdmN0pPcFpiYnl1Z3JMRUJxZFFDVkdZZTJ4R1ptKzR0THljdHBaOEZEMndONit2WEZoYk1uM2JTRlJKVkVPVWhkcjZjSkVVN3BRQlRoOWhDdG5GU0NucldScVZWbFpyMXNUeGo1KzFRUVc0bkxhaVdYemp1K3hCeXRvR1VmRTQ5WjRnQmRjUVdJYldCNG1qRU5vL3lBalMvVE9Db3JvQ2V6ZGpLSXEyYmEvLy9lM2J6ODdwQ3JWRnZRc2Nmc2xCd2NkRFlQVWlRa3BTSUNvQU5naldoWnRFUjJ0Rjk0TXN0cStZdHlzcks0MUtHR0tGeG5WOWZmMlhodFdodEdxbnJiQXE4ajJRUDlzWU1JWTlVYjBmR3NBVEtJdlI2alVObi9FeVNNWVFkV1hzU3I4YWJjSDFXSGVJeTBxcnBodnI1VnNvSTJxeUNjcUhGUkM5cDQzS1U4S3JXZ3g5ZzdCdmVrMjA0N2ZIelNBeHJFL3I3RHd5V0YyWjBDQlVJZFF2N1ZwRld4UWFXVzBHc2V2cTlDeGFlWEd2ejRTMTVWdVo5eWdsYlBrQUdsVERZUmxhUmxRbXYvZVBVMTBycytFSlN4aFhON1RFcG9BNWROSnEyemVxcmM1dnJQMHZ4TUxzSk9iQ09qeDd5Q3BTVm5VQ1pla0VvV2taWmUwL1VWdXJ6NTVmUmJKeWptV0VaVVNsZ1JsVmFaRWhyU1daUktldGxLZ0dLaXVzZk85cFQyY2oyRlRWY0ZpZ0xYdW56SDdmV3dYakFzc3FDMGh0UUZxZ0tHR1lBU3pVMXJLanEyTHRhSG1OTFVNMW1BOHI3VlY5WEJXd2FrNEN5MmdMSXRaKzcvc3JucTc0TWlpVTNSUUtxNnkyTGR6VklpM0NxclpQandzRjlyWThqYktTc2dKTTIwaFdwL0FzcTYxUGN3aXgvNHpXd1kydkdyeXloTjAvWTJ3d0JsK3d5MnNyVGx4ZFdCeEpqbGpXQTJBeGFUVitEV3hJRG5XaUFsd25nV1cwWmUvczQ5dkJPTGU3cmdHMmhQcGhycDBBMTRJUkxJVG8wNnB0b2dkcDlUWS9nNVdWU0ZYYzF3T3V4V25leTkxTTRpcXhFckxjRG52bllGZEdXSUJNR1ZZUVRBdE04MjNOSnRFM2doMWZHSEU5UEFtc0hpU05hRnY1K1R1bHNxeHZPVlI3WHZXdElsbFpVZ0JJdUNuMHc0amF3cnkxckxsMThZckxmbUlncktiL29GYlZCRlFuZzRXK0ZVaDVXYTJJdFZ0WmJVQlJPaWtRUXU2REhYNDZzU1o2WUZ4YXkyR3dHcDRYbWpndmVHV2RGaGJTWXN0Z2NQY0k2RkppQUFBU0UwbEVRVlJRTklCWmFXSUdpalAzeU9KM3p1VUpyTTZWelhYd2VFdHRBS3dtbXI4dEQxYW9xU1lNNHVLRVB3bUcwTnE0ak1XbVVPQWl1QUZkQ2NRVXhoQS8yclhwTmJHcnZYZUJkWFZ1SExOaE5kdEQ4MGVpRlZHV2xDZUVaWHlMblR2VGdBVXJJTFJYMkkzaUk5SlVBVnRFS3kzVVZuU2hwcnJ3U3owRVZqS3J1eFhRNmNvUDRVbVZCZHBpTFhMUWxZSU8yY2NyRTBWVmF3YXhjTjZsR0ROVkpHalY0ZWlIOURiNXNKcmVacG1KaW5FQ2FaMFVsdGZXcGgrd2JDVmo5NFBXczRxSWtHaURpZlYyUG1SeDdJeXNyTUJ5WVRtdjJ2WlVaWG41TEhvZVdKZ2dyRld0d3JtemNyMG9xcXBWcmZBelZ4UjlhanVCblUxYnAvZUovbUN4eXg5RGIrNjlGRnI1ZEVWUnlaUERzclQ0YVdyUUZaYklrQnNFaWl0ZUNwMnlJS1FXcE44NkZDS1d5MnhZeVc2aFljSEtmU0JQYnZEQnQxalovbWpybUxBT3FwNnRrMlVSZ3lrdzFaLzZYZE0xc2FONTNobFlQcXdtSGtOblYwMndkbWxGQlIvY1haNzh4OUFpcmZoQUZWVmxIWjBhRnF5SjdZNmpjd2tmc3J6UkZkditrSTRyWDFsL1J1VUVGU1pSeW1weCtwOXc3R2dCc2NmUXllQjJNSzBzbDBhOXNpeXVWQWZoWlFYdGM2YXlGZ2Nta0d3R3ZiU2tlOXlkSHRiSTBsSXJVcm1iR1ZUK1pDSU5yR1dEQ0tQbys2MSs1SExPbFFWcnVxajZzaUtKb1VGaHlXQllBR3Q2Y2xoV1d5dCtrQU5IWGdKOVhiWFVyTHlpUkc4UWQzcnBKTnBLS213QXJNUUVlbFFrWlVtVWw0RjFoaDlpYjdRRnRoNE9DS0VZUmMreVdhRlZURkhDSzRwb1M3VEs1NjF1bVI3R0hGaWo3NHNrcW9ydGNHU1FsUUVtNWQzTkdXQmRYRnhxV3VTR0JoaENKVVJSOU1Pb29GR0x3Q3BzTTZoaC9hNVRzQVlvYTNUMXIyakxUTGJOVFVEbEU1YTladU56d0xydzJqTGhBUnErWDg2d3FEZnhyTlV6TW5DdW9uRDlGamg2RjgxakZxekxCZUhrSGN1TFNwSUJOSnF5dE1yWjVlaHN0QURXNHdaRUZRNEh2M0lwbHlESW11aVArRkZkV2JCK3pNTFdwZ3A3Ry8yQWtTTlJGSkZaWFBPcjg4QkMzNEpiaW9BVEZzaTB3SEpCVkppUUplS2toVG9UOW91aWZtdW9zaTRBVnQvVlVWbU5kSng4YUxEWG1Vekwwd0tiaCs4YlRpamNyS1ZWSnJDRFVOR3F5UHN0cnF3OFdPT2JsTEhUbmtIYTVFQWNTOHIxbVV3TGFZR3FyTGViVWV3ek9wUlFoYmN0VkZiYzJIakh6NEtGRWI2aTVVS3ZrZUVUS004Nmg0R1d1NWxCNGJHWGxZN29jMUlKWG01OURMVDQzcWZPaDFWeHcvTGJtL1FNbHJJc3p4TkxLUzE3V0k4bk4ybjlHTWNTRVRJVkJoRytPSnhWVzJTV1dCYXMwWFJCVzc0cUx2dWNhK0VRVm83V0dlZlErWmFBQVRUREpCSXhRZGphUFNFeDVmZUpxcURuaVIzTkQzbkt1cnpiVnRHcG9JK2Z2cElKVTFqaW82em0zMGRucGFWc2hTQVNYVitVVDZuQXFNVVh6dXhzM2lKeHE4dFQxdVdDMVh4RVlCVnRzSWhmbFJMbThQNTgwZ0phUXJWMlo2aUsvall3bEE1dDZ0OWNBNEZ4OXJmYitYaDk1U2xMWndmYVdqV1ZiTHlzbkxob0huWEtrdFg1TE43UmFuMlB3RENGSW90OE5xakxIWmJaU1dUOWxoL0RQR1hwN0NDZFI1SGt3SFZGVUZsYThzelNzaTRQMzdMZDhZaUNIVWYvSVQ4VWVNQnZ4OWluMDg2WlZwYzlocFBwWFJYdm5vT2tZQUw5UWxqYXBSQ2U1Vm1sQmJSK3FWYW4waDFmRG5sb0o1bStKVFVnZnRJQk0wWWZ0WUY1eWhwZExYcDZvbjBNemUwV0Y4QmF5N3ZaT2FVRiswVGpXNWpnUlRKT2FZOFNDWElpY0hMN3hJTDNXNWxqcUIyK0NtYzRUY1RMU1V3R3d5cFJXbXRabm5OQmRMVGdoaUlSTzFQVXY4TTJzV0RCd1grTnpoZ0MvNGJCRzBtbG1iQXVmdHlrTXJza3l5QlBXR0JaYTdrdXk3dHpkUStFbGpMM3FoWCtrRXVJWTdZKzlyNGtQNUlHRjc5L0t4Y1dtSll2WldRNHdtSDV5cEt5bm9VS083UEhPMXB3czd2cGluSExwMFh5OTRjWENYaStneGd3aG1CYXREcVdkUHRNQWxZcDBheWt4RUVzeS9WNlBqMC9MZk50S3ZWb0pvbDJvdkUrY1JjWGhJd1YzbEg1Ty9oV0xxekxXV3hVOUpDUTBpcTlzTkM1akcxTnprdHJncjdsVHJpQ0hTbENTZEJLWHZHelY4RzBaZThOeklabGtoYnQyeVVWVmt3S0ozRnRudVhhRE9Mc2FuVHhmL0V0a0ViUk12T21kYlA0dzNGMTNHOTErYkRNQ1krTWhTWGpVcWFNMTBLWVF6a2ZRR3MwR24zRjVURmR1anJCMTZSaFpWUXB6MWRNV2Y0ZW0xeFliQTVsaEF1QWxmeGhSTFdHMTRjaHRFYVgwOHNqYVlXOGhTSXI0djFQd3VFVkt5bFl2elZBV2FQeFRjUktWZ2QwRmVJN3NDbzFyVEtYMXVUcWRuNmM1UUV0UElhQWIzZjN4OU9LNUcrTHFBM01oZ1Z6U0pvK0N3cFJWU0V5QkZwSVNzc0xYdk5vamFlM3QwKzN0OGZTK3FVSzUxdm9VamE3NzlLcFFTU2FVOGhlZUo0NEFKWU84YktKKy9hb1JpNXRZQ0RDa212Z1pXaDlIMzlaemZlM1QvbzZudGFqL2pZZHJTTWJlVUZLVmJlbEJuVnBiV1hEMHV2aFhjT1BKNlNrckVwdVdXWXBSSFd0Z2RaNlBwdCs3UWM0amk0MXE1ZW5wNWVYMitNbTBTUUlFMGFoYUZicExndlZKWnpzekcvNi95RHV0K3A4V0tNckhlSmxReEpEZi9jY1JHV1ZWZUlVbXF0OG1OOWZmU0Z3amIvUGIxODBLOFByZUczNXhLUU9uWW1sVDF6ZEVQckxaUGw4V0JjL1pqSnEyNlhYVmhtQ3U5L25yTzJLdU1ZTGJQNW9jZW5WZDM3Nyt2b0UxOHZyOGJSMjJHL3RGSGVrSGFzZjFDRjd4eklDbnByV0FGaTRQL1RaaXVxcWxMMHRvWnRCTUN5QTlmQ2c0K245OXlOd2pVYmpxWldWMWhYODh2UUZsMjlkaEVqZURuK3dEUFNvWEszZlh1ZkQwbi9ZTWo0ZnJEZ3JOb2xycWlzemhscGIycmxtZjRkck5CbFBqYXhlWUFMeCtmVHloVW1FTmxDSWc4NithL0hnSi94RkRPSHZmUkMrNWpKdnpmSnR3TnQ0M053NXM1TDlaWkJwU3RwbGtQUFM2akpHcjRkeE1qb3NxcXY3K2UwenlPbjErY2xkTDEveHJmWnc1ZEQ3R3dTaHErZjdiK042UTJDWjZrR3k0QzU3d2QwcWF4MUNWZ1JMUHpVdVBZM2ozajVHNzJ6R2wwNVV6MC9QMXQyZjNDQWVUY3YwVWlTUjI4cjVieVp5SjRJY2JZZ1lBdXRpY25NWFduZXVMUm0xRFRTVU1sUnczUmxlMCsrWDQvRmtNakxYWkRJWmo2K205ek9ONnZuNTVmbkZYZDZ6dmtnTGQ5TTc1VHBSeUtuaDZIQjNqSXUxZzJCcGFjbit6VEpTMHNBUU1rT0lXTGdZUG9Ubnc4UHJlajZmR1dUNm1wcVgyYjNtZEt2bjc1bkNlcUltLzNLa3kwL2lmbXNueElHQjNQMHBzS3BCc0xScnJkbEpEc3RZc3MvSzAzcEFYRVJjbXRmRDY2dk9CSE84N203LzE5N1Y5Q2FPQk5Hd0JHRW1Da0pJT0VLY01ISzBRcGJRK0dEM3dWTGZrZmovZjJlNytyT3F1czBBTnRGcUVxODJ5YXoyc1B2eTZ2V3JWOVZHMU9yUHRjR3F0bEE5eHEzZWZDdGkxU1ZSbm42TGNGZ1pnakVObkRydzhxTm9CY1VxVXN3Q3BFb1FmS0YvQnBEMEY4Q0tWS0VWTGYxRGZUdTNydWRiVVh0WVJYY3hCak5McVZaeE9IQ2w4azBoeXh1MGQwZDFpTEN5M0RMd0NBMFQvS0Z0TVZ3bjgzY2cxbDNjWXZsV1ZiR0NPL3VVU3grSFBxenAvTjJ4Z2N4UzFNcFR2aUY0ZDljVDBpclVTQVdzWkNrTVZzSjhoUUowMzBXb1FvdVZGNjMyUHBWbitSYnVmN3JlS0g1TVp1a0RNWlZnRlRoeXdOVENDaTh0VkU2eU5FQ0dYNzRFcWNDM3ZnSTl2KzdRTFpSdjdhdmVDdXp6WW9PWnBhaTFPalI4V2NZTmM1ekpna0JaVWt0cXFXWHgwbGhaNVFJMmFWSjV5QnkxVHI0SzJ4T3F4ZHZSd3ZsV21FMmZrMUp2REQzWnhSbk1ySmM1ZElpbXY0RnFMSWpBRytjT0taWXNVbGpKY0JLV1pXMnA1YkVLQW8rNVJZN0RPOUg2Vk9yZWwyK2xyOWhoeWwwR2cvWHk4VXMyaDRLT0NhUEQwSGM3eEdWSnhDd05tQWg0MWVGQWJKRnNCWStGRWJ2SGIvRjhpM0dxNjEzakdsNkdFSXR2aTBOVHNBbTBteEs2M0YyeVhvY0I1Y0FLU0FsN0tDYVlkV3F4d3QvcnQreVFpd2NRZkEwQ3J3ZzZDSWVEQmM2MGNZWWgySVVRWTdrbU9uQ3JSSkpGa2NKdythY2x0dFNUQ2pHcnZUMngrY1Q1Vm5yTnBrZnF4MkFXUkRVV0xkb1JOcmdsYkpMZER2WllsRm1XWGJWeERnbk5haWxjaitWYnpLS2ZBNnZRNmszZzJBaGd2U3plVlNGYWdNeWlMVWxtY1BSZXhMNUI0bTRud0lVZjVMU1F1aitrOG5HK2RiNGk5bWM4dVI2RldWQ0lCVzZnNGZ2QlRWWWJIemR3elpKTXRJd2pMU216ckg4UDVnRXo2MUcwWEw3VjRidlQxUjlzMWtqTWdrSXNEaXdadFVWSW1SVnBGcldrMkR0WTZ5QThXaXgzaUF6RTQvbFd4VXV5UzFyVmtaZzFWeWRpT0FsbGc2WTV3Vi9oeE1FcGxrTU1rYW9NeDZFWGVTWmFxS05tYUwzZDNDY2F2L1ZwN2lDZXZmUHEyRlV4dkJGUmRhT0FCYVBpTFpwUVNMY0VRanhEaVAxS0tWTytvY2VVdWs0NnhEUk8zZU5TdkdOQ2R0SDc4dEgrRnRFd3NoelJWU09CTlFmWktoQmVaUFpGQXVVUzV6T28xNkZGYU10UUpKbDFhb1BUYWg5QXkrVmJuWC85bjRHclN2c0hOM3NjaTFsYXRramd3RUsvb2tmYzBWbUlUc09hK0N4MkhCSWJUNTg3c2xPVUw4ZjUxdm5DT0ZhTnlTempIMkIzMnpITGpTaDQ2T2ZSNGsxMEtZaThZOEIwcWhYeHFrMFlpTWZ6cmE3cTNaWjN1alVlV0RCekRXWlVheGFxUTRuU0dkd1VCb1VYMUdmaDN0QVVZVTNMOEpRb3drSDVGcjIrRXUxTWpsbUdHcTI4Q2RrTTdnbTV5WElwS1pINGtqWTd0QlJSdE96ck1Na3NqVloybzI1MWFMdnZmR1dTdUIrZFdlcTN0Y3NMbk16d3NVN0JpcEQ3ZDFLSWRiSTNKTVJLMllmYjBZTE9wd3FKellWMmgxcXZpTjhhT0dSTjdFOXRuVjQxWE51anJwQ0dNeVUvQ3lPaEozRnBHd3hFb2hKWHQrOXYwWHlyWjQvU0JQS3FES2VqdmxzTzBESldxMGxpNWFZVS9paVVVYXRqb2FwckZqeFFUNHJ6MHJnUzgzczJrbkMrMVhHbkZlNzVqQTJXUWN0Y2FZSy9HaGw1VXE5V1Z4VEx3Y1ZraTR3dHlGZ3M1dFp0bDgreUsvbFdkRFJXWTRPbDBkS0dsSjZFRXR0M3BGZ3NvNG04UThKbk9XYVJ5WFFiTno0My9XL3hmT3ZhTmpQNHJNbkxxTTk4c3R0YXdVbzVVam9DSTcxT0Q3RlNIdjdQekZyZHVDUVg1MXZuM3JjREtyREd2a2V6QUxTa2tYbmNRSWMrR2l2OE5XYXg3ckRGVm92TXBhTXVjWG43elRPU2Iva2JLdUhsQmVqOUxGMjFHZjNTMGZ6ajExWVNWa1d0RG1kVzFCY0dXbUhOUXZsZjI5c2RBbGE3TzI3cHhmdGJGZGV0eWpGcmZMQkF0M0pyU01OZUpOT3NNTnloMUtKNG1XRitHenN0Tm1sdHFWN3Q3dHFDRHZrVzlhTThuNytNYWVBamxaY1MyWGdpOGJLa1hiUkhpbGw0d1JLdE9IbElsT0R5M2h0NjJkVGZUNnpzeC9MQXp4Y1NDeXIyL1I1YjN4MWFiN2t4V3FWMUVRVkxzaVExN3dudlFKdkQxSUVZcGhhMklGdXphbnAzclNpMHJOK0N6ekdpNDBSL0dWWmh0MzdTUGNtUDl4eEV2cFRSOGd4YXk1TEptV0hpTEF6TVlrRU5wcFZaRTFsTkg3akxhS2F2NWg3NUorU21sVnVVdERtWE52bFBxVUk3ZWwyWjdyREVLMW5jT2tobVN2dDhWaUpacGk3TGJaaytlQUhidlBVSEFEdDN4KzZvdEJ6c1JOaUcxeEgwNW1rWGNPZUxpVGtVcmJZWGtrd3FKRzExNmxSdkdLalYraktrSWsvajVSYms2dEZyVzZEeW5YdDNNTDIvYWQ0ZmNwdzk5V1VuSDIrNWtFVkJBbVcyNzhmTlE4bE5WcC9BZTNsdlVVaWF2ei8rdTlkK3F6T3ZzS0Vwdk4zam1xMmZlck43bmsxWFcxV0dEcTJTUk1wc042dWtEdDV6cTdjTXd3NmcrYmJNZDRQZWdhRHpMZlBwTXU0ZGJkVSt2UFBvTW52eUd4YkF6ZWNOR1lLVnZkTlY2dUI5Q1lxMHdMUEZOaDAwWklNL0VmQ29EZGRsYjEvQzVkNlZwUDdCK1hucWpnZUtLMUF1dlZuTGgyRFNyZDVhOHhBeDY5cnc4R1JGeTlKcXVSdXVLSXZwNXZpcGh6MWRkenpxdC84WUFWTjJkUGFhdlR6L1dVemVWdHV5QVJmaEZtZVNBVTNadzZ4b3hCTnltbE50THFtMElsOE5wWlg5YjkzTTlyL3RyT2U4MTUrR0NIVlp6ZGJUcjhES3dKV0wwb3RXZ2RSZDlnYWx4R2lKVkFKNEVnWXBFUGEzeVZqenZOZlpXY3RXZVBhL2ovKzhadk9YTDNvV0lQU2x1VFRYbzFvUnM1S1RROG90RFZYZEttRWY4ZGVlVGRmNnJyQ1dMdjMxYzdiNUtscVpYOWo4NDMyMURQZkFQS2Q2TmF0R1Rxc3ZBVHlkaEZEV2Fwd0t4RWY0WnZidjBiNUpkemJickwrUVZraTZjanE1dithekJLNUFNcklJa2lYcThhRXljRTFlMXh2OXJGK25reStIeXB3MUNpNFUvUEhXc0V4clZqekRkM0NKWmY0RXFFd2xMTEpza21XSlczMWZWb3lHWFRKSzMwV3NXWFVxS2lYTVdqNE5xdi9MQTlvVnRGNTdMNXMzaEhFWW1SdHF1UFFsSHJ2d29La2xhbFYvU3RiL1pxak15YWl2cHRhbGJLUmJDSEdwZ3lEeG4yaHhDUnJrTkZMQ2tHcnh0ME5scXZGanF2R1NPcFp4OFF4Q3kyK1YrbXRpVUkzS3FnT0NMU0ExeWI0RFVnU3ZyYllTTmJwc1dDWXllQ0NVOGxPYVc4Q3B0K2szUXNyaHBXOUFBMkNXWExXZ3VYSnRMN0lLVzRNQTFFNXhhdkhkb1BLR1JoRnNwUkFEV2trTVYrMFdRK0Q4ZzV2QTZsOTduMzVYb0pDam1iN3JTL1k1WU1ZYVJHQ1R2cFkvemI0NVVLUW1nV1E3aFJsNWRqOHdYYVBaUXIvUFFlR1RMZlFMSG41QStYbCtucC9uNTNuQzh4L3RBTWxqV2tlQm5BQUFBQUJKUlU1RXJrSmdnZz09YDtcblxuY29uc3QgcmVzb2x2ZVdhbGxldFVybCA9IChuZXR3b3JrLCB3YWxsZXRVcmwpID0+IHtcbiAgaWYgKHdhbGxldFVybCkge1xuICAgIHJldHVybiB3YWxsZXRVcmw7XG4gIH1cbiAgc3dpdGNoIChuZXR3b3JrLm5ldHdvcmtJZCkge1xuICAgIGNhc2UgXCJtYWlubmV0XCI6XG4gICAgICByZXR1cm4gXCJodHRwczovL2FwcC5teW5lYXJ3YWxsZXQuY29tXCI7XG4gICAgY2FzZSBcInRlc3RuZXRcIjpcbiAgICAgIHJldHVybiBcImh0dHBzOi8vdGVzdG5ldC5teW5lYXJ3YWxsZXQuY29tXCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgd2FsbGV0IHVybFwiKTtcbiAgfVxufTtcbmNvbnN0IHNldHVwV2FsbGV0U3RhdGUgPSAocGFyYW1zLCBuZXR3b3JrKSA9PiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgY29uc3Qga2V5U3RvcmUgPSBuZXcgbmVhckFQSS5rZXlTdG9yZXMuQnJvd3NlckxvY2FsU3RvcmFnZUtleVN0b3JlKCk7XG4gIGNvbnN0IG5lYXIgPSB5aWVsZCBuZWFyQVBJLmNvbm5lY3QoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHtcbiAgICBrZXlTdG9yZSxcbiAgICB3YWxsZXRVcmw6IHBhcmFtcy53YWxsZXRVcmxcbiAgfSwgbmV0d29yayksIHtcbiAgICBoZWFkZXJzOiB7fVxuICB9KSk7XG4gIGNvbnN0IHdhbGxldCA9IG5ldyBuZWFyQVBJLldhbGxldENvbm5lY3Rpb24obmVhciwgXCJuZWFyX2FwcFwiKTtcbiAgcmV0dXJuIHtcbiAgICB3YWxsZXQsXG4gICAga2V5U3RvcmVcbiAgfTtcbn0pO1xuY29uc3QgTXlOZWFyV2FsbGV0ID0gKHtcbiAgbWV0YWRhdGEsXG4gIG9wdGlvbnMsXG4gIHN0b3JlLFxuICBwYXJhbXMsXG4gIGxvZ2dlcixcbiAgaWRcbn0pID0+IF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICBjb25zdCBfc3RhdGUgPSB5aWVsZCBzZXR1cFdhbGxldFN0YXRlKHBhcmFtcywgb3B0aW9ucy5uZXR3b3JrKTtcbiAgY29uc3QgZ2V0QWNjb3VudHMgPSAoKSA9PiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICBjb25zdCBhY2NvdW50SWQgPSBfc3RhdGUud2FsbGV0LmdldEFjY291bnRJZCgpO1xuICAgIGNvbnN0IGFjY291bnQgPSBfc3RhdGUud2FsbGV0LmFjY291bnQoKTtcbiAgICBpZiAoIWFjY291bnRJZCB8fCAhYWNjb3VudCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCBwdWJsaWNLZXkgPSB5aWVsZCBhY2NvdW50LmNvbm5lY3Rpb24uc2lnbmVyLmdldFB1YmxpY0tleShhY2NvdW50LmFjY291bnRJZCwgb3B0aW9ucy5uZXR3b3JrLm5ldHdvcmtJZCk7XG4gICAgcmV0dXJuIFt7XG4gICAgICBhY2NvdW50SWQsXG4gICAgICBwdWJsaWNLZXk6IHB1YmxpY0tleSA/IHB1YmxpY0tleS50b1N0cmluZygpIDogXCJcIlxuICAgIH1dO1xuICB9KTtcbiAgY29uc3QgdHJhbnNmb3JtVHJhbnNhY3Rpb25zID0gdHJhbnNhY3Rpb25zID0+IF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgIGNvbnN0IGFjY291bnQgPSBfc3RhdGUud2FsbGV0LmFjY291bnQoKTtcbiAgICBjb25zdCB7XG4gICAgICBuZXR3b3JrSWQsXG4gICAgICBzaWduZXIsXG4gICAgICBwcm92aWRlclxuICAgIH0gPSBhY2NvdW50LmNvbm5lY3Rpb247XG4gICAgY29uc3QgbG9jYWxLZXkgPSB5aWVsZCBzaWduZXIuZ2V0UHVibGljS2V5KGFjY291bnQuYWNjb3VudElkLCBuZXR3b3JrSWQpO1xuICAgIHJldHVybiBQcm9taXNlLmFsbCh0cmFuc2FjdGlvbnMubWFwKCh0cmFuc2FjdGlvbiwgaW5kZXgpID0+IF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgYWN0aW9ucyA9IHRyYW5zYWN0aW9uLmFjdGlvbnMubWFwKGFjdGlvbiA9PiBjcmVhdGVBY3Rpb24oYWN0aW9uKSk7XG4gICAgICBjb25zdCBhY2Nlc3NLZXkgPSB5aWVsZCBhY2NvdW50LmFjY2Vzc0tleUZvclRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLnJlY2VpdmVySWQsIGFjdGlvbnMsIGxvY2FsS2V5KTtcbiAgICAgIGlmICghYWNjZXNzS2V5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZpbmQgbWF0Y2hpbmcga2V5IGZvciB0cmFuc2FjdGlvbiBzZW50IHRvICR7dHJhbnNhY3Rpb24ucmVjZWl2ZXJJZH1gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJsb2NrID0geWllbGQgcHJvdmlkZXIuYmxvY2soe1xuICAgICAgICBmaW5hbGl0eTogXCJmaW5hbFwiXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuZWFyQVBJLnRyYW5zYWN0aW9ucy5jcmVhdGVUcmFuc2FjdGlvbihhY2NvdW50LmFjY291bnRJZCwgbmVhckFQSS51dGlscy5QdWJsaWNLZXkuZnJvbShhY2Nlc3NLZXkucHVibGljX2tleSksIHRyYW5zYWN0aW9uLnJlY2VpdmVySWQsIGFjY2Vzc0tleS5hY2Nlc3Nfa2V5Lm5vbmNlICsgaW5kZXggKyAxLCBhY3Rpb25zLCBuZWFyQVBJLnV0aWxzLnNlcmlhbGl6ZS5iYXNlX2RlY29kZShibG9jay5oZWFkZXIuaGFzaCkpO1xuICAgIH0pKSk7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHNpZ25Jbih7XG4gICAgICBjb250cmFjdElkLFxuICAgICAgbWV0aG9kTmFtZXMsXG4gICAgICBzdWNjZXNzVXJsLFxuICAgICAgZmFpbHVyZVVybFxuICAgIH0pIHtcbiAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nQWNjb3VudHMgPSB5aWVsZCBnZXRBY2NvdW50cygpO1xuICAgICAgICBpZiAoZXhpc3RpbmdBY2NvdW50cy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gZXhpc3RpbmdBY2NvdW50cztcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCBfc3RhdGUud2FsbGV0LnJlcXVlc3RTaWduSW4oe1xuICAgICAgICAgIGNvbnRyYWN0SWQsXG4gICAgICAgICAgbWV0aG9kTmFtZXMsXG4gICAgICAgICAgc3VjY2Vzc1VybCxcbiAgICAgICAgICBmYWlsdXJlVXJsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZ2V0QWNjb3VudHMoKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgc2lnbk91dCgpIHtcbiAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGlmIChfc3RhdGUud2FsbGV0LmlzU2lnbmVkSW4oKSkge1xuICAgICAgICAgIF9zdGF0ZS53YWxsZXQuc2lnbk91dCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGdldEFjY291bnRzKCkge1xuICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgcmV0dXJuIGdldEFjY291bnRzKCk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHZlcmlmeU93bmVyKCkge1xuICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNZXRob2Qgbm90IHN1cHBvcnRlZCBieSAke21ldGFkYXRhLm5hbWV9YCk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHNpZ25NZXNzYWdlKHtcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBub25jZSxcbiAgICAgIHJlY2lwaWVudCxcbiAgICAgIGNhbGxiYWNrVXJsLFxuICAgICAgc3RhdGVcbiAgICB9KSB7XG4gICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBsb2dnZXIubG9nKFwic2lnbiBtZXNzYWdlXCIsIHtcbiAgICAgICAgICBtZXNzYWdlXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaWQgIT09IFwibXktbmVhci13YWxsZXRcIikge1xuICAgICAgICAgIHRocm93IEVycm9yKGBUaGUgc2lnbk1lc3NhZ2UgbWV0aG9kIGlzIG5vdCBzdXBwb3J0ZWQgYnkgJHttZXRhZGF0YS5uYW1lfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxvY2F0aW9uVXJsID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5sb2NhdGlvbi5ocmVmIDogXCJcIjtcbiAgICAgICAgY29uc3QgdXJsID0gY2FsbGJhY2tVcmwgfHwgbG9jYXRpb25Vcmw7XG4gICAgICAgIGlmICghdXJsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgY2FsbGJhY2tVcmwgaXMgbWlzc2luZyBmb3IgJHttZXRhZGF0YS5uYW1lfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhyZWYgPSBuZXcgVVJMKHBhcmFtcy53YWxsZXRVcmwpO1xuICAgICAgICBocmVmLnBhdGhuYW1lID0gXCJzaWduLW1lc3NhZ2VcIjtcbiAgICAgICAgaHJlZi5zZWFyY2hQYXJhbXMuYXBwZW5kKFwibWVzc2FnZVwiLCBtZXNzYWdlKTtcbiAgICAgICAgaHJlZi5zZWFyY2hQYXJhbXMuYXBwZW5kKFwibm9uY2VcIiwgbm9uY2UudG9TdHJpbmcoXCJiYXNlNjRcIikpO1xuICAgICAgICBocmVmLnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJyZWNpcGllbnRcIiwgcmVjaXBpZW50KTtcbiAgICAgICAgaHJlZi5zZWFyY2hQYXJhbXMuYXBwZW5kKFwiY2FsbGJhY2tVcmxcIiwgdXJsKTtcbiAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgaHJlZi5zZWFyY2hQYXJhbXMuYXBwZW5kKFwic3RhdGVcIiwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKGhyZWYudG9TdHJpbmcoKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgc2lnbkFuZFNlbmRUcmFuc2FjdGlvbih7XG4gICAgICBzaWduZXJJZCxcbiAgICAgIHJlY2VpdmVySWQsXG4gICAgICBhY3Rpb25zLFxuICAgICAgY2FsbGJhY2tVcmxcbiAgICB9KSB7XG4gICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBsb2dnZXIubG9nKFwic2lnbkFuZFNlbmRUcmFuc2FjdGlvblwiLCB7XG4gICAgICAgICAgc2lnbmVySWQsXG4gICAgICAgICAgcmVjZWl2ZXJJZCxcbiAgICAgICAgICBhY3Rpb25zLFxuICAgICAgICAgIGNhbGxiYWNrVXJsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgY29udHJhY3RcbiAgICAgICAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIGlmICghX3N0YXRlLndhbGxldC5pc1NpZ25lZEluKCkgfHwgIWNvbnRyYWN0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2FsbGV0IG5vdCBzaWduZWQgaW5cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWNjb3VudCA9IF9zdGF0ZS53YWxsZXQuYWNjb3VudCgpO1xuICAgICAgICByZXR1cm4gYWNjb3VudFtcInNpZ25BbmRTZW5kVHJhbnNhY3Rpb25cIl0oe1xuICAgICAgICAgIHJlY2VpdmVySWQ6IHJlY2VpdmVySWQgfHwgY29udHJhY3QuY29udHJhY3RJZCxcbiAgICAgICAgICBhY3Rpb25zOiBhY3Rpb25zLm1hcChhY3Rpb24gPT4gY3JlYXRlQWN0aW9uKGFjdGlvbikpLFxuICAgICAgICAgIHdhbGxldENhbGxiYWNrVXJsOiBjYWxsYmFja1VybFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgc2lnbkFuZFNlbmRUcmFuc2FjdGlvbnMoe1xuICAgICAgdHJhbnNhY3Rpb25zLFxuICAgICAgY2FsbGJhY2tVcmxcbiAgICB9KSB7XG4gICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBsb2dnZXIubG9nKFwic2lnbkFuZFNlbmRUcmFuc2FjdGlvbnNcIiwge1xuICAgICAgICAgIHRyYW5zYWN0aW9ucyxcbiAgICAgICAgICBjYWxsYmFja1VybFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFfc3RhdGUud2FsbGV0LmlzU2lnbmVkSW4oKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldhbGxldCBub3Qgc2lnbmVkIGluXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfc3RhdGUud2FsbGV0LnJlcXVlc3RTaWduVHJhbnNhY3Rpb25zKHtcbiAgICAgICAgICB0cmFuc2FjdGlvbnM6IHlpZWxkIHRyYW5zZm9ybVRyYW5zYWN0aW9ucyh0cmFuc2FjdGlvbnMpLFxuICAgICAgICAgIGNhbGxiYWNrVXJsXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBidWlsZEltcG9ydEFjY291bnRzVXJsKCkge1xuICAgICAgcmV0dXJuIGAke3BhcmFtcy53YWxsZXRVcmx9L2JhdGNoLWltcG9ydGA7XG4gICAgfVxuICB9O1xufSk7XG5mdW5jdGlvbiBzZXR1cE15TmVhcldhbGxldCh7XG4gIHdhbGxldFVybCxcbiAgaWNvblVybCA9IGljb24sXG4gIGRlcHJlY2F0ZWQgPSBmYWxzZSxcbiAgc3VjY2Vzc1VybCA9IFwiXCIsXG4gIGZhaWx1cmVVcmwgPSBcIlwiXG59ID0ge30pIHtcbiAgcmV0dXJuIG1vZHVsZU9wdGlvbnMgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgIHJldHVybiB7XG4gICAgICBpZDogXCJteS1uZWFyLXdhbGxldFwiLFxuICAgICAgdHlwZTogXCJicm93c2VyXCIsXG4gICAgICBtZXRhZGF0YToge1xuICAgICAgICBuYW1lOiBcIk15TmVhcldhbGxldFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJORUFSIHdhbGxldCB0byBzdG9yZSwgYnV5LCBzZW5kIGFuZCBzdGFrZSBhc3NldHMgZm9yIERlRmkuXCIsXG4gICAgICAgIGljb25VcmwsXG4gICAgICAgIGRlcHJlY2F0ZWQsXG4gICAgICAgIGF2YWlsYWJsZTogdHJ1ZSxcbiAgICAgICAgc3VjY2Vzc1VybCxcbiAgICAgICAgZmFpbHVyZVVybCxcbiAgICAgICAgd2FsbGV0VXJsOiByZXNvbHZlV2FsbGV0VXJsKG1vZHVsZU9wdGlvbnMub3B0aW9ucy5uZXR3b3JrLCB3YWxsZXRVcmwpXG4gICAgICB9LFxuICAgICAgaW5pdDogb3B0aW9ucyA9PiB7XG4gICAgICAgIHJldHVybiBNeU5lYXJXYWxsZXQoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwge1xuICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgd2FsbGV0VXJsOiByZXNvbHZlV2FsbGV0VXJsKG9wdGlvbnMub3B0aW9ucy5uZXR3b3JrLCB3YWxsZXRVcmwpXG4gICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG59XG5cbmV4cG9ydCB7IHNldHVwTXlOZWFyV2FsbGV0IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@near-wallet-selector/my-near-wallet/index.js\n");

/***/ })

};
;